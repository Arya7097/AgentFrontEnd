"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/app/pages/Upload/Upload.tsx":
/*!*****************************************!*\
  !*** ./src/app/pages/Upload/Upload.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Dashboard)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! styled-jsx/style */ \"(app-pages-browser)/./node_modules/styled-jsx/style.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-chartjs-2 */ \"(app-pages-browser)/./node_modules/react-chartjs-2/dist/index.js\");\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! chart.js */ \"(app-pages-browser)/./node_modules/chart.js/dist/chart.js\");\n/* harmony import */ var _barrel_optimize_names_BsUpload_react_icons_bs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=BsUpload!=!react-icons/bs */ \"(app-pages-browser)/./node_modules/react-icons/bs/index.mjs\");\n/* harmony import */ var chartjs_plugin_zoom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! chartjs-plugin-zoom */ \"(app-pages-browser)/./node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js\");\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n// } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// ChartJS.register(\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n//   zoomPlugin\n// );\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string;\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[];\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const [selectedLabels, setSelectedLabels] = useState<string[]>([]);\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: chartType.includes(\"Bar\")\n//                 ? \"rgba(54, 162, 235, 0.5)\"\n//                 : \"rgba(255, 99, 132, 0.5)\",\n//               borderColor: chartType.includes(\"Line\")\n//                 ? \"rgba(255, 99, 132, 1)\"\n//                 : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   useEffect(() => {\n//     if (selectedChart && chartData[selectedChart]) {\n//       const baseLabels = chartData[selectedChart]?.labels || [];\n//       setChartWidth((selectedLabels.length || baseLabels.length) * 150);\n//     }\n//   }, [selectedChart, selectedLabels, chartData]);\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//           x: {\n//             ticks: {\n//               autoSkip: false,\n//               maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//               minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//               autoSkipPadding: 20,\n//             },\n//             grid: {\n//               display: true,\n//               drawTicks: false,\n//               tickLength: 100,\n//               lineWidth: 1\n//             },\n//           },\n//           y: {\n//             beginAtZero: true,\n//             ticks: {\n//               precision: 0,\n//             },\n//           },\n//         },\n//     plugins: {\n//       legend: {\n//         display: true,\n//         position: \"top\",\n//       },\n//       tooltip: {\n//         enabled: true,\n//       },\n//     },\n//   });\n//   const applyFilter = (data: ChartData | null) => {\n//     if (!data) return data;\n//     const filteredLabels = selectedLabels.length\n//       ? data.labels.filter(label => selectedLabels.includes(label))\n//       : data.labels;\n//     const filteredData = data.datasets.map(dataset => ({\n//       ...dataset,\n//       data: filteredLabels.map(label => dataset.data[data.labels.indexOf(label)])\n//     }));\n//     return {\n//       labels: filteredLabels,\n//       datasets: filteredData,\n//     };\n//   };\n//   const handleCheckboxChange = (label: string) => {\n//     setSelectedLabels(prev =>\n//       prev.includes(label)\n//         ? prev.filter(item => item !== label)\n//         : [...prev, label]\n//     );\n//   };\n//   const handleSelectAll = () => {\n//     if (selectedChart && chartData[selectedChart]) {\n//       setSelectedLabels(chartData[selectedChart]?.labels || []);\n//     }\n//   };\n//   const handleClearAll = () => {\n//     setSelectedLabels([]);\n//   };\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = applyFilter(chartData[type]);\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div\n//               style={{\n//                 minWidth: [\"lineChartData\", \"barChartData\"].includes(type)\n//                   ? `${chartWidth}px`\n//                   : \"auto\",\n//                 height: \"400px\",\n//               }}\n//             >\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button\n//           onClick={handleSubmit}\n//           className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\"\n//         >\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         {selectedChart && (\n//           <div className=\"mt-4\">\n//             <h3 className=\"font-semibold\">Filters</h3>\n//             <button onClick={handleSelectAll} className=\"bg-green-500 text-white px-2 py-1 rounded mt-2\">Select All</button>\n//             <button onClick={handleClearAll} className=\"bg-red-500 text-white px-2 py-1 rounded mt-2 ml-2\">Clear All</button>\n//             {chartData[selectedChart]?.labels.map(label => (\n//               <div key={label} className=\"flex items-center\">\n//                 <input\n//                   type=\"checkbox\"\n//                   checked={selectedLabels.includes(label)}\n//                   onChange={() => handleCheckboxChange(label)}\n//                 />\n//                 <label className=\"ml-2\">{label}</label>\n//               </div>\n//             ))}\n//           </div>\n//         )}\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map(\n//             (type) => (\n//               <button\n//                 key={type}\n//                 onClick={() => {\n//                   setSelectedChart(type);\n//                   setSelectedLabels([]);\n//                 }}\n//                 className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\"\n//               >\n//                 {type.replace(\"ChartData\", \" Chart\")}\n//               </button>\n//             )\n//           )}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           renderChart(selectedChart, {\n//             lineChartData: Line,\n//             barChartData: Bar,\n//             scatterChartData: Scatter,\n//             pieChartData: Pie,\n//             donutChartData: Doughnut,\n//           }[selectedChart])\n//         )}\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n// } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// import { log } from \"node:console\";\n// ChartJS.register(\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n//   zoomPlugin\n// );\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string;\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[];\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n// console.log(\"processedData\",processedData);\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//  console.log(\"labels.length \",chartType,labels.length );\n//  console.log(\"values.length \",chartType,values.length );\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: chartType.includes(\"Bar\")\n//                 ? \"rgba(54, 162, 235, 0.5)\"\n//                 : \"rgba(255, 99, 132, 0.5)\",\n//               borderColor: chartType.includes(\"Line\")\n//                 ? \"rgba(255, 99, 132, 1)\"\n//                 : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//         };\n//       };\n// console.log(\"generateChartData\",generateChartData);\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//         x: {\n//           ticks: {\n//             autoSkip: false,\n//             maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//         minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//             autoSkipPadding: 20,\n//           },\n//           grid: {\n//             display: true,\n//             drawTicks: false,\n//             tickLength: 100,\n//             lineWidth: 1\n//           },\n//         },\n//           y: {\n//             beginAtZero: true,\n//             ticks: {\n//               precision: 0,\n//             },\n//           },\n//         },\n//     plugins: {\n//       legend: {\n//         display: true,\n//         position: \"top\",\n//       },\n//       tooltip: {\n//         enabled: true,\n//       },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div\n//               style={{\n//                 minWidth: [\"lineChartData\", \"barChartData\"].includes(type)\n//                   ? `${chartWidth}px`\n//                   : \"auto\",\n//                 height: \"400px\",\n//               }}\n//             >\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button\n//           onClick={handleSubmit}\n//           className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\"\n//         >\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map(\n//             (type) => (\n//               <button\n//                 key={type}\n//                 onClick={() => setSelectedChart(type)}\n//                 className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\"\n//               >\n//                 {type.replace(\"ChartData\", \" Chart\")}\n//               </button>\n//             )\n//           )}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           renderChart(selectedChart, {\n//             lineChartData: Line,\n//             barChartData: Bar,\n//             scatterChartData: Scatter,\n//             pieChartData: Pie,\n//             donutChartData: Doughnut,\n//           }[selectedChart])\n//         )}\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n// } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// import { log } from \"node:console\";\n// ChartJS.register(\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n//   zoomPlugin\n// );\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string | string[];\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[];\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       const lightColors = [\n//         \"rgba(173, 216, 230, 0.6)\",\n//         \"rgba(144, 238, 144, 0.6)\",\n//         \"rgba(255, 182, 193, 0.6)\",\n//         \"rgba(255, 228, 181, 0.6)\",\n//         \"rgba(221, 160, 221, 0.6)\",\n//         \"rgba(240, 230, 140, 0.6)\",\n//       ];\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? lightColors.slice(0, labels.length)\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\")\n//                 ? \"rgba(135, 206, 250, 1)\"\n//                 : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n// x: {\n//   ticks: {\n//     autoSkip: false,\n//     maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n// minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//     autoSkipPadding: 20,\n//   },\n//   grid: {\n//     display: true,\n//     drawTicks: false,\n//     tickLength: 100,\n//     lineWidth: 1\n//   },\n// },\n//           y: {\n//             beginAtZero: true,\n//             ticks: {\n//               precision: 0,\n//             },\n//           },\n//         },\n//     plugins: {\n//       legend: {\n//         display: true,\n//         position: \"top\",\n//       },\n//       tooltip: {\n//         enabled: true,\n//       },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div\n//               style={{\n//                 minWidth: [\"lineChartData\", \"barChartData\"].includes(type)\n//                   ? `${chartWidth}px`\n//                   : \"auto\",\n//                 height: \"400px\",\n//               }}\n//             >\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button\n//           onClick={handleSubmit}\n//           className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\"\n//         >\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map(\n//             (type) => (\n//               <button\n//                 key={type}\n//                 onClick={() => setSelectedChart(type)}\n//                 className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\"\n//               >\n//                 {type.replace(\"ChartData\", \" Chart\")}\n//               </button>\n//             )\n//           )}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           renderChart(selectedChart, {\n//             lineChartData: Line,\n//             barChartData: Bar,\n//             scatterChartData: Scatter,\n//             pieChartData: Pie,\n//             donutChartData: Doughnut,\n//           }[selectedChart])\n//         )}\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n// } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// ChartJS.register(\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n//   zoomPlugin\n// );\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string | string[];\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[];\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const [inputValue, setInputValue] = useState<string>(\"\");\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       const lightColors = [\n//         \"rgba(173, 216, 230, 0.6)\",\n//         \"rgba(144, 238, 144, 0.6)\",\n//         \"rgba(255, 182, 193, 0.6)\",\n//         \"rgba(255, 228, 181, 0.6)\",\n//         \"rgba(221, 160, 221, 0.6)\",\n//         \"rgba(240, 230, 140, 0.6)\",\n//       ];\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? lightColors.slice(0, labels.length)\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\")\n//                 ? \"rgba(135, 206, 250, 1)\"\n//                 : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const handleSend = () => {\n//     console.log(\"Input Value:\", inputValue);\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//         x: {\n//           ticks: {\n//             autoSkip: false,\n//             maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//         minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//             autoSkipPadding: 20,\n//           },\n//           grid: {\n//             display: true,\n//             drawTicks: false,\n//             tickLength: 100,\n//             lineWidth: 1\n//           },\n//         },\n//           y: {\n//             beginAtZero: true,\n//             ticks: {\n//               precision: 0,\n//             },\n//           },\n//         },\n//     plugins: {\n//       legend: {\n//         display: true,\n//         position: \"top\",\n//       },\n//       tooltip: {\n//         enabled: true,\n//       },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div\n//               style={{\n//                 minWidth: [\"lineChartData\", \"barChartData\"].includes(type)\n//                   ? `${chartWidth}px`\n//                   : \"auto\",\n//                 height: \"400px\",\n//               }}\n//             >\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button\n//           onClick={handleSubmit}\n//           className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\"\n//         >\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map(\n//             (type) => (\n//               <button\n//                 key={type}\n//                 onClick={() => setSelectedChart(type)}\n//                 className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\"\n//               >\n//                 {type.replace(\"ChartData\", \" Chart\")}\n//               </button>\n//             )\n//           )}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           renderChart(selectedChart, {\n//             lineChartData: Line,\n//             barChartData: Bar,\n//             scatterChartData: Scatter,\n//             pieChartData: Pie,\n//             donutChartData: Doughnut,\n//           }[selectedChart])\n//         )}\n//         <div className=\"mt-4 flex\">\n//           <input\n//             type=\"text\"\n//             value={inputValue}\n//             onChange={(e) => setInputValue(e.target.value)}\n//             className=\"border p-2 flex-grow mr-2 rounded\"\n//             placeholder=\"Enter your text here\"\n//           />\n//           <button\n//             onClick={handleSend}\n//             className=\"bg-green-500 text-white p-2 rounded\"\n//           >\n//             Send\n//           </button>\n//         </div>\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import { Chart as ChartJS, CategoryScale, LinearScale, BarElement, LineElement, PointElement, ArcElement, Title, Tooltip, Legend } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// ChartJS.register(CategoryScale, LinearScale, BarElement, LineElement, PointElement, ArcElement, Title, Tooltip, Legend, zoomPlugin);\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string | string[];\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[]\n//   meta?: {\n//     header: string;\n//     valueName: string;\n//   };\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const [inputValue, setInputValue] = useState<string>(\"\");\n//   const [storedProcessedData, setStoredProcessedData] = useState<any>(null); // New state to store processed data\n//   const [combinedInsights, setCombinedInsights] = useState<any>(null);\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const combinedInsights = result.data?.combinedInsights;\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n// console.log(\"processedData\",processedData);\n//       setStoredProcessedData(processedData); // Store the processed data\n//       setCombinedInsights(combinedInsights);\n//       const lightColors = [\n//         \"rgba(173, 216, 230, 0.6)\",\n//         \"rgba(144, 238, 144, 0.6)\",\n//         \"rgba(255, 182, 193, 0.6)\",\n//         \"rgba(255, 228, 181, 0.6)\",\n//         \"rgba(221, 160, 221, 0.6)\",\n//         \"rgba(240, 230, 140, 0.6)\",\n//       ];\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? lightColors.slice(0, labels.length)\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//           meta: {\n//             header: chartInfo.header || \"default_header\",\n//             valueName: chartInfo.valueName || \"default_valueName\",\n//           },\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const handleSend = async () => {\n//     if (!inputValue) return;\n//     const graphData = chartData[selectedChart];\n//     if (!graphData) return;\n//     const labels = graphData.labels;\n//     const values = graphData.datasets[0].data;\n//     const dataObject = labels.reduce((obj: { [key: string]: number }, label, index) => {\n//       obj[label] = values[index];\n//       return obj;\n//     }, {});\n//     const chartTypeMapping: Record<string, string> = {\n//       lineChartData: \"Line Chart\",\n//       pieChartData: \"Pie Chart\",\n//       donutChartData: \"Donut Chart\",\n//       barChartData: \"Bar Chart\",\n//       scatterChartData: \"Scatter Plot\",\n//     };\n//     const selectedChartType = chartTypeMapping[selectedChart] || selectedChart;\n//     // Filter the stored processed data to include only the selected chart's data\n//     const filteredProcessedData = {\n//       [selectedChartType]: storedProcessedData[selectedChartType],\n//     };\n//     console.log(\"...filteredProcessedData,\", filteredProcessedData[selectedChartType]?.[0]?.data);\n//     console.log(\"dataObject,\", dataObject);\n//     const requestBody = {\n//       question: inputValue,\n//       processedData: {\n//         // Include the stored processed data\n//         [selectedChartType]: [\n//           {\n//             header: graphData.meta?.header || \"default_header\",\n//             valueName: graphData.meta?.valueName || \"default_valueName\",\n//             label: graphData.datasets[0].label,\n//             data: filteredProcessedData[selectedChartType]?.[0]?.data,\n//           },\n//         ],\n//       },\n//     };\n//     try {\n//       const response = await fetch(\n//         `http://localhost:3012/api/answer-analyze-excel?question=${encodeURIComponent(inputValue)}`,\n//         {\n//           method: \"POST\",\n//           headers: { \"Content-Type\": \"application/json\" },\n//           body: JSON.stringify(requestBody),\n//         }\n//       );\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       console.log(\"Updated API Response Data:\", processedData);\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0]; // Use only API response data\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? [\"rgba(173, 216, 230, 0.6)\", \"rgba(144, 238, 144, 0.6)\", \"rgba(255, 182, 193, 0.6)\"]\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//           meta: {\n//             header: chartInfo.header || \"default_header\",\n//             valueName: chartInfo.valueName || \"default_valueName\",\n//           },\n//         };\n//       };\n//       // Only update chartData without storing in storedProcessedData\n//       setChartData((prevChartData) => ({\n//         ...prevChartData,\n//         [selectedChart]: generateChartData(selectedChartType),\n//       }));\n//     } catch (error) {\n//       console.error(\"Error sending request:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//         x: {\n//           ticks: {\n//             autoSkip: false,\n//             maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//         minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//             autoSkipPadding: 20,\n//           },\n//           grid: {\n//             display: true,\n//             drawTicks: false,\n//             tickLength: 100,\n//             lineWidth: 1\n//           },\n//         },\n//         y: {\n//           beginAtZero: true,\n//           ticks: { precision: 0 },\n//         },\n//       },\n//     plugins: {\n//       legend: { display: true, position: \"top\" },\n//       tooltip: { enabled: true },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div style={{ minWidth: [\"lineChartData\", \"barChartData\"].includes(type) ? `${chartWidth}px` : \"auto\", height: \"400px\" }}>\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button onClick={handleSubmit} className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\">\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map((type) => (\n//             <button key={type} onClick={() => setSelectedChart(type)} className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\">\n//               {type.replace(\"ChartData\", \" Chart\")}\n//             </button>\n//           ))}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           selectedChart && renderChart(selectedChart, { lineChartData: Line, barChartData: Bar, scatterChartData: Scatter, pieChartData: Pie, donutChartData: Doughnut }[selectedChart])\n//         )}\n//         <div className=\"mt-4 flex\">\n//           <input\n//             type=\"text\"\n//             value={inputValue}\n//             onChange={(e) => setInputValue(e.target.value)}\n//             className=\"border p-2 flex-grow mr-2 rounded\"\n//             placeholder=\"Enter your text here\"\n//           />\n//           <button onClick={handleSend} className=\"bg-green-500 text-white p-2 rounded\">\n//             Send\n//           </button>\n//         </div>\n//         <div className=\"mt-4 p-4 border border-gray-300 rounded bg-white\">\n//         <h3 className=\"text-lg font-bold mb-2\">Insights</h3>\n//         {combinedInsights ? (\n//             <ol className=\"list-decimal list-inside text-sm text-gray-700 bg-gray-100 p-2 rounded overflow-auto\">\n//             {combinedInsights.split('\\n').map((insight, index) => (\n//               <ul key={index}>{insight}</ul>\n//             ))}\n//           </ol>\n//         ) : (\n//           <p className=\"text-gray-500\">No insights available.</p>\n//         )}\n//       </div>\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect, useRef } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import { Chart as ChartJS, CategoryScale, LinearScale, BarElement, LineElement, PointElement, ArcElement, Title, Tooltip, Legend } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// import html2canvas from \"html2canvas\";\n// import jsPDF from \"jspdf\";\n// ChartJS.register(CategoryScale, LinearScale, BarElement, LineElement, PointElement, ArcElement, Title, Tooltip, Legend, zoomPlugin);\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string | string[];\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[]\n//   meta?: {\n//     header: string;\n//     valueName: string;\n//   };\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const [inputValue, setInputValue] = useState<string>(\"\");\n//   const [storedProcessedData, setStoredProcessedData] = useState<any>(null); // New state to store processed data\n//   const [combinedInsights, setCombinedInsights] = useState<any>(null);\n//   const chartRef = useRef<HTMLDivElement>(null); // Ref for the chart container\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const combinedInsights = result.data?.combinedInsights;\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n// console.log(\"processedData\",processedData);\n//       setStoredProcessedData(processedData); // Store the processed data\n//       setCombinedInsights(combinedInsights);\n//       const lightColors = [\n//         \"rgba(173, 216, 230, 0.6)\",\n//         \"rgba(144, 238, 144, 0.6)\",\n//         \"rgba(255, 182, 193, 0.6)\",\n//         \"rgba(255, 228, 181, 0.6)\",\n//         \"rgba(221, 160, 221, 0.6)\",\n//         \"rgba(240, 230, 140, 0.6)\",\n//       ];\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? lightColors.slice(0, labels.length)\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//           meta: {\n//             header: chartInfo.header || \"default_header\",\n//             valueName: chartInfo.valueName || \"default_valueName\",\n//           },\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const handleSend = async () => {\n//     if (!inputValue) return;\n//     const graphData = chartData[selectedChart];\n//     if (!graphData) return;\n//     const labels = graphData.labels;\n//     const values = graphData.datasets[0].data;\n//     const dataObject = labels.reduce((obj: { [key: string]: number }, label, index) => {\n//       obj[label] = values[index];\n//       return obj;\n//     }, {});\n//     const chartTypeMapping: Record<string, string> = {\n//       lineChartData: \"Line Chart\",\n//       pieChartData: \"Pie Chart\",\n//       donutChartData: \"Donut Chart\",\n//       barChartData: \"Bar Chart\",\n//       scatterChartData: \"Scatter Plot\",\n//     };\n//     const selectedChartType = chartTypeMapping[selectedChart] || selectedChart;\n//     // Filter the stored processed data to include only the selected chart's data\n//     const filteredProcessedData = {\n//       [selectedChartType]: storedProcessedData[selectedChartType],\n//     };\n//     console.log(\"...filteredProcessedData,\", filteredProcessedData[selectedChartType]?.[0]?.data);\n//     console.log(\"dataObject,\", dataObject);\n//     const requestBody = {\n//       question: inputValue,\n//       processedData: {\n//         // Include the stored processed data\n//         [selectedChartType]: [\n//           {\n//             header: graphData.meta?.header || \"default_header\",\n//             valueName: graphData.meta?.valueName || \"default_valueName\",\n//             label: graphData.datasets[0].label,\n//             data: filteredProcessedData[selectedChartType]?.[0]?.data,\n//           },\n//         ],\n//       },\n//     };\n//     try {\n//       const response = await fetch(\n//         `http://localhost:3012/api/answer-analyze-excel?question=${encodeURIComponent(inputValue)}`,\n//         {\n//           method: \"POST\",\n//           headers: { \"Content-Type\": \"application/json\" },\n//           body: JSON.stringify(requestBody),\n//         }\n//       );\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       console.log(\"Updated API Response Data:\", processedData);\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0]; // Use only API response data\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? [\"rgba(173, 216, 230, 0.6)\", \"rgba(144, 238, 144, 0.6)\", \"rgba(255, 182, 193, 0.6)\"]\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//           meta: {\n//             header: chartInfo.header || \"default_header\",\n//             valueName: chartInfo.valueName || \"default_valueName\",\n//           },\n//         };\n//       };\n//       // Only update chartData without storing in storedProcessedData\n//       setChartData((prevChartData) => ({\n//         ...prevChartData,\n//         [selectedChart]: generateChartData(selectedChartType),\n//       }));\n//     } catch (error) {\n//       console.error(\"Error sending request:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//         x: {\n//           ticks: {\n//             autoSkip: false,\n//             maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//         minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//             autoSkipPadding: 20,\n//           },\n//           grid: {\n//             display: true,\n//             drawTicks: false,\n//             tickLength: 100,\n//             lineWidth: 1\n//           },\n//         },\n//         y: {\n//           beginAtZero: true,\n//           ticks: { precision: 0 },\n//         },\n//       },\n//     plugins: {\n//       legend: { display: true, position: \"top\" },\n//       tooltip: { enabled: true },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div style={{ minWidth: [\"lineChartData\", \"barChartData\"].includes(type) ? `${chartWidth}px` : \"auto\", height: \"400px\" }}>\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   const handleDownloadPDF = async () => {\n//     if (!chartRef.current) return;\n//     // Temporarily set the chart container to its full height to capture all content\n//     const originalHeight = chartRef.current.style.height;\n//     chartRef.current.style.height = `${chartRef.current.scrollHeight}px`;\n//     const canvas = await html2canvas(chartRef.current, {\n//       scrollX: 0,\n//       scrollY: -window.scrollY,\n//       width: chartRef.current.scrollWidth,\n//       height: chartRef.current.scrollHeight,\n//     });\n//     // Restore the original height of the chart container\n//     chartRef.current.style.height = originalHeight;\n//     const imgData = canvas.toDataURL(\"image/png\");\n//     const pdf = new jsPDF(\"landscape\", \"mm\", \"a4\");\n//     const imgProps = pdf.getImageProperties(imgData);\n//     const pdfWidth = pdf.internal.pageSize.getWidth();\n//     const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;\n//     pdf.addImage(imgData, \"PNG\", 0, 0, pdfWidth, pdfHeight);\n//     pdf.save(\"chart.pdf\");\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button onClick={handleSubmit} className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\">\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map((type) => (\n//             <button key={type} onClick={() => setSelectedChart(type)} className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\">\n//               {type.replace(\"ChartData\", \" Chart\")}\n//             </button>\n//           ))}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           selectedChart && renderChart(selectedChart, { lineChartData: Line, barChartData: Bar, scatterChartData: Scatter, pieChartData: Pie, donutChartData: Doughnut }[selectedChart])\n//         )}\n//         <div className=\"mt-4 flex\">\n//           <input\n//             type=\"text\"\n//             value={inputValue}\n//             onChange={(e) => setInputValue(e.target.value)}\n//             className=\"border p-2 flex-grow mr-2 rounded\"\n//             placeholder=\"Enter your text here\"\n//           />\n//           <button onClick={handleSend} className=\"bg-green-500 text-white p-2 rounded\">\n//             Send\n//           </button>\n//         </div>\n//         <div className=\"mt-4 p-4 border border-gray-300 rounded bg-white\">\n//           <h3 className=\"text-lg font-bold mb-2\">Insights</h3>\n//           {combinedInsights ? (\n//             <ol className=\"list-decimal list-inside text-sm text-gray-700 bg-gray-100 p-2 rounded overflow-auto\">\n//               {combinedInsights.split('\\n').map((insight, index) => (\n//                 <ul key={index}>{insight}</ul>\n//               ))}\n//             </ol>\n//           ) : (\n//             <p className=\"text-gray-500\">No insights available.</p>\n//           )}\n//         </div>\n//         <button onClick={handleDownloadPDF} className=\"bg-red-500 text-white p-2 rounded mt-4\">\n//           Download as PDF\n//         </button>\n//       </div>\n//     </div>\n//   );\n// }\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nchart_js__WEBPACK_IMPORTED_MODULE_4__.Chart.register(chart_js__WEBPACK_IMPORTED_MODULE_4__.CategoryScale, chart_js__WEBPACK_IMPORTED_MODULE_4__.LinearScale, chart_js__WEBPACK_IMPORTED_MODULE_4__.BarElement, chart_js__WEBPACK_IMPORTED_MODULE_4__.LineElement, chart_js__WEBPACK_IMPORTED_MODULE_4__.PointElement, chart_js__WEBPACK_IMPORTED_MODULE_4__.ArcElement, chart_js__WEBPACK_IMPORTED_MODULE_4__.Title, chart_js__WEBPACK_IMPORTED_MODULE_4__.Tooltip, chart_js__WEBPACK_IMPORTED_MODULE_4__.Legend, chartjs_plugin_zoom__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\nfunction Dashboard() {\n    _s();\n    const [chartData, setChartData] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({\n        scatterChartData: null,\n        pieChartData: null,\n        donutChartData: null,\n        lineChartData: null,\n        barChartData: null\n    });\n    const [selectedFile, setSelectedFile] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [selectedChart, setSelectedChart] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"lineChartData\");\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [chartWidth, setChartWidth] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(0);\n    const [inputValue, setInputValue] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [storedProcessedData, setStoredProcessedData] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null); // New state to store processed data\n    const [combinedInsights, setCombinedInsights] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null); // Ref for the chart container\n    const handleFileChange = (event)=>{\n        var _event_target_files;\n        setSelectedFile(((_event_target_files = event.target.files) === null || _event_target_files === void 0 ? void 0 : _event_target_files[0]) || null);\n    };\n    const handleSubmit = async ()=>{\n        if (!selectedFile) return;\n        setLoading(true);\n        const formData = new FormData();\n        formData.append(\"file\", selectedFile);\n        try {\n            var _result_data, _result_data1;\n            const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n                method: \"POST\",\n                body: formData\n            });\n            if (!response.ok) throw new Error(\"Error uploading file.\");\n            const result = await response.json();\n            const combinedInsights = (_result_data = result.data) === null || _result_data === void 0 ? void 0 : _result_data.combinedInsights;\n            const processedData = (_result_data1 = result.data) === null || _result_data1 === void 0 ? void 0 : _result_data1.processedData;\n            if (!processedData) throw new Error(\"Invalid response structure.\");\n            console.log(\"processedData\", processedData);\n            setStoredProcessedData(processedData); // Store the processed data\n            setCombinedInsights(combinedInsights);\n            const lightColors = [\n                \"rgba(173, 216, 230, 0.6)\",\n                \"rgba(144, 238, 144, 0.6)\",\n                \"rgba(255, 182, 193, 0.6)\",\n                \"rgba(255, 228, 181, 0.6)\",\n                \"rgba(221, 160, 221, 0.6)\",\n                \"rgba(240, 230, 140, 0.6)\"\n            ];\n            const generateChartData = (chartType)=>{\n                var _processedData_chartType;\n                const chartInfo = (_processedData_chartType = processedData[chartType]) === null || _processedData_chartType === void 0 ? void 0 : _processedData_chartType[0];\n                if (!chartInfo) return null;\n                const labels = Object.keys(chartInfo.data);\n                const values = Object.values(chartInfo.data);\n                console.log(\"chartType\", chartType);\n                let chartWidth = 0;\n                if ([\n                    \"Line Chart\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150;\n                } else if ([\n                    \"Bar Chart\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150; // Adjust the width for bar chart\n                } else if ([\n                    \"Scatter Plot\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150; // Adjust the width for bar chart\n                } else {\n                    chartWidth = 400; // Default width for other chart types\n                }\n                setChartWidth(chartWidth);\n                return {\n                    labels,\n                    datasets: [\n                        {\n                            label: chartInfo.label || chartType,\n                            data: values,\n                            backgroundColor: [\n                                \"Pie Chart\",\n                                \"Donut Chart\",\n                                \"Bar Chart\"\n                            ].includes(chartType) ? lightColors.slice(0, labels.length) : \"rgba(135, 206, 250, 0.6)\",\n                            borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n                            fill: !chartType.includes(\"Line\")\n                        }\n                    ],\n                    meta: {\n                        header: chartInfo.header || \"default_header\",\n                        valueName: chartInfo.valueName || \"default_valueName\"\n                    }\n                };\n            };\n            setChartData({\n                scatterChartData: generateChartData(\"Scatter Plot\"),\n                pieChartData: generateChartData(\"Pie Chart\"),\n                donutChartData: generateChartData(\"Donut Chart\"),\n                lineChartData: generateChartData(\"Line Chart\"),\n                barChartData: generateChartData(\"Bar Chart\")\n            });\n        } catch (error) {\n            console.error(\"Error uploading file:\", error);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const handleSend = async ()=>{\n        var _graphData_meta, _graphData_meta1, _filteredProcessedData_selectedChartType_, _filteredProcessedData_selectedChartType;\n        if (!inputValue) return;\n        const graphData = chartData[selectedChart];\n        if (!graphData) return;\n        const labels = graphData.labels;\n        const values = graphData.datasets[0].data;\n        const dataObject = labels.reduce((obj, label, index)=>{\n            obj[label] = values[index];\n            return obj;\n        }, {});\n        const chartTypeMapping = {\n            lineChartData: \"Line Chart\",\n            pieChartData: \"Pie Chart\",\n            donutChartData: \"Donut Chart\",\n            barChartData: \"Bar Chart\",\n            scatterChartData: \"Scatter Plot\"\n        };\n        const selectedChartType = chartTypeMapping[selectedChart] || selectedChart;\n        // Filter the stored processed data to include only the selected chart's data\n        const filteredProcessedData = {\n            [selectedChartType]: storedProcessedData[selectedChartType]\n        };\n        const requestBody = {\n            question: inputValue,\n            processedData: {\n                // Include the stored processed data\n                [selectedChartType]: [\n                    {\n                        header: ((_graphData_meta = graphData.meta) === null || _graphData_meta === void 0 ? void 0 : _graphData_meta.header) || \"default_header\",\n                        valueName: ((_graphData_meta1 = graphData.meta) === null || _graphData_meta1 === void 0 ? void 0 : _graphData_meta1.valueName) || \"default_valueName\",\n                        label: graphData.datasets[0].label,\n                        data: (_filteredProcessedData_selectedChartType = filteredProcessedData[selectedChartType]) === null || _filteredProcessedData_selectedChartType === void 0 ? void 0 : (_filteredProcessedData_selectedChartType_ = _filteredProcessedData_selectedChartType[0]) === null || _filteredProcessedData_selectedChartType_ === void 0 ? void 0 : _filteredProcessedData_selectedChartType_.data\n                    }\n                ]\n            }\n        };\n        try {\n            var _result_data;\n            const response = await fetch(\"http://localhost:3012/api/answer-analyze-excel?question=\".concat(encodeURIComponent(inputValue)), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(requestBody)\n            });\n            if (!response.ok) throw new Error(\"Error uploading file.\");\n            const result = await response.json();\n            const processedData = (_result_data = result.data) === null || _result_data === void 0 ? void 0 : _result_data.processedData;\n            if (!processedData) throw new Error(\"Invalid response structure.\");\n            const generateChartData = (chartType)=>{\n                var _processedData_chartType;\n                const chartInfo = (_processedData_chartType = processedData[chartType]) === null || _processedData_chartType === void 0 ? void 0 : _processedData_chartType[0]; // Use only API response data\n                if (!chartInfo) return null;\n                const labels = Object.keys(chartInfo.data);\n                const values = Object.values(chartInfo.data);\n                let chartWidth = 0;\n                if ([\n                    \"Line Chart\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150;\n                } else if ([\n                    \"Bar Chart\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150; // Adjust the width for bar chart\n                } else if ([\n                    \"Scatter Plot\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150; // Adjust the width for bar chart\n                } else {\n                    chartWidth = 400; // Default width for other chart types\n                }\n                setChartWidth(chartWidth);\n                return {\n                    labels,\n                    datasets: [\n                        {\n                            label: chartInfo.label || chartType,\n                            data: values,\n                            backgroundColor: [\n                                \"Pie Chart\",\n                                \"Donut Chart\",\n                                \"Bar Chart\"\n                            ].includes(chartType) ? [\n                                \"rgba(173, 216, 230, 0.6)\",\n                                \"rgba(144, 238, 144, 0.6)\",\n                                \"rgba(255, 182, 193, 0.6)\"\n                            ] : \"rgba(135, 206, 250, 0.6)\",\n                            borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n                            fill: !chartType.includes(\"Line\")\n                        }\n                    ],\n                    meta: {\n                        header: chartInfo.header || \"default_header\",\n                        valueName: chartInfo.valueName || \"default_valueName\"\n                    }\n                };\n            };\n            // Only update chartData without storing in storedProcessedData\n            setChartData((prevChartData)=>({\n                    ...prevChartData,\n                    [selectedChart]: generateChartData(selectedChartType)\n                }));\n        } catch (error) {\n            console.error(\"Error sending request:\", error);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const renderChart = (type, ChartComponent)=>{\n        const data = chartData === null || chartData === void 0 ? void 0 : chartData[type];\n        if (!loading && data) {\n            var _data_labels;\n            // Calculate tick spacing based on data length\n            const dataLength = ((_data_labels = data.labels) === null || _data_labels === void 0 ? void 0 : _data_labels.length) || 0;\n            const maxTicks = Math.floor(600 / 50); // Approx 50px per label width\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-full overflow-x-auto overflow-y-hidden bg-white p-4 rounded-lg shadow\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        width: \"100%\",\n                        minWidth: [\n                            \"lineChartData\",\n                            \"barChartData\"\n                        ].includes(type) ? Math.max(600, dataLength * 50) + \"px\" // Dynamic min-width based on data\n                         : \"100%\",\n                        height: \"400px\"\n                    },\n                    className: \"relative\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChartComponent, {\n                        data: data,\n                        options: {\n                            responsive: true,\n                            maintainAspectRatio: false,\n                            scales: {\n                                x: {\n                                    min: 0,\n                                    ticks: {\n                                        autoSkip: true,\n                                        maxTicksLimit: maxTicks,\n                                        maxRotation: 45,\n                                        minRotation: 0,\n                                        padding: 10,\n                                        font: {\n                                            size: 12\n                                        }\n                                    },\n                                    grid: {\n                                        display: false\n                                    }\n                                },\n                                y: {\n                                    beginAtZero: true\n                                }\n                            },\n                            plugins: {\n                                legend: {\n                                    display: true,\n                                    position: \"top\"\n                                },\n                                tooltip: {\n                                    enabled: true,\n                                    intersect: false,\n                                    mode: 'index'\n                                }\n                            },\n                            // Add padding to ensure labels aren't cut off\n                            layout: {\n                                padding: {\n                                    left: 20,\n                                    right: 20\n                                }\n                            }\n                        }\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 1973,\n                        columnNumber: 13\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                    lineNumber: 1963,\n                    columnNumber: 3\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                lineNumber: 1962,\n                columnNumber: 9\n            }, this);\n        }\n        return null;\n    };\n    const getChartOptions = (type)=>({\n            responsive: true,\n            maintainAspectRatio: false,\n            // Ensure proper scroll behavior\n            layout: {\n                padding: {\n                    right: 20\n                }\n            },\n            scales: {\n                x: {\n                    min: 0,\n                    ticks: {\n                        autoSkip: false,\n                        maxRotation: 0,\n                        minRotation: 0\n                    }\n                },\n                y: {\n                    beginAtZero: true\n                }\n            },\n            plugins: {\n                legend: {\n                    display: true,\n                    position: \"top\"\n                },\n                tooltip: {\n                    enabled: true,\n                    // Ensure tooltips work with overflow\n                    intersect: false,\n                    mode: 'index'\n                }\n            }\n        });\n    // CSS to support scrolling\n    const chartStyles = \"\\n    .overflow-x-auto {\\n      -webkit-overflow-scrolling: touch;\\n      scrollbar-width: thin;\\n      scrollbar-color: #888 #f1f1f1;\\n    }\\n    \\n    .overflow-x-auto::-webkit-scrollbar {\\n      height: 8px;\\n    }\\n    \\n    .overflow-x-auto::-webkit-scrollbar-thumb {\\n      background: #888;\\n      border-radius: 4px;\\n    }\\n    \\n    .overflow-x-auto::-webkit-scrollbar-track {\\n      background: #f1f1f1;\\n    }\\n    \\n    .overflow-y-hidden {\\n      overflow-y: hidden; /* Prevent vertical scroll */\\n    }\\n    \\n    @media (max-width: 640px) {\\n      .card {\\n        padding: 0.75rem;\\n      }\\n      .card > div > div {\\n        height: 300px;\\n        min-width: 400px;\\n      }\\n    }\\n  \";\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"flex flex-col md:flex-row h-screen border border-black\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"text-lg font-bold mb-2\",\n                        children: \"Upload File\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2101,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"file\",\n                        onChange: handleFileChange,\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"border p-2 w-full\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2102,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: handleSubmit,\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BsUpload_react_icons_bs__WEBPACK_IMPORTED_MODULE_5__.BsUpload, {\n                                className: \"mr-2\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2104,\n                                columnNumber: 11\n                            }, this),\n                            \" Submit\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2103,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"flex flex-col space-y-2 mt-4\",\n                        children: [\n                            \"lineChartData\",\n                            \"barChartData\",\n                            \"scatterChartData\",\n                            \"pieChartData\",\n                            \"donutChartData\"\n                        ].map((type)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>setSelectedChart(type),\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"p-2 bg-gray-300 rounded hover:bg-gray-400\",\n                                children: type.replace(\"ChartData\", \" Chart\")\n                            }, type, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2108,\n                                columnNumber: 13\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2106,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                lineNumber: 2100,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"w-full md:w-3/4 bg-gray-100 p-5\",\n                children: [\n                    loading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"flex justify-center items-center h-full\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"jsx-ee216b23b408fc3d\" + \" \" + \"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                            lineNumber: 2117,\n                            columnNumber: 7\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2116,\n                        columnNumber: 5\n                    }, this) : selectedChart && renderChart(selectedChart, {\n                        lineChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__.Line,\n                        barChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__.Bar,\n                        scatterChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__.Scatter,\n                        pieChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__.Pie,\n                        donutChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__.Doughnut\n                    }[selectedChart]),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"mt-4 flex\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                value: inputValue,\n                                onChange: (e)=>setInputValue(e.target.value),\n                                placeholder: \"Enter your text here\",\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"border p-2 flex-grow mr-2 rounded\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2129,\n                                columnNumber: 5\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: handleSend,\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"bg-green-500 text-white p-2 rounded\",\n                                children: \"Send\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2136,\n                                columnNumber: 5\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2128,\n                        columnNumber: 3\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"mt-4 p-4 border border-gray-300 rounded bg-white\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"text-lg font-bold mb-2\",\n                                children: \"Insights\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2141,\n                                columnNumber: 5\n                            }, this),\n                            combinedInsights ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ol\", {\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"list-decimal list-inside text-sm text-gray-700 bg-gray-100 p-2 rounded max-h-60 overflow-y-auto\",\n                                children: combinedInsights.split('\\n').map((insight, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"py-1\",\n                                        children: insight\n                                    }, index, false, {\n                                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                        lineNumber: 2145,\n                                        columnNumber: 11\n                                    }, this))\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2143,\n                                columnNumber: 7\n                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"text-gray-500\",\n                                children: \"No insights available.\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2149,\n                                columnNumber: 7\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2140,\n                        columnNumber: 3\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                lineNumber: 2114,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default()), {\n                id: \"ee216b23b408fc3d\",\n                children: \".overflow-x-auto.jsx-ee216b23b408fc3d{-webkit-overflow-scrolling:touch;scrollbar-width:thin;scrollbar-color:#888#f1f1f1}.overflow-x-auto.jsx-ee216b23b408fc3d::-webkit-scrollbar{height:8px}.overflow-x-auto.jsx-ee216b23b408fc3d::-webkit-scrollbar-thumb{background:#888;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.overflow-x-auto.jsx-ee216b23b408fc3d::-webkit-scrollbar-track{background:#f1f1f1}@media(max-width:768px){.overflow-x-auto.jsx-ee216b23b408fc3d>div.jsx-ee216b23b408fc3d{min-width:400px;height:300px}}\"\n            }, void 0, false, void 0, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n        lineNumber: 2099,\n        columnNumber: 5\n    }, this);\n}\n_s(Dashboard, \"P/Zh0x9l01YSUrGDOmP3n5Y2uFs=\");\n_c = Dashboard;\nvar _c;\n$RefreshReg$(_c, \"Dashboard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcGFnZXMvVXBsb2FkL1VwbG9hZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUdBLGdCQUFnQjtBQUNoQiwrQ0FBK0M7QUFDL0MsdUVBQXVFO0FBQ3ZFLFdBQVc7QUFDWCxzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsV0FBVztBQUNYLGFBQWE7QUFDYixZQUFZO0FBQ1oscUJBQXFCO0FBQ3JCLDZDQUE2QztBQUM3QyxnREFBZ0Q7QUFFaEQsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLFdBQVc7QUFDWCxhQUFhO0FBQ2IsWUFBWTtBQUNaLGVBQWU7QUFDZixLQUFLO0FBRUwsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QixnQkFBZ0I7QUFDaEIscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QixnQ0FBZ0M7QUFDaEMsNEJBQTRCO0FBQzVCLHNCQUFzQjtBQUN0QixTQUFTO0FBQ1QsSUFBSTtBQUVKLHdDQUF3QztBQUN4QyxtRkFBbUY7QUFDbkYsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQiw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQixRQUFRO0FBQ1IseUVBQXlFO0FBQ3pFLG9FQUFvRTtBQUNwRSw0REFBNEQ7QUFDNUQsNkRBQTZEO0FBQzdELHdFQUF3RTtBQUV4RSwrRUFBK0U7QUFDL0Usd0RBQXdEO0FBQ3hELE9BQU87QUFFUCx1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDLHdCQUF3QjtBQUV4Qix1Q0FBdUM7QUFDdkMsNkNBQTZDO0FBRTdDLFlBQVk7QUFDWixrRkFBa0Y7QUFDbEYsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixZQUFZ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QUFLO2dDQUNMa0QsT0FBT25IO2dDQUNQOEcsVUFBVSxDQUFDTSxJQUFNbkgsY0FBY21ILEVBQUUzRyxNQUFNLENBQUMwRyxLQUFLO2dDQUU3Q0UsYUFBWTswRUFERjs7Ozs7OzBDQUdaLDhEQUFDTjtnQ0FBT0MsU0FBU2hFOzBFQUFzQjswQ0FBc0M7Ozs7Ozs7Ozs7OztrQ0FJL0UsOERBQUN1QjtrRUFBYzs7MENBQ2IsOERBQUMrQzswRUFBYTswQ0FBeUI7Ozs7Ozs0QkFDdENsSCxpQ0FDQyw4REFBQ21IOzBFQUFhOzBDQUNYbkgsaUJBQWlCb0gsS0FBSyxDQUFDLE1BQU1QLEdBQUcsQ0FBQyxDQUFDUSxTQUF5TG5FLHNCQUMxTiw4REFBQ29FO2tGQUF5QjtrREFBUUQ7dUNBQXpCbkU7Ozs7Ozs7OztxREFJYiw4REFBQ3FFOzBFQUFZOzBDQUFnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDbkM7R0FoY3dCM0k7S0FBQUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTXVrZXNoLmthc2ltYWhhbnRoaVxcRGVza3RvcFxcdmlzdWxpemF0aW9uXFxhaUFnZW50RnJvbnRlbmRDb2RlXFxzcmNcXGFwcFxccGFnZXNcXFVwbG9hZFxcVXBsb2FkLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuXHJcblxyXG4vLyBcInVzZSBjbGllbnRcIjtcclxuLy8gaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG4vLyBpbXBvcnQgeyBCYXIsIExpbmUsIERvdWdobnV0LCBQaWUsIFNjYXR0ZXIgfSBmcm9tIFwicmVhY3QtY2hhcnRqcy0yXCI7XHJcbi8vIGltcG9ydCB7XHJcbi8vICAgQ2hhcnQgYXMgQ2hhcnRKUyxcclxuLy8gICBDYXRlZ29yeVNjYWxlLFxyXG4vLyAgIExpbmVhclNjYWxlLFxyXG4vLyAgIEJhckVsZW1lbnQsXHJcbi8vICAgTGluZUVsZW1lbnQsXHJcbi8vICAgUG9pbnRFbGVtZW50LFxyXG4vLyAgIEFyY0VsZW1lbnQsXHJcbi8vICAgVGl0bGUsXHJcbi8vICAgVG9vbHRpcCxcclxuLy8gICBMZWdlbmQsXHJcbi8vIH0gZnJvbSBcImNoYXJ0LmpzXCI7XHJcbi8vIGltcG9ydCB7IEJzVXBsb2FkIH0gZnJvbSBcInJlYWN0LWljb25zL2JzXCI7XHJcbi8vIGltcG9ydCB6b29tUGx1Z2luIGZyb20gXCJjaGFydGpzLXBsdWdpbi16b29tXCI7XHJcblxyXG4vLyBDaGFydEpTLnJlZ2lzdGVyKFxyXG4vLyAgIENhdGVnb3J5U2NhbGUsXHJcbi8vICAgTGluZWFyU2NhbGUsXHJcbi8vICAgQmFyRWxlbWVudCxcclxuLy8gICBMaW5lRWxlbWVudCxcclxuLy8gICBQb2ludEVsZW1lbnQsXHJcbi8vICAgQXJjRWxlbWVudCxcclxuLy8gICBUaXRsZSxcclxuLy8gICBUb29sdGlwLFxyXG4vLyAgIExlZ2VuZCxcclxuLy8gICB6b29tUGx1Z2luXHJcbi8vICk7XHJcblxyXG4vLyBpbnRlcmZhY2UgQ2hhcnREYXRhIHtcclxuLy8gICBsYWJlbHM6IHN0cmluZ1tdO1xyXG4vLyAgIGRhdGFzZXRzOiB7XHJcbi8vICAgICBsYWJlbDogc3RyaW5nO1xyXG4vLyAgICAgZGF0YTogbnVtYmVyW107XHJcbi8vICAgICBiYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmc7XHJcbi8vICAgICBib3JkZXJDb2xvcj86IHN0cmluZztcclxuLy8gICAgIGZpbGw/OiBib29sZWFuO1xyXG4vLyAgIH1bXTtcclxuLy8gfVxyXG5cclxuLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGFzaGJvYXJkKCkge1xyXG4vLyAgIGNvbnN0IFtjaGFydERhdGEsIHNldENoYXJ0RGF0YV0gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBDaGFydERhdGEgfCBudWxsPj4oe1xyXG4vLyAgICAgc2NhdHRlckNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIHBpZUNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGRvbnV0Q2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgbGluZUNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGJhckNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICB9KTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRGaWxlLCBzZXRTZWxlY3RlZEZpbGVdID0gdXNlU3RhdGU8RmlsZSB8IG51bGw+KG51bGwpO1xyXG4vLyAgIGNvbnN0IFtzZWxlY3RlZENoYXJ0LCBzZXRTZWxlY3RlZENoYXJ0XSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XHJcbi8vICAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG4vLyAgIGNvbnN0IFtjaGFydFdpZHRoLCBzZXRDaGFydFdpZHRoXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkTGFiZWxzLCBzZXRTZWxlY3RlZExhYmVsc10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW10pO1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVGaWxlQ2hhbmdlID0gKGV2ZW50OiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xyXG4vLyAgICAgc2V0U2VsZWN0ZWRGaWxlKGV2ZW50LnRhcmdldC5maWxlcz8uWzBdIHx8IG51bGwpO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IGFzeW5jICgpID0+IHtcclxuLy8gICAgIGlmICghc2VsZWN0ZWRGaWxlKSByZXR1cm47XHJcbi8vICAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG5cclxuLy8gICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbi8vICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIHNlbGVjdGVkRmlsZSk7XHJcblxyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHA6Ly9sb2NhbGhvc3Q6MzAxMi9hcGkvYW5hbHl6ZS1leGNlbFwiLCB7XHJcbi8vICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuLy8gICAgICAgICBib2R5OiBmb3JtRGF0YSxcclxuLy8gICAgICAgfSk7XHJcblxyXG4vLyAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZS5cIik7XHJcbi8vICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuLy8gICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHJlc3VsdC5kYXRhPy5wcm9jZXNzZWREYXRhO1xyXG5cclxuLy8gICAgICAgaWYgKCFwcm9jZXNzZWREYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZS5cIik7XHJcblxyXG4vLyAgICAgICBjb25zdCBnZW5lcmF0ZUNoYXJ0RGF0YSA9IChjaGFydFR5cGU6IHN0cmluZyk6IENoYXJ0RGF0YSB8IG51bGwgPT4ge1xyXG4vLyAgICAgICAgIGNvbnN0IGNoYXJ0SW5mbyA9IHByb2Nlc3NlZERhdGFbY2hhcnRUeXBlXT8uWzBdO1xyXG4vLyAgICAgICAgIGlmICghY2hhcnRJbmZvKSByZXR1cm4gbnVsbDtcclxuXHJcbi8vICAgICAgICAgY29uc3QgbGFiZWxzID0gT2JqZWN0LmtleXMoY2hhcnRJbmZvLmRhdGEpO1xyXG4vLyAgICAgICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoY2hhcnRJbmZvLmRhdGEpO1xyXG5cclxuLy8gICAgICAgICByZXR1cm4ge1xyXG4vLyAgICAgICAgICAgbGFiZWxzLFxyXG4vLyAgICAgICAgICAgZGF0YXNldHM6IFtcclxuLy8gICAgICAgICAgICAge1xyXG4vLyAgICAgICAgICAgICAgIGxhYmVsOiBjaGFydEluZm8ubGFiZWwgfHwgY2hhcnRUeXBlLFxyXG4vLyAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlcyBhcyBudW1iZXJbXSxcclxuLy8gICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNoYXJ0VHlwZS5pbmNsdWRlcyhcIkJhclwiKVxyXG4vLyAgICAgICAgICAgICAgICAgPyBcInJnYmEoNTQsIDE2MiwgMjM1LCAwLjUpXCJcclxuLy8gICAgICAgICAgICAgICAgIDogXCJyZ2JhKDI1NSwgOTksIDEzMiwgMC41KVwiLFxyXG4vLyAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpXHJcbi8vICAgICAgICAgICAgICAgICA/IFwicmdiYSgyNTUsIDk5LCAxMzIsIDEpXCJcclxuLy8gICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxyXG4vLyAgICAgICAgICAgICAgIGZpbGw6ICFjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgXSxcclxuLy8gICAgICAgICB9O1xyXG4vLyAgICAgICB9O1xyXG5cclxuLy8gICAgICAgc2V0Q2hhcnREYXRhKHtcclxuLy8gICAgICAgICBzY2F0dGVyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlNjYXR0ZXIgUGxvdFwiKSxcclxuLy8gICAgICAgICBwaWVDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiUGllIENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGRvbnV0Q2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkRvbnV0IENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGxpbmVDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiTGluZSBDaGFydFwiKSxcclxuLy8gICAgICAgICBiYXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiQmFyIENoYXJ0XCIpLFxyXG4vLyAgICAgICB9KTtcclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZTpcIiwgZXJyb3IpO1xyXG4vLyAgICAgfSBmaW5hbGx5IHtcclxuLy8gICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbi8vICAgICB9XHJcbi8vICAgfTtcclxuXHJcbi8vICAgdXNlRWZmZWN0KCgpID0+IHtcclxuLy8gICAgIGlmIChzZWxlY3RlZENoYXJ0ICYmIGNoYXJ0RGF0YVtzZWxlY3RlZENoYXJ0XSkge1xyXG4vLyAgICAgICBjb25zdCBiYXNlTGFiZWxzID0gY2hhcnREYXRhW3NlbGVjdGVkQ2hhcnRdPy5sYWJlbHMgfHwgW107XHJcbi8vICAgICAgIHNldENoYXJ0V2lkdGgoKHNlbGVjdGVkTGFiZWxzLmxlbmd0aCB8fCBiYXNlTGFiZWxzLmxlbmd0aCkgKiAxNTApO1xyXG4vLyAgICAgfVxyXG4vLyAgIH0sIFtzZWxlY3RlZENoYXJ0LCBzZWxlY3RlZExhYmVscywgY2hhcnREYXRhXSk7XHJcbiAgXHJcblxyXG4vLyAgIGNvbnN0IGdldENoYXJ0T3B0aW9ucyA9ICh0eXBlOiBzdHJpbmcpID0+ICh7XHJcbi8vICAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4vLyAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXHJcbi8vICAgICBzY2FsZXM6IFtcInBpZUNoYXJ0RGF0YVwiLCBcImRvbnV0Q2hhcnREYXRhXCJdLmluY2x1ZGVzKHR5cGUpXHJcbi8vICAgICAgID8ge31cclxuLy8gICAgICAgOiB7XHJcbi8vICAgICAgICAgICB4OiB7XHJcbi8vICAgICAgICAgICAgIHRpY2tzOiB7XHJcbi8vICAgICAgICAgICAgICAgYXV0b1NraXA6IGZhbHNlLFxyXG4vLyAgICAgICAgICAgICAgIG1heFJvdGF0aW9uOiB0eXBlID09PSAnYmFyQ2hhcnREYXRhJyB8fCB0eXBlID09PSAnc2NhdHRlckNoYXJ0RGF0YScgPyAyMCA6IDEwMCxcclxuLy8gICAgICAgICAgICAgICBtaW5Sb3RhdGlvbjogdHlwZSA9PT0gJ2JhckNoYXJ0RGF0YScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXJDaGFydERhdGEnID8gMCA6IDkwLFxyXG4vLyAgICAgICAgICAgICAgIGF1dG9Ta2lwUGFkZGluZzogMjAsXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICAgIGdyaWQ6IHtcclxuLy8gICAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4vLyAgICAgICAgICAgICAgIGRyYXdUaWNrczogZmFsc2UsXHJcbi8vICAgICAgICAgICAgICAgdGlja0xlbmd0aDogMTAwLFxyXG4vLyAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMVxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIHk6IHtcclxuLy8gICAgICAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXHJcbi8vICAgICAgICAgICAgIHRpY2tzOiB7XHJcbi8vICAgICAgICAgICAgICAgcHJlY2lzaW9uOiAwLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgcGx1Z2luczoge1xyXG4vLyAgICAgICBsZWdlbmQ6IHtcclxuLy8gICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4vLyAgICAgICAgIHBvc2l0aW9uOiBcInRvcFwiLFxyXG4vLyAgICAgICB9LFxyXG4vLyAgICAgICB0b29sdGlwOiB7XHJcbi8vICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuLy8gICAgICAgfSxcclxuLy8gICAgIH0sXHJcbi8vICAgfSk7XHJcblxyXG4vLyAgIGNvbnN0IGFwcGx5RmlsdGVyID0gKGRhdGE6IENoYXJ0RGF0YSB8IG51bGwpID0+IHtcclxuLy8gICAgIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XHJcblxyXG4vLyAgICAgY29uc3QgZmlsdGVyZWRMYWJlbHMgPSBzZWxlY3RlZExhYmVscy5sZW5ndGhcclxuLy8gICAgICAgPyBkYXRhLmxhYmVscy5maWx0ZXIobGFiZWwgPT4gc2VsZWN0ZWRMYWJlbHMuaW5jbHVkZXMobGFiZWwpKVxyXG4vLyAgICAgICA6IGRhdGEubGFiZWxzO1xyXG5cclxuLy8gICAgIGNvbnN0IGZpbHRlcmVkRGF0YSA9IGRhdGEuZGF0YXNldHMubWFwKGRhdGFzZXQgPT4gKHtcclxuLy8gICAgICAgLi4uZGF0YXNldCxcclxuLy8gICAgICAgZGF0YTogZmlsdGVyZWRMYWJlbHMubWFwKGxhYmVsID0+IGRhdGFzZXQuZGF0YVtkYXRhLmxhYmVscy5pbmRleE9mKGxhYmVsKV0pXHJcbi8vICAgICB9KSk7XHJcblxyXG4vLyAgICAgcmV0dXJuIHtcclxuLy8gICAgICAgbGFiZWxzOiBmaWx0ZXJlZExhYmVscyxcclxuLy8gICAgICAgZGF0YXNldHM6IGZpbHRlcmVkRGF0YSxcclxuLy8gICAgIH07XHJcbi8vICAgfTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlQ2hlY2tib3hDaGFuZ2UgPSAobGFiZWw6IHN0cmluZykgPT4ge1xyXG4vLyAgICAgc2V0U2VsZWN0ZWRMYWJlbHMocHJldiA9PlxyXG4vLyAgICAgICBwcmV2LmluY2x1ZGVzKGxhYmVsKVxyXG4vLyAgICAgICAgID8gcHJldi5maWx0ZXIoaXRlbSA9PiBpdGVtICE9PSBsYWJlbClcclxuLy8gICAgICAgICA6IFsuLi5wcmV2LCBsYWJlbF1cclxuLy8gICAgICk7XHJcbi8vICAgfTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlU2VsZWN0QWxsID0gKCkgPT4ge1xyXG4vLyAgICAgaWYgKHNlbGVjdGVkQ2hhcnQgJiYgY2hhcnREYXRhW3NlbGVjdGVkQ2hhcnRdKSB7XHJcbi8vICAgICAgIHNldFNlbGVjdGVkTGFiZWxzKGNoYXJ0RGF0YVtzZWxlY3RlZENoYXJ0XT8ubGFiZWxzIHx8IFtdKTtcclxuLy8gICAgIH1cclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVDbGVhckFsbCA9ICgpID0+IHtcclxuLy8gICAgIHNldFNlbGVjdGVkTGFiZWxzKFtdKTtcclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCByZW5kZXJDaGFydCA9ICh0eXBlOiBzdHJpbmcsIENoYXJ0Q29tcG9uZW50OiBhbnkpID0+IHtcclxuLy8gICAgIGNvbnN0IGRhdGEgPSBhcHBseUZpbHRlcihjaGFydERhdGFbdHlwZV0pO1xyXG5cclxuLy8gICAgIGlmICghbG9hZGluZyAmJiBkYXRhKSB7XHJcbi8vICAgICAgIHJldHVybiAoXHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkIHAtNCBib3JkZXIgcm91bmRlZCBzaGFkb3ctc21cIj5cclxuLy8gICAgICAgICAgIDxkaXYgc3R5bGU9e3sgd2lkdGg6IFwiMTAwJVwiLCBvdmVyZmxvd1g6IFwiYXV0b1wiIH19PlxyXG4vLyAgICAgICAgICAgICA8ZGl2XHJcbi8vICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuLy8gICAgICAgICAgICAgICAgIG1pbldpZHRoOiBbXCJsaW5lQ2hhcnREYXRhXCIsIFwiYmFyQ2hhcnREYXRhXCJdLmluY2x1ZGVzKHR5cGUpXHJcbi8vICAgICAgICAgICAgICAgICAgID8gYCR7Y2hhcnRXaWR0aH1weGBcclxuLy8gICAgICAgICAgICAgICAgICAgOiBcImF1dG9cIixcclxuLy8gICAgICAgICAgICAgICAgIGhlaWdodDogXCI0MDBweFwiLFxyXG4vLyAgICAgICAgICAgICAgIH19XHJcbi8vICAgICAgICAgICAgID5cclxuLy8gICAgICAgICAgICAgICA8Q2hhcnRDb21wb25lbnQgZGF0YT17ZGF0YX0gb3B0aW9ucz17Z2V0Q2hhcnRPcHRpb25zKHR5cGUpfSAvPlxyXG4vLyAgICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICApO1xyXG4vLyAgICAgfVxyXG4vLyAgICAgcmV0dXJuIG51bGw7XHJcbi8vICAgfTtcclxuXHJcbi8vICAgcmV0dXJuIChcclxuLy8gICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBtZDpmbGV4LXJvdyBoLXNjcmVlbiBib3JkZXIgYm9yZGVyLWJsYWNrXCI+XHJcbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMS80IGJnLXdoaXRlIHAtNSBib3JkZXItdCBtZDpib3JkZXItbCBtZDpib3JkZXItYmxhY2tcIj5cclxuLy8gICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPlVwbG9hZCBGaWxlPC9oMj5cclxuLy8gICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIiBvbkNoYW5nZT17aGFuZGxlRmlsZUNoYW5nZX0gY2xhc3NOYW1lPVwiYm9yZGVyIHAtMiB3LWZ1bGxcIiAvPlxyXG4vLyAgICAgICAgIDxidXR0b25cclxuLy8gICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVN1Ym1pdH1cclxuLy8gICAgICAgICAgIGNsYXNzTmFtZT1cImJnLWJsdWUtNTAwIHRleHQtd2hpdGUgcC0yIHJvdW5kZWQgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgbXQtNFwiXHJcbi8vICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgPEJzVXBsb2FkIGNsYXNzTmFtZT1cIm1yLTJcIiAvPiBTdWJtaXRcclxuLy8gICAgICAgICA8L2J1dHRvbj5cclxuXHJcbi8vICAgICAgICAge3NlbGVjdGVkQ2hhcnQgJiYgKFxyXG4vLyAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC00XCI+XHJcbi8vICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkXCI+RmlsdGVyczwvaDM+XHJcbi8vICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlU2VsZWN0QWxsfSBjbGFzc05hbWU9XCJiZy1ncmVlbi01MDAgdGV4dC13aGl0ZSBweC0yIHB5LTEgcm91bmRlZCBtdC0yXCI+U2VsZWN0IEFsbDwvYnV0dG9uPlxyXG4vLyAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2hhbmRsZUNsZWFyQWxsfSBjbGFzc05hbWU9XCJiZy1yZWQtNTAwIHRleHQtd2hpdGUgcHgtMiBweS0xIHJvdW5kZWQgbXQtMiBtbC0yXCI+Q2xlYXIgQWxsPC9idXR0b24+XHJcbi8vICAgICAgICAgICAgIHtjaGFydERhdGFbc2VsZWN0ZWRDaGFydF0/LmxhYmVscy5tYXAobGFiZWwgPT4gKFxyXG4vLyAgICAgICAgICAgICAgIDxkaXYga2V5PXtsYWJlbH0gY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXJcIj5cclxuLy8gICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4vLyAgICAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxyXG4vLyAgICAgICAgICAgICAgICAgICBjaGVja2VkPXtzZWxlY3RlZExhYmVscy5pbmNsdWRlcyhsYWJlbCl9XHJcbi8vICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoKSA9PiBoYW5kbGVDaGVja2JveENoYW5nZShsYWJlbCl9XHJcbi8vICAgICAgICAgICAgICAgICAvPlxyXG4vLyAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cIm1sLTJcIj57bGFiZWx9PC9sYWJlbD5cclxuLy8gICAgICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICAgICAgKSl9XHJcbi8vICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICApfVxyXG5cclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgc3BhY2UteS0yIG10LTRcIj5cclxuLy8gICAgICAgICAgIHtbXCJsaW5lQ2hhcnREYXRhXCIsIFwiYmFyQ2hhcnREYXRhXCIsIFwic2NhdHRlckNoYXJ0RGF0YVwiLCBcInBpZUNoYXJ0RGF0YVwiLCBcImRvbnV0Q2hhcnREYXRhXCJdLm1hcChcclxuLy8gICAgICAgICAgICAgKHR5cGUpID0+IChcclxuLy8gICAgICAgICAgICAgICA8YnV0dG9uXHJcbi8vICAgICAgICAgICAgICAgICBrZXk9e3R5cGV9XHJcbi8vICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XHJcbi8vICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkQ2hhcnQodHlwZSk7XHJcbi8vICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkTGFiZWxzKFtdKTtcclxuLy8gICAgICAgICAgICAgICAgIH19XHJcbi8vICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJwLTIgYmctZ3JheS0zMDAgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTQwMFwiXHJcbi8vICAgICAgICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgICAgICAge3R5cGUucmVwbGFjZShcIkNoYXJ0RGF0YVwiLCBcIiBDaGFydFwiKX1cclxuLy8gICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgICAgICAgKVxyXG4vLyAgICAgICAgICAgKX1cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgPC9kaXY+XHJcblxyXG4vLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTMvNCBiZy1ncmF5LTEwMCBwLTUgb3ZlcmZsb3ctYXV0b1wiPlxyXG4vLyAgICAgICAgIHtsb2FkaW5nID8gKFxyXG4vLyAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBoLWZ1bGxcIj5cclxuLy8gICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGlubmVyLWJvcmRlciBhbmltYXRlLXNwaW4gYm9yZGVyLXQtNCBib3JkZXItYmx1ZS01MDAgcm91bmRlZC1mdWxsIHctMTIgaC0xMlwiPjwvZGl2PlxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgKSA6IChcclxuLy8gICAgICAgICAgIHJlbmRlckNoYXJ0KHNlbGVjdGVkQ2hhcnQsIHtcclxuLy8gICAgICAgICAgICAgbGluZUNoYXJ0RGF0YTogTGluZSxcclxuLy8gICAgICAgICAgICAgYmFyQ2hhcnREYXRhOiBCYXIsXHJcbi8vICAgICAgICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IFNjYXR0ZXIsXHJcbi8vICAgICAgICAgICAgIHBpZUNoYXJ0RGF0YTogUGllLFxyXG4vLyAgICAgICAgICAgICBkb251dENoYXJ0RGF0YTogRG91Z2hudXQsXHJcbi8vICAgICAgICAgICB9W3NlbGVjdGVkQ2hhcnRdKVxyXG4vLyAgICAgICAgICl9XHJcbi8vICAgICAgIDwvZGl2PlxyXG4vLyAgICAgPC9kaXY+XHJcbi8vICAgKTtcclxuLy8gfVxyXG5cclxuXHJcbi8vIFwidXNlIGNsaWVudFwiO1xyXG4vLyBpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XHJcbi8vIGltcG9ydCB7IEJhciwgTGluZSwgRG91Z2hudXQsIFBpZSwgU2NhdHRlciB9IGZyb20gXCJyZWFjdC1jaGFydGpzLTJcIjtcclxuLy8gaW1wb3J0IHtcclxuLy8gICBDaGFydCBhcyBDaGFydEpTLFxyXG4vLyAgIENhdGVnb3J5U2NhbGUsXHJcbi8vICAgTGluZWFyU2NhbGUsXHJcbi8vICAgQmFyRWxlbWVudCxcclxuLy8gICBMaW5lRWxlbWVudCxcclxuLy8gICBQb2ludEVsZW1lbnQsXHJcbi8vICAgQXJjRWxlbWVudCxcclxuLy8gICBUaXRsZSxcclxuLy8gICBUb29sdGlwLFxyXG4vLyAgIExlZ2VuZCxcclxuLy8gfSBmcm9tIFwiY2hhcnQuanNcIjtcclxuLy8gaW1wb3J0IHsgQnNVcGxvYWQgfSBmcm9tIFwicmVhY3QtaWNvbnMvYnNcIjtcclxuLy8gaW1wb3J0IHpvb21QbHVnaW4gZnJvbSBcImNoYXJ0anMtcGx1Z2luLXpvb21cIjtcclxuLy8gaW1wb3J0IHsgbG9nIH0gZnJvbSBcIm5vZGU6Y29uc29sZVwiO1xyXG4gXHJcbi8vIENoYXJ0SlMucmVnaXN0ZXIoXHJcbi8vICAgQ2F0ZWdvcnlTY2FsZSxcclxuLy8gICBMaW5lYXJTY2FsZSxcclxuLy8gICBCYXJFbGVtZW50LFxyXG4vLyAgIExpbmVFbGVtZW50LFxyXG4vLyAgIFBvaW50RWxlbWVudCxcclxuLy8gICBBcmNFbGVtZW50LFxyXG4vLyAgIFRpdGxlLFxyXG4vLyAgIFRvb2x0aXAsXHJcbi8vICAgTGVnZW5kLFxyXG4vLyAgIHpvb21QbHVnaW5cclxuLy8gKTtcclxuIFxyXG4vLyBpbnRlcmZhY2UgQ2hhcnREYXRhIHtcclxuLy8gICBsYWJlbHM6IHN0cmluZ1tdO1xyXG4vLyAgIGRhdGFzZXRzOiB7XHJcbi8vICAgICBsYWJlbDogc3RyaW5nO1xyXG4vLyAgICAgZGF0YTogbnVtYmVyW107XHJcbi8vICAgICBiYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmc7XHJcbi8vICAgICBib3JkZXJDb2xvcj86IHN0cmluZztcclxuLy8gICAgIGZpbGw/OiBib29sZWFuO1xyXG4vLyAgIH1bXTtcclxuLy8gfVxyXG4gXHJcbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhc2hib2FyZCgpIHtcclxuLy8gICBjb25zdCBbY2hhcnREYXRhLCBzZXRDaGFydERhdGFdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgQ2hhcnREYXRhIHwgbnVsbD4+KHtcclxuLy8gICAgIHNjYXR0ZXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBwaWVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBkb251dENoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGxpbmVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBiYXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgfSk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkRmlsZSwgc2V0U2VsZWN0ZWRGaWxlXSA9IHVzZVN0YXRlPEZpbGUgfCBudWxsPihudWxsKTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRDaGFydCwgc2V0U2VsZWN0ZWRDaGFydF0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwibGluZUNoYXJ0RGF0YVwiKTtcclxuLy8gICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcbi8vICAgY29uc3QgW2NoYXJ0V2lkdGgsIHNldENoYXJ0V2lkdGhdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcclxuIFxyXG4vLyAgIGNvbnN0IGhhbmRsZUZpbGVDaGFuZ2UgPSAoZXZlbnQ6IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XHJcbi8vICAgICBzZXRTZWxlY3RlZEZpbGUoZXZlbnQudGFyZ2V0LmZpbGVzPy5bMF0gfHwgbnVsbCk7XHJcbi8vICAgfTtcclxuIFxyXG4vLyAgIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IGFzeW5jICgpID0+IHtcclxuLy8gICAgIGlmICghc2VsZWN0ZWRGaWxlKSByZXR1cm47XHJcbi8vICAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG4gXHJcbi8vICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4vLyAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBzZWxlY3RlZEZpbGUpO1xyXG4gXHJcbi8vICAgICB0cnkge1xyXG4vLyAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cDovL2xvY2FsaG9zdDozMDEyL2FwaS9hbmFseXplLWV4Y2VsXCIsIHtcclxuLy8gICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4vLyAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxyXG4vLyAgICAgICB9KTtcclxuIFxyXG4vLyAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZS5cIik7XHJcbi8vICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuLy8gICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHJlc3VsdC5kYXRhPy5wcm9jZXNzZWREYXRhO1xyXG4vLyBjb25zb2xlLmxvZyhcInByb2Nlc3NlZERhdGFcIixwcm9jZXNzZWREYXRhKTtcclxuIFxyXG4vLyAgICAgICBpZiAoIXByb2Nlc3NlZERhdGEpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzcG9uc2Ugc3RydWN0dXJlLlwiKTtcclxuIFxyXG4vLyAgICAgICBjb25zdCBnZW5lcmF0ZUNoYXJ0RGF0YSA9IChjaGFydFR5cGU6IHN0cmluZyk6IENoYXJ0RGF0YSB8IG51bGwgPT4ge1xyXG4vLyAgICAgICAgIGNvbnN0IGNoYXJ0SW5mbyA9IHByb2Nlc3NlZERhdGFbY2hhcnRUeXBlXT8uWzBdO1xyXG4vLyAgICAgICAgIGlmICghY2hhcnRJbmZvKSByZXR1cm4gbnVsbDtcclxuIFxyXG4vLyAgICAgICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5rZXlzKGNoYXJ0SW5mby5kYXRhKTtcclxuLy8gICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGNoYXJ0SW5mby5kYXRhKTtcclxuLy8gIGNvbnNvbGUubG9nKFwibGFiZWxzLmxlbmd0aCBcIixjaGFydFR5cGUsbGFiZWxzLmxlbmd0aCApO1xyXG4vLyAgY29uc29sZS5sb2coXCJ2YWx1ZXMubGVuZ3RoIFwiLGNoYXJ0VHlwZSx2YWx1ZXMubGVuZ3RoICk7XHJcblxyXG4gXHJcbi8vICAgICAgICAgc2V0Q2hhcnRXaWR0aChsYWJlbHMubGVuZ3RoICogMTUwKTtcclxuIFxyXG4vLyAgICAgICAgIHJldHVybiB7XHJcbi8vICAgICAgICAgICBsYWJlbHMsXHJcbi8vICAgICAgICAgICBkYXRhc2V0czogW1xyXG4vLyAgICAgICAgICAgICB7XHJcbi8vICAgICAgICAgICAgICAgbGFiZWw6IGNoYXJ0SW5mby5sYWJlbCB8fCBjaGFydFR5cGUsXHJcbi8vICAgICAgICAgICAgICAgZGF0YTogdmFsdWVzIGFzIG51bWJlcltdLFxyXG4vLyAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY2hhcnRUeXBlLmluY2x1ZGVzKFwiQmFyXCIpXHJcbi8vICAgICAgICAgICAgICAgICA/IFwicmdiYSg1NCwgMTYyLCAyMzUsIDAuNSlcIlxyXG4vLyAgICAgICAgICAgICAgICAgOiBcInJnYmEoMjU1LCA5OSwgMTMyLCAwLjUpXCIsXHJcbi8vICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIilcclxuLy8gICAgICAgICAgICAgICAgID8gXCJyZ2JhKDI1NSwgOTksIDEzMiwgMSlcIlxyXG4vLyAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXHJcbi8vICAgICAgICAgICAgICAgZmlsbDogIWNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIiksXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICBdLFxyXG4vLyAgICAgICAgIH07XHJcbi8vICAgICAgIH07XHJcbi8vIGNvbnNvbGUubG9nKFwiZ2VuZXJhdGVDaGFydERhdGFcIixnZW5lcmF0ZUNoYXJ0RGF0YSk7XHJcbiBcclxuLy8gICAgICAgc2V0Q2hhcnREYXRhKHtcclxuLy8gICAgICAgICBzY2F0dGVyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlNjYXR0ZXIgUGxvdFwiKSxcclxuLy8gICAgICAgICBwaWVDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiUGllIENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGRvbnV0Q2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkRvbnV0IENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGxpbmVDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiTGluZSBDaGFydFwiKSxcclxuLy8gICAgICAgICBiYXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiQmFyIENoYXJ0XCIpLFxyXG4vLyAgICAgICB9KTtcclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZTpcIiwgZXJyb3IpO1xyXG4vLyAgICAgfSBmaW5hbGx5IHtcclxuLy8gICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbi8vICAgICB9XHJcbi8vICAgfTtcclxuIFxyXG4vLyAgIGNvbnN0IGdldENoYXJ0T3B0aW9ucyA9ICh0eXBlOiBzdHJpbmcpID0+ICh7XHJcbiAgIFxyXG4vLyAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuLy8gICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxyXG4vLyAgICAgc2NhbGVzOiBbXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKVxyXG4vLyAgICAgICA/IHt9XHJcbi8vICAgICAgIDoge1xyXG4vLyAgICAgICAgIHg6IHtcclxuLy8gICAgICAgICAgIHRpY2tzOiB7XHJcbi8vICAgICAgICAgICAgIGF1dG9Ta2lwOiBmYWxzZSxcclxuLy8gICAgICAgICAgICAgbWF4Um90YXRpb246IHR5cGUgPT09ICdiYXJDaGFydERhdGEnIHx8IHR5cGUgPT09ICdzY2F0dGVyQ2hhcnREYXRhJyA/IDIwIDogMTAwLFxyXG4vLyAgICAgICAgIG1pblJvdGF0aW9uOiB0eXBlID09PSAnYmFyQ2hhcnREYXRhJyB8fCB0eXBlID09PSAnc2NhdHRlckNoYXJ0RGF0YScgPyAwIDogOTAsXHJcbi8vICAgICAgICAgICAgIGF1dG9Ta2lwUGFkZGluZzogMjAsXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgZ3JpZDoge1xyXG4vLyAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4vLyAgICAgICAgICAgICBkcmF3VGlja3M6IGZhbHNlLFxyXG4vLyAgICAgICAgICAgICB0aWNrTGVuZ3RoOiAxMDAsXHJcbi8vICAgICAgICAgICAgIGxpbmVXaWR0aDogMVxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgeToge1xyXG4vLyAgICAgICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgdGlja3M6IHtcclxuLy8gICAgICAgICAgICAgICBwcmVjaXNpb246IDAsXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICBwbHVnaW5zOiB7XHJcbi8vICAgICAgIGxlZ2VuZDoge1xyXG4vLyAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbi8vICAgICAgICAgcG9zaXRpb246IFwidG9wXCIsXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICAgIHRvb2x0aXA6IHtcclxuLy8gICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4vLyAgICAgICB9LFxyXG4vLyAgICAgfSxcclxuLy8gICB9KTtcclxuIFxyXG4vLyAgIGNvbnN0IHJlbmRlckNoYXJ0ID0gKHR5cGU6IHN0cmluZywgQ2hhcnRDb21wb25lbnQ6IGFueSkgPT4ge1xyXG4vLyAgICAgY29uc3QgZGF0YSA9IGNoYXJ0RGF0YVt0eXBlXTtcclxuLy8gICAgIGlmICghbG9hZGluZyAmJiBkYXRhKSB7XHJcbi8vICAgICAgIHJldHVybiAoXHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkIHAtNCBib3JkZXIgcm91bmRlZCBzaGFkb3ctc21cIj5cclxuLy8gICAgICAgICAgIDxkaXYgc3R5bGU9e3sgd2lkdGg6IFwiMTAwJVwiLCBvdmVyZmxvd1g6IFwiYXV0b1wiIH19PlxyXG4vLyAgICAgICAgICAgICA8ZGl2XHJcbi8vICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuLy8gICAgICAgICAgICAgICAgIG1pbldpZHRoOiBbXCJsaW5lQ2hhcnREYXRhXCIsIFwiYmFyQ2hhcnREYXRhXCJdLmluY2x1ZGVzKHR5cGUpXHJcbi8vICAgICAgICAgICAgICAgICAgID8gYCR7Y2hhcnRXaWR0aH1weGBcclxuLy8gICAgICAgICAgICAgICAgICAgOiBcImF1dG9cIixcclxuLy8gICAgICAgICAgICAgICAgIGhlaWdodDogXCI0MDBweFwiLFxyXG4vLyAgICAgICAgICAgICAgIH19XHJcbi8vICAgICAgICAgICAgID5cclxuLy8gICAgICAgICAgICAgICA8Q2hhcnRDb21wb25lbnQgZGF0YT17ZGF0YX0gb3B0aW9ucz17Z2V0Q2hhcnRPcHRpb25zKHR5cGUpfSAvPlxyXG4vLyAgICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICApO1xyXG4vLyAgICAgfVxyXG4vLyAgICAgcmV0dXJuIG51bGw7XHJcbi8vICAgfTtcclxuIFxyXG4vLyAgIHJldHVybiAoXHJcbi8vICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgbWQ6ZmxleC1yb3cgaC1zY3JlZW4gYm9yZGVyIGJvcmRlci1ibGFja1wiPlxyXG4vLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTEvNCBiZy13aGl0ZSBwLTUgYm9yZGVyLXQgbWQ6Ym9yZGVyLWwgbWQ6Ym9yZGVyLWJsYWNrXCI+XHJcbi8vICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5VcGxvYWQgRmlsZTwvaDI+XHJcbi8vICAgICAgICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgb25DaGFuZ2U9e2hhbmRsZUZpbGVDaGFuZ2V9IGNsYXNzTmFtZT1cImJvcmRlciBwLTIgdy1mdWxsXCIgLz5cclxuLy8gICAgICAgICA8YnV0dG9uXHJcbi8vICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVTdWJtaXR9XHJcbi8vICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlIHAtMiByb3VuZGVkIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG10LTRcIlxyXG4vLyAgICAgICAgID5cclxuLy8gICAgICAgICAgIDxCc1VwbG9hZCBjbGFzc05hbWU9XCJtci0yXCIgLz4gU3VibWl0XHJcbi8vICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHNwYWNlLXktMiBtdC00XCI+XHJcbi8vICAgICAgICAgICB7W1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiLCBcInNjYXR0ZXJDaGFydERhdGFcIiwgXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5tYXAoXHJcbi8vICAgICAgICAgICAgICh0eXBlKSA9PiAoXHJcbi8vICAgICAgICAgICAgICAgPGJ1dHRvblxyXG4vLyAgICAgICAgICAgICAgICAga2V5PXt0eXBlfVxyXG4vLyAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0U2VsZWN0ZWRDaGFydCh0eXBlKX1cclxuLy8gICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInAtMiBiZy1ncmF5LTMwMCByb3VuZGVkIGhvdmVyOmJnLWdyYXktNDAwXCJcclxuLy8gICAgICAgICAgICAgICA+XHJcbi8vICAgICAgICAgICAgICAgICB7dHlwZS5yZXBsYWNlKFwiQ2hhcnREYXRhXCIsIFwiIENoYXJ0XCIpfVxyXG4vLyAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgICAgICApXHJcbi8vICAgICAgICAgICApfVxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICA8L2Rpdj5cclxuIFxyXG4vLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTMvNCBiZy1ncmF5LTEwMCBwLTUgb3ZlcmZsb3ctYXV0b1wiPlxyXG4vLyAgICAgICAgIHtsb2FkaW5nID8gKFxyXG4vLyAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBoLWZ1bGxcIj5cclxuLy8gICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGlubmVyLWJvcmRlciBhbmltYXRlLXNwaW4gYm9yZGVyLXQtNCBib3JkZXItYmx1ZS01MDAgcm91bmRlZC1mdWxsIHctMTIgaC0xMlwiPjwvZGl2PlxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgKSA6IChcclxuLy8gICAgICAgICAgIHJlbmRlckNoYXJ0KHNlbGVjdGVkQ2hhcnQsIHtcclxuLy8gICAgICAgICAgICAgbGluZUNoYXJ0RGF0YTogTGluZSxcclxuLy8gICAgICAgICAgICAgYmFyQ2hhcnREYXRhOiBCYXIsXHJcbi8vICAgICAgICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IFNjYXR0ZXIsXHJcbi8vICAgICAgICAgICAgIHBpZUNoYXJ0RGF0YTogUGllLFxyXG4vLyAgICAgICAgICAgICBkb251dENoYXJ0RGF0YTogRG91Z2hudXQsXHJcbi8vICAgICAgICAgICB9W3NlbGVjdGVkQ2hhcnRdKVxyXG4vLyAgICAgICAgICl9XHJcbi8vICAgICAgIDwvZGl2PlxyXG4vLyAgICAgPC9kaXY+XHJcbi8vICAgKTtcclxuLy8gfVxyXG5cclxuXHJcbi8vIFwidXNlIGNsaWVudFwiO1xyXG4vLyBpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XHJcbi8vIGltcG9ydCB7IEJhciwgTGluZSwgRG91Z2hudXQsIFBpZSwgU2NhdHRlciB9IGZyb20gXCJyZWFjdC1jaGFydGpzLTJcIjtcclxuLy8gaW1wb3J0IHtcclxuLy8gICBDaGFydCBhcyBDaGFydEpTLFxyXG4vLyAgIENhdGVnb3J5U2NhbGUsXHJcbi8vICAgTGluZWFyU2NhbGUsXHJcbi8vICAgQmFyRWxlbWVudCxcclxuLy8gICBMaW5lRWxlbWVudCxcclxuLy8gICBQb2ludEVsZW1lbnQsXHJcbi8vICAgQXJjRWxlbWVudCxcclxuLy8gICBUaXRsZSxcclxuLy8gICBUb29sdGlwLFxyXG4vLyAgIExlZ2VuZCxcclxuLy8gfSBmcm9tIFwiY2hhcnQuanNcIjtcclxuLy8gaW1wb3J0IHsgQnNVcGxvYWQgfSBmcm9tIFwicmVhY3QtaWNvbnMvYnNcIjtcclxuLy8gaW1wb3J0IHpvb21QbHVnaW4gZnJvbSBcImNoYXJ0anMtcGx1Z2luLXpvb21cIjtcclxuLy8gaW1wb3J0IHsgbG9nIH0gZnJvbSBcIm5vZGU6Y29uc29sZVwiO1xyXG5cclxuLy8gQ2hhcnRKUy5yZWdpc3RlcihcclxuLy8gICBDYXRlZ29yeVNjYWxlLFxyXG4vLyAgIExpbmVhclNjYWxlLFxyXG4vLyAgIEJhckVsZW1lbnQsXHJcbi8vICAgTGluZUVsZW1lbnQsXHJcbi8vICAgUG9pbnRFbGVtZW50LFxyXG4vLyAgIEFyY0VsZW1lbnQsXHJcbi8vICAgVGl0bGUsXHJcbi8vICAgVG9vbHRpcCxcclxuLy8gICBMZWdlbmQsXHJcbi8vICAgem9vbVBsdWdpblxyXG4vLyApO1xyXG5cclxuLy8gaW50ZXJmYWNlIENoYXJ0RGF0YSB7XHJcbi8vICAgbGFiZWxzOiBzdHJpbmdbXTtcclxuLy8gICBkYXRhc2V0czoge1xyXG4vLyAgICAgbGFiZWw6IHN0cmluZztcclxuLy8gICAgIGRhdGE6IG51bWJlcltdO1xyXG4vLyAgICAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nIHwgc3RyaW5nW107XHJcbi8vICAgICBib3JkZXJDb2xvcj86IHN0cmluZztcclxuLy8gICAgIGZpbGw/OiBib29sZWFuO1xyXG4vLyAgIH1bXTtcclxuLy8gfVxyXG5cclxuLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGFzaGJvYXJkKCkge1xyXG4vLyAgIGNvbnN0IFtjaGFydERhdGEsIHNldENoYXJ0RGF0YV0gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBDaGFydERhdGEgfCBudWxsPj4oe1xyXG4vLyAgICAgc2NhdHRlckNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIHBpZUNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGRvbnV0Q2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgbGluZUNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGJhckNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICB9KTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRGaWxlLCBzZXRTZWxlY3RlZEZpbGVdID0gdXNlU3RhdGU8RmlsZSB8IG51bGw+KG51bGwpO1xyXG4vLyAgIGNvbnN0IFtzZWxlY3RlZENoYXJ0LCBzZXRTZWxlY3RlZENoYXJ0XSA9IHVzZVN0YXRlPHN0cmluZz4oXCJsaW5lQ2hhcnREYXRhXCIpO1xyXG4vLyAgIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcclxuLy8gICBjb25zdCBbY2hhcnRXaWR0aCwgc2V0Q2hhcnRXaWR0aF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVGaWxlQ2hhbmdlID0gKGV2ZW50OiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xyXG4vLyAgICAgc2V0U2VsZWN0ZWRGaWxlKGV2ZW50LnRhcmdldC5maWxlcz8uWzBdIHx8IG51bGwpO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IGFzeW5jICgpID0+IHtcclxuLy8gICAgIGlmICghc2VsZWN0ZWRGaWxlKSByZXR1cm47XHJcbi8vICAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG5cclxuLy8gICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbi8vICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIHNlbGVjdGVkRmlsZSk7XHJcblxyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHA6Ly9sb2NhbGhvc3Q6MzAxMi9hcGkvYW5hbHl6ZS1leGNlbFwiLCB7XHJcbi8vICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuLy8gICAgICAgICBib2R5OiBmb3JtRGF0YSxcclxuLy8gICAgICAgfSk7XHJcblxyXG4vLyAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZS5cIik7XHJcbi8vICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuLy8gICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHJlc3VsdC5kYXRhPy5wcm9jZXNzZWREYXRhO1xyXG5cclxuLy8gICAgICAgaWYgKCFwcm9jZXNzZWREYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZS5cIik7XHJcblxyXG4vLyAgICAgICBjb25zdCBsaWdodENvbG9ycyA9IFtcclxuLy8gICAgICAgICBcInJnYmEoMTczLCAyMTYsIDIzMCwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgxNDQsIDIzOCwgMTQ0LCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDI1NSwgMTgyLCAxOTMsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjU1LCAyMjgsIDE4MSwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyMjEsIDE2MCwgMjIxLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDI0MCwgMjMwLCAxNDAsIDAuNilcIixcclxuLy8gICAgICAgXTtcclxuXHJcbi8vICAgICAgIGNvbnN0IGdlbmVyYXRlQ2hhcnREYXRhID0gKGNoYXJ0VHlwZTogc3RyaW5nKTogQ2hhcnREYXRhIHwgbnVsbCA9PiB7XHJcbi8vICAgICAgICAgY29uc3QgY2hhcnRJbmZvID0gcHJvY2Vzc2VkRGF0YVtjaGFydFR5cGVdPy5bMF07XHJcbi8vICAgICAgICAgaWYgKCFjaGFydEluZm8pIHJldHVybiBudWxsO1xyXG5cclxuLy8gICAgICAgICBjb25zdCBsYWJlbHMgPSBPYmplY3Qua2V5cyhjaGFydEluZm8uZGF0YSk7XHJcbi8vICAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhjaGFydEluZm8uZGF0YSk7XHJcblxyXG4vLyAgICAgICAgIHNldENoYXJ0V2lkdGgobGFiZWxzLmxlbmd0aCAqIDE1MCk7XHJcblxyXG4vLyAgICAgICAgIHJldHVybiB7XHJcbi8vICAgICAgICAgICBsYWJlbHMsXHJcbi8vICAgICAgICAgICBkYXRhc2V0czogW1xyXG4vLyAgICAgICAgICAgICB7XHJcbi8vICAgICAgICAgICAgICAgbGFiZWw6IGNoYXJ0SW5mby5sYWJlbCB8fCBjaGFydFR5cGUsXHJcbi8vICAgICAgICAgICAgICAgZGF0YTogdmFsdWVzIGFzIG51bWJlcltdLFxyXG4vLyAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogW1wiUGllIENoYXJ0XCIsIFwiRG9udXQgQ2hhcnRcIiwgXCJCYXIgQ2hhcnRcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKVxyXG4vLyAgICAgICAgICAgICAgICAgPyBsaWdodENvbG9ycy5zbGljZSgwLCBsYWJlbHMubGVuZ3RoKVxyXG4vLyAgICAgICAgICAgICAgICAgOiBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMC42KVwiLFxyXG4vLyAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpXHJcbi8vICAgICAgICAgICAgICAgICA/IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAxKVwiXHJcbi8vICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcclxuLy8gICAgICAgICAgICAgICBmaWxsOiAhY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIF0sXHJcbi8vICAgICAgICAgfTtcclxuLy8gICAgICAgfTtcclxuXHJcbi8vICAgICAgIHNldENoYXJ0RGF0YSh7XHJcbi8vICAgICAgICAgc2NhdHRlckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJTY2F0dGVyIFBsb3RcIiksXHJcbi8vICAgICAgICAgcGllQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlBpZSBDaGFydFwiKSxcclxuLy8gICAgICAgICBkb251dENoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJEb251dCBDaGFydFwiKSxcclxuLy8gICAgICAgICBsaW5lQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkxpbmUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgYmFyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkJhciBDaGFydFwiKSxcclxuLy8gICAgICAgfSk7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGU6XCIsIGVycm9yKTtcclxuLy8gICAgIH0gZmluYWxseSB7XHJcbi8vICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IGdldENoYXJ0T3B0aW9ucyA9ICh0eXBlOiBzdHJpbmcpID0+ICh7XHJcbi8vICAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4vLyAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXHJcbi8vICAgICBzY2FsZXM6IFtcInBpZUNoYXJ0RGF0YVwiLCBcImRvbnV0Q2hhcnREYXRhXCJdLmluY2x1ZGVzKHR5cGUpXHJcbi8vICAgICAgID8ge31cclxuLy8gICAgICAgOiB7XHJcbiAgICAgICAgLy8geDoge1xyXG4gICAgICAgIC8vICAgdGlja3M6IHtcclxuICAgICAgICAvLyAgICAgYXV0b1NraXA6IGZhbHNlLFxyXG4gICAgICAgIC8vICAgICBtYXhSb3RhdGlvbjogdHlwZSA9PT0gJ2JhckNoYXJ0RGF0YScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXJDaGFydERhdGEnID8gMjAgOiAxMDAsXHJcbiAgICAgICAgLy8gbWluUm90YXRpb246IHR5cGUgPT09ICdiYXJDaGFydERhdGEnIHx8IHR5cGUgPT09ICdzY2F0dGVyQ2hhcnREYXRhJyA/IDAgOiA5MCxcclxuICAgICAgICAvLyAgICAgYXV0b1NraXBQYWRkaW5nOiAyMCxcclxuICAgICAgICAvLyAgIH0sXHJcbiAgICAgICAgLy8gICBncmlkOiB7XHJcbiAgICAgICAgLy8gICAgIGRpc3BsYXk6IHRydWUsXHJcbiAgICAgICAgLy8gICAgIGRyYXdUaWNrczogZmFsc2UsXHJcbiAgICAgICAgLy8gICAgIHRpY2tMZW5ndGg6IDEwMCxcclxuICAgICAgICAvLyAgICAgbGluZVdpZHRoOiAxXHJcbiAgICAgICAgLy8gICB9LFxyXG4gICAgICAgIC8vIH0sXHJcbi8vICAgICAgICAgICB5OiB7XHJcbi8vICAgICAgICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxyXG4vLyAgICAgICAgICAgICB0aWNrczoge1xyXG4vLyAgICAgICAgICAgICAgIHByZWNpc2lvbjogMCxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgIHBsdWdpbnM6IHtcclxuLy8gICAgICAgbGVnZW5kOiB7XHJcbi8vICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICBwb3NpdGlvbjogXCJ0b3BcIixcclxuLy8gICAgICAgfSxcclxuLy8gICAgICAgdG9vbHRpcDoge1xyXG4vLyAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICB9LFxyXG4vLyAgIH0pO1xyXG5cclxuLy8gICBjb25zdCByZW5kZXJDaGFydCA9ICh0eXBlOiBzdHJpbmcsIENoYXJ0Q29tcG9uZW50OiBhbnkpID0+IHtcclxuLy8gICAgIGNvbnN0IGRhdGEgPSBjaGFydERhdGFbdHlwZV07XHJcbi8vICAgICBpZiAoIWxvYWRpbmcgJiYgZGF0YSkge1xyXG4vLyAgICAgICByZXR1cm4gKFxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZCBwLTQgYm9yZGVyIHJvdW5kZWQgc2hhZG93LXNtXCI+XHJcbi8vICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiBcIjEwMCVcIiwgb3ZlcmZsb3dYOiBcImF1dG9cIiB9fT5cclxuLy8gICAgICAgICAgICAgPGRpdlxyXG4vLyAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbi8vICAgICAgICAgICAgICAgICBtaW5XaWR0aDogW1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKVxyXG4vLyAgICAgICAgICAgICAgICAgICA/IGAke2NoYXJ0V2lkdGh9cHhgXHJcbi8vICAgICAgICAgICAgICAgICAgIDogXCJhdXRvXCIsXHJcbi8vICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiNDAwcHhcIixcclxuLy8gICAgICAgICAgICAgICB9fVxyXG4vLyAgICAgICAgICAgICA+XHJcbi8vICAgICAgICAgICAgICAgPENoYXJ0Q29tcG9uZW50IGRhdGE9e2RhdGF9IG9wdGlvbnM9e2dldENoYXJ0T3B0aW9ucyh0eXBlKX0gLz5cclxuLy8gICAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgKTtcclxuLy8gICAgIH1cclxuLy8gICAgIHJldHVybiBudWxsO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIHJldHVybiAoXHJcbi8vICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgbWQ6ZmxleC1yb3cgaC1zY3JlZW4gYm9yZGVyIGJvcmRlci1ibGFja1wiPlxyXG4vLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTEvNCBiZy13aGl0ZSBwLTUgYm9yZGVyLXQgbWQ6Ym9yZGVyLWwgbWQ6Ym9yZGVyLWJsYWNrXCI+XHJcbi8vICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5VcGxvYWQgRmlsZTwvaDI+XHJcbi8vICAgICAgICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgb25DaGFuZ2U9e2hhbmRsZUZpbGVDaGFuZ2V9IGNsYXNzTmFtZT1cImJvcmRlciBwLTIgdy1mdWxsXCIgLz5cclxuLy8gICAgICAgICA8YnV0dG9uXHJcbi8vICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVTdWJtaXR9XHJcbi8vICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlIHAtMiByb3VuZGVkIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG10LTRcIlxyXG4vLyAgICAgICAgID5cclxuLy8gICAgICAgICAgIDxCc1VwbG9hZCBjbGFzc05hbWU9XCJtci0yXCIgLz4gU3VibWl0XHJcbi8vICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHNwYWNlLXktMiBtdC00XCI+XHJcbi8vICAgICAgICAgICB7W1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiLCBcInNjYXR0ZXJDaGFydERhdGFcIiwgXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5tYXAoXHJcbi8vICAgICAgICAgICAgICh0eXBlKSA9PiAoXHJcbi8vICAgICAgICAgICAgICAgPGJ1dHRvblxyXG4vLyAgICAgICAgICAgICAgICAga2V5PXt0eXBlfVxyXG4vLyAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0U2VsZWN0ZWRDaGFydCh0eXBlKX1cclxuLy8gICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInAtMiBiZy1ncmF5LTMwMCByb3VuZGVkIGhvdmVyOmJnLWdyYXktNDAwXCJcclxuLy8gICAgICAgICAgICAgICA+XHJcbi8vICAgICAgICAgICAgICAgICB7dHlwZS5yZXBsYWNlKFwiQ2hhcnREYXRhXCIsIFwiIENoYXJ0XCIpfVxyXG4vLyAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgICAgICApXHJcbi8vICAgICAgICAgICApfVxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICA8L2Rpdj5cclxuXHJcbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMy80IGJnLWdyYXktMTAwIHAtNSBvdmVyZmxvdy1hdXRvXCI+XHJcbi8vICAgICAgICAge2xvYWRpbmcgPyAoXHJcbi8vICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIGgtZnVsbFwiPlxyXG4vLyAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwaW5uZXItYm9yZGVyIGFuaW1hdGUtc3BpbiBib3JkZXItdC00IGJvcmRlci1ibHVlLTUwMCByb3VuZGVkLWZ1bGwgdy0xMiBoLTEyXCI+PC9kaXY+XHJcbi8vICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICApIDogKFxyXG4vLyAgICAgICAgICAgcmVuZGVyQ2hhcnQoc2VsZWN0ZWRDaGFydCwge1xyXG4vLyAgICAgICAgICAgICBsaW5lQ2hhcnREYXRhOiBMaW5lLFxyXG4vLyAgICAgICAgICAgICBiYXJDaGFydERhdGE6IEJhcixcclxuLy8gICAgICAgICAgICAgc2NhdHRlckNoYXJ0RGF0YTogU2NhdHRlcixcclxuLy8gICAgICAgICAgICAgcGllQ2hhcnREYXRhOiBQaWUsXHJcbi8vICAgICAgICAgICAgIGRvbnV0Q2hhcnREYXRhOiBEb3VnaG51dCxcclxuLy8gICAgICAgICAgIH1bc2VsZWN0ZWRDaGFydF0pXHJcbi8vICAgICAgICAgKX1cclxuLy8gICAgICAgPC9kaXY+XHJcbi8vICAgICA8L2Rpdj5cclxuLy8gICApO1xyXG4vLyB9XHJcblxyXG5cclxuLy8gXCJ1c2UgY2xpZW50XCI7XHJcbi8vIGltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuLy8gaW1wb3J0IHsgQmFyLCBMaW5lLCBEb3VnaG51dCwgUGllLCBTY2F0dGVyIH0gZnJvbSBcInJlYWN0LWNoYXJ0anMtMlwiO1xyXG4vLyBpbXBvcnQge1xyXG4vLyAgIENoYXJ0IGFzIENoYXJ0SlMsXHJcbi8vICAgQ2F0ZWdvcnlTY2FsZSxcclxuLy8gICBMaW5lYXJTY2FsZSxcclxuLy8gICBCYXJFbGVtZW50LFxyXG4vLyAgIExpbmVFbGVtZW50LFxyXG4vLyAgIFBvaW50RWxlbWVudCxcclxuLy8gICBBcmNFbGVtZW50LFxyXG4vLyAgIFRpdGxlLFxyXG4vLyAgIFRvb2x0aXAsXHJcbi8vICAgTGVnZW5kLFxyXG4vLyB9IGZyb20gXCJjaGFydC5qc1wiO1xyXG4vLyBpbXBvcnQgeyBCc1VwbG9hZCB9IGZyb20gXCJyZWFjdC1pY29ucy9ic1wiO1xyXG4vLyBpbXBvcnQgem9vbVBsdWdpbiBmcm9tIFwiY2hhcnRqcy1wbHVnaW4tem9vbVwiO1xyXG5cclxuLy8gQ2hhcnRKUy5yZWdpc3RlcihcclxuLy8gICBDYXRlZ29yeVNjYWxlLFxyXG4vLyAgIExpbmVhclNjYWxlLFxyXG4vLyAgIEJhckVsZW1lbnQsXHJcbi8vICAgTGluZUVsZW1lbnQsXHJcbi8vICAgUG9pbnRFbGVtZW50LFxyXG4vLyAgIEFyY0VsZW1lbnQsXHJcbi8vICAgVGl0bGUsXHJcbi8vICAgVG9vbHRpcCxcclxuLy8gICBMZWdlbmQsXHJcbi8vICAgem9vbVBsdWdpblxyXG4vLyApO1xyXG5cclxuLy8gaW50ZXJmYWNlIENoYXJ0RGF0YSB7XHJcbi8vICAgbGFiZWxzOiBzdHJpbmdbXTtcclxuLy8gICBkYXRhc2V0czoge1xyXG4vLyAgICAgbGFiZWw6IHN0cmluZztcclxuLy8gICAgIGRhdGE6IG51bWJlcltdO1xyXG4vLyAgICAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nIHwgc3RyaW5nW107XHJcbi8vICAgICBib3JkZXJDb2xvcj86IHN0cmluZztcclxuLy8gICAgIGZpbGw/OiBib29sZWFuO1xyXG4vLyAgIH1bXTtcclxuLy8gfVxyXG5cclxuLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGFzaGJvYXJkKCkge1xyXG4vLyAgIGNvbnN0IFtjaGFydERhdGEsIHNldENoYXJ0RGF0YV0gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBDaGFydERhdGEgfCBudWxsPj4oe1xyXG4vLyAgICAgc2NhdHRlckNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIHBpZUNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGRvbnV0Q2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgbGluZUNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGJhckNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICB9KTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRGaWxlLCBzZXRTZWxlY3RlZEZpbGVdID0gdXNlU3RhdGU8RmlsZSB8IG51bGw+KG51bGwpO1xyXG4vLyAgIGNvbnN0IFtzZWxlY3RlZENoYXJ0LCBzZXRTZWxlY3RlZENoYXJ0XSA9IHVzZVN0YXRlPHN0cmluZz4oXCJsaW5lQ2hhcnREYXRhXCIpO1xyXG4vLyAgIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcclxuLy8gICBjb25zdCBbY2hhcnRXaWR0aCwgc2V0Q2hhcnRXaWR0aF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xyXG4vLyAgIGNvbnN0IFtpbnB1dFZhbHVlLCBzZXRJbnB1dFZhbHVlXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZUZpbGVDaGFuZ2UgPSAoZXZlbnQ6IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XHJcbi8vICAgICBzZXRTZWxlY3RlZEZpbGUoZXZlbnQudGFyZ2V0LmZpbGVzPy5bMF0gfHwgbnVsbCk7XHJcbi8vICAgfTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlU3VibWl0ID0gYXN5bmMgKCkgPT4ge1xyXG4vLyAgICAgaWYgKCFzZWxlY3RlZEZpbGUpIHJldHVybjtcclxuLy8gICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcblxyXG4vLyAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuLy8gICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgc2VsZWN0ZWRGaWxlKTtcclxuXHJcbi8vICAgICB0cnkge1xyXG4vLyAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cDovL2xvY2FsaG9zdDozMDEyL2FwaS9hbmFseXplLWV4Y2VsXCIsIHtcclxuLy8gICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4vLyAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxyXG4vLyAgICAgICB9KTtcclxuXHJcbi8vICAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlLlwiKTtcclxuLy8gICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4vLyAgICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gcmVzdWx0LmRhdGE/LnByb2Nlc3NlZERhdGE7XHJcblxyXG4vLyAgICAgICBpZiAoIXByb2Nlc3NlZERhdGEpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzcG9uc2Ugc3RydWN0dXJlLlwiKTtcclxuXHJcbi8vICAgICAgIGNvbnN0IGxpZ2h0Q29sb3JzID0gW1xyXG4vLyAgICAgICAgIFwicmdiYSgxNzMsIDIxNiwgMjMwLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDE0NCwgMjM4LCAxNDQsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjU1LCAxODIsIDE5MywgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyNTUsIDIyOCwgMTgxLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDIyMSwgMTYwLCAyMjEsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjQwLCAyMzAsIDE0MCwgMC42KVwiLFxyXG4vLyAgICAgICBdO1xyXG5cclxuLy8gICAgICAgY29uc3QgZ2VuZXJhdGVDaGFydERhdGEgPSAoY2hhcnRUeXBlOiBzdHJpbmcpOiBDaGFydERhdGEgfCBudWxsID0+IHtcclxuLy8gICAgICAgICBjb25zdCBjaGFydEluZm8gPSBwcm9jZXNzZWREYXRhW2NoYXJ0VHlwZV0/LlswXTtcclxuLy8gICAgICAgICBpZiAoIWNoYXJ0SW5mbykgcmV0dXJuIG51bGw7XHJcblxyXG4vLyAgICAgICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5rZXlzKGNoYXJ0SW5mby5kYXRhKTtcclxuLy8gICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGNoYXJ0SW5mby5kYXRhKTtcclxuXHJcbi8vICAgICAgICAgc2V0Q2hhcnRXaWR0aChsYWJlbHMubGVuZ3RoICogMTUwKTtcclxuXHJcbi8vICAgICAgICAgcmV0dXJuIHtcclxuLy8gICAgICAgICAgIGxhYmVscyxcclxuLy8gICAgICAgICAgIGRhdGFzZXRzOiBbXHJcbi8vICAgICAgICAgICAgIHtcclxuLy8gICAgICAgICAgICAgICBsYWJlbDogY2hhcnRJbmZvLmxhYmVsIHx8IGNoYXJ0VHlwZSxcclxuLy8gICAgICAgICAgICAgICBkYXRhOiB2YWx1ZXMgYXMgbnVtYmVyW10sXHJcbi8vICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbXCJQaWUgQ2hhcnRcIiwgXCJEb251dCBDaGFydFwiLCBcIkJhciBDaGFydFwiXS5pbmNsdWRlcyhjaGFydFR5cGUpXHJcbi8vICAgICAgICAgICAgICAgICA/IGxpZ2h0Q29sb3JzLnNsaWNlKDAsIGxhYmVscy5sZW5ndGgpXHJcbi8vICAgICAgICAgICAgICAgICA6IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAwLjYpXCIsXHJcbi8vICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIilcclxuLy8gICAgICAgICAgICAgICAgID8gXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDEpXCJcclxuLy8gICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxyXG4vLyAgICAgICAgICAgICAgIGZpbGw6ICFjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgXSxcclxuLy8gICAgICAgICB9O1xyXG4vLyAgICAgICB9O1xyXG5cclxuLy8gICAgICAgc2V0Q2hhcnREYXRhKHtcclxuLy8gICAgICAgICBzY2F0dGVyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlNjYXR0ZXIgUGxvdFwiKSxcclxuLy8gICAgICAgICBwaWVDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiUGllIENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGRvbnV0Q2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkRvbnV0IENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGxpbmVDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiTGluZSBDaGFydFwiKSxcclxuLy8gICAgICAgICBiYXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiQmFyIENoYXJ0XCIpLFxyXG4vLyAgICAgICB9KTtcclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZTpcIiwgZXJyb3IpO1xyXG4vLyAgICAgfSBmaW5hbGx5IHtcclxuLy8gICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbi8vICAgICB9XHJcbi8vICAgfTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlU2VuZCA9ICgpID0+IHtcclxuLy8gICAgIGNvbnNvbGUubG9nKFwiSW5wdXQgVmFsdWU6XCIsIGlucHV0VmFsdWUpO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IGdldENoYXJ0T3B0aW9ucyA9ICh0eXBlOiBzdHJpbmcpID0+ICh7XHJcbi8vICAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4vLyAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXHJcbi8vICAgICBzY2FsZXM6IFtcInBpZUNoYXJ0RGF0YVwiLCBcImRvbnV0Q2hhcnREYXRhXCJdLmluY2x1ZGVzKHR5cGUpXHJcbi8vICAgICAgID8ge31cclxuLy8gICAgICAgOiB7XHJcbi8vICAgICAgICAgeDoge1xyXG4vLyAgICAgICAgICAgdGlja3M6IHtcclxuLy8gICAgICAgICAgICAgYXV0b1NraXA6IGZhbHNlLFxyXG4vLyAgICAgICAgICAgICBtYXhSb3RhdGlvbjogdHlwZSA9PT0gJ2JhckNoYXJ0RGF0YScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXJDaGFydERhdGEnID8gMjAgOiAxMDAsXHJcbi8vICAgICAgICAgbWluUm90YXRpb246IHR5cGUgPT09ICdiYXJDaGFydERhdGEnIHx8IHR5cGUgPT09ICdzY2F0dGVyQ2hhcnREYXRhJyA/IDAgOiA5MCxcclxuLy8gICAgICAgICAgICAgYXV0b1NraXBQYWRkaW5nOiAyMCxcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICBncmlkOiB7XHJcbi8vICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbi8vICAgICAgICAgICAgIGRyYXdUaWNrczogZmFsc2UsXHJcbi8vICAgICAgICAgICAgIHRpY2tMZW5ndGg6IDEwMCxcclxuLy8gICAgICAgICAgICAgbGluZVdpZHRoOiAxXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICB5OiB7XHJcbi8vICAgICAgICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxyXG4vLyAgICAgICAgICAgICB0aWNrczoge1xyXG4vLyAgICAgICAgICAgICAgIHByZWNpc2lvbjogMCxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgIHBsdWdpbnM6IHtcclxuLy8gICAgICAgbGVnZW5kOiB7XHJcbi8vICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICBwb3NpdGlvbjogXCJ0b3BcIixcclxuLy8gICAgICAgfSxcclxuLy8gICAgICAgdG9vbHRpcDoge1xyXG4vLyAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICB9LFxyXG4vLyAgIH0pO1xyXG5cclxuLy8gICBjb25zdCByZW5kZXJDaGFydCA9ICh0eXBlOiBzdHJpbmcsIENoYXJ0Q29tcG9uZW50OiBhbnkpID0+IHtcclxuLy8gICAgIGNvbnN0IGRhdGEgPSBjaGFydERhdGFbdHlwZV07XHJcbi8vICAgICBpZiAoIWxvYWRpbmcgJiYgZGF0YSkge1xyXG4vLyAgICAgICByZXR1cm4gKFxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZCBwLTQgYm9yZGVyIHJvdW5kZWQgc2hhZG93LXNtXCI+XHJcbi8vICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiBcIjEwMCVcIiwgb3ZlcmZsb3dYOiBcImF1dG9cIiB9fT5cclxuLy8gICAgICAgICAgICAgPGRpdlxyXG4vLyAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbi8vICAgICAgICAgICAgICAgICBtaW5XaWR0aDogW1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKVxyXG4vLyAgICAgICAgICAgICAgICAgICA/IGAke2NoYXJ0V2lkdGh9cHhgXHJcbi8vICAgICAgICAgICAgICAgICAgIDogXCJhdXRvXCIsXHJcbi8vICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiNDAwcHhcIixcclxuLy8gICAgICAgICAgICAgICB9fVxyXG4vLyAgICAgICAgICAgICA+XHJcbi8vICAgICAgICAgICAgICAgPENoYXJ0Q29tcG9uZW50IGRhdGE9e2RhdGF9IG9wdGlvbnM9e2dldENoYXJ0T3B0aW9ucyh0eXBlKX0gLz5cclxuLy8gICAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgKTtcclxuLy8gICAgIH1cclxuLy8gICAgIHJldHVybiBudWxsO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIHJldHVybiAoXHJcbi8vICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgbWQ6ZmxleC1yb3cgaC1zY3JlZW4gYm9yZGVyIGJvcmRlci1ibGFja1wiPlxyXG4vLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTEvNCBiZy13aGl0ZSBwLTUgYm9yZGVyLXQgbWQ6Ym9yZGVyLWwgbWQ6Ym9yZGVyLWJsYWNrXCI+XHJcbi8vICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5VcGxvYWQgRmlsZTwvaDI+XHJcbi8vICAgICAgICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgb25DaGFuZ2U9e2hhbmRsZUZpbGVDaGFuZ2V9IGNsYXNzTmFtZT1cImJvcmRlciBwLTIgdy1mdWxsXCIgLz5cclxuLy8gICAgICAgICA8YnV0dG9uXHJcbi8vICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVTdWJtaXR9XHJcbi8vICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlIHAtMiByb3VuZGVkIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG10LTRcIlxyXG4vLyAgICAgICAgID5cclxuLy8gICAgICAgICAgIDxCc1VwbG9hZCBjbGFzc05hbWU9XCJtci0yXCIgLz4gU3VibWl0XHJcbi8vICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHNwYWNlLXktMiBtdC00XCI+XHJcbi8vICAgICAgICAgICB7W1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiLCBcInNjYXR0ZXJDaGFydERhdGFcIiwgXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5tYXAoXHJcbi8vICAgICAgICAgICAgICh0eXBlKSA9PiAoXHJcbi8vICAgICAgICAgICAgICAgPGJ1dHRvblxyXG4vLyAgICAgICAgICAgICAgICAga2V5PXt0eXBlfVxyXG4vLyAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0U2VsZWN0ZWRDaGFydCh0eXBlKX1cclxuLy8gICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInAtMiBiZy1ncmF5LTMwMCByb3VuZGVkIGhvdmVyOmJnLWdyYXktNDAwXCJcclxuLy8gICAgICAgICAgICAgICA+XHJcbi8vICAgICAgICAgICAgICAgICB7dHlwZS5yZXBsYWNlKFwiQ2hhcnREYXRhXCIsIFwiIENoYXJ0XCIpfVxyXG4vLyAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgICAgICApXHJcbi8vICAgICAgICAgICApfVxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICA8L2Rpdj5cclxuXHJcbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMy80IGJnLWdyYXktMTAwIHAtNSBvdmVyZmxvdy1hdXRvXCI+XHJcbi8vICAgICAgICAge2xvYWRpbmcgPyAoXHJcbi8vICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIGgtZnVsbFwiPlxyXG4vLyAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwaW5uZXItYm9yZGVyIGFuaW1hdGUtc3BpbiBib3JkZXItdC00IGJvcmRlci1ibHVlLTUwMCByb3VuZGVkLWZ1bGwgdy0xMiBoLTEyXCI+PC9kaXY+XHJcbi8vICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICApIDogKFxyXG4vLyAgICAgICAgICAgcmVuZGVyQ2hhcnQoc2VsZWN0ZWRDaGFydCwge1xyXG4vLyAgICAgICAgICAgICBsaW5lQ2hhcnREYXRhOiBMaW5lLFxyXG4vLyAgICAgICAgICAgICBiYXJDaGFydERhdGE6IEJhcixcclxuLy8gICAgICAgICAgICAgc2NhdHRlckNoYXJ0RGF0YTogU2NhdHRlcixcclxuLy8gICAgICAgICAgICAgcGllQ2hhcnREYXRhOiBQaWUsXHJcbi8vICAgICAgICAgICAgIGRvbnV0Q2hhcnREYXRhOiBEb3VnaG51dCxcclxuLy8gICAgICAgICAgIH1bc2VsZWN0ZWRDaGFydF0pXHJcbi8vICAgICAgICAgKX1cclxuXHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC00IGZsZXhcIj5cclxuLy8gICAgICAgICAgIDxpbnB1dFxyXG4vLyAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXHJcbi8vICAgICAgICAgICAgIHZhbHVlPXtpbnB1dFZhbHVlfVxyXG4vLyAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldElucHV0VmFsdWUoZS50YXJnZXQudmFsdWUpfVxyXG4vLyAgICAgICAgICAgICBjbGFzc05hbWU9XCJib3JkZXIgcC0yIGZsZXgtZ3JvdyBtci0yIHJvdW5kZWRcIlxyXG4vLyAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkVudGVyIHlvdXIgdGV4dCBoZXJlXCJcclxuLy8gICAgICAgICAgIC8+XHJcbi8vICAgICAgICAgICA8YnV0dG9uXHJcbi8vICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVNlbmR9XHJcbi8vICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJnLWdyZWVuLTUwMCB0ZXh0LXdoaXRlIHAtMiByb3VuZGVkXCJcclxuLy8gICAgICAgICAgID5cclxuLy8gICAgICAgICAgICAgU2VuZFxyXG4vLyAgICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgIDwvZGl2PlxyXG4vLyAgICAgPC9kaXY+XHJcbi8vICAgKTtcclxuLy8gfVxyXG5cclxuXHJcblxyXG4vLyBcInVzZSBjbGllbnRcIjtcclxuLy8gaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG4vLyBpbXBvcnQgeyBCYXIsIExpbmUsIERvdWdobnV0LCBQaWUsIFNjYXR0ZXIgfSBmcm9tIFwicmVhY3QtY2hhcnRqcy0yXCI7XHJcbi8vIGltcG9ydCB7IENoYXJ0IGFzIENoYXJ0SlMsIENhdGVnb3J5U2NhbGUsIExpbmVhclNjYWxlLCBCYXJFbGVtZW50LCBMaW5lRWxlbWVudCwgUG9pbnRFbGVtZW50LCBBcmNFbGVtZW50LCBUaXRsZSwgVG9vbHRpcCwgTGVnZW5kIH0gZnJvbSBcImNoYXJ0LmpzXCI7XHJcbi8vIGltcG9ydCB7IEJzVXBsb2FkIH0gZnJvbSBcInJlYWN0LWljb25zL2JzXCI7XHJcbi8vIGltcG9ydCB6b29tUGx1Z2luIGZyb20gXCJjaGFydGpzLXBsdWdpbi16b29tXCI7XHJcblxyXG4vLyBDaGFydEpTLnJlZ2lzdGVyKENhdGVnb3J5U2NhbGUsIExpbmVhclNjYWxlLCBCYXJFbGVtZW50LCBMaW5lRWxlbWVudCwgUG9pbnRFbGVtZW50LCBBcmNFbGVtZW50LCBUaXRsZSwgVG9vbHRpcCwgTGVnZW5kLCB6b29tUGx1Z2luKTtcclxuXHJcbi8vIGludGVyZmFjZSBDaGFydERhdGEge1xyXG4vLyAgIGxhYmVsczogc3RyaW5nW107XHJcbi8vICAgZGF0YXNldHM6IHtcclxuLy8gICAgIGxhYmVsOiBzdHJpbmc7XHJcbi8vICAgICBkYXRhOiBudW1iZXJbXTtcclxuLy8gICAgIGJhY2tncm91bmRDb2xvcj86IHN0cmluZyB8IHN0cmluZ1tdO1xyXG4vLyAgICAgYm9yZGVyQ29sb3I/OiBzdHJpbmc7XHJcbi8vICAgICBmaWxsPzogYm9vbGVhbjtcclxuLy8gICB9W11cclxuLy8gICBtZXRhPzoge1xyXG4vLyAgICAgaGVhZGVyOiBzdHJpbmc7XHJcbi8vICAgICB2YWx1ZU5hbWU6IHN0cmluZztcclxuLy8gICB9O1xyXG4vLyB9XHJcblxyXG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEYXNoYm9hcmQoKSB7XHJcbi8vICAgY29uc3QgW2NoYXJ0RGF0YSwgc2V0Q2hhcnREYXRhXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIENoYXJ0RGF0YSB8IG51bGw+Pih7XHJcbi8vICAgICBzY2F0dGVyQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgcGllQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgZG9udXRDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBsaW5lQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgYmFyQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgIH0pO1xyXG4vLyAgIGNvbnN0IFtzZWxlY3RlZEZpbGUsIHNldFNlbGVjdGVkRmlsZV0gPSB1c2VTdGF0ZTxGaWxlIHwgbnVsbD4obnVsbCk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkQ2hhcnQsIHNldFNlbGVjdGVkQ2hhcnRdID0gdXNlU3RhdGU8c3RyaW5nPihcImxpbmVDaGFydERhdGFcIik7XHJcbi8vICAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG4vLyAgIGNvbnN0IFtjaGFydFdpZHRoLCBzZXRDaGFydFdpZHRoXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XHJcbi8vICAgY29uc3QgW2lucHV0VmFsdWUsIHNldElucHV0VmFsdWVdID0gdXNlU3RhdGU8c3RyaW5nPihcIlwiKTtcclxuLy8gICBjb25zdCBbc3RvcmVkUHJvY2Vzc2VkRGF0YSwgc2V0U3RvcmVkUHJvY2Vzc2VkRGF0YV0gPSB1c2VTdGF0ZTxhbnk+KG51bGwpOyAvLyBOZXcgc3RhdGUgdG8gc3RvcmUgcHJvY2Vzc2VkIGRhdGFcclxuLy8gICBjb25zdCBbY29tYmluZWRJbnNpZ2h0cywgc2V0Q29tYmluZWRJbnNpZ2h0c10gPSB1c2VTdGF0ZTxhbnk+KG51bGwpO1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVGaWxlQ2hhbmdlID0gKGV2ZW50OiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xyXG4vLyAgICAgc2V0U2VsZWN0ZWRGaWxlKGV2ZW50LnRhcmdldC5maWxlcz8uWzBdIHx8IG51bGwpO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IGFzeW5jICgpID0+IHtcclxuLy8gICAgIGlmICghc2VsZWN0ZWRGaWxlKSByZXR1cm47XHJcbi8vICAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG5cclxuLy8gICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbi8vICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIHNlbGVjdGVkRmlsZSk7XHJcblxyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHA6Ly9sb2NhbGhvc3Q6MzAxMi9hcGkvYW5hbHl6ZS1leGNlbFwiLCB7XHJcbi8vICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuLy8gICAgICAgICBib2R5OiBmb3JtRGF0YSxcclxuLy8gICAgICAgfSk7XHJcblxyXG4vLyAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZS5cIik7XHJcbi8vICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuLy8gICAgICAgY29uc3QgY29tYmluZWRJbnNpZ2h0cyA9IHJlc3VsdC5kYXRhPy5jb21iaW5lZEluc2lnaHRzO1xyXG4vLyAgICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gcmVzdWx0LmRhdGE/LnByb2Nlc3NlZERhdGE7XHJcblxyXG4vLyAgICAgICBpZiAoIXByb2Nlc3NlZERhdGEpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzcG9uc2Ugc3RydWN0dXJlLlwiKTtcclxuLy8gY29uc29sZS5sb2coXCJwcm9jZXNzZWREYXRhXCIscHJvY2Vzc2VkRGF0YSk7XHJcblxyXG4vLyAgICAgICBzZXRTdG9yZWRQcm9jZXNzZWREYXRhKHByb2Nlc3NlZERhdGEpOyAvLyBTdG9yZSB0aGUgcHJvY2Vzc2VkIGRhdGFcclxuLy8gICAgICAgc2V0Q29tYmluZWRJbnNpZ2h0cyhjb21iaW5lZEluc2lnaHRzKTtcclxuLy8gICAgICAgY29uc3QgbGlnaHRDb2xvcnMgPSBbXHJcbi8vICAgICAgICAgXCJyZ2JhKDE3MywgMjE2LCAyMzAsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMTQ0LCAyMzgsIDE0NCwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyNTUsIDE4MiwgMTkzLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDI1NSwgMjI4LCAxODEsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjIxLCAxNjAsIDIyMSwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyNDAsIDIzMCwgMTQwLCAwLjYpXCIsXHJcbi8vICAgICAgIF07XHJcblxyXG4vLyAgICAgICBjb25zdCBnZW5lcmF0ZUNoYXJ0RGF0YSA9IChjaGFydFR5cGU6IHN0cmluZyk6IENoYXJ0RGF0YSB8IG51bGwgPT4ge1xyXG4vLyAgICAgICAgIGNvbnN0IGNoYXJ0SW5mbyA9IHByb2Nlc3NlZERhdGFbY2hhcnRUeXBlXT8uWzBdO1xyXG4vLyAgICAgICAgIGlmICghY2hhcnRJbmZvKSByZXR1cm4gbnVsbDtcclxuXHJcbi8vICAgICAgICAgY29uc3QgbGFiZWxzID0gT2JqZWN0LmtleXMoY2hhcnRJbmZvLmRhdGEpO1xyXG4vLyAgICAgICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoY2hhcnRJbmZvLmRhdGEpO1xyXG5cclxuLy8gICAgICAgICBzZXRDaGFydFdpZHRoKGxhYmVscy5sZW5ndGggKiAxNTApO1xyXG5cclxuLy8gICAgICAgICByZXR1cm4ge1xyXG4vLyAgICAgICAgICAgbGFiZWxzLFxyXG4vLyAgICAgICAgICAgZGF0YXNldHM6IFtcclxuLy8gICAgICAgICAgICAge1xyXG4vLyAgICAgICAgICAgICAgIGxhYmVsOiBjaGFydEluZm8ubGFiZWwgfHwgY2hhcnRUeXBlLFxyXG4vLyAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlcyBhcyBudW1iZXJbXSxcclxuLy8gICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcIlBpZSBDaGFydFwiLCBcIkRvbnV0IENoYXJ0XCIsIFwiQmFyIENoYXJ0XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSlcclxuLy8gICAgICAgICAgICAgICAgID8gbGlnaHRDb2xvcnMuc2xpY2UoMCwgbGFiZWxzLmxlbmd0aClcclxuLy8gICAgICAgICAgICAgICAgIDogXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDAuNilcIixcclxuLy8gICAgICAgICAgICAgICBib3JkZXJDb2xvcjogY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSA/IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAxKVwiIDogdW5kZWZpbmVkLFxyXG4vLyAgICAgICAgICAgICAgIGZpbGw6ICFjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgXSxcclxuLy8gICAgICAgICAgIG1ldGE6IHtcclxuLy8gICAgICAgICAgICAgaGVhZGVyOiBjaGFydEluZm8uaGVhZGVyIHx8IFwiZGVmYXVsdF9oZWFkZXJcIixcclxuLy8gICAgICAgICAgICAgdmFsdWVOYW1lOiBjaGFydEluZm8udmFsdWVOYW1lIHx8IFwiZGVmYXVsdF92YWx1ZU5hbWVcIixcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfTtcclxuLy8gICAgICAgfTtcclxuXHJcbi8vICAgICAgIHNldENoYXJ0RGF0YSh7XHJcbi8vICAgICAgICAgc2NhdHRlckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJTY2F0dGVyIFBsb3RcIiksXHJcbi8vICAgICAgICAgcGllQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlBpZSBDaGFydFwiKSxcclxuLy8gICAgICAgICBkb251dENoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJEb251dCBDaGFydFwiKSxcclxuLy8gICAgICAgICBsaW5lQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkxpbmUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgYmFyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkJhciBDaGFydFwiKSxcclxuLy8gICAgICAgfSk7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGU6XCIsIGVycm9yKTtcclxuLy8gICAgIH0gZmluYWxseSB7XHJcbi8vICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH07XHJcblxyXG4gXHJcbi8vICAgY29uc3QgaGFuZGxlU2VuZCA9IGFzeW5jICgpID0+IHtcclxuLy8gICAgIGlmICghaW5wdXRWYWx1ZSkgcmV0dXJuO1xyXG4gIFxyXG4vLyAgICAgY29uc3QgZ3JhcGhEYXRhID0gY2hhcnREYXRhW3NlbGVjdGVkQ2hhcnRdO1xyXG4vLyAgICAgaWYgKCFncmFwaERhdGEpIHJldHVybjtcclxuICBcclxuLy8gICAgIGNvbnN0IGxhYmVscyA9IGdyYXBoRGF0YS5sYWJlbHM7XHJcbi8vICAgICBjb25zdCB2YWx1ZXMgPSBncmFwaERhdGEuZGF0YXNldHNbMF0uZGF0YTtcclxuICBcclxuLy8gICAgIGNvbnN0IGRhdGFPYmplY3QgPSBsYWJlbHMucmVkdWNlKChvYmo6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0sIGxhYmVsLCBpbmRleCkgPT4ge1xyXG4vLyAgICAgICBvYmpbbGFiZWxdID0gdmFsdWVzW2luZGV4XTtcclxuLy8gICAgICAgcmV0dXJuIG9iajtcclxuLy8gICAgIH0sIHt9KTtcclxuICBcclxuLy8gICAgIGNvbnN0IGNoYXJ0VHlwZU1hcHBpbmc6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XHJcbi8vICAgICAgIGxpbmVDaGFydERhdGE6IFwiTGluZSBDaGFydFwiLFxyXG4vLyAgICAgICBwaWVDaGFydERhdGE6IFwiUGllIENoYXJ0XCIsXHJcbi8vICAgICAgIGRvbnV0Q2hhcnREYXRhOiBcIkRvbnV0IENoYXJ0XCIsXHJcbi8vICAgICAgIGJhckNoYXJ0RGF0YTogXCJCYXIgQ2hhcnRcIixcclxuLy8gICAgICAgc2NhdHRlckNoYXJ0RGF0YTogXCJTY2F0dGVyIFBsb3RcIixcclxuLy8gICAgIH07XHJcbiAgXHJcbi8vICAgICBjb25zdCBzZWxlY3RlZENoYXJ0VHlwZSA9IGNoYXJ0VHlwZU1hcHBpbmdbc2VsZWN0ZWRDaGFydF0gfHwgc2VsZWN0ZWRDaGFydDtcclxuICBcclxuLy8gICAgIC8vIEZpbHRlciB0aGUgc3RvcmVkIHByb2Nlc3NlZCBkYXRhIHRvIGluY2x1ZGUgb25seSB0aGUgc2VsZWN0ZWQgY2hhcnQncyBkYXRhXHJcbi8vICAgICBjb25zdCBmaWx0ZXJlZFByb2Nlc3NlZERhdGEgPSB7XHJcbi8vICAgICAgIFtzZWxlY3RlZENoYXJ0VHlwZV06IHN0b3JlZFByb2Nlc3NlZERhdGFbc2VsZWN0ZWRDaGFydFR5cGVdLFxyXG4vLyAgICAgfTtcclxuICBcclxuLy8gICAgIGNvbnNvbGUubG9nKFwiLi4uZmlsdGVyZWRQcm9jZXNzZWREYXRhLFwiLCBmaWx0ZXJlZFByb2Nlc3NlZERhdGFbc2VsZWN0ZWRDaGFydFR5cGVdPy5bMF0/LmRhdGEpO1xyXG4vLyAgICAgY29uc29sZS5sb2coXCJkYXRhT2JqZWN0LFwiLCBkYXRhT2JqZWN0KTtcclxuICBcclxuLy8gICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xyXG4vLyAgICAgICBxdWVzdGlvbjogaW5wdXRWYWx1ZSxcclxuLy8gICAgICAgcHJvY2Vzc2VkRGF0YToge1xyXG4vLyAgICAgICAgIC8vIEluY2x1ZGUgdGhlIHN0b3JlZCBwcm9jZXNzZWQgZGF0YVxyXG4vLyAgICAgICAgIFtzZWxlY3RlZENoYXJ0VHlwZV06IFtcclxuLy8gICAgICAgICAgIHtcclxuLy8gICAgICAgICAgICAgaGVhZGVyOiBncmFwaERhdGEubWV0YT8uaGVhZGVyIHx8IFwiZGVmYXVsdF9oZWFkZXJcIixcclxuLy8gICAgICAgICAgICAgdmFsdWVOYW1lOiBncmFwaERhdGEubWV0YT8udmFsdWVOYW1lIHx8IFwiZGVmYXVsdF92YWx1ZU5hbWVcIixcclxuLy8gICAgICAgICAgICAgbGFiZWw6IGdyYXBoRGF0YS5kYXRhc2V0c1swXS5sYWJlbCxcclxuLy8gICAgICAgICAgICAgZGF0YTogZmlsdGVyZWRQcm9jZXNzZWREYXRhW3NlbGVjdGVkQ2hhcnRUeXBlXT8uWzBdPy5kYXRhLFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICBdLFxyXG4vLyAgICAgICB9LFxyXG4vLyAgICAgfTtcclxuICBcclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcbi8vICAgICAgICAgYGh0dHA6Ly9sb2NhbGhvc3Q6MzAxMi9hcGkvYW5zd2VyLWFuYWx5emUtZXhjZWw/cXVlc3Rpb249JHtlbmNvZGVVUklDb21wb25lbnQoaW5wdXRWYWx1ZSl9YCxcclxuLy8gICAgICAgICB7XHJcbi8vICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4vLyAgICAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxyXG4vLyAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxyXG4vLyAgICAgICAgIH1cclxuLy8gICAgICAgKTtcclxuICBcclxuLy8gICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGUuXCIpO1xyXG4vLyAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbi8vICAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSByZXN1bHQuZGF0YT8ucHJvY2Vzc2VkRGF0YTtcclxuICBcclxuLy8gICAgICAgaWYgKCFwcm9jZXNzZWREYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZS5cIik7XHJcbiAgXHJcbi8vICAgICAgIGNvbnNvbGUubG9nKFwiVXBkYXRlZCBBUEkgUmVzcG9uc2UgRGF0YTpcIiwgcHJvY2Vzc2VkRGF0YSk7XHJcbiAgXHJcbi8vICAgICAgIGNvbnN0IGdlbmVyYXRlQ2hhcnREYXRhID0gKGNoYXJ0VHlwZTogc3RyaW5nKTogQ2hhcnREYXRhIHwgbnVsbCA9PiB7XHJcbi8vICAgICAgICAgY29uc3QgY2hhcnRJbmZvID0gcHJvY2Vzc2VkRGF0YVtjaGFydFR5cGVdPy5bMF07IC8vIFVzZSBvbmx5IEFQSSByZXNwb25zZSBkYXRhXHJcbi8vICAgICAgICAgaWYgKCFjaGFydEluZm8pIHJldHVybiBudWxsO1xyXG4gIFxyXG4vLyAgICAgICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5rZXlzKGNoYXJ0SW5mby5kYXRhKTtcclxuLy8gICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGNoYXJ0SW5mby5kYXRhKTtcclxuICBcclxuLy8gICAgICAgICBzZXRDaGFydFdpZHRoKGxhYmVscy5sZW5ndGggKiAxNTApO1xyXG4gIFxyXG4vLyAgICAgICAgIHJldHVybiB7XHJcbi8vICAgICAgICAgICBsYWJlbHMsXHJcbi8vICAgICAgICAgICBkYXRhc2V0czogW1xyXG4vLyAgICAgICAgICAgICB7XHJcbi8vICAgICAgICAgICAgICAgbGFiZWw6IGNoYXJ0SW5mby5sYWJlbCB8fCBjaGFydFR5cGUsXHJcbi8vICAgICAgICAgICAgICAgZGF0YTogdmFsdWVzIGFzIG51bWJlcltdLFxyXG4vLyAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogW1wiUGllIENoYXJ0XCIsIFwiRG9udXQgQ2hhcnRcIiwgXCJCYXIgQ2hhcnRcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKVxyXG4vLyAgICAgICAgICAgICAgICAgPyBbXCJyZ2JhKDE3MywgMjE2LCAyMzAsIDAuNilcIiwgXCJyZ2JhKDE0NCwgMjM4LCAxNDQsIDAuNilcIiwgXCJyZ2JhKDI1NSwgMTgyLCAxOTMsIDAuNilcIl1cclxuLy8gICAgICAgICAgICAgICAgIDogXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDAuNilcIixcclxuLy8gICAgICAgICAgICAgICBib3JkZXJDb2xvcjogY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSA/IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAxKVwiIDogdW5kZWZpbmVkLFxyXG4vLyAgICAgICAgICAgICAgIGZpbGw6ICFjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgXSxcclxuLy8gICAgICAgICAgIG1ldGE6IHtcclxuLy8gICAgICAgICAgICAgaGVhZGVyOiBjaGFydEluZm8uaGVhZGVyIHx8IFwiZGVmYXVsdF9oZWFkZXJcIixcclxuLy8gICAgICAgICAgICAgdmFsdWVOYW1lOiBjaGFydEluZm8udmFsdWVOYW1lIHx8IFwiZGVmYXVsdF92YWx1ZU5hbWVcIixcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfTtcclxuLy8gICAgICAgfTtcclxuICBcclxuLy8gICAgICAgLy8gT25seSB1cGRhdGUgY2hhcnREYXRhIHdpdGhvdXQgc3RvcmluZyBpbiBzdG9yZWRQcm9jZXNzZWREYXRhXHJcbi8vICAgICAgIHNldENoYXJ0RGF0YSgocHJldkNoYXJ0RGF0YSkgPT4gKHtcclxuLy8gICAgICAgICAuLi5wcmV2Q2hhcnREYXRhLFxyXG4vLyAgICAgICAgIFtzZWxlY3RlZENoYXJ0XTogZ2VuZXJhdGVDaGFydERhdGEoc2VsZWN0ZWRDaGFydFR5cGUpLFxyXG4vLyAgICAgICB9KSk7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2VuZGluZyByZXF1ZXN0OlwiLCBlcnJvcik7XHJcbi8vICAgICB9IGZpbmFsbHkge1xyXG4vLyAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuLy8gICAgIH1cclxuLy8gICB9O1xyXG4gIFxyXG5cclxuLy8gICBjb25zdCBnZXRDaGFydE9wdGlvbnMgPSAodHlwZTogc3RyaW5nKSA9PiAoe1xyXG4vLyAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuLy8gICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxyXG4vLyAgICAgc2NhbGVzOiBbXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKVxyXG4vLyAgICAgICA/IHt9XHJcbi8vICAgICAgIDoge1xyXG4vLyAgICAgICAgIHg6IHtcclxuLy8gICAgICAgICAgIHRpY2tzOiB7XHJcbi8vICAgICAgICAgICAgIGF1dG9Ta2lwOiBmYWxzZSxcclxuLy8gICAgICAgICAgICAgbWF4Um90YXRpb246IHR5cGUgPT09ICdiYXJDaGFydERhdGEnIHx8IHR5cGUgPT09ICdzY2F0dGVyQ2hhcnREYXRhJyA/IDIwIDogMTAwLFxyXG4vLyAgICAgICAgIG1pblJvdGF0aW9uOiB0eXBlID09PSAnYmFyQ2hhcnREYXRhJyB8fCB0eXBlID09PSAnc2NhdHRlckNoYXJ0RGF0YScgPyAwIDogOTAsXHJcbi8vICAgICAgICAgICAgIGF1dG9Ta2lwUGFkZGluZzogMjAsXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgZ3JpZDoge1xyXG4vLyAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4vLyAgICAgICAgICAgICBkcmF3VGlja3M6IGZhbHNlLFxyXG4vLyAgICAgICAgICAgICB0aWNrTGVuZ3RoOiAxMDAsXHJcbi8vICAgICAgICAgICAgIGxpbmVXaWR0aDogMVxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgICAgIHk6IHtcclxuLy8gICAgICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxyXG4vLyAgICAgICAgICAgdGlja3M6IHsgcHJlY2lzaW9uOiAwIH0sXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgICAgfSxcclxuLy8gICAgIHBsdWdpbnM6IHtcclxuLy8gICAgICAgbGVnZW5kOiB7IGRpc3BsYXk6IHRydWUsIHBvc2l0aW9uOiBcInRvcFwiIH0sXHJcbi8vICAgICAgIHRvb2x0aXA6IHsgZW5hYmxlZDogdHJ1ZSB9LFxyXG4vLyAgICAgfSxcclxuLy8gICB9KTtcclxuXHJcbi8vICAgY29uc3QgcmVuZGVyQ2hhcnQgPSAodHlwZTogc3RyaW5nLCBDaGFydENvbXBvbmVudDogYW55KSA9PiB7XHJcbi8vICAgICBjb25zdCBkYXRhID0gY2hhcnREYXRhW3R5cGVdO1xyXG4vLyAgICAgaWYgKCFsb2FkaW5nICYmIGRhdGEpIHtcclxuLy8gICAgICAgcmV0dXJuIChcclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQgcC00IGJvcmRlciByb3VuZGVkIHNoYWRvdy1zbVwiPlxyXG4vLyAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogXCIxMDAlXCIsIG92ZXJmbG93WDogXCJhdXRvXCIgfX0+XHJcbi8vICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgbWluV2lkdGg6IFtcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSkgPyBgJHtjaGFydFdpZHRofXB4YCA6IFwiYXV0b1wiLCBoZWlnaHQ6IFwiNDAwcHhcIiB9fT5cclxuLy8gICAgICAgICAgICAgICA8Q2hhcnRDb21wb25lbnQgZGF0YT17ZGF0YX0gb3B0aW9ucz17Z2V0Q2hhcnRPcHRpb25zKHR5cGUpfSAvPlxyXG4vLyAgICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICApO1xyXG4vLyAgICAgfVxyXG4vLyAgICAgcmV0dXJuIG51bGw7XHJcbi8vICAgfTtcclxuLy8gICByZXR1cm4gKFxyXG4vLyAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIG1kOmZsZXgtcm93IGgtc2NyZWVuIGJvcmRlciBib3JkZXItYmxhY2tcIj5cclxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0xLzQgYmctd2hpdGUgcC01IGJvcmRlci10IG1kOmJvcmRlci1sIG1kOmJvcmRlci1ibGFja1wiPlxyXG4vLyAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+VXBsb2FkIEZpbGU8L2gyPlxyXG4vLyAgICAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIG9uQ2hhbmdlPXtoYW5kbGVGaWxlQ2hhbmdlfSBjbGFzc05hbWU9XCJib3JkZXIgcC0yIHctZnVsbFwiIC8+XHJcbi8vICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtoYW5kbGVTdWJtaXR9IGNsYXNzTmFtZT1cImJnLWJsdWUtNTAwIHRleHQtd2hpdGUgcC0yIHJvdW5kZWQgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgbXQtNFwiPlxyXG4vLyAgICAgICAgICAgPEJzVXBsb2FkIGNsYXNzTmFtZT1cIm1yLTJcIiAvPiBTdWJtaXRcclxuLy8gICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgc3BhY2UteS0yIG10LTRcIj5cclxuLy8gICAgICAgICAgIHtbXCJsaW5lQ2hhcnREYXRhXCIsIFwiYmFyQ2hhcnREYXRhXCIsIFwic2NhdHRlckNoYXJ0RGF0YVwiLCBcInBpZUNoYXJ0RGF0YVwiLCBcImRvbnV0Q2hhcnREYXRhXCJdLm1hcCgodHlwZSkgPT4gKFxyXG4vLyAgICAgICAgICAgICA8YnV0dG9uIGtleT17dHlwZX0gb25DbGljaz17KCkgPT4gc2V0U2VsZWN0ZWRDaGFydCh0eXBlKX0gY2xhc3NOYW1lPVwicC0yIGJnLWdyYXktMzAwIHJvdW5kZWQgaG92ZXI6YmctZ3JheS00MDBcIj5cclxuLy8gICAgICAgICAgICAgICB7dHlwZS5yZXBsYWNlKFwiQ2hhcnREYXRhXCIsIFwiIENoYXJ0XCIpfVxyXG4vLyAgICAgICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgICAgICkpfVxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0zLzQgYmctZ3JheS0xMDAgcC01IG92ZXJmbG93LWF1dG9cIj5cclxuLy8gICAgICAgICB7bG9hZGluZyA/IChcclxuLy8gICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgaC1mdWxsXCI+XHJcbi8vICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3Bpbm5lci1ib3JkZXIgYW5pbWF0ZS1zcGluIGJvcmRlci10LTQgYm9yZGVyLWJsdWUtNTAwIHJvdW5kZWQtZnVsbCB3LTEyIGgtMTJcIj48L2Rpdj5cclxuLy8gICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICkgOiAoXHJcbi8vICAgICAgICAgICBzZWxlY3RlZENoYXJ0ICYmIHJlbmRlckNoYXJ0KHNlbGVjdGVkQ2hhcnQsIHsgbGluZUNoYXJ0RGF0YTogTGluZSwgYmFyQ2hhcnREYXRhOiBCYXIsIHNjYXR0ZXJDaGFydERhdGE6IFNjYXR0ZXIsIHBpZUNoYXJ0RGF0YTogUGllLCBkb251dENoYXJ0RGF0YTogRG91Z2hudXQgfVtzZWxlY3RlZENoYXJ0XSlcclxuLy8gICAgICAgICApfVxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtNCBmbGV4XCI+XHJcbi8vICAgICAgICAgICA8aW5wdXRcclxuLy8gICAgICAgICAgICAgdHlwZT1cInRleHRcIlxyXG4vLyAgICAgICAgICAgICB2YWx1ZT17aW5wdXRWYWx1ZX1cclxuLy8gICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRJbnB1dFZhbHVlKGUudGFyZ2V0LnZhbHVlKX1cclxuLy8gICAgICAgICAgICAgY2xhc3NOYW1lPVwiYm9yZGVyIHAtMiBmbGV4LWdyb3cgbXItMiByb3VuZGVkXCJcclxuLy8gICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJFbnRlciB5b3VyIHRleHQgaGVyZVwiXHJcbi8vICAgICAgICAgICAvPlxyXG4vLyAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtoYW5kbGVTZW5kfSBjbGFzc05hbWU9XCJiZy1ncmVlbi01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZFwiPlxyXG4vLyAgICAgICAgICAgICBTZW5kXHJcbi8vICAgICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTQgcC00IGJvcmRlciBib3JkZXItZ3JheS0zMDAgcm91bmRlZCBiZy13aGl0ZVwiPlxyXG4vLyAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+SW5zaWdodHM8L2gzPlxyXG4vLyAgICAgICAgIHtjb21iaW5lZEluc2lnaHRzID8gKFxyXG4vLyAgICAgICAgICAgICA8b2wgY2xhc3NOYW1lPVwibGlzdC1kZWNpbWFsIGxpc3QtaW5zaWRlIHRleHQtc20gdGV4dC1ncmF5LTcwMCBiZy1ncmF5LTEwMCBwLTIgcm91bmRlZCBvdmVyZmxvdy1hdXRvXCI+XHJcbi8vICAgICAgICAgICAgIHtjb21iaW5lZEluc2lnaHRzLnNwbGl0KCdcXG4nKS5tYXAoKGluc2lnaHQsIGluZGV4KSA9PiAoXHJcbi8vICAgICAgICAgICAgICAgPHVsIGtleT17aW5kZXh9PntpbnNpZ2h0fTwvdWw+XHJcbi8vICAgICAgICAgICAgICkpfVxyXG4vLyAgICAgICAgICAgPC9vbD5cclxuLy8gICAgICAgICApIDogKFxyXG4vLyAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTUwMFwiPk5vIGluc2lnaHRzIGF2YWlsYWJsZS48L3A+XHJcbi8vICAgICAgICAgKX1cclxuLy8gICAgICAgPC9kaXY+XHJcbi8vICAgICAgIDwvZGl2PlxyXG4vLyAgICAgPC9kaXY+XHJcbi8vICAgKTtcclxuLy8gfVxyXG5cclxuLy8gXCJ1c2UgY2xpZW50XCI7XHJcbi8vIGltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xyXG4vLyBpbXBvcnQgeyBCYXIsIExpbmUsIERvdWdobnV0LCBQaWUsIFNjYXR0ZXIgfSBmcm9tIFwicmVhY3QtY2hhcnRqcy0yXCI7XHJcbi8vIGltcG9ydCB7IENoYXJ0IGFzIENoYXJ0SlMsIENhdGVnb3J5U2NhbGUsIExpbmVhclNjYWxlLCBCYXJFbGVtZW50LCBMaW5lRWxlbWVudCwgUG9pbnRFbGVtZW50LCBBcmNFbGVtZW50LCBUaXRsZSwgVG9vbHRpcCwgTGVnZW5kIH0gZnJvbSBcImNoYXJ0LmpzXCI7XHJcbi8vIGltcG9ydCB7IEJzVXBsb2FkIH0gZnJvbSBcInJlYWN0LWljb25zL2JzXCI7XHJcbi8vIGltcG9ydCB6b29tUGx1Z2luIGZyb20gXCJjaGFydGpzLXBsdWdpbi16b29tXCI7XHJcbi8vIGltcG9ydCBodG1sMmNhbnZhcyBmcm9tIFwiaHRtbDJjYW52YXNcIjtcclxuLy8gaW1wb3J0IGpzUERGIGZyb20gXCJqc3BkZlwiO1xyXG5cclxuLy8gQ2hhcnRKUy5yZWdpc3RlcihDYXRlZ29yeVNjYWxlLCBMaW5lYXJTY2FsZSwgQmFyRWxlbWVudCwgTGluZUVsZW1lbnQsIFBvaW50RWxlbWVudCwgQXJjRWxlbWVudCwgVGl0bGUsIFRvb2x0aXAsIExlZ2VuZCwgem9vbVBsdWdpbik7XHJcblxyXG4vLyBpbnRlcmZhY2UgQ2hhcnREYXRhIHtcclxuLy8gICBsYWJlbHM6IHN0cmluZ1tdO1xyXG4vLyAgIGRhdGFzZXRzOiB7XHJcbi8vICAgICBsYWJlbDogc3RyaW5nO1xyXG4vLyAgICAgZGF0YTogbnVtYmVyW107XHJcbi8vICAgICBiYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmcgfCBzdHJpbmdbXTtcclxuLy8gICAgIGJvcmRlckNvbG9yPzogc3RyaW5nO1xyXG4vLyAgICAgZmlsbD86IGJvb2xlYW47XHJcbi8vICAgfVtdXHJcbi8vICAgbWV0YT86IHtcclxuLy8gICAgIGhlYWRlcjogc3RyaW5nO1xyXG4vLyAgICAgdmFsdWVOYW1lOiBzdHJpbmc7XHJcbi8vICAgfTtcclxuLy8gfVxyXG5cclxuLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGFzaGJvYXJkKCkge1xyXG4vLyAgIGNvbnN0IFtjaGFydERhdGEsIHNldENoYXJ0RGF0YV0gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBDaGFydERhdGEgfCBudWxsPj4oe1xyXG4vLyAgICAgc2NhdHRlckNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIHBpZUNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGRvbnV0Q2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgbGluZUNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGJhckNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICB9KTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRGaWxlLCBzZXRTZWxlY3RlZEZpbGVdID0gdXNlU3RhdGU8RmlsZSB8IG51bGw+KG51bGwpO1xyXG4vLyAgIGNvbnN0IFtzZWxlY3RlZENoYXJ0LCBzZXRTZWxlY3RlZENoYXJ0XSA9IHVzZVN0YXRlPHN0cmluZz4oXCJsaW5lQ2hhcnREYXRhXCIpO1xyXG4vLyAgIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcclxuLy8gICBjb25zdCBbY2hhcnRXaWR0aCwgc2V0Q2hhcnRXaWR0aF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xyXG4vLyAgIGNvbnN0IFtpbnB1dFZhbHVlLCBzZXRJbnB1dFZhbHVlXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XHJcbi8vICAgY29uc3QgW3N0b3JlZFByb2Nlc3NlZERhdGEsIHNldFN0b3JlZFByb2Nlc3NlZERhdGFdID0gdXNlU3RhdGU8YW55PihudWxsKTsgLy8gTmV3IHN0YXRlIHRvIHN0b3JlIHByb2Nlc3NlZCBkYXRhXHJcbi8vICAgY29uc3QgW2NvbWJpbmVkSW5zaWdodHMsIHNldENvbWJpbmVkSW5zaWdodHNdID0gdXNlU3RhdGU8YW55PihudWxsKTtcclxuLy8gICBjb25zdCBjaGFydFJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7IC8vIFJlZiBmb3IgdGhlIGNoYXJ0IGNvbnRhaW5lclxyXG5cclxuLy8gICBjb25zdCBoYW5kbGVGaWxlQ2hhbmdlID0gKGV2ZW50OiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xyXG4vLyAgICAgc2V0U2VsZWN0ZWRGaWxlKGV2ZW50LnRhcmdldC5maWxlcz8uWzBdIHx8IG51bGwpO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IGFzeW5jICgpID0+IHtcclxuLy8gICAgIGlmICghc2VsZWN0ZWRGaWxlKSByZXR1cm47XHJcbi8vICAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG5cclxuLy8gICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbi8vICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIHNlbGVjdGVkRmlsZSk7XHJcblxyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHA6Ly9sb2NhbGhvc3Q6MzAxMi9hcGkvYW5hbHl6ZS1leGNlbFwiLCB7XHJcbi8vICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuLy8gICAgICAgICBib2R5OiBmb3JtRGF0YSxcclxuLy8gICAgICAgfSk7XHJcblxyXG4vLyAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZS5cIik7XHJcbi8vICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuLy8gICAgICAgY29uc3QgY29tYmluZWRJbnNpZ2h0cyA9IHJlc3VsdC5kYXRhPy5jb21iaW5lZEluc2lnaHRzO1xyXG4vLyAgICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gcmVzdWx0LmRhdGE/LnByb2Nlc3NlZERhdGE7XHJcblxyXG4vLyAgICAgICBpZiAoIXByb2Nlc3NlZERhdGEpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzcG9uc2Ugc3RydWN0dXJlLlwiKTtcclxuLy8gY29uc29sZS5sb2coXCJwcm9jZXNzZWREYXRhXCIscHJvY2Vzc2VkRGF0YSk7XHJcblxyXG4vLyAgICAgICBzZXRTdG9yZWRQcm9jZXNzZWREYXRhKHByb2Nlc3NlZERhdGEpOyAvLyBTdG9yZSB0aGUgcHJvY2Vzc2VkIGRhdGFcclxuLy8gICAgICAgc2V0Q29tYmluZWRJbnNpZ2h0cyhjb21iaW5lZEluc2lnaHRzKTtcclxuLy8gICAgICAgY29uc3QgbGlnaHRDb2xvcnMgPSBbXHJcbi8vICAgICAgICAgXCJyZ2JhKDE3MywgMjE2LCAyMzAsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMTQ0LCAyMzgsIDE0NCwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyNTUsIDE4MiwgMTkzLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDI1NSwgMjI4LCAxODEsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjIxLCAxNjAsIDIyMSwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyNDAsIDIzMCwgMTQwLCAwLjYpXCIsXHJcbi8vICAgICAgIF07XHJcblxyXG4vLyAgICAgICBjb25zdCBnZW5lcmF0ZUNoYXJ0RGF0YSA9IChjaGFydFR5cGU6IHN0cmluZyk6IENoYXJ0RGF0YSB8IG51bGwgPT4ge1xyXG4vLyAgICAgICAgIGNvbnN0IGNoYXJ0SW5mbyA9IHByb2Nlc3NlZERhdGFbY2hhcnRUeXBlXT8uWzBdO1xyXG4vLyAgICAgICAgIGlmICghY2hhcnRJbmZvKSByZXR1cm4gbnVsbDtcclxuXHJcbi8vICAgICAgICAgY29uc3QgbGFiZWxzID0gT2JqZWN0LmtleXMoY2hhcnRJbmZvLmRhdGEpO1xyXG4vLyAgICAgICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoY2hhcnRJbmZvLmRhdGEpO1xyXG5cclxuLy8gICAgICAgICBzZXRDaGFydFdpZHRoKGxhYmVscy5sZW5ndGggKiAxNTApO1xyXG5cclxuLy8gICAgICAgICByZXR1cm4ge1xyXG4vLyAgICAgICAgICAgbGFiZWxzLFxyXG4vLyAgICAgICAgICAgZGF0YXNldHM6IFtcclxuLy8gICAgICAgICAgICAge1xyXG4vLyAgICAgICAgICAgICAgIGxhYmVsOiBjaGFydEluZm8ubGFiZWwgfHwgY2hhcnRUeXBlLFxyXG4vLyAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlcyBhcyBudW1iZXJbXSxcclxuLy8gICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcIlBpZSBDaGFydFwiLCBcIkRvbnV0IENoYXJ0XCIsIFwiQmFyIENoYXJ0XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSlcclxuLy8gICAgICAgICAgICAgICAgID8gbGlnaHRDb2xvcnMuc2xpY2UoMCwgbGFiZWxzLmxlbmd0aClcclxuLy8gICAgICAgICAgICAgICAgIDogXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDAuNilcIixcclxuLy8gICAgICAgICAgICAgICBib3JkZXJDb2xvcjogY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSA/IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAxKVwiIDogdW5kZWZpbmVkLFxyXG4vLyAgICAgICAgICAgICAgIGZpbGw6ICFjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgXSxcclxuLy8gICAgICAgICAgIG1ldGE6IHtcclxuLy8gICAgICAgICAgICAgaGVhZGVyOiBjaGFydEluZm8uaGVhZGVyIHx8IFwiZGVmYXVsdF9oZWFkZXJcIixcclxuLy8gICAgICAgICAgICAgdmFsdWVOYW1lOiBjaGFydEluZm8udmFsdWVOYW1lIHx8IFwiZGVmYXVsdF92YWx1ZU5hbWVcIixcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfTtcclxuLy8gICAgICAgfTtcclxuXHJcbi8vICAgICAgIHNldENoYXJ0RGF0YSh7XHJcbi8vICAgICAgICAgc2NhdHRlckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJTY2F0dGVyIFBsb3RcIiksXHJcbi8vICAgICAgICAgcGllQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlBpZSBDaGFydFwiKSxcclxuLy8gICAgICAgICBkb251dENoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJEb251dCBDaGFydFwiKSxcclxuLy8gICAgICAgICBsaW5lQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkxpbmUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgYmFyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkJhciBDaGFydFwiKSxcclxuLy8gICAgICAgfSk7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGU6XCIsIGVycm9yKTtcclxuLy8gICAgIH0gZmluYWxseSB7XHJcbi8vICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH07XHJcblxyXG4gXHJcbi8vICAgY29uc3QgaGFuZGxlU2VuZCA9IGFzeW5jICgpID0+IHtcclxuLy8gICAgIGlmICghaW5wdXRWYWx1ZSkgcmV0dXJuO1xyXG4gIFxyXG4vLyAgICAgY29uc3QgZ3JhcGhEYXRhID0gY2hhcnREYXRhW3NlbGVjdGVkQ2hhcnRdO1xyXG4vLyAgICAgaWYgKCFncmFwaERhdGEpIHJldHVybjtcclxuICBcclxuLy8gICAgIGNvbnN0IGxhYmVscyA9IGdyYXBoRGF0YS5sYWJlbHM7XHJcbi8vICAgICBjb25zdCB2YWx1ZXMgPSBncmFwaERhdGEuZGF0YXNldHNbMF0uZGF0YTtcclxuICBcclxuLy8gICAgIGNvbnN0IGRhdGFPYmplY3QgPSBsYWJlbHMucmVkdWNlKChvYmo6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0sIGxhYmVsLCBpbmRleCkgPT4ge1xyXG4vLyAgICAgICBvYmpbbGFiZWxdID0gdmFsdWVzW2luZGV4XTtcclxuLy8gICAgICAgcmV0dXJuIG9iajtcclxuLy8gICAgIH0sIHt9KTtcclxuICBcclxuLy8gICAgIGNvbnN0IGNoYXJ0VHlwZU1hcHBpbmc6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XHJcbi8vICAgICAgIGxpbmVDaGFydERhdGE6IFwiTGluZSBDaGFydFwiLFxyXG4vLyAgICAgICBwaWVDaGFydERhdGE6IFwiUGllIENoYXJ0XCIsXHJcbi8vICAgICAgIGRvbnV0Q2hhcnREYXRhOiBcIkRvbnV0IENoYXJ0XCIsXHJcbi8vICAgICAgIGJhckNoYXJ0RGF0YTogXCJCYXIgQ2hhcnRcIixcclxuLy8gICAgICAgc2NhdHRlckNoYXJ0RGF0YTogXCJTY2F0dGVyIFBsb3RcIixcclxuLy8gICAgIH07XHJcbiAgXHJcbi8vICAgICBjb25zdCBzZWxlY3RlZENoYXJ0VHlwZSA9IGNoYXJ0VHlwZU1hcHBpbmdbc2VsZWN0ZWRDaGFydF0gfHwgc2VsZWN0ZWRDaGFydDtcclxuICBcclxuLy8gICAgIC8vIEZpbHRlciB0aGUgc3RvcmVkIHByb2Nlc3NlZCBkYXRhIHRvIGluY2x1ZGUgb25seSB0aGUgc2VsZWN0ZWQgY2hhcnQncyBkYXRhXHJcbi8vICAgICBjb25zdCBmaWx0ZXJlZFByb2Nlc3NlZERhdGEgPSB7XHJcbi8vICAgICAgIFtzZWxlY3RlZENoYXJ0VHlwZV06IHN0b3JlZFByb2Nlc3NlZERhdGFbc2VsZWN0ZWRDaGFydFR5cGVdLFxyXG4vLyAgICAgfTtcclxuICBcclxuLy8gICAgIGNvbnNvbGUubG9nKFwiLi4uZmlsdGVyZWRQcm9jZXNzZWREYXRhLFwiLCBmaWx0ZXJlZFByb2Nlc3NlZERhdGFbc2VsZWN0ZWRDaGFydFR5cGVdPy5bMF0/LmRhdGEpO1xyXG4vLyAgICAgY29uc29sZS5sb2coXCJkYXRhT2JqZWN0LFwiLCBkYXRhT2JqZWN0KTtcclxuICBcclxuLy8gICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xyXG4vLyAgICAgICBxdWVzdGlvbjogaW5wdXRWYWx1ZSxcclxuLy8gICAgICAgcHJvY2Vzc2VkRGF0YToge1xyXG4vLyAgICAgICAgIC8vIEluY2x1ZGUgdGhlIHN0b3JlZCBwcm9jZXNzZWQgZGF0YVxyXG4vLyAgICAgICAgIFtzZWxlY3RlZENoYXJ0VHlwZV06IFtcclxuLy8gICAgICAgICAgIHtcclxuLy8gICAgICAgICAgICAgaGVhZGVyOiBncmFwaERhdGEubWV0YT8uaGVhZGVyIHx8IFwiZGVmYXVsdF9oZWFkZXJcIixcclxuLy8gICAgICAgICAgICAgdmFsdWVOYW1lOiBncmFwaERhdGEubWV0YT8udmFsdWVOYW1lIHx8IFwiZGVmYXVsdF92YWx1ZU5hbWVcIixcclxuLy8gICAgICAgICAgICAgbGFiZWw6IGdyYXBoRGF0YS5kYXRhc2V0c1swXS5sYWJlbCxcclxuLy8gICAgICAgICAgICAgZGF0YTogZmlsdGVyZWRQcm9jZXNzZWREYXRhW3NlbGVjdGVkQ2hhcnRUeXBlXT8uWzBdPy5kYXRhLFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICBdLFxyXG4vLyAgICAgICB9LFxyXG4vLyAgICAgfTtcclxuICBcclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcbi8vICAgICAgICAgYGh0dHA6Ly9sb2NhbGhvc3Q6MzAxMi9hcGkvYW5zd2VyLWFuYWx5emUtZXhjZWw/cXVlc3Rpb249JHtlbmNvZGVVUklDb21wb25lbnQoaW5wdXRWYWx1ZSl9YCxcclxuLy8gICAgICAgICB7XHJcbi8vICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4vLyAgICAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxyXG4vLyAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxyXG4vLyAgICAgICAgIH1cclxuLy8gICAgICAgKTtcclxuICBcclxuLy8gICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGUuXCIpO1xyXG4vLyAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbi8vICAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSByZXN1bHQuZGF0YT8ucHJvY2Vzc2VkRGF0YTtcclxuICBcclxuLy8gICAgICAgaWYgKCFwcm9jZXNzZWREYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZS5cIik7XHJcbiAgXHJcbi8vICAgICAgIGNvbnNvbGUubG9nKFwiVXBkYXRlZCBBUEkgUmVzcG9uc2UgRGF0YTpcIiwgcHJvY2Vzc2VkRGF0YSk7XHJcbiAgXHJcbi8vICAgICAgIGNvbnN0IGdlbmVyYXRlQ2hhcnREYXRhID0gKGNoYXJ0VHlwZTogc3RyaW5nKTogQ2hhcnREYXRhIHwgbnVsbCA9PiB7XHJcbi8vICAgICAgICAgY29uc3QgY2hhcnRJbmZvID0gcHJvY2Vzc2VkRGF0YVtjaGFydFR5cGVdPy5bMF07IC8vIFVzZSBvbmx5IEFQSSByZXNwb25zZSBkYXRhXHJcbi8vICAgICAgICAgaWYgKCFjaGFydEluZm8pIHJldHVybiBudWxsO1xyXG4gIFxyXG4vLyAgICAgICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5rZXlzKGNoYXJ0SW5mby5kYXRhKTtcclxuLy8gICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGNoYXJ0SW5mby5kYXRhKTtcclxuICBcclxuLy8gICAgICAgICBzZXRDaGFydFdpZHRoKGxhYmVscy5sZW5ndGggKiAxNTApO1xyXG4gIFxyXG4vLyAgICAgICAgIHJldHVybiB7XHJcbi8vICAgICAgICAgICBsYWJlbHMsXHJcbi8vICAgICAgICAgICBkYXRhc2V0czogW1xyXG4vLyAgICAgICAgICAgICB7XHJcbi8vICAgICAgICAgICAgICAgbGFiZWw6IGNoYXJ0SW5mby5sYWJlbCB8fCBjaGFydFR5cGUsXHJcbi8vICAgICAgICAgICAgICAgZGF0YTogdmFsdWVzIGFzIG51bWJlcltdLFxyXG4vLyAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogW1wiUGllIENoYXJ0XCIsIFwiRG9udXQgQ2hhcnRcIiwgXCJCYXIgQ2hhcnRcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKVxyXG4vLyAgICAgICAgICAgICAgICAgPyBbXCJyZ2JhKDE3MywgMjE2LCAyMzAsIDAuNilcIiwgXCJyZ2JhKDE0NCwgMjM4LCAxNDQsIDAuNilcIiwgXCJyZ2JhKDI1NSwgMTgyLCAxOTMsIDAuNilcIl1cclxuLy8gICAgICAgICAgICAgICAgIDogXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDAuNilcIixcclxuLy8gICAgICAgICAgICAgICBib3JkZXJDb2xvcjogY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSA/IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAxKVwiIDogdW5kZWZpbmVkLFxyXG4vLyAgICAgICAgICAgICAgIGZpbGw6ICFjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgXSxcclxuLy8gICAgICAgICAgIG1ldGE6IHtcclxuLy8gICAgICAgICAgICAgaGVhZGVyOiBjaGFydEluZm8uaGVhZGVyIHx8IFwiZGVmYXVsdF9oZWFkZXJcIixcclxuLy8gICAgICAgICAgICAgdmFsdWVOYW1lOiBjaGFydEluZm8udmFsdWVOYW1lIHx8IFwiZGVmYXVsdF92YWx1ZU5hbWVcIixcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfTtcclxuLy8gICAgICAgfTtcclxuICBcclxuLy8gICAgICAgLy8gT25seSB1cGRhdGUgY2hhcnREYXRhIHdpdGhvdXQgc3RvcmluZyBpbiBzdG9yZWRQcm9jZXNzZWREYXRhXHJcbi8vICAgICAgIHNldENoYXJ0RGF0YSgocHJldkNoYXJ0RGF0YSkgPT4gKHtcclxuLy8gICAgICAgICAuLi5wcmV2Q2hhcnREYXRhLFxyXG4vLyAgICAgICAgIFtzZWxlY3RlZENoYXJ0XTogZ2VuZXJhdGVDaGFydERhdGEoc2VsZWN0ZWRDaGFydFR5cGUpLFxyXG4vLyAgICAgICB9KSk7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2VuZGluZyByZXF1ZXN0OlwiLCBlcnJvcik7XHJcbi8vICAgICB9IGZpbmFsbHkge1xyXG4vLyAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuLy8gICAgIH1cclxuLy8gICB9O1xyXG4gIFxyXG5cclxuLy8gICBjb25zdCBnZXRDaGFydE9wdGlvbnMgPSAodHlwZTogc3RyaW5nKSA9PiAoe1xyXG4vLyAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuLy8gICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxyXG4vLyAgICAgc2NhbGVzOiBbXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKVxyXG4vLyAgICAgICA/IHt9XHJcbi8vICAgICAgIDoge1xyXG4vLyAgICAgICAgIHg6IHtcclxuLy8gICAgICAgICAgIHRpY2tzOiB7XHJcbi8vICAgICAgICAgICAgIGF1dG9Ta2lwOiBmYWxzZSxcclxuLy8gICAgICAgICAgICAgbWF4Um90YXRpb246IHR5cGUgPT09ICdiYXJDaGFydERhdGEnIHx8IHR5cGUgPT09ICdzY2F0dGVyQ2hhcnREYXRhJyA/IDIwIDogMTAwLFxyXG4vLyAgICAgICAgIG1pblJvdGF0aW9uOiB0eXBlID09PSAnYmFyQ2hhcnREYXRhJyB8fCB0eXBlID09PSAnc2NhdHRlckNoYXJ0RGF0YScgPyAwIDogOTAsXHJcbi8vICAgICAgICAgICAgIGF1dG9Ta2lwUGFkZGluZzogMjAsXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgZ3JpZDoge1xyXG4vLyAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4vLyAgICAgICAgICAgICBkcmF3VGlja3M6IGZhbHNlLFxyXG4vLyAgICAgICAgICAgICB0aWNrTGVuZ3RoOiAxMDAsXHJcbi8vICAgICAgICAgICAgIGxpbmVXaWR0aDogMVxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgICAgIHk6IHtcclxuLy8gICAgICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxyXG4vLyAgICAgICAgICAgdGlja3M6IHsgcHJlY2lzaW9uOiAwIH0sXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgICAgfSxcclxuLy8gICAgIHBsdWdpbnM6IHtcclxuLy8gICAgICAgbGVnZW5kOiB7IGRpc3BsYXk6IHRydWUsIHBvc2l0aW9uOiBcInRvcFwiIH0sXHJcbi8vICAgICAgIHRvb2x0aXA6IHsgZW5hYmxlZDogdHJ1ZSB9LFxyXG4vLyAgICAgfSxcclxuLy8gICB9KTtcclxuLy8gICBjb25zdCByZW5kZXJDaGFydCA9ICh0eXBlOiBzdHJpbmcsIENoYXJ0Q29tcG9uZW50OiBhbnkpID0+IHtcclxuLy8gICAgIGNvbnN0IGRhdGEgPSBjaGFydERhdGFbdHlwZV07XHJcbi8vICAgICBpZiAoIWxvYWRpbmcgJiYgZGF0YSkge1xyXG4vLyAgICAgICByZXR1cm4gKFxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZCBwLTQgYm9yZGVyIHJvdW5kZWQgc2hhZG93LXNtXCI+XHJcbi8vICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiBcIjEwMCVcIiwgb3ZlcmZsb3dYOiBcImF1dG9cIiB9fT5cclxuLy8gICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBtaW5XaWR0aDogW1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKSA/IGAke2NoYXJ0V2lkdGh9cHhgIDogXCJhdXRvXCIsIGhlaWdodDogXCI0MDBweFwiIH19PlxyXG4vLyAgICAgICAgICAgICAgIDxDaGFydENvbXBvbmVudCBkYXRhPXtkYXRhfSBvcHRpb25zPXtnZXRDaGFydE9wdGlvbnModHlwZSl9IC8+XHJcbi8vICAgICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICk7XHJcbi8vICAgICB9XHJcbi8vICAgICByZXR1cm4gbnVsbDtcclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVEb3dubG9hZFBERiA9IGFzeW5jICgpID0+IHtcclxuLy8gICAgIGlmICghY2hhcnRSZWYuY3VycmVudCkgcmV0dXJuO1xyXG4gIFxyXG4vLyAgICAgLy8gVGVtcG9yYXJpbHkgc2V0IHRoZSBjaGFydCBjb250YWluZXIgdG8gaXRzIGZ1bGwgaGVpZ2h0IHRvIGNhcHR1cmUgYWxsIGNvbnRlbnRcclxuLy8gICAgIGNvbnN0IG9yaWdpbmFsSGVpZ2h0ID0gY2hhcnRSZWYuY3VycmVudC5zdHlsZS5oZWlnaHQ7XHJcbi8vICAgICBjaGFydFJlZi5jdXJyZW50LnN0eWxlLmhlaWdodCA9IGAke2NoYXJ0UmVmLmN1cnJlbnQuc2Nyb2xsSGVpZ2h0fXB4YDtcclxuICBcclxuLy8gICAgIGNvbnN0IGNhbnZhcyA9IGF3YWl0IGh0bWwyY2FudmFzKGNoYXJ0UmVmLmN1cnJlbnQsIHtcclxuLy8gICAgICAgc2Nyb2xsWDogMCxcclxuLy8gICAgICAgc2Nyb2xsWTogLXdpbmRvdy5zY3JvbGxZLFxyXG4vLyAgICAgICB3aWR0aDogY2hhcnRSZWYuY3VycmVudC5zY3JvbGxXaWR0aCxcclxuLy8gICAgICAgaGVpZ2h0OiBjaGFydFJlZi5jdXJyZW50LnNjcm9sbEhlaWdodCxcclxuLy8gICAgIH0pO1xyXG4gIFxyXG4vLyAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgaGVpZ2h0IG9mIHRoZSBjaGFydCBjb250YWluZXJcclxuLy8gICAgIGNoYXJ0UmVmLmN1cnJlbnQuc3R5bGUuaGVpZ2h0ID0gb3JpZ2luYWxIZWlnaHQ7XHJcbiAgXHJcbi8vICAgICBjb25zdCBpbWdEYXRhID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcclxuLy8gICAgIGNvbnN0IHBkZiA9IG5ldyBqc1BERihcImxhbmRzY2FwZVwiLCBcIm1tXCIsIFwiYTRcIik7XHJcbi8vICAgICBjb25zdCBpbWdQcm9wcyA9IHBkZi5nZXRJbWFnZVByb3BlcnRpZXMoaW1nRGF0YSk7XHJcbi8vICAgICBjb25zdCBwZGZXaWR0aCA9IHBkZi5pbnRlcm5hbC5wYWdlU2l6ZS5nZXRXaWR0aCgpO1xyXG4vLyAgICAgY29uc3QgcGRmSGVpZ2h0ID0gKGltZ1Byb3BzLmhlaWdodCAqIHBkZldpZHRoKSAvIGltZ1Byb3BzLndpZHRoO1xyXG4gIFxyXG4vLyAgICAgcGRmLmFkZEltYWdlKGltZ0RhdGEsIFwiUE5HXCIsIDAsIDAsIHBkZldpZHRoLCBwZGZIZWlnaHQpO1xyXG4vLyAgICAgcGRmLnNhdmUoXCJjaGFydC5wZGZcIik7XHJcbi8vICAgfTtcclxuXHJcbi8vICAgcmV0dXJuIChcclxuLy8gICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBtZDpmbGV4LXJvdyBoLXNjcmVlbiBib3JkZXIgYm9yZGVyLWJsYWNrXCI+XHJcbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMS80IGJnLXdoaXRlIHAtNSBib3JkZXItdCBtZDpib3JkZXItbCBtZDpib3JkZXItYmxhY2tcIj5cclxuLy8gICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPlVwbG9hZCBGaWxlPC9oMj5cclxuLy8gICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIiBvbkNoYW5nZT17aGFuZGxlRmlsZUNoYW5nZX0gY2xhc3NOYW1lPVwiYm9yZGVyIHAtMiB3LWZ1bGxcIiAvPlxyXG4vLyAgICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlU3VibWl0fSBjbGFzc05hbWU9XCJiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlIHAtMiByb3VuZGVkIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG10LTRcIj5cclxuLy8gICAgICAgICAgIDxCc1VwbG9hZCBjbGFzc05hbWU9XCJtci0yXCIgLz4gU3VibWl0XHJcbi8vICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHNwYWNlLXktMiBtdC00XCI+XHJcbi8vICAgICAgICAgICB7W1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiLCBcInNjYXR0ZXJDaGFydERhdGFcIiwgXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5tYXAoKHR5cGUpID0+IChcclxuLy8gICAgICAgICAgICAgPGJ1dHRvbiBrZXk9e3R5cGV9IG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkQ2hhcnQodHlwZSl9IGNsYXNzTmFtZT1cInAtMiBiZy1ncmF5LTMwMCByb3VuZGVkIGhvdmVyOmJnLWdyYXktNDAwXCI+XHJcbi8vICAgICAgICAgICAgICAge3R5cGUucmVwbGFjZShcIkNoYXJ0RGF0YVwiLCBcIiBDaGFydFwiKX1cclxuLy8gICAgICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgICApKX1cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgPC9kaXY+XHJcbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMy80IGJnLWdyYXktMTAwIHAtNSBvdmVyZmxvdy1hdXRvXCI+XHJcbi8vICAgICAgICAge2xvYWRpbmcgPyAoXHJcbi8vICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIGgtZnVsbFwiPlxyXG4vLyAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwaW5uZXItYm9yZGVyIGFuaW1hdGUtc3BpbiBib3JkZXItdC00IGJvcmRlci1ibHVlLTUwMCByb3VuZGVkLWZ1bGwgdy0xMiBoLTEyXCI+PC9kaXY+XHJcbi8vICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICApIDogKFxyXG4vLyAgICAgICAgICAgc2VsZWN0ZWRDaGFydCAmJiByZW5kZXJDaGFydChzZWxlY3RlZENoYXJ0LCB7IGxpbmVDaGFydERhdGE6IExpbmUsIGJhckNoYXJ0RGF0YTogQmFyLCBzY2F0dGVyQ2hhcnREYXRhOiBTY2F0dGVyLCBwaWVDaGFydERhdGE6IFBpZSwgZG9udXRDaGFydERhdGE6IERvdWdobnV0IH1bc2VsZWN0ZWRDaGFydF0pXHJcbi8vICAgICAgICAgKX1cclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTQgZmxleFwiPlxyXG4vLyAgICAgICAgICAgPGlucHV0XHJcbi8vICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcclxuLy8gICAgICAgICAgICAgdmFsdWU9e2lucHV0VmFsdWV9XHJcbi8vICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0SW5wdXRWYWx1ZShlLnRhcmdldC52YWx1ZSl9XHJcbi8vICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJvcmRlciBwLTIgZmxleC1ncm93IG1yLTIgcm91bmRlZFwiXHJcbi8vICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiRW50ZXIgeW91ciB0ZXh0IGhlcmVcIlxyXG4vLyAgICAgICAgICAgLz5cclxuLy8gICAgICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlU2VuZH0gY2xhc3NOYW1lPVwiYmctZ3JlZW4tNTAwIHRleHQtd2hpdGUgcC0yIHJvdW5kZWRcIj5cclxuLy8gICAgICAgICAgICAgU2VuZFxyXG4vLyAgICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC00IHAtNCBib3JkZXIgYm9yZGVyLWdyYXktMzAwIHJvdW5kZWQgYmctd2hpdGVcIj5cclxuLy8gICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+SW5zaWdodHM8L2gzPlxyXG4vLyAgICAgICAgICAge2NvbWJpbmVkSW5zaWdodHMgPyAoXHJcbi8vICAgICAgICAgICAgIDxvbCBjbGFzc05hbWU9XCJsaXN0LWRlY2ltYWwgbGlzdC1pbnNpZGUgdGV4dC1zbSB0ZXh0LWdyYXktNzAwIGJnLWdyYXktMTAwIHAtMiByb3VuZGVkIG92ZXJmbG93LWF1dG9cIj5cclxuLy8gICAgICAgICAgICAgICB7Y29tYmluZWRJbnNpZ2h0cy5zcGxpdCgnXFxuJykubWFwKChpbnNpZ2h0LCBpbmRleCkgPT4gKFxyXG4vLyAgICAgICAgICAgICAgICAgPHVsIGtleT17aW5kZXh9PntpbnNpZ2h0fTwvdWw+XHJcbi8vICAgICAgICAgICAgICAgKSl9XHJcbi8vICAgICAgICAgICAgIDwvb2w+XHJcbi8vICAgICAgICAgICApIDogKFxyXG4vLyAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNTAwXCI+Tm8gaW5zaWdodHMgYXZhaWxhYmxlLjwvcD5cclxuLy8gICAgICAgICAgICl9XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtoYW5kbGVEb3dubG9hZFBERn0gY2xhc3NOYW1lPVwiYmctcmVkLTUwMCB0ZXh0LXdoaXRlIHAtMiByb3VuZGVkIG10LTRcIj5cclxuLy8gICAgICAgICAgIERvd25sb2FkIGFzIFBERlxyXG4vLyAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICA8L2Rpdj5cclxuLy8gICAgIDwvZGl2PlxyXG4vLyAgICk7XHJcbi8vIH1cclxuXHJcblxyXG5cclxuXCJ1c2UgY2xpZW50XCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiwgQXdhaXRlZFJlYWN0Tm9kZSwgSlNYRWxlbWVudENvbnN0cnVjdG9yLCBLZXksIFJlYWN0RWxlbWVudCwgUmVhY3ROb2RlLCBSZWFjdFBvcnRhbCB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyBCYXIsIExpbmUsIERvdWdobnV0LCBQaWUsIFNjYXR0ZXIgfSBmcm9tIFwicmVhY3QtY2hhcnRqcy0yXCI7XHJcbmltcG9ydCB7IENoYXJ0IGFzIENoYXJ0SlMsIENhdGVnb3J5U2NhbGUsIExpbmVhclNjYWxlLCBCYXJFbGVtZW50LCBMaW5lRWxlbWVudCwgUG9pbnRFbGVtZW50LCBBcmNFbGVtZW50LCBUaXRsZSwgVG9vbHRpcCwgTGVnZW5kIH0gZnJvbSBcImNoYXJ0LmpzXCI7XHJcbmltcG9ydCB7IEJzVXBsb2FkIH0gZnJvbSBcInJlYWN0LWljb25zL2JzXCI7XHJcbmltcG9ydCB6b29tUGx1Z2luIGZyb20gXCJjaGFydGpzLXBsdWdpbi16b29tXCI7XHJcbmltcG9ydCBodG1sMmNhbnZhcyBmcm9tIFwiaHRtbDJjYW52YXNcIjtcclxuaW1wb3J0IGpzUERGIGZyb20gXCJqc3BkZlwiO1xyXG5pbXBvcnQgQ2hhcnQgZnJvbSBcInJlYWN0LWFwZXhjaGFydHNcIjtcclxuQ2hhcnRKUy5yZWdpc3RlcihDYXRlZ29yeVNjYWxlLCBMaW5lYXJTY2FsZSwgQmFyRWxlbWVudCwgTGluZUVsZW1lbnQsIFBvaW50RWxlbWVudCwgQXJjRWxlbWVudCwgVGl0bGUsIFRvb2x0aXAsIExlZ2VuZCwgem9vbVBsdWdpbik7XHJcblxyXG5pbnRlcmZhY2UgQ2hhcnREYXRhIHtcclxuICBsYWJlbHM6IHN0cmluZ1tdO1xyXG4gIGRhdGFzZXRzOiB7XHJcbiAgICBsYWJlbDogc3RyaW5nO1xyXG4gICAgZGF0YTogbnVtYmVyW107XHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmcgfCBzdHJpbmdbXTtcclxuICAgIGJvcmRlckNvbG9yPzogc3RyaW5nO1xyXG4gICAgZmlsbD86IGJvb2xlYW47XHJcbiAgfVtdXHJcbiAgbWV0YT86IHtcclxuICAgIGhlYWRlcjogc3RyaW5nO1xyXG4gICAgdmFsdWVOYW1lOiBzdHJpbmc7XHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGFzaGJvYXJkKCkge1xyXG4gIGNvbnN0IFtjaGFydERhdGEsIHNldENoYXJ0RGF0YV0gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBDaGFydERhdGEgfCBudWxsPj4oe1xyXG4gICAgc2NhdHRlckNoYXJ0RGF0YTogbnVsbCxcclxuICAgIHBpZUNoYXJ0RGF0YTogbnVsbCxcclxuICAgIGRvbnV0Q2hhcnREYXRhOiBudWxsLFxyXG4gICAgbGluZUNoYXJ0RGF0YTogbnVsbCxcclxuICAgIGJhckNoYXJ0RGF0YTogbnVsbCxcclxuICB9KTtcclxuICBjb25zdCBbc2VsZWN0ZWRGaWxlLCBzZXRTZWxlY3RlZEZpbGVdID0gdXNlU3RhdGU8RmlsZSB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFtzZWxlY3RlZENoYXJ0LCBzZXRTZWxlY3RlZENoYXJ0XSA9IHVzZVN0YXRlPHN0cmluZz4oXCJsaW5lQ2hhcnREYXRhXCIpO1xyXG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcclxuICBjb25zdCBbY2hhcnRXaWR0aCwgc2V0Q2hhcnRXaWR0aF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xyXG4gIGNvbnN0IFtpbnB1dFZhbHVlLCBzZXRJbnB1dFZhbHVlXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XHJcbiAgY29uc3QgW3N0b3JlZFByb2Nlc3NlZERhdGEsIHNldFN0b3JlZFByb2Nlc3NlZERhdGFdID0gdXNlU3RhdGU8YW55PihudWxsKTsgLy8gTmV3IHN0YXRlIHRvIHN0b3JlIHByb2Nlc3NlZCBkYXRhXHJcbiAgY29uc3QgW2NvbWJpbmVkSW5zaWdodHMsIHNldENvbWJpbmVkSW5zaWdodHNdID0gdXNlU3RhdGU8YW55PihudWxsKTtcclxuICBjb25zdCBjaGFydFJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7IC8vIFJlZiBmb3IgdGhlIGNoYXJ0IGNvbnRhaW5lclxyXG5cclxuICBjb25zdCBoYW5kbGVGaWxlQ2hhbmdlID0gKGV2ZW50OiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xyXG4gICAgc2V0U2VsZWN0ZWRGaWxlKGV2ZW50LnRhcmdldC5maWxlcz8uWzBdIHx8IG51bGwpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IGFzeW5jICgpID0+IHtcclxuICAgIGlmICghc2VsZWN0ZWRGaWxlKSByZXR1cm47XHJcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbiAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIHNlbGVjdGVkRmlsZSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHA6Ly9sb2NhbGhvc3Q6MzAxMi9hcGkvYW5hbHl6ZS1leGNlbFwiLCB7XHJcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgICBib2R5OiBmb3JtRGF0YSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZS5cIik7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgY29uc3QgY29tYmluZWRJbnNpZ2h0cyA9IHJlc3VsdC5kYXRhPy5jb21iaW5lZEluc2lnaHRzO1xyXG4gICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gcmVzdWx0LmRhdGE/LnByb2Nlc3NlZERhdGE7XHJcblxyXG4gICAgICBpZiAoIXByb2Nlc3NlZERhdGEpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzcG9uc2Ugc3RydWN0dXJlLlwiKTtcclxuICAgICAgY29uc29sZS5sb2coXCJwcm9jZXNzZWREYXRhXCIsIHByb2Nlc3NlZERhdGEpO1xyXG5cclxuICAgICAgc2V0U3RvcmVkUHJvY2Vzc2VkRGF0YShwcm9jZXNzZWREYXRhKTsgLy8gU3RvcmUgdGhlIHByb2Nlc3NlZCBkYXRhXHJcbiAgICAgIHNldENvbWJpbmVkSW5zaWdodHMoY29tYmluZWRJbnNpZ2h0cyk7XHJcbiAgICAgIGNvbnN0IGxpZ2h0Q29sb3JzID0gW1xyXG4gICAgICAgIFwicmdiYSgxNzMsIDIxNiwgMjMwLCAwLjYpXCIsXHJcbiAgICAgICAgXCJyZ2JhKDE0NCwgMjM4LCAxNDQsIDAuNilcIixcclxuICAgICAgICBcInJnYmEoMjU1LCAxODIsIDE5MywgMC42KVwiLFxyXG4gICAgICAgIFwicmdiYSgyNTUsIDIyOCwgMTgxLCAwLjYpXCIsXHJcbiAgICAgICAgXCJyZ2JhKDIyMSwgMTYwLCAyMjEsIDAuNilcIixcclxuICAgICAgICBcInJnYmEoMjQwLCAyMzAsIDE0MCwgMC42KVwiLFxyXG4gICAgICBdO1xyXG5cclxuICAgICAgY29uc3QgZ2VuZXJhdGVDaGFydERhdGEgPSAoY2hhcnRUeXBlOiBzdHJpbmcpOiBDaGFydERhdGEgfCBudWxsID0+IHtcclxuICAgICAgICBjb25zdCBjaGFydEluZm8gPSBwcm9jZXNzZWREYXRhW2NoYXJ0VHlwZV0/LlswXTtcclxuICAgICAgICBpZiAoIWNoYXJ0SW5mbykgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5rZXlzKGNoYXJ0SW5mby5kYXRhKTtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGNoYXJ0SW5mby5kYXRhKTtcclxuY29uc29sZS5sb2coXCJjaGFydFR5cGVcIixjaGFydFR5cGUpO1xyXG5cclxuICAgICAgICBsZXQgY2hhcnRXaWR0aCA9IDA7XHJcbiAgICAgICAgaWYgKFtcIkxpbmUgQ2hhcnRcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKSkge1xyXG4gICAgICAgICAgY2hhcnRXaWR0aCA9IGxhYmVscy5sZW5ndGggKiAxNTA7XHJcbiAgICAgICAgfSBlbHNlIGlmIChbXCJCYXIgQ2hhcnRcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKSkge1xyXG4gICAgICAgICAgY2hhcnRXaWR0aCA9IGxhYmVscy5sZW5ndGggKiAxNTA7IC8vIEFkanVzdCB0aGUgd2lkdGggZm9yIGJhciBjaGFydFxyXG4gICAgICAgIH0gXHJcbiAgICAgICAgZWxzZSBpZiAoW1wiU2NhdHRlciBQbG90XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSkpIHtcclxuICAgICAgICAgIGNoYXJ0V2lkdGggPSBsYWJlbHMubGVuZ3RoICogMTUwOyAvLyBBZGp1c3QgdGhlIHdpZHRoIGZvciBiYXIgY2hhcnRcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICBjaGFydFdpZHRoID0gNDAwOyAvLyBEZWZhdWx0IHdpZHRoIGZvciBvdGhlciBjaGFydCB0eXBlc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0Q2hhcnRXaWR0aChjaGFydFdpZHRoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGxhYmVscyxcclxuICAgICAgICAgIGRhdGFzZXRzOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBsYWJlbDogY2hhcnRJbmZvLmxhYmVsIHx8IGNoYXJ0VHlwZSxcclxuICAgICAgICAgICAgICBkYXRhOiB2YWx1ZXMgYXMgbnVtYmVyW10sXHJcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbXCJQaWUgQ2hhcnRcIiwgXCJEb251dCBDaGFydFwiLCBcIkJhciBDaGFydFwiXS5pbmNsdWRlcyhjaGFydFR5cGUpXHJcbiAgICAgICAgICAgICAgICA/IGxpZ2h0Q29sb3JzLnNsaWNlKDAsIGxhYmVscy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICA6IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAwLjYpXCIsXHJcbiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIikgPyBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMSlcIiA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICBmaWxsOiAhY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIF0sXHJcbiAgICAgICAgICBtZXRhOiB7XHJcbiAgICAgICAgICAgIGhlYWRlcjogY2hhcnRJbmZvLmhlYWRlciB8fCBcImRlZmF1bHRfaGVhZGVyXCIsXHJcbiAgICAgICAgICAgIHZhbHVlTmFtZTogY2hhcnRJbmZvLnZhbHVlTmFtZSB8fCBcImRlZmF1bHRfdmFsdWVOYW1lXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBzZXRDaGFydERhdGEoe1xyXG4gICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiU2NhdHRlciBQbG90XCIpLFxyXG4gICAgICAgIHBpZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJQaWUgQ2hhcnRcIiksXHJcbiAgICAgICAgZG9udXRDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiRG9udXQgQ2hhcnRcIiksXHJcbiAgICAgICAgbGluZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJMaW5lIENoYXJ0XCIpLFxyXG4gICAgICAgIGJhckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJCYXIgQ2hhcnRcIiksXHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlOlwiLCBlcnJvcik7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVTZW5kID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKCFpbnB1dFZhbHVlKSByZXR1cm47XHJcbiAgXHJcbiAgICBjb25zdCBncmFwaERhdGEgPSBjaGFydERhdGFbc2VsZWN0ZWRDaGFydF07XHJcbiAgICBpZiAoIWdyYXBoRGF0YSkgcmV0dXJuO1xyXG4gIFxyXG4gICAgY29uc3QgbGFiZWxzID0gZ3JhcGhEYXRhLmxhYmVscztcclxuICAgIGNvbnN0IHZhbHVlcyA9IGdyYXBoRGF0YS5kYXRhc2V0c1swXS5kYXRhO1xyXG4gIFxyXG4gICAgY29uc3QgZGF0YU9iamVjdCA9IGxhYmVscy5yZWR1Y2UoKG9iajogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSwgbGFiZWwsIGluZGV4KSA9PiB7XHJcbiAgICAgIG9ialtsYWJlbF0gPSB2YWx1ZXNbaW5kZXhdO1xyXG4gICAgICByZXR1cm4gb2JqO1xyXG4gICAgfSwge30pO1xyXG4gIFxyXG4gICAgY29uc3QgY2hhcnRUeXBlTWFwcGluZzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcclxuICAgICAgbGluZUNoYXJ0RGF0YTogXCJMaW5lIENoYXJ0XCIsXHJcbiAgICAgIHBpZUNoYXJ0RGF0YTogXCJQaWUgQ2hhcnRcIixcclxuICAgICAgZG9udXRDaGFydERhdGE6IFwiRG9udXQgQ2hhcnRcIixcclxuICAgICAgYmFyQ2hhcnREYXRhOiBcIkJhciBDaGFydFwiLFxyXG4gICAgICBzY2F0dGVyQ2hhcnREYXRhOiBcIlNjYXR0ZXIgUGxvdFwiLFxyXG4gICAgfTtcclxuICBcclxuICAgIGNvbnN0IHNlbGVjdGVkQ2hhcnRUeXBlID0gY2hhcnRUeXBlTWFwcGluZ1tzZWxlY3RlZENoYXJ0XSB8fCBzZWxlY3RlZENoYXJ0O1xyXG4gIFxyXG4gICAgLy8gRmlsdGVyIHRoZSBzdG9yZWQgcHJvY2Vzc2VkIGRhdGEgdG8gaW5jbHVkZSBvbmx5IHRoZSBzZWxlY3RlZCBjaGFydCdzIGRhdGFcclxuICAgIGNvbnN0IGZpbHRlcmVkUHJvY2Vzc2VkRGF0YSA9IHtcclxuICAgICAgW3NlbGVjdGVkQ2hhcnRUeXBlXTogc3RvcmVkUHJvY2Vzc2VkRGF0YVtzZWxlY3RlZENoYXJ0VHlwZV0sXHJcbiAgICB9O1xyXG4gIFxyXG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XHJcbiAgICAgIHF1ZXN0aW9uOiBpbnB1dFZhbHVlLFxyXG4gICAgICBwcm9jZXNzZWREYXRhOiB7XHJcbiAgICAgICAgLy8gSW5jbHVkZSB0aGUgc3RvcmVkIHByb2Nlc3NlZCBkYXRhXHJcbiAgICAgICAgW3NlbGVjdGVkQ2hhcnRUeXBlXTogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBoZWFkZXI6IGdyYXBoRGF0YS5tZXRhPy5oZWFkZXIgfHwgXCJkZWZhdWx0X2hlYWRlclwiLFxyXG4gICAgICAgICAgICB2YWx1ZU5hbWU6IGdyYXBoRGF0YS5tZXRhPy52YWx1ZU5hbWUgfHwgXCJkZWZhdWx0X3ZhbHVlTmFtZVwiLFxyXG4gICAgICAgICAgICBsYWJlbDogZ3JhcGhEYXRhLmRhdGFzZXRzWzBdLmxhYmVsLFxyXG4gICAgICAgICAgICBkYXRhOiBmaWx0ZXJlZFByb2Nlc3NlZERhdGFbc2VsZWN0ZWRDaGFydFR5cGVdPy5bMF0/LmRhdGEsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgICBgaHR0cDovL2xvY2FsaG9zdDozMDEyL2FwaS9hbnN3ZXItYW5hbHl6ZS1leGNlbD9xdWVzdGlvbj0ke2VuY29kZVVSSUNvbXBvbmVudChpbnB1dFZhbHVlKX1gLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXHJcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gIFxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZS5cIik7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHJlc3VsdC5kYXRhPy5wcm9jZXNzZWREYXRhO1xyXG4gIFxyXG4gICAgICBpZiAoIXByb2Nlc3NlZERhdGEpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzcG9uc2Ugc3RydWN0dXJlLlwiKTtcclxuICBcclxuICAgICAgY29uc3QgZ2VuZXJhdGVDaGFydERhdGEgPSAoY2hhcnRUeXBlOiBzdHJpbmcpOiBDaGFydERhdGEgfCBudWxsID0+IHtcclxuICAgICAgICBjb25zdCBjaGFydEluZm8gPSBwcm9jZXNzZWREYXRhW2NoYXJ0VHlwZV0/LlswXTsgLy8gVXNlIG9ubHkgQVBJIHJlc3BvbnNlIGRhdGFcclxuICAgICAgICBpZiAoIWNoYXJ0SW5mbykgcmV0dXJuIG51bGw7XHJcbiAgXHJcbiAgICAgICAgY29uc3QgbGFiZWxzID0gT2JqZWN0LmtleXMoY2hhcnRJbmZvLmRhdGEpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoY2hhcnRJbmZvLmRhdGEpO1xyXG4gICAgICAgIGxldCBjaGFydFdpZHRoID0gMDtcclxuICAgICAgICBpZiAoW1wiTGluZSBDaGFydFwiXS5pbmNsdWRlcyhjaGFydFR5cGUpKSB7XHJcbiAgICAgICAgICBjaGFydFdpZHRoID0gbGFiZWxzLmxlbmd0aCAqIDE1MDtcclxuICAgICAgICB9IGVsc2UgaWYgKFtcIkJhciBDaGFydFwiXS5pbmNsdWRlcyhjaGFydFR5cGUpKSB7XHJcbiAgICAgICAgICBjaGFydFdpZHRoID0gbGFiZWxzLmxlbmd0aCAqIDE1MDsgLy8gQWRqdXN0IHRoZSB3aWR0aCBmb3IgYmFyIGNoYXJ0XHJcbiAgICAgICAgfSBcclxuICAgICAgICBlbHNlIGlmIChbXCJTY2F0dGVyIFBsb3RcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKSkge1xyXG4gICAgICAgICAgY2hhcnRXaWR0aCA9IGxhYmVscy5sZW5ndGggKiAxNTA7IC8vIEFkanVzdCB0aGUgd2lkdGggZm9yIGJhciBjaGFydFxyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgIGNoYXJ0V2lkdGggPSA0MDA7IC8vIERlZmF1bHQgd2lkdGggZm9yIG90aGVyIGNoYXJ0IHR5cGVzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldENoYXJ0V2lkdGgoY2hhcnRXaWR0aCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGxhYmVscyxcclxuICAgICAgICAgIGRhdGFzZXRzOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBsYWJlbDogY2hhcnRJbmZvLmxhYmVsIHx8IGNoYXJ0VHlwZSxcclxuICAgICAgICAgICAgICBkYXRhOiB2YWx1ZXMgYXMgbnVtYmVyW10sXHJcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbXCJQaWUgQ2hhcnRcIiwgXCJEb251dCBDaGFydFwiLCBcIkJhciBDaGFydFwiXS5pbmNsdWRlcyhjaGFydFR5cGUpXHJcbiAgICAgICAgICAgICAgICA/IFtcInJnYmEoMTczLCAyMTYsIDIzMCwgMC42KVwiLCBcInJnYmEoMTQ0LCAyMzgsIDE0NCwgMC42KVwiLCBcInJnYmEoMjU1LCAxODIsIDE5MywgMC42KVwiXVxyXG4gICAgICAgICAgICAgICAgOiBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMC42KVwiLFxyXG4gICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpID8gXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDEpXCIgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgZmlsbDogIWNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIiksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgICAgbWV0YToge1xyXG4gICAgICAgICAgICBoZWFkZXI6IGNoYXJ0SW5mby5oZWFkZXIgfHwgXCJkZWZhdWx0X2hlYWRlclwiLFxyXG4gICAgICAgICAgICB2YWx1ZU5hbWU6IGNoYXJ0SW5mby52YWx1ZU5hbWUgfHwgXCJkZWZhdWx0X3ZhbHVlTmFtZVwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICB9O1xyXG4gIFxyXG4gICAgICAvLyBPbmx5IHVwZGF0ZSBjaGFydERhdGEgd2l0aG91dCBzdG9yaW5nIGluIHN0b3JlZFByb2Nlc3NlZERhdGFcclxuICAgICAgc2V0Q2hhcnREYXRhKChwcmV2Q2hhcnREYXRhKSA9PiAoe1xyXG4gICAgICAgIC4uLnByZXZDaGFydERhdGEsXHJcbiAgICAgICAgW3NlbGVjdGVkQ2hhcnRdOiBnZW5lcmF0ZUNoYXJ0RGF0YShzZWxlY3RlZENoYXJ0VHlwZSksXHJcbiAgICAgIH0pKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzZW5kaW5nIHJlcXVlc3Q6XCIsIGVycm9yKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgY29uc3QgcmVuZGVyQ2hhcnQgPSAodHlwZTogc3RyaW5nLCBDaGFydENvbXBvbmVudDogYW55KSA9PiB7XHJcbiAgICBjb25zdCBkYXRhID0gY2hhcnREYXRhPy5bdHlwZV07XHJcbiAgXHJcbiAgICBpZiAoIWxvYWRpbmcgJiYgZGF0YSkge1xyXG4gICAgICAvLyBDYWxjdWxhdGUgdGljayBzcGFjaW5nIGJhc2VkIG9uIGRhdGEgbGVuZ3RoXHJcbiAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBkYXRhLmxhYmVscz8ubGVuZ3RoIHx8IDA7XHJcbiAgICAgIGNvbnN0IG1heFRpY2tzID0gTWF0aC5mbG9vcig2MDAgLyA1MCk7IC8vIEFwcHJveCA1MHB4IHBlciBsYWJlbCB3aWR0aFxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBvdmVyZmxvdy14LWF1dG8gb3ZlcmZsb3cteS1oaWRkZW4gYmctd2hpdGUgcC00IHJvdW5kZWQtbGcgc2hhZG93XCI+XHJcbiAgPGRpdlxyXG4gICAgc3R5bGU9e3tcclxuICAgICAgd2lkdGg6IFwiMTAwJVwiLFxyXG4gICAgICBtaW5XaWR0aDogW1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKVxyXG4gICAgICAgID8gTWF0aC5tYXgoNjAwLCBkYXRhTGVuZ3RoICogNTApICsgXCJweFwiIC8vIER5bmFtaWMgbWluLXdpZHRoIGJhc2VkIG9uIGRhdGFcclxuICAgICAgICA6IFwiMTAwJVwiLFxyXG4gICAgICBoZWlnaHQ6IFwiNDAwcHhcIixcclxuICAgIH19XHJcbiAgICBjbGFzc05hbWU9XCJyZWxhdGl2ZVwiXHJcbiAgPlxyXG4gICAgICAgICAgICA8Q2hhcnRDb21wb25lbnRcclxuICAgICAgICAgICAgICBkYXRhPXtkYXRhfVxyXG4gICAgICAgICAgICAgIG9wdGlvbnM9e3tcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNjYWxlczoge1xyXG4gICAgICAgICAgICAgICAgICB4OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpY2tzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBhdXRvU2tpcDogdHJ1ZSwgLy8gRW5hYmxlIGF1dG8tc2tpcHBpbmcgZm9yIGh1Z2UgZGF0YXNldHNcclxuICAgICAgICAgICAgICAgICAgICAgIG1heFRpY2tzTGltaXQ6IG1heFRpY2tzLCAvLyBMaW1pdCB2aXNpYmxlIHRpY2tzXHJcbiAgICAgICAgICAgICAgICAgICAgICBtYXhSb3RhdGlvbjogNDUsIC8vIEFsbG93IHNsaWdodCByb3RhdGlvbiBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgICAgICAgIG1pblJvdGF0aW9uOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMTAsIC8vIFNwYWNlIGJldHdlZW4gbGFiZWxzXHJcbiAgICAgICAgICAgICAgICAgICAgICBmb250OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDEyLCAvLyBDb250cm9sIGxhYmVsIHNpemVcclxuICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBncmlkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICB5OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcGx1Z2luczoge1xyXG4gICAgICAgICAgICAgICAgICBsZWdlbmQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInRvcFwiLFxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICB0b29sdGlwOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6ICdpbmRleCcsXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmcgdG8gZW5zdXJlIGxhYmVscyBhcmVuJ3QgY3V0IG9mZlxyXG4gICAgICAgICAgICAgICAgbGF5b3V0OiB7XHJcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAyMCxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogMjAsXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH07XHJcbiAgXHJcbiAgY29uc3QgZ2V0Q2hhcnRPcHRpb25zID0gKHR5cGU6IHN0cmluZykgPT4gKHtcclxuICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbiAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcclxuICAgIC8vIEVuc3VyZSBwcm9wZXIgc2Nyb2xsIGJlaGF2aW9yXHJcbiAgICBsYXlvdXQ6IHtcclxuICAgICAgcGFkZGluZzoge1xyXG4gICAgICAgIHJpZ2h0OiAyMCwgLy8gQWRkIHBhZGRpbmcgdG8gcHJldmVudCBjdXRvZmYgb24gc2Nyb2xsXHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgc2NhbGVzOiB7XHJcbiAgICAgIHg6IHtcclxuICAgICAgICBtaW46IDAsIC8vIFN0YXJ0aW5nIHBvaW50IGZvciBzY3JvbGxcclxuICAgICAgICB0aWNrczoge1xyXG4gICAgICAgICAgYXV0b1NraXA6IGZhbHNlLCAvLyBTaG93IGFsbCBsYWJlbHMgZXZlbiB3aGVuIHNjcm9sbGluZ1xyXG4gICAgICAgICAgbWF4Um90YXRpb246IDAsIC8vIFByZXZlbnQgbGFiZWwgcm90YXRpb25cclxuICAgICAgICAgIG1pblJvdGF0aW9uOiAwLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIHk6IHtcclxuICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBwbHVnaW5zOiB7XHJcbiAgICAgIGxlZ2VuZDogeyBcclxuICAgICAgICBkaXNwbGF5OiB0cnVlLCBcclxuICAgICAgICBwb3NpdGlvbjogXCJ0b3BcIixcclxuICAgICAgfSxcclxuICAgICAgdG9vbHRpcDogeyBcclxuICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgIC8vIEVuc3VyZSB0b29sdGlwcyB3b3JrIHdpdGggb3ZlcmZsb3dcclxuICAgICAgICBpbnRlcnNlY3Q6IGZhbHNlLFxyXG4gICAgICAgIG1vZGU6ICdpbmRleCcsXHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gIH0pO1xyXG4gIFxyXG4gIC8vIENTUyB0byBzdXBwb3J0IHNjcm9sbGluZ1xyXG4gIGNvbnN0IGNoYXJ0U3R5bGVzID0gYFxyXG4gICAgLm92ZXJmbG93LXgtYXV0byB7XHJcbiAgICAgIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcclxuICAgICAgc2Nyb2xsYmFyLXdpZHRoOiB0aGluO1xyXG4gICAgICBzY3JvbGxiYXItY29sb3I6ICM4ODggI2YxZjFmMTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLm92ZXJmbG93LXgtYXV0bzo6LXdlYmtpdC1zY3JvbGxiYXIge1xyXG4gICAgICBoZWlnaHQ6IDhweDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLm92ZXJmbG93LXgtYXV0bzo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWIge1xyXG4gICAgICBiYWNrZ3JvdW5kOiAjODg4O1xyXG4gICAgICBib3JkZXItcmFkaXVzOiA0cHg7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC5vdmVyZmxvdy14LWF1dG86Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrIHtcclxuICAgICAgYmFja2dyb3VuZDogI2YxZjFmMTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLm92ZXJmbG93LXktaGlkZGVuIHtcclxuICAgICAgb3ZlcmZsb3cteTogaGlkZGVuOyAvKiBQcmV2ZW50IHZlcnRpY2FsIHNjcm9sbCAqL1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBAbWVkaWEgKG1heC13aWR0aDogNjQwcHgpIHtcclxuICAgICAgLmNhcmQge1xyXG4gICAgICAgIHBhZGRpbmc6IDAuNzVyZW07XHJcbiAgICAgIH1cclxuICAgICAgLmNhcmQgPiBkaXYgPiBkaXYge1xyXG4gICAgICAgIGhlaWdodDogMzAwcHg7XHJcbiAgICAgICAgbWluLXdpZHRoOiA0MDBweDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIGA7XHJcbiAgXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBtZDpmbGV4LXJvdyBoLXNjcmVlbiBib3JkZXIgYm9yZGVyLWJsYWNrXCI+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMS80IGJnLXdoaXRlIHAtNSBib3JkZXItdCBtZDpib3JkZXItbCBtZDpib3JkZXItYmxhY2tcIj5cclxuICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPlVwbG9hZCBGaWxlPC9oMj5cclxuICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIiBvbkNoYW5nZT17aGFuZGxlRmlsZUNoYW5nZX0gY2xhc3NOYW1lPVwiYm9yZGVyIHAtMiB3LWZ1bGxcIiAvPlxyXG4gICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlU3VibWl0fSBjbGFzc05hbWU9XCJiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlIHAtMiByb3VuZGVkIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG10LTRcIj5cclxuICAgICAgICAgIDxCc1VwbG9hZCBjbGFzc05hbWU9XCJtci0yXCIgLz4gU3VibWl0XHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHNwYWNlLXktMiBtdC00XCI+XHJcbiAgICAgICAgICB7W1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiLCBcInNjYXR0ZXJDaGFydERhdGFcIiwgXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5tYXAoKHR5cGUpID0+IChcclxuICAgICAgICAgICAgPGJ1dHRvbiBrZXk9e3R5cGV9IG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkQ2hhcnQodHlwZSl9IGNsYXNzTmFtZT1cInAtMiBiZy1ncmF5LTMwMCByb3VuZGVkIGhvdmVyOmJnLWdyYXktNDAwXCI+XHJcbiAgICAgICAgICAgICAge3R5cGUucmVwbGFjZShcIkNoYXJ0RGF0YVwiLCBcIiBDaGFydFwiKX1cclxuICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICApKX1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMy80IGJnLWdyYXktMTAwIHAtNVwiPlxyXG4gIHtsb2FkaW5nID8gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBoLWZ1bGxcIj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGlubmVyLWJvcmRlciBhbmltYXRlLXNwaW4gYm9yZGVyLXQtNCBib3JkZXItYmx1ZS01MDAgcm91bmRlZC1mdWxsIHctMTIgaC0xMlwiPjwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgKSA6IChcclxuICAgIHNlbGVjdGVkQ2hhcnQgJiYgcmVuZGVyQ2hhcnQoc2VsZWN0ZWRDaGFydCwgeyBcclxuICAgICAgbGluZUNoYXJ0RGF0YTogTGluZSwgXHJcbiAgICAgIGJhckNoYXJ0RGF0YTogQmFyLCBcclxuICAgICAgc2NhdHRlckNoYXJ0RGF0YTogU2NhdHRlciwgXHJcbiAgICAgIHBpZUNoYXJ0RGF0YTogUGllLCBcclxuICAgICAgZG9udXRDaGFydERhdGE6IERvdWdobnV0IFxyXG4gICAgfVtzZWxlY3RlZENoYXJ0XSlcclxuICApfVxyXG4gIDxkaXYgY2xhc3NOYW1lPVwibXQtNCBmbGV4XCI+XHJcbiAgICA8aW5wdXRcclxuICAgICAgdHlwZT1cInRleHRcIlxyXG4gICAgICB2YWx1ZT17aW5wdXRWYWx1ZX1cclxuICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRJbnB1dFZhbHVlKGUudGFyZ2V0LnZhbHVlKX1cclxuICAgICAgY2xhc3NOYW1lPVwiYm9yZGVyIHAtMiBmbGV4LWdyb3cgbXItMiByb3VuZGVkXCJcclxuICAgICAgcGxhY2Vob2xkZXI9XCJFbnRlciB5b3VyIHRleHQgaGVyZVwiXHJcbiAgICAvPlxyXG4gICAgPGJ1dHRvbiBvbkNsaWNrPXtoYW5kbGVTZW5kfSBjbGFzc05hbWU9XCJiZy1ncmVlbi01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZFwiPlxyXG4gICAgICBTZW5kXHJcbiAgICA8L2J1dHRvbj5cclxuICA8L2Rpdj5cclxuICA8ZGl2IGNsYXNzTmFtZT1cIm10LTQgcC00IGJvcmRlciBib3JkZXItZ3JheS0zMDAgcm91bmRlZCBiZy13aGl0ZVwiPlxyXG4gICAgPGgzIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5JbnNpZ2h0czwvaDM+XHJcbiAgICB7Y29tYmluZWRJbnNpZ2h0cyA/IChcclxuICAgICAgPG9sIGNsYXNzTmFtZT1cImxpc3QtZGVjaW1hbCBsaXN0LWluc2lkZSB0ZXh0LXNtIHRleHQtZ3JheS03MDAgYmctZ3JheS0xMDAgcC0yIHJvdW5kZWQgbWF4LWgtNjAgb3ZlcmZsb3cteS1hdXRvXCI+XHJcbiAgICAgICAge2NvbWJpbmVkSW5zaWdodHMuc3BsaXQoJ1xcbicpLm1hcCgoaW5zaWdodDogc3RyaW5nIHwgbnVtYmVyIHwgYmlnaW50IHwgYm9vbGVhbiB8IFJlYWN0RWxlbWVudDxhbnksIHN0cmluZyB8IEpTWEVsZW1lbnRDb25zdHJ1Y3Rvcjxhbnk+PiB8IEl0ZXJhYmxlPFJlYWN0Tm9kZT4gfCBSZWFjdFBvcnRhbCB8IFByb21pc2U8QXdhaXRlZFJlYWN0Tm9kZT4gfCBudWxsIHwgdW5kZWZpbmVkLCBpbmRleDogS2V5IHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gKFxyXG4gICAgICAgICAgPGxpIGtleT17aW5kZXh9IGNsYXNzTmFtZT1cInB5LTFcIj57aW5zaWdodH08L2xpPlxyXG4gICAgICAgICkpfVxyXG4gICAgICA8L29sPlxyXG4gICAgKSA6IChcclxuICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTUwMFwiPk5vIGluc2lnaHRzIGF2YWlsYWJsZS48L3A+XHJcbiAgICApfVxyXG4gIDwvZGl2PlxyXG48L2Rpdj5cclxuXHJcbjxzdHlsZSBqc3g+e2BcclxuICAub3ZlcmZsb3cteC1hdXRvIHtcclxuICAgIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcclxuICAgIHNjcm9sbGJhci13aWR0aDogdGhpbjtcclxuICAgIHNjcm9sbGJhci1jb2xvcjogIzg4OCAjZjFmMWYxO1xyXG4gIH1cclxuXHJcbiAgLm92ZXJmbG93LXgtYXV0bzo6LXdlYmtpdC1zY3JvbGxiYXIge1xyXG4gICAgaGVpZ2h0OiA4cHg7XHJcbiAgfVxyXG5cclxuICAub3ZlcmZsb3cteC1hdXRvOjotd2Via2l0LXNjcm9sbGJhci10aHVtYiB7XHJcbiAgICBiYWNrZ3JvdW5kOiAjODg4O1xyXG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xyXG4gIH1cclxuXHJcbiAgLm92ZXJmbG93LXgtYXV0bzo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2sge1xyXG4gICAgYmFja2dyb3VuZDogI2YxZjFmMTtcclxuICB9XHJcblxyXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA3NjhweCkge1xyXG4gICAgLm92ZXJmbG93LXgtYXV0byA+IGRpdiB7XHJcbiAgICAgIG1pbi13aWR0aDogNDAwcHg7XHJcbiAgICAgIGhlaWdodDogMzAwcHg7XHJcbiAgICB9XHJcbiAgfVxyXG5gfTwvc3R5bGU+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlUmVmIiwiQmFyIiwiTGluZSIsIkRvdWdobnV0IiwiUGllIiwiU2NhdHRlciIsIkNoYXJ0IiwiQ2hhcnRKUyIsIkNhdGVnb3J5U2NhbGUiLCJMaW5lYXJTY2FsZSIsIkJhckVsZW1lbnQiLCJMaW5lRWxlbWVudCIsIlBvaW50RWxlbWVudCIsIkFyY0VsZW1lbnQiLCJUaXRsZSIsIlRvb2x0aXAiLCJMZWdlbmQiLCJCc1VwbG9hZCIsInpvb21QbHVnaW4iLCJyZWdpc3RlciIsIkRhc2hib2FyZCIsImNoYXJ0RGF0YSIsInNldENoYXJ0RGF0YSIsInNjYXR0ZXJDaGFydERhdGEiLCJwaWVDaGFydERhdGEiLCJkb251dENoYXJ0RGF0YSIsImxpbmVDaGFydERhdGEiLCJiYXJDaGFydERhdGEiLCJzZWxlY3RlZEZpbGUiLCJzZXRTZWxlY3RlZEZpbGUiLCJzZWxlY3RlZENoYXJ0Iiwic2V0U2VsZWN0ZWRDaGFydCIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiY2hhcnRXaWR0aCIsInNldENoYXJ0V2lkdGgiLCJpbnB1dFZhbHVlIiwic2V0SW5wdXRWYWx1ZSIsInN0b3JlZFByb2Nlc3NlZERhdGEiLCJzZXRTdG9yZWRQcm9jZXNzZWREYXRhIiwiY29tYmluZWRJbnNpZ2h0cyIsInNldENvbWJpbmVkSW5zaWdodHMiLCJjaGFydFJlZiIsImhhbmRsZUZpbGVDaGFuZ2UiLCJldmVudCIsInRhcmdldCIsImZpbGVzIiwiaGFuZGxlU3VibWl0IiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImFwcGVuZCIsInJlc3VsdCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJib2R5Iiwib2siLCJFcnJvciIsImpzb24iLCJkYXRhIiwicHJvY2Vzc2VkRGF0YSIsImNvbnNvbGUiLCJsb2ciLCJsaWdodENvbG9ycyIsImdlbmVyYXRlQ2hhcnREYXRhIiwiY2hhcnRUeXBlIiwiY2hhcnRJbmZvIiwibGFiZWxzIiwiT2JqZWN0Iiwia2V5cyIsInZhbHVlcyIsImluY2x1ZGVzIiwibGVuZ3RoIiwiZGF0YXNldHMiLCJsYWJlbCIsImJhY2tncm91bmRDb2xvciIsInNsaWNlIiwiYm9yZGVyQ29sb3IiLCJ1bmRlZmluZWQiLCJmaWxsIiwibWV0YSIsImhlYWRlciIsInZhbHVlTmFtZSIsImVycm9yIiwiaGFuZGxlU2VuZCIsImdyYXBoRGF0YSIsImZpbHRlcmVkUHJvY2Vzc2VkRGF0YSIsImRhdGFPYmplY3QiLCJyZWR1Y2UiLCJvYmoiLCJpbmRleCIsImNoYXJ0VHlwZU1hcHBpbmciLCJzZWxlY3RlZENoYXJ0VHlwZSIsInJlcXVlc3RCb2R5IiwicXVlc3Rpb24iLCJlbmNvZGVVUklDb21wb25lbnQiLCJoZWFkZXJzIiwiSlNPTiIsInN0cmluZ2lmeSIsInByZXZDaGFydERhdGEiLCJyZW5kZXJDaGFydCIsInR5cGUiLCJDaGFydENvbXBvbmVudCIsImRhdGFMZW5ndGgiLCJtYXhUaWNrcyIsIk1hdGgiLCJmbG9vciIsImRpdiIsImNsYXNzTmFtZSIsInN0eWxlIiwid2lkdGgiLCJtaW5XaWR0aCIsIm1heCIsImhlaWdodCIsIm9wdGlvbnMiLCJyZXNwb25zaXZlIiwibWFpbnRhaW5Bc3BlY3RSYXRpbyIsInNjYWxlcyIsIngiLCJtaW4iLCJ0aWNrcyIsImF1dG9Ta2lwIiwibWF4VGlja3NMaW1pdCIsIm1heFJvdGF0aW9uIiwibWluUm90YXRpb24iLCJwYWRkaW5nIiwiZm9udCIsInNpemUiLCJncmlkIiwiZGlzcGxheSIsInkiLCJiZWdpbkF0WmVybyIsInBsdWdpbnMiLCJsZWdlbmQiLCJwb3NpdGlvbiIsInRvb2x0aXAiLCJlbmFibGVkIiwiaW50ZXJzZWN0IiwibW9kZSIsImxheW91dCIsImxlZnQiLCJyaWdodCIsImdldENoYXJ0T3B0aW9ucyIsImNoYXJ0U3R5bGVzIiwiaDIiLCJpbnB1dCIsIm9uQ2hhbmdlIiwiYnV0dG9uIiwib25DbGljayIsIm1hcCIsInJlcGxhY2UiLCJ2YWx1ZSIsImUiLCJwbGFjZWhvbGRlciIsImgzIiwib2wiLCJzcGxpdCIsImluc2lnaHQiLCJsaSIsInAiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/pages/Upload/Upload.tsx\n"));

/***/ })

});