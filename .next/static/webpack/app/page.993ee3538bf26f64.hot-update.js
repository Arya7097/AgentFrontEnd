"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/app/pages/Upload/Upload.tsx":
/*!*****************************************!*\
  !*** ./src/app/pages/Upload/Upload.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Dashboard)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! styled-jsx/style */ \"(app-pages-browser)/./node_modules/styled-jsx/style.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-chartjs-2 */ \"(app-pages-browser)/./node_modules/react-chartjs-2/dist/index.js\");\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! chart.js */ \"(app-pages-browser)/./node_modules/chart.js/dist/chart.js\");\n/* harmony import */ var _barrel_optimize_names_BsUpload_react_icons_bs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=BsUpload!=!react-icons/bs */ \"(app-pages-browser)/./node_modules/react-icons/bs/index.mjs\");\n/* harmony import */ var chartjs_plugin_zoom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! chartjs-plugin-zoom */ \"(app-pages-browser)/./node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js\");\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n// } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// ChartJS.register(\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n//   zoomPlugin\n// );\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string;\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[];\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const [selectedLabels, setSelectedLabels] = useState<string[]>([]);\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: chartType.includes(\"Bar\")\n//                 ? \"rgba(54, 162, 235, 0.5)\"\n//                 : \"rgba(255, 99, 132, 0.5)\",\n//               borderColor: chartType.includes(\"Line\")\n//                 ? \"rgba(255, 99, 132, 1)\"\n//                 : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   useEffect(() => {\n//     if (selectedChart && chartData[selectedChart]) {\n//       const baseLabels = chartData[selectedChart]?.labels || [];\n//       setChartWidth((selectedLabels.length || baseLabels.length) * 150);\n//     }\n//   }, [selectedChart, selectedLabels, chartData]);\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//           x: {\n//             ticks: {\n//               autoSkip: false,\n//               maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//               minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//               autoSkipPadding: 20,\n//             },\n//             grid: {\n//               display: true,\n//               drawTicks: false,\n//               tickLength: 100,\n//               lineWidth: 1\n//             },\n//           },\n//           y: {\n//             beginAtZero: true,\n//             ticks: {\n//               precision: 0,\n//             },\n//           },\n//         },\n//     plugins: {\n//       legend: {\n//         display: true,\n//         position: \"top\",\n//       },\n//       tooltip: {\n//         enabled: true,\n//       },\n//     },\n//   });\n//   const applyFilter = (data: ChartData | null) => {\n//     if (!data) return data;\n//     const filteredLabels = selectedLabels.length\n//       ? data.labels.filter(label => selectedLabels.includes(label))\n//       : data.labels;\n//     const filteredData = data.datasets.map(dataset => ({\n//       ...dataset,\n//       data: filteredLabels.map(label => dataset.data[data.labels.indexOf(label)])\n//     }));\n//     return {\n//       labels: filteredLabels,\n//       datasets: filteredData,\n//     };\n//   };\n//   const handleCheckboxChange = (label: string) => {\n//     setSelectedLabels(prev =>\n//       prev.includes(label)\n//         ? prev.filter(item => item !== label)\n//         : [...prev, label]\n//     );\n//   };\n//   const handleSelectAll = () => {\n//     if (selectedChart && chartData[selectedChart]) {\n//       setSelectedLabels(chartData[selectedChart]?.labels || []);\n//     }\n//   };\n//   const handleClearAll = () => {\n//     setSelectedLabels([]);\n//   };\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = applyFilter(chartData[type]);\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div\n//               style={{\n//                 minWidth: [\"lineChartData\", \"barChartData\"].includes(type)\n//                   ? `${chartWidth}px`\n//                   : \"auto\",\n//                 height: \"400px\",\n//               }}\n//             >\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button\n//           onClick={handleSubmit}\n//           className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\"\n//         >\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         {selectedChart && (\n//           <div className=\"mt-4\">\n//             <h3 className=\"font-semibold\">Filters</h3>\n//             <button onClick={handleSelectAll} className=\"bg-green-500 text-white px-2 py-1 rounded mt-2\">Select All</button>\n//             <button onClick={handleClearAll} className=\"bg-red-500 text-white px-2 py-1 rounded mt-2 ml-2\">Clear All</button>\n//             {chartData[selectedChart]?.labels.map(label => (\n//               <div key={label} className=\"flex items-center\">\n//                 <input\n//                   type=\"checkbox\"\n//                   checked={selectedLabels.includes(label)}\n//                   onChange={() => handleCheckboxChange(label)}\n//                 />\n//                 <label className=\"ml-2\">{label}</label>\n//               </div>\n//             ))}\n//           </div>\n//         )}\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map(\n//             (type) => (\n//               <button\n//                 key={type}\n//                 onClick={() => {\n//                   setSelectedChart(type);\n//                   setSelectedLabels([]);\n//                 }}\n//                 className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\"\n//               >\n//                 {type.replace(\"ChartData\", \" Chart\")}\n//               </button>\n//             )\n//           )}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           renderChart(selectedChart, {\n//             lineChartData: Line,\n//             barChartData: Bar,\n//             scatterChartData: Scatter,\n//             pieChartData: Pie,\n//             donutChartData: Doughnut,\n//           }[selectedChart])\n//         )}\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n// } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// import { log } from \"node:console\";\n// ChartJS.register(\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n//   zoomPlugin\n// );\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string;\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[];\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n// console.log(\"processedData\",processedData);\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//  console.log(\"labels.length \",chartType,labels.length );\n//  console.log(\"values.length \",chartType,values.length );\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: chartType.includes(\"Bar\")\n//                 ? \"rgba(54, 162, 235, 0.5)\"\n//                 : \"rgba(255, 99, 132, 0.5)\",\n//               borderColor: chartType.includes(\"Line\")\n//                 ? \"rgba(255, 99, 132, 1)\"\n//                 : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//         };\n//       };\n// console.log(\"generateChartData\",generateChartData);\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//         x: {\n//           ticks: {\n//             autoSkip: false,\n//             maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//         minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//             autoSkipPadding: 20,\n//           },\n//           grid: {\n//             display: true,\n//             drawTicks: false,\n//             tickLength: 100,\n//             lineWidth: 1\n//           },\n//         },\n//           y: {\n//             beginAtZero: true,\n//             ticks: {\n//               precision: 0,\n//             },\n//           },\n//         },\n//     plugins: {\n//       legend: {\n//         display: true,\n//         position: \"top\",\n//       },\n//       tooltip: {\n//         enabled: true,\n//       },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div\n//               style={{\n//                 minWidth: [\"lineChartData\", \"barChartData\"].includes(type)\n//                   ? `${chartWidth}px`\n//                   : \"auto\",\n//                 height: \"400px\",\n//               }}\n//             >\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button\n//           onClick={handleSubmit}\n//           className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\"\n//         >\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map(\n//             (type) => (\n//               <button\n//                 key={type}\n//                 onClick={() => setSelectedChart(type)}\n//                 className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\"\n//               >\n//                 {type.replace(\"ChartData\", \" Chart\")}\n//               </button>\n//             )\n//           )}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           renderChart(selectedChart, {\n//             lineChartData: Line,\n//             barChartData: Bar,\n//             scatterChartData: Scatter,\n//             pieChartData: Pie,\n//             donutChartData: Doughnut,\n//           }[selectedChart])\n//         )}\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n// } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// import { log } from \"node:console\";\n// ChartJS.register(\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n//   zoomPlugin\n// );\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string | string[];\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[];\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       const lightColors = [\n//         \"rgba(173, 216, 230, 0.6)\",\n//         \"rgba(144, 238, 144, 0.6)\",\n//         \"rgba(255, 182, 193, 0.6)\",\n//         \"rgba(255, 228, 181, 0.6)\",\n//         \"rgba(221, 160, 221, 0.6)\",\n//         \"rgba(240, 230, 140, 0.6)\",\n//       ];\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? lightColors.slice(0, labels.length)\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\")\n//                 ? \"rgba(135, 206, 250, 1)\"\n//                 : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n// x: {\n//   ticks: {\n//     autoSkip: false,\n//     maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n// minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//     autoSkipPadding: 20,\n//   },\n//   grid: {\n//     display: true,\n//     drawTicks: false,\n//     tickLength: 100,\n//     lineWidth: 1\n//   },\n// },\n//           y: {\n//             beginAtZero: true,\n//             ticks: {\n//               precision: 0,\n//             },\n//           },\n//         },\n//     plugins: {\n//       legend: {\n//         display: true,\n//         position: \"top\",\n//       },\n//       tooltip: {\n//         enabled: true,\n//       },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div\n//               style={{\n//                 minWidth: [\"lineChartData\", \"barChartData\"].includes(type)\n//                   ? `${chartWidth}px`\n//                   : \"auto\",\n//                 height: \"400px\",\n//               }}\n//             >\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button\n//           onClick={handleSubmit}\n//           className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\"\n//         >\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map(\n//             (type) => (\n//               <button\n//                 key={type}\n//                 onClick={() => setSelectedChart(type)}\n//                 className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\"\n//               >\n//                 {type.replace(\"ChartData\", \" Chart\")}\n//               </button>\n//             )\n//           )}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           renderChart(selectedChart, {\n//             lineChartData: Line,\n//             barChartData: Bar,\n//             scatterChartData: Scatter,\n//             pieChartData: Pie,\n//             donutChartData: Doughnut,\n//           }[selectedChart])\n//         )}\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n// } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// ChartJS.register(\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n//   zoomPlugin\n// );\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string | string[];\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[];\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const [inputValue, setInputValue] = useState<string>(\"\");\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       const lightColors = [\n//         \"rgba(173, 216, 230, 0.6)\",\n//         \"rgba(144, 238, 144, 0.6)\",\n//         \"rgba(255, 182, 193, 0.6)\",\n//         \"rgba(255, 228, 181, 0.6)\",\n//         \"rgba(221, 160, 221, 0.6)\",\n//         \"rgba(240, 230, 140, 0.6)\",\n//       ];\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? lightColors.slice(0, labels.length)\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\")\n//                 ? \"rgba(135, 206, 250, 1)\"\n//                 : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const handleSend = () => {\n//     console.log(\"Input Value:\", inputValue);\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//         x: {\n//           ticks: {\n//             autoSkip: false,\n//             maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//         minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//             autoSkipPadding: 20,\n//           },\n//           grid: {\n//             display: true,\n//             drawTicks: false,\n//             tickLength: 100,\n//             lineWidth: 1\n//           },\n//         },\n//           y: {\n//             beginAtZero: true,\n//             ticks: {\n//               precision: 0,\n//             },\n//           },\n//         },\n//     plugins: {\n//       legend: {\n//         display: true,\n//         position: \"top\",\n//       },\n//       tooltip: {\n//         enabled: true,\n//       },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div\n//               style={{\n//                 minWidth: [\"lineChartData\", \"barChartData\"].includes(type)\n//                   ? `${chartWidth}px`\n//                   : \"auto\",\n//                 height: \"400px\",\n//               }}\n//             >\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button\n//           onClick={handleSubmit}\n//           className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\"\n//         >\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map(\n//             (type) => (\n//               <button\n//                 key={type}\n//                 onClick={() => setSelectedChart(type)}\n//                 className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\"\n//               >\n//                 {type.replace(\"ChartData\", \" Chart\")}\n//               </button>\n//             )\n//           )}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           renderChart(selectedChart, {\n//             lineChartData: Line,\n//             barChartData: Bar,\n//             scatterChartData: Scatter,\n//             pieChartData: Pie,\n//             donutChartData: Doughnut,\n//           }[selectedChart])\n//         )}\n//         <div className=\"mt-4 flex\">\n//           <input\n//             type=\"text\"\n//             value={inputValue}\n//             onChange={(e) => setInputValue(e.target.value)}\n//             className=\"border p-2 flex-grow mr-2 rounded\"\n//             placeholder=\"Enter your text here\"\n//           />\n//           <button\n//             onClick={handleSend}\n//             className=\"bg-green-500 text-white p-2 rounded\"\n//           >\n//             Send\n//           </button>\n//         </div>\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import { Chart as ChartJS, CategoryScale, LinearScale, BarElement, LineElement, PointElement, ArcElement, Title, Tooltip, Legend } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// ChartJS.register(CategoryScale, LinearScale, BarElement, LineElement, PointElement, ArcElement, Title, Tooltip, Legend, zoomPlugin);\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string | string[];\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[]\n//   meta?: {\n//     header: string;\n//     valueName: string;\n//   };\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const [inputValue, setInputValue] = useState<string>(\"\");\n//   const [storedProcessedData, setStoredProcessedData] = useState<any>(null); // New state to store processed data\n//   const [combinedInsights, setCombinedInsights] = useState<any>(null);\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const combinedInsights = result.data?.combinedInsights;\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n// console.log(\"processedData\",processedData);\n//       setStoredProcessedData(processedData); // Store the processed data\n//       setCombinedInsights(combinedInsights);\n//       const lightColors = [\n//         \"rgba(173, 216, 230, 0.6)\",\n//         \"rgba(144, 238, 144, 0.6)\",\n//         \"rgba(255, 182, 193, 0.6)\",\n//         \"rgba(255, 228, 181, 0.6)\",\n//         \"rgba(221, 160, 221, 0.6)\",\n//         \"rgba(240, 230, 140, 0.6)\",\n//       ];\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? lightColors.slice(0, labels.length)\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//           meta: {\n//             header: chartInfo.header || \"default_header\",\n//             valueName: chartInfo.valueName || \"default_valueName\",\n//           },\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const handleSend = async () => {\n//     if (!inputValue) return;\n//     const graphData = chartData[selectedChart];\n//     if (!graphData) return;\n//     const labels = graphData.labels;\n//     const values = graphData.datasets[0].data;\n//     const dataObject = labels.reduce((obj: { [key: string]: number }, label, index) => {\n//       obj[label] = values[index];\n//       return obj;\n//     }, {});\n//     const chartTypeMapping: Record<string, string> = {\n//       lineChartData: \"Line Chart\",\n//       pieChartData: \"Pie Chart\",\n//       donutChartData: \"Donut Chart\",\n//       barChartData: \"Bar Chart\",\n//       scatterChartData: \"Scatter Plot\",\n//     };\n//     const selectedChartType = chartTypeMapping[selectedChart] || selectedChart;\n//     // Filter the stored processed data to include only the selected chart's data\n//     const filteredProcessedData = {\n//       [selectedChartType]: storedProcessedData[selectedChartType],\n//     };\n//     console.log(\"...filteredProcessedData,\", filteredProcessedData[selectedChartType]?.[0]?.data);\n//     console.log(\"dataObject,\", dataObject);\n//     const requestBody = {\n//       question: inputValue,\n//       processedData: {\n//         // Include the stored processed data\n//         [selectedChartType]: [\n//           {\n//             header: graphData.meta?.header || \"default_header\",\n//             valueName: graphData.meta?.valueName || \"default_valueName\",\n//             label: graphData.datasets[0].label,\n//             data: filteredProcessedData[selectedChartType]?.[0]?.data,\n//           },\n//         ],\n//       },\n//     };\n//     try {\n//       const response = await fetch(\n//         `http://localhost:3012/api/answer-analyze-excel?question=${encodeURIComponent(inputValue)}`,\n//         {\n//           method: \"POST\",\n//           headers: { \"Content-Type\": \"application/json\" },\n//           body: JSON.stringify(requestBody),\n//         }\n//       );\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       console.log(\"Updated API Response Data:\", processedData);\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0]; // Use only API response data\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? [\"rgba(173, 216, 230, 0.6)\", \"rgba(144, 238, 144, 0.6)\", \"rgba(255, 182, 193, 0.6)\"]\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//           meta: {\n//             header: chartInfo.header || \"default_header\",\n//             valueName: chartInfo.valueName || \"default_valueName\",\n//           },\n//         };\n//       };\n//       // Only update chartData without storing in storedProcessedData\n//       setChartData((prevChartData) => ({\n//         ...prevChartData,\n//         [selectedChart]: generateChartData(selectedChartType),\n//       }));\n//     } catch (error) {\n//       console.error(\"Error sending request:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//         x: {\n//           ticks: {\n//             autoSkip: false,\n//             maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//         minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//             autoSkipPadding: 20,\n//           },\n//           grid: {\n//             display: true,\n//             drawTicks: false,\n//             tickLength: 100,\n//             lineWidth: 1\n//           },\n//         },\n//         y: {\n//           beginAtZero: true,\n//           ticks: { precision: 0 },\n//         },\n//       },\n//     plugins: {\n//       legend: { display: true, position: \"top\" },\n//       tooltip: { enabled: true },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div style={{ minWidth: [\"lineChartData\", \"barChartData\"].includes(type) ? `${chartWidth}px` : \"auto\", height: \"400px\" }}>\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button onClick={handleSubmit} className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\">\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map((type) => (\n//             <button key={type} onClick={() => setSelectedChart(type)} className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\">\n//               {type.replace(\"ChartData\", \" Chart\")}\n//             </button>\n//           ))}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           selectedChart && renderChart(selectedChart, { lineChartData: Line, barChartData: Bar, scatterChartData: Scatter, pieChartData: Pie, donutChartData: Doughnut }[selectedChart])\n//         )}\n//         <div className=\"mt-4 flex\">\n//           <input\n//             type=\"text\"\n//             value={inputValue}\n//             onChange={(e) => setInputValue(e.target.value)}\n//             className=\"border p-2 flex-grow mr-2 rounded\"\n//             placeholder=\"Enter your text here\"\n//           />\n//           <button onClick={handleSend} className=\"bg-green-500 text-white p-2 rounded\">\n//             Send\n//           </button>\n//         </div>\n//         <div className=\"mt-4 p-4 border border-gray-300 rounded bg-white\">\n//         <h3 className=\"text-lg font-bold mb-2\">Insights</h3>\n//         {combinedInsights ? (\n//             <ol className=\"list-decimal list-inside text-sm text-gray-700 bg-gray-100 p-2 rounded overflow-auto\">\n//             {combinedInsights.split('\\n').map((insight, index) => (\n//               <ul key={index}>{insight}</ul>\n//             ))}\n//           </ol>\n//         ) : (\n//           <p className=\"text-gray-500\">No insights available.</p>\n//         )}\n//       </div>\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect, useRef } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import { Chart as ChartJS, CategoryScale, LinearScale, BarElement, LineElement, PointElement, ArcElement, Title, Tooltip, Legend } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// import html2canvas from \"html2canvas\";\n// import jsPDF from \"jspdf\";\n// ChartJS.register(CategoryScale, LinearScale, BarElement, LineElement, PointElement, ArcElement, Title, Tooltip, Legend, zoomPlugin);\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string | string[];\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[]\n//   meta?: {\n//     header: string;\n//     valueName: string;\n//   };\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const [inputValue, setInputValue] = useState<string>(\"\");\n//   const [storedProcessedData, setStoredProcessedData] = useState<any>(null); // New state to store processed data\n//   const [combinedInsights, setCombinedInsights] = useState<any>(null);\n//   const chartRef = useRef<HTMLDivElement>(null); // Ref for the chart container\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const combinedInsights = result.data?.combinedInsights;\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n// console.log(\"processedData\",processedData);\n//       setStoredProcessedData(processedData); // Store the processed data\n//       setCombinedInsights(combinedInsights);\n//       const lightColors = [\n//         \"rgba(173, 216, 230, 0.6)\",\n//         \"rgba(144, 238, 144, 0.6)\",\n//         \"rgba(255, 182, 193, 0.6)\",\n//         \"rgba(255, 228, 181, 0.6)\",\n//         \"rgba(221, 160, 221, 0.6)\",\n//         \"rgba(240, 230, 140, 0.6)\",\n//       ];\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? lightColors.slice(0, labels.length)\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//           meta: {\n//             header: chartInfo.header || \"default_header\",\n//             valueName: chartInfo.valueName || \"default_valueName\",\n//           },\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const handleSend = async () => {\n//     if (!inputValue) return;\n//     const graphData = chartData[selectedChart];\n//     if (!graphData) return;\n//     const labels = graphData.labels;\n//     const values = graphData.datasets[0].data;\n//     const dataObject = labels.reduce((obj: { [key: string]: number }, label, index) => {\n//       obj[label] = values[index];\n//       return obj;\n//     }, {});\n//     const chartTypeMapping: Record<string, string> = {\n//       lineChartData: \"Line Chart\",\n//       pieChartData: \"Pie Chart\",\n//       donutChartData: \"Donut Chart\",\n//       barChartData: \"Bar Chart\",\n//       scatterChartData: \"Scatter Plot\",\n//     };\n//     const selectedChartType = chartTypeMapping[selectedChart] || selectedChart;\n//     // Filter the stored processed data to include only the selected chart's data\n//     const filteredProcessedData = {\n//       [selectedChartType]: storedProcessedData[selectedChartType],\n//     };\n//     console.log(\"...filteredProcessedData,\", filteredProcessedData[selectedChartType]?.[0]?.data);\n//     console.log(\"dataObject,\", dataObject);\n//     const requestBody = {\n//       question: inputValue,\n//       processedData: {\n//         // Include the stored processed data\n//         [selectedChartType]: [\n//           {\n//             header: graphData.meta?.header || \"default_header\",\n//             valueName: graphData.meta?.valueName || \"default_valueName\",\n//             label: graphData.datasets[0].label,\n//             data: filteredProcessedData[selectedChartType]?.[0]?.data,\n//           },\n//         ],\n//       },\n//     };\n//     try {\n//       const response = await fetch(\n//         `http://localhost:3012/api/answer-analyze-excel?question=${encodeURIComponent(inputValue)}`,\n//         {\n//           method: \"POST\",\n//           headers: { \"Content-Type\": \"application/json\" },\n//           body: JSON.stringify(requestBody),\n//         }\n//       );\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       console.log(\"Updated API Response Data:\", processedData);\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0]; // Use only API response data\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? [\"rgba(173, 216, 230, 0.6)\", \"rgba(144, 238, 144, 0.6)\", \"rgba(255, 182, 193, 0.6)\"]\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//           meta: {\n//             header: chartInfo.header || \"default_header\",\n//             valueName: chartInfo.valueName || \"default_valueName\",\n//           },\n//         };\n//       };\n//       // Only update chartData without storing in storedProcessedData\n//       setChartData((prevChartData) => ({\n//         ...prevChartData,\n//         [selectedChart]: generateChartData(selectedChartType),\n//       }));\n//     } catch (error) {\n//       console.error(\"Error sending request:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//         x: {\n//           ticks: {\n//             autoSkip: false,\n//             maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//         minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//             autoSkipPadding: 20,\n//           },\n//           grid: {\n//             display: true,\n//             drawTicks: false,\n//             tickLength: 100,\n//             lineWidth: 1\n//           },\n//         },\n//         y: {\n//           beginAtZero: true,\n//           ticks: { precision: 0 },\n//         },\n//       },\n//     plugins: {\n//       legend: { display: true, position: \"top\" },\n//       tooltip: { enabled: true },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div style={{ minWidth: [\"lineChartData\", \"barChartData\"].includes(type) ? `${chartWidth}px` : \"auto\", height: \"400px\" }}>\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   const handleDownloadPDF = async () => {\n//     if (!chartRef.current) return;\n//     // Temporarily set the chart container to its full height to capture all content\n//     const originalHeight = chartRef.current.style.height;\n//     chartRef.current.style.height = `${chartRef.current.scrollHeight}px`;\n//     const canvas = await html2canvas(chartRef.current, {\n//       scrollX: 0,\n//       scrollY: -window.scrollY,\n//       width: chartRef.current.scrollWidth,\n//       height: chartRef.current.scrollHeight,\n//     });\n//     // Restore the original height of the chart container\n//     chartRef.current.style.height = originalHeight;\n//     const imgData = canvas.toDataURL(\"image/png\");\n//     const pdf = new jsPDF(\"landscape\", \"mm\", \"a4\");\n//     const imgProps = pdf.getImageProperties(imgData);\n//     const pdfWidth = pdf.internal.pageSize.getWidth();\n//     const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;\n//     pdf.addImage(imgData, \"PNG\", 0, 0, pdfWidth, pdfHeight);\n//     pdf.save(\"chart.pdf\");\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button onClick={handleSubmit} className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\">\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map((type) => (\n//             <button key={type} onClick={() => setSelectedChart(type)} className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\">\n//               {type.replace(\"ChartData\", \" Chart\")}\n//             </button>\n//           ))}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           selectedChart && renderChart(selectedChart, { lineChartData: Line, barChartData: Bar, scatterChartData: Scatter, pieChartData: Pie, donutChartData: Doughnut }[selectedChart])\n//         )}\n//         <div className=\"mt-4 flex\">\n//           <input\n//             type=\"text\"\n//             value={inputValue}\n//             onChange={(e) => setInputValue(e.target.value)}\n//             className=\"border p-2 flex-grow mr-2 rounded\"\n//             placeholder=\"Enter your text here\"\n//           />\n//           <button onClick={handleSend} className=\"bg-green-500 text-white p-2 rounded\">\n//             Send\n//           </button>\n//         </div>\n//         <div className=\"mt-4 p-4 border border-gray-300 rounded bg-white\">\n//           <h3 className=\"text-lg font-bold mb-2\">Insights</h3>\n//           {combinedInsights ? (\n//             <ol className=\"list-decimal list-inside text-sm text-gray-700 bg-gray-100 p-2 rounded overflow-auto\">\n//               {combinedInsights.split('\\n').map((insight, index) => (\n//                 <ul key={index}>{insight}</ul>\n//               ))}\n//             </ol>\n//           ) : (\n//             <p className=\"text-gray-500\">No insights available.</p>\n//           )}\n//         </div>\n//         <button onClick={handleDownloadPDF} className=\"bg-red-500 text-white p-2 rounded mt-4\">\n//           Download as PDF\n//         </button>\n//       </div>\n//     </div>\n//   );\n// }\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nchart_js__WEBPACK_IMPORTED_MODULE_4__.Chart.register(chart_js__WEBPACK_IMPORTED_MODULE_4__.CategoryScale, chart_js__WEBPACK_IMPORTED_MODULE_4__.LinearScale, chart_js__WEBPACK_IMPORTED_MODULE_4__.BarElement, chart_js__WEBPACK_IMPORTED_MODULE_4__.LineElement, chart_js__WEBPACK_IMPORTED_MODULE_4__.PointElement, chart_js__WEBPACK_IMPORTED_MODULE_4__.ArcElement, chart_js__WEBPACK_IMPORTED_MODULE_4__.Title, chart_js__WEBPACK_IMPORTED_MODULE_4__.Tooltip, chart_js__WEBPACK_IMPORTED_MODULE_4__.Legend, chartjs_plugin_zoom__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\nfunction Dashboard() {\n    _s();\n    const [chartData, setChartData] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({\n        scatterChartData: null,\n        pieChartData: null,\n        donutChartData: null,\n        lineChartData: null,\n        barChartData: null\n    });\n    const [selectedFile, setSelectedFile] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [selectedChart, setSelectedChart] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"lineChartData\");\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [chartWidth, setChartWidth] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(0);\n    const [inputValue, setInputValue] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [storedProcessedData, setStoredProcessedData] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null); // New state to store processed data\n    const [combinedInsights, setCombinedInsights] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null); // Ref for the chart container\n    const handleFileChange = (event)=>{\n        var _event_target_files;\n        setSelectedFile(((_event_target_files = event.target.files) === null || _event_target_files === void 0 ? void 0 : _event_target_files[0]) || null);\n    };\n    const handleSubmit = async ()=>{\n        if (!selectedFile) return;\n        setLoading(true);\n        const formData = new FormData();\n        formData.append(\"file\", selectedFile);\n        try {\n            var _result_data, _result_data1;\n            const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n                method: \"POST\",\n                body: formData\n            });\n            if (!response.ok) throw new Error(\"Error uploading file.\");\n            const result = await response.json();\n            const combinedInsights = (_result_data = result.data) === null || _result_data === void 0 ? void 0 : _result_data.combinedInsights;\n            const processedData = (_result_data1 = result.data) === null || _result_data1 === void 0 ? void 0 : _result_data1.processedData;\n            if (!processedData) throw new Error(\"Invalid response structure.\");\n            console.log(\"processedData\", processedData);\n            setStoredProcessedData(processedData); // Store the processed data\n            setCombinedInsights(combinedInsights);\n            const lightColors = [\n                \"rgba(173, 216, 230, 0.6)\",\n                \"rgba(144, 238, 144, 0.6)\",\n                \"rgba(255, 182, 193, 0.6)\",\n                \"rgba(255, 228, 181, 0.6)\",\n                \"rgba(221, 160, 221, 0.6)\",\n                \"rgba(240, 230, 140, 0.6)\"\n            ];\n            const generateChartData = (chartType)=>{\n                var _processedData_chartType;\n                const chartInfo = (_processedData_chartType = processedData[chartType]) === null || _processedData_chartType === void 0 ? void 0 : _processedData_chartType[0];\n                if (!chartInfo) return null;\n                const labels = Object.keys(chartInfo.data);\n                const values = Object.values(chartInfo.data);\n                console.log(\"chartType\", chartType);\n                let chartWidth = 0;\n                if ([\n                    \"Line Chart\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150;\n                } else if ([\n                    \"Bar Chart\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150; // Adjust the width for bar chart\n                } else if ([\n                    \"Scatter Plot\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150; // Adjust the width for bar chart\n                } else {\n                    chartWidth = 400; // Default width for other chart types\n                }\n                setChartWidth(chartWidth);\n                return {\n                    labels,\n                    datasets: [\n                        {\n                            label: chartInfo.label || chartType,\n                            data: values,\n                            backgroundColor: [\n                                \"Pie Chart\",\n                                \"Donut Chart\",\n                                \"Bar Chart\"\n                            ].includes(chartType) ? lightColors.slice(0, labels.length) : \"rgba(135, 206, 250, 0.6)\",\n                            borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n                            fill: !chartType.includes(\"Line\")\n                        }\n                    ],\n                    meta: {\n                        header: chartInfo.header || \"default_header\",\n                        valueName: chartInfo.valueName || \"default_valueName\"\n                    }\n                };\n            };\n            setChartData({\n                scatterChartData: generateChartData(\"Scatter Plot\"),\n                pieChartData: generateChartData(\"Pie Chart\"),\n                donutChartData: generateChartData(\"Donut Chart\"),\n                lineChartData: generateChartData(\"Line Chart\"),\n                barChartData: generateChartData(\"Bar Chart\")\n            });\n        } catch (error) {\n            console.error(\"Error uploading file:\", error);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const handleSend = async ()=>{\n        var _graphData_meta, _graphData_meta1, _filteredProcessedData_selectedChartType_, _filteredProcessedData_selectedChartType;\n        if (!inputValue) return;\n        const graphData = chartData[selectedChart];\n        if (!graphData) return;\n        const labels = graphData.labels;\n        const values = graphData.datasets[0].data;\n        const dataObject = labels.reduce((obj, label, index)=>{\n            obj[label] = values[index];\n            return obj;\n        }, {});\n        const chartTypeMapping = {\n            lineChartData: \"Line Chart\",\n            pieChartData: \"Pie Chart\",\n            donutChartData: \"Donut Chart\",\n            barChartData: \"Bar Chart\",\n            scatterChartData: \"Scatter Plot\"\n        };\n        const selectedChartType = chartTypeMapping[selectedChart] || selectedChart;\n        // Filter the stored processed data to include only the selected chart's data\n        const filteredProcessedData = {\n            [selectedChartType]: storedProcessedData[selectedChartType]\n        };\n        const requestBody = {\n            question: inputValue,\n            processedData: {\n                // Include the stored processed data\n                [selectedChartType]: [\n                    {\n                        header: ((_graphData_meta = graphData.meta) === null || _graphData_meta === void 0 ? void 0 : _graphData_meta.header) || \"default_header\",\n                        valueName: ((_graphData_meta1 = graphData.meta) === null || _graphData_meta1 === void 0 ? void 0 : _graphData_meta1.valueName) || \"default_valueName\",\n                        label: graphData.datasets[0].label,\n                        data: (_filteredProcessedData_selectedChartType = filteredProcessedData[selectedChartType]) === null || _filteredProcessedData_selectedChartType === void 0 ? void 0 : (_filteredProcessedData_selectedChartType_ = _filteredProcessedData_selectedChartType[0]) === null || _filteredProcessedData_selectedChartType_ === void 0 ? void 0 : _filteredProcessedData_selectedChartType_.data\n                    }\n                ]\n            }\n        };\n        setLoading(true);\n        try {\n            var _result_data;\n            const response = await fetch(\"http://localhost:3012/api/answer-analyze-excel?question=\".concat(encodeURIComponent(inputValue)), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(requestBody)\n            });\n            if (!response.ok) throw new Error(\"Error uploading file.\");\n            setLoading(false);\n            const result = await response.json();\n            console.log(\"result.data\", result.data.data.combinedInsights);\n            setCombinedInsights(result.data.data.combinedInsights);\n            const processedData = (_result_data = result.data) === null || _result_data === void 0 ? void 0 : _result_data.processedData;\n            if (!processedData) throw new Error(\"Invalid response structure.\");\n            const generateChartData = (chartType)=>{\n                var _processedData_chartType;\n                const chartInfo = (_processedData_chartType = processedData[chartType]) === null || _processedData_chartType === void 0 ? void 0 : _processedData_chartType[0]; // Use only API response data\n                if (!chartInfo) return null;\n                const labels = Object.keys(chartInfo.data);\n                const values = Object.values(chartInfo.data);\n                let chartWidth = 0;\n                if ([\n                    \"Line Chart\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150;\n                } else if ([\n                    \"Bar Chart\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150; // Adjust the width for bar chart\n                } else if ([\n                    \"Scatter Plot\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150; // Adjust the width for bar chart\n                } else {\n                    chartWidth = 400; // Default width for other chart types\n                }\n                setChartWidth(chartWidth);\n                return {\n                    labels,\n                    datasets: [\n                        {\n                            label: chartInfo.label || chartType,\n                            data: values,\n                            backgroundColor: [\n                                \"Pie Chart\",\n                                \"Donut Chart\",\n                                \"Bar Chart\"\n                            ].includes(chartType) ? [\n                                \"rgba(173, 216, 230, 0.6)\",\n                                \"rgba(144, 238, 144, 0.6)\",\n                                \"rgba(255, 182, 193, 0.6)\"\n                            ] : \"rgba(135, 206, 250, 0.6)\",\n                            borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n                            fill: !chartType.includes(\"Line\")\n                        }\n                    ],\n                    meta: {\n                        header: chartInfo.header || \"default_header\",\n                        valueName: chartInfo.valueName || \"default_valueName\"\n                    }\n                };\n            };\n            // Only update chartData without storing in storedProcessedData\n            setChartData((prevChartData)=>({\n                    ...prevChartData,\n                    [selectedChart]: generateChartData(selectedChartType)\n                }));\n        } catch (error) {\n            console.error(\"Error sending request:\", error);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const renderChart = (type, ChartComponent)=>{\n        const data = chartData === null || chartData === void 0 ? void 0 : chartData[type];\n        if (!loading && data) {\n            var _data_labels;\n            const dataLength = ((_data_labels = data.labels) === null || _data_labels === void 0 ? void 0 : _data_labels.length) || 0;\n            const maxTicks = Math.floor(600 / 30); // Approx 30px per vertical label\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-full overflow-x-auto overflow-y-hidden bg-white p-4 rounded-lg shadow\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        width: \"100%\",\n                        minWidth: [\n                            \"lineChartData\",\n                            \"barChartData\"\n                        ].includes(type) ? Math.max(600, dataLength * 30) + \"px\" : \"100%\",\n                        height: \"400px\"\n                    },\n                    className: \"relative\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChartComponent, {\n                        data: data,\n                        options: {\n                            responsive: true,\n                            maintainAspectRatio: false,\n                            scales: {\n                                x: {\n                                    min: 0,\n                                    ticks: {\n                                        autoSkip: false,\n                                        maxTicksLimit: maxTicks,\n                                        maxRotation: 90,\n                                        minRotation: 90,\n                                        padding: 10,\n                                        font: {\n                                            size: 12\n                                        },\n                                        align: 'center',\n                                        // Ensure last labels don't overlap\n                                        callback: function(_value, index, values) {\n                                            // Skip rendering if too close to the end\n                                            if (index === values.length - 1 && dataLength > maxTicks) {\n                                                return null; // Hide last label if it might overlap\n                                            }\n                                            return data.labels[index];\n                                        }\n                                    },\n                                    grid: {\n                                        display: false\n                                    }\n                                },\n                                y: {\n                                    beginAtZero: true\n                                }\n                            },\n                            plugins: {\n                                legend: {\n                                    display: true,\n                                    position: \"top\"\n                                },\n                                tooltip: {\n                                    enabled: true,\n                                    intersect: false,\n                                    mode: 'index'\n                                }\n                            },\n                            layout: {\n                                padding: {\n                                    left: 30,\n                                    right: 30,\n                                    bottom: 40\n                                }\n                            }\n                        }\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 1975,\n                        columnNumber: 13\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                    lineNumber: 1965,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                lineNumber: 1964,\n                columnNumber: 9\n            }, this);\n        }\n        return null;\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"flex flex-col w-full md:flex-row h-screen border border-black\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"text-lg font-bold mb-2\",\n                        children: \"Upload File\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2042,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"file\",\n                        onChange: handleFileChange,\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"border p-2 w-full\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2043,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: handleSubmit,\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BsUpload_react_icons_bs__WEBPACK_IMPORTED_MODULE_5__.BsUpload, {\n                                className: \"mr-2\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2045,\n                                columnNumber: 11\n                            }, this),\n                            \" Submit\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2044,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"flex flex-col space-y-2 mt-4\",\n                        children: [\n                            \"lineChartData\",\n                            \"barChartData\",\n                            \"scatterChartData\",\n                            \"pieChartData\",\n                            \"donutChartData\"\n                        ].map((type)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>setSelectedChart(type),\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"p-2 bg-gray-300 rounded hover:bg-gray-400\",\n                                children: type.replace(\"ChartData\", \" Chart\")\n                            }, type, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2049,\n                                columnNumber: 13\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2047,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                lineNumber: 2041,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"w-full md:w-3/4 bg-gray-100 p-5\",\n                children: [\n                    loading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"flex justify-center items-center h-full\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"jsx-ee216b23b408fc3d\" + \" \" + \"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                            lineNumber: 2058,\n                            columnNumber: 7\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2057,\n                        columnNumber: 5\n                    }, this) : selectedChart && renderChart(selectedChart, {\n                        lineChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__.Line,\n                        barChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__.Bar,\n                        scatterChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__.Scatter,\n                        pieChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__.Pie,\n                        donutChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__.Doughnut\n                    }[selectedChart]),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"mt-4 flex\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                value: inputValue,\n                                onChange: (e)=>setInputValue(e.target.value),\n                                placeholder: \"Enter your text here\",\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"border p-2 flex-grow mr-2 rounded\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2070,\n                                columnNumber: 5\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: handleSend,\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"bg-green-500 text-white p-2 rounded\",\n                                children: \"Send\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2077,\n                                columnNumber: 5\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2069,\n                        columnNumber: 3\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"mt-4 p-4 border border-gray-300 rounded bg-white\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"text-lg font-bold mb-2\",\n                                children: \"Insights\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2082,\n                                columnNumber: 5\n                            }, this),\n                            combinedInsights ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ol\", {\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"list-decimal list-inside text-sm text-gray-700 bg-gray-100 p-2 rounded max-h-60 overflow-y-auto\",\n                                children: combinedInsights.split('\\n').map((insight, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"py-1\",\n                                        children: insight\n                                    }, index, false, {\n                                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                        lineNumber: 2086,\n                                        columnNumber: 11\n                                    }, this))\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2084,\n                                columnNumber: 7\n                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"text-gray-500\",\n                                children: \"No insights available.\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2090,\n                                columnNumber: 7\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2081,\n                        columnNumber: 3\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                lineNumber: 2055,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default()), {\n                id: \"ee216b23b408fc3d\",\n                children: \".overflow-x-auto.jsx-ee216b23b408fc3d{-webkit-overflow-scrolling:touch;scrollbar-width:thin;scrollbar-color:#888#f1f1f1}.overflow-x-auto.jsx-ee216b23b408fc3d::-webkit-scrollbar{height:8px}.overflow-x-auto.jsx-ee216b23b408fc3d::-webkit-scrollbar-thumb{background:#888;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.overflow-x-auto.jsx-ee216b23b408fc3d::-webkit-scrollbar-track{background:#f1f1f1}@media(max-width:768px){.overflow-x-auto.jsx-ee216b23b408fc3d>div.jsx-ee216b23b408fc3d{min-width:400px;height:300px}}\"\n            }, void 0, false, void 0, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n        lineNumber: 2040,\n        columnNumber: 5\n    }, this);\n}\n_s(Dashboard, \"P/Zh0x9l01YSUrGDOmP3n5Y2uFs=\");\n_c = Dashboard;\nvar _c;\n$RefreshReg$(_c, \"Dashboard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcGFnZXMvVXBsb2FkL1VwbG9hZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUdBLGdCQUFnQjtBQUNoQiwrQ0FBK0M7QUFDL0MsdUVBQXVFO0FBQ3ZFLFdBQVc7QUFDWCxzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsV0FBVztBQUNYLGFBQWE7QUFDYixZQUFZO0FBQ1oscUJBQXFCO0FBQ3JCLDZDQUE2QztBQUM3QyxnREFBZ0Q7QUFFaEQsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLFdBQVc7QUFDWCxhQUFhO0FBQ2IsWUFBWTtBQUNaLGVBQWU7QUFDZixLQUFLO0FBRUwsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QixnQkFBZ0I7QUFDaEIscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QixnQ0FBZ0M7QUFDaEMsNEJBQTRCO0FBQzVCLHNCQUFzQjtBQUN0QixTQUFTO0FBQ1QsSUFBSTtBQUVKLHdDQUF3QztBQUN4QyxtRkFBbUY7QUFDbkYsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQiw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQixRQUFRO0FBQ1IseUVBQXlFO0FBQ3pFLG9FQUFvRTtBQUNwRSw0REFBNEQ7QUFDNUQsNkRBQTZEO0FBQzdELHdFQUF3RTtBQUV4RSwrRUFBK0U7QUFDL0Usd0RBQXdEO0FBQ3hELE9BQU87QUFFUCx1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDLHdCQUF3QjtBQUV4Qix1Q0FBdUM7QUFDdkMsNkNBQTZDO0FBRTdDLFlBQVk7QUFDWixrRkFBa0Y7QUFDbEYsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixZQUFZ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Q0FFN0NFLGFBQVk7MEVBREY7Ozs7OzswQ0FHWiw4REFBQ047Z0NBQU9DLFNBQVNsRTswRUFBc0I7MENBQXNDOzs7Ozs7Ozs7Ozs7a0NBSS9FLDhEQUFDdUI7a0VBQWM7OzBDQUNiLDhEQUFDaUQ7MEVBQWE7MENBQXlCOzs7Ozs7NEJBQ3RDcEgsaUNBQ0MsOERBQUNxSDswRUFBYTswQ0FDWHJILGlCQUFpQnNILEtBQUssQ0FBQyxNQUFNUCxHQUFHLENBQUMsQ0FBQ1EsU0FBeUxyRSxzQkFDMU4sOERBQUNzRTtrRkFBeUI7a0RBQVFEO3VDQUF6QnJFOzs7Ozs7Ozs7cURBSWIsOERBQUN1RTswRUFBWTswQ0FBZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ25DO0dBcll3QjdJO0tBQUFBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE11a2VzaC5rYXNpbWFoYW50aGlcXERlc2t0b3BcXHZpc3VsaXphdGlvblxcYWlBZ2VudEZyb250ZW5kQ29kZVxcc3JjXFxhcHBcXHBhZ2VzXFxVcGxvYWRcXFVwbG9hZC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXHJcblxyXG5cclxuLy8gXCJ1c2UgY2xpZW50XCI7XHJcbi8vIGltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuLy8gaW1wb3J0IHsgQmFyLCBMaW5lLCBEb3VnaG51dCwgUGllLCBTY2F0dGVyIH0gZnJvbSBcInJlYWN0LWNoYXJ0anMtMlwiO1xyXG4vLyBpbXBvcnQge1xyXG4vLyAgIENoYXJ0IGFzIENoYXJ0SlMsXHJcbi8vICAgQ2F0ZWdvcnlTY2FsZSxcclxuLy8gICBMaW5lYXJTY2FsZSxcclxuLy8gICBCYXJFbGVtZW50LFxyXG4vLyAgIExpbmVFbGVtZW50LFxyXG4vLyAgIFBvaW50RWxlbWVudCxcclxuLy8gICBBcmNFbGVtZW50LFxyXG4vLyAgIFRpdGxlLFxyXG4vLyAgIFRvb2x0aXAsXHJcbi8vICAgTGVnZW5kLFxyXG4vLyB9IGZyb20gXCJjaGFydC5qc1wiO1xyXG4vLyBpbXBvcnQgeyBCc1VwbG9hZCB9IGZyb20gXCJyZWFjdC1pY29ucy9ic1wiO1xyXG4vLyBpbXBvcnQgem9vbVBsdWdpbiBmcm9tIFwiY2hhcnRqcy1wbHVnaW4tem9vbVwiO1xyXG5cclxuLy8gQ2hhcnRKUy5yZWdpc3RlcihcclxuLy8gICBDYXRlZ29yeVNjYWxlLFxyXG4vLyAgIExpbmVhclNjYWxlLFxyXG4vLyAgIEJhckVsZW1lbnQsXHJcbi8vICAgTGluZUVsZW1lbnQsXHJcbi8vICAgUG9pbnRFbGVtZW50LFxyXG4vLyAgIEFyY0VsZW1lbnQsXHJcbi8vICAgVGl0bGUsXHJcbi8vICAgVG9vbHRpcCxcclxuLy8gICBMZWdlbmQsXHJcbi8vICAgem9vbVBsdWdpblxyXG4vLyApO1xyXG5cclxuLy8gaW50ZXJmYWNlIENoYXJ0RGF0YSB7XHJcbi8vICAgbGFiZWxzOiBzdHJpbmdbXTtcclxuLy8gICBkYXRhc2V0czoge1xyXG4vLyAgICAgbGFiZWw6IHN0cmluZztcclxuLy8gICAgIGRhdGE6IG51bWJlcltdO1xyXG4vLyAgICAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nO1xyXG4vLyAgICAgYm9yZGVyQ29sb3I/OiBzdHJpbmc7XHJcbi8vICAgICBmaWxsPzogYm9vbGVhbjtcclxuLy8gICB9W107XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhc2hib2FyZCgpIHtcclxuLy8gICBjb25zdCBbY2hhcnREYXRhLCBzZXRDaGFydERhdGFdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgQ2hhcnREYXRhIHwgbnVsbD4+KHtcclxuLy8gICAgIHNjYXR0ZXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBwaWVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBkb251dENoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGxpbmVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBiYXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgfSk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkRmlsZSwgc2V0U2VsZWN0ZWRGaWxlXSA9IHVzZVN0YXRlPEZpbGUgfCBudWxsPihudWxsKTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRDaGFydCwgc2V0U2VsZWN0ZWRDaGFydF0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiXCIpO1xyXG4vLyAgIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcclxuLy8gICBjb25zdCBbY2hhcnRXaWR0aCwgc2V0Q2hhcnRXaWR0aF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xyXG4vLyAgIGNvbnN0IFtzZWxlY3RlZExhYmVscywgc2V0U2VsZWN0ZWRMYWJlbHNdID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlRmlsZUNoYW5nZSA9IChldmVudDogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcclxuLy8gICAgIHNldFNlbGVjdGVkRmlsZShldmVudC50YXJnZXQuZmlsZXM/LlswXSB8fCBudWxsKTtcclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVTdWJtaXQgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBpZiAoIXNlbGVjdGVkRmlsZSkgcmV0dXJuO1xyXG4vLyAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuXHJcbi8vICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4vLyAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBzZWxlY3RlZEZpbGUpO1xyXG5cclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwOi8vbG9jYWxob3N0OjMwMTIvYXBpL2FuYWx5emUtZXhjZWxcIiwge1xyXG4vLyAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbi8vICAgICAgICAgYm9keTogZm9ybURhdGEsXHJcbi8vICAgICAgIH0pO1xyXG5cclxuLy8gICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGUuXCIpO1xyXG4vLyAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbi8vICAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSByZXN1bHQuZGF0YT8ucHJvY2Vzc2VkRGF0YTtcclxuXHJcbi8vICAgICAgIGlmICghcHJvY2Vzc2VkRGF0YSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBzdHJ1Y3R1cmUuXCIpO1xyXG5cclxuLy8gICAgICAgY29uc3QgZ2VuZXJhdGVDaGFydERhdGEgPSAoY2hhcnRUeXBlOiBzdHJpbmcpOiBDaGFydERhdGEgfCBudWxsID0+IHtcclxuLy8gICAgICAgICBjb25zdCBjaGFydEluZm8gPSBwcm9jZXNzZWREYXRhW2NoYXJ0VHlwZV0/LlswXTtcclxuLy8gICAgICAgICBpZiAoIWNoYXJ0SW5mbykgcmV0dXJuIG51bGw7XHJcblxyXG4vLyAgICAgICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5rZXlzKGNoYXJ0SW5mby5kYXRhKTtcclxuLy8gICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGNoYXJ0SW5mby5kYXRhKTtcclxuXHJcbi8vICAgICAgICAgcmV0dXJuIHtcclxuLy8gICAgICAgICAgIGxhYmVscyxcclxuLy8gICAgICAgICAgIGRhdGFzZXRzOiBbXHJcbi8vICAgICAgICAgICAgIHtcclxuLy8gICAgICAgICAgICAgICBsYWJlbDogY2hhcnRJbmZvLmxhYmVsIHx8IGNoYXJ0VHlwZSxcclxuLy8gICAgICAgICAgICAgICBkYXRhOiB2YWx1ZXMgYXMgbnVtYmVyW10sXHJcbi8vICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjaGFydFR5cGUuaW5jbHVkZXMoXCJCYXJcIilcclxuLy8gICAgICAgICAgICAgICAgID8gXCJyZ2JhKDU0LCAxNjIsIDIzNSwgMC41KVwiXHJcbi8vICAgICAgICAgICAgICAgICA6IFwicmdiYSgyNTUsIDk5LCAxMzIsIDAuNSlcIixcclxuLy8gICAgICAgICAgICAgICBib3JkZXJDb2xvcjogY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKVxyXG4vLyAgICAgICAgICAgICAgICAgPyBcInJnYmEoMjU1LCA5OSwgMTMyLCAxKVwiXHJcbi8vICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcclxuLy8gICAgICAgICAgICAgICBmaWxsOiAhY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIF0sXHJcbi8vICAgICAgICAgfTtcclxuLy8gICAgICAgfTtcclxuXHJcbi8vICAgICAgIHNldENoYXJ0RGF0YSh7XHJcbi8vICAgICAgICAgc2NhdHRlckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJTY2F0dGVyIFBsb3RcIiksXHJcbi8vICAgICAgICAgcGllQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlBpZSBDaGFydFwiKSxcclxuLy8gICAgICAgICBkb251dENoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJEb251dCBDaGFydFwiKSxcclxuLy8gICAgICAgICBsaW5lQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkxpbmUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgYmFyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkJhciBDaGFydFwiKSxcclxuLy8gICAgICAgfSk7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGU6XCIsIGVycm9yKTtcclxuLy8gICAgIH0gZmluYWxseSB7XHJcbi8vICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH07XHJcblxyXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbi8vICAgICBpZiAoc2VsZWN0ZWRDaGFydCAmJiBjaGFydERhdGFbc2VsZWN0ZWRDaGFydF0pIHtcclxuLy8gICAgICAgY29uc3QgYmFzZUxhYmVscyA9IGNoYXJ0RGF0YVtzZWxlY3RlZENoYXJ0XT8ubGFiZWxzIHx8IFtdO1xyXG4vLyAgICAgICBzZXRDaGFydFdpZHRoKChzZWxlY3RlZExhYmVscy5sZW5ndGggfHwgYmFzZUxhYmVscy5sZW5ndGgpICogMTUwKTtcclxuLy8gICAgIH1cclxuLy8gICB9LCBbc2VsZWN0ZWRDaGFydCwgc2VsZWN0ZWRMYWJlbHMsIGNoYXJ0RGF0YV0pO1xyXG4gIFxyXG5cclxuLy8gICBjb25zdCBnZXRDaGFydE9wdGlvbnMgPSAodHlwZTogc3RyaW5nKSA9PiAoe1xyXG4vLyAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuLy8gICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxyXG4vLyAgICAgc2NhbGVzOiBbXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKVxyXG4vLyAgICAgICA/IHt9XHJcbi8vICAgICAgIDoge1xyXG4vLyAgICAgICAgICAgeDoge1xyXG4vLyAgICAgICAgICAgICB0aWNrczoge1xyXG4vLyAgICAgICAgICAgICAgIGF1dG9Ta2lwOiBmYWxzZSxcclxuLy8gICAgICAgICAgICAgICBtYXhSb3RhdGlvbjogdHlwZSA9PT0gJ2JhckNoYXJ0RGF0YScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXJDaGFydERhdGEnID8gMjAgOiAxMDAsXHJcbi8vICAgICAgICAgICAgICAgbWluUm90YXRpb246IHR5cGUgPT09ICdiYXJDaGFydERhdGEnIHx8IHR5cGUgPT09ICdzY2F0dGVyQ2hhcnREYXRhJyA/IDAgOiA5MCxcclxuLy8gICAgICAgICAgICAgICBhdXRvU2tpcFBhZGRpbmc6IDIwLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgICBncmlkOiB7XHJcbi8vICAgICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgICBkcmF3VGlja3M6IGZhbHNlLFxyXG4vLyAgICAgICAgICAgICAgIHRpY2tMZW5ndGg6IDEwMCxcclxuLy8gICAgICAgICAgICAgICBsaW5lV2lkdGg6IDFcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICB5OiB7XHJcbi8vICAgICAgICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxyXG4vLyAgICAgICAgICAgICB0aWNrczoge1xyXG4vLyAgICAgICAgICAgICAgIHByZWNpc2lvbjogMCxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgIHBsdWdpbnM6IHtcclxuLy8gICAgICAgbGVnZW5kOiB7XHJcbi8vICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICBwb3NpdGlvbjogXCJ0b3BcIixcclxuLy8gICAgICAgfSxcclxuLy8gICAgICAgdG9vbHRpcDoge1xyXG4vLyAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICB9LFxyXG4vLyAgIH0pO1xyXG5cclxuLy8gICBjb25zdCBhcHBseUZpbHRlciA9IChkYXRhOiBDaGFydERhdGEgfCBudWxsKSA9PiB7XHJcbi8vICAgICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xyXG5cclxuLy8gICAgIGNvbnN0IGZpbHRlcmVkTGFiZWxzID0gc2VsZWN0ZWRMYWJlbHMubGVuZ3RoXHJcbi8vICAgICAgID8gZGF0YS5sYWJlbHMuZmlsdGVyKGxhYmVsID0+IHNlbGVjdGVkTGFiZWxzLmluY2x1ZGVzKGxhYmVsKSlcclxuLy8gICAgICAgOiBkYXRhLmxhYmVscztcclxuXHJcbi8vICAgICBjb25zdCBmaWx0ZXJlZERhdGEgPSBkYXRhLmRhdGFzZXRzLm1hcChkYXRhc2V0ID0+ICh7XHJcbi8vICAgICAgIC4uLmRhdGFzZXQsXHJcbi8vICAgICAgIGRhdGE6IGZpbHRlcmVkTGFiZWxzLm1hcChsYWJlbCA9PiBkYXRhc2V0LmRhdGFbZGF0YS5sYWJlbHMuaW5kZXhPZihsYWJlbCldKVxyXG4vLyAgICAgfSkpO1xyXG5cclxuLy8gICAgIHJldHVybiB7XHJcbi8vICAgICAgIGxhYmVsczogZmlsdGVyZWRMYWJlbHMsXHJcbi8vICAgICAgIGRhdGFzZXRzOiBmaWx0ZXJlZERhdGEsXHJcbi8vICAgICB9O1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZUNoZWNrYm94Q2hhbmdlID0gKGxhYmVsOiBzdHJpbmcpID0+IHtcclxuLy8gICAgIHNldFNlbGVjdGVkTGFiZWxzKHByZXYgPT5cclxuLy8gICAgICAgcHJldi5pbmNsdWRlcyhsYWJlbClcclxuLy8gICAgICAgICA/IHByZXYuZmlsdGVyKGl0ZW0gPT4gaXRlbSAhPT0gbGFiZWwpXHJcbi8vICAgICAgICAgOiBbLi4ucHJldiwgbGFiZWxdXHJcbi8vICAgICApO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZVNlbGVjdEFsbCA9ICgpID0+IHtcclxuLy8gICAgIGlmIChzZWxlY3RlZENoYXJ0ICYmIGNoYXJ0RGF0YVtzZWxlY3RlZENoYXJ0XSkge1xyXG4vLyAgICAgICBzZXRTZWxlY3RlZExhYmVscyhjaGFydERhdGFbc2VsZWN0ZWRDaGFydF0/LmxhYmVscyB8fCBbXSk7XHJcbi8vICAgICB9XHJcbi8vICAgfTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlQ2xlYXJBbGwgPSAoKSA9PiB7XHJcbi8vICAgICBzZXRTZWxlY3RlZExhYmVscyhbXSk7XHJcbi8vICAgfTtcclxuXHJcbi8vICAgY29uc3QgcmVuZGVyQ2hhcnQgPSAodHlwZTogc3RyaW5nLCBDaGFydENvbXBvbmVudDogYW55KSA9PiB7XHJcbi8vICAgICBjb25zdCBkYXRhID0gYXBwbHlGaWx0ZXIoY2hhcnREYXRhW3R5cGVdKTtcclxuXHJcbi8vICAgICBpZiAoIWxvYWRpbmcgJiYgZGF0YSkge1xyXG4vLyAgICAgICByZXR1cm4gKFxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZCBwLTQgYm9yZGVyIHJvdW5kZWQgc2hhZG93LXNtXCI+XHJcbi8vICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiBcIjEwMCVcIiwgb3ZlcmZsb3dYOiBcImF1dG9cIiB9fT5cclxuLy8gICAgICAgICAgICAgPGRpdlxyXG4vLyAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbi8vICAgICAgICAgICAgICAgICBtaW5XaWR0aDogW1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKVxyXG4vLyAgICAgICAgICAgICAgICAgICA/IGAke2NoYXJ0V2lkdGh9cHhgXHJcbi8vICAgICAgICAgICAgICAgICAgIDogXCJhdXRvXCIsXHJcbi8vICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiNDAwcHhcIixcclxuLy8gICAgICAgICAgICAgICB9fVxyXG4vLyAgICAgICAgICAgICA+XHJcbi8vICAgICAgICAgICAgICAgPENoYXJ0Q29tcG9uZW50IGRhdGE9e2RhdGF9IG9wdGlvbnM9e2dldENoYXJ0T3B0aW9ucyh0eXBlKX0gLz5cclxuLy8gICAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgKTtcclxuLy8gICAgIH1cclxuLy8gICAgIHJldHVybiBudWxsO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIHJldHVybiAoXHJcbi8vICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgbWQ6ZmxleC1yb3cgaC1zY3JlZW4gYm9yZGVyIGJvcmRlci1ibGFja1wiPlxyXG4vLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTEvNCBiZy13aGl0ZSBwLTUgYm9yZGVyLXQgbWQ6Ym9yZGVyLWwgbWQ6Ym9yZGVyLWJsYWNrXCI+XHJcbi8vICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5VcGxvYWQgRmlsZTwvaDI+XHJcbi8vICAgICAgICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgb25DaGFuZ2U9e2hhbmRsZUZpbGVDaGFuZ2V9IGNsYXNzTmFtZT1cImJvcmRlciBwLTIgdy1mdWxsXCIgLz5cclxuLy8gICAgICAgICA8YnV0dG9uXHJcbi8vICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVTdWJtaXR9XHJcbi8vICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlIHAtMiByb3VuZGVkIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG10LTRcIlxyXG4vLyAgICAgICAgID5cclxuLy8gICAgICAgICAgIDxCc1VwbG9hZCBjbGFzc05hbWU9XCJtci0yXCIgLz4gU3VibWl0XHJcbi8vICAgICAgICAgPC9idXR0b24+XHJcblxyXG4vLyAgICAgICAgIHtzZWxlY3RlZENoYXJ0ICYmIChcclxuLy8gICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtNFwiPlxyXG4vLyAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwiZm9udC1zZW1pYm9sZFwiPkZpbHRlcnM8L2gzPlxyXG4vLyAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2hhbmRsZVNlbGVjdEFsbH0gY2xhc3NOYW1lPVwiYmctZ3JlZW4tNTAwIHRleHQtd2hpdGUgcHgtMiBweS0xIHJvdW5kZWQgbXQtMlwiPlNlbGVjdCBBbGw8L2J1dHRvbj5cclxuLy8gICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtoYW5kbGVDbGVhckFsbH0gY2xhc3NOYW1lPVwiYmctcmVkLTUwMCB0ZXh0LXdoaXRlIHB4LTIgcHktMSByb3VuZGVkIG10LTIgbWwtMlwiPkNsZWFyIEFsbDwvYnV0dG9uPlxyXG4vLyAgICAgICAgICAgICB7Y2hhcnREYXRhW3NlbGVjdGVkQ2hhcnRdPy5sYWJlbHMubWFwKGxhYmVsID0+IChcclxuLy8gICAgICAgICAgICAgICA8ZGl2IGtleT17bGFiZWx9IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyXCI+XHJcbi8vICAgICAgICAgICAgICAgICA8aW5wdXRcclxuLy8gICAgICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcclxuLy8gICAgICAgICAgICAgICAgICAgY2hlY2tlZD17c2VsZWN0ZWRMYWJlbHMuaW5jbHVkZXMobGFiZWwpfVxyXG4vLyAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gaGFuZGxlQ2hlY2tib3hDaGFuZ2UobGFiZWwpfVxyXG4vLyAgICAgICAgICAgICAgICAgLz5cclxuLy8gICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJtbC0yXCI+e2xhYmVsfTwvbGFiZWw+XHJcbi8vICAgICAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgICAgICkpfVxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgKX1cclxuXHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHNwYWNlLXktMiBtdC00XCI+XHJcbi8vICAgICAgICAgICB7W1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiLCBcInNjYXR0ZXJDaGFydERhdGFcIiwgXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5tYXAoXHJcbi8vICAgICAgICAgICAgICh0eXBlKSA9PiAoXHJcbi8vICAgICAgICAgICAgICAgPGJ1dHRvblxyXG4vLyAgICAgICAgICAgICAgICAga2V5PXt0eXBlfVxyXG4vLyAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xyXG4vLyAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZENoYXJ0KHR5cGUpO1xyXG4vLyAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZExhYmVscyhbXSk7XHJcbi8vICAgICAgICAgICAgICAgICB9fVxyXG4vLyAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicC0yIGJnLWdyYXktMzAwIHJvdW5kZWQgaG92ZXI6YmctZ3JheS00MDBcIlxyXG4vLyAgICAgICAgICAgICAgID5cclxuLy8gICAgICAgICAgICAgICAgIHt0eXBlLnJlcGxhY2UoXCJDaGFydERhdGFcIiwgXCIgQ2hhcnRcIil9XHJcbi8vICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgICAgIClcclxuLy8gICAgICAgICAgICl9XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgIDwvZGl2PlxyXG5cclxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0zLzQgYmctZ3JheS0xMDAgcC01IG92ZXJmbG93LWF1dG9cIj5cclxuLy8gICAgICAgICB7bG9hZGluZyA/IChcclxuLy8gICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgaC1mdWxsXCI+XHJcbi8vICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3Bpbm5lci1ib3JkZXIgYW5pbWF0ZS1zcGluIGJvcmRlci10LTQgYm9yZGVyLWJsdWUtNTAwIHJvdW5kZWQtZnVsbCB3LTEyIGgtMTJcIj48L2Rpdj5cclxuLy8gICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICkgOiAoXHJcbi8vICAgICAgICAgICByZW5kZXJDaGFydChzZWxlY3RlZENoYXJ0LCB7XHJcbi8vICAgICAgICAgICAgIGxpbmVDaGFydERhdGE6IExpbmUsXHJcbi8vICAgICAgICAgICAgIGJhckNoYXJ0RGF0YTogQmFyLFxyXG4vLyAgICAgICAgICAgICBzY2F0dGVyQ2hhcnREYXRhOiBTY2F0dGVyLFxyXG4vLyAgICAgICAgICAgICBwaWVDaGFydERhdGE6IFBpZSxcclxuLy8gICAgICAgICAgICAgZG9udXRDaGFydERhdGE6IERvdWdobnV0LFxyXG4vLyAgICAgICAgICAgfVtzZWxlY3RlZENoYXJ0XSlcclxuLy8gICAgICAgICApfVxyXG4vLyAgICAgICA8L2Rpdj5cclxuLy8gICAgIDwvZGl2PlxyXG4vLyAgICk7XHJcbi8vIH1cclxuXHJcblxyXG4vLyBcInVzZSBjbGllbnRcIjtcclxuLy8gaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG4vLyBpbXBvcnQgeyBCYXIsIExpbmUsIERvdWdobnV0LCBQaWUsIFNjYXR0ZXIgfSBmcm9tIFwicmVhY3QtY2hhcnRqcy0yXCI7XHJcbi8vIGltcG9ydCB7XHJcbi8vICAgQ2hhcnQgYXMgQ2hhcnRKUyxcclxuLy8gICBDYXRlZ29yeVNjYWxlLFxyXG4vLyAgIExpbmVhclNjYWxlLFxyXG4vLyAgIEJhckVsZW1lbnQsXHJcbi8vICAgTGluZUVsZW1lbnQsXHJcbi8vICAgUG9pbnRFbGVtZW50LFxyXG4vLyAgIEFyY0VsZW1lbnQsXHJcbi8vICAgVGl0bGUsXHJcbi8vICAgVG9vbHRpcCxcclxuLy8gICBMZWdlbmQsXHJcbi8vIH0gZnJvbSBcImNoYXJ0LmpzXCI7XHJcbi8vIGltcG9ydCB7IEJzVXBsb2FkIH0gZnJvbSBcInJlYWN0LWljb25zL2JzXCI7XHJcbi8vIGltcG9ydCB6b29tUGx1Z2luIGZyb20gXCJjaGFydGpzLXBsdWdpbi16b29tXCI7XHJcbi8vIGltcG9ydCB7IGxvZyB9IGZyb20gXCJub2RlOmNvbnNvbGVcIjtcclxuIFxyXG4vLyBDaGFydEpTLnJlZ2lzdGVyKFxyXG4vLyAgIENhdGVnb3J5U2NhbGUsXHJcbi8vICAgTGluZWFyU2NhbGUsXHJcbi8vICAgQmFyRWxlbWVudCxcclxuLy8gICBMaW5lRWxlbWVudCxcclxuLy8gICBQb2ludEVsZW1lbnQsXHJcbi8vICAgQXJjRWxlbWVudCxcclxuLy8gICBUaXRsZSxcclxuLy8gICBUb29sdGlwLFxyXG4vLyAgIExlZ2VuZCxcclxuLy8gICB6b29tUGx1Z2luXHJcbi8vICk7XHJcbiBcclxuLy8gaW50ZXJmYWNlIENoYXJ0RGF0YSB7XHJcbi8vICAgbGFiZWxzOiBzdHJpbmdbXTtcclxuLy8gICBkYXRhc2V0czoge1xyXG4vLyAgICAgbGFiZWw6IHN0cmluZztcclxuLy8gICAgIGRhdGE6IG51bWJlcltdO1xyXG4vLyAgICAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nO1xyXG4vLyAgICAgYm9yZGVyQ29sb3I/OiBzdHJpbmc7XHJcbi8vICAgICBmaWxsPzogYm9vbGVhbjtcclxuLy8gICB9W107XHJcbi8vIH1cclxuIFxyXG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEYXNoYm9hcmQoKSB7XHJcbi8vICAgY29uc3QgW2NoYXJ0RGF0YSwgc2V0Q2hhcnREYXRhXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIENoYXJ0RGF0YSB8IG51bGw+Pih7XHJcbi8vICAgICBzY2F0dGVyQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgcGllQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgZG9udXRDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBsaW5lQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgYmFyQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgIH0pO1xyXG4vLyAgIGNvbnN0IFtzZWxlY3RlZEZpbGUsIHNldFNlbGVjdGVkRmlsZV0gPSB1c2VTdGF0ZTxGaWxlIHwgbnVsbD4obnVsbCk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkQ2hhcnQsIHNldFNlbGVjdGVkQ2hhcnRdID0gdXNlU3RhdGU8c3RyaW5nPihcImxpbmVDaGFydERhdGFcIik7XHJcbi8vICAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG4vLyAgIGNvbnN0IFtjaGFydFdpZHRoLCBzZXRDaGFydFdpZHRoXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XHJcbiBcclxuLy8gICBjb25zdCBoYW5kbGVGaWxlQ2hhbmdlID0gKGV2ZW50OiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xyXG4vLyAgICAgc2V0U2VsZWN0ZWRGaWxlKGV2ZW50LnRhcmdldC5maWxlcz8uWzBdIHx8IG51bGwpO1xyXG4vLyAgIH07XHJcbiBcclxuLy8gICBjb25zdCBoYW5kbGVTdWJtaXQgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBpZiAoIXNlbGVjdGVkRmlsZSkgcmV0dXJuO1xyXG4vLyAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuIFxyXG4vLyAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuLy8gICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgc2VsZWN0ZWRGaWxlKTtcclxuIFxyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHA6Ly9sb2NhbGhvc3Q6MzAxMi9hcGkvYW5hbHl6ZS1leGNlbFwiLCB7XHJcbi8vICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuLy8gICAgICAgICBib2R5OiBmb3JtRGF0YSxcclxuLy8gICAgICAgfSk7XHJcbiBcclxuLy8gICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGUuXCIpO1xyXG4vLyAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbi8vICAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSByZXN1bHQuZGF0YT8ucHJvY2Vzc2VkRGF0YTtcclxuLy8gY29uc29sZS5sb2coXCJwcm9jZXNzZWREYXRhXCIscHJvY2Vzc2VkRGF0YSk7XHJcbiBcclxuLy8gICAgICAgaWYgKCFwcm9jZXNzZWREYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZS5cIik7XHJcbiBcclxuLy8gICAgICAgY29uc3QgZ2VuZXJhdGVDaGFydERhdGEgPSAoY2hhcnRUeXBlOiBzdHJpbmcpOiBDaGFydERhdGEgfCBudWxsID0+IHtcclxuLy8gICAgICAgICBjb25zdCBjaGFydEluZm8gPSBwcm9jZXNzZWREYXRhW2NoYXJ0VHlwZV0/LlswXTtcclxuLy8gICAgICAgICBpZiAoIWNoYXJ0SW5mbykgcmV0dXJuIG51bGw7XHJcbiBcclxuLy8gICAgICAgICBjb25zdCBsYWJlbHMgPSBPYmplY3Qua2V5cyhjaGFydEluZm8uZGF0YSk7XHJcbi8vICAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhjaGFydEluZm8uZGF0YSk7XHJcbi8vICBjb25zb2xlLmxvZyhcImxhYmVscy5sZW5ndGggXCIsY2hhcnRUeXBlLGxhYmVscy5sZW5ndGggKTtcclxuLy8gIGNvbnNvbGUubG9nKFwidmFsdWVzLmxlbmd0aCBcIixjaGFydFR5cGUsdmFsdWVzLmxlbmd0aCApO1xyXG5cclxuIFxyXG4vLyAgICAgICAgIHNldENoYXJ0V2lkdGgobGFiZWxzLmxlbmd0aCAqIDE1MCk7XHJcbiBcclxuLy8gICAgICAgICByZXR1cm4ge1xyXG4vLyAgICAgICAgICAgbGFiZWxzLFxyXG4vLyAgICAgICAgICAgZGF0YXNldHM6IFtcclxuLy8gICAgICAgICAgICAge1xyXG4vLyAgICAgICAgICAgICAgIGxhYmVsOiBjaGFydEluZm8ubGFiZWwgfHwgY2hhcnRUeXBlLFxyXG4vLyAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlcyBhcyBudW1iZXJbXSxcclxuLy8gICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNoYXJ0VHlwZS5pbmNsdWRlcyhcIkJhclwiKVxyXG4vLyAgICAgICAgICAgICAgICAgPyBcInJnYmEoNTQsIDE2MiwgMjM1LCAwLjUpXCJcclxuLy8gICAgICAgICAgICAgICAgIDogXCJyZ2JhKDI1NSwgOTksIDEzMiwgMC41KVwiLFxyXG4vLyAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpXHJcbi8vICAgICAgICAgICAgICAgICA/IFwicmdiYSgyNTUsIDk5LCAxMzIsIDEpXCJcclxuLy8gICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxyXG4vLyAgICAgICAgICAgICAgIGZpbGw6ICFjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgXSxcclxuLy8gICAgICAgICB9O1xyXG4vLyAgICAgICB9O1xyXG4vLyBjb25zb2xlLmxvZyhcImdlbmVyYXRlQ2hhcnREYXRhXCIsZ2VuZXJhdGVDaGFydERhdGEpO1xyXG4gXHJcbi8vICAgICAgIHNldENoYXJ0RGF0YSh7XHJcbi8vICAgICAgICAgc2NhdHRlckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJTY2F0dGVyIFBsb3RcIiksXHJcbi8vICAgICAgICAgcGllQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlBpZSBDaGFydFwiKSxcclxuLy8gICAgICAgICBkb251dENoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJEb251dCBDaGFydFwiKSxcclxuLy8gICAgICAgICBsaW5lQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkxpbmUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgYmFyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkJhciBDaGFydFwiKSxcclxuLy8gICAgICAgfSk7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGU6XCIsIGVycm9yKTtcclxuLy8gICAgIH0gZmluYWxseSB7XHJcbi8vICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH07XHJcbiBcclxuLy8gICBjb25zdCBnZXRDaGFydE9wdGlvbnMgPSAodHlwZTogc3RyaW5nKSA9PiAoe1xyXG4gICBcclxuLy8gICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbi8vICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcclxuLy8gICAgIHNjYWxlczogW1wicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSlcclxuLy8gICAgICAgPyB7fVxyXG4vLyAgICAgICA6IHtcclxuLy8gICAgICAgICB4OiB7XHJcbi8vICAgICAgICAgICB0aWNrczoge1xyXG4vLyAgICAgICAgICAgICBhdXRvU2tpcDogZmFsc2UsXHJcbi8vICAgICAgICAgICAgIG1heFJvdGF0aW9uOiB0eXBlID09PSAnYmFyQ2hhcnREYXRhJyB8fCB0eXBlID09PSAnc2NhdHRlckNoYXJ0RGF0YScgPyAyMCA6IDEwMCxcclxuLy8gICAgICAgICBtaW5Sb3RhdGlvbjogdHlwZSA9PT0gJ2JhckNoYXJ0RGF0YScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXJDaGFydERhdGEnID8gMCA6IDkwLFxyXG4vLyAgICAgICAgICAgICBhdXRvU2tpcFBhZGRpbmc6IDIwLFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIGdyaWQ6IHtcclxuLy8gICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgZHJhd1RpY2tzOiBmYWxzZSxcclxuLy8gICAgICAgICAgICAgdGlja0xlbmd0aDogMTAwLFxyXG4vLyAgICAgICAgICAgICBsaW5lV2lkdGg6IDFcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIHk6IHtcclxuLy8gICAgICAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXHJcbi8vICAgICAgICAgICAgIHRpY2tzOiB7XHJcbi8vICAgICAgICAgICAgICAgcHJlY2lzaW9uOiAwLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgcGx1Z2luczoge1xyXG4vLyAgICAgICBsZWdlbmQ6IHtcclxuLy8gICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4vLyAgICAgICAgIHBvc2l0aW9uOiBcInRvcFwiLFxyXG4vLyAgICAgICB9LFxyXG4vLyAgICAgICB0b29sdGlwOiB7XHJcbi8vICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuLy8gICAgICAgfSxcclxuLy8gICAgIH0sXHJcbi8vICAgfSk7XHJcbiBcclxuLy8gICBjb25zdCByZW5kZXJDaGFydCA9ICh0eXBlOiBzdHJpbmcsIENoYXJ0Q29tcG9uZW50OiBhbnkpID0+IHtcclxuLy8gICAgIGNvbnN0IGRhdGEgPSBjaGFydERhdGFbdHlwZV07XHJcbi8vICAgICBpZiAoIWxvYWRpbmcgJiYgZGF0YSkge1xyXG4vLyAgICAgICByZXR1cm4gKFxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZCBwLTQgYm9yZGVyIHJvdW5kZWQgc2hhZG93LXNtXCI+XHJcbi8vICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiBcIjEwMCVcIiwgb3ZlcmZsb3dYOiBcImF1dG9cIiB9fT5cclxuLy8gICAgICAgICAgICAgPGRpdlxyXG4vLyAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbi8vICAgICAgICAgICAgICAgICBtaW5XaWR0aDogW1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKVxyXG4vLyAgICAgICAgICAgICAgICAgICA/IGAke2NoYXJ0V2lkdGh9cHhgXHJcbi8vICAgICAgICAgICAgICAgICAgIDogXCJhdXRvXCIsXHJcbi8vICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiNDAwcHhcIixcclxuLy8gICAgICAgICAgICAgICB9fVxyXG4vLyAgICAgICAgICAgICA+XHJcbi8vICAgICAgICAgICAgICAgPENoYXJ0Q29tcG9uZW50IGRhdGE9e2RhdGF9IG9wdGlvbnM9e2dldENoYXJ0T3B0aW9ucyh0eXBlKX0gLz5cclxuLy8gICAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgKTtcclxuLy8gICAgIH1cclxuLy8gICAgIHJldHVybiBudWxsO1xyXG4vLyAgIH07XHJcbiBcclxuLy8gICByZXR1cm4gKFxyXG4vLyAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIG1kOmZsZXgtcm93IGgtc2NyZWVuIGJvcmRlciBib3JkZXItYmxhY2tcIj5cclxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0xLzQgYmctd2hpdGUgcC01IGJvcmRlci10IG1kOmJvcmRlci1sIG1kOmJvcmRlci1ibGFja1wiPlxyXG4vLyAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+VXBsb2FkIEZpbGU8L2gyPlxyXG4vLyAgICAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIG9uQ2hhbmdlPXtoYW5kbGVGaWxlQ2hhbmdlfSBjbGFzc05hbWU9XCJib3JkZXIgcC0yIHctZnVsbFwiIC8+XHJcbi8vICAgICAgICAgPGJ1dHRvblxyXG4vLyAgICAgICAgICAgb25DbGljaz17aGFuZGxlU3VibWl0fVxyXG4vLyAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctYmx1ZS01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBtdC00XCJcclxuLy8gICAgICAgICA+XHJcbi8vICAgICAgICAgICA8QnNVcGxvYWQgY2xhc3NOYW1lPVwibXItMlwiIC8+IFN1Ym1pdFxyXG4vLyAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBzcGFjZS15LTIgbXQtNFwiPlxyXG4vLyAgICAgICAgICAge1tcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIiwgXCJzY2F0dGVyQ2hhcnREYXRhXCIsIFwicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0ubWFwKFxyXG4vLyAgICAgICAgICAgICAodHlwZSkgPT4gKFxyXG4vLyAgICAgICAgICAgICAgIDxidXR0b25cclxuLy8gICAgICAgICAgICAgICAgIGtleT17dHlwZX1cclxuLy8gICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkQ2hhcnQodHlwZSl9XHJcbi8vICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJwLTIgYmctZ3JheS0zMDAgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTQwMFwiXHJcbi8vICAgICAgICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgICAgICAge3R5cGUucmVwbGFjZShcIkNoYXJ0RGF0YVwiLCBcIiBDaGFydFwiKX1cclxuLy8gICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgICAgICAgKVxyXG4vLyAgICAgICAgICAgKX1cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgPC9kaXY+XHJcbiBcclxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0zLzQgYmctZ3JheS0xMDAgcC01IG92ZXJmbG93LWF1dG9cIj5cclxuLy8gICAgICAgICB7bG9hZGluZyA/IChcclxuLy8gICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgaC1mdWxsXCI+XHJcbi8vICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3Bpbm5lci1ib3JkZXIgYW5pbWF0ZS1zcGluIGJvcmRlci10LTQgYm9yZGVyLWJsdWUtNTAwIHJvdW5kZWQtZnVsbCB3LTEyIGgtMTJcIj48L2Rpdj5cclxuLy8gICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICkgOiAoXHJcbi8vICAgICAgICAgICByZW5kZXJDaGFydChzZWxlY3RlZENoYXJ0LCB7XHJcbi8vICAgICAgICAgICAgIGxpbmVDaGFydERhdGE6IExpbmUsXHJcbi8vICAgICAgICAgICAgIGJhckNoYXJ0RGF0YTogQmFyLFxyXG4vLyAgICAgICAgICAgICBzY2F0dGVyQ2hhcnREYXRhOiBTY2F0dGVyLFxyXG4vLyAgICAgICAgICAgICBwaWVDaGFydERhdGE6IFBpZSxcclxuLy8gICAgICAgICAgICAgZG9udXRDaGFydERhdGE6IERvdWdobnV0LFxyXG4vLyAgICAgICAgICAgfVtzZWxlY3RlZENoYXJ0XSlcclxuLy8gICAgICAgICApfVxyXG4vLyAgICAgICA8L2Rpdj5cclxuLy8gICAgIDwvZGl2PlxyXG4vLyAgICk7XHJcbi8vIH1cclxuXHJcblxyXG4vLyBcInVzZSBjbGllbnRcIjtcclxuLy8gaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG4vLyBpbXBvcnQgeyBCYXIsIExpbmUsIERvdWdobnV0LCBQaWUsIFNjYXR0ZXIgfSBmcm9tIFwicmVhY3QtY2hhcnRqcy0yXCI7XHJcbi8vIGltcG9ydCB7XHJcbi8vICAgQ2hhcnQgYXMgQ2hhcnRKUyxcclxuLy8gICBDYXRlZ29yeVNjYWxlLFxyXG4vLyAgIExpbmVhclNjYWxlLFxyXG4vLyAgIEJhckVsZW1lbnQsXHJcbi8vICAgTGluZUVsZW1lbnQsXHJcbi8vICAgUG9pbnRFbGVtZW50LFxyXG4vLyAgIEFyY0VsZW1lbnQsXHJcbi8vICAgVGl0bGUsXHJcbi8vICAgVG9vbHRpcCxcclxuLy8gICBMZWdlbmQsXHJcbi8vIH0gZnJvbSBcImNoYXJ0LmpzXCI7XHJcbi8vIGltcG9ydCB7IEJzVXBsb2FkIH0gZnJvbSBcInJlYWN0LWljb25zL2JzXCI7XHJcbi8vIGltcG9ydCB6b29tUGx1Z2luIGZyb20gXCJjaGFydGpzLXBsdWdpbi16b29tXCI7XHJcbi8vIGltcG9ydCB7IGxvZyB9IGZyb20gXCJub2RlOmNvbnNvbGVcIjtcclxuXHJcbi8vIENoYXJ0SlMucmVnaXN0ZXIoXHJcbi8vICAgQ2F0ZWdvcnlTY2FsZSxcclxuLy8gICBMaW5lYXJTY2FsZSxcclxuLy8gICBCYXJFbGVtZW50LFxyXG4vLyAgIExpbmVFbGVtZW50LFxyXG4vLyAgIFBvaW50RWxlbWVudCxcclxuLy8gICBBcmNFbGVtZW50LFxyXG4vLyAgIFRpdGxlLFxyXG4vLyAgIFRvb2x0aXAsXHJcbi8vICAgTGVnZW5kLFxyXG4vLyAgIHpvb21QbHVnaW5cclxuLy8gKTtcclxuXHJcbi8vIGludGVyZmFjZSBDaGFydERhdGEge1xyXG4vLyAgIGxhYmVsczogc3RyaW5nW107XHJcbi8vICAgZGF0YXNldHM6IHtcclxuLy8gICAgIGxhYmVsOiBzdHJpbmc7XHJcbi8vICAgICBkYXRhOiBudW1iZXJbXTtcclxuLy8gICAgIGJhY2tncm91bmRDb2xvcj86IHN0cmluZyB8IHN0cmluZ1tdO1xyXG4vLyAgICAgYm9yZGVyQ29sb3I/OiBzdHJpbmc7XHJcbi8vICAgICBmaWxsPzogYm9vbGVhbjtcclxuLy8gICB9W107XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhc2hib2FyZCgpIHtcclxuLy8gICBjb25zdCBbY2hhcnREYXRhLCBzZXRDaGFydERhdGFdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgQ2hhcnREYXRhIHwgbnVsbD4+KHtcclxuLy8gICAgIHNjYXR0ZXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBwaWVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBkb251dENoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGxpbmVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBiYXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgfSk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkRmlsZSwgc2V0U2VsZWN0ZWRGaWxlXSA9IHVzZVN0YXRlPEZpbGUgfCBudWxsPihudWxsKTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRDaGFydCwgc2V0U2VsZWN0ZWRDaGFydF0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwibGluZUNoYXJ0RGF0YVwiKTtcclxuLy8gICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcbi8vICAgY29uc3QgW2NoYXJ0V2lkdGgsIHNldENoYXJ0V2lkdGhdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlRmlsZUNoYW5nZSA9IChldmVudDogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcclxuLy8gICAgIHNldFNlbGVjdGVkRmlsZShldmVudC50YXJnZXQuZmlsZXM/LlswXSB8fCBudWxsKTtcclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVTdWJtaXQgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBpZiAoIXNlbGVjdGVkRmlsZSkgcmV0dXJuO1xyXG4vLyAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuXHJcbi8vICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4vLyAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBzZWxlY3RlZEZpbGUpO1xyXG5cclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwOi8vbG9jYWxob3N0OjMwMTIvYXBpL2FuYWx5emUtZXhjZWxcIiwge1xyXG4vLyAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbi8vICAgICAgICAgYm9keTogZm9ybURhdGEsXHJcbi8vICAgICAgIH0pO1xyXG5cclxuLy8gICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGUuXCIpO1xyXG4vLyAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbi8vICAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSByZXN1bHQuZGF0YT8ucHJvY2Vzc2VkRGF0YTtcclxuXHJcbi8vICAgICAgIGlmICghcHJvY2Vzc2VkRGF0YSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBzdHJ1Y3R1cmUuXCIpO1xyXG5cclxuLy8gICAgICAgY29uc3QgbGlnaHRDb2xvcnMgPSBbXHJcbi8vICAgICAgICAgXCJyZ2JhKDE3MywgMjE2LCAyMzAsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMTQ0LCAyMzgsIDE0NCwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyNTUsIDE4MiwgMTkzLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDI1NSwgMjI4LCAxODEsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjIxLCAxNjAsIDIyMSwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyNDAsIDIzMCwgMTQwLCAwLjYpXCIsXHJcbi8vICAgICAgIF07XHJcblxyXG4vLyAgICAgICBjb25zdCBnZW5lcmF0ZUNoYXJ0RGF0YSA9IChjaGFydFR5cGU6IHN0cmluZyk6IENoYXJ0RGF0YSB8IG51bGwgPT4ge1xyXG4vLyAgICAgICAgIGNvbnN0IGNoYXJ0SW5mbyA9IHByb2Nlc3NlZERhdGFbY2hhcnRUeXBlXT8uWzBdO1xyXG4vLyAgICAgICAgIGlmICghY2hhcnRJbmZvKSByZXR1cm4gbnVsbDtcclxuXHJcbi8vICAgICAgICAgY29uc3QgbGFiZWxzID0gT2JqZWN0LmtleXMoY2hhcnRJbmZvLmRhdGEpO1xyXG4vLyAgICAgICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoY2hhcnRJbmZvLmRhdGEpO1xyXG5cclxuLy8gICAgICAgICBzZXRDaGFydFdpZHRoKGxhYmVscy5sZW5ndGggKiAxNTApO1xyXG5cclxuLy8gICAgICAgICByZXR1cm4ge1xyXG4vLyAgICAgICAgICAgbGFiZWxzLFxyXG4vLyAgICAgICAgICAgZGF0YXNldHM6IFtcclxuLy8gICAgICAgICAgICAge1xyXG4vLyAgICAgICAgICAgICAgIGxhYmVsOiBjaGFydEluZm8ubGFiZWwgfHwgY2hhcnRUeXBlLFxyXG4vLyAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlcyBhcyBudW1iZXJbXSxcclxuLy8gICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcIlBpZSBDaGFydFwiLCBcIkRvbnV0IENoYXJ0XCIsIFwiQmFyIENoYXJ0XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSlcclxuLy8gICAgICAgICAgICAgICAgID8gbGlnaHRDb2xvcnMuc2xpY2UoMCwgbGFiZWxzLmxlbmd0aClcclxuLy8gICAgICAgICAgICAgICAgIDogXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDAuNilcIixcclxuLy8gICAgICAgICAgICAgICBib3JkZXJDb2xvcjogY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKVxyXG4vLyAgICAgICAgICAgICAgICAgPyBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMSlcIlxyXG4vLyAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXHJcbi8vICAgICAgICAgICAgICAgZmlsbDogIWNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIiksXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICBdLFxyXG4vLyAgICAgICAgIH07XHJcbi8vICAgICAgIH07XHJcblxyXG4vLyAgICAgICBzZXRDaGFydERhdGEoe1xyXG4vLyAgICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiU2NhdHRlciBQbG90XCIpLFxyXG4vLyAgICAgICAgIHBpZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJQaWUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgZG9udXRDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiRG9udXQgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgbGluZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJMaW5lIENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGJhckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJCYXIgQ2hhcnRcIiksXHJcbi8vICAgICAgIH0pO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlOlwiLCBlcnJvcik7XHJcbi8vICAgICB9IGZpbmFsbHkge1xyXG4vLyAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuLy8gICAgIH1cclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBnZXRDaGFydE9wdGlvbnMgPSAodHlwZTogc3RyaW5nKSA9PiAoe1xyXG4vLyAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuLy8gICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxyXG4vLyAgICAgc2NhbGVzOiBbXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKVxyXG4vLyAgICAgICA/IHt9XHJcbi8vICAgICAgIDoge1xyXG4gICAgICAgIC8vIHg6IHtcclxuICAgICAgICAvLyAgIHRpY2tzOiB7XHJcbiAgICAgICAgLy8gICAgIGF1dG9Ta2lwOiBmYWxzZSxcclxuICAgICAgICAvLyAgICAgbWF4Um90YXRpb246IHR5cGUgPT09ICdiYXJDaGFydERhdGEnIHx8IHR5cGUgPT09ICdzY2F0dGVyQ2hhcnREYXRhJyA/IDIwIDogMTAwLFxyXG4gICAgICAgIC8vIG1pblJvdGF0aW9uOiB0eXBlID09PSAnYmFyQ2hhcnREYXRhJyB8fCB0eXBlID09PSAnc2NhdHRlckNoYXJ0RGF0YScgPyAwIDogOTAsXHJcbiAgICAgICAgLy8gICAgIGF1dG9Ta2lwUGFkZGluZzogMjAsXHJcbiAgICAgICAgLy8gICB9LFxyXG4gICAgICAgIC8vICAgZ3JpZDoge1xyXG4gICAgICAgIC8vICAgICBkaXNwbGF5OiB0cnVlLFxyXG4gICAgICAgIC8vICAgICBkcmF3VGlja3M6IGZhbHNlLFxyXG4gICAgICAgIC8vICAgICB0aWNrTGVuZ3RoOiAxMDAsXHJcbiAgICAgICAgLy8gICAgIGxpbmVXaWR0aDogMVxyXG4gICAgICAgIC8vICAgfSxcclxuICAgICAgICAvLyB9LFxyXG4vLyAgICAgICAgICAgeToge1xyXG4vLyAgICAgICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgdGlja3M6IHtcclxuLy8gICAgICAgICAgICAgICBwcmVjaXNpb246IDAsXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICBwbHVnaW5zOiB7XHJcbi8vICAgICAgIGxlZ2VuZDoge1xyXG4vLyAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbi8vICAgICAgICAgcG9zaXRpb246IFwidG9wXCIsXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICAgIHRvb2x0aXA6IHtcclxuLy8gICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4vLyAgICAgICB9LFxyXG4vLyAgICAgfSxcclxuLy8gICB9KTtcclxuXHJcbi8vICAgY29uc3QgcmVuZGVyQ2hhcnQgPSAodHlwZTogc3RyaW5nLCBDaGFydENvbXBvbmVudDogYW55KSA9PiB7XHJcbi8vICAgICBjb25zdCBkYXRhID0gY2hhcnREYXRhW3R5cGVdO1xyXG4vLyAgICAgaWYgKCFsb2FkaW5nICYmIGRhdGEpIHtcclxuLy8gICAgICAgcmV0dXJuIChcclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQgcC00IGJvcmRlciByb3VuZGVkIHNoYWRvdy1zbVwiPlxyXG4vLyAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogXCIxMDAlXCIsIG92ZXJmbG93WDogXCJhdXRvXCIgfX0+XHJcbi8vICAgICAgICAgICAgIDxkaXZcclxuLy8gICAgICAgICAgICAgICBzdHlsZT17e1xyXG4vLyAgICAgICAgICAgICAgICAgbWluV2lkdGg6IFtcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSlcclxuLy8gICAgICAgICAgICAgICAgICAgPyBgJHtjaGFydFdpZHRofXB4YFxyXG4vLyAgICAgICAgICAgICAgICAgICA6IFwiYXV0b1wiLFxyXG4vLyAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjQwMHB4XCIsXHJcbi8vICAgICAgICAgICAgICAgfX1cclxuLy8gICAgICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgICAgIDxDaGFydENvbXBvbmVudCBkYXRhPXtkYXRhfSBvcHRpb25zPXtnZXRDaGFydE9wdGlvbnModHlwZSl9IC8+XHJcbi8vICAgICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICk7XHJcbi8vICAgICB9XHJcbi8vICAgICByZXR1cm4gbnVsbDtcclxuLy8gICB9O1xyXG5cclxuLy8gICByZXR1cm4gKFxyXG4vLyAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIG1kOmZsZXgtcm93IGgtc2NyZWVuIGJvcmRlciBib3JkZXItYmxhY2tcIj5cclxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0xLzQgYmctd2hpdGUgcC01IGJvcmRlci10IG1kOmJvcmRlci1sIG1kOmJvcmRlci1ibGFja1wiPlxyXG4vLyAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+VXBsb2FkIEZpbGU8L2gyPlxyXG4vLyAgICAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIG9uQ2hhbmdlPXtoYW5kbGVGaWxlQ2hhbmdlfSBjbGFzc05hbWU9XCJib3JkZXIgcC0yIHctZnVsbFwiIC8+XHJcbi8vICAgICAgICAgPGJ1dHRvblxyXG4vLyAgICAgICAgICAgb25DbGljaz17aGFuZGxlU3VibWl0fVxyXG4vLyAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctYmx1ZS01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBtdC00XCJcclxuLy8gICAgICAgICA+XHJcbi8vICAgICAgICAgICA8QnNVcGxvYWQgY2xhc3NOYW1lPVwibXItMlwiIC8+IFN1Ym1pdFxyXG4vLyAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBzcGFjZS15LTIgbXQtNFwiPlxyXG4vLyAgICAgICAgICAge1tcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIiwgXCJzY2F0dGVyQ2hhcnREYXRhXCIsIFwicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0ubWFwKFxyXG4vLyAgICAgICAgICAgICAodHlwZSkgPT4gKFxyXG4vLyAgICAgICAgICAgICAgIDxidXR0b25cclxuLy8gICAgICAgICAgICAgICAgIGtleT17dHlwZX1cclxuLy8gICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkQ2hhcnQodHlwZSl9XHJcbi8vICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJwLTIgYmctZ3JheS0zMDAgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTQwMFwiXHJcbi8vICAgICAgICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgICAgICAge3R5cGUucmVwbGFjZShcIkNoYXJ0RGF0YVwiLCBcIiBDaGFydFwiKX1cclxuLy8gICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgICAgICAgKVxyXG4vLyAgICAgICAgICAgKX1cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgPC9kaXY+XHJcblxyXG4vLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTMvNCBiZy1ncmF5LTEwMCBwLTUgb3ZlcmZsb3ctYXV0b1wiPlxyXG4vLyAgICAgICAgIHtsb2FkaW5nID8gKFxyXG4vLyAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBoLWZ1bGxcIj5cclxuLy8gICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGlubmVyLWJvcmRlciBhbmltYXRlLXNwaW4gYm9yZGVyLXQtNCBib3JkZXItYmx1ZS01MDAgcm91bmRlZC1mdWxsIHctMTIgaC0xMlwiPjwvZGl2PlxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgKSA6IChcclxuLy8gICAgICAgICAgIHJlbmRlckNoYXJ0KHNlbGVjdGVkQ2hhcnQsIHtcclxuLy8gICAgICAgICAgICAgbGluZUNoYXJ0RGF0YTogTGluZSxcclxuLy8gICAgICAgICAgICAgYmFyQ2hhcnREYXRhOiBCYXIsXHJcbi8vICAgICAgICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IFNjYXR0ZXIsXHJcbi8vICAgICAgICAgICAgIHBpZUNoYXJ0RGF0YTogUGllLFxyXG4vLyAgICAgICAgICAgICBkb251dENoYXJ0RGF0YTogRG91Z2hudXQsXHJcbi8vICAgICAgICAgICB9W3NlbGVjdGVkQ2hhcnRdKVxyXG4vLyAgICAgICAgICl9XHJcbi8vICAgICAgIDwvZGl2PlxyXG4vLyAgICAgPC9kaXY+XHJcbi8vICAgKTtcclxuLy8gfVxyXG5cclxuXHJcbi8vIFwidXNlIGNsaWVudFwiO1xyXG4vLyBpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XHJcbi8vIGltcG9ydCB7IEJhciwgTGluZSwgRG91Z2hudXQsIFBpZSwgU2NhdHRlciB9IGZyb20gXCJyZWFjdC1jaGFydGpzLTJcIjtcclxuLy8gaW1wb3J0IHtcclxuLy8gICBDaGFydCBhcyBDaGFydEpTLFxyXG4vLyAgIENhdGVnb3J5U2NhbGUsXHJcbi8vICAgTGluZWFyU2NhbGUsXHJcbi8vICAgQmFyRWxlbWVudCxcclxuLy8gICBMaW5lRWxlbWVudCxcclxuLy8gICBQb2ludEVsZW1lbnQsXHJcbi8vICAgQXJjRWxlbWVudCxcclxuLy8gICBUaXRsZSxcclxuLy8gICBUb29sdGlwLFxyXG4vLyAgIExlZ2VuZCxcclxuLy8gfSBmcm9tIFwiY2hhcnQuanNcIjtcclxuLy8gaW1wb3J0IHsgQnNVcGxvYWQgfSBmcm9tIFwicmVhY3QtaWNvbnMvYnNcIjtcclxuLy8gaW1wb3J0IHpvb21QbHVnaW4gZnJvbSBcImNoYXJ0anMtcGx1Z2luLXpvb21cIjtcclxuXHJcbi8vIENoYXJ0SlMucmVnaXN0ZXIoXHJcbi8vICAgQ2F0ZWdvcnlTY2FsZSxcclxuLy8gICBMaW5lYXJTY2FsZSxcclxuLy8gICBCYXJFbGVtZW50LFxyXG4vLyAgIExpbmVFbGVtZW50LFxyXG4vLyAgIFBvaW50RWxlbWVudCxcclxuLy8gICBBcmNFbGVtZW50LFxyXG4vLyAgIFRpdGxlLFxyXG4vLyAgIFRvb2x0aXAsXHJcbi8vICAgTGVnZW5kLFxyXG4vLyAgIHpvb21QbHVnaW5cclxuLy8gKTtcclxuXHJcbi8vIGludGVyZmFjZSBDaGFydERhdGEge1xyXG4vLyAgIGxhYmVsczogc3RyaW5nW107XHJcbi8vICAgZGF0YXNldHM6IHtcclxuLy8gICAgIGxhYmVsOiBzdHJpbmc7XHJcbi8vICAgICBkYXRhOiBudW1iZXJbXTtcclxuLy8gICAgIGJhY2tncm91bmRDb2xvcj86IHN0cmluZyB8IHN0cmluZ1tdO1xyXG4vLyAgICAgYm9yZGVyQ29sb3I/OiBzdHJpbmc7XHJcbi8vICAgICBmaWxsPzogYm9vbGVhbjtcclxuLy8gICB9W107XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhc2hib2FyZCgpIHtcclxuLy8gICBjb25zdCBbY2hhcnREYXRhLCBzZXRDaGFydERhdGFdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgQ2hhcnREYXRhIHwgbnVsbD4+KHtcclxuLy8gICAgIHNjYXR0ZXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBwaWVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBkb251dENoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGxpbmVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBiYXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgfSk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkRmlsZSwgc2V0U2VsZWN0ZWRGaWxlXSA9IHVzZVN0YXRlPEZpbGUgfCBudWxsPihudWxsKTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRDaGFydCwgc2V0U2VsZWN0ZWRDaGFydF0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwibGluZUNoYXJ0RGF0YVwiKTtcclxuLy8gICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcbi8vICAgY29uc3QgW2NoYXJ0V2lkdGgsIHNldENoYXJ0V2lkdGhdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcclxuLy8gICBjb25zdCBbaW5wdXRWYWx1ZSwgc2V0SW5wdXRWYWx1ZV0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiXCIpO1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVGaWxlQ2hhbmdlID0gKGV2ZW50OiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xyXG4vLyAgICAgc2V0U2VsZWN0ZWRGaWxlKGV2ZW50LnRhcmdldC5maWxlcz8uWzBdIHx8IG51bGwpO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IGFzeW5jICgpID0+IHtcclxuLy8gICAgIGlmICghc2VsZWN0ZWRGaWxlKSByZXR1cm47XHJcbi8vICAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG5cclxuLy8gICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbi8vICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIHNlbGVjdGVkRmlsZSk7XHJcblxyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHA6Ly9sb2NhbGhvc3Q6MzAxMi9hcGkvYW5hbHl6ZS1leGNlbFwiLCB7XHJcbi8vICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuLy8gICAgICAgICBib2R5OiBmb3JtRGF0YSxcclxuLy8gICAgICAgfSk7XHJcblxyXG4vLyAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZS5cIik7XHJcbi8vICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuLy8gICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHJlc3VsdC5kYXRhPy5wcm9jZXNzZWREYXRhO1xyXG5cclxuLy8gICAgICAgaWYgKCFwcm9jZXNzZWREYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZS5cIik7XHJcblxyXG4vLyAgICAgICBjb25zdCBsaWdodENvbG9ycyA9IFtcclxuLy8gICAgICAgICBcInJnYmEoMTczLCAyMTYsIDIzMCwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgxNDQsIDIzOCwgMTQ0LCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDI1NSwgMTgyLCAxOTMsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjU1LCAyMjgsIDE4MSwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyMjEsIDE2MCwgMjIxLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDI0MCwgMjMwLCAxNDAsIDAuNilcIixcclxuLy8gICAgICAgXTtcclxuXHJcbi8vICAgICAgIGNvbnN0IGdlbmVyYXRlQ2hhcnREYXRhID0gKGNoYXJ0VHlwZTogc3RyaW5nKTogQ2hhcnREYXRhIHwgbnVsbCA9PiB7XHJcbi8vICAgICAgICAgY29uc3QgY2hhcnRJbmZvID0gcHJvY2Vzc2VkRGF0YVtjaGFydFR5cGVdPy5bMF07XHJcbi8vICAgICAgICAgaWYgKCFjaGFydEluZm8pIHJldHVybiBudWxsO1xyXG5cclxuLy8gICAgICAgICBjb25zdCBsYWJlbHMgPSBPYmplY3Qua2V5cyhjaGFydEluZm8uZGF0YSk7XHJcbi8vICAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhjaGFydEluZm8uZGF0YSk7XHJcblxyXG4vLyAgICAgICAgIHNldENoYXJ0V2lkdGgobGFiZWxzLmxlbmd0aCAqIDE1MCk7XHJcblxyXG4vLyAgICAgICAgIHJldHVybiB7XHJcbi8vICAgICAgICAgICBsYWJlbHMsXHJcbi8vICAgICAgICAgICBkYXRhc2V0czogW1xyXG4vLyAgICAgICAgICAgICB7XHJcbi8vICAgICAgICAgICAgICAgbGFiZWw6IGNoYXJ0SW5mby5sYWJlbCB8fCBjaGFydFR5cGUsXHJcbi8vICAgICAgICAgICAgICAgZGF0YTogdmFsdWVzIGFzIG51bWJlcltdLFxyXG4vLyAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogW1wiUGllIENoYXJ0XCIsIFwiRG9udXQgQ2hhcnRcIiwgXCJCYXIgQ2hhcnRcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKVxyXG4vLyAgICAgICAgICAgICAgICAgPyBsaWdodENvbG9ycy5zbGljZSgwLCBsYWJlbHMubGVuZ3RoKVxyXG4vLyAgICAgICAgICAgICAgICAgOiBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMC42KVwiLFxyXG4vLyAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpXHJcbi8vICAgICAgICAgICAgICAgICA/IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAxKVwiXHJcbi8vICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcclxuLy8gICAgICAgICAgICAgICBmaWxsOiAhY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIF0sXHJcbi8vICAgICAgICAgfTtcclxuLy8gICAgICAgfTtcclxuXHJcbi8vICAgICAgIHNldENoYXJ0RGF0YSh7XHJcbi8vICAgICAgICAgc2NhdHRlckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJTY2F0dGVyIFBsb3RcIiksXHJcbi8vICAgICAgICAgcGllQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlBpZSBDaGFydFwiKSxcclxuLy8gICAgICAgICBkb251dENoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJEb251dCBDaGFydFwiKSxcclxuLy8gICAgICAgICBsaW5lQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkxpbmUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgYmFyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkJhciBDaGFydFwiKSxcclxuLy8gICAgICAgfSk7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGU6XCIsIGVycm9yKTtcclxuLy8gICAgIH0gZmluYWxseSB7XHJcbi8vICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZVNlbmQgPSAoKSA9PiB7XHJcbi8vICAgICBjb25zb2xlLmxvZyhcIklucHV0IFZhbHVlOlwiLCBpbnB1dFZhbHVlKTtcclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBnZXRDaGFydE9wdGlvbnMgPSAodHlwZTogc3RyaW5nKSA9PiAoe1xyXG4vLyAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuLy8gICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxyXG4vLyAgICAgc2NhbGVzOiBbXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKVxyXG4vLyAgICAgICA/IHt9XHJcbi8vICAgICAgIDoge1xyXG4vLyAgICAgICAgIHg6IHtcclxuLy8gICAgICAgICAgIHRpY2tzOiB7XHJcbi8vICAgICAgICAgICAgIGF1dG9Ta2lwOiBmYWxzZSxcclxuLy8gICAgICAgICAgICAgbWF4Um90YXRpb246IHR5cGUgPT09ICdiYXJDaGFydERhdGEnIHx8IHR5cGUgPT09ICdzY2F0dGVyQ2hhcnREYXRhJyA/IDIwIDogMTAwLFxyXG4vLyAgICAgICAgIG1pblJvdGF0aW9uOiB0eXBlID09PSAnYmFyQ2hhcnREYXRhJyB8fCB0eXBlID09PSAnc2NhdHRlckNoYXJ0RGF0YScgPyAwIDogOTAsXHJcbi8vICAgICAgICAgICAgIGF1dG9Ta2lwUGFkZGluZzogMjAsXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgZ3JpZDoge1xyXG4vLyAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4vLyAgICAgICAgICAgICBkcmF3VGlja3M6IGZhbHNlLFxyXG4vLyAgICAgICAgICAgICB0aWNrTGVuZ3RoOiAxMDAsXHJcbi8vICAgICAgICAgICAgIGxpbmVXaWR0aDogMVxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgeToge1xyXG4vLyAgICAgICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgdGlja3M6IHtcclxuLy8gICAgICAgICAgICAgICBwcmVjaXNpb246IDAsXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICBwbHVnaW5zOiB7XHJcbi8vICAgICAgIGxlZ2VuZDoge1xyXG4vLyAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbi8vICAgICAgICAgcG9zaXRpb246IFwidG9wXCIsXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICAgIHRvb2x0aXA6IHtcclxuLy8gICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4vLyAgICAgICB9LFxyXG4vLyAgICAgfSxcclxuLy8gICB9KTtcclxuXHJcbi8vICAgY29uc3QgcmVuZGVyQ2hhcnQgPSAodHlwZTogc3RyaW5nLCBDaGFydENvbXBvbmVudDogYW55KSA9PiB7XHJcbi8vICAgICBjb25zdCBkYXRhID0gY2hhcnREYXRhW3R5cGVdO1xyXG4vLyAgICAgaWYgKCFsb2FkaW5nICYmIGRhdGEpIHtcclxuLy8gICAgICAgcmV0dXJuIChcclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQgcC00IGJvcmRlciByb3VuZGVkIHNoYWRvdy1zbVwiPlxyXG4vLyAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogXCIxMDAlXCIsIG92ZXJmbG93WDogXCJhdXRvXCIgfX0+XHJcbi8vICAgICAgICAgICAgIDxkaXZcclxuLy8gICAgICAgICAgICAgICBzdHlsZT17e1xyXG4vLyAgICAgICAgICAgICAgICAgbWluV2lkdGg6IFtcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSlcclxuLy8gICAgICAgICAgICAgICAgICAgPyBgJHtjaGFydFdpZHRofXB4YFxyXG4vLyAgICAgICAgICAgICAgICAgICA6IFwiYXV0b1wiLFxyXG4vLyAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjQwMHB4XCIsXHJcbi8vICAgICAgICAgICAgICAgfX1cclxuLy8gICAgICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgICAgIDxDaGFydENvbXBvbmVudCBkYXRhPXtkYXRhfSBvcHRpb25zPXtnZXRDaGFydE9wdGlvbnModHlwZSl9IC8+XHJcbi8vICAgICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICk7XHJcbi8vICAgICB9XHJcbi8vICAgICByZXR1cm4gbnVsbDtcclxuLy8gICB9O1xyXG5cclxuLy8gICByZXR1cm4gKFxyXG4vLyAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIG1kOmZsZXgtcm93IGgtc2NyZWVuIGJvcmRlciBib3JkZXItYmxhY2tcIj5cclxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0xLzQgYmctd2hpdGUgcC01IGJvcmRlci10IG1kOmJvcmRlci1sIG1kOmJvcmRlci1ibGFja1wiPlxyXG4vLyAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+VXBsb2FkIEZpbGU8L2gyPlxyXG4vLyAgICAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIG9uQ2hhbmdlPXtoYW5kbGVGaWxlQ2hhbmdlfSBjbGFzc05hbWU9XCJib3JkZXIgcC0yIHctZnVsbFwiIC8+XHJcbi8vICAgICAgICAgPGJ1dHRvblxyXG4vLyAgICAgICAgICAgb25DbGljaz17aGFuZGxlU3VibWl0fVxyXG4vLyAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctYmx1ZS01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBtdC00XCJcclxuLy8gICAgICAgICA+XHJcbi8vICAgICAgICAgICA8QnNVcGxvYWQgY2xhc3NOYW1lPVwibXItMlwiIC8+IFN1Ym1pdFxyXG4vLyAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBzcGFjZS15LTIgbXQtNFwiPlxyXG4vLyAgICAgICAgICAge1tcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIiwgXCJzY2F0dGVyQ2hhcnREYXRhXCIsIFwicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0ubWFwKFxyXG4vLyAgICAgICAgICAgICAodHlwZSkgPT4gKFxyXG4vLyAgICAgICAgICAgICAgIDxidXR0b25cclxuLy8gICAgICAgICAgICAgICAgIGtleT17dHlwZX1cclxuLy8gICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkQ2hhcnQodHlwZSl9XHJcbi8vICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJwLTIgYmctZ3JheS0zMDAgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTQwMFwiXHJcbi8vICAgICAgICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgICAgICAge3R5cGUucmVwbGFjZShcIkNoYXJ0RGF0YVwiLCBcIiBDaGFydFwiKX1cclxuLy8gICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgICAgICAgKVxyXG4vLyAgICAgICAgICAgKX1cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgPC9kaXY+XHJcblxyXG4vLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTMvNCBiZy1ncmF5LTEwMCBwLTUgb3ZlcmZsb3ctYXV0b1wiPlxyXG4vLyAgICAgICAgIHtsb2FkaW5nID8gKFxyXG4vLyAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBoLWZ1bGxcIj5cclxuLy8gICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGlubmVyLWJvcmRlciBhbmltYXRlLXNwaW4gYm9yZGVyLXQtNCBib3JkZXItYmx1ZS01MDAgcm91bmRlZC1mdWxsIHctMTIgaC0xMlwiPjwvZGl2PlxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgKSA6IChcclxuLy8gICAgICAgICAgIHJlbmRlckNoYXJ0KHNlbGVjdGVkQ2hhcnQsIHtcclxuLy8gICAgICAgICAgICAgbGluZUNoYXJ0RGF0YTogTGluZSxcclxuLy8gICAgICAgICAgICAgYmFyQ2hhcnREYXRhOiBCYXIsXHJcbi8vICAgICAgICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IFNjYXR0ZXIsXHJcbi8vICAgICAgICAgICAgIHBpZUNoYXJ0RGF0YTogUGllLFxyXG4vLyAgICAgICAgICAgICBkb251dENoYXJ0RGF0YTogRG91Z2hudXQsXHJcbi8vICAgICAgICAgICB9W3NlbGVjdGVkQ2hhcnRdKVxyXG4vLyAgICAgICAgICl9XHJcblxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtNCBmbGV4XCI+XHJcbi8vICAgICAgICAgICA8aW5wdXRcclxuLy8gICAgICAgICAgICAgdHlwZT1cInRleHRcIlxyXG4vLyAgICAgICAgICAgICB2YWx1ZT17aW5wdXRWYWx1ZX1cclxuLy8gICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRJbnB1dFZhbHVlKGUudGFyZ2V0LnZhbHVlKX1cclxuLy8gICAgICAgICAgICAgY2xhc3NOYW1lPVwiYm9yZGVyIHAtMiBmbGV4LWdyb3cgbXItMiByb3VuZGVkXCJcclxuLy8gICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJFbnRlciB5b3VyIHRleHQgaGVyZVwiXHJcbi8vICAgICAgICAgICAvPlxyXG4vLyAgICAgICAgICAgPGJ1dHRvblxyXG4vLyAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVTZW5kfVxyXG4vLyAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1ncmVlbi01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZFwiXHJcbi8vICAgICAgICAgICA+XHJcbi8vICAgICAgICAgICAgIFNlbmRcclxuLy8gICAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICA8L2Rpdj5cclxuLy8gICAgIDwvZGl2PlxyXG4vLyAgICk7XHJcbi8vIH1cclxuXHJcblxyXG5cclxuLy8gXCJ1c2UgY2xpZW50XCI7XHJcbi8vIGltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuLy8gaW1wb3J0IHsgQmFyLCBMaW5lLCBEb3VnaG51dCwgUGllLCBTY2F0dGVyIH0gZnJvbSBcInJlYWN0LWNoYXJ0anMtMlwiO1xyXG4vLyBpbXBvcnQgeyBDaGFydCBhcyBDaGFydEpTLCBDYXRlZ29yeVNjYWxlLCBMaW5lYXJTY2FsZSwgQmFyRWxlbWVudCwgTGluZUVsZW1lbnQsIFBvaW50RWxlbWVudCwgQXJjRWxlbWVudCwgVGl0bGUsIFRvb2x0aXAsIExlZ2VuZCB9IGZyb20gXCJjaGFydC5qc1wiO1xyXG4vLyBpbXBvcnQgeyBCc1VwbG9hZCB9IGZyb20gXCJyZWFjdC1pY29ucy9ic1wiO1xyXG4vLyBpbXBvcnQgem9vbVBsdWdpbiBmcm9tIFwiY2hhcnRqcy1wbHVnaW4tem9vbVwiO1xyXG5cclxuLy8gQ2hhcnRKUy5yZWdpc3RlcihDYXRlZ29yeVNjYWxlLCBMaW5lYXJTY2FsZSwgQmFyRWxlbWVudCwgTGluZUVsZW1lbnQsIFBvaW50RWxlbWVudCwgQXJjRWxlbWVudCwgVGl0bGUsIFRvb2x0aXAsIExlZ2VuZCwgem9vbVBsdWdpbik7XHJcblxyXG4vLyBpbnRlcmZhY2UgQ2hhcnREYXRhIHtcclxuLy8gICBsYWJlbHM6IHN0cmluZ1tdO1xyXG4vLyAgIGRhdGFzZXRzOiB7XHJcbi8vICAgICBsYWJlbDogc3RyaW5nO1xyXG4vLyAgICAgZGF0YTogbnVtYmVyW107XHJcbi8vICAgICBiYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmcgfCBzdHJpbmdbXTtcclxuLy8gICAgIGJvcmRlckNvbG9yPzogc3RyaW5nO1xyXG4vLyAgICAgZmlsbD86IGJvb2xlYW47XHJcbi8vICAgfVtdXHJcbi8vICAgbWV0YT86IHtcclxuLy8gICAgIGhlYWRlcjogc3RyaW5nO1xyXG4vLyAgICAgdmFsdWVOYW1lOiBzdHJpbmc7XHJcbi8vICAgfTtcclxuLy8gfVxyXG5cclxuLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGFzaGJvYXJkKCkge1xyXG4vLyAgIGNvbnN0IFtjaGFydERhdGEsIHNldENoYXJ0RGF0YV0gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBDaGFydERhdGEgfCBudWxsPj4oe1xyXG4vLyAgICAgc2NhdHRlckNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIHBpZUNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGRvbnV0Q2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgbGluZUNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGJhckNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICB9KTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRGaWxlLCBzZXRTZWxlY3RlZEZpbGVdID0gdXNlU3RhdGU8RmlsZSB8IG51bGw+KG51bGwpO1xyXG4vLyAgIGNvbnN0IFtzZWxlY3RlZENoYXJ0LCBzZXRTZWxlY3RlZENoYXJ0XSA9IHVzZVN0YXRlPHN0cmluZz4oXCJsaW5lQ2hhcnREYXRhXCIpO1xyXG4vLyAgIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcclxuLy8gICBjb25zdCBbY2hhcnRXaWR0aCwgc2V0Q2hhcnRXaWR0aF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xyXG4vLyAgIGNvbnN0IFtpbnB1dFZhbHVlLCBzZXRJbnB1dFZhbHVlXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XHJcbi8vICAgY29uc3QgW3N0b3JlZFByb2Nlc3NlZERhdGEsIHNldFN0b3JlZFByb2Nlc3NlZERhdGFdID0gdXNlU3RhdGU8YW55PihudWxsKTsgLy8gTmV3IHN0YXRlIHRvIHN0b3JlIHByb2Nlc3NlZCBkYXRhXHJcbi8vICAgY29uc3QgW2NvbWJpbmVkSW5zaWdodHMsIHNldENvbWJpbmVkSW5zaWdodHNdID0gdXNlU3RhdGU8YW55PihudWxsKTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlRmlsZUNoYW5nZSA9IChldmVudDogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcclxuLy8gICAgIHNldFNlbGVjdGVkRmlsZShldmVudC50YXJnZXQuZmlsZXM/LlswXSB8fCBudWxsKTtcclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVTdWJtaXQgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBpZiAoIXNlbGVjdGVkRmlsZSkgcmV0dXJuO1xyXG4vLyAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuXHJcbi8vICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4vLyAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBzZWxlY3RlZEZpbGUpO1xyXG5cclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwOi8vbG9jYWxob3N0OjMwMTIvYXBpL2FuYWx5emUtZXhjZWxcIiwge1xyXG4vLyAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbi8vICAgICAgICAgYm9keTogZm9ybURhdGEsXHJcbi8vICAgICAgIH0pO1xyXG5cclxuLy8gICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGUuXCIpO1xyXG4vLyAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbi8vICAgICAgIGNvbnN0IGNvbWJpbmVkSW5zaWdodHMgPSByZXN1bHQuZGF0YT8uY29tYmluZWRJbnNpZ2h0cztcclxuLy8gICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHJlc3VsdC5kYXRhPy5wcm9jZXNzZWREYXRhO1xyXG5cclxuLy8gICAgICAgaWYgKCFwcm9jZXNzZWREYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZS5cIik7XHJcbi8vIGNvbnNvbGUubG9nKFwicHJvY2Vzc2VkRGF0YVwiLHByb2Nlc3NlZERhdGEpO1xyXG5cclxuLy8gICAgICAgc2V0U3RvcmVkUHJvY2Vzc2VkRGF0YShwcm9jZXNzZWREYXRhKTsgLy8gU3RvcmUgdGhlIHByb2Nlc3NlZCBkYXRhXHJcbi8vICAgICAgIHNldENvbWJpbmVkSW5zaWdodHMoY29tYmluZWRJbnNpZ2h0cyk7XHJcbi8vICAgICAgIGNvbnN0IGxpZ2h0Q29sb3JzID0gW1xyXG4vLyAgICAgICAgIFwicmdiYSgxNzMsIDIxNiwgMjMwLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDE0NCwgMjM4LCAxNDQsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjU1LCAxODIsIDE5MywgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyNTUsIDIyOCwgMTgxLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDIyMSwgMTYwLCAyMjEsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjQwLCAyMzAsIDE0MCwgMC42KVwiLFxyXG4vLyAgICAgICBdO1xyXG5cclxuLy8gICAgICAgY29uc3QgZ2VuZXJhdGVDaGFydERhdGEgPSAoY2hhcnRUeXBlOiBzdHJpbmcpOiBDaGFydERhdGEgfCBudWxsID0+IHtcclxuLy8gICAgICAgICBjb25zdCBjaGFydEluZm8gPSBwcm9jZXNzZWREYXRhW2NoYXJ0VHlwZV0/LlswXTtcclxuLy8gICAgICAgICBpZiAoIWNoYXJ0SW5mbykgcmV0dXJuIG51bGw7XHJcblxyXG4vLyAgICAgICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5rZXlzKGNoYXJ0SW5mby5kYXRhKTtcclxuLy8gICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGNoYXJ0SW5mby5kYXRhKTtcclxuXHJcbi8vICAgICAgICAgc2V0Q2hhcnRXaWR0aChsYWJlbHMubGVuZ3RoICogMTUwKTtcclxuXHJcbi8vICAgICAgICAgcmV0dXJuIHtcclxuLy8gICAgICAgICAgIGxhYmVscyxcclxuLy8gICAgICAgICAgIGRhdGFzZXRzOiBbXHJcbi8vICAgICAgICAgICAgIHtcclxuLy8gICAgICAgICAgICAgICBsYWJlbDogY2hhcnRJbmZvLmxhYmVsIHx8IGNoYXJ0VHlwZSxcclxuLy8gICAgICAgICAgICAgICBkYXRhOiB2YWx1ZXMgYXMgbnVtYmVyW10sXHJcbi8vICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbXCJQaWUgQ2hhcnRcIiwgXCJEb251dCBDaGFydFwiLCBcIkJhciBDaGFydFwiXS5pbmNsdWRlcyhjaGFydFR5cGUpXHJcbi8vICAgICAgICAgICAgICAgICA/IGxpZ2h0Q29sb3JzLnNsaWNlKDAsIGxhYmVscy5sZW5ndGgpXHJcbi8vICAgICAgICAgICAgICAgICA6IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAwLjYpXCIsXHJcbi8vICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIikgPyBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMSlcIiA6IHVuZGVmaW5lZCxcclxuLy8gICAgICAgICAgICAgICBmaWxsOiAhY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIF0sXHJcbi8vICAgICAgICAgICBtZXRhOiB7XHJcbi8vICAgICAgICAgICAgIGhlYWRlcjogY2hhcnRJbmZvLmhlYWRlciB8fCBcImRlZmF1bHRfaGVhZGVyXCIsXHJcbi8vICAgICAgICAgICAgIHZhbHVlTmFtZTogY2hhcnRJbmZvLnZhbHVlTmFtZSB8fCBcImRlZmF1bHRfdmFsdWVOYW1lXCIsXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH07XHJcbi8vICAgICAgIH07XHJcblxyXG4vLyAgICAgICBzZXRDaGFydERhdGEoe1xyXG4vLyAgICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiU2NhdHRlciBQbG90XCIpLFxyXG4vLyAgICAgICAgIHBpZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJQaWUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgZG9udXRDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiRG9udXQgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgbGluZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJMaW5lIENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGJhckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJCYXIgQ2hhcnRcIiksXHJcbi8vICAgICAgIH0pO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlOlwiLCBlcnJvcik7XHJcbi8vICAgICB9IGZpbmFsbHkge1xyXG4vLyAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuLy8gICAgIH1cclxuLy8gICB9O1xyXG5cclxuIFxyXG4vLyAgIGNvbnN0IGhhbmRsZVNlbmQgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBpZiAoIWlucHV0VmFsdWUpIHJldHVybjtcclxuICBcclxuLy8gICAgIGNvbnN0IGdyYXBoRGF0YSA9IGNoYXJ0RGF0YVtzZWxlY3RlZENoYXJ0XTtcclxuLy8gICAgIGlmICghZ3JhcGhEYXRhKSByZXR1cm47XHJcbiAgXHJcbi8vICAgICBjb25zdCBsYWJlbHMgPSBncmFwaERhdGEubGFiZWxzO1xyXG4vLyAgICAgY29uc3QgdmFsdWVzID0gZ3JhcGhEYXRhLmRhdGFzZXRzWzBdLmRhdGE7XHJcbiAgXHJcbi8vICAgICBjb25zdCBkYXRhT2JqZWN0ID0gbGFiZWxzLnJlZHVjZSgob2JqOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9LCBsYWJlbCwgaW5kZXgpID0+IHtcclxuLy8gICAgICAgb2JqW2xhYmVsXSA9IHZhbHVlc1tpbmRleF07XHJcbi8vICAgICAgIHJldHVybiBvYmo7XHJcbi8vICAgICB9LCB7fSk7XHJcbiAgXHJcbi8vICAgICBjb25zdCBjaGFydFR5cGVNYXBwaW5nOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xyXG4vLyAgICAgICBsaW5lQ2hhcnREYXRhOiBcIkxpbmUgQ2hhcnRcIixcclxuLy8gICAgICAgcGllQ2hhcnREYXRhOiBcIlBpZSBDaGFydFwiLFxyXG4vLyAgICAgICBkb251dENoYXJ0RGF0YTogXCJEb251dCBDaGFydFwiLFxyXG4vLyAgICAgICBiYXJDaGFydERhdGE6IFwiQmFyIENoYXJ0XCIsXHJcbi8vICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IFwiU2NhdHRlciBQbG90XCIsXHJcbi8vICAgICB9O1xyXG4gIFxyXG4vLyAgICAgY29uc3Qgc2VsZWN0ZWRDaGFydFR5cGUgPSBjaGFydFR5cGVNYXBwaW5nW3NlbGVjdGVkQ2hhcnRdIHx8IHNlbGVjdGVkQ2hhcnQ7XHJcbiAgXHJcbi8vICAgICAvLyBGaWx0ZXIgdGhlIHN0b3JlZCBwcm9jZXNzZWQgZGF0YSB0byBpbmNsdWRlIG9ubHkgdGhlIHNlbGVjdGVkIGNoYXJ0J3MgZGF0YVxyXG4vLyAgICAgY29uc3QgZmlsdGVyZWRQcm9jZXNzZWREYXRhID0ge1xyXG4vLyAgICAgICBbc2VsZWN0ZWRDaGFydFR5cGVdOiBzdG9yZWRQcm9jZXNzZWREYXRhW3NlbGVjdGVkQ2hhcnRUeXBlXSxcclxuLy8gICAgIH07XHJcbiAgXHJcbi8vICAgICBjb25zb2xlLmxvZyhcIi4uLmZpbHRlcmVkUHJvY2Vzc2VkRGF0YSxcIiwgZmlsdGVyZWRQcm9jZXNzZWREYXRhW3NlbGVjdGVkQ2hhcnRUeXBlXT8uWzBdPy5kYXRhKTtcclxuLy8gICAgIGNvbnNvbGUubG9nKFwiZGF0YU9iamVjdCxcIiwgZGF0YU9iamVjdCk7XHJcbiAgXHJcbi8vICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcclxuLy8gICAgICAgcXVlc3Rpb246IGlucHV0VmFsdWUsXHJcbi8vICAgICAgIHByb2Nlc3NlZERhdGE6IHtcclxuLy8gICAgICAgICAvLyBJbmNsdWRlIHRoZSBzdG9yZWQgcHJvY2Vzc2VkIGRhdGFcclxuLy8gICAgICAgICBbc2VsZWN0ZWRDaGFydFR5cGVdOiBbXHJcbi8vICAgICAgICAgICB7XHJcbi8vICAgICAgICAgICAgIGhlYWRlcjogZ3JhcGhEYXRhLm1ldGE/LmhlYWRlciB8fCBcImRlZmF1bHRfaGVhZGVyXCIsXHJcbi8vICAgICAgICAgICAgIHZhbHVlTmFtZTogZ3JhcGhEYXRhLm1ldGE/LnZhbHVlTmFtZSB8fCBcImRlZmF1bHRfdmFsdWVOYW1lXCIsXHJcbi8vICAgICAgICAgICAgIGxhYmVsOiBncmFwaERhdGEuZGF0YXNldHNbMF0ubGFiZWwsXHJcbi8vICAgICAgICAgICAgIGRhdGE6IGZpbHRlcmVkUHJvY2Vzc2VkRGF0YVtzZWxlY3RlZENoYXJ0VHlwZV0/LlswXT8uZGF0YSxcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgXSxcclxuLy8gICAgICAgfSxcclxuLy8gICAgIH07XHJcbiAgXHJcbi8vICAgICB0cnkge1xyXG4vLyAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxyXG4vLyAgICAgICAgIGBodHRwOi8vbG9jYWxob3N0OjMwMTIvYXBpL2Fuc3dlci1hbmFseXplLWV4Y2VsP3F1ZXN0aW9uPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0VmFsdWUpfWAsXHJcbi8vICAgICAgICAge1xyXG4vLyAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuLy8gICAgICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcclxuLy8gICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KSxcclxuLy8gICAgICAgICB9XHJcbi8vICAgICAgICk7XHJcbiAgXHJcbi8vICAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlLlwiKTtcclxuLy8gICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4vLyAgICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gcmVzdWx0LmRhdGE/LnByb2Nlc3NlZERhdGE7XHJcbiAgXHJcbi8vICAgICAgIGlmICghcHJvY2Vzc2VkRGF0YSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBzdHJ1Y3R1cmUuXCIpO1xyXG4gIFxyXG4vLyAgICAgICBjb25zb2xlLmxvZyhcIlVwZGF0ZWQgQVBJIFJlc3BvbnNlIERhdGE6XCIsIHByb2Nlc3NlZERhdGEpO1xyXG4gIFxyXG4vLyAgICAgICBjb25zdCBnZW5lcmF0ZUNoYXJ0RGF0YSA9IChjaGFydFR5cGU6IHN0cmluZyk6IENoYXJ0RGF0YSB8IG51bGwgPT4ge1xyXG4vLyAgICAgICAgIGNvbnN0IGNoYXJ0SW5mbyA9IHByb2Nlc3NlZERhdGFbY2hhcnRUeXBlXT8uWzBdOyAvLyBVc2Ugb25seSBBUEkgcmVzcG9uc2UgZGF0YVxyXG4vLyAgICAgICAgIGlmICghY2hhcnRJbmZvKSByZXR1cm4gbnVsbDtcclxuICBcclxuLy8gICAgICAgICBjb25zdCBsYWJlbHMgPSBPYmplY3Qua2V5cyhjaGFydEluZm8uZGF0YSk7XHJcbi8vICAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhjaGFydEluZm8uZGF0YSk7XHJcbiAgXHJcbi8vICAgICAgICAgc2V0Q2hhcnRXaWR0aChsYWJlbHMubGVuZ3RoICogMTUwKTtcclxuICBcclxuLy8gICAgICAgICByZXR1cm4ge1xyXG4vLyAgICAgICAgICAgbGFiZWxzLFxyXG4vLyAgICAgICAgICAgZGF0YXNldHM6IFtcclxuLy8gICAgICAgICAgICAge1xyXG4vLyAgICAgICAgICAgICAgIGxhYmVsOiBjaGFydEluZm8ubGFiZWwgfHwgY2hhcnRUeXBlLFxyXG4vLyAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlcyBhcyBudW1iZXJbXSxcclxuLy8gICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcIlBpZSBDaGFydFwiLCBcIkRvbnV0IENoYXJ0XCIsIFwiQmFyIENoYXJ0XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSlcclxuLy8gICAgICAgICAgICAgICAgID8gW1wicmdiYSgxNzMsIDIxNiwgMjMwLCAwLjYpXCIsIFwicmdiYSgxNDQsIDIzOCwgMTQ0LCAwLjYpXCIsIFwicmdiYSgyNTUsIDE4MiwgMTkzLCAwLjYpXCJdXHJcbi8vICAgICAgICAgICAgICAgICA6IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAwLjYpXCIsXHJcbi8vICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIikgPyBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMSlcIiA6IHVuZGVmaW5lZCxcclxuLy8gICAgICAgICAgICAgICBmaWxsOiAhY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIF0sXHJcbi8vICAgICAgICAgICBtZXRhOiB7XHJcbi8vICAgICAgICAgICAgIGhlYWRlcjogY2hhcnRJbmZvLmhlYWRlciB8fCBcImRlZmF1bHRfaGVhZGVyXCIsXHJcbi8vICAgICAgICAgICAgIHZhbHVlTmFtZTogY2hhcnRJbmZvLnZhbHVlTmFtZSB8fCBcImRlZmF1bHRfdmFsdWVOYW1lXCIsXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH07XHJcbi8vICAgICAgIH07XHJcbiAgXHJcbi8vICAgICAgIC8vIE9ubHkgdXBkYXRlIGNoYXJ0RGF0YSB3aXRob3V0IHN0b3JpbmcgaW4gc3RvcmVkUHJvY2Vzc2VkRGF0YVxyXG4vLyAgICAgICBzZXRDaGFydERhdGEoKHByZXZDaGFydERhdGEpID0+ICh7XHJcbi8vICAgICAgICAgLi4ucHJldkNoYXJ0RGF0YSxcclxuLy8gICAgICAgICBbc2VsZWN0ZWRDaGFydF06IGdlbmVyYXRlQ2hhcnREYXRhKHNlbGVjdGVkQ2hhcnRUeXBlKSxcclxuLy8gICAgICAgfSkpO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNlbmRpbmcgcmVxdWVzdDpcIiwgZXJyb3IpO1xyXG4vLyAgICAgfSBmaW5hbGx5IHtcclxuLy8gICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbi8vICAgICB9XHJcbi8vICAgfTtcclxuICBcclxuXHJcbi8vICAgY29uc3QgZ2V0Q2hhcnRPcHRpb25zID0gKHR5cGU6IHN0cmluZykgPT4gKHtcclxuLy8gICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbi8vICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcclxuLy8gICAgIHNjYWxlczogW1wicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSlcclxuLy8gICAgICAgPyB7fVxyXG4vLyAgICAgICA6IHtcclxuLy8gICAgICAgICB4OiB7XHJcbi8vICAgICAgICAgICB0aWNrczoge1xyXG4vLyAgICAgICAgICAgICBhdXRvU2tpcDogZmFsc2UsXHJcbi8vICAgICAgICAgICAgIG1heFJvdGF0aW9uOiB0eXBlID09PSAnYmFyQ2hhcnREYXRhJyB8fCB0eXBlID09PSAnc2NhdHRlckNoYXJ0RGF0YScgPyAyMCA6IDEwMCxcclxuLy8gICAgICAgICBtaW5Sb3RhdGlvbjogdHlwZSA9PT0gJ2JhckNoYXJ0RGF0YScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXJDaGFydERhdGEnID8gMCA6IDkwLFxyXG4vLyAgICAgICAgICAgICBhdXRvU2tpcFBhZGRpbmc6IDIwLFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIGdyaWQ6IHtcclxuLy8gICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgZHJhd1RpY2tzOiBmYWxzZSxcclxuLy8gICAgICAgICAgICAgdGlja0xlbmd0aDogMTAwLFxyXG4vLyAgICAgICAgICAgICBsaW5lV2lkdGg6IDFcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgICAgICB5OiB7XHJcbi8vICAgICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcclxuLy8gICAgICAgICAgIHRpY2tzOiB7IHByZWNpc2lvbjogMCB9LFxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICBwbHVnaW5zOiB7XHJcbi8vICAgICAgIGxlZ2VuZDogeyBkaXNwbGF5OiB0cnVlLCBwb3NpdGlvbjogXCJ0b3BcIiB9LFxyXG4vLyAgICAgICB0b29sdGlwOiB7IGVuYWJsZWQ6IHRydWUgfSxcclxuLy8gICAgIH0sXHJcbi8vICAgfSk7XHJcblxyXG4vLyAgIGNvbnN0IHJlbmRlckNoYXJ0ID0gKHR5cGU6IHN0cmluZywgQ2hhcnRDb21wb25lbnQ6IGFueSkgPT4ge1xyXG4vLyAgICAgY29uc3QgZGF0YSA9IGNoYXJ0RGF0YVt0eXBlXTtcclxuLy8gICAgIGlmICghbG9hZGluZyAmJiBkYXRhKSB7XHJcbi8vICAgICAgIHJldHVybiAoXHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkIHAtNCBib3JkZXIgcm91bmRlZCBzaGFkb3ctc21cIj5cclxuLy8gICAgICAgICAgIDxkaXYgc3R5bGU9e3sgd2lkdGg6IFwiMTAwJVwiLCBvdmVyZmxvd1g6IFwiYXV0b1wiIH19PlxyXG4vLyAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IG1pbldpZHRoOiBbXCJsaW5lQ2hhcnREYXRhXCIsIFwiYmFyQ2hhcnREYXRhXCJdLmluY2x1ZGVzKHR5cGUpID8gYCR7Y2hhcnRXaWR0aH1weGAgOiBcImF1dG9cIiwgaGVpZ2h0OiBcIjQwMHB4XCIgfX0+XHJcbi8vICAgICAgICAgICAgICAgPENoYXJ0Q29tcG9uZW50IGRhdGE9e2RhdGF9IG9wdGlvbnM9e2dldENoYXJ0T3B0aW9ucyh0eXBlKX0gLz5cclxuLy8gICAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgKTtcclxuLy8gICAgIH1cclxuLy8gICAgIHJldHVybiBudWxsO1xyXG4vLyAgIH07XHJcbi8vICAgcmV0dXJuIChcclxuLy8gICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBtZDpmbGV4LXJvdyBoLXNjcmVlbiBib3JkZXIgYm9yZGVyLWJsYWNrXCI+XHJcbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMS80IGJnLXdoaXRlIHAtNSBib3JkZXItdCBtZDpib3JkZXItbCBtZDpib3JkZXItYmxhY2tcIj5cclxuLy8gICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPlVwbG9hZCBGaWxlPC9oMj5cclxuLy8gICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIiBvbkNoYW5nZT17aGFuZGxlRmlsZUNoYW5nZX0gY2xhc3NOYW1lPVwiYm9yZGVyIHAtMiB3LWZ1bGxcIiAvPlxyXG4vLyAgICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlU3VibWl0fSBjbGFzc05hbWU9XCJiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlIHAtMiByb3VuZGVkIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG10LTRcIj5cclxuLy8gICAgICAgICAgIDxCc1VwbG9hZCBjbGFzc05hbWU9XCJtci0yXCIgLz4gU3VibWl0XHJcbi8vICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHNwYWNlLXktMiBtdC00XCI+XHJcbi8vICAgICAgICAgICB7W1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiLCBcInNjYXR0ZXJDaGFydERhdGFcIiwgXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5tYXAoKHR5cGUpID0+IChcclxuLy8gICAgICAgICAgICAgPGJ1dHRvbiBrZXk9e3R5cGV9IG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkQ2hhcnQodHlwZSl9IGNsYXNzTmFtZT1cInAtMiBiZy1ncmF5LTMwMCByb3VuZGVkIGhvdmVyOmJnLWdyYXktNDAwXCI+XHJcbi8vICAgICAgICAgICAgICAge3R5cGUucmVwbGFjZShcIkNoYXJ0RGF0YVwiLCBcIiBDaGFydFwiKX1cclxuLy8gICAgICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgICApKX1cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgPC9kaXY+XHJcbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMy80IGJnLWdyYXktMTAwIHAtNSBvdmVyZmxvdy1hdXRvXCI+XHJcbi8vICAgICAgICAge2xvYWRpbmcgPyAoXHJcbi8vICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIGgtZnVsbFwiPlxyXG4vLyAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwaW5uZXItYm9yZGVyIGFuaW1hdGUtc3BpbiBib3JkZXItdC00IGJvcmRlci1ibHVlLTUwMCByb3VuZGVkLWZ1bGwgdy0xMiBoLTEyXCI+PC9kaXY+XHJcbi8vICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICApIDogKFxyXG4vLyAgICAgICAgICAgc2VsZWN0ZWRDaGFydCAmJiByZW5kZXJDaGFydChzZWxlY3RlZENoYXJ0LCB7IGxpbmVDaGFydERhdGE6IExpbmUsIGJhckNoYXJ0RGF0YTogQmFyLCBzY2F0dGVyQ2hhcnREYXRhOiBTY2F0dGVyLCBwaWVDaGFydERhdGE6IFBpZSwgZG9udXRDaGFydERhdGE6IERvdWdobnV0IH1bc2VsZWN0ZWRDaGFydF0pXHJcbi8vICAgICAgICAgKX1cclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTQgZmxleFwiPlxyXG4vLyAgICAgICAgICAgPGlucHV0XHJcbi8vICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcclxuLy8gICAgICAgICAgICAgdmFsdWU9e2lucHV0VmFsdWV9XHJcbi8vICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0SW5wdXRWYWx1ZShlLnRhcmdldC52YWx1ZSl9XHJcbi8vICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJvcmRlciBwLTIgZmxleC1ncm93IG1yLTIgcm91bmRlZFwiXHJcbi8vICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiRW50ZXIgeW91ciB0ZXh0IGhlcmVcIlxyXG4vLyAgICAgICAgICAgLz5cclxuLy8gICAgICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlU2VuZH0gY2xhc3NOYW1lPVwiYmctZ3JlZW4tNTAwIHRleHQtd2hpdGUgcC0yIHJvdW5kZWRcIj5cclxuLy8gICAgICAgICAgICAgU2VuZFxyXG4vLyAgICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC00IHAtNCBib3JkZXIgYm9yZGVyLWdyYXktMzAwIHJvdW5kZWQgYmctd2hpdGVcIj5cclxuLy8gICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPkluc2lnaHRzPC9oMz5cclxuLy8gICAgICAgICB7Y29tYmluZWRJbnNpZ2h0cyA/IChcclxuLy8gICAgICAgICAgICAgPG9sIGNsYXNzTmFtZT1cImxpc3QtZGVjaW1hbCBsaXN0LWluc2lkZSB0ZXh0LXNtIHRleHQtZ3JheS03MDAgYmctZ3JheS0xMDAgcC0yIHJvdW5kZWQgb3ZlcmZsb3ctYXV0b1wiPlxyXG4vLyAgICAgICAgICAgICB7Y29tYmluZWRJbnNpZ2h0cy5zcGxpdCgnXFxuJykubWFwKChpbnNpZ2h0LCBpbmRleCkgPT4gKFxyXG4vLyAgICAgICAgICAgICAgIDx1bCBrZXk9e2luZGV4fT57aW5zaWdodH08L3VsPlxyXG4vLyAgICAgICAgICAgICApKX1cclxuLy8gICAgICAgICAgIDwvb2w+XHJcbi8vICAgICAgICAgKSA6IChcclxuLy8gICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtZ3JheS01MDBcIj5ObyBpbnNpZ2h0cyBhdmFpbGFibGUuPC9wPlxyXG4vLyAgICAgICAgICl9XHJcbi8vICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICA8L2Rpdj5cclxuLy8gICAgIDwvZGl2PlxyXG4vLyAgICk7XHJcbi8vIH1cclxuXHJcbi8vIFwidXNlIGNsaWVudFwiO1xyXG4vLyBpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcclxuLy8gaW1wb3J0IHsgQmFyLCBMaW5lLCBEb3VnaG51dCwgUGllLCBTY2F0dGVyIH0gZnJvbSBcInJlYWN0LWNoYXJ0anMtMlwiO1xyXG4vLyBpbXBvcnQgeyBDaGFydCBhcyBDaGFydEpTLCBDYXRlZ29yeVNjYWxlLCBMaW5lYXJTY2FsZSwgQmFyRWxlbWVudCwgTGluZUVsZW1lbnQsIFBvaW50RWxlbWVudCwgQXJjRWxlbWVudCwgVGl0bGUsIFRvb2x0aXAsIExlZ2VuZCB9IGZyb20gXCJjaGFydC5qc1wiO1xyXG4vLyBpbXBvcnQgeyBCc1VwbG9hZCB9IGZyb20gXCJyZWFjdC1pY29ucy9ic1wiO1xyXG4vLyBpbXBvcnQgem9vbVBsdWdpbiBmcm9tIFwiY2hhcnRqcy1wbHVnaW4tem9vbVwiO1xyXG4vLyBpbXBvcnQgaHRtbDJjYW52YXMgZnJvbSBcImh0bWwyY2FudmFzXCI7XHJcbi8vIGltcG9ydCBqc1BERiBmcm9tIFwianNwZGZcIjtcclxuXHJcbi8vIENoYXJ0SlMucmVnaXN0ZXIoQ2F0ZWdvcnlTY2FsZSwgTGluZWFyU2NhbGUsIEJhckVsZW1lbnQsIExpbmVFbGVtZW50LCBQb2ludEVsZW1lbnQsIEFyY0VsZW1lbnQsIFRpdGxlLCBUb29sdGlwLCBMZWdlbmQsIHpvb21QbHVnaW4pO1xyXG5cclxuLy8gaW50ZXJmYWNlIENoYXJ0RGF0YSB7XHJcbi8vICAgbGFiZWxzOiBzdHJpbmdbXTtcclxuLy8gICBkYXRhc2V0czoge1xyXG4vLyAgICAgbGFiZWw6IHN0cmluZztcclxuLy8gICAgIGRhdGE6IG51bWJlcltdO1xyXG4vLyAgICAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nIHwgc3RyaW5nW107XHJcbi8vICAgICBib3JkZXJDb2xvcj86IHN0cmluZztcclxuLy8gICAgIGZpbGw/OiBib29sZWFuO1xyXG4vLyAgIH1bXVxyXG4vLyAgIG1ldGE/OiB7XHJcbi8vICAgICBoZWFkZXI6IHN0cmluZztcclxuLy8gICAgIHZhbHVlTmFtZTogc3RyaW5nO1xyXG4vLyAgIH07XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhc2hib2FyZCgpIHtcclxuLy8gICBjb25zdCBbY2hhcnREYXRhLCBzZXRDaGFydERhdGFdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgQ2hhcnREYXRhIHwgbnVsbD4+KHtcclxuLy8gICAgIHNjYXR0ZXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBwaWVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBkb251dENoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGxpbmVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBiYXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgfSk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkRmlsZSwgc2V0U2VsZWN0ZWRGaWxlXSA9IHVzZVN0YXRlPEZpbGUgfCBudWxsPihudWxsKTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRDaGFydCwgc2V0U2VsZWN0ZWRDaGFydF0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwibGluZUNoYXJ0RGF0YVwiKTtcclxuLy8gICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcbi8vICAgY29uc3QgW2NoYXJ0V2lkdGgsIHNldENoYXJ0V2lkdGhdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcclxuLy8gICBjb25zdCBbaW5wdXRWYWx1ZSwgc2V0SW5wdXRWYWx1ZV0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiXCIpO1xyXG4vLyAgIGNvbnN0IFtzdG9yZWRQcm9jZXNzZWREYXRhLCBzZXRTdG9yZWRQcm9jZXNzZWREYXRhXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7IC8vIE5ldyBzdGF0ZSB0byBzdG9yZSBwcm9jZXNzZWQgZGF0YVxyXG4vLyAgIGNvbnN0IFtjb21iaW5lZEluc2lnaHRzLCBzZXRDb21iaW5lZEluc2lnaHRzXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7XHJcbi8vICAgY29uc3QgY2hhcnRSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpOyAvLyBSZWYgZm9yIHRoZSBjaGFydCBjb250YWluZXJcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlRmlsZUNoYW5nZSA9IChldmVudDogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcclxuLy8gICAgIHNldFNlbGVjdGVkRmlsZShldmVudC50YXJnZXQuZmlsZXM/LlswXSB8fCBudWxsKTtcclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVTdWJtaXQgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBpZiAoIXNlbGVjdGVkRmlsZSkgcmV0dXJuO1xyXG4vLyAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuXHJcbi8vICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4vLyAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBzZWxlY3RlZEZpbGUpO1xyXG5cclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwOi8vbG9jYWxob3N0OjMwMTIvYXBpL2FuYWx5emUtZXhjZWxcIiwge1xyXG4vLyAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbi8vICAgICAgICAgYm9keTogZm9ybURhdGEsXHJcbi8vICAgICAgIH0pO1xyXG5cclxuLy8gICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGUuXCIpO1xyXG4vLyAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbi8vICAgICAgIGNvbnN0IGNvbWJpbmVkSW5zaWdodHMgPSByZXN1bHQuZGF0YT8uY29tYmluZWRJbnNpZ2h0cztcclxuLy8gICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHJlc3VsdC5kYXRhPy5wcm9jZXNzZWREYXRhO1xyXG5cclxuLy8gICAgICAgaWYgKCFwcm9jZXNzZWREYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZS5cIik7XHJcbi8vIGNvbnNvbGUubG9nKFwicHJvY2Vzc2VkRGF0YVwiLHByb2Nlc3NlZERhdGEpO1xyXG5cclxuLy8gICAgICAgc2V0U3RvcmVkUHJvY2Vzc2VkRGF0YShwcm9jZXNzZWREYXRhKTsgLy8gU3RvcmUgdGhlIHByb2Nlc3NlZCBkYXRhXHJcbi8vICAgICAgIHNldENvbWJpbmVkSW5zaWdodHMoY29tYmluZWRJbnNpZ2h0cyk7XHJcbi8vICAgICAgIGNvbnN0IGxpZ2h0Q29sb3JzID0gW1xyXG4vLyAgICAgICAgIFwicmdiYSgxNzMsIDIxNiwgMjMwLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDE0NCwgMjM4LCAxNDQsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjU1LCAxODIsIDE5MywgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyNTUsIDIyOCwgMTgxLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDIyMSwgMTYwLCAyMjEsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjQwLCAyMzAsIDE0MCwgMC42KVwiLFxyXG4vLyAgICAgICBdO1xyXG5cclxuLy8gICAgICAgY29uc3QgZ2VuZXJhdGVDaGFydERhdGEgPSAoY2hhcnRUeXBlOiBzdHJpbmcpOiBDaGFydERhdGEgfCBudWxsID0+IHtcclxuLy8gICAgICAgICBjb25zdCBjaGFydEluZm8gPSBwcm9jZXNzZWREYXRhW2NoYXJ0VHlwZV0/LlswXTtcclxuLy8gICAgICAgICBpZiAoIWNoYXJ0SW5mbykgcmV0dXJuIG51bGw7XHJcblxyXG4vLyAgICAgICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5rZXlzKGNoYXJ0SW5mby5kYXRhKTtcclxuLy8gICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGNoYXJ0SW5mby5kYXRhKTtcclxuXHJcbi8vICAgICAgICAgc2V0Q2hhcnRXaWR0aChsYWJlbHMubGVuZ3RoICogMTUwKTtcclxuXHJcbi8vICAgICAgICAgcmV0dXJuIHtcclxuLy8gICAgICAgICAgIGxhYmVscyxcclxuLy8gICAgICAgICAgIGRhdGFzZXRzOiBbXHJcbi8vICAgICAgICAgICAgIHtcclxuLy8gICAgICAgICAgICAgICBsYWJlbDogY2hhcnRJbmZvLmxhYmVsIHx8IGNoYXJ0VHlwZSxcclxuLy8gICAgICAgICAgICAgICBkYXRhOiB2YWx1ZXMgYXMgbnVtYmVyW10sXHJcbi8vICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbXCJQaWUgQ2hhcnRcIiwgXCJEb251dCBDaGFydFwiLCBcIkJhciBDaGFydFwiXS5pbmNsdWRlcyhjaGFydFR5cGUpXHJcbi8vICAgICAgICAgICAgICAgICA/IGxpZ2h0Q29sb3JzLnNsaWNlKDAsIGxhYmVscy5sZW5ndGgpXHJcbi8vICAgICAgICAgICAgICAgICA6IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAwLjYpXCIsXHJcbi8vICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIikgPyBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMSlcIiA6IHVuZGVmaW5lZCxcclxuLy8gICAgICAgICAgICAgICBmaWxsOiAhY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIF0sXHJcbi8vICAgICAgICAgICBtZXRhOiB7XHJcbi8vICAgICAgICAgICAgIGhlYWRlcjogY2hhcnRJbmZvLmhlYWRlciB8fCBcImRlZmF1bHRfaGVhZGVyXCIsXHJcbi8vICAgICAgICAgICAgIHZhbHVlTmFtZTogY2hhcnRJbmZvLnZhbHVlTmFtZSB8fCBcImRlZmF1bHRfdmFsdWVOYW1lXCIsXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH07XHJcbi8vICAgICAgIH07XHJcblxyXG4vLyAgICAgICBzZXRDaGFydERhdGEoe1xyXG4vLyAgICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiU2NhdHRlciBQbG90XCIpLFxyXG4vLyAgICAgICAgIHBpZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJQaWUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgZG9udXRDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiRG9udXQgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgbGluZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJMaW5lIENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGJhckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJCYXIgQ2hhcnRcIiksXHJcbi8vICAgICAgIH0pO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlOlwiLCBlcnJvcik7XHJcbi8vICAgICB9IGZpbmFsbHkge1xyXG4vLyAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuLy8gICAgIH1cclxuLy8gICB9O1xyXG5cclxuIFxyXG4vLyAgIGNvbnN0IGhhbmRsZVNlbmQgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBpZiAoIWlucHV0VmFsdWUpIHJldHVybjtcclxuICBcclxuLy8gICAgIGNvbnN0IGdyYXBoRGF0YSA9IGNoYXJ0RGF0YVtzZWxlY3RlZENoYXJ0XTtcclxuLy8gICAgIGlmICghZ3JhcGhEYXRhKSByZXR1cm47XHJcbiAgXHJcbi8vICAgICBjb25zdCBsYWJlbHMgPSBncmFwaERhdGEubGFiZWxzO1xyXG4vLyAgICAgY29uc3QgdmFsdWVzID0gZ3JhcGhEYXRhLmRhdGFzZXRzWzBdLmRhdGE7XHJcbiAgXHJcbi8vICAgICBjb25zdCBkYXRhT2JqZWN0ID0gbGFiZWxzLnJlZHVjZSgob2JqOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9LCBsYWJlbCwgaW5kZXgpID0+IHtcclxuLy8gICAgICAgb2JqW2xhYmVsXSA9IHZhbHVlc1tpbmRleF07XHJcbi8vICAgICAgIHJldHVybiBvYmo7XHJcbi8vICAgICB9LCB7fSk7XHJcbiAgXHJcbi8vICAgICBjb25zdCBjaGFydFR5cGVNYXBwaW5nOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xyXG4vLyAgICAgICBsaW5lQ2hhcnREYXRhOiBcIkxpbmUgQ2hhcnRcIixcclxuLy8gICAgICAgcGllQ2hhcnREYXRhOiBcIlBpZSBDaGFydFwiLFxyXG4vLyAgICAgICBkb251dENoYXJ0RGF0YTogXCJEb251dCBDaGFydFwiLFxyXG4vLyAgICAgICBiYXJDaGFydERhdGE6IFwiQmFyIENoYXJ0XCIsXHJcbi8vICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IFwiU2NhdHRlciBQbG90XCIsXHJcbi8vICAgICB9O1xyXG4gIFxyXG4vLyAgICAgY29uc3Qgc2VsZWN0ZWRDaGFydFR5cGUgPSBjaGFydFR5cGVNYXBwaW5nW3NlbGVjdGVkQ2hhcnRdIHx8IHNlbGVjdGVkQ2hhcnQ7XHJcbiAgXHJcbi8vICAgICAvLyBGaWx0ZXIgdGhlIHN0b3JlZCBwcm9jZXNzZWQgZGF0YSB0byBpbmNsdWRlIG9ubHkgdGhlIHNlbGVjdGVkIGNoYXJ0J3MgZGF0YVxyXG4vLyAgICAgY29uc3QgZmlsdGVyZWRQcm9jZXNzZWREYXRhID0ge1xyXG4vLyAgICAgICBbc2VsZWN0ZWRDaGFydFR5cGVdOiBzdG9yZWRQcm9jZXNzZWREYXRhW3NlbGVjdGVkQ2hhcnRUeXBlXSxcclxuLy8gICAgIH07XHJcbiAgXHJcbi8vICAgICBjb25zb2xlLmxvZyhcIi4uLmZpbHRlcmVkUHJvY2Vzc2VkRGF0YSxcIiwgZmlsdGVyZWRQcm9jZXNzZWREYXRhW3NlbGVjdGVkQ2hhcnRUeXBlXT8uWzBdPy5kYXRhKTtcclxuLy8gICAgIGNvbnNvbGUubG9nKFwiZGF0YU9iamVjdCxcIiwgZGF0YU9iamVjdCk7XHJcbiAgXHJcbi8vICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcclxuLy8gICAgICAgcXVlc3Rpb246IGlucHV0VmFsdWUsXHJcbi8vICAgICAgIHByb2Nlc3NlZERhdGE6IHtcclxuLy8gICAgICAgICAvLyBJbmNsdWRlIHRoZSBzdG9yZWQgcHJvY2Vzc2VkIGRhdGFcclxuLy8gICAgICAgICBbc2VsZWN0ZWRDaGFydFR5cGVdOiBbXHJcbi8vICAgICAgICAgICB7XHJcbi8vICAgICAgICAgICAgIGhlYWRlcjogZ3JhcGhEYXRhLm1ldGE/LmhlYWRlciB8fCBcImRlZmF1bHRfaGVhZGVyXCIsXHJcbi8vICAgICAgICAgICAgIHZhbHVlTmFtZTogZ3JhcGhEYXRhLm1ldGE/LnZhbHVlTmFtZSB8fCBcImRlZmF1bHRfdmFsdWVOYW1lXCIsXHJcbi8vICAgICAgICAgICAgIGxhYmVsOiBncmFwaERhdGEuZGF0YXNldHNbMF0ubGFiZWwsXHJcbi8vICAgICAgICAgICAgIGRhdGE6IGZpbHRlcmVkUHJvY2Vzc2VkRGF0YVtzZWxlY3RlZENoYXJ0VHlwZV0/LlswXT8uZGF0YSxcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgXSxcclxuLy8gICAgICAgfSxcclxuLy8gICAgIH07XHJcbiAgXHJcbi8vICAgICB0cnkge1xyXG4vLyAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxyXG4vLyAgICAgICAgIGBodHRwOi8vbG9jYWxob3N0OjMwMTIvYXBpL2Fuc3dlci1hbmFseXplLWV4Y2VsP3F1ZXN0aW9uPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0VmFsdWUpfWAsXHJcbi8vICAgICAgICAge1xyXG4vLyAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuLy8gICAgICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcclxuLy8gICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KSxcclxuLy8gICAgICAgICB9XHJcbi8vICAgICAgICk7XHJcbiAgXHJcbi8vICAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlLlwiKTtcclxuLy8gICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4vLyAgICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gcmVzdWx0LmRhdGE/LnByb2Nlc3NlZERhdGE7XHJcbiAgXHJcbi8vICAgICAgIGlmICghcHJvY2Vzc2VkRGF0YSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBzdHJ1Y3R1cmUuXCIpO1xyXG4gIFxyXG4vLyAgICAgICBjb25zb2xlLmxvZyhcIlVwZGF0ZWQgQVBJIFJlc3BvbnNlIERhdGE6XCIsIHByb2Nlc3NlZERhdGEpO1xyXG4gIFxyXG4vLyAgICAgICBjb25zdCBnZW5lcmF0ZUNoYXJ0RGF0YSA9IChjaGFydFR5cGU6IHN0cmluZyk6IENoYXJ0RGF0YSB8IG51bGwgPT4ge1xyXG4vLyAgICAgICAgIGNvbnN0IGNoYXJ0SW5mbyA9IHByb2Nlc3NlZERhdGFbY2hhcnRUeXBlXT8uWzBdOyAvLyBVc2Ugb25seSBBUEkgcmVzcG9uc2UgZGF0YVxyXG4vLyAgICAgICAgIGlmICghY2hhcnRJbmZvKSByZXR1cm4gbnVsbDtcclxuICBcclxuLy8gICAgICAgICBjb25zdCBsYWJlbHMgPSBPYmplY3Qua2V5cyhjaGFydEluZm8uZGF0YSk7XHJcbi8vICAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhjaGFydEluZm8uZGF0YSk7XHJcbiAgXHJcbi8vICAgICAgICAgc2V0Q2hhcnRXaWR0aChsYWJlbHMubGVuZ3RoICogMTUwKTtcclxuICBcclxuLy8gICAgICAgICByZXR1cm4ge1xyXG4vLyAgICAgICAgICAgbGFiZWxzLFxyXG4vLyAgICAgICAgICAgZGF0YXNldHM6IFtcclxuLy8gICAgICAgICAgICAge1xyXG4vLyAgICAgICAgICAgICAgIGxhYmVsOiBjaGFydEluZm8ubGFiZWwgfHwgY2hhcnRUeXBlLFxyXG4vLyAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlcyBhcyBudW1iZXJbXSxcclxuLy8gICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcIlBpZSBDaGFydFwiLCBcIkRvbnV0IENoYXJ0XCIsIFwiQmFyIENoYXJ0XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSlcclxuLy8gICAgICAgICAgICAgICAgID8gW1wicmdiYSgxNzMsIDIxNiwgMjMwLCAwLjYpXCIsIFwicmdiYSgxNDQsIDIzOCwgMTQ0LCAwLjYpXCIsIFwicmdiYSgyNTUsIDE4MiwgMTkzLCAwLjYpXCJdXHJcbi8vICAgICAgICAgICAgICAgICA6IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAwLjYpXCIsXHJcbi8vICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIikgPyBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMSlcIiA6IHVuZGVmaW5lZCxcclxuLy8gICAgICAgICAgICAgICBmaWxsOiAhY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIF0sXHJcbi8vICAgICAgICAgICBtZXRhOiB7XHJcbi8vICAgICAgICAgICAgIGhlYWRlcjogY2hhcnRJbmZvLmhlYWRlciB8fCBcImRlZmF1bHRfaGVhZGVyXCIsXHJcbi8vICAgICAgICAgICAgIHZhbHVlTmFtZTogY2hhcnRJbmZvLnZhbHVlTmFtZSB8fCBcImRlZmF1bHRfdmFsdWVOYW1lXCIsXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH07XHJcbi8vICAgICAgIH07XHJcbiAgXHJcbi8vICAgICAgIC8vIE9ubHkgdXBkYXRlIGNoYXJ0RGF0YSB3aXRob3V0IHN0b3JpbmcgaW4gc3RvcmVkUHJvY2Vzc2VkRGF0YVxyXG4vLyAgICAgICBzZXRDaGFydERhdGEoKHByZXZDaGFydERhdGEpID0+ICh7XHJcbi8vICAgICAgICAgLi4ucHJldkNoYXJ0RGF0YSxcclxuLy8gICAgICAgICBbc2VsZWN0ZWRDaGFydF06IGdlbmVyYXRlQ2hhcnREYXRhKHNlbGVjdGVkQ2hhcnRUeXBlKSxcclxuLy8gICAgICAgfSkpO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNlbmRpbmcgcmVxdWVzdDpcIiwgZXJyb3IpO1xyXG4vLyAgICAgfSBmaW5hbGx5IHtcclxuLy8gICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbi8vICAgICB9XHJcbi8vICAgfTtcclxuICBcclxuXHJcbi8vICAgY29uc3QgZ2V0Q2hhcnRPcHRpb25zID0gKHR5cGU6IHN0cmluZykgPT4gKHtcclxuLy8gICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbi8vICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcclxuLy8gICAgIHNjYWxlczogW1wicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSlcclxuLy8gICAgICAgPyB7fVxyXG4vLyAgICAgICA6IHtcclxuLy8gICAgICAgICB4OiB7XHJcbi8vICAgICAgICAgICB0aWNrczoge1xyXG4vLyAgICAgICAgICAgICBhdXRvU2tpcDogZmFsc2UsXHJcbi8vICAgICAgICAgICAgIG1heFJvdGF0aW9uOiB0eXBlID09PSAnYmFyQ2hhcnREYXRhJyB8fCB0eXBlID09PSAnc2NhdHRlckNoYXJ0RGF0YScgPyAyMCA6IDEwMCxcclxuLy8gICAgICAgICBtaW5Sb3RhdGlvbjogdHlwZSA9PT0gJ2JhckNoYXJ0RGF0YScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXJDaGFydERhdGEnID8gMCA6IDkwLFxyXG4vLyAgICAgICAgICAgICBhdXRvU2tpcFBhZGRpbmc6IDIwLFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIGdyaWQ6IHtcclxuLy8gICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgZHJhd1RpY2tzOiBmYWxzZSxcclxuLy8gICAgICAgICAgICAgdGlja0xlbmd0aDogMTAwLFxyXG4vLyAgICAgICAgICAgICBsaW5lV2lkdGg6IDFcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgICAgICB5OiB7XHJcbi8vICAgICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcclxuLy8gICAgICAgICAgIHRpY2tzOiB7IHByZWNpc2lvbjogMCB9LFxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICBwbHVnaW5zOiB7XHJcbi8vICAgICAgIGxlZ2VuZDogeyBkaXNwbGF5OiB0cnVlLCBwb3NpdGlvbjogXCJ0b3BcIiB9LFxyXG4vLyAgICAgICB0b29sdGlwOiB7IGVuYWJsZWQ6IHRydWUgfSxcclxuLy8gICAgIH0sXHJcbi8vICAgfSk7XHJcbi8vICAgY29uc3QgcmVuZGVyQ2hhcnQgPSAodHlwZTogc3RyaW5nLCBDaGFydENvbXBvbmVudDogYW55KSA9PiB7XHJcbi8vICAgICBjb25zdCBkYXRhID0gY2hhcnREYXRhW3R5cGVdO1xyXG4vLyAgICAgaWYgKCFsb2FkaW5nICYmIGRhdGEpIHtcclxuLy8gICAgICAgcmV0dXJuIChcclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQgcC00IGJvcmRlciByb3VuZGVkIHNoYWRvdy1zbVwiPlxyXG4vLyAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogXCIxMDAlXCIsIG92ZXJmbG93WDogXCJhdXRvXCIgfX0+XHJcbi8vICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgbWluV2lkdGg6IFtcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSkgPyBgJHtjaGFydFdpZHRofXB4YCA6IFwiYXV0b1wiLCBoZWlnaHQ6IFwiNDAwcHhcIiB9fT5cclxuLy8gICAgICAgICAgICAgICA8Q2hhcnRDb21wb25lbnQgZGF0YT17ZGF0YX0gb3B0aW9ucz17Z2V0Q2hhcnRPcHRpb25zKHR5cGUpfSAvPlxyXG4vLyAgICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICApO1xyXG4vLyAgICAgfVxyXG4vLyAgICAgcmV0dXJuIG51bGw7XHJcbi8vICAgfTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlRG93bmxvYWRQREYgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBpZiAoIWNoYXJ0UmVmLmN1cnJlbnQpIHJldHVybjtcclxuICBcclxuLy8gICAgIC8vIFRlbXBvcmFyaWx5IHNldCB0aGUgY2hhcnQgY29udGFpbmVyIHRvIGl0cyBmdWxsIGhlaWdodCB0byBjYXB0dXJlIGFsbCBjb250ZW50XHJcbi8vICAgICBjb25zdCBvcmlnaW5hbEhlaWdodCA9IGNoYXJ0UmVmLmN1cnJlbnQuc3R5bGUuaGVpZ2h0O1xyXG4vLyAgICAgY2hhcnRSZWYuY3VycmVudC5zdHlsZS5oZWlnaHQgPSBgJHtjaGFydFJlZi5jdXJyZW50LnNjcm9sbEhlaWdodH1weGA7XHJcbiAgXHJcbi8vICAgICBjb25zdCBjYW52YXMgPSBhd2FpdCBodG1sMmNhbnZhcyhjaGFydFJlZi5jdXJyZW50LCB7XHJcbi8vICAgICAgIHNjcm9sbFg6IDAsXHJcbi8vICAgICAgIHNjcm9sbFk6IC13aW5kb3cuc2Nyb2xsWSxcclxuLy8gICAgICAgd2lkdGg6IGNoYXJ0UmVmLmN1cnJlbnQuc2Nyb2xsV2lkdGgsXHJcbi8vICAgICAgIGhlaWdodDogY2hhcnRSZWYuY3VycmVudC5zY3JvbGxIZWlnaHQsXHJcbi8vICAgICB9KTtcclxuICBcclxuLy8gICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGhlaWdodCBvZiB0aGUgY2hhcnQgY29udGFpbmVyXHJcbi8vICAgICBjaGFydFJlZi5jdXJyZW50LnN0eWxlLmhlaWdodCA9IG9yaWdpbmFsSGVpZ2h0O1xyXG4gIFxyXG4vLyAgICAgY29uc3QgaW1nRGF0YSA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XHJcbi8vICAgICBjb25zdCBwZGYgPSBuZXcganNQREYoXCJsYW5kc2NhcGVcIiwgXCJtbVwiLCBcImE0XCIpO1xyXG4vLyAgICAgY29uc3QgaW1nUHJvcHMgPSBwZGYuZ2V0SW1hZ2VQcm9wZXJ0aWVzKGltZ0RhdGEpO1xyXG4vLyAgICAgY29uc3QgcGRmV2lkdGggPSBwZGYuaW50ZXJuYWwucGFnZVNpemUuZ2V0V2lkdGgoKTtcclxuLy8gICAgIGNvbnN0IHBkZkhlaWdodCA9IChpbWdQcm9wcy5oZWlnaHQgKiBwZGZXaWR0aCkgLyBpbWdQcm9wcy53aWR0aDtcclxuICBcclxuLy8gICAgIHBkZi5hZGRJbWFnZShpbWdEYXRhLCBcIlBOR1wiLCAwLCAwLCBwZGZXaWR0aCwgcGRmSGVpZ2h0KTtcclxuLy8gICAgIHBkZi5zYXZlKFwiY2hhcnQucGRmXCIpO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIHJldHVybiAoXHJcbi8vICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgbWQ6ZmxleC1yb3cgaC1zY3JlZW4gYm9yZGVyIGJvcmRlci1ibGFja1wiPlxyXG4vLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTEvNCBiZy13aGl0ZSBwLTUgYm9yZGVyLXQgbWQ6Ym9yZGVyLWwgbWQ6Ym9yZGVyLWJsYWNrXCI+XHJcbi8vICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5VcGxvYWQgRmlsZTwvaDI+XHJcbi8vICAgICAgICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgb25DaGFuZ2U9e2hhbmRsZUZpbGVDaGFuZ2V9IGNsYXNzTmFtZT1cImJvcmRlciBwLTIgdy1mdWxsXCIgLz5cclxuLy8gICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2hhbmRsZVN1Ym1pdH0gY2xhc3NOYW1lPVwiYmctYmx1ZS01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBtdC00XCI+XHJcbi8vICAgICAgICAgICA8QnNVcGxvYWQgY2xhc3NOYW1lPVwibXItMlwiIC8+IFN1Ym1pdFxyXG4vLyAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBzcGFjZS15LTIgbXQtNFwiPlxyXG4vLyAgICAgICAgICAge1tcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIiwgXCJzY2F0dGVyQ2hhcnREYXRhXCIsIFwicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0ubWFwKCh0eXBlKSA9PiAoXHJcbi8vICAgICAgICAgICAgIDxidXR0b24ga2V5PXt0eXBlfSBvbkNsaWNrPXsoKSA9PiBzZXRTZWxlY3RlZENoYXJ0KHR5cGUpfSBjbGFzc05hbWU9XCJwLTIgYmctZ3JheS0zMDAgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTQwMFwiPlxyXG4vLyAgICAgICAgICAgICAgIHt0eXBlLnJlcGxhY2UoXCJDaGFydERhdGFcIiwgXCIgQ2hhcnRcIil9XHJcbi8vICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgICAgKSl9XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTMvNCBiZy1ncmF5LTEwMCBwLTUgb3ZlcmZsb3ctYXV0b1wiPlxyXG4vLyAgICAgICAgIHtsb2FkaW5nID8gKFxyXG4vLyAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBoLWZ1bGxcIj5cclxuLy8gICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGlubmVyLWJvcmRlciBhbmltYXRlLXNwaW4gYm9yZGVyLXQtNCBib3JkZXItYmx1ZS01MDAgcm91bmRlZC1mdWxsIHctMTIgaC0xMlwiPjwvZGl2PlxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgKSA6IChcclxuLy8gICAgICAgICAgIHNlbGVjdGVkQ2hhcnQgJiYgcmVuZGVyQ2hhcnQoc2VsZWN0ZWRDaGFydCwgeyBsaW5lQ2hhcnREYXRhOiBMaW5lLCBiYXJDaGFydERhdGE6IEJhciwgc2NhdHRlckNoYXJ0RGF0YTogU2NhdHRlciwgcGllQ2hhcnREYXRhOiBQaWUsIGRvbnV0Q2hhcnREYXRhOiBEb3VnaG51dCB9W3NlbGVjdGVkQ2hhcnRdKVxyXG4vLyAgICAgICAgICl9XHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC00IGZsZXhcIj5cclxuLy8gICAgICAgICAgIDxpbnB1dFxyXG4vLyAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXHJcbi8vICAgICAgICAgICAgIHZhbHVlPXtpbnB1dFZhbHVlfVxyXG4vLyAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldElucHV0VmFsdWUoZS50YXJnZXQudmFsdWUpfVxyXG4vLyAgICAgICAgICAgICBjbGFzc05hbWU9XCJib3JkZXIgcC0yIGZsZXgtZ3JvdyBtci0yIHJvdW5kZWRcIlxyXG4vLyAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkVudGVyIHlvdXIgdGV4dCBoZXJlXCJcclxuLy8gICAgICAgICAgIC8+XHJcbi8vICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2hhbmRsZVNlbmR9IGNsYXNzTmFtZT1cImJnLWdyZWVuLTUwMCB0ZXh0LXdoaXRlIHAtMiByb3VuZGVkXCI+XHJcbi8vICAgICAgICAgICAgIFNlbmRcclxuLy8gICAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtNCBwLTQgYm9yZGVyIGJvcmRlci1ncmF5LTMwMCByb3VuZGVkIGJnLXdoaXRlXCI+XHJcbi8vICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPkluc2lnaHRzPC9oMz5cclxuLy8gICAgICAgICAgIHtjb21iaW5lZEluc2lnaHRzID8gKFxyXG4vLyAgICAgICAgICAgICA8b2wgY2xhc3NOYW1lPVwibGlzdC1kZWNpbWFsIGxpc3QtaW5zaWRlIHRleHQtc20gdGV4dC1ncmF5LTcwMCBiZy1ncmF5LTEwMCBwLTIgcm91bmRlZCBvdmVyZmxvdy1hdXRvXCI+XHJcbi8vICAgICAgICAgICAgICAge2NvbWJpbmVkSW5zaWdodHMuc3BsaXQoJ1xcbicpLm1hcCgoaW5zaWdodCwgaW5kZXgpID0+IChcclxuLy8gICAgICAgICAgICAgICAgIDx1bCBrZXk9e2luZGV4fT57aW5zaWdodH08L3VsPlxyXG4vLyAgICAgICAgICAgICAgICkpfVxyXG4vLyAgICAgICAgICAgICA8L29sPlxyXG4vLyAgICAgICAgICAgKSA6IChcclxuLy8gICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTUwMFwiPk5vIGluc2lnaHRzIGF2YWlsYWJsZS48L3A+XHJcbi8vICAgICAgICAgICApfVxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlRG93bmxvYWRQREZ9IGNsYXNzTmFtZT1cImJnLXJlZC01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZCBtdC00XCI+XHJcbi8vICAgICAgICAgICBEb3dubG9hZCBhcyBQREZcclxuLy8gICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgPC9kaXY+XHJcbi8vICAgICA8L2Rpdj5cclxuLy8gICApO1xyXG4vLyB9XHJcblxyXG5cclxuXHJcblwidXNlIGNsaWVudFwiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYsIEF3YWl0ZWRSZWFjdE5vZGUsIEpTWEVsZW1lbnRDb25zdHJ1Y3RvciwgS2V5LCBSZWFjdEVsZW1lbnQsIFJlYWN0Tm9kZSwgUmVhY3RQb3J0YWwgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgQmFyLCBMaW5lLCBEb3VnaG51dCwgUGllLCBTY2F0dGVyIH0gZnJvbSBcInJlYWN0LWNoYXJ0anMtMlwiO1xyXG5pbXBvcnQgeyBDaGFydCBhcyBDaGFydEpTLCBDYXRlZ29yeVNjYWxlLCBMaW5lYXJTY2FsZSwgQmFyRWxlbWVudCwgTGluZUVsZW1lbnQsIFBvaW50RWxlbWVudCwgQXJjRWxlbWVudCwgVGl0bGUsIFRvb2x0aXAsIExlZ2VuZCB9IGZyb20gXCJjaGFydC5qc1wiO1xyXG5pbXBvcnQgeyBCc1VwbG9hZCB9IGZyb20gXCJyZWFjdC1pY29ucy9ic1wiO1xyXG5pbXBvcnQgem9vbVBsdWdpbiBmcm9tIFwiY2hhcnRqcy1wbHVnaW4tem9vbVwiO1xyXG5pbXBvcnQgaHRtbDJjYW52YXMgZnJvbSBcImh0bWwyY2FudmFzXCI7XHJcbmltcG9ydCBqc1BERiBmcm9tIFwianNwZGZcIjtcclxuaW1wb3J0IENoYXJ0IGZyb20gXCJyZWFjdC1hcGV4Y2hhcnRzXCI7XHJcbkNoYXJ0SlMucmVnaXN0ZXIoQ2F0ZWdvcnlTY2FsZSwgTGluZWFyU2NhbGUsIEJhckVsZW1lbnQsIExpbmVFbGVtZW50LCBQb2ludEVsZW1lbnQsIEFyY0VsZW1lbnQsIFRpdGxlLCBUb29sdGlwLCBMZWdlbmQsIHpvb21QbHVnaW4pO1xyXG5cclxuaW50ZXJmYWNlIENoYXJ0RGF0YSB7XHJcbiAgbGFiZWxzOiBzdHJpbmdbXTtcclxuICBkYXRhc2V0czoge1xyXG4gICAgbGFiZWw6IHN0cmluZztcclxuICAgIGRhdGE6IG51bWJlcltdO1xyXG4gICAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nIHwgc3RyaW5nW107XHJcbiAgICBib3JkZXJDb2xvcj86IHN0cmluZztcclxuICAgIGZpbGw/OiBib29sZWFuO1xyXG4gIH1bXVxyXG4gIG1ldGE/OiB7XHJcbiAgICBoZWFkZXI6IHN0cmluZztcclxuICAgIHZhbHVlTmFtZTogc3RyaW5nO1xyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhc2hib2FyZCgpIHtcclxuICBjb25zdCBbY2hhcnREYXRhLCBzZXRDaGFydERhdGFdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgQ2hhcnREYXRhIHwgbnVsbD4+KHtcclxuICAgIHNjYXR0ZXJDaGFydERhdGE6IG51bGwsXHJcbiAgICBwaWVDaGFydERhdGE6IG51bGwsXHJcbiAgICBkb251dENoYXJ0RGF0YTogbnVsbCxcclxuICAgIGxpbmVDaGFydERhdGE6IG51bGwsXHJcbiAgICBiYXJDaGFydERhdGE6IG51bGwsXHJcbiAgfSk7XHJcbiAgY29uc3QgW3NlbGVjdGVkRmlsZSwgc2V0U2VsZWN0ZWRGaWxlXSA9IHVzZVN0YXRlPEZpbGUgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBbc2VsZWN0ZWRDaGFydCwgc2V0U2VsZWN0ZWRDaGFydF0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwibGluZUNoYXJ0RGF0YVwiKTtcclxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcbiAgY29uc3QgW2NoYXJ0V2lkdGgsIHNldENoYXJ0V2lkdGhdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcclxuICBjb25zdCBbaW5wdXRWYWx1ZSwgc2V0SW5wdXRWYWx1ZV0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiXCIpO1xyXG4gIGNvbnN0IFtzdG9yZWRQcm9jZXNzZWREYXRhLCBzZXRTdG9yZWRQcm9jZXNzZWREYXRhXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7IC8vIE5ldyBzdGF0ZSB0byBzdG9yZSBwcm9jZXNzZWQgZGF0YVxyXG4gIGNvbnN0IFtjb21iaW5lZEluc2lnaHRzLCBzZXRDb21iaW5lZEluc2lnaHRzXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7XHJcbiAgY29uc3QgY2hhcnRSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpOyAvLyBSZWYgZm9yIHRoZSBjaGFydCBjb250YWluZXJcclxuXHJcbiAgY29uc3QgaGFuZGxlRmlsZUNoYW5nZSA9IChldmVudDogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcclxuICAgIHNldFNlbGVjdGVkRmlsZShldmVudC50YXJnZXQuZmlsZXM/LlswXSB8fCBudWxsKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVTdWJtaXQgPSBhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAoIXNlbGVjdGVkRmlsZSkgcmV0dXJuO1xyXG4gICAgc2V0TG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4gICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBzZWxlY3RlZEZpbGUpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwOi8vbG9jYWxob3N0OjMwMTIvYXBpL2FuYWx5emUtZXhjZWxcIiwge1xyXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgYm9keTogZm9ybURhdGEsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGUuXCIpO1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIGNvbnN0IGNvbWJpbmVkSW5zaWdodHMgPSByZXN1bHQuZGF0YT8uY29tYmluZWRJbnNpZ2h0cztcclxuICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHJlc3VsdC5kYXRhPy5wcm9jZXNzZWREYXRhO1xyXG5cclxuICAgICAgaWYgKCFwcm9jZXNzZWREYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZS5cIik7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwicHJvY2Vzc2VkRGF0YVwiLCBwcm9jZXNzZWREYXRhKTtcclxuXHJcbiAgICAgIHNldFN0b3JlZFByb2Nlc3NlZERhdGEocHJvY2Vzc2VkRGF0YSk7IC8vIFN0b3JlIHRoZSBwcm9jZXNzZWQgZGF0YVxyXG4gICAgICBzZXRDb21iaW5lZEluc2lnaHRzKGNvbWJpbmVkSW5zaWdodHMpO1xyXG4gICAgICBjb25zdCBsaWdodENvbG9ycyA9IFtcclxuICAgICAgICBcInJnYmEoMTczLCAyMTYsIDIzMCwgMC42KVwiLFxyXG4gICAgICAgIFwicmdiYSgxNDQsIDIzOCwgMTQ0LCAwLjYpXCIsXHJcbiAgICAgICAgXCJyZ2JhKDI1NSwgMTgyLCAxOTMsIDAuNilcIixcclxuICAgICAgICBcInJnYmEoMjU1LCAyMjgsIDE4MSwgMC42KVwiLFxyXG4gICAgICAgIFwicmdiYSgyMjEsIDE2MCwgMjIxLCAwLjYpXCIsXHJcbiAgICAgICAgXCJyZ2JhKDI0MCwgMjMwLCAxNDAsIDAuNilcIixcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGNvbnN0IGdlbmVyYXRlQ2hhcnREYXRhID0gKGNoYXJ0VHlwZTogc3RyaW5nKTogQ2hhcnREYXRhIHwgbnVsbCA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hhcnRJbmZvID0gcHJvY2Vzc2VkRGF0YVtjaGFydFR5cGVdPy5bMF07XHJcbiAgICAgICAgaWYgKCFjaGFydEluZm8pIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBjb25zdCBsYWJlbHMgPSBPYmplY3Qua2V5cyhjaGFydEluZm8uZGF0YSk7XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhjaGFydEluZm8uZGF0YSk7XHJcbmNvbnNvbGUubG9nKFwiY2hhcnRUeXBlXCIsY2hhcnRUeXBlKTtcclxuXHJcbiAgICAgICAgbGV0IGNoYXJ0V2lkdGggPSAwO1xyXG4gICAgICAgIGlmIChbXCJMaW5lIENoYXJ0XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSkpIHtcclxuICAgICAgICAgIGNoYXJ0V2lkdGggPSBsYWJlbHMubGVuZ3RoICogMTUwO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoW1wiQmFyIENoYXJ0XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSkpIHtcclxuICAgICAgICAgIGNoYXJ0V2lkdGggPSBsYWJlbHMubGVuZ3RoICogMTUwOyAvLyBBZGp1c3QgdGhlIHdpZHRoIGZvciBiYXIgY2hhcnRcclxuICAgICAgICB9IFxyXG4gICAgICAgIGVsc2UgaWYgKFtcIlNjYXR0ZXIgUGxvdFwiXS5pbmNsdWRlcyhjaGFydFR5cGUpKSB7XHJcbiAgICAgICAgICBjaGFydFdpZHRoID0gbGFiZWxzLmxlbmd0aCAqIDE1MDsgLy8gQWRqdXN0IHRoZSB3aWR0aCBmb3IgYmFyIGNoYXJ0XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgY2hhcnRXaWR0aCA9IDQwMDsgLy8gRGVmYXVsdCB3aWR0aCBmb3Igb3RoZXIgY2hhcnQgdHlwZXNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldENoYXJ0V2lkdGgoY2hhcnRXaWR0aCk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBsYWJlbHMsXHJcbiAgICAgICAgICBkYXRhc2V0czogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgbGFiZWw6IGNoYXJ0SW5mby5sYWJlbCB8fCBjaGFydFR5cGUsXHJcbiAgICAgICAgICAgICAgZGF0YTogdmFsdWVzIGFzIG51bWJlcltdLFxyXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogW1wiUGllIENoYXJ0XCIsIFwiRG9udXQgQ2hhcnRcIiwgXCJCYXIgQ2hhcnRcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKVxyXG4gICAgICAgICAgICAgICAgPyBsaWdodENvbG9ycy5zbGljZSgwLCBsYWJlbHMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgOiBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMC42KVwiLFxyXG4gICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpID8gXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDEpXCIgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgZmlsbDogIWNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIiksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgICAgbWV0YToge1xyXG4gICAgICAgICAgICBoZWFkZXI6IGNoYXJ0SW5mby5oZWFkZXIgfHwgXCJkZWZhdWx0X2hlYWRlclwiLFxyXG4gICAgICAgICAgICB2YWx1ZU5hbWU6IGNoYXJ0SW5mby52YWx1ZU5hbWUgfHwgXCJkZWZhdWx0X3ZhbHVlTmFtZVwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgc2V0Q2hhcnREYXRhKHtcclxuICAgICAgICBzY2F0dGVyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlNjYXR0ZXIgUGxvdFwiKSxcclxuICAgICAgICBwaWVDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiUGllIENoYXJ0XCIpLFxyXG4gICAgICAgIGRvbnV0Q2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkRvbnV0IENoYXJ0XCIpLFxyXG4gICAgICAgIGxpbmVDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiTGluZSBDaGFydFwiKSxcclxuICAgICAgICBiYXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiQmFyIENoYXJ0XCIpLFxyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZTpcIiwgZXJyb3IpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlU2VuZCA9IGFzeW5jICgpID0+IHtcclxuICAgIGlmICghaW5wdXRWYWx1ZSkgcmV0dXJuO1xyXG4gIFxyXG4gICAgY29uc3QgZ3JhcGhEYXRhID0gY2hhcnREYXRhW3NlbGVjdGVkQ2hhcnRdO1xyXG4gICAgaWYgKCFncmFwaERhdGEpIHJldHVybjtcclxuICBcclxuICAgIGNvbnN0IGxhYmVscyA9IGdyYXBoRGF0YS5sYWJlbHM7XHJcbiAgICBjb25zdCB2YWx1ZXMgPSBncmFwaERhdGEuZGF0YXNldHNbMF0uZGF0YTtcclxuICBcclxuICAgIGNvbnN0IGRhdGFPYmplY3QgPSBsYWJlbHMucmVkdWNlKChvYmo6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0sIGxhYmVsLCBpbmRleCkgPT4ge1xyXG4gICAgICBvYmpbbGFiZWxdID0gdmFsdWVzW2luZGV4XTtcclxuICAgICAgcmV0dXJuIG9iajtcclxuICAgIH0sIHt9KTtcclxuICBcclxuICAgIGNvbnN0IGNoYXJ0VHlwZU1hcHBpbmc6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XHJcbiAgICAgIGxpbmVDaGFydERhdGE6IFwiTGluZSBDaGFydFwiLFxyXG4gICAgICBwaWVDaGFydERhdGE6IFwiUGllIENoYXJ0XCIsXHJcbiAgICAgIGRvbnV0Q2hhcnREYXRhOiBcIkRvbnV0IENoYXJ0XCIsXHJcbiAgICAgIGJhckNoYXJ0RGF0YTogXCJCYXIgQ2hhcnRcIixcclxuICAgICAgc2NhdHRlckNoYXJ0RGF0YTogXCJTY2F0dGVyIFBsb3RcIixcclxuICAgIH07XHJcbiAgXHJcbiAgICBjb25zdCBzZWxlY3RlZENoYXJ0VHlwZSA9IGNoYXJ0VHlwZU1hcHBpbmdbc2VsZWN0ZWRDaGFydF0gfHwgc2VsZWN0ZWRDaGFydDtcclxuICBcclxuICAgIC8vIEZpbHRlciB0aGUgc3RvcmVkIHByb2Nlc3NlZCBkYXRhIHRvIGluY2x1ZGUgb25seSB0aGUgc2VsZWN0ZWQgY2hhcnQncyBkYXRhXHJcbiAgICBjb25zdCBmaWx0ZXJlZFByb2Nlc3NlZERhdGEgPSB7XHJcbiAgICAgIFtzZWxlY3RlZENoYXJ0VHlwZV06IHN0b3JlZFByb2Nlc3NlZERhdGFbc2VsZWN0ZWRDaGFydFR5cGVdLFxyXG4gICAgfTtcclxuICBcclxuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xyXG4gICAgICBxdWVzdGlvbjogaW5wdXRWYWx1ZSxcclxuICAgICAgcHJvY2Vzc2VkRGF0YToge1xyXG4gICAgICAgIC8vIEluY2x1ZGUgdGhlIHN0b3JlZCBwcm9jZXNzZWQgZGF0YVxyXG4gICAgICAgIFtzZWxlY3RlZENoYXJ0VHlwZV06IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgaGVhZGVyOiBncmFwaERhdGEubWV0YT8uaGVhZGVyIHx8IFwiZGVmYXVsdF9oZWFkZXJcIixcclxuICAgICAgICAgICAgdmFsdWVOYW1lOiBncmFwaERhdGEubWV0YT8udmFsdWVOYW1lIHx8IFwiZGVmYXVsdF92YWx1ZU5hbWVcIixcclxuICAgICAgICAgICAgbGFiZWw6IGdyYXBoRGF0YS5kYXRhc2V0c1swXS5sYWJlbCxcclxuICAgICAgICAgICAgZGF0YTogZmlsdGVyZWRQcm9jZXNzZWREYXRhW3NlbGVjdGVkQ2hhcnRUeXBlXT8uWzBdPy5kYXRhLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxyXG4gICAgICAgIGBodHRwOi8vbG9jYWxob3N0OjMwMTIvYXBpL2Fuc3dlci1hbmFseXplLWV4Y2VsP3F1ZXN0aW9uPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0VmFsdWUpfWAsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcclxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KSxcclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcbiAgXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlLlwiKTtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgY29uc29sZS5sb2coXCJyZXN1bHQuZGF0YVwiLHJlc3VsdC5kYXRhLmRhdGEuY29tYmluZWRJbnNpZ2h0cylcclxuICAgICAgc2V0Q29tYmluZWRJbnNpZ2h0cyhyZXN1bHQuZGF0YS5kYXRhLmNvbWJpbmVkSW5zaWdodHMpXHJcbiAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSByZXN1bHQuZGF0YT8ucHJvY2Vzc2VkRGF0YTtcclxuICBcclxuICAgICAgaWYgKCFwcm9jZXNzZWREYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZS5cIik7XHJcbiAgXHJcbiAgICAgIGNvbnN0IGdlbmVyYXRlQ2hhcnREYXRhID0gKGNoYXJ0VHlwZTogc3RyaW5nKTogQ2hhcnREYXRhIHwgbnVsbCA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hhcnRJbmZvID0gcHJvY2Vzc2VkRGF0YVtjaGFydFR5cGVdPy5bMF07IC8vIFVzZSBvbmx5IEFQSSByZXNwb25zZSBkYXRhXHJcbiAgICAgICAgaWYgKCFjaGFydEluZm8pIHJldHVybiBudWxsO1xyXG4gIFxyXG4gICAgICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5rZXlzKGNoYXJ0SW5mby5kYXRhKTtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGNoYXJ0SW5mby5kYXRhKTtcclxuICAgICAgICBsZXQgY2hhcnRXaWR0aCA9IDA7XHJcbiAgICAgICAgaWYgKFtcIkxpbmUgQ2hhcnRcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKSkge1xyXG4gICAgICAgICAgY2hhcnRXaWR0aCA9IGxhYmVscy5sZW5ndGggKiAxNTA7XHJcbiAgICAgICAgfSBlbHNlIGlmIChbXCJCYXIgQ2hhcnRcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKSkge1xyXG4gICAgICAgICAgY2hhcnRXaWR0aCA9IGxhYmVscy5sZW5ndGggKiAxNTA7IC8vIEFkanVzdCB0aGUgd2lkdGggZm9yIGJhciBjaGFydFxyXG4gICAgICAgIH0gXHJcbiAgICAgICAgZWxzZSBpZiAoW1wiU2NhdHRlciBQbG90XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSkpIHtcclxuICAgICAgICAgIGNoYXJ0V2lkdGggPSBsYWJlbHMubGVuZ3RoICogMTUwOyAvLyBBZGp1c3QgdGhlIHdpZHRoIGZvciBiYXIgY2hhcnRcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICBjaGFydFdpZHRoID0gNDAwOyAvLyBEZWZhdWx0IHdpZHRoIGZvciBvdGhlciBjaGFydCB0eXBlc1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRDaGFydFdpZHRoKGNoYXJ0V2lkdGgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBsYWJlbHMsXHJcbiAgICAgICAgICBkYXRhc2V0czogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgbGFiZWw6IGNoYXJ0SW5mby5sYWJlbCB8fCBjaGFydFR5cGUsXHJcbiAgICAgICAgICAgICAgZGF0YTogdmFsdWVzIGFzIG51bWJlcltdLFxyXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogW1wiUGllIENoYXJ0XCIsIFwiRG9udXQgQ2hhcnRcIiwgXCJCYXIgQ2hhcnRcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKVxyXG4gICAgICAgICAgICAgICAgPyBbXCJyZ2JhKDE3MywgMjE2LCAyMzAsIDAuNilcIiwgXCJyZ2JhKDE0NCwgMjM4LCAxNDQsIDAuNilcIiwgXCJyZ2JhKDI1NSwgMTgyLCAxOTMsIDAuNilcIl1cclxuICAgICAgICAgICAgICAgIDogXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDAuNilcIixcclxuICAgICAgICAgICAgICBib3JkZXJDb2xvcjogY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSA/IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAxKVwiIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgIGZpbGw6ICFjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgXSxcclxuICAgICAgICAgIG1ldGE6IHtcclxuICAgICAgICAgICAgaGVhZGVyOiBjaGFydEluZm8uaGVhZGVyIHx8IFwiZGVmYXVsdF9oZWFkZXJcIixcclxuICAgICAgICAgICAgdmFsdWVOYW1lOiBjaGFydEluZm8udmFsdWVOYW1lIHx8IFwiZGVmYXVsdF92YWx1ZU5hbWVcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgfTtcclxuICBcclxuICAgICAgLy8gT25seSB1cGRhdGUgY2hhcnREYXRhIHdpdGhvdXQgc3RvcmluZyBpbiBzdG9yZWRQcm9jZXNzZWREYXRhXHJcbiAgICAgIHNldENoYXJ0RGF0YSgocHJldkNoYXJ0RGF0YSkgPT4gKHtcclxuICAgICAgICAuLi5wcmV2Q2hhcnREYXRhLFxyXG4gICAgICAgIFtzZWxlY3RlZENoYXJ0XTogZ2VuZXJhdGVDaGFydERhdGEoc2VsZWN0ZWRDaGFydFR5cGUpLFxyXG4gICAgICB9KSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2VuZGluZyByZXF1ZXN0OlwiLCBlcnJvcik7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IHJlbmRlckNoYXJ0ID0gKHR5cGU6IHN0cmluZywgQ2hhcnRDb21wb25lbnQ6IGFueSkgPT4ge1xyXG4gICAgY29uc3QgZGF0YSA9IGNoYXJ0RGF0YT8uW3R5cGVdO1xyXG4gIFxyXG4gICAgaWYgKCFsb2FkaW5nICYmIGRhdGEpIHtcclxuICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IGRhdGEubGFiZWxzPy5sZW5ndGggfHwgMDtcclxuICAgICAgY29uc3QgbWF4VGlja3MgPSBNYXRoLmZsb29yKDYwMCAvIDMwKTsgLy8gQXBwcm94IDMwcHggcGVyIHZlcnRpY2FsIGxhYmVsXHJcbiAgXHJcbiAgICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgb3ZlcmZsb3cteC1hdXRvIG92ZXJmbG93LXktaGlkZGVuIGJnLXdoaXRlIHAtNCByb3VuZGVkLWxnIHNoYWRvd1wiPlxyXG4gICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgICBtaW5XaWR0aDogW1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKVxyXG4gICAgICAgICAgICAgICAgPyBNYXRoLm1heCg2MDAsIGRhdGFMZW5ndGggKiAzMCkgKyBcInB4XCJcclxuICAgICAgICAgICAgICAgIDogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgaGVpZ2h0OiBcIjQwMHB4XCIsXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInJlbGF0aXZlXCJcclxuICAgICAgICAgID5cclxuICAgICAgICAgICAgPENoYXJ0Q29tcG9uZW50XHJcbiAgICAgICAgICAgICAgZGF0YT17ZGF0YX1cclxuICAgICAgICAgICAgICBvcHRpb25zPXt7XHJcbiAgICAgICAgICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzY2FsZXM6IHtcclxuICAgICAgICAgICAgICAgICAgeDoge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbjogMCxcclxuICAgICAgICAgICAgICAgICAgICB0aWNrczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgYXV0b1NraXA6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgbWF4VGlja3NMaW1pdDogbWF4VGlja3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICBtYXhSb3RhdGlvbjogOTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICBtaW5Sb3RhdGlvbjogOTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAxMCwgLy8gSW5jcmVhc2VkIHBhZGRpbmcgZm9yIGJldHRlciBzcGFjaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICBmb250OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDEyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgIGFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBsYXN0IGxhYmVscyBkb24ndCBvdmVybGFwXHJcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oX3ZhbHVlOiBzdHJpbmcgfCBudW1iZXIsIGluZGV4OiBudW1iZXIsIHZhbHVlczogYW55W10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCByZW5kZXJpbmcgaWYgdG9vIGNsb3NlIHRvIHRoZSBlbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSB2YWx1ZXMubGVuZ3RoIC0gMSAmJiBkYXRhTGVuZ3RoID4gbWF4VGlja3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gSGlkZSBsYXN0IGxhYmVsIGlmIGl0IG1pZ2h0IG92ZXJsYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGdyaWQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIHk6IHtcclxuICAgICAgICAgICAgICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwbHVnaW5zOiB7XHJcbiAgICAgICAgICAgICAgICAgIGxlZ2VuZDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwidG9wXCIsXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIHRvb2x0aXA6IHtcclxuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogJ2luZGV4JyxcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBsYXlvdXQ6IHtcclxuICAgICAgICAgICAgICAgICAgcGFkZGluZzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDMwLCAgLy8gSW5jcmVhc2VkIHRvIHByZXZlbnQgbGVmdCBlZGdlIG92ZXJsYXBcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogMzAsIC8vIEluY3JlYXNlZCB0byBwcmV2ZW50IHJpZ2h0IGVkZ2Ugb3ZlcmxhcFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogNDAsIC8vIEluY3JlYXNlZCBmb3IgdmVydGljYWwgbGFiZWxzXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH07XHJcblxyXG5cclxuICBcclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHctZnVsbCBtZDpmbGV4LXJvdyBoLXNjcmVlbiBib3JkZXIgYm9yZGVyLWJsYWNrXCI+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMS80IGJnLXdoaXRlIHAtNSBib3JkZXItdCBtZDpib3JkZXItbCBtZDpib3JkZXItYmxhY2tcIj5cclxuICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPlVwbG9hZCBGaWxlPC9oMj5cclxuICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIiBvbkNoYW5nZT17aGFuZGxlRmlsZUNoYW5nZX0gY2xhc3NOYW1lPVwiYm9yZGVyIHAtMiB3LWZ1bGxcIiAvPlxyXG4gICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlU3VibWl0fSBjbGFzc05hbWU9XCJiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlIHAtMiByb3VuZGVkIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG10LTRcIj5cclxuICAgICAgICAgIDxCc1VwbG9hZCBjbGFzc05hbWU9XCJtci0yXCIgLz4gU3VibWl0XHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHNwYWNlLXktMiBtdC00XCI+XHJcbiAgICAgICAgICB7W1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiLCBcInNjYXR0ZXJDaGFydERhdGFcIiwgXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5tYXAoKHR5cGUpID0+IChcclxuICAgICAgICAgICAgPGJ1dHRvbiBrZXk9e3R5cGV9IG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkQ2hhcnQodHlwZSl9IGNsYXNzTmFtZT1cInAtMiBiZy1ncmF5LTMwMCByb3VuZGVkIGhvdmVyOmJnLWdyYXktNDAwXCI+XHJcbiAgICAgICAgICAgICAge3R5cGUucmVwbGFjZShcIkNoYXJ0RGF0YVwiLCBcIiBDaGFydFwiKX1cclxuICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICApKX1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMy80IGJnLWdyYXktMTAwIHAtNVwiPlxyXG4gIHtsb2FkaW5nID8gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBoLWZ1bGxcIj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGlubmVyLWJvcmRlciBhbmltYXRlLXNwaW4gYm9yZGVyLXQtNCBib3JkZXItYmx1ZS01MDAgcm91bmRlZC1mdWxsIHctMTIgaC0xMlwiPjwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgKSA6IChcclxuICAgIHNlbGVjdGVkQ2hhcnQgJiYgcmVuZGVyQ2hhcnQoc2VsZWN0ZWRDaGFydCwgeyBcclxuICAgICAgbGluZUNoYXJ0RGF0YTogTGluZSwgXHJcbiAgICAgIGJhckNoYXJ0RGF0YTogQmFyLCBcclxuICAgICAgc2NhdHRlckNoYXJ0RGF0YTogU2NhdHRlciwgXHJcbiAgICAgIHBpZUNoYXJ0RGF0YTogUGllLCBcclxuICAgICAgZG9udXRDaGFydERhdGE6IERvdWdobnV0IFxyXG4gICAgfVtzZWxlY3RlZENoYXJ0XSlcclxuICApfVxyXG4gIDxkaXYgY2xhc3NOYW1lPVwibXQtNCBmbGV4XCI+XHJcbiAgICA8aW5wdXRcclxuICAgICAgdHlwZT1cInRleHRcIlxyXG4gICAgICB2YWx1ZT17aW5wdXRWYWx1ZX1cclxuICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRJbnB1dFZhbHVlKGUudGFyZ2V0LnZhbHVlKX1cclxuICAgICAgY2xhc3NOYW1lPVwiYm9yZGVyIHAtMiBmbGV4LWdyb3cgbXItMiByb3VuZGVkXCJcclxuICAgICAgcGxhY2Vob2xkZXI9XCJFbnRlciB5b3VyIHRleHQgaGVyZVwiXHJcbiAgICAvPlxyXG4gICAgPGJ1dHRvbiBvbkNsaWNrPXtoYW5kbGVTZW5kfSBjbGFzc05hbWU9XCJiZy1ncmVlbi01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZFwiPlxyXG4gICAgICBTZW5kXHJcbiAgICA8L2J1dHRvbj5cclxuICA8L2Rpdj5cclxuICA8ZGl2IGNsYXNzTmFtZT1cIm10LTQgcC00IGJvcmRlciBib3JkZXItZ3JheS0zMDAgcm91bmRlZCBiZy13aGl0ZVwiPlxyXG4gICAgPGgzIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5JbnNpZ2h0czwvaDM+XHJcbiAgICB7Y29tYmluZWRJbnNpZ2h0cyA/IChcclxuICAgICAgPG9sIGNsYXNzTmFtZT1cImxpc3QtZGVjaW1hbCBsaXN0LWluc2lkZSB0ZXh0LXNtIHRleHQtZ3JheS03MDAgYmctZ3JheS0xMDAgcC0yIHJvdW5kZWQgbWF4LWgtNjAgb3ZlcmZsb3cteS1hdXRvXCI+XHJcbiAgICAgICAge2NvbWJpbmVkSW5zaWdodHMuc3BsaXQoJ1xcbicpLm1hcCgoaW5zaWdodDogc3RyaW5nIHwgbnVtYmVyIHwgYmlnaW50IHwgYm9vbGVhbiB8IFJlYWN0RWxlbWVudDxhbnksIHN0cmluZyB8IEpTWEVsZW1lbnRDb25zdHJ1Y3Rvcjxhbnk+PiB8IEl0ZXJhYmxlPFJlYWN0Tm9kZT4gfCBSZWFjdFBvcnRhbCB8IFByb21pc2U8QXdhaXRlZFJlYWN0Tm9kZT4gfCBudWxsIHwgdW5kZWZpbmVkLCBpbmRleDogS2V5IHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gKFxyXG4gICAgICAgICAgPGxpIGtleT17aW5kZXh9IGNsYXNzTmFtZT1cInB5LTFcIj57aW5zaWdodH08L2xpPlxyXG4gICAgICAgICkpfVxyXG4gICAgICA8L29sPlxyXG4gICAgKSA6IChcclxuICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTUwMFwiPk5vIGluc2lnaHRzIGF2YWlsYWJsZS48L3A+XHJcbiAgICApfVxyXG4gIDwvZGl2PlxyXG48L2Rpdj5cclxuXHJcbjxzdHlsZSBqc3g+e2BcclxuICAub3ZlcmZsb3cteC1hdXRvIHtcclxuICAgIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcclxuICAgIHNjcm9sbGJhci13aWR0aDogdGhpbjtcclxuICAgIHNjcm9sbGJhci1jb2xvcjogIzg4OCAjZjFmMWYxO1xyXG4gIH1cclxuXHJcbiAgLm92ZXJmbG93LXgtYXV0bzo6LXdlYmtpdC1zY3JvbGxiYXIge1xyXG4gICAgaGVpZ2h0OiA4cHg7XHJcbiAgfVxyXG5cclxuICAub3ZlcmZsb3cteC1hdXRvOjotd2Via2l0LXNjcm9sbGJhci10aHVtYiB7XHJcbiAgICBiYWNrZ3JvdW5kOiAjODg4O1xyXG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xyXG4gIH1cclxuXHJcbiAgLm92ZXJmbG93LXgtYXV0bzo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2sge1xyXG4gICAgYmFja2dyb3VuZDogI2YxZjFmMTtcclxuICB9XHJcblxyXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA3NjhweCkge1xyXG4gICAgLm92ZXJmbG93LXgtYXV0byA+IGRpdiB7XHJcbiAgICAgIG1pbi13aWR0aDogNDAwcHg7XHJcbiAgICAgIGhlaWdodDogMzAwcHg7XHJcbiAgICB9XHJcbiAgfVxyXG5gfTwvc3R5bGU+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlUmVmIiwiQmFyIiwiTGluZSIsIkRvdWdobnV0IiwiUGllIiwiU2NhdHRlciIsIkNoYXJ0IiwiQ2hhcnRKUyIsIkNhdGVnb3J5U2NhbGUiLCJMaW5lYXJTY2FsZSIsIkJhckVsZW1lbnQiLCJMaW5lRWxlbWVudCIsIlBvaW50RWxlbWVudCIsIkFyY0VsZW1lbnQiLCJUaXRsZSIsIlRvb2x0aXAiLCJMZWdlbmQiLCJCc1VwbG9hZCIsInpvb21QbHVnaW4iLCJyZWdpc3RlciIsIkRhc2hib2FyZCIsImNoYXJ0RGF0YSIsInNldENoYXJ0RGF0YSIsInNjYXR0ZXJDaGFydERhdGEiLCJwaWVDaGFydERhdGEiLCJkb251dENoYXJ0RGF0YSIsImxpbmVDaGFydERhdGEiLCJiYXJDaGFydERhdGEiLCJzZWxlY3RlZEZpbGUiLCJzZXRTZWxlY3RlZEZpbGUiLCJzZWxlY3RlZENoYXJ0Iiwic2V0U2VsZWN0ZWRDaGFydCIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiY2hhcnRXaWR0aCIsInNldENoYXJ0V2lkdGgiLCJpbnB1dFZhbHVlIiwic2V0SW5wdXRWYWx1ZSIsInN0b3JlZFByb2Nlc3NlZERhdGEiLCJzZXRTdG9yZWRQcm9jZXNzZWREYXRhIiwiY29tYmluZWRJbnNpZ2h0cyIsInNldENvbWJpbmVkSW5zaWdodHMiLCJjaGFydFJlZiIsImhhbmRsZUZpbGVDaGFuZ2UiLCJldmVudCIsInRhcmdldCIsImZpbGVzIiwiaGFuZGxlU3VibWl0IiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImFwcGVuZCIsInJlc3VsdCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJib2R5Iiwib2siLCJFcnJvciIsImpzb24iLCJkYXRhIiwicHJvY2Vzc2VkRGF0YSIsImNvbnNvbGUiLCJsb2ciLCJsaWdodENvbG9ycyIsImdlbmVyYXRlQ2hhcnREYXRhIiwiY2hhcnRUeXBlIiwiY2hhcnRJbmZvIiwibGFiZWxzIiwiT2JqZWN0Iiwia2V5cyIsInZhbHVlcyIsImluY2x1ZGVzIiwibGVuZ3RoIiwiZGF0YXNldHMiLCJsYWJlbCIsImJhY2tncm91bmRDb2xvciIsInNsaWNlIiwiYm9yZGVyQ29sb3IiLCJ1bmRlZmluZWQiLCJmaWxsIiwibWV0YSIsImhlYWRlciIsInZhbHVlTmFtZSIsImVycm9yIiwiaGFuZGxlU2VuZCIsImdyYXBoRGF0YSIsImZpbHRlcmVkUHJvY2Vzc2VkRGF0YSIsImRhdGFPYmplY3QiLCJyZWR1Y2UiLCJvYmoiLCJpbmRleCIsImNoYXJ0VHlwZU1hcHBpbmciLCJzZWxlY3RlZENoYXJ0VHlwZSIsInJlcXVlc3RCb2R5IiwicXVlc3Rpb24iLCJlbmNvZGVVUklDb21wb25lbnQiLCJoZWFkZXJzIiwiSlNPTiIsInN0cmluZ2lmeSIsInByZXZDaGFydERhdGEiLCJyZW5kZXJDaGFydCIsInR5cGUiLCJDaGFydENvbXBvbmVudCIsImRhdGFMZW5ndGgiLCJtYXhUaWNrcyIsIk1hdGgiLCJmbG9vciIsImRpdiIsImNsYXNzTmFtZSIsInN0eWxlIiwid2lkdGgiLCJtaW5XaWR0aCIsIm1heCIsImhlaWdodCIsIm9wdGlvbnMiLCJyZXNwb25zaXZlIiwibWFpbnRhaW5Bc3BlY3RSYXRpbyIsInNjYWxlcyIsIngiLCJtaW4iLCJ0aWNrcyIsImF1dG9Ta2lwIiwibWF4VGlja3NMaW1pdCIsIm1heFJvdGF0aW9uIiwibWluUm90YXRpb24iLCJwYWRkaW5nIiwiZm9udCIsInNpemUiLCJhbGlnbiIsImNhbGxiYWNrIiwiX3ZhbHVlIiwiZ3JpZCIsImRpc3BsYXkiLCJ5IiwiYmVnaW5BdFplcm8iLCJwbHVnaW5zIiwibGVnZW5kIiwicG9zaXRpb24iLCJ0b29sdGlwIiwiZW5hYmxlZCIsImludGVyc2VjdCIsIm1vZGUiLCJsYXlvdXQiLCJsZWZ0IiwicmlnaHQiLCJib3R0b20iLCJoMiIsImlucHV0Iiwib25DaGFuZ2UiLCJidXR0b24iLCJvbkNsaWNrIiwibWFwIiwicmVwbGFjZSIsInZhbHVlIiwiZSIsInBsYWNlaG9sZGVyIiwiaDMiLCJvbCIsInNwbGl0IiwiaW5zaWdodCIsImxpIiwicCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/pages/Upload/Upload.tsx\n"));

/***/ })

});