"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/app/pages/Upload/Upload.tsx":
/*!*****************************************!*\
  !*** ./src/app/pages/Upload/Upload.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Dashboard)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_chartjs_2__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-chartjs-2 */ \"(app-pages-browser)/./node_modules/react-chartjs-2/dist/index.js\");\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! chart.js */ \"(app-pages-browser)/./node_modules/chart.js/dist/chart.js\");\n/* harmony import */ var _barrel_optimize_names_BsUpload_react_icons_bs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=BsUpload!=!react-icons/bs */ \"(app-pages-browser)/./node_modules/react-icons/bs/index.mjs\");\n/* harmony import */ var chartjs_plugin_zoom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! chartjs-plugin-zoom */ \"(app-pages-browser)/./node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js\");\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n// } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// ChartJS.register(\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n//   zoomPlugin\n// );\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string;\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[];\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const [selectedLabels, setSelectedLabels] = useState<string[]>([]);\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: chartType.includes(\"Bar\")\n//                 ? \"rgba(54, 162, 235, 0.5)\"\n//                 : \"rgba(255, 99, 132, 0.5)\",\n//               borderColor: chartType.includes(\"Line\")\n//                 ? \"rgba(255, 99, 132, 1)\"\n//                 : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   useEffect(() => {\n//     if (selectedChart && chartData[selectedChart]) {\n//       const baseLabels = chartData[selectedChart]?.labels || [];\n//       setChartWidth((selectedLabels.length || baseLabels.length) * 150);\n//     }\n//   }, [selectedChart, selectedLabels, chartData]);\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//           x: {\n//             ticks: {\n//               autoSkip: false,\n//               maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//               minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//               autoSkipPadding: 20,\n//             },\n//             grid: {\n//               display: true,\n//               drawTicks: false,\n//               tickLength: 100,\n//               lineWidth: 1\n//             },\n//           },\n//           y: {\n//             beginAtZero: true,\n//             ticks: {\n//               precision: 0,\n//             },\n//           },\n//         },\n//     plugins: {\n//       legend: {\n//         display: true,\n//         position: \"top\",\n//       },\n//       tooltip: {\n//         enabled: true,\n//       },\n//     },\n//   });\n//   const applyFilter = (data: ChartData | null) => {\n//     if (!data) return data;\n//     const filteredLabels = selectedLabels.length\n//       ? data.labels.filter(label => selectedLabels.includes(label))\n//       : data.labels;\n//     const filteredData = data.datasets.map(dataset => ({\n//       ...dataset,\n//       data: filteredLabels.map(label => dataset.data[data.labels.indexOf(label)])\n//     }));\n//     return {\n//       labels: filteredLabels,\n//       datasets: filteredData,\n//     };\n//   };\n//   const handleCheckboxChange = (label: string) => {\n//     setSelectedLabels(prev =>\n//       prev.includes(label)\n//         ? prev.filter(item => item !== label)\n//         : [...prev, label]\n//     );\n//   };\n//   const handleSelectAll = () => {\n//     if (selectedChart && chartData[selectedChart]) {\n//       setSelectedLabels(chartData[selectedChart]?.labels || []);\n//     }\n//   };\n//   const handleClearAll = () => {\n//     setSelectedLabels([]);\n//   };\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = applyFilter(chartData[type]);\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div\n//               style={{\n//                 minWidth: [\"lineChartData\", \"barChartData\"].includes(type)\n//                   ? `${chartWidth}px`\n//                   : \"auto\",\n//                 height: \"400px\",\n//               }}\n//             >\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button\n//           onClick={handleSubmit}\n//           className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\"\n//         >\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         {selectedChart && (\n//           <div className=\"mt-4\">\n//             <h3 className=\"font-semibold\">Filters</h3>\n//             <button onClick={handleSelectAll} className=\"bg-green-500 text-white px-2 py-1 rounded mt-2\">Select All</button>\n//             <button onClick={handleClearAll} className=\"bg-red-500 text-white px-2 py-1 rounded mt-2 ml-2\">Clear All</button>\n//             {chartData[selectedChart]?.labels.map(label => (\n//               <div key={label} className=\"flex items-center\">\n//                 <input\n//                   type=\"checkbox\"\n//                   checked={selectedLabels.includes(label)}\n//                   onChange={() => handleCheckboxChange(label)}\n//                 />\n//                 <label className=\"ml-2\">{label}</label>\n//               </div>\n//             ))}\n//           </div>\n//         )}\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map(\n//             (type) => (\n//               <button\n//                 key={type}\n//                 onClick={() => {\n//                   setSelectedChart(type);\n//                   setSelectedLabels([]);\n//                 }}\n//                 className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\"\n//               >\n//                 {type.replace(\"ChartData\", \" Chart\")}\n//               </button>\n//             )\n//           )}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           renderChart(selectedChart, {\n//             lineChartData: Line,\n//             barChartData: Bar,\n//             scatterChartData: Scatter,\n//             pieChartData: Pie,\n//             donutChartData: Doughnut,\n//           }[selectedChart])\n//         )}\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n// } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// import { log } from \"node:console\";\n// ChartJS.register(\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n//   zoomPlugin\n// );\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string;\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[];\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n// console.log(\"processedData\",processedData);\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//  console.log(\"labels.length \",chartType,labels.length );\n//  console.log(\"values.length \",chartType,values.length );\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: chartType.includes(\"Bar\")\n//                 ? \"rgba(54, 162, 235, 0.5)\"\n//                 : \"rgba(255, 99, 132, 0.5)\",\n//               borderColor: chartType.includes(\"Line\")\n//                 ? \"rgba(255, 99, 132, 1)\"\n//                 : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//         };\n//       };\n// console.log(\"generateChartData\",generateChartData);\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//         x: {\n//           ticks: {\n//             autoSkip: false,\n//             maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//         minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//             autoSkipPadding: 20,\n//           },\n//           grid: {\n//             display: true,\n//             drawTicks: false,\n//             tickLength: 100,\n//             lineWidth: 1\n//           },\n//         },\n//           y: {\n//             beginAtZero: true,\n//             ticks: {\n//               precision: 0,\n//             },\n//           },\n//         },\n//     plugins: {\n//       legend: {\n//         display: true,\n//         position: \"top\",\n//       },\n//       tooltip: {\n//         enabled: true,\n//       },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div\n//               style={{\n//                 minWidth: [\"lineChartData\", \"barChartData\"].includes(type)\n//                   ? `${chartWidth}px`\n//                   : \"auto\",\n//                 height: \"400px\",\n//               }}\n//             >\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button\n//           onClick={handleSubmit}\n//           className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\"\n//         >\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map(\n//             (type) => (\n//               <button\n//                 key={type}\n//                 onClick={() => setSelectedChart(type)}\n//                 className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\"\n//               >\n//                 {type.replace(\"ChartData\", \" Chart\")}\n//               </button>\n//             )\n//           )}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           renderChart(selectedChart, {\n//             lineChartData: Line,\n//             barChartData: Bar,\n//             scatterChartData: Scatter,\n//             pieChartData: Pie,\n//             donutChartData: Doughnut,\n//           }[selectedChart])\n//         )}\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n// } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// import { log } from \"node:console\";\n// ChartJS.register(\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n//   zoomPlugin\n// );\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string | string[];\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[];\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       const lightColors = [\n//         \"rgba(173, 216, 230, 0.6)\",\n//         \"rgba(144, 238, 144, 0.6)\",\n//         \"rgba(255, 182, 193, 0.6)\",\n//         \"rgba(255, 228, 181, 0.6)\",\n//         \"rgba(221, 160, 221, 0.6)\",\n//         \"rgba(240, 230, 140, 0.6)\",\n//       ];\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? lightColors.slice(0, labels.length)\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\")\n//                 ? \"rgba(135, 206, 250, 1)\"\n//                 : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n// x: {\n//   ticks: {\n//     autoSkip: false,\n//     maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n// minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//     autoSkipPadding: 20,\n//   },\n//   grid: {\n//     display: true,\n//     drawTicks: false,\n//     tickLength: 100,\n//     lineWidth: 1\n//   },\n// },\n//           y: {\n//             beginAtZero: true,\n//             ticks: {\n//               precision: 0,\n//             },\n//           },\n//         },\n//     plugins: {\n//       legend: {\n//         display: true,\n//         position: \"top\",\n//       },\n//       tooltip: {\n//         enabled: true,\n//       },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div\n//               style={{\n//                 minWidth: [\"lineChartData\", \"barChartData\"].includes(type)\n//                   ? `${chartWidth}px`\n//                   : \"auto\",\n//                 height: \"400px\",\n//               }}\n//             >\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button\n//           onClick={handleSubmit}\n//           className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\"\n//         >\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map(\n//             (type) => (\n//               <button\n//                 key={type}\n//                 onClick={() => setSelectedChart(type)}\n//                 className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\"\n//               >\n//                 {type.replace(\"ChartData\", \" Chart\")}\n//               </button>\n//             )\n//           )}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           renderChart(selectedChart, {\n//             lineChartData: Line,\n//             barChartData: Bar,\n//             scatterChartData: Scatter,\n//             pieChartData: Pie,\n//             donutChartData: Doughnut,\n//           }[selectedChart])\n//         )}\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n// } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// ChartJS.register(\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n//   zoomPlugin\n// );\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string | string[];\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[];\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const [inputValue, setInputValue] = useState<string>(\"\");\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       const lightColors = [\n//         \"rgba(173, 216, 230, 0.6)\",\n//         \"rgba(144, 238, 144, 0.6)\",\n//         \"rgba(255, 182, 193, 0.6)\",\n//         \"rgba(255, 228, 181, 0.6)\",\n//         \"rgba(221, 160, 221, 0.6)\",\n//         \"rgba(240, 230, 140, 0.6)\",\n//       ];\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? lightColors.slice(0, labels.length)\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\")\n//                 ? \"rgba(135, 206, 250, 1)\"\n//                 : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const handleSend = () => {\n//     console.log(\"Input Value:\", inputValue);\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//         x: {\n//           ticks: {\n//             autoSkip: false,\n//             maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//         minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//             autoSkipPadding: 20,\n//           },\n//           grid: {\n//             display: true,\n//             drawTicks: false,\n//             tickLength: 100,\n//             lineWidth: 1\n//           },\n//         },\n//           y: {\n//             beginAtZero: true,\n//             ticks: {\n//               precision: 0,\n//             },\n//           },\n//         },\n//     plugins: {\n//       legend: {\n//         display: true,\n//         position: \"top\",\n//       },\n//       tooltip: {\n//         enabled: true,\n//       },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div\n//               style={{\n//                 minWidth: [\"lineChartData\", \"barChartData\"].includes(type)\n//                   ? `${chartWidth}px`\n//                   : \"auto\",\n//                 height: \"400px\",\n//               }}\n//             >\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button\n//           onClick={handleSubmit}\n//           className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\"\n//         >\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map(\n//             (type) => (\n//               <button\n//                 key={type}\n//                 onClick={() => setSelectedChart(type)}\n//                 className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\"\n//               >\n//                 {type.replace(\"ChartData\", \" Chart\")}\n//               </button>\n//             )\n//           )}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           renderChart(selectedChart, {\n//             lineChartData: Line,\n//             barChartData: Bar,\n//             scatterChartData: Scatter,\n//             pieChartData: Pie,\n//             donutChartData: Doughnut,\n//           }[selectedChart])\n//         )}\n//         <div className=\"mt-4 flex\">\n//           <input\n//             type=\"text\"\n//             value={inputValue}\n//             onChange={(e) => setInputValue(e.target.value)}\n//             className=\"border p-2 flex-grow mr-2 rounded\"\n//             placeholder=\"Enter your text here\"\n//           />\n//           <button\n//             onClick={handleSend}\n//             className=\"bg-green-500 text-white p-2 rounded\"\n//           >\n//             Send\n//           </button>\n//         </div>\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import { Chart as ChartJS, CategoryScale, LinearScale, BarElement, LineElement, PointElement, ArcElement, Title, Tooltip, Legend } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// ChartJS.register(CategoryScale, LinearScale, BarElement, LineElement, PointElement, ArcElement, Title, Tooltip, Legend, zoomPlugin);\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string | string[];\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[]\n//   meta?: {\n//     header: string;\n//     valueName: string;\n//   };\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const [inputValue, setInputValue] = useState<string>(\"\");\n//   const [storedProcessedData, setStoredProcessedData] = useState<any>(null); // New state to store processed data\n//   const [combinedInsights, setCombinedInsights] = useState<any>(null);\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const combinedInsights = result.data?.combinedInsights;\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n// console.log(\"processedData\",processedData);\n//       setStoredProcessedData(processedData); // Store the processed data\n//       setCombinedInsights(combinedInsights);\n//       const lightColors = [\n//         \"rgba(173, 216, 230, 0.6)\",\n//         \"rgba(144, 238, 144, 0.6)\",\n//         \"rgba(255, 182, 193, 0.6)\",\n//         \"rgba(255, 228, 181, 0.6)\",\n//         \"rgba(221, 160, 221, 0.6)\",\n//         \"rgba(240, 230, 140, 0.6)\",\n//       ];\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? lightColors.slice(0, labels.length)\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//           meta: {\n//             header: chartInfo.header || \"default_header\",\n//             valueName: chartInfo.valueName || \"default_valueName\",\n//           },\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const handleSend = async () => {\n//     if (!inputValue) return;\n//     const graphData = chartData[selectedChart];\n//     if (!graphData) return;\n//     const labels = graphData.labels;\n//     const values = graphData.datasets[0].data;\n//     const dataObject = labels.reduce((obj: { [key: string]: number }, label, index) => {\n//       obj[label] = values[index];\n//       return obj;\n//     }, {});\n//     const chartTypeMapping: Record<string, string> = {\n//       lineChartData: \"Line Chart\",\n//       pieChartData: \"Pie Chart\",\n//       donutChartData: \"Donut Chart\",\n//       barChartData: \"Bar Chart\",\n//       scatterChartData: \"Scatter Plot\",\n//     };\n//     const selectedChartType = chartTypeMapping[selectedChart] || selectedChart;\n//     // Filter the stored processed data to include only the selected chart's data\n//     const filteredProcessedData = {\n//       [selectedChartType]: storedProcessedData[selectedChartType],\n//     };\n//     console.log(\"...filteredProcessedData,\", filteredProcessedData[selectedChartType]?.[0]?.data);\n//     console.log(\"dataObject,\", dataObject);\n//     const requestBody = {\n//       question: inputValue,\n//       processedData: {\n//         // Include the stored processed data\n//         [selectedChartType]: [\n//           {\n//             header: graphData.meta?.header || \"default_header\",\n//             valueName: graphData.meta?.valueName || \"default_valueName\",\n//             label: graphData.datasets[0].label,\n//             data: filteredProcessedData[selectedChartType]?.[0]?.data,\n//           },\n//         ],\n//       },\n//     };\n//     try {\n//       const response = await fetch(\n//         `http://localhost:3012/api/answer-analyze-excel?question=${encodeURIComponent(inputValue)}`,\n//         {\n//           method: \"POST\",\n//           headers: { \"Content-Type\": \"application/json\" },\n//           body: JSON.stringify(requestBody),\n//         }\n//       );\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       console.log(\"Updated API Response Data:\", processedData);\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0]; // Use only API response data\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? [\"rgba(173, 216, 230, 0.6)\", \"rgba(144, 238, 144, 0.6)\", \"rgba(255, 182, 193, 0.6)\"]\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//           meta: {\n//             header: chartInfo.header || \"default_header\",\n//             valueName: chartInfo.valueName || \"default_valueName\",\n//           },\n//         };\n//       };\n//       // Only update chartData without storing in storedProcessedData\n//       setChartData((prevChartData) => ({\n//         ...prevChartData,\n//         [selectedChart]: generateChartData(selectedChartType),\n//       }));\n//     } catch (error) {\n//       console.error(\"Error sending request:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//         x: {\n//           ticks: {\n//             autoSkip: false,\n//             maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//         minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//             autoSkipPadding: 20,\n//           },\n//           grid: {\n//             display: true,\n//             drawTicks: false,\n//             tickLength: 100,\n//             lineWidth: 1\n//           },\n//         },\n//         y: {\n//           beginAtZero: true,\n//           ticks: { precision: 0 },\n//         },\n//       },\n//     plugins: {\n//       legend: { display: true, position: \"top\" },\n//       tooltip: { enabled: true },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div style={{ minWidth: [\"lineChartData\", \"barChartData\"].includes(type) ? `${chartWidth}px` : \"auto\", height: \"400px\" }}>\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button onClick={handleSubmit} className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\">\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map((type) => (\n//             <button key={type} onClick={() => setSelectedChart(type)} className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\">\n//               {type.replace(\"ChartData\", \" Chart\")}\n//             </button>\n//           ))}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           selectedChart && renderChart(selectedChart, { lineChartData: Line, barChartData: Bar, scatterChartData: Scatter, pieChartData: Pie, donutChartData: Doughnut }[selectedChart])\n//         )}\n//         <div className=\"mt-4 flex\">\n//           <input\n//             type=\"text\"\n//             value={inputValue}\n//             onChange={(e) => setInputValue(e.target.value)}\n//             className=\"border p-2 flex-grow mr-2 rounded\"\n//             placeholder=\"Enter your text here\"\n//           />\n//           <button onClick={handleSend} className=\"bg-green-500 text-white p-2 rounded\">\n//             Send\n//           </button>\n//         </div>\n//         <div className=\"mt-4 p-4 border border-gray-300 rounded bg-white\">\n//         <h3 className=\"text-lg font-bold mb-2\">Insights</h3>\n//         {combinedInsights ? (\n//             <ol className=\"list-decimal list-inside text-sm text-gray-700 bg-gray-100 p-2 rounded overflow-auto\">\n//             {combinedInsights.split('\\n').map((insight, index) => (\n//               <ul key={index}>{insight}</ul>\n//             ))}\n//           </ol>\n//         ) : (\n//           <p className=\"text-gray-500\">No insights available.</p>\n//         )}\n//       </div>\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect, useRef } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import { Chart as ChartJS, CategoryScale, LinearScale, BarElement, LineElement, PointElement, ArcElement, Title, Tooltip, Legend } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// import html2canvas from \"html2canvas\";\n// import jsPDF from \"jspdf\";\n// ChartJS.register(CategoryScale, LinearScale, BarElement, LineElement, PointElement, ArcElement, Title, Tooltip, Legend, zoomPlugin);\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string | string[];\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[]\n//   meta?: {\n//     header: string;\n//     valueName: string;\n//   };\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const [inputValue, setInputValue] = useState<string>(\"\");\n//   const [storedProcessedData, setStoredProcessedData] = useState<any>(null); // New state to store processed data\n//   const [combinedInsights, setCombinedInsights] = useState<any>(null);\n//   const chartRef = useRef<HTMLDivElement>(null); // Ref for the chart container\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const combinedInsights = result.data?.combinedInsights;\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n// console.log(\"processedData\",processedData);\n//       setStoredProcessedData(processedData); // Store the processed data\n//       setCombinedInsights(combinedInsights);\n//       const lightColors = [\n//         \"rgba(173, 216, 230, 0.6)\",\n//         \"rgba(144, 238, 144, 0.6)\",\n//         \"rgba(255, 182, 193, 0.6)\",\n//         \"rgba(255, 228, 181, 0.6)\",\n//         \"rgba(221, 160, 221, 0.6)\",\n//         \"rgba(240, 230, 140, 0.6)\",\n//       ];\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? lightColors.slice(0, labels.length)\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//           meta: {\n//             header: chartInfo.header || \"default_header\",\n//             valueName: chartInfo.valueName || \"default_valueName\",\n//           },\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const handleSend = async () => {\n//     if (!inputValue) return;\n//     const graphData = chartData[selectedChart];\n//     if (!graphData) return;\n//     const labels = graphData.labels;\n//     const values = graphData.datasets[0].data;\n//     const dataObject = labels.reduce((obj: { [key: string]: number }, label, index) => {\n//       obj[label] = values[index];\n//       return obj;\n//     }, {});\n//     const chartTypeMapping: Record<string, string> = {\n//       lineChartData: \"Line Chart\",\n//       pieChartData: \"Pie Chart\",\n//       donutChartData: \"Donut Chart\",\n//       barChartData: \"Bar Chart\",\n//       scatterChartData: \"Scatter Plot\",\n//     };\n//     const selectedChartType = chartTypeMapping[selectedChart] || selectedChart;\n//     // Filter the stored processed data to include only the selected chart's data\n//     const filteredProcessedData = {\n//       [selectedChartType]: storedProcessedData[selectedChartType],\n//     };\n//     console.log(\"...filteredProcessedData,\", filteredProcessedData[selectedChartType]?.[0]?.data);\n//     console.log(\"dataObject,\", dataObject);\n//     const requestBody = {\n//       question: inputValue,\n//       processedData: {\n//         // Include the stored processed data\n//         [selectedChartType]: [\n//           {\n//             header: graphData.meta?.header || \"default_header\",\n//             valueName: graphData.meta?.valueName || \"default_valueName\",\n//             label: graphData.datasets[0].label,\n//             data: filteredProcessedData[selectedChartType]?.[0]?.data,\n//           },\n//         ],\n//       },\n//     };\n//     try {\n//       const response = await fetch(\n//         `http://localhost:3012/api/answer-analyze-excel?question=${encodeURIComponent(inputValue)}`,\n//         {\n//           method: \"POST\",\n//           headers: { \"Content-Type\": \"application/json\" },\n//           body: JSON.stringify(requestBody),\n//         }\n//       );\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       console.log(\"Updated API Response Data:\", processedData);\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0]; // Use only API response data\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? [\"rgba(173, 216, 230, 0.6)\", \"rgba(144, 238, 144, 0.6)\", \"rgba(255, 182, 193, 0.6)\"]\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//           meta: {\n//             header: chartInfo.header || \"default_header\",\n//             valueName: chartInfo.valueName || \"default_valueName\",\n//           },\n//         };\n//       };\n//       // Only update chartData without storing in storedProcessedData\n//       setChartData((prevChartData) => ({\n//         ...prevChartData,\n//         [selectedChart]: generateChartData(selectedChartType),\n//       }));\n//     } catch (error) {\n//       console.error(\"Error sending request:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//         x: {\n//           ticks: {\n//             autoSkip: false,\n//             maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//         minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//             autoSkipPadding: 20,\n//           },\n//           grid: {\n//             display: true,\n//             drawTicks: false,\n//             tickLength: 100,\n//             lineWidth: 1\n//           },\n//         },\n//         y: {\n//           beginAtZero: true,\n//           ticks: { precision: 0 },\n//         },\n//       },\n//     plugins: {\n//       legend: { display: true, position: \"top\" },\n//       tooltip: { enabled: true },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div style={{ minWidth: [\"lineChartData\", \"barChartData\"].includes(type) ? `${chartWidth}px` : \"auto\", height: \"400px\" }}>\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   const handleDownloadPDF = async () => {\n//     if (!chartRef.current) return;\n//     // Temporarily set the chart container to its full height to capture all content\n//     const originalHeight = chartRef.current.style.height;\n//     chartRef.current.style.height = `${chartRef.current.scrollHeight}px`;\n//     const canvas = await html2canvas(chartRef.current, {\n//       scrollX: 0,\n//       scrollY: -window.scrollY,\n//       width: chartRef.current.scrollWidth,\n//       height: chartRef.current.scrollHeight,\n//     });\n//     // Restore the original height of the chart container\n//     chartRef.current.style.height = originalHeight;\n//     const imgData = canvas.toDataURL(\"image/png\");\n//     const pdf = new jsPDF(\"landscape\", \"mm\", \"a4\");\n//     const imgProps = pdf.getImageProperties(imgData);\n//     const pdfWidth = pdf.internal.pageSize.getWidth();\n//     const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;\n//     pdf.addImage(imgData, \"PNG\", 0, 0, pdfWidth, pdfHeight);\n//     pdf.save(\"chart.pdf\");\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button onClick={handleSubmit} className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\">\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map((type) => (\n//             <button key={type} onClick={() => setSelectedChart(type)} className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\">\n//               {type.replace(\"ChartData\", \" Chart\")}\n//             </button>\n//           ))}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           selectedChart && renderChart(selectedChart, { lineChartData: Line, barChartData: Bar, scatterChartData: Scatter, pieChartData: Pie, donutChartData: Doughnut }[selectedChart])\n//         )}\n//         <div className=\"mt-4 flex\">\n//           <input\n//             type=\"text\"\n//             value={inputValue}\n//             onChange={(e) => setInputValue(e.target.value)}\n//             className=\"border p-2 flex-grow mr-2 rounded\"\n//             placeholder=\"Enter your text here\"\n//           />\n//           <button onClick={handleSend} className=\"bg-green-500 text-white p-2 rounded\">\n//             Send\n//           </button>\n//         </div>\n//         <div className=\"mt-4 p-4 border border-gray-300 rounded bg-white\">\n//           <h3 className=\"text-lg font-bold mb-2\">Insights</h3>\n//           {combinedInsights ? (\n//             <ol className=\"list-decimal list-inside text-sm text-gray-700 bg-gray-100 p-2 rounded overflow-auto\">\n//               {combinedInsights.split('\\n').map((insight, index) => (\n//                 <ul key={index}>{insight}</ul>\n//               ))}\n//             </ol>\n//           ) : (\n//             <p className=\"text-gray-500\">No insights available.</p>\n//           )}\n//         </div>\n//         <button onClick={handleDownloadPDF} className=\"bg-red-500 text-white p-2 rounded mt-4\">\n//           Download as PDF\n//         </button>\n//       </div>\n//     </div>\n//   );\n// }\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\nchart_js__WEBPACK_IMPORTED_MODULE_3__.Chart.register(chart_js__WEBPACK_IMPORTED_MODULE_3__.CategoryScale, chart_js__WEBPACK_IMPORTED_MODULE_3__.LinearScale, chart_js__WEBPACK_IMPORTED_MODULE_3__.BarElement, chart_js__WEBPACK_IMPORTED_MODULE_3__.LineElement, chart_js__WEBPACK_IMPORTED_MODULE_3__.PointElement, chart_js__WEBPACK_IMPORTED_MODULE_3__.ArcElement, chart_js__WEBPACK_IMPORTED_MODULE_3__.Title, chart_js__WEBPACK_IMPORTED_MODULE_3__.Tooltip, chart_js__WEBPACK_IMPORTED_MODULE_3__.Legend, chartjs_plugin_zoom__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\nfunction Dashboard() {\n    _s();\n    const [chartData, setChartData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        scatterChartData: null,\n        pieChartData: null,\n        donutChartData: null,\n        lineChartData: null,\n        barChartData: null\n    });\n    const [selectedFile, setSelectedFile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [selectedChart, setSelectedChart] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"lineChartData\");\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [chartWidth, setChartWidth] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [inputValue, setInputValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [storedProcessedData, setStoredProcessedData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null); // New state to store processed data\n    const [combinedInsights, setCombinedInsights] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null); // Ref for the chart container\n    const handleFileChange = (event)=>{\n        var _event_target_files;\n        setSelectedFile(((_event_target_files = event.target.files) === null || _event_target_files === void 0 ? void 0 : _event_target_files[0]) || null);\n    };\n    const handleSubmit = async ()=>{\n        if (!selectedFile) return;\n        setLoading(true);\n        const formData = new FormData();\n        formData.append(\"file\", selectedFile);\n        try {\n            var _result_data, _result_data1;\n            const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n                method: \"POST\",\n                body: formData\n            });\n            if (!response.ok) throw new Error(\"Error uploading file.\");\n            const result = await response.json();\n            const combinedInsights = (_result_data = result.data) === null || _result_data === void 0 ? void 0 : _result_data.combinedInsights;\n            const processedData = (_result_data1 = result.data) === null || _result_data1 === void 0 ? void 0 : _result_data1.processedData;\n            if (!processedData) throw new Error(\"Invalid response structure.\");\n            console.log(\"processedData\", processedData);\n            setStoredProcessedData(processedData); // Store the processed data\n            setCombinedInsights(combinedInsights);\n            const lightColors = [\n                \"rgba(173, 216, 230, 0.6)\",\n                \"rgba(144, 238, 144, 0.6)\",\n                \"rgba(255, 182, 193, 0.6)\",\n                \"rgba(255, 228, 181, 0.6)\",\n                \"rgba(221, 160, 221, 0.6)\",\n                \"rgba(240, 230, 140, 0.6)\"\n            ];\n            const generateChartData = (chartType)=>{\n                var _processedData_chartType;\n                const chartInfo = (_processedData_chartType = processedData[chartType]) === null || _processedData_chartType === void 0 ? void 0 : _processedData_chartType[0];\n                if (!chartInfo) return null;\n                const labels = Object.keys(chartInfo.data);\n                const values = Object.values(chartInfo.data);\n                console.log(\"chartType\", chartType);\n                let chartWidth = 0;\n                if ([\n                    \"Line Chart\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150;\n                } else if ([\n                    \"Bar Chart\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150; // Adjust the width for bar chart\n                } else if ([\n                    \"Scatter Plot\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150; // Adjust the width for bar chart\n                } else {\n                    chartWidth = 400; // Default width for other chart types\n                }\n                setChartWidth(chartWidth);\n                return {\n                    labels,\n                    datasets: [\n                        {\n                            label: chartInfo.label || chartType,\n                            data: values,\n                            backgroundColor: [\n                                \"Pie Chart\",\n                                \"Donut Chart\",\n                                \"Bar Chart\"\n                            ].includes(chartType) ? lightColors.slice(0, labels.length) : \"rgba(135, 206, 250, 0.6)\",\n                            borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n                            fill: !chartType.includes(\"Line\")\n                        }\n                    ],\n                    meta: {\n                        header: chartInfo.header || \"default_header\",\n                        valueName: chartInfo.valueName || \"default_valueName\"\n                    }\n                };\n            };\n            setChartData({\n                scatterChartData: generateChartData(\"Scatter Plot\"),\n                pieChartData: generateChartData(\"Pie Chart\"),\n                donutChartData: generateChartData(\"Donut Chart\"),\n                lineChartData: generateChartData(\"Line Chart\"),\n                barChartData: generateChartData(\"Bar Chart\")\n            });\n        } catch (error) {\n            console.error(\"Error uploading file:\", error);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const handleSend = async ()=>{\n        var _graphData_meta, _graphData_meta1, _filteredProcessedData_selectedChartType_, _filteredProcessedData_selectedChartType;\n        if (!inputValue) return;\n        const graphData = chartData[selectedChart];\n        if (!graphData) return;\n        const labels = graphData.labels;\n        const values = graphData.datasets[0].data;\n        const dataObject = labels.reduce((obj, label, index)=>{\n            obj[label] = values[index];\n            return obj;\n        }, {});\n        const chartTypeMapping = {\n            lineChartData: \"Line Chart\",\n            pieChartData: \"Pie Chart\",\n            donutChartData: \"Donut Chart\",\n            barChartData: \"Bar Chart\",\n            scatterChartData: \"Scatter Plot\"\n        };\n        const selectedChartType = chartTypeMapping[selectedChart] || selectedChart;\n        // Filter the stored processed data to include only the selected chart's data\n        const filteredProcessedData = {\n            [selectedChartType]: storedProcessedData[selectedChartType]\n        };\n        const requestBody = {\n            question: inputValue,\n            processedData: {\n                // Include the stored processed data\n                [selectedChartType]: [\n                    {\n                        header: ((_graphData_meta = graphData.meta) === null || _graphData_meta === void 0 ? void 0 : _graphData_meta.header) || \"default_header\",\n                        valueName: ((_graphData_meta1 = graphData.meta) === null || _graphData_meta1 === void 0 ? void 0 : _graphData_meta1.valueName) || \"default_valueName\",\n                        label: graphData.datasets[0].label,\n                        data: (_filteredProcessedData_selectedChartType = filteredProcessedData[selectedChartType]) === null || _filteredProcessedData_selectedChartType === void 0 ? void 0 : (_filteredProcessedData_selectedChartType_ = _filteredProcessedData_selectedChartType[0]) === null || _filteredProcessedData_selectedChartType_ === void 0 ? void 0 : _filteredProcessedData_selectedChartType_.data\n                    }\n                ]\n            }\n        };\n        try {\n            var _result_data;\n            const response = await fetch(\"http://localhost:3012/api/answer-analyze-excel?question=\".concat(encodeURIComponent(inputValue)), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(requestBody)\n            });\n            if (!response.ok) throw new Error(\"Error uploading file.\");\n            const result = await response.json();\n            const processedData = (_result_data = result.data) === null || _result_data === void 0 ? void 0 : _result_data.processedData;\n            if (!processedData) throw new Error(\"Invalid response structure.\");\n            const generateChartData = (chartType)=>{\n                var _processedData_chartType;\n                const chartInfo = (_processedData_chartType = processedData[chartType]) === null || _processedData_chartType === void 0 ? void 0 : _processedData_chartType[0]; // Use only API response data\n                if (!chartInfo) return null;\n                const labels = Object.keys(chartInfo.data);\n                const values = Object.values(chartInfo.data);\n                let chartWidth = 0;\n                if ([\n                    \"Line Chart\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150;\n                } else if ([\n                    \"Bar Chart\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150; // Adjust the width for bar chart\n                } else if ([\n                    \"Scatter Plot\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150; // Adjust the width for bar chart\n                } else {\n                    chartWidth = 400; // Default width for other chart types\n                }\n                setChartWidth(chartWidth);\n                return {\n                    labels,\n                    datasets: [\n                        {\n                            label: chartInfo.label || chartType,\n                            data: values,\n                            backgroundColor: [\n                                \"Pie Chart\",\n                                \"Donut Chart\",\n                                \"Bar Chart\"\n                            ].includes(chartType) ? [\n                                \"rgba(173, 216, 230, 0.6)\",\n                                \"rgba(144, 238, 144, 0.6)\",\n                                \"rgba(255, 182, 193, 0.6)\"\n                            ] : \"rgba(135, 206, 250, 0.6)\",\n                            borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n                            fill: !chartType.includes(\"Line\")\n                        }\n                    ],\n                    meta: {\n                        header: chartInfo.header || \"default_header\",\n                        valueName: chartInfo.valueName || \"default_valueName\"\n                    }\n                };\n            };\n            // Only update chartData without storing in storedProcessedData\n            setChartData((prevChartData)=>({\n                    ...prevChartData,\n                    [selectedChart]: generateChartData(selectedChartType)\n                }));\n        } catch (error) {\n            console.error(\"Error sending request:\", error);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const getChartOptions = (type)=>({\n            responsive: true,\n            maintainAspectRatio: false,\n            scales: [\n                \"Pie Chart\",\n                \"Donut Chart\"\n            ].includes(type) ? {} : {\n                x: {\n                    ticks: {\n                        autoSkip: false,\n                        maxRotation: [\n                            \"Bar Chart\",\n                            \"Scatter Plot\"\n                        ].includes(type) ? 20 : 100,\n                        minRotation: [\n                            \"Bar Chart\",\n                            \"Scatter Plot\"\n                        ].includes(type) ? 0 : 90,\n                        autoSkipPadding: 20\n                    },\n                    grid: {\n                        display: true,\n                        drawTicks: false,\n                        tickLength: 100,\n                        lineWidth: 1\n                    }\n                },\n                y: {\n                    beginAtZero: true,\n                    ticks: {\n                        precision: 0\n                    }\n                }\n            },\n            plugins: {\n                legend: {\n                    display: true,\n                    position: \"top\"\n                },\n                tooltip: {\n                    enabled: true\n                }\n            }\n        });\n    const renderChart = (type, ChartComponent)=>{\n        const data = chartData === null || chartData === void 0 ? void 0 : chartData[type]; // Use optional chaining\n        if (!loading && data) {\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"card p-4 border rounded shadow-sm\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"w-full overflow-x-auto\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            width: \"100%\",\n                            minWidth: [\n                                \"Line Chart\",\n                                \"Bar Chart\"\n                            ].includes(type) ? \"600px\" // Minimum width for scrollable charts\n                             : \"100%\",\n                            height: \"400px\",\n                            margin: \"0 auto\"\n                        },\n                        className: \"relative\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"w-full h-full\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChartComponent, {\n                                data: data,\n                                options: {\n                                    ...getChartOptions(type),\n                                    responsive: true,\n                                    maintainAspectRatio: false\n                                }\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2004,\n                                columnNumber: 17\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                            lineNumber: 2003,\n                            columnNumber: 15\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 1992,\n                        columnNumber: 13\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                    lineNumber: 1991,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                lineNumber: 1990,\n                columnNumber: 9\n            }, this);\n        }\n        return null;\n    };\n    // Optional: Add CSS to your stylesheet\n    const responsiveChartStyles = \"\\n    @media (max-width: 640px) {\\n      .card {\\n        padding: 1rem;\\n      }\\n      .card > div > div {\\n        height: 300px; /* Smaller height on mobile */\\n      }\\n    }\\n    \\n    @media (min-width: 641px) and (max-width: 1024px) {\\n      .card > div > div {\\n        height: 350px; /* Medium height for tablets */\\n      }\\n    }\\n  \";\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col md:flex-row h-screen border border-black\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-lg font-bold mb-2\",\n                        children: \"Upload File\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2042,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"file\",\n                        onChange: handleFileChange,\n                        className: \"border p-2 w-full\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2043,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: handleSubmit,\n                        className: \"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BsUpload_react_icons_bs__WEBPACK_IMPORTED_MODULE_4__.BsUpload, {\n                                className: \"mr-2\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2045,\n                                columnNumber: 11\n                            }, this),\n                            \" Submit\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2044,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex flex-col space-y-2 mt-4\",\n                        children: [\n                            \"lineChartData\",\n                            \"barChartData\",\n                            \"scatterChartData\",\n                            \"pieChartData\",\n                            \"donutChartData\"\n                        ].map((type)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>setSelectedChart(type),\n                                className: \"p-2 bg-gray-300 rounded hover:bg-gray-400\",\n                                children: type.replace(\"ChartData\", \" Chart\")\n                            }, type, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2049,\n                                columnNumber: 13\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2047,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                lineNumber: 2041,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\",\n                children: [\n                    loading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex justify-center items-center h-full\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                            lineNumber: 2058,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2057,\n                        columnNumber: 11\n                    }, this) : selectedChart && renderChart(selectedChart, {\n                        lineChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_5__.Line,\n                        barChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_5__.Bar,\n                        scatterChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_5__.Scatter,\n                        pieChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_5__.Pie,\n                        donutChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_5__.Doughnut\n                    }[selectedChart]),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mt-4 flex\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                value: inputValue,\n                                onChange: (e)=>setInputValue(e.target.value),\n                                className: \"border p-2 flex-grow mr-2 rounded\",\n                                placeholder: \"Enter your text here\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2064,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: handleSend,\n                                className: \"bg-green-500 text-white p-2 rounded\",\n                                children: \"Send\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2071,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2063,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mt-4 p-4 border border-gray-300 rounded bg-white\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                className: \"text-lg font-bold mb-2\",\n                                children: \"Insights\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2076,\n                                columnNumber: 11\n                            }, this),\n                            combinedInsights ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ol\", {\n                                className: \"list-decimal list-inside text-sm text-gray-700 bg-gray-100 p-2 rounded overflow-auto\",\n                                children: combinedInsights.split('\\n').map((insight, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                        children: insight\n                                    }, index, false, {\n                                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                        lineNumber: 2080,\n                                        columnNumber: 17\n                                    }, this))\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2078,\n                                columnNumber: 13\n                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-gray-500\",\n                                children: \"No insights available.\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2084,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2075,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                lineNumber: 2055,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n        lineNumber: 2040,\n        columnNumber: 5\n    }, this);\n}\n_s(Dashboard, \"P/Zh0x9l01YSUrGDOmP3n5Y2uFs=\");\n_c = Dashboard;\nvar _c;\n$RefreshReg$(_c, \"Dashboard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcGFnZXMvVXBsb2FkL1VwbG9hZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFHQSxnQkFBZ0I7QUFDaEIsK0NBQStDO0FBQy9DLHVFQUF1RTtBQUN2RSxXQUFXO0FBQ1gsc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLFdBQVc7QUFDWCxhQUFhO0FBQ2IsWUFBWTtBQUNaLHFCQUFxQjtBQUNyQiw2Q0FBNkM7QUFDN0MsZ0RBQWdEO0FBRWhELG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixXQUFXO0FBQ1gsYUFBYTtBQUNiLFlBQVk7QUFDWixlQUFlO0FBQ2YsS0FBSztBQUVMLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIsZ0JBQWdCO0FBQ2hCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsZ0NBQWdDO0FBQ2hDLDRCQUE0QjtBQUM1QixzQkFBc0I7QUFDdEIsU0FBUztBQUNULElBQUk7QUFFSix3Q0FBd0M7QUFDeEMsbUZBQW1GO0FBQ25GLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsUUFBUTtBQUNSLHlFQUF5RTtBQUN6RSxvRUFBb0U7QUFDcEUsNERBQTREO0FBQzVELDZEQUE2RDtBQUM3RCx3RUFBd0U7QUFFeEUsK0VBQStFO0FBQy9FLHdEQUF3RDtBQUN4RCxPQUFPO0FBRVAsdUNBQXVDO0FBQ3ZDLGlDQUFpQztBQUNqQyx3QkFBd0I7QUFFeEIsdUNBQXVDO0FBQ3ZDLDZDQUE2QztBQUU3QyxZQUFZO0FBQ1osa0ZBQWtGO0FBQ2xGLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsWUFBWTtB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OzBDQUNYdkYsaUJBQWlCMkcsS0FBSyxDQUFDLE1BQU1QLEdBQUcsQ0FBQyxDQUFDUSxTQUF5TDFELHNCQUMxTiw4REFBQzJEO2tEQUFnQkQ7dUNBQVIxRDs7Ozs7Ozs7O3FEQUliLDhEQUFDNEQ7Z0NBQUV2QixXQUFVOzBDQUFnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTXpDO0dBbld3QjNHO0tBQUFBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE11a2VzaC5rYXNpbWFoYW50aGlcXERlc2t0b3BcXHZpc3VsaXphdGlvblxcYWlBZ2VudEZyb250ZW5kQ29kZVxcc3JjXFxhcHBcXHBhZ2VzXFxVcGxvYWRcXFVwbG9hZC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXHJcblxyXG5cclxuLy8gXCJ1c2UgY2xpZW50XCI7XHJcbi8vIGltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuLy8gaW1wb3J0IHsgQmFyLCBMaW5lLCBEb3VnaG51dCwgUGllLCBTY2F0dGVyIH0gZnJvbSBcInJlYWN0LWNoYXJ0anMtMlwiO1xyXG4vLyBpbXBvcnQge1xyXG4vLyAgIENoYXJ0IGFzIENoYXJ0SlMsXHJcbi8vICAgQ2F0ZWdvcnlTY2FsZSxcclxuLy8gICBMaW5lYXJTY2FsZSxcclxuLy8gICBCYXJFbGVtZW50LFxyXG4vLyAgIExpbmVFbGVtZW50LFxyXG4vLyAgIFBvaW50RWxlbWVudCxcclxuLy8gICBBcmNFbGVtZW50LFxyXG4vLyAgIFRpdGxlLFxyXG4vLyAgIFRvb2x0aXAsXHJcbi8vICAgTGVnZW5kLFxyXG4vLyB9IGZyb20gXCJjaGFydC5qc1wiO1xyXG4vLyBpbXBvcnQgeyBCc1VwbG9hZCB9IGZyb20gXCJyZWFjdC1pY29ucy9ic1wiO1xyXG4vLyBpbXBvcnQgem9vbVBsdWdpbiBmcm9tIFwiY2hhcnRqcy1wbHVnaW4tem9vbVwiO1xyXG5cclxuLy8gQ2hhcnRKUy5yZWdpc3RlcihcclxuLy8gICBDYXRlZ29yeVNjYWxlLFxyXG4vLyAgIExpbmVhclNjYWxlLFxyXG4vLyAgIEJhckVsZW1lbnQsXHJcbi8vICAgTGluZUVsZW1lbnQsXHJcbi8vICAgUG9pbnRFbGVtZW50LFxyXG4vLyAgIEFyY0VsZW1lbnQsXHJcbi8vICAgVGl0bGUsXHJcbi8vICAgVG9vbHRpcCxcclxuLy8gICBMZWdlbmQsXHJcbi8vICAgem9vbVBsdWdpblxyXG4vLyApO1xyXG5cclxuLy8gaW50ZXJmYWNlIENoYXJ0RGF0YSB7XHJcbi8vICAgbGFiZWxzOiBzdHJpbmdbXTtcclxuLy8gICBkYXRhc2V0czoge1xyXG4vLyAgICAgbGFiZWw6IHN0cmluZztcclxuLy8gICAgIGRhdGE6IG51bWJlcltdO1xyXG4vLyAgICAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nO1xyXG4vLyAgICAgYm9yZGVyQ29sb3I/OiBzdHJpbmc7XHJcbi8vICAgICBmaWxsPzogYm9vbGVhbjtcclxuLy8gICB9W107XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhc2hib2FyZCgpIHtcclxuLy8gICBjb25zdCBbY2hhcnREYXRhLCBzZXRDaGFydERhdGFdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgQ2hhcnREYXRhIHwgbnVsbD4+KHtcclxuLy8gICAgIHNjYXR0ZXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBwaWVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBkb251dENoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGxpbmVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBiYXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgfSk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkRmlsZSwgc2V0U2VsZWN0ZWRGaWxlXSA9IHVzZVN0YXRlPEZpbGUgfCBudWxsPihudWxsKTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRDaGFydCwgc2V0U2VsZWN0ZWRDaGFydF0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiXCIpO1xyXG4vLyAgIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcclxuLy8gICBjb25zdCBbY2hhcnRXaWR0aCwgc2V0Q2hhcnRXaWR0aF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xyXG4vLyAgIGNvbnN0IFtzZWxlY3RlZExhYmVscywgc2V0U2VsZWN0ZWRMYWJlbHNdID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlRmlsZUNoYW5nZSA9IChldmVudDogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcclxuLy8gICAgIHNldFNlbGVjdGVkRmlsZShldmVudC50YXJnZXQuZmlsZXM/LlswXSB8fCBudWxsKTtcclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVTdWJtaXQgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBpZiAoIXNlbGVjdGVkRmlsZSkgcmV0dXJuO1xyXG4vLyAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuXHJcbi8vICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4vLyAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBzZWxlY3RlZEZpbGUpO1xyXG5cclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwOi8vbG9jYWxob3N0OjMwMTIvYXBpL2FuYWx5emUtZXhjZWxcIiwge1xyXG4vLyAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbi8vICAgICAgICAgYm9keTogZm9ybURhdGEsXHJcbi8vICAgICAgIH0pO1xyXG5cclxuLy8gICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGUuXCIpO1xyXG4vLyAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbi8vICAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSByZXN1bHQuZGF0YT8ucHJvY2Vzc2VkRGF0YTtcclxuXHJcbi8vICAgICAgIGlmICghcHJvY2Vzc2VkRGF0YSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBzdHJ1Y3R1cmUuXCIpO1xyXG5cclxuLy8gICAgICAgY29uc3QgZ2VuZXJhdGVDaGFydERhdGEgPSAoY2hhcnRUeXBlOiBzdHJpbmcpOiBDaGFydERhdGEgfCBudWxsID0+IHtcclxuLy8gICAgICAgICBjb25zdCBjaGFydEluZm8gPSBwcm9jZXNzZWREYXRhW2NoYXJ0VHlwZV0/LlswXTtcclxuLy8gICAgICAgICBpZiAoIWNoYXJ0SW5mbykgcmV0dXJuIG51bGw7XHJcblxyXG4vLyAgICAgICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5rZXlzKGNoYXJ0SW5mby5kYXRhKTtcclxuLy8gICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGNoYXJ0SW5mby5kYXRhKTtcclxuXHJcbi8vICAgICAgICAgcmV0dXJuIHtcclxuLy8gICAgICAgICAgIGxhYmVscyxcclxuLy8gICAgICAgICAgIGRhdGFzZXRzOiBbXHJcbi8vICAgICAgICAgICAgIHtcclxuLy8gICAgICAgICAgICAgICBsYWJlbDogY2hhcnRJbmZvLmxhYmVsIHx8IGNoYXJ0VHlwZSxcclxuLy8gICAgICAgICAgICAgICBkYXRhOiB2YWx1ZXMgYXMgbnVtYmVyW10sXHJcbi8vICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjaGFydFR5cGUuaW5jbHVkZXMoXCJCYXJcIilcclxuLy8gICAgICAgICAgICAgICAgID8gXCJyZ2JhKDU0LCAxNjIsIDIzNSwgMC41KVwiXHJcbi8vICAgICAgICAgICAgICAgICA6IFwicmdiYSgyNTUsIDk5LCAxMzIsIDAuNSlcIixcclxuLy8gICAgICAgICAgICAgICBib3JkZXJDb2xvcjogY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKVxyXG4vLyAgICAgICAgICAgICAgICAgPyBcInJnYmEoMjU1LCA5OSwgMTMyLCAxKVwiXHJcbi8vICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcclxuLy8gICAgICAgICAgICAgICBmaWxsOiAhY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIF0sXHJcbi8vICAgICAgICAgfTtcclxuLy8gICAgICAgfTtcclxuXHJcbi8vICAgICAgIHNldENoYXJ0RGF0YSh7XHJcbi8vICAgICAgICAgc2NhdHRlckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJTY2F0dGVyIFBsb3RcIiksXHJcbi8vICAgICAgICAgcGllQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlBpZSBDaGFydFwiKSxcclxuLy8gICAgICAgICBkb251dENoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJEb251dCBDaGFydFwiKSxcclxuLy8gICAgICAgICBsaW5lQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkxpbmUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgYmFyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkJhciBDaGFydFwiKSxcclxuLy8gICAgICAgfSk7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGU6XCIsIGVycm9yKTtcclxuLy8gICAgIH0gZmluYWxseSB7XHJcbi8vICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH07XHJcblxyXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbi8vICAgICBpZiAoc2VsZWN0ZWRDaGFydCAmJiBjaGFydERhdGFbc2VsZWN0ZWRDaGFydF0pIHtcclxuLy8gICAgICAgY29uc3QgYmFzZUxhYmVscyA9IGNoYXJ0RGF0YVtzZWxlY3RlZENoYXJ0XT8ubGFiZWxzIHx8IFtdO1xyXG4vLyAgICAgICBzZXRDaGFydFdpZHRoKChzZWxlY3RlZExhYmVscy5sZW5ndGggfHwgYmFzZUxhYmVscy5sZW5ndGgpICogMTUwKTtcclxuLy8gICAgIH1cclxuLy8gICB9LCBbc2VsZWN0ZWRDaGFydCwgc2VsZWN0ZWRMYWJlbHMsIGNoYXJ0RGF0YV0pO1xyXG4gIFxyXG5cclxuLy8gICBjb25zdCBnZXRDaGFydE9wdGlvbnMgPSAodHlwZTogc3RyaW5nKSA9PiAoe1xyXG4vLyAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuLy8gICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxyXG4vLyAgICAgc2NhbGVzOiBbXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKVxyXG4vLyAgICAgICA/IHt9XHJcbi8vICAgICAgIDoge1xyXG4vLyAgICAgICAgICAgeDoge1xyXG4vLyAgICAgICAgICAgICB0aWNrczoge1xyXG4vLyAgICAgICAgICAgICAgIGF1dG9Ta2lwOiBmYWxzZSxcclxuLy8gICAgICAgICAgICAgICBtYXhSb3RhdGlvbjogdHlwZSA9PT0gJ2JhckNoYXJ0RGF0YScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXJDaGFydERhdGEnID8gMjAgOiAxMDAsXHJcbi8vICAgICAgICAgICAgICAgbWluUm90YXRpb246IHR5cGUgPT09ICdiYXJDaGFydERhdGEnIHx8IHR5cGUgPT09ICdzY2F0dGVyQ2hhcnREYXRhJyA/IDAgOiA5MCxcclxuLy8gICAgICAgICAgICAgICBhdXRvU2tpcFBhZGRpbmc6IDIwLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgICBncmlkOiB7XHJcbi8vICAgICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgICBkcmF3VGlja3M6IGZhbHNlLFxyXG4vLyAgICAgICAgICAgICAgIHRpY2tMZW5ndGg6IDEwMCxcclxuLy8gICAgICAgICAgICAgICBsaW5lV2lkdGg6IDFcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICB5OiB7XHJcbi8vICAgICAgICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxyXG4vLyAgICAgICAgICAgICB0aWNrczoge1xyXG4vLyAgICAgICAgICAgICAgIHByZWNpc2lvbjogMCxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgIHBsdWdpbnM6IHtcclxuLy8gICAgICAgbGVnZW5kOiB7XHJcbi8vICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICBwb3NpdGlvbjogXCJ0b3BcIixcclxuLy8gICAgICAgfSxcclxuLy8gICAgICAgdG9vbHRpcDoge1xyXG4vLyAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICB9LFxyXG4vLyAgIH0pO1xyXG5cclxuLy8gICBjb25zdCBhcHBseUZpbHRlciA9IChkYXRhOiBDaGFydERhdGEgfCBudWxsKSA9PiB7XHJcbi8vICAgICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xyXG5cclxuLy8gICAgIGNvbnN0IGZpbHRlcmVkTGFiZWxzID0gc2VsZWN0ZWRMYWJlbHMubGVuZ3RoXHJcbi8vICAgICAgID8gZGF0YS5sYWJlbHMuZmlsdGVyKGxhYmVsID0+IHNlbGVjdGVkTGFiZWxzLmluY2x1ZGVzKGxhYmVsKSlcclxuLy8gICAgICAgOiBkYXRhLmxhYmVscztcclxuXHJcbi8vICAgICBjb25zdCBmaWx0ZXJlZERhdGEgPSBkYXRhLmRhdGFzZXRzLm1hcChkYXRhc2V0ID0+ICh7XHJcbi8vICAgICAgIC4uLmRhdGFzZXQsXHJcbi8vICAgICAgIGRhdGE6IGZpbHRlcmVkTGFiZWxzLm1hcChsYWJlbCA9PiBkYXRhc2V0LmRhdGFbZGF0YS5sYWJlbHMuaW5kZXhPZihsYWJlbCldKVxyXG4vLyAgICAgfSkpO1xyXG5cclxuLy8gICAgIHJldHVybiB7XHJcbi8vICAgICAgIGxhYmVsczogZmlsdGVyZWRMYWJlbHMsXHJcbi8vICAgICAgIGRhdGFzZXRzOiBmaWx0ZXJlZERhdGEsXHJcbi8vICAgICB9O1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZUNoZWNrYm94Q2hhbmdlID0gKGxhYmVsOiBzdHJpbmcpID0+IHtcclxuLy8gICAgIHNldFNlbGVjdGVkTGFiZWxzKHByZXYgPT5cclxuLy8gICAgICAgcHJldi5pbmNsdWRlcyhsYWJlbClcclxuLy8gICAgICAgICA/IHByZXYuZmlsdGVyKGl0ZW0gPT4gaXRlbSAhPT0gbGFiZWwpXHJcbi8vICAgICAgICAgOiBbLi4ucHJldiwgbGFiZWxdXHJcbi8vICAgICApO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZVNlbGVjdEFsbCA9ICgpID0+IHtcclxuLy8gICAgIGlmIChzZWxlY3RlZENoYXJ0ICYmIGNoYXJ0RGF0YVtzZWxlY3RlZENoYXJ0XSkge1xyXG4vLyAgICAgICBzZXRTZWxlY3RlZExhYmVscyhjaGFydERhdGFbc2VsZWN0ZWRDaGFydF0/LmxhYmVscyB8fCBbXSk7XHJcbi8vICAgICB9XHJcbi8vICAgfTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlQ2xlYXJBbGwgPSAoKSA9PiB7XHJcbi8vICAgICBzZXRTZWxlY3RlZExhYmVscyhbXSk7XHJcbi8vICAgfTtcclxuXHJcbi8vICAgY29uc3QgcmVuZGVyQ2hhcnQgPSAodHlwZTogc3RyaW5nLCBDaGFydENvbXBvbmVudDogYW55KSA9PiB7XHJcbi8vICAgICBjb25zdCBkYXRhID0gYXBwbHlGaWx0ZXIoY2hhcnREYXRhW3R5cGVdKTtcclxuXHJcbi8vICAgICBpZiAoIWxvYWRpbmcgJiYgZGF0YSkge1xyXG4vLyAgICAgICByZXR1cm4gKFxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZCBwLTQgYm9yZGVyIHJvdW5kZWQgc2hhZG93LXNtXCI+XHJcbi8vICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiBcIjEwMCVcIiwgb3ZlcmZsb3dYOiBcImF1dG9cIiB9fT5cclxuLy8gICAgICAgICAgICAgPGRpdlxyXG4vLyAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbi8vICAgICAgICAgICAgICAgICBtaW5XaWR0aDogW1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKVxyXG4vLyAgICAgICAgICAgICAgICAgICA/IGAke2NoYXJ0V2lkdGh9cHhgXHJcbi8vICAgICAgICAgICAgICAgICAgIDogXCJhdXRvXCIsXHJcbi8vICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiNDAwcHhcIixcclxuLy8gICAgICAgICAgICAgICB9fVxyXG4vLyAgICAgICAgICAgICA+XHJcbi8vICAgICAgICAgICAgICAgPENoYXJ0Q29tcG9uZW50IGRhdGE9e2RhdGF9IG9wdGlvbnM9e2dldENoYXJ0T3B0aW9ucyh0eXBlKX0gLz5cclxuLy8gICAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgKTtcclxuLy8gICAgIH1cclxuLy8gICAgIHJldHVybiBudWxsO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIHJldHVybiAoXHJcbi8vICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgbWQ6ZmxleC1yb3cgaC1zY3JlZW4gYm9yZGVyIGJvcmRlci1ibGFja1wiPlxyXG4vLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTEvNCBiZy13aGl0ZSBwLTUgYm9yZGVyLXQgbWQ6Ym9yZGVyLWwgbWQ6Ym9yZGVyLWJsYWNrXCI+XHJcbi8vICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5VcGxvYWQgRmlsZTwvaDI+XHJcbi8vICAgICAgICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgb25DaGFuZ2U9e2hhbmRsZUZpbGVDaGFuZ2V9IGNsYXNzTmFtZT1cImJvcmRlciBwLTIgdy1mdWxsXCIgLz5cclxuLy8gICAgICAgICA8YnV0dG9uXHJcbi8vICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVTdWJtaXR9XHJcbi8vICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlIHAtMiByb3VuZGVkIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG10LTRcIlxyXG4vLyAgICAgICAgID5cclxuLy8gICAgICAgICAgIDxCc1VwbG9hZCBjbGFzc05hbWU9XCJtci0yXCIgLz4gU3VibWl0XHJcbi8vICAgICAgICAgPC9idXR0b24+XHJcblxyXG4vLyAgICAgICAgIHtzZWxlY3RlZENoYXJ0ICYmIChcclxuLy8gICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtNFwiPlxyXG4vLyAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwiZm9udC1zZW1pYm9sZFwiPkZpbHRlcnM8L2gzPlxyXG4vLyAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2hhbmRsZVNlbGVjdEFsbH0gY2xhc3NOYW1lPVwiYmctZ3JlZW4tNTAwIHRleHQtd2hpdGUgcHgtMiBweS0xIHJvdW5kZWQgbXQtMlwiPlNlbGVjdCBBbGw8L2J1dHRvbj5cclxuLy8gICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtoYW5kbGVDbGVhckFsbH0gY2xhc3NOYW1lPVwiYmctcmVkLTUwMCB0ZXh0LXdoaXRlIHB4LTIgcHktMSByb3VuZGVkIG10LTIgbWwtMlwiPkNsZWFyIEFsbDwvYnV0dG9uPlxyXG4vLyAgICAgICAgICAgICB7Y2hhcnREYXRhW3NlbGVjdGVkQ2hhcnRdPy5sYWJlbHMubWFwKGxhYmVsID0+IChcclxuLy8gICAgICAgICAgICAgICA8ZGl2IGtleT17bGFiZWx9IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyXCI+XHJcbi8vICAgICAgICAgICAgICAgICA8aW5wdXRcclxuLy8gICAgICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcclxuLy8gICAgICAgICAgICAgICAgICAgY2hlY2tlZD17c2VsZWN0ZWRMYWJlbHMuaW5jbHVkZXMobGFiZWwpfVxyXG4vLyAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KCkgPT4gaGFuZGxlQ2hlY2tib3hDaGFuZ2UobGFiZWwpfVxyXG4vLyAgICAgICAgICAgICAgICAgLz5cclxuLy8gICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJtbC0yXCI+e2xhYmVsfTwvbGFiZWw+XHJcbi8vICAgICAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgICAgICkpfVxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgKX1cclxuXHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHNwYWNlLXktMiBtdC00XCI+XHJcbi8vICAgICAgICAgICB7W1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiLCBcInNjYXR0ZXJDaGFydERhdGFcIiwgXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5tYXAoXHJcbi8vICAgICAgICAgICAgICh0eXBlKSA9PiAoXHJcbi8vICAgICAgICAgICAgICAgPGJ1dHRvblxyXG4vLyAgICAgICAgICAgICAgICAga2V5PXt0eXBlfVxyXG4vLyAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xyXG4vLyAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZENoYXJ0KHR5cGUpO1xyXG4vLyAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZExhYmVscyhbXSk7XHJcbi8vICAgICAgICAgICAgICAgICB9fVxyXG4vLyAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicC0yIGJnLWdyYXktMzAwIHJvdW5kZWQgaG92ZXI6YmctZ3JheS00MDBcIlxyXG4vLyAgICAgICAgICAgICAgID5cclxuLy8gICAgICAgICAgICAgICAgIHt0eXBlLnJlcGxhY2UoXCJDaGFydERhdGFcIiwgXCIgQ2hhcnRcIil9XHJcbi8vICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgICAgIClcclxuLy8gICAgICAgICAgICl9XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgIDwvZGl2PlxyXG5cclxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0zLzQgYmctZ3JheS0xMDAgcC01IG92ZXJmbG93LWF1dG9cIj5cclxuLy8gICAgICAgICB7bG9hZGluZyA/IChcclxuLy8gICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgaC1mdWxsXCI+XHJcbi8vICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3Bpbm5lci1ib3JkZXIgYW5pbWF0ZS1zcGluIGJvcmRlci10LTQgYm9yZGVyLWJsdWUtNTAwIHJvdW5kZWQtZnVsbCB3LTEyIGgtMTJcIj48L2Rpdj5cclxuLy8gICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICkgOiAoXHJcbi8vICAgICAgICAgICByZW5kZXJDaGFydChzZWxlY3RlZENoYXJ0LCB7XHJcbi8vICAgICAgICAgICAgIGxpbmVDaGFydERhdGE6IExpbmUsXHJcbi8vICAgICAgICAgICAgIGJhckNoYXJ0RGF0YTogQmFyLFxyXG4vLyAgICAgICAgICAgICBzY2F0dGVyQ2hhcnREYXRhOiBTY2F0dGVyLFxyXG4vLyAgICAgICAgICAgICBwaWVDaGFydERhdGE6IFBpZSxcclxuLy8gICAgICAgICAgICAgZG9udXRDaGFydERhdGE6IERvdWdobnV0LFxyXG4vLyAgICAgICAgICAgfVtzZWxlY3RlZENoYXJ0XSlcclxuLy8gICAgICAgICApfVxyXG4vLyAgICAgICA8L2Rpdj5cclxuLy8gICAgIDwvZGl2PlxyXG4vLyAgICk7XHJcbi8vIH1cclxuXHJcblxyXG4vLyBcInVzZSBjbGllbnRcIjtcclxuLy8gaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG4vLyBpbXBvcnQgeyBCYXIsIExpbmUsIERvdWdobnV0LCBQaWUsIFNjYXR0ZXIgfSBmcm9tIFwicmVhY3QtY2hhcnRqcy0yXCI7XHJcbi8vIGltcG9ydCB7XHJcbi8vICAgQ2hhcnQgYXMgQ2hhcnRKUyxcclxuLy8gICBDYXRlZ29yeVNjYWxlLFxyXG4vLyAgIExpbmVhclNjYWxlLFxyXG4vLyAgIEJhckVsZW1lbnQsXHJcbi8vICAgTGluZUVsZW1lbnQsXHJcbi8vICAgUG9pbnRFbGVtZW50LFxyXG4vLyAgIEFyY0VsZW1lbnQsXHJcbi8vICAgVGl0bGUsXHJcbi8vICAgVG9vbHRpcCxcclxuLy8gICBMZWdlbmQsXHJcbi8vIH0gZnJvbSBcImNoYXJ0LmpzXCI7XHJcbi8vIGltcG9ydCB7IEJzVXBsb2FkIH0gZnJvbSBcInJlYWN0LWljb25zL2JzXCI7XHJcbi8vIGltcG9ydCB6b29tUGx1Z2luIGZyb20gXCJjaGFydGpzLXBsdWdpbi16b29tXCI7XHJcbi8vIGltcG9ydCB7IGxvZyB9IGZyb20gXCJub2RlOmNvbnNvbGVcIjtcclxuIFxyXG4vLyBDaGFydEpTLnJlZ2lzdGVyKFxyXG4vLyAgIENhdGVnb3J5U2NhbGUsXHJcbi8vICAgTGluZWFyU2NhbGUsXHJcbi8vICAgQmFyRWxlbWVudCxcclxuLy8gICBMaW5lRWxlbWVudCxcclxuLy8gICBQb2ludEVsZW1lbnQsXHJcbi8vICAgQXJjRWxlbWVudCxcclxuLy8gICBUaXRsZSxcclxuLy8gICBUb29sdGlwLFxyXG4vLyAgIExlZ2VuZCxcclxuLy8gICB6b29tUGx1Z2luXHJcbi8vICk7XHJcbiBcclxuLy8gaW50ZXJmYWNlIENoYXJ0RGF0YSB7XHJcbi8vICAgbGFiZWxzOiBzdHJpbmdbXTtcclxuLy8gICBkYXRhc2V0czoge1xyXG4vLyAgICAgbGFiZWw6IHN0cmluZztcclxuLy8gICAgIGRhdGE6IG51bWJlcltdO1xyXG4vLyAgICAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nO1xyXG4vLyAgICAgYm9yZGVyQ29sb3I/OiBzdHJpbmc7XHJcbi8vICAgICBmaWxsPzogYm9vbGVhbjtcclxuLy8gICB9W107XHJcbi8vIH1cclxuIFxyXG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEYXNoYm9hcmQoKSB7XHJcbi8vICAgY29uc3QgW2NoYXJ0RGF0YSwgc2V0Q2hhcnREYXRhXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIENoYXJ0RGF0YSB8IG51bGw+Pih7XHJcbi8vICAgICBzY2F0dGVyQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgcGllQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgZG9udXRDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBsaW5lQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgYmFyQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgIH0pO1xyXG4vLyAgIGNvbnN0IFtzZWxlY3RlZEZpbGUsIHNldFNlbGVjdGVkRmlsZV0gPSB1c2VTdGF0ZTxGaWxlIHwgbnVsbD4obnVsbCk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkQ2hhcnQsIHNldFNlbGVjdGVkQ2hhcnRdID0gdXNlU3RhdGU8c3RyaW5nPihcImxpbmVDaGFydERhdGFcIik7XHJcbi8vICAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG4vLyAgIGNvbnN0IFtjaGFydFdpZHRoLCBzZXRDaGFydFdpZHRoXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XHJcbiBcclxuLy8gICBjb25zdCBoYW5kbGVGaWxlQ2hhbmdlID0gKGV2ZW50OiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xyXG4vLyAgICAgc2V0U2VsZWN0ZWRGaWxlKGV2ZW50LnRhcmdldC5maWxlcz8uWzBdIHx8IG51bGwpO1xyXG4vLyAgIH07XHJcbiBcclxuLy8gICBjb25zdCBoYW5kbGVTdWJtaXQgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBpZiAoIXNlbGVjdGVkRmlsZSkgcmV0dXJuO1xyXG4vLyAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuIFxyXG4vLyAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuLy8gICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgc2VsZWN0ZWRGaWxlKTtcclxuIFxyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHA6Ly9sb2NhbGhvc3Q6MzAxMi9hcGkvYW5hbHl6ZS1leGNlbFwiLCB7XHJcbi8vICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuLy8gICAgICAgICBib2R5OiBmb3JtRGF0YSxcclxuLy8gICAgICAgfSk7XHJcbiBcclxuLy8gICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGUuXCIpO1xyXG4vLyAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbi8vICAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSByZXN1bHQuZGF0YT8ucHJvY2Vzc2VkRGF0YTtcclxuLy8gY29uc29sZS5sb2coXCJwcm9jZXNzZWREYXRhXCIscHJvY2Vzc2VkRGF0YSk7XHJcbiBcclxuLy8gICAgICAgaWYgKCFwcm9jZXNzZWREYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZS5cIik7XHJcbiBcclxuLy8gICAgICAgY29uc3QgZ2VuZXJhdGVDaGFydERhdGEgPSAoY2hhcnRUeXBlOiBzdHJpbmcpOiBDaGFydERhdGEgfCBudWxsID0+IHtcclxuLy8gICAgICAgICBjb25zdCBjaGFydEluZm8gPSBwcm9jZXNzZWREYXRhW2NoYXJ0VHlwZV0/LlswXTtcclxuLy8gICAgICAgICBpZiAoIWNoYXJ0SW5mbykgcmV0dXJuIG51bGw7XHJcbiBcclxuLy8gICAgICAgICBjb25zdCBsYWJlbHMgPSBPYmplY3Qua2V5cyhjaGFydEluZm8uZGF0YSk7XHJcbi8vICAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhjaGFydEluZm8uZGF0YSk7XHJcbi8vICBjb25zb2xlLmxvZyhcImxhYmVscy5sZW5ndGggXCIsY2hhcnRUeXBlLGxhYmVscy5sZW5ndGggKTtcclxuLy8gIGNvbnNvbGUubG9nKFwidmFsdWVzLmxlbmd0aCBcIixjaGFydFR5cGUsdmFsdWVzLmxlbmd0aCApO1xyXG5cclxuIFxyXG4vLyAgICAgICAgIHNldENoYXJ0V2lkdGgobGFiZWxzLmxlbmd0aCAqIDE1MCk7XHJcbiBcclxuLy8gICAgICAgICByZXR1cm4ge1xyXG4vLyAgICAgICAgICAgbGFiZWxzLFxyXG4vLyAgICAgICAgICAgZGF0YXNldHM6IFtcclxuLy8gICAgICAgICAgICAge1xyXG4vLyAgICAgICAgICAgICAgIGxhYmVsOiBjaGFydEluZm8ubGFiZWwgfHwgY2hhcnRUeXBlLFxyXG4vLyAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlcyBhcyBudW1iZXJbXSxcclxuLy8gICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNoYXJ0VHlwZS5pbmNsdWRlcyhcIkJhclwiKVxyXG4vLyAgICAgICAgICAgICAgICAgPyBcInJnYmEoNTQsIDE2MiwgMjM1LCAwLjUpXCJcclxuLy8gICAgICAgICAgICAgICAgIDogXCJyZ2JhKDI1NSwgOTksIDEzMiwgMC41KVwiLFxyXG4vLyAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpXHJcbi8vICAgICAgICAgICAgICAgICA/IFwicmdiYSgyNTUsIDk5LCAxMzIsIDEpXCJcclxuLy8gICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxyXG4vLyAgICAgICAgICAgICAgIGZpbGw6ICFjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgXSxcclxuLy8gICAgICAgICB9O1xyXG4vLyAgICAgICB9O1xyXG4vLyBjb25zb2xlLmxvZyhcImdlbmVyYXRlQ2hhcnREYXRhXCIsZ2VuZXJhdGVDaGFydERhdGEpO1xyXG4gXHJcbi8vICAgICAgIHNldENoYXJ0RGF0YSh7XHJcbi8vICAgICAgICAgc2NhdHRlckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJTY2F0dGVyIFBsb3RcIiksXHJcbi8vICAgICAgICAgcGllQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlBpZSBDaGFydFwiKSxcclxuLy8gICAgICAgICBkb251dENoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJEb251dCBDaGFydFwiKSxcclxuLy8gICAgICAgICBsaW5lQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkxpbmUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgYmFyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkJhciBDaGFydFwiKSxcclxuLy8gICAgICAgfSk7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGU6XCIsIGVycm9yKTtcclxuLy8gICAgIH0gZmluYWxseSB7XHJcbi8vICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH07XHJcbiBcclxuLy8gICBjb25zdCBnZXRDaGFydE9wdGlvbnMgPSAodHlwZTogc3RyaW5nKSA9PiAoe1xyXG4gICBcclxuLy8gICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbi8vICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcclxuLy8gICAgIHNjYWxlczogW1wicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSlcclxuLy8gICAgICAgPyB7fVxyXG4vLyAgICAgICA6IHtcclxuLy8gICAgICAgICB4OiB7XHJcbi8vICAgICAgICAgICB0aWNrczoge1xyXG4vLyAgICAgICAgICAgICBhdXRvU2tpcDogZmFsc2UsXHJcbi8vICAgICAgICAgICAgIG1heFJvdGF0aW9uOiB0eXBlID09PSAnYmFyQ2hhcnREYXRhJyB8fCB0eXBlID09PSAnc2NhdHRlckNoYXJ0RGF0YScgPyAyMCA6IDEwMCxcclxuLy8gICAgICAgICBtaW5Sb3RhdGlvbjogdHlwZSA9PT0gJ2JhckNoYXJ0RGF0YScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXJDaGFydERhdGEnID8gMCA6IDkwLFxyXG4vLyAgICAgICAgICAgICBhdXRvU2tpcFBhZGRpbmc6IDIwLFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIGdyaWQ6IHtcclxuLy8gICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgZHJhd1RpY2tzOiBmYWxzZSxcclxuLy8gICAgICAgICAgICAgdGlja0xlbmd0aDogMTAwLFxyXG4vLyAgICAgICAgICAgICBsaW5lV2lkdGg6IDFcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIHk6IHtcclxuLy8gICAgICAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXHJcbi8vICAgICAgICAgICAgIHRpY2tzOiB7XHJcbi8vICAgICAgICAgICAgICAgcHJlY2lzaW9uOiAwLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgcGx1Z2luczoge1xyXG4vLyAgICAgICBsZWdlbmQ6IHtcclxuLy8gICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4vLyAgICAgICAgIHBvc2l0aW9uOiBcInRvcFwiLFxyXG4vLyAgICAgICB9LFxyXG4vLyAgICAgICB0b29sdGlwOiB7XHJcbi8vICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuLy8gICAgICAgfSxcclxuLy8gICAgIH0sXHJcbi8vICAgfSk7XHJcbiBcclxuLy8gICBjb25zdCByZW5kZXJDaGFydCA9ICh0eXBlOiBzdHJpbmcsIENoYXJ0Q29tcG9uZW50OiBhbnkpID0+IHtcclxuLy8gICAgIGNvbnN0IGRhdGEgPSBjaGFydERhdGFbdHlwZV07XHJcbi8vICAgICBpZiAoIWxvYWRpbmcgJiYgZGF0YSkge1xyXG4vLyAgICAgICByZXR1cm4gKFxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZCBwLTQgYm9yZGVyIHJvdW5kZWQgc2hhZG93LXNtXCI+XHJcbi8vICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiBcIjEwMCVcIiwgb3ZlcmZsb3dYOiBcImF1dG9cIiB9fT5cclxuLy8gICAgICAgICAgICAgPGRpdlxyXG4vLyAgICAgICAgICAgICAgIHN0eWxlPXt7XHJcbi8vICAgICAgICAgICAgICAgICBtaW5XaWR0aDogW1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKVxyXG4vLyAgICAgICAgICAgICAgICAgICA/IGAke2NoYXJ0V2lkdGh9cHhgXHJcbi8vICAgICAgICAgICAgICAgICAgIDogXCJhdXRvXCIsXHJcbi8vICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiNDAwcHhcIixcclxuLy8gICAgICAgICAgICAgICB9fVxyXG4vLyAgICAgICAgICAgICA+XHJcbi8vICAgICAgICAgICAgICAgPENoYXJ0Q29tcG9uZW50IGRhdGE9e2RhdGF9IG9wdGlvbnM9e2dldENoYXJ0T3B0aW9ucyh0eXBlKX0gLz5cclxuLy8gICAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgKTtcclxuLy8gICAgIH1cclxuLy8gICAgIHJldHVybiBudWxsO1xyXG4vLyAgIH07XHJcbiBcclxuLy8gICByZXR1cm4gKFxyXG4vLyAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIG1kOmZsZXgtcm93IGgtc2NyZWVuIGJvcmRlciBib3JkZXItYmxhY2tcIj5cclxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0xLzQgYmctd2hpdGUgcC01IGJvcmRlci10IG1kOmJvcmRlci1sIG1kOmJvcmRlci1ibGFja1wiPlxyXG4vLyAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+VXBsb2FkIEZpbGU8L2gyPlxyXG4vLyAgICAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIG9uQ2hhbmdlPXtoYW5kbGVGaWxlQ2hhbmdlfSBjbGFzc05hbWU9XCJib3JkZXIgcC0yIHctZnVsbFwiIC8+XHJcbi8vICAgICAgICAgPGJ1dHRvblxyXG4vLyAgICAgICAgICAgb25DbGljaz17aGFuZGxlU3VibWl0fVxyXG4vLyAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctYmx1ZS01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBtdC00XCJcclxuLy8gICAgICAgICA+XHJcbi8vICAgICAgICAgICA8QnNVcGxvYWQgY2xhc3NOYW1lPVwibXItMlwiIC8+IFN1Ym1pdFxyXG4vLyAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBzcGFjZS15LTIgbXQtNFwiPlxyXG4vLyAgICAgICAgICAge1tcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIiwgXCJzY2F0dGVyQ2hhcnREYXRhXCIsIFwicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0ubWFwKFxyXG4vLyAgICAgICAgICAgICAodHlwZSkgPT4gKFxyXG4vLyAgICAgICAgICAgICAgIDxidXR0b25cclxuLy8gICAgICAgICAgICAgICAgIGtleT17dHlwZX1cclxuLy8gICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkQ2hhcnQodHlwZSl9XHJcbi8vICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJwLTIgYmctZ3JheS0zMDAgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTQwMFwiXHJcbi8vICAgICAgICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgICAgICAge3R5cGUucmVwbGFjZShcIkNoYXJ0RGF0YVwiLCBcIiBDaGFydFwiKX1cclxuLy8gICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgICAgICAgKVxyXG4vLyAgICAgICAgICAgKX1cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgPC9kaXY+XHJcbiBcclxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0zLzQgYmctZ3JheS0xMDAgcC01IG92ZXJmbG93LWF1dG9cIj5cclxuLy8gICAgICAgICB7bG9hZGluZyA/IChcclxuLy8gICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgaC1mdWxsXCI+XHJcbi8vICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3Bpbm5lci1ib3JkZXIgYW5pbWF0ZS1zcGluIGJvcmRlci10LTQgYm9yZGVyLWJsdWUtNTAwIHJvdW5kZWQtZnVsbCB3LTEyIGgtMTJcIj48L2Rpdj5cclxuLy8gICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICkgOiAoXHJcbi8vICAgICAgICAgICByZW5kZXJDaGFydChzZWxlY3RlZENoYXJ0LCB7XHJcbi8vICAgICAgICAgICAgIGxpbmVDaGFydERhdGE6IExpbmUsXHJcbi8vICAgICAgICAgICAgIGJhckNoYXJ0RGF0YTogQmFyLFxyXG4vLyAgICAgICAgICAgICBzY2F0dGVyQ2hhcnREYXRhOiBTY2F0dGVyLFxyXG4vLyAgICAgICAgICAgICBwaWVDaGFydERhdGE6IFBpZSxcclxuLy8gICAgICAgICAgICAgZG9udXRDaGFydERhdGE6IERvdWdobnV0LFxyXG4vLyAgICAgICAgICAgfVtzZWxlY3RlZENoYXJ0XSlcclxuLy8gICAgICAgICApfVxyXG4vLyAgICAgICA8L2Rpdj5cclxuLy8gICAgIDwvZGl2PlxyXG4vLyAgICk7XHJcbi8vIH1cclxuXHJcblxyXG4vLyBcInVzZSBjbGllbnRcIjtcclxuLy8gaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG4vLyBpbXBvcnQgeyBCYXIsIExpbmUsIERvdWdobnV0LCBQaWUsIFNjYXR0ZXIgfSBmcm9tIFwicmVhY3QtY2hhcnRqcy0yXCI7XHJcbi8vIGltcG9ydCB7XHJcbi8vICAgQ2hhcnQgYXMgQ2hhcnRKUyxcclxuLy8gICBDYXRlZ29yeVNjYWxlLFxyXG4vLyAgIExpbmVhclNjYWxlLFxyXG4vLyAgIEJhckVsZW1lbnQsXHJcbi8vICAgTGluZUVsZW1lbnQsXHJcbi8vICAgUG9pbnRFbGVtZW50LFxyXG4vLyAgIEFyY0VsZW1lbnQsXHJcbi8vICAgVGl0bGUsXHJcbi8vICAgVG9vbHRpcCxcclxuLy8gICBMZWdlbmQsXHJcbi8vIH0gZnJvbSBcImNoYXJ0LmpzXCI7XHJcbi8vIGltcG9ydCB7IEJzVXBsb2FkIH0gZnJvbSBcInJlYWN0LWljb25zL2JzXCI7XHJcbi8vIGltcG9ydCB6b29tUGx1Z2luIGZyb20gXCJjaGFydGpzLXBsdWdpbi16b29tXCI7XHJcbi8vIGltcG9ydCB7IGxvZyB9IGZyb20gXCJub2RlOmNvbnNvbGVcIjtcclxuXHJcbi8vIENoYXJ0SlMucmVnaXN0ZXIoXHJcbi8vICAgQ2F0ZWdvcnlTY2FsZSxcclxuLy8gICBMaW5lYXJTY2FsZSxcclxuLy8gICBCYXJFbGVtZW50LFxyXG4vLyAgIExpbmVFbGVtZW50LFxyXG4vLyAgIFBvaW50RWxlbWVudCxcclxuLy8gICBBcmNFbGVtZW50LFxyXG4vLyAgIFRpdGxlLFxyXG4vLyAgIFRvb2x0aXAsXHJcbi8vICAgTGVnZW5kLFxyXG4vLyAgIHpvb21QbHVnaW5cclxuLy8gKTtcclxuXHJcbi8vIGludGVyZmFjZSBDaGFydERhdGEge1xyXG4vLyAgIGxhYmVsczogc3RyaW5nW107XHJcbi8vICAgZGF0YXNldHM6IHtcclxuLy8gICAgIGxhYmVsOiBzdHJpbmc7XHJcbi8vICAgICBkYXRhOiBudW1iZXJbXTtcclxuLy8gICAgIGJhY2tncm91bmRDb2xvcj86IHN0cmluZyB8IHN0cmluZ1tdO1xyXG4vLyAgICAgYm9yZGVyQ29sb3I/OiBzdHJpbmc7XHJcbi8vICAgICBmaWxsPzogYm9vbGVhbjtcclxuLy8gICB9W107XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhc2hib2FyZCgpIHtcclxuLy8gICBjb25zdCBbY2hhcnREYXRhLCBzZXRDaGFydERhdGFdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgQ2hhcnREYXRhIHwgbnVsbD4+KHtcclxuLy8gICAgIHNjYXR0ZXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBwaWVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBkb251dENoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGxpbmVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBiYXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgfSk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkRmlsZSwgc2V0U2VsZWN0ZWRGaWxlXSA9IHVzZVN0YXRlPEZpbGUgfCBudWxsPihudWxsKTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRDaGFydCwgc2V0U2VsZWN0ZWRDaGFydF0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwibGluZUNoYXJ0RGF0YVwiKTtcclxuLy8gICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcbi8vICAgY29uc3QgW2NoYXJ0V2lkdGgsIHNldENoYXJ0V2lkdGhdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlRmlsZUNoYW5nZSA9IChldmVudDogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcclxuLy8gICAgIHNldFNlbGVjdGVkRmlsZShldmVudC50YXJnZXQuZmlsZXM/LlswXSB8fCBudWxsKTtcclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVTdWJtaXQgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBpZiAoIXNlbGVjdGVkRmlsZSkgcmV0dXJuO1xyXG4vLyAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuXHJcbi8vICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4vLyAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBzZWxlY3RlZEZpbGUpO1xyXG5cclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwOi8vbG9jYWxob3N0OjMwMTIvYXBpL2FuYWx5emUtZXhjZWxcIiwge1xyXG4vLyAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbi8vICAgICAgICAgYm9keTogZm9ybURhdGEsXHJcbi8vICAgICAgIH0pO1xyXG5cclxuLy8gICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGUuXCIpO1xyXG4vLyAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbi8vICAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSByZXN1bHQuZGF0YT8ucHJvY2Vzc2VkRGF0YTtcclxuXHJcbi8vICAgICAgIGlmICghcHJvY2Vzc2VkRGF0YSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBzdHJ1Y3R1cmUuXCIpO1xyXG5cclxuLy8gICAgICAgY29uc3QgbGlnaHRDb2xvcnMgPSBbXHJcbi8vICAgICAgICAgXCJyZ2JhKDE3MywgMjE2LCAyMzAsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMTQ0LCAyMzgsIDE0NCwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyNTUsIDE4MiwgMTkzLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDI1NSwgMjI4LCAxODEsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjIxLCAxNjAsIDIyMSwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyNDAsIDIzMCwgMTQwLCAwLjYpXCIsXHJcbi8vICAgICAgIF07XHJcblxyXG4vLyAgICAgICBjb25zdCBnZW5lcmF0ZUNoYXJ0RGF0YSA9IChjaGFydFR5cGU6IHN0cmluZyk6IENoYXJ0RGF0YSB8IG51bGwgPT4ge1xyXG4vLyAgICAgICAgIGNvbnN0IGNoYXJ0SW5mbyA9IHByb2Nlc3NlZERhdGFbY2hhcnRUeXBlXT8uWzBdO1xyXG4vLyAgICAgICAgIGlmICghY2hhcnRJbmZvKSByZXR1cm4gbnVsbDtcclxuXHJcbi8vICAgICAgICAgY29uc3QgbGFiZWxzID0gT2JqZWN0LmtleXMoY2hhcnRJbmZvLmRhdGEpO1xyXG4vLyAgICAgICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoY2hhcnRJbmZvLmRhdGEpO1xyXG5cclxuLy8gICAgICAgICBzZXRDaGFydFdpZHRoKGxhYmVscy5sZW5ndGggKiAxNTApO1xyXG5cclxuLy8gICAgICAgICByZXR1cm4ge1xyXG4vLyAgICAgICAgICAgbGFiZWxzLFxyXG4vLyAgICAgICAgICAgZGF0YXNldHM6IFtcclxuLy8gICAgICAgICAgICAge1xyXG4vLyAgICAgICAgICAgICAgIGxhYmVsOiBjaGFydEluZm8ubGFiZWwgfHwgY2hhcnRUeXBlLFxyXG4vLyAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlcyBhcyBudW1iZXJbXSxcclxuLy8gICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcIlBpZSBDaGFydFwiLCBcIkRvbnV0IENoYXJ0XCIsIFwiQmFyIENoYXJ0XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSlcclxuLy8gICAgICAgICAgICAgICAgID8gbGlnaHRDb2xvcnMuc2xpY2UoMCwgbGFiZWxzLmxlbmd0aClcclxuLy8gICAgICAgICAgICAgICAgIDogXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDAuNilcIixcclxuLy8gICAgICAgICAgICAgICBib3JkZXJDb2xvcjogY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKVxyXG4vLyAgICAgICAgICAgICAgICAgPyBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMSlcIlxyXG4vLyAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXHJcbi8vICAgICAgICAgICAgICAgZmlsbDogIWNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIiksXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICBdLFxyXG4vLyAgICAgICAgIH07XHJcbi8vICAgICAgIH07XHJcblxyXG4vLyAgICAgICBzZXRDaGFydERhdGEoe1xyXG4vLyAgICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiU2NhdHRlciBQbG90XCIpLFxyXG4vLyAgICAgICAgIHBpZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJQaWUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgZG9udXRDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiRG9udXQgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgbGluZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJMaW5lIENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGJhckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJCYXIgQ2hhcnRcIiksXHJcbi8vICAgICAgIH0pO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlOlwiLCBlcnJvcik7XHJcbi8vICAgICB9IGZpbmFsbHkge1xyXG4vLyAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuLy8gICAgIH1cclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBnZXRDaGFydE9wdGlvbnMgPSAodHlwZTogc3RyaW5nKSA9PiAoe1xyXG4vLyAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuLy8gICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxyXG4vLyAgICAgc2NhbGVzOiBbXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKVxyXG4vLyAgICAgICA/IHt9XHJcbi8vICAgICAgIDoge1xyXG4gICAgICAgIC8vIHg6IHtcclxuICAgICAgICAvLyAgIHRpY2tzOiB7XHJcbiAgICAgICAgLy8gICAgIGF1dG9Ta2lwOiBmYWxzZSxcclxuICAgICAgICAvLyAgICAgbWF4Um90YXRpb246IHR5cGUgPT09ICdiYXJDaGFydERhdGEnIHx8IHR5cGUgPT09ICdzY2F0dGVyQ2hhcnREYXRhJyA/IDIwIDogMTAwLFxyXG4gICAgICAgIC8vIG1pblJvdGF0aW9uOiB0eXBlID09PSAnYmFyQ2hhcnREYXRhJyB8fCB0eXBlID09PSAnc2NhdHRlckNoYXJ0RGF0YScgPyAwIDogOTAsXHJcbiAgICAgICAgLy8gICAgIGF1dG9Ta2lwUGFkZGluZzogMjAsXHJcbiAgICAgICAgLy8gICB9LFxyXG4gICAgICAgIC8vICAgZ3JpZDoge1xyXG4gICAgICAgIC8vICAgICBkaXNwbGF5OiB0cnVlLFxyXG4gICAgICAgIC8vICAgICBkcmF3VGlja3M6IGZhbHNlLFxyXG4gICAgICAgIC8vICAgICB0aWNrTGVuZ3RoOiAxMDAsXHJcbiAgICAgICAgLy8gICAgIGxpbmVXaWR0aDogMVxyXG4gICAgICAgIC8vICAgfSxcclxuICAgICAgICAvLyB9LFxyXG4vLyAgICAgICAgICAgeToge1xyXG4vLyAgICAgICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgdGlja3M6IHtcclxuLy8gICAgICAgICAgICAgICBwcmVjaXNpb246IDAsXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICBwbHVnaW5zOiB7XHJcbi8vICAgICAgIGxlZ2VuZDoge1xyXG4vLyAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbi8vICAgICAgICAgcG9zaXRpb246IFwidG9wXCIsXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICAgIHRvb2x0aXA6IHtcclxuLy8gICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4vLyAgICAgICB9LFxyXG4vLyAgICAgfSxcclxuLy8gICB9KTtcclxuXHJcbi8vICAgY29uc3QgcmVuZGVyQ2hhcnQgPSAodHlwZTogc3RyaW5nLCBDaGFydENvbXBvbmVudDogYW55KSA9PiB7XHJcbi8vICAgICBjb25zdCBkYXRhID0gY2hhcnREYXRhW3R5cGVdO1xyXG4vLyAgICAgaWYgKCFsb2FkaW5nICYmIGRhdGEpIHtcclxuLy8gICAgICAgcmV0dXJuIChcclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQgcC00IGJvcmRlciByb3VuZGVkIHNoYWRvdy1zbVwiPlxyXG4vLyAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogXCIxMDAlXCIsIG92ZXJmbG93WDogXCJhdXRvXCIgfX0+XHJcbi8vICAgICAgICAgICAgIDxkaXZcclxuLy8gICAgICAgICAgICAgICBzdHlsZT17e1xyXG4vLyAgICAgICAgICAgICAgICAgbWluV2lkdGg6IFtcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSlcclxuLy8gICAgICAgICAgICAgICAgICAgPyBgJHtjaGFydFdpZHRofXB4YFxyXG4vLyAgICAgICAgICAgICAgICAgICA6IFwiYXV0b1wiLFxyXG4vLyAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjQwMHB4XCIsXHJcbi8vICAgICAgICAgICAgICAgfX1cclxuLy8gICAgICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgICAgIDxDaGFydENvbXBvbmVudCBkYXRhPXtkYXRhfSBvcHRpb25zPXtnZXRDaGFydE9wdGlvbnModHlwZSl9IC8+XHJcbi8vICAgICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICk7XHJcbi8vICAgICB9XHJcbi8vICAgICByZXR1cm4gbnVsbDtcclxuLy8gICB9O1xyXG5cclxuLy8gICByZXR1cm4gKFxyXG4vLyAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIG1kOmZsZXgtcm93IGgtc2NyZWVuIGJvcmRlciBib3JkZXItYmxhY2tcIj5cclxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0xLzQgYmctd2hpdGUgcC01IGJvcmRlci10IG1kOmJvcmRlci1sIG1kOmJvcmRlci1ibGFja1wiPlxyXG4vLyAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+VXBsb2FkIEZpbGU8L2gyPlxyXG4vLyAgICAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIG9uQ2hhbmdlPXtoYW5kbGVGaWxlQ2hhbmdlfSBjbGFzc05hbWU9XCJib3JkZXIgcC0yIHctZnVsbFwiIC8+XHJcbi8vICAgICAgICAgPGJ1dHRvblxyXG4vLyAgICAgICAgICAgb25DbGljaz17aGFuZGxlU3VibWl0fVxyXG4vLyAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctYmx1ZS01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBtdC00XCJcclxuLy8gICAgICAgICA+XHJcbi8vICAgICAgICAgICA8QnNVcGxvYWQgY2xhc3NOYW1lPVwibXItMlwiIC8+IFN1Ym1pdFxyXG4vLyAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBzcGFjZS15LTIgbXQtNFwiPlxyXG4vLyAgICAgICAgICAge1tcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIiwgXCJzY2F0dGVyQ2hhcnREYXRhXCIsIFwicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0ubWFwKFxyXG4vLyAgICAgICAgICAgICAodHlwZSkgPT4gKFxyXG4vLyAgICAgICAgICAgICAgIDxidXR0b25cclxuLy8gICAgICAgICAgICAgICAgIGtleT17dHlwZX1cclxuLy8gICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkQ2hhcnQodHlwZSl9XHJcbi8vICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJwLTIgYmctZ3JheS0zMDAgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTQwMFwiXHJcbi8vICAgICAgICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgICAgICAge3R5cGUucmVwbGFjZShcIkNoYXJ0RGF0YVwiLCBcIiBDaGFydFwiKX1cclxuLy8gICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgICAgICAgKVxyXG4vLyAgICAgICAgICAgKX1cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgPC9kaXY+XHJcblxyXG4vLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTMvNCBiZy1ncmF5LTEwMCBwLTUgb3ZlcmZsb3ctYXV0b1wiPlxyXG4vLyAgICAgICAgIHtsb2FkaW5nID8gKFxyXG4vLyAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBoLWZ1bGxcIj5cclxuLy8gICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGlubmVyLWJvcmRlciBhbmltYXRlLXNwaW4gYm9yZGVyLXQtNCBib3JkZXItYmx1ZS01MDAgcm91bmRlZC1mdWxsIHctMTIgaC0xMlwiPjwvZGl2PlxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgKSA6IChcclxuLy8gICAgICAgICAgIHJlbmRlckNoYXJ0KHNlbGVjdGVkQ2hhcnQsIHtcclxuLy8gICAgICAgICAgICAgbGluZUNoYXJ0RGF0YTogTGluZSxcclxuLy8gICAgICAgICAgICAgYmFyQ2hhcnREYXRhOiBCYXIsXHJcbi8vICAgICAgICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IFNjYXR0ZXIsXHJcbi8vICAgICAgICAgICAgIHBpZUNoYXJ0RGF0YTogUGllLFxyXG4vLyAgICAgICAgICAgICBkb251dENoYXJ0RGF0YTogRG91Z2hudXQsXHJcbi8vICAgICAgICAgICB9W3NlbGVjdGVkQ2hhcnRdKVxyXG4vLyAgICAgICAgICl9XHJcbi8vICAgICAgIDwvZGl2PlxyXG4vLyAgICAgPC9kaXY+XHJcbi8vICAgKTtcclxuLy8gfVxyXG5cclxuXHJcbi8vIFwidXNlIGNsaWVudFwiO1xyXG4vLyBpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XHJcbi8vIGltcG9ydCB7IEJhciwgTGluZSwgRG91Z2hudXQsIFBpZSwgU2NhdHRlciB9IGZyb20gXCJyZWFjdC1jaGFydGpzLTJcIjtcclxuLy8gaW1wb3J0IHtcclxuLy8gICBDaGFydCBhcyBDaGFydEpTLFxyXG4vLyAgIENhdGVnb3J5U2NhbGUsXHJcbi8vICAgTGluZWFyU2NhbGUsXHJcbi8vICAgQmFyRWxlbWVudCxcclxuLy8gICBMaW5lRWxlbWVudCxcclxuLy8gICBQb2ludEVsZW1lbnQsXHJcbi8vICAgQXJjRWxlbWVudCxcclxuLy8gICBUaXRsZSxcclxuLy8gICBUb29sdGlwLFxyXG4vLyAgIExlZ2VuZCxcclxuLy8gfSBmcm9tIFwiY2hhcnQuanNcIjtcclxuLy8gaW1wb3J0IHsgQnNVcGxvYWQgfSBmcm9tIFwicmVhY3QtaWNvbnMvYnNcIjtcclxuLy8gaW1wb3J0IHpvb21QbHVnaW4gZnJvbSBcImNoYXJ0anMtcGx1Z2luLXpvb21cIjtcclxuXHJcbi8vIENoYXJ0SlMucmVnaXN0ZXIoXHJcbi8vICAgQ2F0ZWdvcnlTY2FsZSxcclxuLy8gICBMaW5lYXJTY2FsZSxcclxuLy8gICBCYXJFbGVtZW50LFxyXG4vLyAgIExpbmVFbGVtZW50LFxyXG4vLyAgIFBvaW50RWxlbWVudCxcclxuLy8gICBBcmNFbGVtZW50LFxyXG4vLyAgIFRpdGxlLFxyXG4vLyAgIFRvb2x0aXAsXHJcbi8vICAgTGVnZW5kLFxyXG4vLyAgIHpvb21QbHVnaW5cclxuLy8gKTtcclxuXHJcbi8vIGludGVyZmFjZSBDaGFydERhdGEge1xyXG4vLyAgIGxhYmVsczogc3RyaW5nW107XHJcbi8vICAgZGF0YXNldHM6IHtcclxuLy8gICAgIGxhYmVsOiBzdHJpbmc7XHJcbi8vICAgICBkYXRhOiBudW1iZXJbXTtcclxuLy8gICAgIGJhY2tncm91bmRDb2xvcj86IHN0cmluZyB8IHN0cmluZ1tdO1xyXG4vLyAgICAgYm9yZGVyQ29sb3I/OiBzdHJpbmc7XHJcbi8vICAgICBmaWxsPzogYm9vbGVhbjtcclxuLy8gICB9W107XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhc2hib2FyZCgpIHtcclxuLy8gICBjb25zdCBbY2hhcnREYXRhLCBzZXRDaGFydERhdGFdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgQ2hhcnREYXRhIHwgbnVsbD4+KHtcclxuLy8gICAgIHNjYXR0ZXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBwaWVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBkb251dENoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGxpbmVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBiYXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgfSk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkRmlsZSwgc2V0U2VsZWN0ZWRGaWxlXSA9IHVzZVN0YXRlPEZpbGUgfCBudWxsPihudWxsKTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRDaGFydCwgc2V0U2VsZWN0ZWRDaGFydF0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwibGluZUNoYXJ0RGF0YVwiKTtcclxuLy8gICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcbi8vICAgY29uc3QgW2NoYXJ0V2lkdGgsIHNldENoYXJ0V2lkdGhdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcclxuLy8gICBjb25zdCBbaW5wdXRWYWx1ZSwgc2V0SW5wdXRWYWx1ZV0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiXCIpO1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVGaWxlQ2hhbmdlID0gKGV2ZW50OiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xyXG4vLyAgICAgc2V0U2VsZWN0ZWRGaWxlKGV2ZW50LnRhcmdldC5maWxlcz8uWzBdIHx8IG51bGwpO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IGFzeW5jICgpID0+IHtcclxuLy8gICAgIGlmICghc2VsZWN0ZWRGaWxlKSByZXR1cm47XHJcbi8vICAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG5cclxuLy8gICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbi8vICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIHNlbGVjdGVkRmlsZSk7XHJcblxyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHA6Ly9sb2NhbGhvc3Q6MzAxMi9hcGkvYW5hbHl6ZS1leGNlbFwiLCB7XHJcbi8vICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuLy8gICAgICAgICBib2R5OiBmb3JtRGF0YSxcclxuLy8gICAgICAgfSk7XHJcblxyXG4vLyAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZS5cIik7XHJcbi8vICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuLy8gICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHJlc3VsdC5kYXRhPy5wcm9jZXNzZWREYXRhO1xyXG5cclxuLy8gICAgICAgaWYgKCFwcm9jZXNzZWREYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZS5cIik7XHJcblxyXG4vLyAgICAgICBjb25zdCBsaWdodENvbG9ycyA9IFtcclxuLy8gICAgICAgICBcInJnYmEoMTczLCAyMTYsIDIzMCwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgxNDQsIDIzOCwgMTQ0LCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDI1NSwgMTgyLCAxOTMsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjU1LCAyMjgsIDE4MSwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyMjEsIDE2MCwgMjIxLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDI0MCwgMjMwLCAxNDAsIDAuNilcIixcclxuLy8gICAgICAgXTtcclxuXHJcbi8vICAgICAgIGNvbnN0IGdlbmVyYXRlQ2hhcnREYXRhID0gKGNoYXJ0VHlwZTogc3RyaW5nKTogQ2hhcnREYXRhIHwgbnVsbCA9PiB7XHJcbi8vICAgICAgICAgY29uc3QgY2hhcnRJbmZvID0gcHJvY2Vzc2VkRGF0YVtjaGFydFR5cGVdPy5bMF07XHJcbi8vICAgICAgICAgaWYgKCFjaGFydEluZm8pIHJldHVybiBudWxsO1xyXG5cclxuLy8gICAgICAgICBjb25zdCBsYWJlbHMgPSBPYmplY3Qua2V5cyhjaGFydEluZm8uZGF0YSk7XHJcbi8vICAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhjaGFydEluZm8uZGF0YSk7XHJcblxyXG4vLyAgICAgICAgIHNldENoYXJ0V2lkdGgobGFiZWxzLmxlbmd0aCAqIDE1MCk7XHJcblxyXG4vLyAgICAgICAgIHJldHVybiB7XHJcbi8vICAgICAgICAgICBsYWJlbHMsXHJcbi8vICAgICAgICAgICBkYXRhc2V0czogW1xyXG4vLyAgICAgICAgICAgICB7XHJcbi8vICAgICAgICAgICAgICAgbGFiZWw6IGNoYXJ0SW5mby5sYWJlbCB8fCBjaGFydFR5cGUsXHJcbi8vICAgICAgICAgICAgICAgZGF0YTogdmFsdWVzIGFzIG51bWJlcltdLFxyXG4vLyAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogW1wiUGllIENoYXJ0XCIsIFwiRG9udXQgQ2hhcnRcIiwgXCJCYXIgQ2hhcnRcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKVxyXG4vLyAgICAgICAgICAgICAgICAgPyBsaWdodENvbG9ycy5zbGljZSgwLCBsYWJlbHMubGVuZ3RoKVxyXG4vLyAgICAgICAgICAgICAgICAgOiBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMC42KVwiLFxyXG4vLyAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpXHJcbi8vICAgICAgICAgICAgICAgICA/IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAxKVwiXHJcbi8vICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcclxuLy8gICAgICAgICAgICAgICBmaWxsOiAhY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIF0sXHJcbi8vICAgICAgICAgfTtcclxuLy8gICAgICAgfTtcclxuXHJcbi8vICAgICAgIHNldENoYXJ0RGF0YSh7XHJcbi8vICAgICAgICAgc2NhdHRlckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJTY2F0dGVyIFBsb3RcIiksXHJcbi8vICAgICAgICAgcGllQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlBpZSBDaGFydFwiKSxcclxuLy8gICAgICAgICBkb251dENoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJEb251dCBDaGFydFwiKSxcclxuLy8gICAgICAgICBsaW5lQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkxpbmUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgYmFyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkJhciBDaGFydFwiKSxcclxuLy8gICAgICAgfSk7XHJcbi8vICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4vLyAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGU6XCIsIGVycm9yKTtcclxuLy8gICAgIH0gZmluYWxseSB7XHJcbi8vICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZVNlbmQgPSAoKSA9PiB7XHJcbi8vICAgICBjb25zb2xlLmxvZyhcIklucHV0IFZhbHVlOlwiLCBpbnB1dFZhbHVlKTtcclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBnZXRDaGFydE9wdGlvbnMgPSAodHlwZTogc3RyaW5nKSA9PiAoe1xyXG4vLyAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuLy8gICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxyXG4vLyAgICAgc2NhbGVzOiBbXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKVxyXG4vLyAgICAgICA/IHt9XHJcbi8vICAgICAgIDoge1xyXG4vLyAgICAgICAgIHg6IHtcclxuLy8gICAgICAgICAgIHRpY2tzOiB7XHJcbi8vICAgICAgICAgICAgIGF1dG9Ta2lwOiBmYWxzZSxcclxuLy8gICAgICAgICAgICAgbWF4Um90YXRpb246IHR5cGUgPT09ICdiYXJDaGFydERhdGEnIHx8IHR5cGUgPT09ICdzY2F0dGVyQ2hhcnREYXRhJyA/IDIwIDogMTAwLFxyXG4vLyAgICAgICAgIG1pblJvdGF0aW9uOiB0eXBlID09PSAnYmFyQ2hhcnREYXRhJyB8fCB0eXBlID09PSAnc2NhdHRlckNoYXJ0RGF0YScgPyAwIDogOTAsXHJcbi8vICAgICAgICAgICAgIGF1dG9Ta2lwUGFkZGluZzogMjAsXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgZ3JpZDoge1xyXG4vLyAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4vLyAgICAgICAgICAgICBkcmF3VGlja3M6IGZhbHNlLFxyXG4vLyAgICAgICAgICAgICB0aWNrTGVuZ3RoOiAxMDAsXHJcbi8vICAgICAgICAgICAgIGxpbmVXaWR0aDogMVxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgeToge1xyXG4vLyAgICAgICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgdGlja3M6IHtcclxuLy8gICAgICAgICAgICAgICBwcmVjaXNpb246IDAsXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICBwbHVnaW5zOiB7XHJcbi8vICAgICAgIGxlZ2VuZDoge1xyXG4vLyAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbi8vICAgICAgICAgcG9zaXRpb246IFwidG9wXCIsXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICAgIHRvb2x0aXA6IHtcclxuLy8gICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4vLyAgICAgICB9LFxyXG4vLyAgICAgfSxcclxuLy8gICB9KTtcclxuXHJcbi8vICAgY29uc3QgcmVuZGVyQ2hhcnQgPSAodHlwZTogc3RyaW5nLCBDaGFydENvbXBvbmVudDogYW55KSA9PiB7XHJcbi8vICAgICBjb25zdCBkYXRhID0gY2hhcnREYXRhW3R5cGVdO1xyXG4vLyAgICAgaWYgKCFsb2FkaW5nICYmIGRhdGEpIHtcclxuLy8gICAgICAgcmV0dXJuIChcclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQgcC00IGJvcmRlciByb3VuZGVkIHNoYWRvdy1zbVwiPlxyXG4vLyAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogXCIxMDAlXCIsIG92ZXJmbG93WDogXCJhdXRvXCIgfX0+XHJcbi8vICAgICAgICAgICAgIDxkaXZcclxuLy8gICAgICAgICAgICAgICBzdHlsZT17e1xyXG4vLyAgICAgICAgICAgICAgICAgbWluV2lkdGg6IFtcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSlcclxuLy8gICAgICAgICAgICAgICAgICAgPyBgJHtjaGFydFdpZHRofXB4YFxyXG4vLyAgICAgICAgICAgICAgICAgICA6IFwiYXV0b1wiLFxyXG4vLyAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjQwMHB4XCIsXHJcbi8vICAgICAgICAgICAgICAgfX1cclxuLy8gICAgICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgICAgIDxDaGFydENvbXBvbmVudCBkYXRhPXtkYXRhfSBvcHRpb25zPXtnZXRDaGFydE9wdGlvbnModHlwZSl9IC8+XHJcbi8vICAgICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICk7XHJcbi8vICAgICB9XHJcbi8vICAgICByZXR1cm4gbnVsbDtcclxuLy8gICB9O1xyXG5cclxuLy8gICByZXR1cm4gKFxyXG4vLyAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIG1kOmZsZXgtcm93IGgtc2NyZWVuIGJvcmRlciBib3JkZXItYmxhY2tcIj5cclxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0xLzQgYmctd2hpdGUgcC01IGJvcmRlci10IG1kOmJvcmRlci1sIG1kOmJvcmRlci1ibGFja1wiPlxyXG4vLyAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+VXBsb2FkIEZpbGU8L2gyPlxyXG4vLyAgICAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIG9uQ2hhbmdlPXtoYW5kbGVGaWxlQ2hhbmdlfSBjbGFzc05hbWU9XCJib3JkZXIgcC0yIHctZnVsbFwiIC8+XHJcbi8vICAgICAgICAgPGJ1dHRvblxyXG4vLyAgICAgICAgICAgb25DbGljaz17aGFuZGxlU3VibWl0fVxyXG4vLyAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctYmx1ZS01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBtdC00XCJcclxuLy8gICAgICAgICA+XHJcbi8vICAgICAgICAgICA8QnNVcGxvYWQgY2xhc3NOYW1lPVwibXItMlwiIC8+IFN1Ym1pdFxyXG4vLyAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBzcGFjZS15LTIgbXQtNFwiPlxyXG4vLyAgICAgICAgICAge1tcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIiwgXCJzY2F0dGVyQ2hhcnREYXRhXCIsIFwicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0ubWFwKFxyXG4vLyAgICAgICAgICAgICAodHlwZSkgPT4gKFxyXG4vLyAgICAgICAgICAgICAgIDxidXR0b25cclxuLy8gICAgICAgICAgICAgICAgIGtleT17dHlwZX1cclxuLy8gICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkQ2hhcnQodHlwZSl9XHJcbi8vICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJwLTIgYmctZ3JheS0zMDAgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTQwMFwiXHJcbi8vICAgICAgICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgICAgICAge3R5cGUucmVwbGFjZShcIkNoYXJ0RGF0YVwiLCBcIiBDaGFydFwiKX1cclxuLy8gICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgICAgICAgKVxyXG4vLyAgICAgICAgICAgKX1cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgPC9kaXY+XHJcblxyXG4vLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTMvNCBiZy1ncmF5LTEwMCBwLTUgb3ZlcmZsb3ctYXV0b1wiPlxyXG4vLyAgICAgICAgIHtsb2FkaW5nID8gKFxyXG4vLyAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBoLWZ1bGxcIj5cclxuLy8gICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGlubmVyLWJvcmRlciBhbmltYXRlLXNwaW4gYm9yZGVyLXQtNCBib3JkZXItYmx1ZS01MDAgcm91bmRlZC1mdWxsIHctMTIgaC0xMlwiPjwvZGl2PlxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgKSA6IChcclxuLy8gICAgICAgICAgIHJlbmRlckNoYXJ0KHNlbGVjdGVkQ2hhcnQsIHtcclxuLy8gICAgICAgICAgICAgbGluZUNoYXJ0RGF0YTogTGluZSxcclxuLy8gICAgICAgICAgICAgYmFyQ2hhcnREYXRhOiBCYXIsXHJcbi8vICAgICAgICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IFNjYXR0ZXIsXHJcbi8vICAgICAgICAgICAgIHBpZUNoYXJ0RGF0YTogUGllLFxyXG4vLyAgICAgICAgICAgICBkb251dENoYXJ0RGF0YTogRG91Z2hudXQsXHJcbi8vICAgICAgICAgICB9W3NlbGVjdGVkQ2hhcnRdKVxyXG4vLyAgICAgICAgICl9XHJcblxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtNCBmbGV4XCI+XHJcbi8vICAgICAgICAgICA8aW5wdXRcclxuLy8gICAgICAgICAgICAgdHlwZT1cInRleHRcIlxyXG4vLyAgICAgICAgICAgICB2YWx1ZT17aW5wdXRWYWx1ZX1cclxuLy8gICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRJbnB1dFZhbHVlKGUudGFyZ2V0LnZhbHVlKX1cclxuLy8gICAgICAgICAgICAgY2xhc3NOYW1lPVwiYm9yZGVyIHAtMiBmbGV4LWdyb3cgbXItMiByb3VuZGVkXCJcclxuLy8gICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJFbnRlciB5b3VyIHRleHQgaGVyZVwiXHJcbi8vICAgICAgICAgICAvPlxyXG4vLyAgICAgICAgICAgPGJ1dHRvblxyXG4vLyAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVTZW5kfVxyXG4vLyAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1ncmVlbi01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZFwiXHJcbi8vICAgICAgICAgICA+XHJcbi8vICAgICAgICAgICAgIFNlbmRcclxuLy8gICAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICA8L2Rpdj5cclxuLy8gICAgIDwvZGl2PlxyXG4vLyAgICk7XHJcbi8vIH1cclxuXHJcblxyXG5cclxuLy8gXCJ1c2UgY2xpZW50XCI7XHJcbi8vIGltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuLy8gaW1wb3J0IHsgQmFyLCBMaW5lLCBEb3VnaG51dCwgUGllLCBTY2F0dGVyIH0gZnJvbSBcInJlYWN0LWNoYXJ0anMtMlwiO1xyXG4vLyBpbXBvcnQgeyBDaGFydCBhcyBDaGFydEpTLCBDYXRlZ29yeVNjYWxlLCBMaW5lYXJTY2FsZSwgQmFyRWxlbWVudCwgTGluZUVsZW1lbnQsIFBvaW50RWxlbWVudCwgQXJjRWxlbWVudCwgVGl0bGUsIFRvb2x0aXAsIExlZ2VuZCB9IGZyb20gXCJjaGFydC5qc1wiO1xyXG4vLyBpbXBvcnQgeyBCc1VwbG9hZCB9IGZyb20gXCJyZWFjdC1pY29ucy9ic1wiO1xyXG4vLyBpbXBvcnQgem9vbVBsdWdpbiBmcm9tIFwiY2hhcnRqcy1wbHVnaW4tem9vbVwiO1xyXG5cclxuLy8gQ2hhcnRKUy5yZWdpc3RlcihDYXRlZ29yeVNjYWxlLCBMaW5lYXJTY2FsZSwgQmFyRWxlbWVudCwgTGluZUVsZW1lbnQsIFBvaW50RWxlbWVudCwgQXJjRWxlbWVudCwgVGl0bGUsIFRvb2x0aXAsIExlZ2VuZCwgem9vbVBsdWdpbik7XHJcblxyXG4vLyBpbnRlcmZhY2UgQ2hhcnREYXRhIHtcclxuLy8gICBsYWJlbHM6IHN0cmluZ1tdO1xyXG4vLyAgIGRhdGFzZXRzOiB7XHJcbi8vICAgICBsYWJlbDogc3RyaW5nO1xyXG4vLyAgICAgZGF0YTogbnVtYmVyW107XHJcbi8vICAgICBiYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmcgfCBzdHJpbmdbXTtcclxuLy8gICAgIGJvcmRlckNvbG9yPzogc3RyaW5nO1xyXG4vLyAgICAgZmlsbD86IGJvb2xlYW47XHJcbi8vICAgfVtdXHJcbi8vICAgbWV0YT86IHtcclxuLy8gICAgIGhlYWRlcjogc3RyaW5nO1xyXG4vLyAgICAgdmFsdWVOYW1lOiBzdHJpbmc7XHJcbi8vICAgfTtcclxuLy8gfVxyXG5cclxuLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGFzaGJvYXJkKCkge1xyXG4vLyAgIGNvbnN0IFtjaGFydERhdGEsIHNldENoYXJ0RGF0YV0gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBDaGFydERhdGEgfCBudWxsPj4oe1xyXG4vLyAgICAgc2NhdHRlckNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIHBpZUNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGRvbnV0Q2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgbGluZUNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGJhckNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICB9KTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRGaWxlLCBzZXRTZWxlY3RlZEZpbGVdID0gdXNlU3RhdGU8RmlsZSB8IG51bGw+KG51bGwpO1xyXG4vLyAgIGNvbnN0IFtzZWxlY3RlZENoYXJ0LCBzZXRTZWxlY3RlZENoYXJ0XSA9IHVzZVN0YXRlPHN0cmluZz4oXCJsaW5lQ2hhcnREYXRhXCIpO1xyXG4vLyAgIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcclxuLy8gICBjb25zdCBbY2hhcnRXaWR0aCwgc2V0Q2hhcnRXaWR0aF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xyXG4vLyAgIGNvbnN0IFtpbnB1dFZhbHVlLCBzZXRJbnB1dFZhbHVlXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XHJcbi8vICAgY29uc3QgW3N0b3JlZFByb2Nlc3NlZERhdGEsIHNldFN0b3JlZFByb2Nlc3NlZERhdGFdID0gdXNlU3RhdGU8YW55PihudWxsKTsgLy8gTmV3IHN0YXRlIHRvIHN0b3JlIHByb2Nlc3NlZCBkYXRhXHJcbi8vICAgY29uc3QgW2NvbWJpbmVkSW5zaWdodHMsIHNldENvbWJpbmVkSW5zaWdodHNdID0gdXNlU3RhdGU8YW55PihudWxsKTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlRmlsZUNoYW5nZSA9IChldmVudDogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcclxuLy8gICAgIHNldFNlbGVjdGVkRmlsZShldmVudC50YXJnZXQuZmlsZXM/LlswXSB8fCBudWxsKTtcclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVTdWJtaXQgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBpZiAoIXNlbGVjdGVkRmlsZSkgcmV0dXJuO1xyXG4vLyAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuXHJcbi8vICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4vLyAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBzZWxlY3RlZEZpbGUpO1xyXG5cclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwOi8vbG9jYWxob3N0OjMwMTIvYXBpL2FuYWx5emUtZXhjZWxcIiwge1xyXG4vLyAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbi8vICAgICAgICAgYm9keTogZm9ybURhdGEsXHJcbi8vICAgICAgIH0pO1xyXG5cclxuLy8gICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGUuXCIpO1xyXG4vLyAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbi8vICAgICAgIGNvbnN0IGNvbWJpbmVkSW5zaWdodHMgPSByZXN1bHQuZGF0YT8uY29tYmluZWRJbnNpZ2h0cztcclxuLy8gICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHJlc3VsdC5kYXRhPy5wcm9jZXNzZWREYXRhO1xyXG5cclxuLy8gICAgICAgaWYgKCFwcm9jZXNzZWREYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZS5cIik7XHJcbi8vIGNvbnNvbGUubG9nKFwicHJvY2Vzc2VkRGF0YVwiLHByb2Nlc3NlZERhdGEpO1xyXG5cclxuLy8gICAgICAgc2V0U3RvcmVkUHJvY2Vzc2VkRGF0YShwcm9jZXNzZWREYXRhKTsgLy8gU3RvcmUgdGhlIHByb2Nlc3NlZCBkYXRhXHJcbi8vICAgICAgIHNldENvbWJpbmVkSW5zaWdodHMoY29tYmluZWRJbnNpZ2h0cyk7XHJcbi8vICAgICAgIGNvbnN0IGxpZ2h0Q29sb3JzID0gW1xyXG4vLyAgICAgICAgIFwicmdiYSgxNzMsIDIxNiwgMjMwLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDE0NCwgMjM4LCAxNDQsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjU1LCAxODIsIDE5MywgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyNTUsIDIyOCwgMTgxLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDIyMSwgMTYwLCAyMjEsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjQwLCAyMzAsIDE0MCwgMC42KVwiLFxyXG4vLyAgICAgICBdO1xyXG5cclxuLy8gICAgICAgY29uc3QgZ2VuZXJhdGVDaGFydERhdGEgPSAoY2hhcnRUeXBlOiBzdHJpbmcpOiBDaGFydERhdGEgfCBudWxsID0+IHtcclxuLy8gICAgICAgICBjb25zdCBjaGFydEluZm8gPSBwcm9jZXNzZWREYXRhW2NoYXJ0VHlwZV0/LlswXTtcclxuLy8gICAgICAgICBpZiAoIWNoYXJ0SW5mbykgcmV0dXJuIG51bGw7XHJcblxyXG4vLyAgICAgICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5rZXlzKGNoYXJ0SW5mby5kYXRhKTtcclxuLy8gICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGNoYXJ0SW5mby5kYXRhKTtcclxuXHJcbi8vICAgICAgICAgc2V0Q2hhcnRXaWR0aChsYWJlbHMubGVuZ3RoICogMTUwKTtcclxuXHJcbi8vICAgICAgICAgcmV0dXJuIHtcclxuLy8gICAgICAgICAgIGxhYmVscyxcclxuLy8gICAgICAgICAgIGRhdGFzZXRzOiBbXHJcbi8vICAgICAgICAgICAgIHtcclxuLy8gICAgICAgICAgICAgICBsYWJlbDogY2hhcnRJbmZvLmxhYmVsIHx8IGNoYXJ0VHlwZSxcclxuLy8gICAgICAgICAgICAgICBkYXRhOiB2YWx1ZXMgYXMgbnVtYmVyW10sXHJcbi8vICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbXCJQaWUgQ2hhcnRcIiwgXCJEb251dCBDaGFydFwiLCBcIkJhciBDaGFydFwiXS5pbmNsdWRlcyhjaGFydFR5cGUpXHJcbi8vICAgICAgICAgICAgICAgICA/IGxpZ2h0Q29sb3JzLnNsaWNlKDAsIGxhYmVscy5sZW5ndGgpXHJcbi8vICAgICAgICAgICAgICAgICA6IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAwLjYpXCIsXHJcbi8vICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIikgPyBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMSlcIiA6IHVuZGVmaW5lZCxcclxuLy8gICAgICAgICAgICAgICBmaWxsOiAhY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIF0sXHJcbi8vICAgICAgICAgICBtZXRhOiB7XHJcbi8vICAgICAgICAgICAgIGhlYWRlcjogY2hhcnRJbmZvLmhlYWRlciB8fCBcImRlZmF1bHRfaGVhZGVyXCIsXHJcbi8vICAgICAgICAgICAgIHZhbHVlTmFtZTogY2hhcnRJbmZvLnZhbHVlTmFtZSB8fCBcImRlZmF1bHRfdmFsdWVOYW1lXCIsXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH07XHJcbi8vICAgICAgIH07XHJcblxyXG4vLyAgICAgICBzZXRDaGFydERhdGEoe1xyXG4vLyAgICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiU2NhdHRlciBQbG90XCIpLFxyXG4vLyAgICAgICAgIHBpZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJQaWUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgZG9udXRDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiRG9udXQgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgbGluZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJMaW5lIENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGJhckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJCYXIgQ2hhcnRcIiksXHJcbi8vICAgICAgIH0pO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlOlwiLCBlcnJvcik7XHJcbi8vICAgICB9IGZpbmFsbHkge1xyXG4vLyAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuLy8gICAgIH1cclxuLy8gICB9O1xyXG5cclxuIFxyXG4vLyAgIGNvbnN0IGhhbmRsZVNlbmQgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBpZiAoIWlucHV0VmFsdWUpIHJldHVybjtcclxuICBcclxuLy8gICAgIGNvbnN0IGdyYXBoRGF0YSA9IGNoYXJ0RGF0YVtzZWxlY3RlZENoYXJ0XTtcclxuLy8gICAgIGlmICghZ3JhcGhEYXRhKSByZXR1cm47XHJcbiAgXHJcbi8vICAgICBjb25zdCBsYWJlbHMgPSBncmFwaERhdGEubGFiZWxzO1xyXG4vLyAgICAgY29uc3QgdmFsdWVzID0gZ3JhcGhEYXRhLmRhdGFzZXRzWzBdLmRhdGE7XHJcbiAgXHJcbi8vICAgICBjb25zdCBkYXRhT2JqZWN0ID0gbGFiZWxzLnJlZHVjZSgob2JqOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9LCBsYWJlbCwgaW5kZXgpID0+IHtcclxuLy8gICAgICAgb2JqW2xhYmVsXSA9IHZhbHVlc1tpbmRleF07XHJcbi8vICAgICAgIHJldHVybiBvYmo7XHJcbi8vICAgICB9LCB7fSk7XHJcbiAgXHJcbi8vICAgICBjb25zdCBjaGFydFR5cGVNYXBwaW5nOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xyXG4vLyAgICAgICBsaW5lQ2hhcnREYXRhOiBcIkxpbmUgQ2hhcnRcIixcclxuLy8gICAgICAgcGllQ2hhcnREYXRhOiBcIlBpZSBDaGFydFwiLFxyXG4vLyAgICAgICBkb251dENoYXJ0RGF0YTogXCJEb251dCBDaGFydFwiLFxyXG4vLyAgICAgICBiYXJDaGFydERhdGE6IFwiQmFyIENoYXJ0XCIsXHJcbi8vICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IFwiU2NhdHRlciBQbG90XCIsXHJcbi8vICAgICB9O1xyXG4gIFxyXG4vLyAgICAgY29uc3Qgc2VsZWN0ZWRDaGFydFR5cGUgPSBjaGFydFR5cGVNYXBwaW5nW3NlbGVjdGVkQ2hhcnRdIHx8IHNlbGVjdGVkQ2hhcnQ7XHJcbiAgXHJcbi8vICAgICAvLyBGaWx0ZXIgdGhlIHN0b3JlZCBwcm9jZXNzZWQgZGF0YSB0byBpbmNsdWRlIG9ubHkgdGhlIHNlbGVjdGVkIGNoYXJ0J3MgZGF0YVxyXG4vLyAgICAgY29uc3QgZmlsdGVyZWRQcm9jZXNzZWREYXRhID0ge1xyXG4vLyAgICAgICBbc2VsZWN0ZWRDaGFydFR5cGVdOiBzdG9yZWRQcm9jZXNzZWREYXRhW3NlbGVjdGVkQ2hhcnRUeXBlXSxcclxuLy8gICAgIH07XHJcbiAgXHJcbi8vICAgICBjb25zb2xlLmxvZyhcIi4uLmZpbHRlcmVkUHJvY2Vzc2VkRGF0YSxcIiwgZmlsdGVyZWRQcm9jZXNzZWREYXRhW3NlbGVjdGVkQ2hhcnRUeXBlXT8uWzBdPy5kYXRhKTtcclxuLy8gICAgIGNvbnNvbGUubG9nKFwiZGF0YU9iamVjdCxcIiwgZGF0YU9iamVjdCk7XHJcbiAgXHJcbi8vICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcclxuLy8gICAgICAgcXVlc3Rpb246IGlucHV0VmFsdWUsXHJcbi8vICAgICAgIHByb2Nlc3NlZERhdGE6IHtcclxuLy8gICAgICAgICAvLyBJbmNsdWRlIHRoZSBzdG9yZWQgcHJvY2Vzc2VkIGRhdGFcclxuLy8gICAgICAgICBbc2VsZWN0ZWRDaGFydFR5cGVdOiBbXHJcbi8vICAgICAgICAgICB7XHJcbi8vICAgICAgICAgICAgIGhlYWRlcjogZ3JhcGhEYXRhLm1ldGE/LmhlYWRlciB8fCBcImRlZmF1bHRfaGVhZGVyXCIsXHJcbi8vICAgICAgICAgICAgIHZhbHVlTmFtZTogZ3JhcGhEYXRhLm1ldGE/LnZhbHVlTmFtZSB8fCBcImRlZmF1bHRfdmFsdWVOYW1lXCIsXHJcbi8vICAgICAgICAgICAgIGxhYmVsOiBncmFwaERhdGEuZGF0YXNldHNbMF0ubGFiZWwsXHJcbi8vICAgICAgICAgICAgIGRhdGE6IGZpbHRlcmVkUHJvY2Vzc2VkRGF0YVtzZWxlY3RlZENoYXJ0VHlwZV0/LlswXT8uZGF0YSxcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgXSxcclxuLy8gICAgICAgfSxcclxuLy8gICAgIH07XHJcbiAgXHJcbi8vICAgICB0cnkge1xyXG4vLyAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxyXG4vLyAgICAgICAgIGBodHRwOi8vbG9jYWxob3N0OjMwMTIvYXBpL2Fuc3dlci1hbmFseXplLWV4Y2VsP3F1ZXN0aW9uPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0VmFsdWUpfWAsXHJcbi8vICAgICAgICAge1xyXG4vLyAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuLy8gICAgICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcclxuLy8gICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KSxcclxuLy8gICAgICAgICB9XHJcbi8vICAgICAgICk7XHJcbiAgXHJcbi8vICAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlLlwiKTtcclxuLy8gICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4vLyAgICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gcmVzdWx0LmRhdGE/LnByb2Nlc3NlZERhdGE7XHJcbiAgXHJcbi8vICAgICAgIGlmICghcHJvY2Vzc2VkRGF0YSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBzdHJ1Y3R1cmUuXCIpO1xyXG4gIFxyXG4vLyAgICAgICBjb25zb2xlLmxvZyhcIlVwZGF0ZWQgQVBJIFJlc3BvbnNlIERhdGE6XCIsIHByb2Nlc3NlZERhdGEpO1xyXG4gIFxyXG4vLyAgICAgICBjb25zdCBnZW5lcmF0ZUNoYXJ0RGF0YSA9IChjaGFydFR5cGU6IHN0cmluZyk6IENoYXJ0RGF0YSB8IG51bGwgPT4ge1xyXG4vLyAgICAgICAgIGNvbnN0IGNoYXJ0SW5mbyA9IHByb2Nlc3NlZERhdGFbY2hhcnRUeXBlXT8uWzBdOyAvLyBVc2Ugb25seSBBUEkgcmVzcG9uc2UgZGF0YVxyXG4vLyAgICAgICAgIGlmICghY2hhcnRJbmZvKSByZXR1cm4gbnVsbDtcclxuICBcclxuLy8gICAgICAgICBjb25zdCBsYWJlbHMgPSBPYmplY3Qua2V5cyhjaGFydEluZm8uZGF0YSk7XHJcbi8vICAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhjaGFydEluZm8uZGF0YSk7XHJcbiAgXHJcbi8vICAgICAgICAgc2V0Q2hhcnRXaWR0aChsYWJlbHMubGVuZ3RoICogMTUwKTtcclxuICBcclxuLy8gICAgICAgICByZXR1cm4ge1xyXG4vLyAgICAgICAgICAgbGFiZWxzLFxyXG4vLyAgICAgICAgICAgZGF0YXNldHM6IFtcclxuLy8gICAgICAgICAgICAge1xyXG4vLyAgICAgICAgICAgICAgIGxhYmVsOiBjaGFydEluZm8ubGFiZWwgfHwgY2hhcnRUeXBlLFxyXG4vLyAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlcyBhcyBudW1iZXJbXSxcclxuLy8gICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcIlBpZSBDaGFydFwiLCBcIkRvbnV0IENoYXJ0XCIsIFwiQmFyIENoYXJ0XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSlcclxuLy8gICAgICAgICAgICAgICAgID8gW1wicmdiYSgxNzMsIDIxNiwgMjMwLCAwLjYpXCIsIFwicmdiYSgxNDQsIDIzOCwgMTQ0LCAwLjYpXCIsIFwicmdiYSgyNTUsIDE4MiwgMTkzLCAwLjYpXCJdXHJcbi8vICAgICAgICAgICAgICAgICA6IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAwLjYpXCIsXHJcbi8vICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIikgPyBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMSlcIiA6IHVuZGVmaW5lZCxcclxuLy8gICAgICAgICAgICAgICBmaWxsOiAhY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIF0sXHJcbi8vICAgICAgICAgICBtZXRhOiB7XHJcbi8vICAgICAgICAgICAgIGhlYWRlcjogY2hhcnRJbmZvLmhlYWRlciB8fCBcImRlZmF1bHRfaGVhZGVyXCIsXHJcbi8vICAgICAgICAgICAgIHZhbHVlTmFtZTogY2hhcnRJbmZvLnZhbHVlTmFtZSB8fCBcImRlZmF1bHRfdmFsdWVOYW1lXCIsXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH07XHJcbi8vICAgICAgIH07XHJcbiAgXHJcbi8vICAgICAgIC8vIE9ubHkgdXBkYXRlIGNoYXJ0RGF0YSB3aXRob3V0IHN0b3JpbmcgaW4gc3RvcmVkUHJvY2Vzc2VkRGF0YVxyXG4vLyAgICAgICBzZXRDaGFydERhdGEoKHByZXZDaGFydERhdGEpID0+ICh7XHJcbi8vICAgICAgICAgLi4ucHJldkNoYXJ0RGF0YSxcclxuLy8gICAgICAgICBbc2VsZWN0ZWRDaGFydF06IGdlbmVyYXRlQ2hhcnREYXRhKHNlbGVjdGVkQ2hhcnRUeXBlKSxcclxuLy8gICAgICAgfSkpO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNlbmRpbmcgcmVxdWVzdDpcIiwgZXJyb3IpO1xyXG4vLyAgICAgfSBmaW5hbGx5IHtcclxuLy8gICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbi8vICAgICB9XHJcbi8vICAgfTtcclxuICBcclxuXHJcbi8vICAgY29uc3QgZ2V0Q2hhcnRPcHRpb25zID0gKHR5cGU6IHN0cmluZykgPT4gKHtcclxuLy8gICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbi8vICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcclxuLy8gICAgIHNjYWxlczogW1wicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSlcclxuLy8gICAgICAgPyB7fVxyXG4vLyAgICAgICA6IHtcclxuLy8gICAgICAgICB4OiB7XHJcbi8vICAgICAgICAgICB0aWNrczoge1xyXG4vLyAgICAgICAgICAgICBhdXRvU2tpcDogZmFsc2UsXHJcbi8vICAgICAgICAgICAgIG1heFJvdGF0aW9uOiB0eXBlID09PSAnYmFyQ2hhcnREYXRhJyB8fCB0eXBlID09PSAnc2NhdHRlckNoYXJ0RGF0YScgPyAyMCA6IDEwMCxcclxuLy8gICAgICAgICBtaW5Sb3RhdGlvbjogdHlwZSA9PT0gJ2JhckNoYXJ0RGF0YScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXJDaGFydERhdGEnID8gMCA6IDkwLFxyXG4vLyAgICAgICAgICAgICBhdXRvU2tpcFBhZGRpbmc6IDIwLFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIGdyaWQ6IHtcclxuLy8gICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgZHJhd1RpY2tzOiBmYWxzZSxcclxuLy8gICAgICAgICAgICAgdGlja0xlbmd0aDogMTAwLFxyXG4vLyAgICAgICAgICAgICBsaW5lV2lkdGg6IDFcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgICAgICB5OiB7XHJcbi8vICAgICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcclxuLy8gICAgICAgICAgIHRpY2tzOiB7IHByZWNpc2lvbjogMCB9LFxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICBwbHVnaW5zOiB7XHJcbi8vICAgICAgIGxlZ2VuZDogeyBkaXNwbGF5OiB0cnVlLCBwb3NpdGlvbjogXCJ0b3BcIiB9LFxyXG4vLyAgICAgICB0b29sdGlwOiB7IGVuYWJsZWQ6IHRydWUgfSxcclxuLy8gICAgIH0sXHJcbi8vICAgfSk7XHJcblxyXG4vLyAgIGNvbnN0IHJlbmRlckNoYXJ0ID0gKHR5cGU6IHN0cmluZywgQ2hhcnRDb21wb25lbnQ6IGFueSkgPT4ge1xyXG4vLyAgICAgY29uc3QgZGF0YSA9IGNoYXJ0RGF0YVt0eXBlXTtcclxuLy8gICAgIGlmICghbG9hZGluZyAmJiBkYXRhKSB7XHJcbi8vICAgICAgIHJldHVybiAoXHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkIHAtNCBib3JkZXIgcm91bmRlZCBzaGFkb3ctc21cIj5cclxuLy8gICAgICAgICAgIDxkaXYgc3R5bGU9e3sgd2lkdGg6IFwiMTAwJVwiLCBvdmVyZmxvd1g6IFwiYXV0b1wiIH19PlxyXG4vLyAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IG1pbldpZHRoOiBbXCJsaW5lQ2hhcnREYXRhXCIsIFwiYmFyQ2hhcnREYXRhXCJdLmluY2x1ZGVzKHR5cGUpID8gYCR7Y2hhcnRXaWR0aH1weGAgOiBcImF1dG9cIiwgaGVpZ2h0OiBcIjQwMHB4XCIgfX0+XHJcbi8vICAgICAgICAgICAgICAgPENoYXJ0Q29tcG9uZW50IGRhdGE9e2RhdGF9IG9wdGlvbnM9e2dldENoYXJ0T3B0aW9ucyh0eXBlKX0gLz5cclxuLy8gICAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgKTtcclxuLy8gICAgIH1cclxuLy8gICAgIHJldHVybiBudWxsO1xyXG4vLyAgIH07XHJcbi8vICAgcmV0dXJuIChcclxuLy8gICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBtZDpmbGV4LXJvdyBoLXNjcmVlbiBib3JkZXIgYm9yZGVyLWJsYWNrXCI+XHJcbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMS80IGJnLXdoaXRlIHAtNSBib3JkZXItdCBtZDpib3JkZXItbCBtZDpib3JkZXItYmxhY2tcIj5cclxuLy8gICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPlVwbG9hZCBGaWxlPC9oMj5cclxuLy8gICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIiBvbkNoYW5nZT17aGFuZGxlRmlsZUNoYW5nZX0gY2xhc3NOYW1lPVwiYm9yZGVyIHAtMiB3LWZ1bGxcIiAvPlxyXG4vLyAgICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlU3VibWl0fSBjbGFzc05hbWU9XCJiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlIHAtMiByb3VuZGVkIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG10LTRcIj5cclxuLy8gICAgICAgICAgIDxCc1VwbG9hZCBjbGFzc05hbWU9XCJtci0yXCIgLz4gU3VibWl0XHJcbi8vICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHNwYWNlLXktMiBtdC00XCI+XHJcbi8vICAgICAgICAgICB7W1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiLCBcInNjYXR0ZXJDaGFydERhdGFcIiwgXCJwaWVDaGFydERhdGFcIiwgXCJkb251dENoYXJ0RGF0YVwiXS5tYXAoKHR5cGUpID0+IChcclxuLy8gICAgICAgICAgICAgPGJ1dHRvbiBrZXk9e3R5cGV9IG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkQ2hhcnQodHlwZSl9IGNsYXNzTmFtZT1cInAtMiBiZy1ncmF5LTMwMCByb3VuZGVkIGhvdmVyOmJnLWdyYXktNDAwXCI+XHJcbi8vICAgICAgICAgICAgICAge3R5cGUucmVwbGFjZShcIkNoYXJ0RGF0YVwiLCBcIiBDaGFydFwiKX1cclxuLy8gICAgICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgICApKX1cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgPC9kaXY+XHJcbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMy80IGJnLWdyYXktMTAwIHAtNSBvdmVyZmxvdy1hdXRvXCI+XHJcbi8vICAgICAgICAge2xvYWRpbmcgPyAoXHJcbi8vICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIGgtZnVsbFwiPlxyXG4vLyAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwaW5uZXItYm9yZGVyIGFuaW1hdGUtc3BpbiBib3JkZXItdC00IGJvcmRlci1ibHVlLTUwMCByb3VuZGVkLWZ1bGwgdy0xMiBoLTEyXCI+PC9kaXY+XHJcbi8vICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICApIDogKFxyXG4vLyAgICAgICAgICAgc2VsZWN0ZWRDaGFydCAmJiByZW5kZXJDaGFydChzZWxlY3RlZENoYXJ0LCB7IGxpbmVDaGFydERhdGE6IExpbmUsIGJhckNoYXJ0RGF0YTogQmFyLCBzY2F0dGVyQ2hhcnREYXRhOiBTY2F0dGVyLCBwaWVDaGFydERhdGE6IFBpZSwgZG9udXRDaGFydERhdGE6IERvdWdobnV0IH1bc2VsZWN0ZWRDaGFydF0pXHJcbi8vICAgICAgICAgKX1cclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTQgZmxleFwiPlxyXG4vLyAgICAgICAgICAgPGlucHV0XHJcbi8vICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcclxuLy8gICAgICAgICAgICAgdmFsdWU9e2lucHV0VmFsdWV9XHJcbi8vICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0SW5wdXRWYWx1ZShlLnRhcmdldC52YWx1ZSl9XHJcbi8vICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJvcmRlciBwLTIgZmxleC1ncm93IG1yLTIgcm91bmRlZFwiXHJcbi8vICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiRW50ZXIgeW91ciB0ZXh0IGhlcmVcIlxyXG4vLyAgICAgICAgICAgLz5cclxuLy8gICAgICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlU2VuZH0gY2xhc3NOYW1lPVwiYmctZ3JlZW4tNTAwIHRleHQtd2hpdGUgcC0yIHJvdW5kZWRcIj5cclxuLy8gICAgICAgICAgICAgU2VuZFxyXG4vLyAgICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC00IHAtNCBib3JkZXIgYm9yZGVyLWdyYXktMzAwIHJvdW5kZWQgYmctd2hpdGVcIj5cclxuLy8gICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPkluc2lnaHRzPC9oMz5cclxuLy8gICAgICAgICB7Y29tYmluZWRJbnNpZ2h0cyA/IChcclxuLy8gICAgICAgICAgICAgPG9sIGNsYXNzTmFtZT1cImxpc3QtZGVjaW1hbCBsaXN0LWluc2lkZSB0ZXh0LXNtIHRleHQtZ3JheS03MDAgYmctZ3JheS0xMDAgcC0yIHJvdW5kZWQgb3ZlcmZsb3ctYXV0b1wiPlxyXG4vLyAgICAgICAgICAgICB7Y29tYmluZWRJbnNpZ2h0cy5zcGxpdCgnXFxuJykubWFwKChpbnNpZ2h0LCBpbmRleCkgPT4gKFxyXG4vLyAgICAgICAgICAgICAgIDx1bCBrZXk9e2luZGV4fT57aW5zaWdodH08L3VsPlxyXG4vLyAgICAgICAgICAgICApKX1cclxuLy8gICAgICAgICAgIDwvb2w+XHJcbi8vICAgICAgICAgKSA6IChcclxuLy8gICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtZ3JheS01MDBcIj5ObyBpbnNpZ2h0cyBhdmFpbGFibGUuPC9wPlxyXG4vLyAgICAgICAgICl9XHJcbi8vICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICA8L2Rpdj5cclxuLy8gICAgIDwvZGl2PlxyXG4vLyAgICk7XHJcbi8vIH1cclxuXHJcbi8vIFwidXNlIGNsaWVudFwiO1xyXG4vLyBpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcclxuLy8gaW1wb3J0IHsgQmFyLCBMaW5lLCBEb3VnaG51dCwgUGllLCBTY2F0dGVyIH0gZnJvbSBcInJlYWN0LWNoYXJ0anMtMlwiO1xyXG4vLyBpbXBvcnQgeyBDaGFydCBhcyBDaGFydEpTLCBDYXRlZ29yeVNjYWxlLCBMaW5lYXJTY2FsZSwgQmFyRWxlbWVudCwgTGluZUVsZW1lbnQsIFBvaW50RWxlbWVudCwgQXJjRWxlbWVudCwgVGl0bGUsIFRvb2x0aXAsIExlZ2VuZCB9IGZyb20gXCJjaGFydC5qc1wiO1xyXG4vLyBpbXBvcnQgeyBCc1VwbG9hZCB9IGZyb20gXCJyZWFjdC1pY29ucy9ic1wiO1xyXG4vLyBpbXBvcnQgem9vbVBsdWdpbiBmcm9tIFwiY2hhcnRqcy1wbHVnaW4tem9vbVwiO1xyXG4vLyBpbXBvcnQgaHRtbDJjYW52YXMgZnJvbSBcImh0bWwyY2FudmFzXCI7XHJcbi8vIGltcG9ydCBqc1BERiBmcm9tIFwianNwZGZcIjtcclxuXHJcbi8vIENoYXJ0SlMucmVnaXN0ZXIoQ2F0ZWdvcnlTY2FsZSwgTGluZWFyU2NhbGUsIEJhckVsZW1lbnQsIExpbmVFbGVtZW50LCBQb2ludEVsZW1lbnQsIEFyY0VsZW1lbnQsIFRpdGxlLCBUb29sdGlwLCBMZWdlbmQsIHpvb21QbHVnaW4pO1xyXG5cclxuLy8gaW50ZXJmYWNlIENoYXJ0RGF0YSB7XHJcbi8vICAgbGFiZWxzOiBzdHJpbmdbXTtcclxuLy8gICBkYXRhc2V0czoge1xyXG4vLyAgICAgbGFiZWw6IHN0cmluZztcclxuLy8gICAgIGRhdGE6IG51bWJlcltdO1xyXG4vLyAgICAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nIHwgc3RyaW5nW107XHJcbi8vICAgICBib3JkZXJDb2xvcj86IHN0cmluZztcclxuLy8gICAgIGZpbGw/OiBib29sZWFuO1xyXG4vLyAgIH1bXVxyXG4vLyAgIG1ldGE/OiB7XHJcbi8vICAgICBoZWFkZXI6IHN0cmluZztcclxuLy8gICAgIHZhbHVlTmFtZTogc3RyaW5nO1xyXG4vLyAgIH07XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhc2hib2FyZCgpIHtcclxuLy8gICBjb25zdCBbY2hhcnREYXRhLCBzZXRDaGFydERhdGFdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgQ2hhcnREYXRhIHwgbnVsbD4+KHtcclxuLy8gICAgIHNjYXR0ZXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBwaWVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBkb251dENoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGxpbmVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBiYXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgfSk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkRmlsZSwgc2V0U2VsZWN0ZWRGaWxlXSA9IHVzZVN0YXRlPEZpbGUgfCBudWxsPihudWxsKTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRDaGFydCwgc2V0U2VsZWN0ZWRDaGFydF0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwibGluZUNoYXJ0RGF0YVwiKTtcclxuLy8gICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcbi8vICAgY29uc3QgW2NoYXJ0V2lkdGgsIHNldENoYXJ0V2lkdGhdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcclxuLy8gICBjb25zdCBbaW5wdXRWYWx1ZSwgc2V0SW5wdXRWYWx1ZV0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiXCIpO1xyXG4vLyAgIGNvbnN0IFtzdG9yZWRQcm9jZXNzZWREYXRhLCBzZXRTdG9yZWRQcm9jZXNzZWREYXRhXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7IC8vIE5ldyBzdGF0ZSB0byBzdG9yZSBwcm9jZXNzZWQgZGF0YVxyXG4vLyAgIGNvbnN0IFtjb21iaW5lZEluc2lnaHRzLCBzZXRDb21iaW5lZEluc2lnaHRzXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7XHJcbi8vICAgY29uc3QgY2hhcnRSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpOyAvLyBSZWYgZm9yIHRoZSBjaGFydCBjb250YWluZXJcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlRmlsZUNoYW5nZSA9IChldmVudDogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcclxuLy8gICAgIHNldFNlbGVjdGVkRmlsZShldmVudC50YXJnZXQuZmlsZXM/LlswXSB8fCBudWxsKTtcclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVTdWJtaXQgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBpZiAoIXNlbGVjdGVkRmlsZSkgcmV0dXJuO1xyXG4vLyAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuXHJcbi8vICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4vLyAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBzZWxlY3RlZEZpbGUpO1xyXG5cclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwOi8vbG9jYWxob3N0OjMwMTIvYXBpL2FuYWx5emUtZXhjZWxcIiwge1xyXG4vLyAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbi8vICAgICAgICAgYm9keTogZm9ybURhdGEsXHJcbi8vICAgICAgIH0pO1xyXG5cclxuLy8gICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGUuXCIpO1xyXG4vLyAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbi8vICAgICAgIGNvbnN0IGNvbWJpbmVkSW5zaWdodHMgPSByZXN1bHQuZGF0YT8uY29tYmluZWRJbnNpZ2h0cztcclxuLy8gICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHJlc3VsdC5kYXRhPy5wcm9jZXNzZWREYXRhO1xyXG5cclxuLy8gICAgICAgaWYgKCFwcm9jZXNzZWREYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZS5cIik7XHJcbi8vIGNvbnNvbGUubG9nKFwicHJvY2Vzc2VkRGF0YVwiLHByb2Nlc3NlZERhdGEpO1xyXG5cclxuLy8gICAgICAgc2V0U3RvcmVkUHJvY2Vzc2VkRGF0YShwcm9jZXNzZWREYXRhKTsgLy8gU3RvcmUgdGhlIHByb2Nlc3NlZCBkYXRhXHJcbi8vICAgICAgIHNldENvbWJpbmVkSW5zaWdodHMoY29tYmluZWRJbnNpZ2h0cyk7XHJcbi8vICAgICAgIGNvbnN0IGxpZ2h0Q29sb3JzID0gW1xyXG4vLyAgICAgICAgIFwicmdiYSgxNzMsIDIxNiwgMjMwLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDE0NCwgMjM4LCAxNDQsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjU1LCAxODIsIDE5MywgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyNTUsIDIyOCwgMTgxLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDIyMSwgMTYwLCAyMjEsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjQwLCAyMzAsIDE0MCwgMC42KVwiLFxyXG4vLyAgICAgICBdO1xyXG5cclxuLy8gICAgICAgY29uc3QgZ2VuZXJhdGVDaGFydERhdGEgPSAoY2hhcnRUeXBlOiBzdHJpbmcpOiBDaGFydERhdGEgfCBudWxsID0+IHtcclxuLy8gICAgICAgICBjb25zdCBjaGFydEluZm8gPSBwcm9jZXNzZWREYXRhW2NoYXJ0VHlwZV0/LlswXTtcclxuLy8gICAgICAgICBpZiAoIWNoYXJ0SW5mbykgcmV0dXJuIG51bGw7XHJcblxyXG4vLyAgICAgICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5rZXlzKGNoYXJ0SW5mby5kYXRhKTtcclxuLy8gICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGNoYXJ0SW5mby5kYXRhKTtcclxuXHJcbi8vICAgICAgICAgc2V0Q2hhcnRXaWR0aChsYWJlbHMubGVuZ3RoICogMTUwKTtcclxuXHJcbi8vICAgICAgICAgcmV0dXJuIHtcclxuLy8gICAgICAgICAgIGxhYmVscyxcclxuLy8gICAgICAgICAgIGRhdGFzZXRzOiBbXHJcbi8vICAgICAgICAgICAgIHtcclxuLy8gICAgICAgICAgICAgICBsYWJlbDogY2hhcnRJbmZvLmxhYmVsIHx8IGNoYXJ0VHlwZSxcclxuLy8gICAgICAgICAgICAgICBkYXRhOiB2YWx1ZXMgYXMgbnVtYmVyW10sXHJcbi8vICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbXCJQaWUgQ2hhcnRcIiwgXCJEb251dCBDaGFydFwiLCBcIkJhciBDaGFydFwiXS5pbmNsdWRlcyhjaGFydFR5cGUpXHJcbi8vICAgICAgICAgICAgICAgICA/IGxpZ2h0Q29sb3JzLnNsaWNlKDAsIGxhYmVscy5sZW5ndGgpXHJcbi8vICAgICAgICAgICAgICAgICA6IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAwLjYpXCIsXHJcbi8vICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIikgPyBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMSlcIiA6IHVuZGVmaW5lZCxcclxuLy8gICAgICAgICAgICAgICBmaWxsOiAhY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIF0sXHJcbi8vICAgICAgICAgICBtZXRhOiB7XHJcbi8vICAgICAgICAgICAgIGhlYWRlcjogY2hhcnRJbmZvLmhlYWRlciB8fCBcImRlZmF1bHRfaGVhZGVyXCIsXHJcbi8vICAgICAgICAgICAgIHZhbHVlTmFtZTogY2hhcnRJbmZvLnZhbHVlTmFtZSB8fCBcImRlZmF1bHRfdmFsdWVOYW1lXCIsXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH07XHJcbi8vICAgICAgIH07XHJcblxyXG4vLyAgICAgICBzZXRDaGFydERhdGEoe1xyXG4vLyAgICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiU2NhdHRlciBQbG90XCIpLFxyXG4vLyAgICAgICAgIHBpZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJQaWUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgZG9udXRDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiRG9udXQgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgbGluZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJMaW5lIENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGJhckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJCYXIgQ2hhcnRcIiksXHJcbi8vICAgICAgIH0pO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlOlwiLCBlcnJvcik7XHJcbi8vICAgICB9IGZpbmFsbHkge1xyXG4vLyAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuLy8gICAgIH1cclxuLy8gICB9O1xyXG5cclxuIFxyXG4vLyAgIGNvbnN0IGhhbmRsZVNlbmQgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBpZiAoIWlucHV0VmFsdWUpIHJldHVybjtcclxuICBcclxuLy8gICAgIGNvbnN0IGdyYXBoRGF0YSA9IGNoYXJ0RGF0YVtzZWxlY3RlZENoYXJ0XTtcclxuLy8gICAgIGlmICghZ3JhcGhEYXRhKSByZXR1cm47XHJcbiAgXHJcbi8vICAgICBjb25zdCBsYWJlbHMgPSBncmFwaERhdGEubGFiZWxzO1xyXG4vLyAgICAgY29uc3QgdmFsdWVzID0gZ3JhcGhEYXRhLmRhdGFzZXRzWzBdLmRhdGE7XHJcbiAgXHJcbi8vICAgICBjb25zdCBkYXRhT2JqZWN0ID0gbGFiZWxzLnJlZHVjZSgob2JqOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9LCBsYWJlbCwgaW5kZXgpID0+IHtcclxuLy8gICAgICAgb2JqW2xhYmVsXSA9IHZhbHVlc1tpbmRleF07XHJcbi8vICAgICAgIHJldHVybiBvYmo7XHJcbi8vICAgICB9LCB7fSk7XHJcbiAgXHJcbi8vICAgICBjb25zdCBjaGFydFR5cGVNYXBwaW5nOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xyXG4vLyAgICAgICBsaW5lQ2hhcnREYXRhOiBcIkxpbmUgQ2hhcnRcIixcclxuLy8gICAgICAgcGllQ2hhcnREYXRhOiBcIlBpZSBDaGFydFwiLFxyXG4vLyAgICAgICBkb251dENoYXJ0RGF0YTogXCJEb251dCBDaGFydFwiLFxyXG4vLyAgICAgICBiYXJDaGFydERhdGE6IFwiQmFyIENoYXJ0XCIsXHJcbi8vICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IFwiU2NhdHRlciBQbG90XCIsXHJcbi8vICAgICB9O1xyXG4gIFxyXG4vLyAgICAgY29uc3Qgc2VsZWN0ZWRDaGFydFR5cGUgPSBjaGFydFR5cGVNYXBwaW5nW3NlbGVjdGVkQ2hhcnRdIHx8IHNlbGVjdGVkQ2hhcnQ7XHJcbiAgXHJcbi8vICAgICAvLyBGaWx0ZXIgdGhlIHN0b3JlZCBwcm9jZXNzZWQgZGF0YSB0byBpbmNsdWRlIG9ubHkgdGhlIHNlbGVjdGVkIGNoYXJ0J3MgZGF0YVxyXG4vLyAgICAgY29uc3QgZmlsdGVyZWRQcm9jZXNzZWREYXRhID0ge1xyXG4vLyAgICAgICBbc2VsZWN0ZWRDaGFydFR5cGVdOiBzdG9yZWRQcm9jZXNzZWREYXRhW3NlbGVjdGVkQ2hhcnRUeXBlXSxcclxuLy8gICAgIH07XHJcbiAgXHJcbi8vICAgICBjb25zb2xlLmxvZyhcIi4uLmZpbHRlcmVkUHJvY2Vzc2VkRGF0YSxcIiwgZmlsdGVyZWRQcm9jZXNzZWREYXRhW3NlbGVjdGVkQ2hhcnRUeXBlXT8uWzBdPy5kYXRhKTtcclxuLy8gICAgIGNvbnNvbGUubG9nKFwiZGF0YU9iamVjdCxcIiwgZGF0YU9iamVjdCk7XHJcbiAgXHJcbi8vICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcclxuLy8gICAgICAgcXVlc3Rpb246IGlucHV0VmFsdWUsXHJcbi8vICAgICAgIHByb2Nlc3NlZERhdGE6IHtcclxuLy8gICAgICAgICAvLyBJbmNsdWRlIHRoZSBzdG9yZWQgcHJvY2Vzc2VkIGRhdGFcclxuLy8gICAgICAgICBbc2VsZWN0ZWRDaGFydFR5cGVdOiBbXHJcbi8vICAgICAgICAgICB7XHJcbi8vICAgICAgICAgICAgIGhlYWRlcjogZ3JhcGhEYXRhLm1ldGE/LmhlYWRlciB8fCBcImRlZmF1bHRfaGVhZGVyXCIsXHJcbi8vICAgICAgICAgICAgIHZhbHVlTmFtZTogZ3JhcGhEYXRhLm1ldGE/LnZhbHVlTmFtZSB8fCBcImRlZmF1bHRfdmFsdWVOYW1lXCIsXHJcbi8vICAgICAgICAgICAgIGxhYmVsOiBncmFwaERhdGEuZGF0YXNldHNbMF0ubGFiZWwsXHJcbi8vICAgICAgICAgICAgIGRhdGE6IGZpbHRlcmVkUHJvY2Vzc2VkRGF0YVtzZWxlY3RlZENoYXJ0VHlwZV0/LlswXT8uZGF0YSxcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgXSxcclxuLy8gICAgICAgfSxcclxuLy8gICAgIH07XHJcbiAgXHJcbi8vICAgICB0cnkge1xyXG4vLyAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxyXG4vLyAgICAgICAgIGBodHRwOi8vbG9jYWxob3N0OjMwMTIvYXBpL2Fuc3dlci1hbmFseXplLWV4Y2VsP3F1ZXN0aW9uPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0VmFsdWUpfWAsXHJcbi8vICAgICAgICAge1xyXG4vLyAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuLy8gICAgICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcclxuLy8gICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KSxcclxuLy8gICAgICAgICB9XHJcbi8vICAgICAgICk7XHJcbiAgXHJcbi8vICAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlLlwiKTtcclxuLy8gICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4vLyAgICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gcmVzdWx0LmRhdGE/LnByb2Nlc3NlZERhdGE7XHJcbiAgXHJcbi8vICAgICAgIGlmICghcHJvY2Vzc2VkRGF0YSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBzdHJ1Y3R1cmUuXCIpO1xyXG4gIFxyXG4vLyAgICAgICBjb25zb2xlLmxvZyhcIlVwZGF0ZWQgQVBJIFJlc3BvbnNlIERhdGE6XCIsIHByb2Nlc3NlZERhdGEpO1xyXG4gIFxyXG4vLyAgICAgICBjb25zdCBnZW5lcmF0ZUNoYXJ0RGF0YSA9IChjaGFydFR5cGU6IHN0cmluZyk6IENoYXJ0RGF0YSB8IG51bGwgPT4ge1xyXG4vLyAgICAgICAgIGNvbnN0IGNoYXJ0SW5mbyA9IHByb2Nlc3NlZERhdGFbY2hhcnRUeXBlXT8uWzBdOyAvLyBVc2Ugb25seSBBUEkgcmVzcG9uc2UgZGF0YVxyXG4vLyAgICAgICAgIGlmICghY2hhcnRJbmZvKSByZXR1cm4gbnVsbDtcclxuICBcclxuLy8gICAgICAgICBjb25zdCBsYWJlbHMgPSBPYmplY3Qua2V5cyhjaGFydEluZm8uZGF0YSk7XHJcbi8vICAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhjaGFydEluZm8uZGF0YSk7XHJcbiAgXHJcbi8vICAgICAgICAgc2V0Q2hhcnRXaWR0aChsYWJlbHMubGVuZ3RoICogMTUwKTtcclxuICBcclxuLy8gICAgICAgICByZXR1cm4ge1xyXG4vLyAgICAgICAgICAgbGFiZWxzLFxyXG4vLyAgICAgICAgICAgZGF0YXNldHM6IFtcclxuLy8gICAgICAgICAgICAge1xyXG4vLyAgICAgICAgICAgICAgIGxhYmVsOiBjaGFydEluZm8ubGFiZWwgfHwgY2hhcnRUeXBlLFxyXG4vLyAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlcyBhcyBudW1iZXJbXSxcclxuLy8gICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcIlBpZSBDaGFydFwiLCBcIkRvbnV0IENoYXJ0XCIsIFwiQmFyIENoYXJ0XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSlcclxuLy8gICAgICAgICAgICAgICAgID8gW1wicmdiYSgxNzMsIDIxNiwgMjMwLCAwLjYpXCIsIFwicmdiYSgxNDQsIDIzOCwgMTQ0LCAwLjYpXCIsIFwicmdiYSgyNTUsIDE4MiwgMTkzLCAwLjYpXCJdXHJcbi8vICAgICAgICAgICAgICAgICA6IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAwLjYpXCIsXHJcbi8vICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIikgPyBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMSlcIiA6IHVuZGVmaW5lZCxcclxuLy8gICAgICAgICAgICAgICBmaWxsOiAhY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIF0sXHJcbi8vICAgICAgICAgICBtZXRhOiB7XHJcbi8vICAgICAgICAgICAgIGhlYWRlcjogY2hhcnRJbmZvLmhlYWRlciB8fCBcImRlZmF1bHRfaGVhZGVyXCIsXHJcbi8vICAgICAgICAgICAgIHZhbHVlTmFtZTogY2hhcnRJbmZvLnZhbHVlTmFtZSB8fCBcImRlZmF1bHRfdmFsdWVOYW1lXCIsXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH07XHJcbi8vICAgICAgIH07XHJcbiAgXHJcbi8vICAgICAgIC8vIE9ubHkgdXBkYXRlIGNoYXJ0RGF0YSB3aXRob3V0IHN0b3JpbmcgaW4gc3RvcmVkUHJvY2Vzc2VkRGF0YVxyXG4vLyAgICAgICBzZXRDaGFydERhdGEoKHByZXZDaGFydERhdGEpID0+ICh7XHJcbi8vICAgICAgICAgLi4ucHJldkNoYXJ0RGF0YSxcclxuLy8gICAgICAgICBbc2VsZWN0ZWRDaGFydF06IGdlbmVyYXRlQ2hhcnREYXRhKHNlbGVjdGVkQ2hhcnRUeXBlKSxcclxuLy8gICAgICAgfSkpO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNlbmRpbmcgcmVxdWVzdDpcIiwgZXJyb3IpO1xyXG4vLyAgICAgfSBmaW5hbGx5IHtcclxuLy8gICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbi8vICAgICB9XHJcbi8vICAgfTtcclxuICBcclxuXHJcbi8vICAgY29uc3QgZ2V0Q2hhcnRPcHRpb25zID0gKHR5cGU6IHN0cmluZykgPT4gKHtcclxuLy8gICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbi8vICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcclxuLy8gICAgIHNjYWxlczogW1wicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSlcclxuLy8gICAgICAgPyB7fVxyXG4vLyAgICAgICA6IHtcclxuLy8gICAgICAgICB4OiB7XHJcbi8vICAgICAgICAgICB0aWNrczoge1xyXG4vLyAgICAgICAgICAgICBhdXRvU2tpcDogZmFsc2UsXHJcbi8vICAgICAgICAgICAgIG1heFJvdGF0aW9uOiB0eXBlID09PSAnYmFyQ2hhcnREYXRhJyB8fCB0eXBlID09PSAnc2NhdHRlckNoYXJ0RGF0YScgPyAyMCA6IDEwMCxcclxuLy8gICAgICAgICBtaW5Sb3RhdGlvbjogdHlwZSA9PT0gJ2JhckNoYXJ0RGF0YScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXJDaGFydERhdGEnID8gMCA6IDkwLFxyXG4vLyAgICAgICAgICAgICBhdXRvU2tpcFBhZGRpbmc6IDIwLFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIGdyaWQ6IHtcclxuLy8gICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgZHJhd1RpY2tzOiBmYWxzZSxcclxuLy8gICAgICAgICAgICAgdGlja0xlbmd0aDogMTAwLFxyXG4vLyAgICAgICAgICAgICBsaW5lV2lkdGg6IDFcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgICAgICB5OiB7XHJcbi8vICAgICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcclxuLy8gICAgICAgICAgIHRpY2tzOiB7IHByZWNpc2lvbjogMCB9LFxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICBwbHVnaW5zOiB7XHJcbi8vICAgICAgIGxlZ2VuZDogeyBkaXNwbGF5OiB0cnVlLCBwb3NpdGlvbjogXCJ0b3BcIiB9LFxyXG4vLyAgICAgICB0b29sdGlwOiB7IGVuYWJsZWQ6IHRydWUgfSxcclxuLy8gICAgIH0sXHJcbi8vICAgfSk7XHJcbi8vICAgY29uc3QgcmVuZGVyQ2hhcnQgPSAodHlwZTogc3RyaW5nLCBDaGFydENvbXBvbmVudDogYW55KSA9PiB7XHJcbi8vICAgICBjb25zdCBkYXRhID0gY2hhcnREYXRhW3R5cGVdO1xyXG4vLyAgICAgaWYgKCFsb2FkaW5nICYmIGRhdGEpIHtcclxuLy8gICAgICAgcmV0dXJuIChcclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQgcC00IGJvcmRlciByb3VuZGVkIHNoYWRvdy1zbVwiPlxyXG4vLyAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogXCIxMDAlXCIsIG92ZXJmbG93WDogXCJhdXRvXCIgfX0+XHJcbi8vICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgbWluV2lkdGg6IFtcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSkgPyBgJHtjaGFydFdpZHRofXB4YCA6IFwiYXV0b1wiLCBoZWlnaHQ6IFwiNDAwcHhcIiB9fT5cclxuLy8gICAgICAgICAgICAgICA8Q2hhcnRDb21wb25lbnQgZGF0YT17ZGF0YX0gb3B0aW9ucz17Z2V0Q2hhcnRPcHRpb25zKHR5cGUpfSAvPlxyXG4vLyAgICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICApO1xyXG4vLyAgICAgfVxyXG4vLyAgICAgcmV0dXJuIG51bGw7XHJcbi8vICAgfTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlRG93bmxvYWRQREYgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBpZiAoIWNoYXJ0UmVmLmN1cnJlbnQpIHJldHVybjtcclxuICBcclxuLy8gICAgIC8vIFRlbXBvcmFyaWx5IHNldCB0aGUgY2hhcnQgY29udGFpbmVyIHRvIGl0cyBmdWxsIGhlaWdodCB0byBjYXB0dXJlIGFsbCBjb250ZW50XHJcbi8vICAgICBjb25zdCBvcmlnaW5hbEhlaWdodCA9IGNoYXJ0UmVmLmN1cnJlbnQuc3R5bGUuaGVpZ2h0O1xyXG4vLyAgICAgY2hhcnRSZWYuY3VycmVudC5zdHlsZS5oZWlnaHQgPSBgJHtjaGFydFJlZi5jdXJyZW50LnNjcm9sbEhlaWdodH1weGA7XHJcbiAgXHJcbi8vICAgICBjb25zdCBjYW52YXMgPSBhd2FpdCBodG1sMmNhbnZhcyhjaGFydFJlZi5jdXJyZW50LCB7XHJcbi8vICAgICAgIHNjcm9sbFg6IDAsXHJcbi8vICAgICAgIHNjcm9sbFk6IC13aW5kb3cuc2Nyb2xsWSxcclxuLy8gICAgICAgd2lkdGg6IGNoYXJ0UmVmLmN1cnJlbnQuc2Nyb2xsV2lkdGgsXHJcbi8vICAgICAgIGhlaWdodDogY2hhcnRSZWYuY3VycmVudC5zY3JvbGxIZWlnaHQsXHJcbi8vICAgICB9KTtcclxuICBcclxuLy8gICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGhlaWdodCBvZiB0aGUgY2hhcnQgY29udGFpbmVyXHJcbi8vICAgICBjaGFydFJlZi5jdXJyZW50LnN0eWxlLmhlaWdodCA9IG9yaWdpbmFsSGVpZ2h0O1xyXG4gIFxyXG4vLyAgICAgY29uc3QgaW1nRGF0YSA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XHJcbi8vICAgICBjb25zdCBwZGYgPSBuZXcganNQREYoXCJsYW5kc2NhcGVcIiwgXCJtbVwiLCBcImE0XCIpO1xyXG4vLyAgICAgY29uc3QgaW1nUHJvcHMgPSBwZGYuZ2V0SW1hZ2VQcm9wZXJ0aWVzKGltZ0RhdGEpO1xyXG4vLyAgICAgY29uc3QgcGRmV2lkdGggPSBwZGYuaW50ZXJuYWwucGFnZVNpemUuZ2V0V2lkdGgoKTtcclxuLy8gICAgIGNvbnN0IHBkZkhlaWdodCA9IChpbWdQcm9wcy5oZWlnaHQgKiBwZGZXaWR0aCkgLyBpbWdQcm9wcy53aWR0aDtcclxuICBcclxuLy8gICAgIHBkZi5hZGRJbWFnZShpbWdEYXRhLCBcIlBOR1wiLCAwLCAwLCBwZGZXaWR0aCwgcGRmSGVpZ2h0KTtcclxuLy8gICAgIHBkZi5zYXZlKFwiY2hhcnQucGRmXCIpO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIHJldHVybiAoXHJcbi8vICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgbWQ6ZmxleC1yb3cgaC1zY3JlZW4gYm9yZGVyIGJvcmRlci1ibGFja1wiPlxyXG4vLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTEvNCBiZy13aGl0ZSBwLTUgYm9yZGVyLXQgbWQ6Ym9yZGVyLWwgbWQ6Ym9yZGVyLWJsYWNrXCI+XHJcbi8vICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5VcGxvYWQgRmlsZTwvaDI+XHJcbi8vICAgICAgICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgb25DaGFuZ2U9e2hhbmRsZUZpbGVDaGFuZ2V9IGNsYXNzTmFtZT1cImJvcmRlciBwLTIgdy1mdWxsXCIgLz5cclxuLy8gICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2hhbmRsZVN1Ym1pdH0gY2xhc3NOYW1lPVwiYmctYmx1ZS01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBtdC00XCI+XHJcbi8vICAgICAgICAgICA8QnNVcGxvYWQgY2xhc3NOYW1lPVwibXItMlwiIC8+IFN1Ym1pdFxyXG4vLyAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBzcGFjZS15LTIgbXQtNFwiPlxyXG4vLyAgICAgICAgICAge1tcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIiwgXCJzY2F0dGVyQ2hhcnREYXRhXCIsIFwicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0ubWFwKCh0eXBlKSA9PiAoXHJcbi8vICAgICAgICAgICAgIDxidXR0b24ga2V5PXt0eXBlfSBvbkNsaWNrPXsoKSA9PiBzZXRTZWxlY3RlZENoYXJ0KHR5cGUpfSBjbGFzc05hbWU9XCJwLTIgYmctZ3JheS0zMDAgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTQwMFwiPlxyXG4vLyAgICAgICAgICAgICAgIHt0eXBlLnJlcGxhY2UoXCJDaGFydERhdGFcIiwgXCIgQ2hhcnRcIil9XHJcbi8vICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgICAgKSl9XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTMvNCBiZy1ncmF5LTEwMCBwLTUgb3ZlcmZsb3ctYXV0b1wiPlxyXG4vLyAgICAgICAgIHtsb2FkaW5nID8gKFxyXG4vLyAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBoLWZ1bGxcIj5cclxuLy8gICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGlubmVyLWJvcmRlciBhbmltYXRlLXNwaW4gYm9yZGVyLXQtNCBib3JkZXItYmx1ZS01MDAgcm91bmRlZC1mdWxsIHctMTIgaC0xMlwiPjwvZGl2PlxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgKSA6IChcclxuLy8gICAgICAgICAgIHNlbGVjdGVkQ2hhcnQgJiYgcmVuZGVyQ2hhcnQoc2VsZWN0ZWRDaGFydCwgeyBsaW5lQ2hhcnREYXRhOiBMaW5lLCBiYXJDaGFydERhdGE6IEJhciwgc2NhdHRlckNoYXJ0RGF0YTogU2NhdHRlciwgcGllQ2hhcnREYXRhOiBQaWUsIGRvbnV0Q2hhcnREYXRhOiBEb3VnaG51dCB9W3NlbGVjdGVkQ2hhcnRdKVxyXG4vLyAgICAgICAgICl9XHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC00IGZsZXhcIj5cclxuLy8gICAgICAgICAgIDxpbnB1dFxyXG4vLyAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXHJcbi8vICAgICAgICAgICAgIHZhbHVlPXtpbnB1dFZhbHVlfVxyXG4vLyAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldElucHV0VmFsdWUoZS50YXJnZXQudmFsdWUpfVxyXG4vLyAgICAgICAgICAgICBjbGFzc05hbWU9XCJib3JkZXIgcC0yIGZsZXgtZ3JvdyBtci0yIHJvdW5kZWRcIlxyXG4vLyAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkVudGVyIHlvdXIgdGV4dCBoZXJlXCJcclxuLy8gICAgICAgICAgIC8+XHJcbi8vICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2hhbmRsZVNlbmR9IGNsYXNzTmFtZT1cImJnLWdyZWVuLTUwMCB0ZXh0LXdoaXRlIHAtMiByb3VuZGVkXCI+XHJcbi8vICAgICAgICAgICAgIFNlbmRcclxuLy8gICAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtNCBwLTQgYm9yZGVyIGJvcmRlci1ncmF5LTMwMCByb3VuZGVkIGJnLXdoaXRlXCI+XHJcbi8vICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPkluc2lnaHRzPC9oMz5cclxuLy8gICAgICAgICAgIHtjb21iaW5lZEluc2lnaHRzID8gKFxyXG4vLyAgICAgICAgICAgICA8b2wgY2xhc3NOYW1lPVwibGlzdC1kZWNpbWFsIGxpc3QtaW5zaWRlIHRleHQtc20gdGV4dC1ncmF5LTcwMCBiZy1ncmF5LTEwMCBwLTIgcm91bmRlZCBvdmVyZmxvdy1hdXRvXCI+XHJcbi8vICAgICAgICAgICAgICAge2NvbWJpbmVkSW5zaWdodHMuc3BsaXQoJ1xcbicpLm1hcCgoaW5zaWdodCwgaW5kZXgpID0+IChcclxuLy8gICAgICAgICAgICAgICAgIDx1bCBrZXk9e2luZGV4fT57aW5zaWdodH08L3VsPlxyXG4vLyAgICAgICAgICAgICAgICkpfVxyXG4vLyAgICAgICAgICAgICA8L29sPlxyXG4vLyAgICAgICAgICAgKSA6IChcclxuLy8gICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTUwMFwiPk5vIGluc2lnaHRzIGF2YWlsYWJsZS48L3A+XHJcbi8vICAgICAgICAgICApfVxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlRG93bmxvYWRQREZ9IGNsYXNzTmFtZT1cImJnLXJlZC01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZCBtdC00XCI+XHJcbi8vICAgICAgICAgICBEb3dubG9hZCBhcyBQREZcclxuLy8gICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgPC9kaXY+XHJcbi8vICAgICA8L2Rpdj5cclxuLy8gICApO1xyXG4vLyB9XHJcblxyXG5cclxuXHJcblwidXNlIGNsaWVudFwiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYsIEF3YWl0ZWRSZWFjdE5vZGUsIEpTWEVsZW1lbnRDb25zdHJ1Y3RvciwgS2V5LCBSZWFjdEVsZW1lbnQsIFJlYWN0Tm9kZSwgUmVhY3RQb3J0YWwgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgQmFyLCBMaW5lLCBEb3VnaG51dCwgUGllLCBTY2F0dGVyIH0gZnJvbSBcInJlYWN0LWNoYXJ0anMtMlwiO1xyXG5pbXBvcnQgeyBDaGFydCBhcyBDaGFydEpTLCBDYXRlZ29yeVNjYWxlLCBMaW5lYXJTY2FsZSwgQmFyRWxlbWVudCwgTGluZUVsZW1lbnQsIFBvaW50RWxlbWVudCwgQXJjRWxlbWVudCwgVGl0bGUsIFRvb2x0aXAsIExlZ2VuZCB9IGZyb20gXCJjaGFydC5qc1wiO1xyXG5pbXBvcnQgeyBCc1VwbG9hZCB9IGZyb20gXCJyZWFjdC1pY29ucy9ic1wiO1xyXG5pbXBvcnQgem9vbVBsdWdpbiBmcm9tIFwiY2hhcnRqcy1wbHVnaW4tem9vbVwiO1xyXG5pbXBvcnQgaHRtbDJjYW52YXMgZnJvbSBcImh0bWwyY2FudmFzXCI7XHJcbmltcG9ydCBqc1BERiBmcm9tIFwianNwZGZcIjtcclxuaW1wb3J0IENoYXJ0IGZyb20gXCJyZWFjdC1hcGV4Y2hhcnRzXCI7XHJcbkNoYXJ0SlMucmVnaXN0ZXIoQ2F0ZWdvcnlTY2FsZSwgTGluZWFyU2NhbGUsIEJhckVsZW1lbnQsIExpbmVFbGVtZW50LCBQb2ludEVsZW1lbnQsIEFyY0VsZW1lbnQsIFRpdGxlLCBUb29sdGlwLCBMZWdlbmQsIHpvb21QbHVnaW4pO1xyXG5cclxuaW50ZXJmYWNlIENoYXJ0RGF0YSB7XHJcbiAgbGFiZWxzOiBzdHJpbmdbXTtcclxuICBkYXRhc2V0czoge1xyXG4gICAgbGFiZWw6IHN0cmluZztcclxuICAgIGRhdGE6IG51bWJlcltdO1xyXG4gICAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nIHwgc3RyaW5nW107XHJcbiAgICBib3JkZXJDb2xvcj86IHN0cmluZztcclxuICAgIGZpbGw/OiBib29sZWFuO1xyXG4gIH1bXVxyXG4gIG1ldGE/OiB7XHJcbiAgICBoZWFkZXI6IHN0cmluZztcclxuICAgIHZhbHVlTmFtZTogc3RyaW5nO1xyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhc2hib2FyZCgpIHtcclxuICBjb25zdCBbY2hhcnREYXRhLCBzZXRDaGFydERhdGFdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgQ2hhcnREYXRhIHwgbnVsbD4+KHtcclxuICAgIHNjYXR0ZXJDaGFydERhdGE6IG51bGwsXHJcbiAgICBwaWVDaGFydERhdGE6IG51bGwsXHJcbiAgICBkb251dENoYXJ0RGF0YTogbnVsbCxcclxuICAgIGxpbmVDaGFydERhdGE6IG51bGwsXHJcbiAgICBiYXJDaGFydERhdGE6IG51bGwsXHJcbiAgfSk7XHJcbiAgY29uc3QgW3NlbGVjdGVkRmlsZSwgc2V0U2VsZWN0ZWRGaWxlXSA9IHVzZVN0YXRlPEZpbGUgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBbc2VsZWN0ZWRDaGFydCwgc2V0U2VsZWN0ZWRDaGFydF0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwibGluZUNoYXJ0RGF0YVwiKTtcclxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcbiAgY29uc3QgW2NoYXJ0V2lkdGgsIHNldENoYXJ0V2lkdGhdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcclxuICBjb25zdCBbaW5wdXRWYWx1ZSwgc2V0SW5wdXRWYWx1ZV0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiXCIpO1xyXG4gIGNvbnN0IFtzdG9yZWRQcm9jZXNzZWREYXRhLCBzZXRTdG9yZWRQcm9jZXNzZWREYXRhXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7IC8vIE5ldyBzdGF0ZSB0byBzdG9yZSBwcm9jZXNzZWQgZGF0YVxyXG4gIGNvbnN0IFtjb21iaW5lZEluc2lnaHRzLCBzZXRDb21iaW5lZEluc2lnaHRzXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7XHJcbiAgY29uc3QgY2hhcnRSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpOyAvLyBSZWYgZm9yIHRoZSBjaGFydCBjb250YWluZXJcclxuXHJcbiAgY29uc3QgaGFuZGxlRmlsZUNoYW5nZSA9IChldmVudDogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcclxuICAgIHNldFNlbGVjdGVkRmlsZShldmVudC50YXJnZXQuZmlsZXM/LlswXSB8fCBudWxsKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVTdWJtaXQgPSBhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAoIXNlbGVjdGVkRmlsZSkgcmV0dXJuO1xyXG4gICAgc2V0TG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4gICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBzZWxlY3RlZEZpbGUpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwOi8vbG9jYWxob3N0OjMwMTIvYXBpL2FuYWx5emUtZXhjZWxcIiwge1xyXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgYm9keTogZm9ybURhdGEsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGUuXCIpO1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIGNvbnN0IGNvbWJpbmVkSW5zaWdodHMgPSByZXN1bHQuZGF0YT8uY29tYmluZWRJbnNpZ2h0cztcclxuICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHJlc3VsdC5kYXRhPy5wcm9jZXNzZWREYXRhO1xyXG5cclxuICAgICAgaWYgKCFwcm9jZXNzZWREYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZS5cIik7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwicHJvY2Vzc2VkRGF0YVwiLCBwcm9jZXNzZWREYXRhKTtcclxuXHJcbiAgICAgIHNldFN0b3JlZFByb2Nlc3NlZERhdGEocHJvY2Vzc2VkRGF0YSk7IC8vIFN0b3JlIHRoZSBwcm9jZXNzZWQgZGF0YVxyXG4gICAgICBzZXRDb21iaW5lZEluc2lnaHRzKGNvbWJpbmVkSW5zaWdodHMpO1xyXG4gICAgICBjb25zdCBsaWdodENvbG9ycyA9IFtcclxuICAgICAgICBcInJnYmEoMTczLCAyMTYsIDIzMCwgMC42KVwiLFxyXG4gICAgICAgIFwicmdiYSgxNDQsIDIzOCwgMTQ0LCAwLjYpXCIsXHJcbiAgICAgICAgXCJyZ2JhKDI1NSwgMTgyLCAxOTMsIDAuNilcIixcclxuICAgICAgICBcInJnYmEoMjU1LCAyMjgsIDE4MSwgMC42KVwiLFxyXG4gICAgICAgIFwicmdiYSgyMjEsIDE2MCwgMjIxLCAwLjYpXCIsXHJcbiAgICAgICAgXCJyZ2JhKDI0MCwgMjMwLCAxNDAsIDAuNilcIixcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGNvbnN0IGdlbmVyYXRlQ2hhcnREYXRhID0gKGNoYXJ0VHlwZTogc3RyaW5nKTogQ2hhcnREYXRhIHwgbnVsbCA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hhcnRJbmZvID0gcHJvY2Vzc2VkRGF0YVtjaGFydFR5cGVdPy5bMF07XHJcbiAgICAgICAgaWYgKCFjaGFydEluZm8pIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBjb25zdCBsYWJlbHMgPSBPYmplY3Qua2V5cyhjaGFydEluZm8uZGF0YSk7XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhjaGFydEluZm8uZGF0YSk7XHJcbmNvbnNvbGUubG9nKFwiY2hhcnRUeXBlXCIsY2hhcnRUeXBlKTtcclxuXHJcbiAgICAgICAgbGV0IGNoYXJ0V2lkdGggPSAwO1xyXG4gICAgICAgIGlmIChbXCJMaW5lIENoYXJ0XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSkpIHtcclxuICAgICAgICAgIGNoYXJ0V2lkdGggPSBsYWJlbHMubGVuZ3RoICogMTUwO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoW1wiQmFyIENoYXJ0XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSkpIHtcclxuICAgICAgICAgIGNoYXJ0V2lkdGggPSBsYWJlbHMubGVuZ3RoICogMTUwOyAvLyBBZGp1c3QgdGhlIHdpZHRoIGZvciBiYXIgY2hhcnRcclxuICAgICAgICB9IFxyXG4gICAgICAgIGVsc2UgaWYgKFtcIlNjYXR0ZXIgUGxvdFwiXS5pbmNsdWRlcyhjaGFydFR5cGUpKSB7XHJcbiAgICAgICAgICBjaGFydFdpZHRoID0gbGFiZWxzLmxlbmd0aCAqIDE1MDsgLy8gQWRqdXN0IHRoZSB3aWR0aCBmb3IgYmFyIGNoYXJ0XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgY2hhcnRXaWR0aCA9IDQwMDsgLy8gRGVmYXVsdCB3aWR0aCBmb3Igb3RoZXIgY2hhcnQgdHlwZXNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldENoYXJ0V2lkdGgoY2hhcnRXaWR0aCk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBsYWJlbHMsXHJcbiAgICAgICAgICBkYXRhc2V0czogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgbGFiZWw6IGNoYXJ0SW5mby5sYWJlbCB8fCBjaGFydFR5cGUsXHJcbiAgICAgICAgICAgICAgZGF0YTogdmFsdWVzIGFzIG51bWJlcltdLFxyXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogW1wiUGllIENoYXJ0XCIsIFwiRG9udXQgQ2hhcnRcIiwgXCJCYXIgQ2hhcnRcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKVxyXG4gICAgICAgICAgICAgICAgPyBsaWdodENvbG9ycy5zbGljZSgwLCBsYWJlbHMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgOiBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMC42KVwiLFxyXG4gICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpID8gXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDEpXCIgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgZmlsbDogIWNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIiksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgICAgbWV0YToge1xyXG4gICAgICAgICAgICBoZWFkZXI6IGNoYXJ0SW5mby5oZWFkZXIgfHwgXCJkZWZhdWx0X2hlYWRlclwiLFxyXG4gICAgICAgICAgICB2YWx1ZU5hbWU6IGNoYXJ0SW5mby52YWx1ZU5hbWUgfHwgXCJkZWZhdWx0X3ZhbHVlTmFtZVwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgc2V0Q2hhcnREYXRhKHtcclxuICAgICAgICBzY2F0dGVyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlNjYXR0ZXIgUGxvdFwiKSxcclxuICAgICAgICBwaWVDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiUGllIENoYXJ0XCIpLFxyXG4gICAgICAgIGRvbnV0Q2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkRvbnV0IENoYXJ0XCIpLFxyXG4gICAgICAgIGxpbmVDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiTGluZSBDaGFydFwiKSxcclxuICAgICAgICBiYXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiQmFyIENoYXJ0XCIpLFxyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZTpcIiwgZXJyb3IpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlU2VuZCA9IGFzeW5jICgpID0+IHtcclxuICAgIGlmICghaW5wdXRWYWx1ZSkgcmV0dXJuO1xyXG4gIFxyXG4gICAgY29uc3QgZ3JhcGhEYXRhID0gY2hhcnREYXRhW3NlbGVjdGVkQ2hhcnRdO1xyXG4gICAgaWYgKCFncmFwaERhdGEpIHJldHVybjtcclxuICBcclxuICAgIGNvbnN0IGxhYmVscyA9IGdyYXBoRGF0YS5sYWJlbHM7XHJcbiAgICBjb25zdCB2YWx1ZXMgPSBncmFwaERhdGEuZGF0YXNldHNbMF0uZGF0YTtcclxuICBcclxuICAgIGNvbnN0IGRhdGFPYmplY3QgPSBsYWJlbHMucmVkdWNlKChvYmo6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0sIGxhYmVsLCBpbmRleCkgPT4ge1xyXG4gICAgICBvYmpbbGFiZWxdID0gdmFsdWVzW2luZGV4XTtcclxuICAgICAgcmV0dXJuIG9iajtcclxuICAgIH0sIHt9KTtcclxuICBcclxuICAgIGNvbnN0IGNoYXJ0VHlwZU1hcHBpbmc6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XHJcbiAgICAgIGxpbmVDaGFydERhdGE6IFwiTGluZSBDaGFydFwiLFxyXG4gICAgICBwaWVDaGFydERhdGE6IFwiUGllIENoYXJ0XCIsXHJcbiAgICAgIGRvbnV0Q2hhcnREYXRhOiBcIkRvbnV0IENoYXJ0XCIsXHJcbiAgICAgIGJhckNoYXJ0RGF0YTogXCJCYXIgQ2hhcnRcIixcclxuICAgICAgc2NhdHRlckNoYXJ0RGF0YTogXCJTY2F0dGVyIFBsb3RcIixcclxuICAgIH07XHJcbiAgXHJcbiAgICBjb25zdCBzZWxlY3RlZENoYXJ0VHlwZSA9IGNoYXJ0VHlwZU1hcHBpbmdbc2VsZWN0ZWRDaGFydF0gfHwgc2VsZWN0ZWRDaGFydDtcclxuICBcclxuICAgIC8vIEZpbHRlciB0aGUgc3RvcmVkIHByb2Nlc3NlZCBkYXRhIHRvIGluY2x1ZGUgb25seSB0aGUgc2VsZWN0ZWQgY2hhcnQncyBkYXRhXHJcbiAgICBjb25zdCBmaWx0ZXJlZFByb2Nlc3NlZERhdGEgPSB7XHJcbiAgICAgIFtzZWxlY3RlZENoYXJ0VHlwZV06IHN0b3JlZFByb2Nlc3NlZERhdGFbc2VsZWN0ZWRDaGFydFR5cGVdLFxyXG4gICAgfTtcclxuICBcclxuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xyXG4gICAgICBxdWVzdGlvbjogaW5wdXRWYWx1ZSxcclxuICAgICAgcHJvY2Vzc2VkRGF0YToge1xyXG4gICAgICAgIC8vIEluY2x1ZGUgdGhlIHN0b3JlZCBwcm9jZXNzZWQgZGF0YVxyXG4gICAgICAgIFtzZWxlY3RlZENoYXJ0VHlwZV06IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgaGVhZGVyOiBncmFwaERhdGEubWV0YT8uaGVhZGVyIHx8IFwiZGVmYXVsdF9oZWFkZXJcIixcclxuICAgICAgICAgICAgdmFsdWVOYW1lOiBncmFwaERhdGEubWV0YT8udmFsdWVOYW1lIHx8IFwiZGVmYXVsdF92YWx1ZU5hbWVcIixcclxuICAgICAgICAgICAgbGFiZWw6IGdyYXBoRGF0YS5kYXRhc2V0c1swXS5sYWJlbCxcclxuICAgICAgICAgICAgZGF0YTogZmlsdGVyZWRQcm9jZXNzZWREYXRhW3NlbGVjdGVkQ2hhcnRUeXBlXT8uWzBdPy5kYXRhLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcbiAgICAgICAgYGh0dHA6Ly9sb2NhbGhvc3Q6MzAxMi9hcGkvYW5zd2VyLWFuYWx5emUtZXhjZWw/cXVlc3Rpb249JHtlbmNvZGVVUklDb21wb25lbnQoaW5wdXRWYWx1ZSl9YCxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxyXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuICBcclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGUuXCIpO1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSByZXN1bHQuZGF0YT8ucHJvY2Vzc2VkRGF0YTtcclxuICBcclxuICAgICAgaWYgKCFwcm9jZXNzZWREYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZS5cIik7XHJcbiAgXHJcbiAgICAgIGNvbnN0IGdlbmVyYXRlQ2hhcnREYXRhID0gKGNoYXJ0VHlwZTogc3RyaW5nKTogQ2hhcnREYXRhIHwgbnVsbCA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hhcnRJbmZvID0gcHJvY2Vzc2VkRGF0YVtjaGFydFR5cGVdPy5bMF07IC8vIFVzZSBvbmx5IEFQSSByZXNwb25zZSBkYXRhXHJcbiAgICAgICAgaWYgKCFjaGFydEluZm8pIHJldHVybiBudWxsO1xyXG4gIFxyXG4gICAgICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5rZXlzKGNoYXJ0SW5mby5kYXRhKTtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGNoYXJ0SW5mby5kYXRhKTtcclxuICAgICAgICBsZXQgY2hhcnRXaWR0aCA9IDA7XHJcbiAgICAgICAgaWYgKFtcIkxpbmUgQ2hhcnRcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKSkge1xyXG4gICAgICAgICAgY2hhcnRXaWR0aCA9IGxhYmVscy5sZW5ndGggKiAxNTA7XHJcbiAgICAgICAgfSBlbHNlIGlmIChbXCJCYXIgQ2hhcnRcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKSkge1xyXG4gICAgICAgICAgY2hhcnRXaWR0aCA9IGxhYmVscy5sZW5ndGggKiAxNTA7IC8vIEFkanVzdCB0aGUgd2lkdGggZm9yIGJhciBjaGFydFxyXG4gICAgICAgIH0gXHJcbiAgICAgICAgZWxzZSBpZiAoW1wiU2NhdHRlciBQbG90XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSkpIHtcclxuICAgICAgICAgIGNoYXJ0V2lkdGggPSBsYWJlbHMubGVuZ3RoICogMTUwOyAvLyBBZGp1c3QgdGhlIHdpZHRoIGZvciBiYXIgY2hhcnRcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICBjaGFydFdpZHRoID0gNDAwOyAvLyBEZWZhdWx0IHdpZHRoIGZvciBvdGhlciBjaGFydCB0eXBlc1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRDaGFydFdpZHRoKGNoYXJ0V2lkdGgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBsYWJlbHMsXHJcbiAgICAgICAgICBkYXRhc2V0czogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgbGFiZWw6IGNoYXJ0SW5mby5sYWJlbCB8fCBjaGFydFR5cGUsXHJcbiAgICAgICAgICAgICAgZGF0YTogdmFsdWVzIGFzIG51bWJlcltdLFxyXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogW1wiUGllIENoYXJ0XCIsIFwiRG9udXQgQ2hhcnRcIiwgXCJCYXIgQ2hhcnRcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKVxyXG4gICAgICAgICAgICAgICAgPyBbXCJyZ2JhKDE3MywgMjE2LCAyMzAsIDAuNilcIiwgXCJyZ2JhKDE0NCwgMjM4LCAxNDQsIDAuNilcIiwgXCJyZ2JhKDI1NSwgMTgyLCAxOTMsIDAuNilcIl1cclxuICAgICAgICAgICAgICAgIDogXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDAuNilcIixcclxuICAgICAgICAgICAgICBib3JkZXJDb2xvcjogY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSA/IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAxKVwiIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgIGZpbGw6ICFjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgXSxcclxuICAgICAgICAgIG1ldGE6IHtcclxuICAgICAgICAgICAgaGVhZGVyOiBjaGFydEluZm8uaGVhZGVyIHx8IFwiZGVmYXVsdF9oZWFkZXJcIixcclxuICAgICAgICAgICAgdmFsdWVOYW1lOiBjaGFydEluZm8udmFsdWVOYW1lIHx8IFwiZGVmYXVsdF92YWx1ZU5hbWVcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgfTtcclxuICBcclxuICAgICAgLy8gT25seSB1cGRhdGUgY2hhcnREYXRhIHdpdGhvdXQgc3RvcmluZyBpbiBzdG9yZWRQcm9jZXNzZWREYXRhXHJcbiAgICAgIHNldENoYXJ0RGF0YSgocHJldkNoYXJ0RGF0YSkgPT4gKHtcclxuICAgICAgICAuLi5wcmV2Q2hhcnREYXRhLFxyXG4gICAgICAgIFtzZWxlY3RlZENoYXJ0XTogZ2VuZXJhdGVDaGFydERhdGEoc2VsZWN0ZWRDaGFydFR5cGUpLFxyXG4gICAgICB9KSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2VuZGluZyByZXF1ZXN0OlwiLCBlcnJvcik7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBnZXRDaGFydE9wdGlvbnMgPSAodHlwZTogc3RyaW5nKSA9PiAoe1xyXG4gICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxyXG4gICAgc2NhbGVzOiBbXCJQaWUgQ2hhcnRcIiwgXCJEb251dCBDaGFydFwiXS5pbmNsdWRlcyh0eXBlKVxyXG4gICAgICA/IHt9XHJcbiAgICAgIDoge1xyXG4gICAgICAgICAgeDoge1xyXG4gICAgICAgICAgICB0aWNrczoge1xyXG4gICAgICAgICAgICAgIGF1dG9Ta2lwOiBmYWxzZSxcclxuICAgICAgICAgICAgICBtYXhSb3RhdGlvbjogW1wiQmFyIENoYXJ0XCIsIFwiU2NhdHRlciBQbG90XCJdLmluY2x1ZGVzKHR5cGUpID8gMjAgOiAxMDAsXHJcbiAgICAgICAgICAgICAgbWluUm90YXRpb246IFtcIkJhciBDaGFydFwiLCBcIlNjYXR0ZXIgUGxvdFwiXS5pbmNsdWRlcyh0eXBlKSA/IDAgOiA5MCxcclxuICAgICAgICAgICAgICBhdXRvU2tpcFBhZGRpbmc6IDIwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBncmlkOiB7XHJcbiAgICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuICAgICAgICAgICAgICBkcmF3VGlja3M6IGZhbHNlLFxyXG4gICAgICAgICAgICAgIHRpY2tMZW5ndGg6IDEwMCxcclxuICAgICAgICAgICAgICBsaW5lV2lkdGg6IDEsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgeToge1xyXG4gICAgICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcclxuICAgICAgICAgICAgdGlja3M6IHsgcHJlY2lzaW9uOiAwIH0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICBwbHVnaW5zOiB7XHJcbiAgICAgIGxlZ2VuZDogeyBkaXNwbGF5OiB0cnVlLCBwb3NpdGlvbjogXCJ0b3BcIiB9LFxyXG4gICAgICB0b29sdGlwOiB7IGVuYWJsZWQ6IHRydWUgfSxcclxuICAgIH0sXHJcbiAgfSk7XHJcbiAgXHJcbiAgY29uc3QgcmVuZGVyQ2hhcnQgPSAodHlwZTogc3RyaW5nLCBDaGFydENvbXBvbmVudDogYW55KSA9PiB7XHJcbiAgICBjb25zdCBkYXRhID0gY2hhcnREYXRhPy5bdHlwZV07IC8vIFVzZSBvcHRpb25hbCBjaGFpbmluZ1xyXG4gIFxyXG4gICAgaWYgKCFsb2FkaW5nICYmIGRhdGEpIHtcclxuICAgICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQgcC00IGJvcmRlciByb3VuZGVkIHNoYWRvdy1zbVwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgb3ZlcmZsb3cteC1hdXRvXCI+XHJcbiAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLCAvLyBGdWxsIHdpZHRoIGJ5IGRlZmF1bHRcclxuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBbXCJMaW5lIENoYXJ0XCIsIFwiQmFyIENoYXJ0XCJdLmluY2x1ZGVzKHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgID8gXCI2MDBweFwiIC8vIE1pbmltdW0gd2lkdGggZm9yIHNjcm9sbGFibGUgY2hhcnRzXHJcbiAgICAgICAgICAgICAgICAgIDogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiNDAwcHhcIiwgLy8gRml4ZWQgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IFwiMCBhdXRvXCIsIC8vIENlbnRlciB0aGUgY2hhcnRcclxuICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInJlbGF0aXZlXCJcclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbFwiPlxyXG4gICAgICAgICAgICAgICAgPENoYXJ0Q29tcG9uZW50IFxyXG4gICAgICAgICAgICAgICAgICBkYXRhPXtkYXRhfSBcclxuICAgICAgICAgICAgICAgICAgb3B0aW9ucz17e1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmdldENoYXJ0T3B0aW9ucyh0eXBlKSxcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLCAvLyBBbGxvd3MgY2hhcnQgdG8gZmlsbCBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgfX0gXHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfTtcclxuICBcclxuICAvLyBPcHRpb25hbDogQWRkIENTUyB0byB5b3VyIHN0eWxlc2hlZXRcclxuICBjb25zdCByZXNwb25zaXZlQ2hhcnRTdHlsZXMgPSBgXHJcbiAgICBAbWVkaWEgKG1heC13aWR0aDogNjQwcHgpIHtcclxuICAgICAgLmNhcmQge1xyXG4gICAgICAgIHBhZGRpbmc6IDFyZW07XHJcbiAgICAgIH1cclxuICAgICAgLmNhcmQgPiBkaXYgPiBkaXYge1xyXG4gICAgICAgIGhlaWdodDogMzAwcHg7IC8qIFNtYWxsZXIgaGVpZ2h0IG9uIG1vYmlsZSAqL1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIEBtZWRpYSAobWluLXdpZHRoOiA2NDFweCkgYW5kIChtYXgtd2lkdGg6IDEwMjRweCkge1xyXG4gICAgICAuY2FyZCA+IGRpdiA+IGRpdiB7XHJcbiAgICAgICAgaGVpZ2h0OiAzNTBweDsgLyogTWVkaXVtIGhlaWdodCBmb3IgdGFibGV0cyAqL1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgYDtcclxuICBcclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIG1kOmZsZXgtcm93IGgtc2NyZWVuIGJvcmRlciBib3JkZXItYmxhY2tcIj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0xLzQgYmctd2hpdGUgcC01IGJvcmRlci10IG1kOmJvcmRlci1sIG1kOmJvcmRlci1ibGFja1wiPlxyXG4gICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+VXBsb2FkIEZpbGU8L2gyPlxyXG4gICAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIG9uQ2hhbmdlPXtoYW5kbGVGaWxlQ2hhbmdlfSBjbGFzc05hbWU9XCJib3JkZXIgcC0yIHctZnVsbFwiIC8+XHJcbiAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtoYW5kbGVTdWJtaXR9IGNsYXNzTmFtZT1cImJnLWJsdWUtNTAwIHRleHQtd2hpdGUgcC0yIHJvdW5kZWQgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgbXQtNFwiPlxyXG4gICAgICAgICAgPEJzVXBsb2FkIGNsYXNzTmFtZT1cIm1yLTJcIiAvPiBTdWJtaXRcclxuICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgc3BhY2UteS0yIG10LTRcIj5cclxuICAgICAgICAgIHtbXCJsaW5lQ2hhcnREYXRhXCIsIFwiYmFyQ2hhcnREYXRhXCIsIFwic2NhdHRlckNoYXJ0RGF0YVwiLCBcInBpZUNoYXJ0RGF0YVwiLCBcImRvbnV0Q2hhcnREYXRhXCJdLm1hcCgodHlwZSkgPT4gKFxyXG4gICAgICAgICAgICA8YnV0dG9uIGtleT17dHlwZX0gb25DbGljaz17KCkgPT4gc2V0U2VsZWN0ZWRDaGFydCh0eXBlKX0gY2xhc3NOYW1lPVwicC0yIGJnLWdyYXktMzAwIHJvdW5kZWQgaG92ZXI6YmctZ3JheS00MDBcIj5cclxuICAgICAgICAgICAgICB7dHlwZS5yZXBsYWNlKFwiQ2hhcnREYXRhXCIsIFwiIENoYXJ0XCIpfVxyXG4gICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICkpfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0zLzQgYmctZ3JheS0xMDAgcC01IG92ZXJmbG93LWF1dG9cIj5cclxuICAgICAgICB7bG9hZGluZyA/IChcclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgaC1mdWxsXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3Bpbm5lci1ib3JkZXIgYW5pbWF0ZS1zcGluIGJvcmRlci10LTQgYm9yZGVyLWJsdWUtNTAwIHJvdW5kZWQtZnVsbCB3LTEyIGgtMTJcIj48L2Rpdj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICkgOiAoXHJcbiAgICAgICAgICBzZWxlY3RlZENoYXJ0ICYmIHJlbmRlckNoYXJ0KHNlbGVjdGVkQ2hhcnQsIHsgbGluZUNoYXJ0RGF0YTogTGluZSwgYmFyQ2hhcnREYXRhOiBCYXIsIHNjYXR0ZXJDaGFydERhdGE6IFNjYXR0ZXIsIHBpZUNoYXJ0RGF0YTogUGllLCBkb251dENoYXJ0RGF0YTogRG91Z2hudXQgfVtzZWxlY3RlZENoYXJ0XSlcclxuICAgICAgICApfVxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtNCBmbGV4XCI+XHJcbiAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgdHlwZT1cInRleHRcIlxyXG4gICAgICAgICAgICB2YWx1ZT17aW5wdXRWYWx1ZX1cclxuICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRJbnB1dFZhbHVlKGUudGFyZ2V0LnZhbHVlKX1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiYm9yZGVyIHAtMiBmbGV4LWdyb3cgbXItMiByb3VuZGVkXCJcclxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJFbnRlciB5b3VyIHRleHQgaGVyZVwiXHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtoYW5kbGVTZW5kfSBjbGFzc05hbWU9XCJiZy1ncmVlbi01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZFwiPlxyXG4gICAgICAgICAgICBTZW5kXHJcbiAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTQgcC00IGJvcmRlciBib3JkZXItZ3JheS0zMDAgcm91bmRlZCBiZy13aGl0ZVwiPlxyXG4gICAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5JbnNpZ2h0czwvaDM+XHJcbiAgICAgICAgICB7Y29tYmluZWRJbnNpZ2h0cyA/IChcclxuICAgICAgICAgICAgPG9sIGNsYXNzTmFtZT1cImxpc3QtZGVjaW1hbCBsaXN0LWluc2lkZSB0ZXh0LXNtIHRleHQtZ3JheS03MDAgYmctZ3JheS0xMDAgcC0yIHJvdW5kZWQgb3ZlcmZsb3ctYXV0b1wiPlxyXG4gICAgICAgICAgICAgIHtjb21iaW5lZEluc2lnaHRzLnNwbGl0KCdcXG4nKS5tYXAoKGluc2lnaHQ6IHN0cmluZyB8IG51bWJlciB8IGJpZ2ludCB8IGJvb2xlYW4gfCBSZWFjdEVsZW1lbnQ8YW55LCBzdHJpbmcgfCBKU1hFbGVtZW50Q29uc3RydWN0b3I8YW55Pj4gfCBJdGVyYWJsZTxSZWFjdE5vZGU+IHwgUmVhY3RQb3J0YWwgfCBQcm9taXNlPEF3YWl0ZWRSZWFjdE5vZGU+IHwgbnVsbCB8IHVuZGVmaW5lZCwgaW5kZXg6IEtleSB8IG51bGwgfCB1bmRlZmluZWQpID0+IChcclxuICAgICAgICAgICAgICAgIDx1bCBrZXk9e2luZGV4fT57aW5zaWdodH08L3VsPlxyXG4gICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICA8L29sPlxyXG4gICAgICAgICAgKSA6IChcclxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTUwMFwiPk5vIGluc2lnaHRzIGF2YWlsYWJsZS48L3A+XHJcbiAgICAgICAgICApfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn0iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VSZWYiLCJCYXIiLCJMaW5lIiwiRG91Z2hudXQiLCJQaWUiLCJTY2F0dGVyIiwiQ2hhcnQiLCJDaGFydEpTIiwiQ2F0ZWdvcnlTY2FsZSIsIkxpbmVhclNjYWxlIiwiQmFyRWxlbWVudCIsIkxpbmVFbGVtZW50IiwiUG9pbnRFbGVtZW50IiwiQXJjRWxlbWVudCIsIlRpdGxlIiwiVG9vbHRpcCIsIkxlZ2VuZCIsIkJzVXBsb2FkIiwiem9vbVBsdWdpbiIsInJlZ2lzdGVyIiwiRGFzaGJvYXJkIiwiY2hhcnREYXRhIiwic2V0Q2hhcnREYXRhIiwic2NhdHRlckNoYXJ0RGF0YSIsInBpZUNoYXJ0RGF0YSIsImRvbnV0Q2hhcnREYXRhIiwibGluZUNoYXJ0RGF0YSIsImJhckNoYXJ0RGF0YSIsInNlbGVjdGVkRmlsZSIsInNldFNlbGVjdGVkRmlsZSIsInNlbGVjdGVkQ2hhcnQiLCJzZXRTZWxlY3RlZENoYXJ0IiwibG9hZGluZyIsInNldExvYWRpbmciLCJjaGFydFdpZHRoIiwic2V0Q2hhcnRXaWR0aCIsImlucHV0VmFsdWUiLCJzZXRJbnB1dFZhbHVlIiwic3RvcmVkUHJvY2Vzc2VkRGF0YSIsInNldFN0b3JlZFByb2Nlc3NlZERhdGEiLCJjb21iaW5lZEluc2lnaHRzIiwic2V0Q29tYmluZWRJbnNpZ2h0cyIsImNoYXJ0UmVmIiwiaGFuZGxlRmlsZUNoYW5nZSIsImV2ZW50IiwidGFyZ2V0IiwiZmlsZXMiLCJoYW5kbGVTdWJtaXQiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwicmVzdWx0IiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImJvZHkiLCJvayIsIkVycm9yIiwianNvbiIsImRhdGEiLCJwcm9jZXNzZWREYXRhIiwiY29uc29sZSIsImxvZyIsImxpZ2h0Q29sb3JzIiwiZ2VuZXJhdGVDaGFydERhdGEiLCJjaGFydFR5cGUiLCJjaGFydEluZm8iLCJsYWJlbHMiLCJPYmplY3QiLCJrZXlzIiwidmFsdWVzIiwiaW5jbHVkZXMiLCJsZW5ndGgiLCJkYXRhc2V0cyIsImxhYmVsIiwiYmFja2dyb3VuZENvbG9yIiwic2xpY2UiLCJib3JkZXJDb2xvciIsInVuZGVmaW5lZCIsImZpbGwiLCJtZXRhIiwiaGVhZGVyIiwidmFsdWVOYW1lIiwiZXJyb3IiLCJoYW5kbGVTZW5kIiwiZ3JhcGhEYXRhIiwiZmlsdGVyZWRQcm9jZXNzZWREYXRhIiwiZGF0YU9iamVjdCIsInJlZHVjZSIsIm9iaiIsImluZGV4IiwiY2hhcnRUeXBlTWFwcGluZyIsInNlbGVjdGVkQ2hhcnRUeXBlIiwicmVxdWVzdEJvZHkiLCJxdWVzdGlvbiIsImVuY29kZVVSSUNvbXBvbmVudCIsImhlYWRlcnMiLCJKU09OIiwic3RyaW5naWZ5IiwicHJldkNoYXJ0RGF0YSIsImdldENoYXJ0T3B0aW9ucyIsInR5cGUiLCJyZXNwb25zaXZlIiwibWFpbnRhaW5Bc3BlY3RSYXRpbyIsInNjYWxlcyIsIngiLCJ0aWNrcyIsImF1dG9Ta2lwIiwibWF4Um90YXRpb24iLCJtaW5Sb3RhdGlvbiIsImF1dG9Ta2lwUGFkZGluZyIsImdyaWQiLCJkaXNwbGF5IiwiZHJhd1RpY2tzIiwidGlja0xlbmd0aCIsImxpbmVXaWR0aCIsInkiLCJiZWdpbkF0WmVybyIsInByZWNpc2lvbiIsInBsdWdpbnMiLCJsZWdlbmQiLCJwb3NpdGlvbiIsInRvb2x0aXAiLCJlbmFibGVkIiwicmVuZGVyQ2hhcnQiLCJDaGFydENvbXBvbmVudCIsImRpdiIsImNsYXNzTmFtZSIsInN0eWxlIiwid2lkdGgiLCJtaW5XaWR0aCIsImhlaWdodCIsIm1hcmdpbiIsIm9wdGlvbnMiLCJyZXNwb25zaXZlQ2hhcnRTdHlsZXMiLCJoMiIsImlucHV0Iiwib25DaGFuZ2UiLCJidXR0b24iLCJvbkNsaWNrIiwibWFwIiwicmVwbGFjZSIsInZhbHVlIiwiZSIsInBsYWNlaG9sZGVyIiwiaDMiLCJvbCIsInNwbGl0IiwiaW5zaWdodCIsInVsIiwicCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/pages/Upload/Upload.tsx\n"));

/***/ })

});