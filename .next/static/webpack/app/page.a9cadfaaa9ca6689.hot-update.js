"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/app/pages/Upload/Upload.tsx":
/*!*****************************************!*\
  !*** ./src/app/pages/Upload/Upload.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Dashboard)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! styled-jsx/style */ \"(app-pages-browser)/./node_modules/styled-jsx/style.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-chartjs-2 */ \"(app-pages-browser)/./node_modules/react-chartjs-2/dist/index.js\");\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! chart.js */ \"(app-pages-browser)/./node_modules/chart.js/dist/chart.js\");\n/* harmony import */ var _barrel_optimize_names_BsUpload_react_icons_bs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=BsUpload!=!react-icons/bs */ \"(app-pages-browser)/./node_modules/react-icons/bs/index.mjs\");\n/* harmony import */ var chartjs_plugin_zoom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! chartjs-plugin-zoom */ \"(app-pages-browser)/./node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js\");\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n// } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// ChartJS.register(\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n//   zoomPlugin\n// );\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string;\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[];\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const [selectedLabels, setSelectedLabels] = useState<string[]>([]);\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: chartType.includes(\"Bar\")\n//                 ? \"rgba(54, 162, 235, 0.5)\"\n//                 : \"rgba(255, 99, 132, 0.5)\",\n//               borderColor: chartType.includes(\"Line\")\n//                 ? \"rgba(255, 99, 132, 1)\"\n//                 : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   useEffect(() => {\n//     if (selectedChart && chartData[selectedChart]) {\n//       const baseLabels = chartData[selectedChart]?.labels || [];\n//       setChartWidth((selectedLabels.length || baseLabels.length) * 150);\n//     }\n//   }, [selectedChart, selectedLabels, chartData]);\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//           x: {\n//             ticks: {\n//               autoSkip: false,\n//               maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//               minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//               autoSkipPadding: 20,\n//             },\n//             grid: {\n//               display: true,\n//               drawTicks: false,\n//               tickLength: 100,\n//               lineWidth: 1\n//             },\n//           },\n//           y: {\n//             beginAtZero: true,\n//             ticks: {\n//               precision: 0,\n//             },\n//           },\n//         },\n//     plugins: {\n//       legend: {\n//         display: true,\n//         position: \"top\",\n//       },\n//       tooltip: {\n//         enabled: true,\n//       },\n//     },\n//   });\n//   const applyFilter = (data: ChartData | null) => {\n//     if (!data) return data;\n//     const filteredLabels = selectedLabels.length\n//       ? data.labels.filter(label => selectedLabels.includes(label))\n//       : data.labels;\n//     const filteredData = data.datasets.map(dataset => ({\n//       ...dataset,\n//       data: filteredLabels.map(label => dataset.data[data.labels.indexOf(label)])\n//     }));\n//     return {\n//       labels: filteredLabels,\n//       datasets: filteredData,\n//     };\n//   };\n//   const handleCheckboxChange = (label: string) => {\n//     setSelectedLabels(prev =>\n//       prev.includes(label)\n//         ? prev.filter(item => item !== label)\n//         : [...prev, label]\n//     );\n//   };\n//   const handleSelectAll = () => {\n//     if (selectedChart && chartData[selectedChart]) {\n//       setSelectedLabels(chartData[selectedChart]?.labels || []);\n//     }\n//   };\n//   const handleClearAll = () => {\n//     setSelectedLabels([]);\n//   };\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = applyFilter(chartData[type]);\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div\n//               style={{\n//                 minWidth: [\"lineChartData\", \"barChartData\"].includes(type)\n//                   ? `${chartWidth}px`\n//                   : \"auto\",\n//                 height: \"400px\",\n//               }}\n//             >\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button\n//           onClick={handleSubmit}\n//           className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\"\n//         >\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         {selectedChart && (\n//           <div className=\"mt-4\">\n//             <h3 className=\"font-semibold\">Filters</h3>\n//             <button onClick={handleSelectAll} className=\"bg-green-500 text-white px-2 py-1 rounded mt-2\">Select All</button>\n//             <button onClick={handleClearAll} className=\"bg-red-500 text-white px-2 py-1 rounded mt-2 ml-2\">Clear All</button>\n//             {chartData[selectedChart]?.labels.map(label => (\n//               <div key={label} className=\"flex items-center\">\n//                 <input\n//                   type=\"checkbox\"\n//                   checked={selectedLabels.includes(label)}\n//                   onChange={() => handleCheckboxChange(label)}\n//                 />\n//                 <label className=\"ml-2\">{label}</label>\n//               </div>\n//             ))}\n//           </div>\n//         )}\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map(\n//             (type) => (\n//               <button\n//                 key={type}\n//                 onClick={() => {\n//                   setSelectedChart(type);\n//                   setSelectedLabels([]);\n//                 }}\n//                 className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\"\n//               >\n//                 {type.replace(\"ChartData\", \" Chart\")}\n//               </button>\n//             )\n//           )}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           renderChart(selectedChart, {\n//             lineChartData: Line,\n//             barChartData: Bar,\n//             scatterChartData: Scatter,\n//             pieChartData: Pie,\n//             donutChartData: Doughnut,\n//           }[selectedChart])\n//         )}\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n// } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// import { log } from \"node:console\";\n// ChartJS.register(\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n//   zoomPlugin\n// );\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string;\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[];\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n// console.log(\"processedData\",processedData);\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//  console.log(\"labels.length \",chartType,labels.length );\n//  console.log(\"values.length \",chartType,values.length );\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: chartType.includes(\"Bar\")\n//                 ? \"rgba(54, 162, 235, 0.5)\"\n//                 : \"rgba(255, 99, 132, 0.5)\",\n//               borderColor: chartType.includes(\"Line\")\n//                 ? \"rgba(255, 99, 132, 1)\"\n//                 : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//         };\n//       };\n// console.log(\"generateChartData\",generateChartData);\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//         x: {\n//           ticks: {\n//             autoSkip: false,\n//             maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//         minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//             autoSkipPadding: 20,\n//           },\n//           grid: {\n//             display: true,\n//             drawTicks: false,\n//             tickLength: 100,\n//             lineWidth: 1\n//           },\n//         },\n//           y: {\n//             beginAtZero: true,\n//             ticks: {\n//               precision: 0,\n//             },\n//           },\n//         },\n//     plugins: {\n//       legend: {\n//         display: true,\n//         position: \"top\",\n//       },\n//       tooltip: {\n//         enabled: true,\n//       },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div\n//               style={{\n//                 minWidth: [\"lineChartData\", \"barChartData\"].includes(type)\n//                   ? `${chartWidth}px`\n//                   : \"auto\",\n//                 height: \"400px\",\n//               }}\n//             >\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button\n//           onClick={handleSubmit}\n//           className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\"\n//         >\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map(\n//             (type) => (\n//               <button\n//                 key={type}\n//                 onClick={() => setSelectedChart(type)}\n//                 className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\"\n//               >\n//                 {type.replace(\"ChartData\", \" Chart\")}\n//               </button>\n//             )\n//           )}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           renderChart(selectedChart, {\n//             lineChartData: Line,\n//             barChartData: Bar,\n//             scatterChartData: Scatter,\n//             pieChartData: Pie,\n//             donutChartData: Doughnut,\n//           }[selectedChart])\n//         )}\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n// } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// import { log } from \"node:console\";\n// ChartJS.register(\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n//   zoomPlugin\n// );\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string | string[];\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[];\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       const lightColors = [\n//         \"rgba(173, 216, 230, 0.6)\",\n//         \"rgba(144, 238, 144, 0.6)\",\n//         \"rgba(255, 182, 193, 0.6)\",\n//         \"rgba(255, 228, 181, 0.6)\",\n//         \"rgba(221, 160, 221, 0.6)\",\n//         \"rgba(240, 230, 140, 0.6)\",\n//       ];\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? lightColors.slice(0, labels.length)\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\")\n//                 ? \"rgba(135, 206, 250, 1)\"\n//                 : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n// x: {\n//   ticks: {\n//     autoSkip: false,\n//     maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n// minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//     autoSkipPadding: 20,\n//   },\n//   grid: {\n//     display: true,\n//     drawTicks: false,\n//     tickLength: 100,\n//     lineWidth: 1\n//   },\n// },\n//           y: {\n//             beginAtZero: true,\n//             ticks: {\n//               precision: 0,\n//             },\n//           },\n//         },\n//     plugins: {\n//       legend: {\n//         display: true,\n//         position: \"top\",\n//       },\n//       tooltip: {\n//         enabled: true,\n//       },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div\n//               style={{\n//                 minWidth: [\"lineChartData\", \"barChartData\"].includes(type)\n//                   ? `${chartWidth}px`\n//                   : \"auto\",\n//                 height: \"400px\",\n//               }}\n//             >\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button\n//           onClick={handleSubmit}\n//           className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\"\n//         >\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map(\n//             (type) => (\n//               <button\n//                 key={type}\n//                 onClick={() => setSelectedChart(type)}\n//                 className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\"\n//               >\n//                 {type.replace(\"ChartData\", \" Chart\")}\n//               </button>\n//             )\n//           )}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           renderChart(selectedChart, {\n//             lineChartData: Line,\n//             barChartData: Bar,\n//             scatterChartData: Scatter,\n//             pieChartData: Pie,\n//             donutChartData: Doughnut,\n//           }[selectedChart])\n//         )}\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n// } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// ChartJS.register(\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   LineElement,\n//   PointElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n//   zoomPlugin\n// );\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string | string[];\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[];\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const [inputValue, setInputValue] = useState<string>(\"\");\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       const lightColors = [\n//         \"rgba(173, 216, 230, 0.6)\",\n//         \"rgba(144, 238, 144, 0.6)\",\n//         \"rgba(255, 182, 193, 0.6)\",\n//         \"rgba(255, 228, 181, 0.6)\",\n//         \"rgba(221, 160, 221, 0.6)\",\n//         \"rgba(240, 230, 140, 0.6)\",\n//       ];\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? lightColors.slice(0, labels.length)\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\")\n//                 ? \"rgba(135, 206, 250, 1)\"\n//                 : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const handleSend = () => {\n//     console.log(\"Input Value:\", inputValue);\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//         x: {\n//           ticks: {\n//             autoSkip: false,\n//             maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//         minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//             autoSkipPadding: 20,\n//           },\n//           grid: {\n//             display: true,\n//             drawTicks: false,\n//             tickLength: 100,\n//             lineWidth: 1\n//           },\n//         },\n//           y: {\n//             beginAtZero: true,\n//             ticks: {\n//               precision: 0,\n//             },\n//           },\n//         },\n//     plugins: {\n//       legend: {\n//         display: true,\n//         position: \"top\",\n//       },\n//       tooltip: {\n//         enabled: true,\n//       },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div\n//               style={{\n//                 minWidth: [\"lineChartData\", \"barChartData\"].includes(type)\n//                   ? `${chartWidth}px`\n//                   : \"auto\",\n//                 height: \"400px\",\n//               }}\n//             >\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button\n//           onClick={handleSubmit}\n//           className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\"\n//         >\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map(\n//             (type) => (\n//               <button\n//                 key={type}\n//                 onClick={() => setSelectedChart(type)}\n//                 className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\"\n//               >\n//                 {type.replace(\"ChartData\", \" Chart\")}\n//               </button>\n//             )\n//           )}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           renderChart(selectedChart, {\n//             lineChartData: Line,\n//             barChartData: Bar,\n//             scatterChartData: Scatter,\n//             pieChartData: Pie,\n//             donutChartData: Doughnut,\n//           }[selectedChart])\n//         )}\n//         <div className=\"mt-4 flex\">\n//           <input\n//             type=\"text\"\n//             value={inputValue}\n//             onChange={(e) => setInputValue(e.target.value)}\n//             className=\"border p-2 flex-grow mr-2 rounded\"\n//             placeholder=\"Enter your text here\"\n//           />\n//           <button\n//             onClick={handleSend}\n//             className=\"bg-green-500 text-white p-2 rounded\"\n//           >\n//             Send\n//           </button>\n//         </div>\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import { Chart as ChartJS, CategoryScale, LinearScale, BarElement, LineElement, PointElement, ArcElement, Title, Tooltip, Legend } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// ChartJS.register(CategoryScale, LinearScale, BarElement, LineElement, PointElement, ArcElement, Title, Tooltip, Legend, zoomPlugin);\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string | string[];\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[]\n//   meta?: {\n//     header: string;\n//     valueName: string;\n//   };\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const [inputValue, setInputValue] = useState<string>(\"\");\n//   const [storedProcessedData, setStoredProcessedData] = useState<any>(null); // New state to store processed data\n//   const [combinedInsights, setCombinedInsights] = useState<any>(null);\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const combinedInsights = result.data?.combinedInsights;\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n// console.log(\"processedData\",processedData);\n//       setStoredProcessedData(processedData); // Store the processed data\n//       setCombinedInsights(combinedInsights);\n//       const lightColors = [\n//         \"rgba(173, 216, 230, 0.6)\",\n//         \"rgba(144, 238, 144, 0.6)\",\n//         \"rgba(255, 182, 193, 0.6)\",\n//         \"rgba(255, 228, 181, 0.6)\",\n//         \"rgba(221, 160, 221, 0.6)\",\n//         \"rgba(240, 230, 140, 0.6)\",\n//       ];\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? lightColors.slice(0, labels.length)\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//           meta: {\n//             header: chartInfo.header || \"default_header\",\n//             valueName: chartInfo.valueName || \"default_valueName\",\n//           },\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const handleSend = async () => {\n//     if (!inputValue) return;\n//     const graphData = chartData[selectedChart];\n//     if (!graphData) return;\n//     const labels = graphData.labels;\n//     const values = graphData.datasets[0].data;\n//     const dataObject = labels.reduce((obj: { [key: string]: number }, label, index) => {\n//       obj[label] = values[index];\n//       return obj;\n//     }, {});\n//     const chartTypeMapping: Record<string, string> = {\n//       lineChartData: \"Line Chart\",\n//       pieChartData: \"Pie Chart\",\n//       donutChartData: \"Donut Chart\",\n//       barChartData: \"Bar Chart\",\n//       scatterChartData: \"Scatter Plot\",\n//     };\n//     const selectedChartType = chartTypeMapping[selectedChart] || selectedChart;\n//     // Filter the stored processed data to include only the selected chart's data\n//     const filteredProcessedData = {\n//       [selectedChartType]: storedProcessedData[selectedChartType],\n//     };\n//     console.log(\"...filteredProcessedData,\", filteredProcessedData[selectedChartType]?.[0]?.data);\n//     console.log(\"dataObject,\", dataObject);\n//     const requestBody = {\n//       question: inputValue,\n//       processedData: {\n//         // Include the stored processed data\n//         [selectedChartType]: [\n//           {\n//             header: graphData.meta?.header || \"default_header\",\n//             valueName: graphData.meta?.valueName || \"default_valueName\",\n//             label: graphData.datasets[0].label,\n//             data: filteredProcessedData[selectedChartType]?.[0]?.data,\n//           },\n//         ],\n//       },\n//     };\n//     try {\n//       const response = await fetch(\n//         `http://localhost:3012/api/answer-analyze-excel?question=${encodeURIComponent(inputValue)}`,\n//         {\n//           method: \"POST\",\n//           headers: { \"Content-Type\": \"application/json\" },\n//           body: JSON.stringify(requestBody),\n//         }\n//       );\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       console.log(\"Updated API Response Data:\", processedData);\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0]; // Use only API response data\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? [\"rgba(173, 216, 230, 0.6)\", \"rgba(144, 238, 144, 0.6)\", \"rgba(255, 182, 193, 0.6)\"]\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//           meta: {\n//             header: chartInfo.header || \"default_header\",\n//             valueName: chartInfo.valueName || \"default_valueName\",\n//           },\n//         };\n//       };\n//       // Only update chartData without storing in storedProcessedData\n//       setChartData((prevChartData) => ({\n//         ...prevChartData,\n//         [selectedChart]: generateChartData(selectedChartType),\n//       }));\n//     } catch (error) {\n//       console.error(\"Error sending request:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//         x: {\n//           ticks: {\n//             autoSkip: false,\n//             maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//         minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//             autoSkipPadding: 20,\n//           },\n//           grid: {\n//             display: true,\n//             drawTicks: false,\n//             tickLength: 100,\n//             lineWidth: 1\n//           },\n//         },\n//         y: {\n//           beginAtZero: true,\n//           ticks: { precision: 0 },\n//         },\n//       },\n//     plugins: {\n//       legend: { display: true, position: \"top\" },\n//       tooltip: { enabled: true },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div style={{ minWidth: [\"lineChartData\", \"barChartData\"].includes(type) ? `${chartWidth}px` : \"auto\", height: \"400px\" }}>\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button onClick={handleSubmit} className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\">\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map((type) => (\n//             <button key={type} onClick={() => setSelectedChart(type)} className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\">\n//               {type.replace(\"ChartData\", \" Chart\")}\n//             </button>\n//           ))}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           selectedChart && renderChart(selectedChart, { lineChartData: Line, barChartData: Bar, scatterChartData: Scatter, pieChartData: Pie, donutChartData: Doughnut }[selectedChart])\n//         )}\n//         <div className=\"mt-4 flex\">\n//           <input\n//             type=\"text\"\n//             value={inputValue}\n//             onChange={(e) => setInputValue(e.target.value)}\n//             className=\"border p-2 flex-grow mr-2 rounded\"\n//             placeholder=\"Enter your text here\"\n//           />\n//           <button onClick={handleSend} className=\"bg-green-500 text-white p-2 rounded\">\n//             Send\n//           </button>\n//         </div>\n//         <div className=\"mt-4 p-4 border border-gray-300 rounded bg-white\">\n//         <h3 className=\"text-lg font-bold mb-2\">Insights</h3>\n//         {combinedInsights ? (\n//             <ol className=\"list-decimal list-inside text-sm text-gray-700 bg-gray-100 p-2 rounded overflow-auto\">\n//             {combinedInsights.split('\\n').map((insight, index) => (\n//               <ul key={index}>{insight}</ul>\n//             ))}\n//           </ol>\n//         ) : (\n//           <p className=\"text-gray-500\">No insights available.</p>\n//         )}\n//       </div>\n//       </div>\n//     </div>\n//   );\n// }\n// \"use client\";\n// import { useState, useEffect, useRef } from \"react\";\n// import { Bar, Line, Doughnut, Pie, Scatter } from \"react-chartjs-2\";\n// import { Chart as ChartJS, CategoryScale, LinearScale, BarElement, LineElement, PointElement, ArcElement, Title, Tooltip, Legend } from \"chart.js\";\n// import { BsUpload } from \"react-icons/bs\";\n// import zoomPlugin from \"chartjs-plugin-zoom\";\n// import html2canvas from \"html2canvas\";\n// import jsPDF from \"jspdf\";\n// ChartJS.register(CategoryScale, LinearScale, BarElement, LineElement, PointElement, ArcElement, Title, Tooltip, Legend, zoomPlugin);\n// interface ChartData {\n//   labels: string[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     backgroundColor?: string | string[];\n//     borderColor?: string;\n//     fill?: boolean;\n//   }[]\n//   meta?: {\n//     header: string;\n//     valueName: string;\n//   };\n// }\n// export default function Dashboard() {\n//   const [chartData, setChartData] = useState<Record<string, ChartData | null>>({\n//     scatterChartData: null,\n//     pieChartData: null,\n//     donutChartData: null,\n//     lineChartData: null,\n//     barChartData: null,\n//   });\n//   const [selectedFile, setSelectedFile] = useState<File | null>(null);\n//   const [selectedChart, setSelectedChart] = useState<string>(\"lineChartData\");\n//   const [loading, setLoading] = useState<boolean>(false);\n//   const [chartWidth, setChartWidth] = useState<number>(0);\n//   const [inputValue, setInputValue] = useState<string>(\"\");\n//   const [storedProcessedData, setStoredProcessedData] = useState<any>(null); // New state to store processed data\n//   const [combinedInsights, setCombinedInsights] = useState<any>(null);\n//   const chartRef = useRef<HTMLDivElement>(null); // Ref for the chart container\n//   const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n//     setSelectedFile(event.target.files?.[0] || null);\n//   };\n//   const handleSubmit = async () => {\n//     if (!selectedFile) return;\n//     setLoading(true);\n//     const formData = new FormData();\n//     formData.append(\"file\", selectedFile);\n//     try {\n//       const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n//         method: \"POST\",\n//         body: formData,\n//       });\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const combinedInsights = result.data?.combinedInsights;\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n// console.log(\"processedData\",processedData);\n//       setStoredProcessedData(processedData); // Store the processed data\n//       setCombinedInsights(combinedInsights);\n//       const lightColors = [\n//         \"rgba(173, 216, 230, 0.6)\",\n//         \"rgba(144, 238, 144, 0.6)\",\n//         \"rgba(255, 182, 193, 0.6)\",\n//         \"rgba(255, 228, 181, 0.6)\",\n//         \"rgba(221, 160, 221, 0.6)\",\n//         \"rgba(240, 230, 140, 0.6)\",\n//       ];\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0];\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? lightColors.slice(0, labels.length)\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//           meta: {\n//             header: chartInfo.header || \"default_header\",\n//             valueName: chartInfo.valueName || \"default_valueName\",\n//           },\n//         };\n//       };\n//       setChartData({\n//         scatterChartData: generateChartData(\"Scatter Plot\"),\n//         pieChartData: generateChartData(\"Pie Chart\"),\n//         donutChartData: generateChartData(\"Donut Chart\"),\n//         lineChartData: generateChartData(\"Line Chart\"),\n//         barChartData: generateChartData(\"Bar Chart\"),\n//       });\n//     } catch (error) {\n//       console.error(\"Error uploading file:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const handleSend = async () => {\n//     if (!inputValue) return;\n//     const graphData = chartData[selectedChart];\n//     if (!graphData) return;\n//     const labels = graphData.labels;\n//     const values = graphData.datasets[0].data;\n//     const dataObject = labels.reduce((obj: { [key: string]: number }, label, index) => {\n//       obj[label] = values[index];\n//       return obj;\n//     }, {});\n//     const chartTypeMapping: Record<string, string> = {\n//       lineChartData: \"Line Chart\",\n//       pieChartData: \"Pie Chart\",\n//       donutChartData: \"Donut Chart\",\n//       barChartData: \"Bar Chart\",\n//       scatterChartData: \"Scatter Plot\",\n//     };\n//     const selectedChartType = chartTypeMapping[selectedChart] || selectedChart;\n//     // Filter the stored processed data to include only the selected chart's data\n//     const filteredProcessedData = {\n//       [selectedChartType]: storedProcessedData[selectedChartType],\n//     };\n//     console.log(\"...filteredProcessedData,\", filteredProcessedData[selectedChartType]?.[0]?.data);\n//     console.log(\"dataObject,\", dataObject);\n//     const requestBody = {\n//       question: inputValue,\n//       processedData: {\n//         // Include the stored processed data\n//         [selectedChartType]: [\n//           {\n//             header: graphData.meta?.header || \"default_header\",\n//             valueName: graphData.meta?.valueName || \"default_valueName\",\n//             label: graphData.datasets[0].label,\n//             data: filteredProcessedData[selectedChartType]?.[0]?.data,\n//           },\n//         ],\n//       },\n//     };\n//     try {\n//       const response = await fetch(\n//         `http://localhost:3012/api/answer-analyze-excel?question=${encodeURIComponent(inputValue)}`,\n//         {\n//           method: \"POST\",\n//           headers: { \"Content-Type\": \"application/json\" },\n//           body: JSON.stringify(requestBody),\n//         }\n//       );\n//       if (!response.ok) throw new Error(\"Error uploading file.\");\n//       const result = await response.json();\n//       const processedData = result.data?.processedData;\n//       if (!processedData) throw new Error(\"Invalid response structure.\");\n//       console.log(\"Updated API Response Data:\", processedData);\n//       const generateChartData = (chartType: string): ChartData | null => {\n//         const chartInfo = processedData[chartType]?.[0]; // Use only API response data\n//         if (!chartInfo) return null;\n//         const labels = Object.keys(chartInfo.data);\n//         const values = Object.values(chartInfo.data);\n//         setChartWidth(labels.length * 150);\n//         return {\n//           labels,\n//           datasets: [\n//             {\n//               label: chartInfo.label || chartType,\n//               data: values as number[],\n//               backgroundColor: [\"Pie Chart\", \"Donut Chart\", \"Bar Chart\"].includes(chartType)\n//                 ? [\"rgba(173, 216, 230, 0.6)\", \"rgba(144, 238, 144, 0.6)\", \"rgba(255, 182, 193, 0.6)\"]\n//                 : \"rgba(135, 206, 250, 0.6)\",\n//               borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n//               fill: !chartType.includes(\"Line\"),\n//             },\n//           ],\n//           meta: {\n//             header: chartInfo.header || \"default_header\",\n//             valueName: chartInfo.valueName || \"default_valueName\",\n//           },\n//         };\n//       };\n//       // Only update chartData without storing in storedProcessedData\n//       setChartData((prevChartData) => ({\n//         ...prevChartData,\n//         [selectedChart]: generateChartData(selectedChartType),\n//       }));\n//     } catch (error) {\n//       console.error(\"Error sending request:\", error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   };\n//   const getChartOptions = (type: string) => ({\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales: [\"pieChartData\", \"donutChartData\"].includes(type)\n//       ? {}\n//       : {\n//         x: {\n//           ticks: {\n//             autoSkip: false,\n//             maxRotation: type === 'barChartData' || type === 'scatterChartData' ? 20 : 100,\n//         minRotation: type === 'barChartData' || type === 'scatterChartData' ? 0 : 90,\n//             autoSkipPadding: 20,\n//           },\n//           grid: {\n//             display: true,\n//             drawTicks: false,\n//             tickLength: 100,\n//             lineWidth: 1\n//           },\n//         },\n//         y: {\n//           beginAtZero: true,\n//           ticks: { precision: 0 },\n//         },\n//       },\n//     plugins: {\n//       legend: { display: true, position: \"top\" },\n//       tooltip: { enabled: true },\n//     },\n//   });\n//   const renderChart = (type: string, ChartComponent: any) => {\n//     const data = chartData[type];\n//     if (!loading && data) {\n//       return (\n//         <div className=\"card p-4 border rounded shadow-sm\">\n//           <div style={{ width: \"100%\", overflowX: \"auto\" }}>\n//             <div style={{ minWidth: [\"lineChartData\", \"barChartData\"].includes(type) ? `${chartWidth}px` : \"auto\", height: \"400px\" }}>\n//               <ChartComponent data={data} options={getChartOptions(type)} />\n//             </div>\n//           </div>\n//         </div>\n//       );\n//     }\n//     return null;\n//   };\n//   const handleDownloadPDF = async () => {\n//     if (!chartRef.current) return;\n//     // Temporarily set the chart container to its full height to capture all content\n//     const originalHeight = chartRef.current.style.height;\n//     chartRef.current.style.height = `${chartRef.current.scrollHeight}px`;\n//     const canvas = await html2canvas(chartRef.current, {\n//       scrollX: 0,\n//       scrollY: -window.scrollY,\n//       width: chartRef.current.scrollWidth,\n//       height: chartRef.current.scrollHeight,\n//     });\n//     // Restore the original height of the chart container\n//     chartRef.current.style.height = originalHeight;\n//     const imgData = canvas.toDataURL(\"image/png\");\n//     const pdf = new jsPDF(\"landscape\", \"mm\", \"a4\");\n//     const imgProps = pdf.getImageProperties(imgData);\n//     const pdfWidth = pdf.internal.pageSize.getWidth();\n//     const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;\n//     pdf.addImage(imgData, \"PNG\", 0, 0, pdfWidth, pdfHeight);\n//     pdf.save(\"chart.pdf\");\n//   };\n//   return (\n//     <div className=\"flex flex-col md:flex-row h-screen border border-black\">\n//       <div className=\"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\">\n//         <h2 className=\"text-lg font-bold mb-2\">Upload File</h2>\n//         <input type=\"file\" onChange={handleFileChange} className=\"border p-2 w-full\" />\n//         <button onClick={handleSubmit} className=\"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\">\n//           <BsUpload className=\"mr-2\" /> Submit\n//         </button>\n//         <div className=\"flex flex-col space-y-2 mt-4\">\n//           {[\"lineChartData\", \"barChartData\", \"scatterChartData\", \"pieChartData\", \"donutChartData\"].map((type) => (\n//             <button key={type} onClick={() => setSelectedChart(type)} className=\"p-2 bg-gray-300 rounded hover:bg-gray-400\">\n//               {type.replace(\"ChartData\", \" Chart\")}\n//             </button>\n//           ))}\n//         </div>\n//       </div>\n//       <div className=\"w-full md:w-3/4 bg-gray-100 p-5 overflow-auto\">\n//         {loading ? (\n//           <div className=\"flex justify-center items-center h-full\">\n//             <div className=\"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"></div>\n//           </div>\n//         ) : (\n//           selectedChart && renderChart(selectedChart, { lineChartData: Line, barChartData: Bar, scatterChartData: Scatter, pieChartData: Pie, donutChartData: Doughnut }[selectedChart])\n//         )}\n//         <div className=\"mt-4 flex\">\n//           <input\n//             type=\"text\"\n//             value={inputValue}\n//             onChange={(e) => setInputValue(e.target.value)}\n//             className=\"border p-2 flex-grow mr-2 rounded\"\n//             placeholder=\"Enter your text here\"\n//           />\n//           <button onClick={handleSend} className=\"bg-green-500 text-white p-2 rounded\">\n//             Send\n//           </button>\n//         </div>\n//         <div className=\"mt-4 p-4 border border-gray-300 rounded bg-white\">\n//           <h3 className=\"text-lg font-bold mb-2\">Insights</h3>\n//           {combinedInsights ? (\n//             <ol className=\"list-decimal list-inside text-sm text-gray-700 bg-gray-100 p-2 rounded overflow-auto\">\n//               {combinedInsights.split('\\n').map((insight, index) => (\n//                 <ul key={index}>{insight}</ul>\n//               ))}\n//             </ol>\n//           ) : (\n//             <p className=\"text-gray-500\">No insights available.</p>\n//           )}\n//         </div>\n//         <button onClick={handleDownloadPDF} className=\"bg-red-500 text-white p-2 rounded mt-4\">\n//           Download as PDF\n//         </button>\n//       </div>\n//     </div>\n//   );\n// }\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nchart_js__WEBPACK_IMPORTED_MODULE_4__.Chart.register(chart_js__WEBPACK_IMPORTED_MODULE_4__.CategoryScale, chart_js__WEBPACK_IMPORTED_MODULE_4__.LinearScale, chart_js__WEBPACK_IMPORTED_MODULE_4__.BarElement, chart_js__WEBPACK_IMPORTED_MODULE_4__.LineElement, chart_js__WEBPACK_IMPORTED_MODULE_4__.PointElement, chart_js__WEBPACK_IMPORTED_MODULE_4__.ArcElement, chart_js__WEBPACK_IMPORTED_MODULE_4__.Title, chart_js__WEBPACK_IMPORTED_MODULE_4__.Tooltip, chart_js__WEBPACK_IMPORTED_MODULE_4__.Legend, chartjs_plugin_zoom__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\nfunction Dashboard() {\n    _s();\n    const [chartData, setChartData] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({\n        scatterChartData: null,\n        pieChartData: null,\n        donutChartData: null,\n        lineChartData: null,\n        barChartData: null\n    });\n    const [selectedFile, setSelectedFile] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [selectedChart, setSelectedChart] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"lineChartData\");\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [chartWidth, setChartWidth] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(0);\n    const [inputValue, setInputValue] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [storedProcessedData, setStoredProcessedData] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null); // New state to store processed data\n    const [combinedInsights, setCombinedInsights] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null); // Ref for the chart container\n    const handleFileChange = (event)=>{\n        var _event_target_files;\n        setSelectedFile(((_event_target_files = event.target.files) === null || _event_target_files === void 0 ? void 0 : _event_target_files[0]) || null);\n    };\n    const handleSubmit = async ()=>{\n        if (!selectedFile) return;\n        setLoading(true);\n        const formData = new FormData();\n        formData.append(\"file\", selectedFile);\n        try {\n            var _result_data, _result_data1;\n            const response = await fetch(\"http://localhost:3012/api/analyze-excel\", {\n                method: \"POST\",\n                body: formData\n            });\n            if (!response.ok) throw new Error(\"Error uploading file.\");\n            const result = await response.json();\n            const combinedInsights = (_result_data = result.data) === null || _result_data === void 0 ? void 0 : _result_data.combinedInsights;\n            const processedData = (_result_data1 = result.data) === null || _result_data1 === void 0 ? void 0 : _result_data1.processedData;\n            if (!processedData) throw new Error(\"Invalid response structure.\");\n            console.log(\"processedData\", processedData);\n            setStoredProcessedData(processedData); // Store the processed data\n            setCombinedInsights(combinedInsights);\n            const lightColors = [\n                \"rgba(173, 216, 230, 0.6)\",\n                \"rgba(144, 238, 144, 0.6)\",\n                \"rgba(255, 182, 193, 0.6)\",\n                \"rgba(255, 228, 181, 0.6)\",\n                \"rgba(221, 160, 221, 0.6)\",\n                \"rgba(240, 230, 140, 0.6)\"\n            ];\n            const generateChartData = (chartType)=>{\n                var _processedData_chartType;\n                const chartInfo = (_processedData_chartType = processedData[chartType]) === null || _processedData_chartType === void 0 ? void 0 : _processedData_chartType[0];\n                if (!chartInfo) return null;\n                const labels = Object.keys(chartInfo.data);\n                const values = Object.values(chartInfo.data);\n                console.log(\"chartType\", chartType);\n                let chartWidth = 0;\n                if ([\n                    \"Line Chart\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150;\n                } else if ([\n                    \"Bar Chart\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150; // Adjust the width for bar chart\n                } else if ([\n                    \"Scatter Plot\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150; // Adjust the width for bar chart\n                } else {\n                    chartWidth = 400; // Default width for other chart types\n                }\n                setChartWidth(chartWidth);\n                return {\n                    labels,\n                    datasets: [\n                        {\n                            label: chartInfo.label || chartType,\n                            data: values,\n                            backgroundColor: [\n                                \"Pie Chart\",\n                                \"Donut Chart\",\n                                \"Bar Chart\"\n                            ].includes(chartType) ? lightColors.slice(0, labels.length) : \"rgba(135, 206, 250, 0.6)\",\n                            borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n                            fill: !chartType.includes(\"Line\")\n                        }\n                    ],\n                    meta: {\n                        header: chartInfo.header || \"default_header\",\n                        valueName: chartInfo.valueName || \"default_valueName\"\n                    }\n                };\n            };\n            setChartData({\n                scatterChartData: generateChartData(\"Scatter Plot\"),\n                pieChartData: generateChartData(\"Pie Chart\"),\n                donutChartData: generateChartData(\"Donut Chart\"),\n                lineChartData: generateChartData(\"Line Chart\"),\n                barChartData: generateChartData(\"Bar Chart\")\n            });\n        } catch (error) {\n            console.error(\"Error uploading file:\", error);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const handleSend = async ()=>{\n        var _graphData_meta, _graphData_meta1, _filteredProcessedData_selectedChartType_, _filteredProcessedData_selectedChartType;\n        if (!inputValue) return;\n        const graphData = chartData[selectedChart];\n        if (!graphData) return;\n        const labels = graphData.labels;\n        const values = graphData.datasets[0].data;\n        const dataObject = labels.reduce((obj, label, index)=>{\n            obj[label] = values[index];\n            return obj;\n        }, {});\n        const chartTypeMapping = {\n            lineChartData: \"Line Chart\",\n            pieChartData: \"Pie Chart\",\n            donutChartData: \"Donut Chart\",\n            barChartData: \"Bar Chart\",\n            scatterChartData: \"Scatter Plot\"\n        };\n        const selectedChartType = chartTypeMapping[selectedChart] || selectedChart;\n        // Filter the stored processed data to include only the selected chart's data\n        const filteredProcessedData = {\n            [selectedChartType]: storedProcessedData[selectedChartType]\n        };\n        const requestBody = {\n            question: inputValue,\n            processedData: {\n                // Include the stored processed data\n                [selectedChartType]: [\n                    {\n                        header: ((_graphData_meta = graphData.meta) === null || _graphData_meta === void 0 ? void 0 : _graphData_meta.header) || \"default_header\",\n                        valueName: ((_graphData_meta1 = graphData.meta) === null || _graphData_meta1 === void 0 ? void 0 : _graphData_meta1.valueName) || \"default_valueName\",\n                        label: graphData.datasets[0].label,\n                        data: (_filteredProcessedData_selectedChartType = filteredProcessedData[selectedChartType]) === null || _filteredProcessedData_selectedChartType === void 0 ? void 0 : (_filteredProcessedData_selectedChartType_ = _filteredProcessedData_selectedChartType[0]) === null || _filteredProcessedData_selectedChartType_ === void 0 ? void 0 : _filteredProcessedData_selectedChartType_.data\n                    }\n                ]\n            }\n        };\n        setLoading(true);\n        try {\n            var _result_data;\n            const response = await fetch(\"http://localhost:3012/api/answer-analyze-excel?question=\".concat(encodeURIComponent(inputValue)), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(requestBody)\n            });\n            if (!response.ok) throw new Error(\"Error uploading file.\");\n            setLoading(false);\n            const result = await response.json();\n            console.log(\"result.data\", result.data.data.combinedInsights);\n            setCombinedInsights(result.data.data.combinedInsights);\n            const processedData = (_result_data = result.data) === null || _result_data === void 0 ? void 0 : _result_data.processedData;\n            if (!processedData) throw new Error(\"Invalid response structure.\");\n            const generateChartData = (chartType)=>{\n                var _processedData_chartType;\n                const chartInfo = (_processedData_chartType = processedData[chartType]) === null || _processedData_chartType === void 0 ? void 0 : _processedData_chartType[0]; // Use only API response data\n                if (!chartInfo) return null;\n                const labels = Object.keys(chartInfo.data);\n                const values = Object.values(chartInfo.data);\n                let chartWidth = 0;\n                if ([\n                    \"Line Chart\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150;\n                } else if ([\n                    \"Bar Chart\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150; // Adjust the width for bar chart\n                } else if ([\n                    \"Scatter Plot\"\n                ].includes(chartType)) {\n                    chartWidth = labels.length * 150; // Adjust the width for bar chart\n                } else {\n                    chartWidth = 400; // Default width for other chart types\n                }\n                setChartWidth(chartWidth);\n                return {\n                    labels,\n                    datasets: [\n                        {\n                            label: chartInfo.label || chartType,\n                            data: values,\n                            backgroundColor: [\n                                \"Pie Chart\",\n                                \"Donut Chart\",\n                                \"Bar Chart\"\n                            ].includes(chartType) ? [\n                                \"rgba(173, 216, 230, 0.6)\",\n                                \"rgba(144, 238, 144, 0.6)\",\n                                \"rgba(255, 182, 193, 0.6)\"\n                            ] : \"rgba(135, 206, 250, 0.6)\",\n                            borderColor: chartType.includes(\"Line\") ? \"rgba(135, 206, 250, 1)\" : undefined,\n                            fill: !chartType.includes(\"Line\")\n                        }\n                    ],\n                    meta: {\n                        header: chartInfo.header || \"default_header\",\n                        valueName: chartInfo.valueName || \"default_valueName\"\n                    }\n                };\n            };\n            // Only update chartData without storing in storedProcessedData\n            setChartData((prevChartData)=>({\n                    ...prevChartData,\n                    [selectedChart]: generateChartData(selectedChartType)\n                }));\n        } catch (error) {\n        // console.error(\"Error sending request:\", error);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const renderChart = (type, ChartComponent)=>{\n        const data = chartData === null || chartData === void 0 ? void 0 : chartData[type];\n        if (!loading && data) {\n            var _data_labels;\n            const dataLength = ((_data_labels = data.labels) === null || _data_labels === void 0 ? void 0 : _data_labels.length) || 0;\n            const maxTicks = Math.floor(600 / 30); // Approx 30px per vertical label\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-full overflow-x-auto overflow-y-hidden bg-white p-4 rounded-lg shadow\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        width: \"100%\",\n                        minWidth: [\n                            \"lineChartData\",\n                            \"barChartData\"\n                        ].includes(type) ? Math.max(600, dataLength * 30) + \"px\" : \"100%\",\n                        height: \"400px\"\n                    },\n                    className: \"relative\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChartComponent, {\n                        data: data,\n                        options: {\n                            responsive: true,\n                            maintainAspectRatio: false,\n                            scales: {\n                                x: {\n                                    min: 0,\n                                    ticks: {\n                                        autoSkip: false,\n                                        maxTicksLimit: maxTicks,\n                                        maxRotation: 90,\n                                        minRotation: 90,\n                                        padding: 10,\n                                        font: {\n                                            size: 12\n                                        },\n                                        align: 'center',\n                                        // Ensure last labels don't overlap\n                                        callback: function(_value, index, values) {\n                                            // Skip rendering if too close to the end\n                                            if (index === values.length - 1 && dataLength > maxTicks) {\n                                                return null; // Hide last label if it might overlap\n                                            }\n                                            return data.labels[index];\n                                        }\n                                    },\n                                    grid: {\n                                        display: false\n                                    }\n                                },\n                                y: {\n                                    beginAtZero: true\n                                }\n                            },\n                            plugins: {\n                                legend: {\n                                    display: true,\n                                    position: \"top\"\n                                },\n                                tooltip: {\n                                    enabled: true,\n                                    intersect: false,\n                                    mode: 'index'\n                                }\n                            },\n                            layout: {\n                                padding: {\n                                    left: 30,\n                                    right: 30,\n                                    bottom: 40\n                                }\n                            }\n                        }\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 1975,\n                        columnNumber: 13\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                    lineNumber: 1965,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                lineNumber: 1964,\n                columnNumber: 9\n            }, this);\n        }\n        return null;\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"flex flex-col w-full md:flex-row h-screen border border-black\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"w-full md:w-1/4 bg-white p-5 border-t md:border-l md:border-black\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"text-lg font-bold mb-2\",\n                        children: \"Upload File\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2042,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"file\",\n                        onChange: handleFileChange,\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"border p-2 w-full\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2043,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: handleSubmit,\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"bg-blue-500 text-white p-2 rounded flex items-center justify-center mt-4\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_BsUpload_react_icons_bs__WEBPACK_IMPORTED_MODULE_5__.BsUpload, {\n                                className: \"mr-2\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2045,\n                                columnNumber: 11\n                            }, this),\n                            \" Submit\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2044,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"flex flex-col space-y-2 mt-4\",\n                        children: [\n                            \"lineChartData\",\n                            \"barChartData\",\n                            \"scatterChartData\",\n                            \"pieChartData\",\n                            \"donutChartData\"\n                        ].map((type)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>setSelectedChart(type),\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"p-2 bg-gray-300 rounded hover:bg-gray-400\",\n                                children: type.replace(\"ChartData\", \" Chart\")\n                            }, type, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2049,\n                                columnNumber: 13\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2047,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                lineNumber: 2041,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"w-full md:w-3/4 bg-gray-100 p-5\",\n                children: [\n                    loading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"flex justify-center items-center h-full\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"jsx-ee216b23b408fc3d\" + \" \" + \"spinner-border animate-spin border-t-4 border-blue-500 rounded-full w-12 h-12\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                            lineNumber: 2058,\n                            columnNumber: 7\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2057,\n                        columnNumber: 5\n                    }, this) : selectedChart && renderChart(selectedChart, {\n                        lineChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__.Line,\n                        barChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__.Bar,\n                        scatterChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__.Scatter,\n                        pieChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__.Pie,\n                        donutChartData: react_chartjs_2__WEBPACK_IMPORTED_MODULE_6__.Doughnut\n                    }[selectedChart]),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"mt-4 flex\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                value: inputValue,\n                                onChange: (e)=>setInputValue(e.target.value),\n                                placeholder: \"Enter your text here\",\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"border p-2 flex-grow mr-2 rounded\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2070,\n                                columnNumber: 5\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: handleSend,\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"bg-green-500 text-white p-2 rounded\",\n                                children: \"Send\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2077,\n                                columnNumber: 5\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2069,\n                        columnNumber: 3\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"mt-4 p-4 border border-gray-300 rounded bg-white\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"text-lg font-bold mb-2\",\n                                children: \"Insights\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2082,\n                                columnNumber: 5\n                            }, this),\n                            combinedInsights ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ol\", {\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"list-decimal list-inside text-sm text-gray-700 bg-gray-100 p-2 rounded max-h-60 overflow-y-auto\",\n                                children: combinedInsights.split('\\n').map((insight, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                        className: \"jsx-ee216b23b408fc3d\" + \" \" + \"py-1\",\n                                        children: insight\n                                    }, index, false, {\n                                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                        lineNumber: 2086,\n                                        columnNumber: 11\n                                    }, this))\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2084,\n                                columnNumber: 7\n                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"jsx-ee216b23b408fc3d\" + \" \" + \"text-gray-500\",\n                                children: \"No insights available.\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                                lineNumber: 2090,\n                                columnNumber: 7\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                        lineNumber: 2081,\n                        columnNumber: 3\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n                lineNumber: 2055,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default()), {\n                id: \"ee216b23b408fc3d\",\n                children: \".overflow-x-auto.jsx-ee216b23b408fc3d{-webkit-overflow-scrolling:touch;scrollbar-width:thin;scrollbar-color:#888#f1f1f1}.overflow-x-auto.jsx-ee216b23b408fc3d::-webkit-scrollbar{height:8px}.overflow-x-auto.jsx-ee216b23b408fc3d::-webkit-scrollbar-thumb{background:#888;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.overflow-x-auto.jsx-ee216b23b408fc3d::-webkit-scrollbar-track{background:#f1f1f1}@media(max-width:768px){.overflow-x-auto.jsx-ee216b23b408fc3d>div.jsx-ee216b23b408fc3d{min-width:400px;height:300px}}\"\n            }, void 0, false, void 0, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Mukesh.kasimahanthi\\\\Desktop\\\\visulization\\\\aiAgentFrontendCode\\\\src\\\\app\\\\pages\\\\Upload\\\\Upload.tsx\",\n        lineNumber: 2040,\n        columnNumber: 5\n    }, this);\n}\n_s(Dashboard, \"P/Zh0x9l01YSUrGDOmP3n5Y2uFs=\");\n_c = Dashboard;\nvar _c;\n$RefreshReg$(_c, \"Dashboard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcGFnZXMvVXBsb2FkL1VwbG9hZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUdBLGdCQUFnQjtBQUNoQiwrQ0FBK0M7QUFDL0MsdUVBQXVFO0FBQ3ZFLFdBQVc7QUFDWCxzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsV0FBVztBQUNYLGFBQWE7QUFDYixZQUFZO0FBQ1oscUJBQXFCO0FBQ3JCLDZDQUE2QztBQUM3QyxnREFBZ0Q7QUFFaEQsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLFdBQVc7QUFDWCxhQUFhO0FBQ2IsWUFBWTtBQUNaLGVBQWU7QUFDZixLQUFLO0FBRUwsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QixnQkFBZ0I7QUFDaEIscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QixnQ0FBZ0M7QUFDaEMsNEJBQTRCO0FBQzVCLHNCQUFzQjtBQUN0QixTQUFTO0FBQ1QsSUFBSTtBQUVKLHdDQUF3QztBQUN4QyxtRkFBbUY7QUFDbkYsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQiw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQixRQUFRO0FBQ1IseUVBQXlFO0FBQ3pFLG9FQUFvRTtBQUNwRSw0REFBNEQ7QUFDNUQsNkRBQTZEO0FBQzdELHdFQUF3RTtBQUV4RSwrRUFBK0U7QUFDL0Usd0RBQXdEO0FBQ3hELE9BQU87QUFFUCx1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDLHdCQUF3QjtBQUV4Qix1Q0FBdUM7QUFDdkMsNkNBQTZDO0FBRTdDLFlBQVk7QUFDWixrRkFBa0Y7QUFDbEYsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixZQUFZ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Ozs7MENBR1osOERBQUNOO2dDQUFPQyxTQUFTbEU7MEVBQXNCOzBDQUFzQzs7Ozs7Ozs7Ozs7O2tDQUkvRSw4REFBQ3VCO2tFQUFjOzswQ0FDYiw4REFBQ2lEOzBFQUFhOzBDQUF5Qjs7Ozs7OzRCQUN0Q3BILGlDQUNDLDhEQUFDcUg7MEVBQWE7MENBQ1hySCxpQkFBaUJzSCxLQUFLLENBQUMsTUFBTVAsR0FBRyxDQUFDLENBQUNRLFNBQXlMckUsc0JBQzFOLDhEQUFDc0U7a0ZBQXlCO2tEQUFRRDt1Q0FBekJyRTs7Ozs7Ozs7O3FEQUliLDhEQUFDdUU7MEVBQVk7MENBQWdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NuQztHQXJZd0I3STtLQUFBQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxNdWtlc2gua2FzaW1haGFudGhpXFxEZXNrdG9wXFx2aXN1bGl6YXRpb25cXGFpQWdlbnRGcm9udGVuZENvZGVcXHNyY1xcYXBwXFxwYWdlc1xcVXBsb2FkXFxVcGxvYWQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5cclxuXHJcbi8vIFwidXNlIGNsaWVudFwiO1xyXG4vLyBpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XHJcbi8vIGltcG9ydCB7IEJhciwgTGluZSwgRG91Z2hudXQsIFBpZSwgU2NhdHRlciB9IGZyb20gXCJyZWFjdC1jaGFydGpzLTJcIjtcclxuLy8gaW1wb3J0IHtcclxuLy8gICBDaGFydCBhcyBDaGFydEpTLFxyXG4vLyAgIENhdGVnb3J5U2NhbGUsXHJcbi8vICAgTGluZWFyU2NhbGUsXHJcbi8vICAgQmFyRWxlbWVudCxcclxuLy8gICBMaW5lRWxlbWVudCxcclxuLy8gICBQb2ludEVsZW1lbnQsXHJcbi8vICAgQXJjRWxlbWVudCxcclxuLy8gICBUaXRsZSxcclxuLy8gICBUb29sdGlwLFxyXG4vLyAgIExlZ2VuZCxcclxuLy8gfSBmcm9tIFwiY2hhcnQuanNcIjtcclxuLy8gaW1wb3J0IHsgQnNVcGxvYWQgfSBmcm9tIFwicmVhY3QtaWNvbnMvYnNcIjtcclxuLy8gaW1wb3J0IHpvb21QbHVnaW4gZnJvbSBcImNoYXJ0anMtcGx1Z2luLXpvb21cIjtcclxuXHJcbi8vIENoYXJ0SlMucmVnaXN0ZXIoXHJcbi8vICAgQ2F0ZWdvcnlTY2FsZSxcclxuLy8gICBMaW5lYXJTY2FsZSxcclxuLy8gICBCYXJFbGVtZW50LFxyXG4vLyAgIExpbmVFbGVtZW50LFxyXG4vLyAgIFBvaW50RWxlbWVudCxcclxuLy8gICBBcmNFbGVtZW50LFxyXG4vLyAgIFRpdGxlLFxyXG4vLyAgIFRvb2x0aXAsXHJcbi8vICAgTGVnZW5kLFxyXG4vLyAgIHpvb21QbHVnaW5cclxuLy8gKTtcclxuXHJcbi8vIGludGVyZmFjZSBDaGFydERhdGEge1xyXG4vLyAgIGxhYmVsczogc3RyaW5nW107XHJcbi8vICAgZGF0YXNldHM6IHtcclxuLy8gICAgIGxhYmVsOiBzdHJpbmc7XHJcbi8vICAgICBkYXRhOiBudW1iZXJbXTtcclxuLy8gICAgIGJhY2tncm91bmRDb2xvcj86IHN0cmluZztcclxuLy8gICAgIGJvcmRlckNvbG9yPzogc3RyaW5nO1xyXG4vLyAgICAgZmlsbD86IGJvb2xlYW47XHJcbi8vICAgfVtdO1xyXG4vLyB9XHJcblxyXG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEYXNoYm9hcmQoKSB7XHJcbi8vICAgY29uc3QgW2NoYXJ0RGF0YSwgc2V0Q2hhcnREYXRhXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIENoYXJ0RGF0YSB8IG51bGw+Pih7XHJcbi8vICAgICBzY2F0dGVyQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgcGllQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgZG9udXRDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBsaW5lQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgYmFyQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgIH0pO1xyXG4vLyAgIGNvbnN0IFtzZWxlY3RlZEZpbGUsIHNldFNlbGVjdGVkRmlsZV0gPSB1c2VTdGF0ZTxGaWxlIHwgbnVsbD4obnVsbCk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkQ2hhcnQsIHNldFNlbGVjdGVkQ2hhcnRdID0gdXNlU3RhdGU8c3RyaW5nPihcIlwiKTtcclxuLy8gICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcbi8vICAgY29uc3QgW2NoYXJ0V2lkdGgsIHNldENoYXJ0V2lkdGhdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRMYWJlbHMsIHNldFNlbGVjdGVkTGFiZWxzXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSk7XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZUZpbGVDaGFuZ2UgPSAoZXZlbnQ6IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XHJcbi8vICAgICBzZXRTZWxlY3RlZEZpbGUoZXZlbnQudGFyZ2V0LmZpbGVzPy5bMF0gfHwgbnVsbCk7XHJcbi8vICAgfTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlU3VibWl0ID0gYXN5bmMgKCkgPT4ge1xyXG4vLyAgICAgaWYgKCFzZWxlY3RlZEZpbGUpIHJldHVybjtcclxuLy8gICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcblxyXG4vLyAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuLy8gICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgc2VsZWN0ZWRGaWxlKTtcclxuXHJcbi8vICAgICB0cnkge1xyXG4vLyAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cDovL2xvY2FsaG9zdDozMDEyL2FwaS9hbmFseXplLWV4Y2VsXCIsIHtcclxuLy8gICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4vLyAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxyXG4vLyAgICAgICB9KTtcclxuXHJcbi8vICAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlLlwiKTtcclxuLy8gICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4vLyAgICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gcmVzdWx0LmRhdGE/LnByb2Nlc3NlZERhdGE7XHJcblxyXG4vLyAgICAgICBpZiAoIXByb2Nlc3NlZERhdGEpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzcG9uc2Ugc3RydWN0dXJlLlwiKTtcclxuXHJcbi8vICAgICAgIGNvbnN0IGdlbmVyYXRlQ2hhcnREYXRhID0gKGNoYXJ0VHlwZTogc3RyaW5nKTogQ2hhcnREYXRhIHwgbnVsbCA9PiB7XHJcbi8vICAgICAgICAgY29uc3QgY2hhcnRJbmZvID0gcHJvY2Vzc2VkRGF0YVtjaGFydFR5cGVdPy5bMF07XHJcbi8vICAgICAgICAgaWYgKCFjaGFydEluZm8pIHJldHVybiBudWxsO1xyXG5cclxuLy8gICAgICAgICBjb25zdCBsYWJlbHMgPSBPYmplY3Qua2V5cyhjaGFydEluZm8uZGF0YSk7XHJcbi8vICAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhjaGFydEluZm8uZGF0YSk7XHJcblxyXG4vLyAgICAgICAgIHJldHVybiB7XHJcbi8vICAgICAgICAgICBsYWJlbHMsXHJcbi8vICAgICAgICAgICBkYXRhc2V0czogW1xyXG4vLyAgICAgICAgICAgICB7XHJcbi8vICAgICAgICAgICAgICAgbGFiZWw6IGNoYXJ0SW5mby5sYWJlbCB8fCBjaGFydFR5cGUsXHJcbi8vICAgICAgICAgICAgICAgZGF0YTogdmFsdWVzIGFzIG51bWJlcltdLFxyXG4vLyAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY2hhcnRUeXBlLmluY2x1ZGVzKFwiQmFyXCIpXHJcbi8vICAgICAgICAgICAgICAgICA/IFwicmdiYSg1NCwgMTYyLCAyMzUsIDAuNSlcIlxyXG4vLyAgICAgICAgICAgICAgICAgOiBcInJnYmEoMjU1LCA5OSwgMTMyLCAwLjUpXCIsXHJcbi8vICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIilcclxuLy8gICAgICAgICAgICAgICAgID8gXCJyZ2JhKDI1NSwgOTksIDEzMiwgMSlcIlxyXG4vLyAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXHJcbi8vICAgICAgICAgICAgICAgZmlsbDogIWNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIiksXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICBdLFxyXG4vLyAgICAgICAgIH07XHJcbi8vICAgICAgIH07XHJcblxyXG4vLyAgICAgICBzZXRDaGFydERhdGEoe1xyXG4vLyAgICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiU2NhdHRlciBQbG90XCIpLFxyXG4vLyAgICAgICAgIHBpZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJQaWUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgZG9udXRDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiRG9udXQgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgbGluZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJMaW5lIENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGJhckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJCYXIgQ2hhcnRcIiksXHJcbi8vICAgICAgIH0pO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlOlwiLCBlcnJvcik7XHJcbi8vICAgICB9IGZpbmFsbHkge1xyXG4vLyAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuLy8gICAgIH1cclxuLy8gICB9O1xyXG5cclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgaWYgKHNlbGVjdGVkQ2hhcnQgJiYgY2hhcnREYXRhW3NlbGVjdGVkQ2hhcnRdKSB7XHJcbi8vICAgICAgIGNvbnN0IGJhc2VMYWJlbHMgPSBjaGFydERhdGFbc2VsZWN0ZWRDaGFydF0/LmxhYmVscyB8fCBbXTtcclxuLy8gICAgICAgc2V0Q2hhcnRXaWR0aCgoc2VsZWN0ZWRMYWJlbHMubGVuZ3RoIHx8IGJhc2VMYWJlbHMubGVuZ3RoKSAqIDE1MCk7XHJcbi8vICAgICB9XHJcbi8vICAgfSwgW3NlbGVjdGVkQ2hhcnQsIHNlbGVjdGVkTGFiZWxzLCBjaGFydERhdGFdKTtcclxuICBcclxuXHJcbi8vICAgY29uc3QgZ2V0Q2hhcnRPcHRpb25zID0gKHR5cGU6IHN0cmluZykgPT4gKHtcclxuLy8gICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbi8vICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcclxuLy8gICAgIHNjYWxlczogW1wicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSlcclxuLy8gICAgICAgPyB7fVxyXG4vLyAgICAgICA6IHtcclxuLy8gICAgICAgICAgIHg6IHtcclxuLy8gICAgICAgICAgICAgdGlja3M6IHtcclxuLy8gICAgICAgICAgICAgICBhdXRvU2tpcDogZmFsc2UsXHJcbi8vICAgICAgICAgICAgICAgbWF4Um90YXRpb246IHR5cGUgPT09ICdiYXJDaGFydERhdGEnIHx8IHR5cGUgPT09ICdzY2F0dGVyQ2hhcnREYXRhJyA/IDIwIDogMTAwLFxyXG4vLyAgICAgICAgICAgICAgIG1pblJvdGF0aW9uOiB0eXBlID09PSAnYmFyQ2hhcnREYXRhJyB8fCB0eXBlID09PSAnc2NhdHRlckNoYXJ0RGF0YScgPyAwIDogOTAsXHJcbi8vICAgICAgICAgICAgICAgYXV0b1NraXBQYWRkaW5nOiAyMCxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgICAgZ3JpZDoge1xyXG4vLyAgICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbi8vICAgICAgICAgICAgICAgZHJhd1RpY2tzOiBmYWxzZSxcclxuLy8gICAgICAgICAgICAgICB0aWNrTGVuZ3RoOiAxMDAsXHJcbi8vICAgICAgICAgICAgICAgbGluZVdpZHRoOiAxXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgeToge1xyXG4vLyAgICAgICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgdGlja3M6IHtcclxuLy8gICAgICAgICAgICAgICBwcmVjaXNpb246IDAsXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICBwbHVnaW5zOiB7XHJcbi8vICAgICAgIGxlZ2VuZDoge1xyXG4vLyAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbi8vICAgICAgICAgcG9zaXRpb246IFwidG9wXCIsXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICAgIHRvb2x0aXA6IHtcclxuLy8gICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4vLyAgICAgICB9LFxyXG4vLyAgICAgfSxcclxuLy8gICB9KTtcclxuXHJcbi8vICAgY29uc3QgYXBwbHlGaWx0ZXIgPSAoZGF0YTogQ2hhcnREYXRhIHwgbnVsbCkgPT4ge1xyXG4vLyAgICAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcclxuXHJcbi8vICAgICBjb25zdCBmaWx0ZXJlZExhYmVscyA9IHNlbGVjdGVkTGFiZWxzLmxlbmd0aFxyXG4vLyAgICAgICA/IGRhdGEubGFiZWxzLmZpbHRlcihsYWJlbCA9PiBzZWxlY3RlZExhYmVscy5pbmNsdWRlcyhsYWJlbCkpXHJcbi8vICAgICAgIDogZGF0YS5sYWJlbHM7XHJcblxyXG4vLyAgICAgY29uc3QgZmlsdGVyZWREYXRhID0gZGF0YS5kYXRhc2V0cy5tYXAoZGF0YXNldCA9PiAoe1xyXG4vLyAgICAgICAuLi5kYXRhc2V0LFxyXG4vLyAgICAgICBkYXRhOiBmaWx0ZXJlZExhYmVscy5tYXAobGFiZWwgPT4gZGF0YXNldC5kYXRhW2RhdGEubGFiZWxzLmluZGV4T2YobGFiZWwpXSlcclxuLy8gICAgIH0pKTtcclxuXHJcbi8vICAgICByZXR1cm4ge1xyXG4vLyAgICAgICBsYWJlbHM6IGZpbHRlcmVkTGFiZWxzLFxyXG4vLyAgICAgICBkYXRhc2V0czogZmlsdGVyZWREYXRhLFxyXG4vLyAgICAgfTtcclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVDaGVja2JveENoYW5nZSA9IChsYWJlbDogc3RyaW5nKSA9PiB7XHJcbi8vICAgICBzZXRTZWxlY3RlZExhYmVscyhwcmV2ID0+XHJcbi8vICAgICAgIHByZXYuaW5jbHVkZXMobGFiZWwpXHJcbi8vICAgICAgICAgPyBwcmV2LmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IGxhYmVsKVxyXG4vLyAgICAgICAgIDogWy4uLnByZXYsIGxhYmVsXVxyXG4vLyAgICAgKTtcclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVTZWxlY3RBbGwgPSAoKSA9PiB7XHJcbi8vICAgICBpZiAoc2VsZWN0ZWRDaGFydCAmJiBjaGFydERhdGFbc2VsZWN0ZWRDaGFydF0pIHtcclxuLy8gICAgICAgc2V0U2VsZWN0ZWRMYWJlbHMoY2hhcnREYXRhW3NlbGVjdGVkQ2hhcnRdPy5sYWJlbHMgfHwgW10pO1xyXG4vLyAgICAgfVxyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZUNsZWFyQWxsID0gKCkgPT4ge1xyXG4vLyAgICAgc2V0U2VsZWN0ZWRMYWJlbHMoW10pO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IHJlbmRlckNoYXJ0ID0gKHR5cGU6IHN0cmluZywgQ2hhcnRDb21wb25lbnQ6IGFueSkgPT4ge1xyXG4vLyAgICAgY29uc3QgZGF0YSA9IGFwcGx5RmlsdGVyKGNoYXJ0RGF0YVt0eXBlXSk7XHJcblxyXG4vLyAgICAgaWYgKCFsb2FkaW5nICYmIGRhdGEpIHtcclxuLy8gICAgICAgcmV0dXJuIChcclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQgcC00IGJvcmRlciByb3VuZGVkIHNoYWRvdy1zbVwiPlxyXG4vLyAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogXCIxMDAlXCIsIG92ZXJmbG93WDogXCJhdXRvXCIgfX0+XHJcbi8vICAgICAgICAgICAgIDxkaXZcclxuLy8gICAgICAgICAgICAgICBzdHlsZT17e1xyXG4vLyAgICAgICAgICAgICAgICAgbWluV2lkdGg6IFtcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSlcclxuLy8gICAgICAgICAgICAgICAgICAgPyBgJHtjaGFydFdpZHRofXB4YFxyXG4vLyAgICAgICAgICAgICAgICAgICA6IFwiYXV0b1wiLFxyXG4vLyAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjQwMHB4XCIsXHJcbi8vICAgICAgICAgICAgICAgfX1cclxuLy8gICAgICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgICAgIDxDaGFydENvbXBvbmVudCBkYXRhPXtkYXRhfSBvcHRpb25zPXtnZXRDaGFydE9wdGlvbnModHlwZSl9IC8+XHJcbi8vICAgICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICk7XHJcbi8vICAgICB9XHJcbi8vICAgICByZXR1cm4gbnVsbDtcclxuLy8gICB9O1xyXG5cclxuLy8gICByZXR1cm4gKFxyXG4vLyAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIG1kOmZsZXgtcm93IGgtc2NyZWVuIGJvcmRlciBib3JkZXItYmxhY2tcIj5cclxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0xLzQgYmctd2hpdGUgcC01IGJvcmRlci10IG1kOmJvcmRlci1sIG1kOmJvcmRlci1ibGFja1wiPlxyXG4vLyAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+VXBsb2FkIEZpbGU8L2gyPlxyXG4vLyAgICAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIG9uQ2hhbmdlPXtoYW5kbGVGaWxlQ2hhbmdlfSBjbGFzc05hbWU9XCJib3JkZXIgcC0yIHctZnVsbFwiIC8+XHJcbi8vICAgICAgICAgPGJ1dHRvblxyXG4vLyAgICAgICAgICAgb25DbGljaz17aGFuZGxlU3VibWl0fVxyXG4vLyAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctYmx1ZS01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBtdC00XCJcclxuLy8gICAgICAgICA+XHJcbi8vICAgICAgICAgICA8QnNVcGxvYWQgY2xhc3NOYW1lPVwibXItMlwiIC8+IFN1Ym1pdFxyXG4vLyAgICAgICAgIDwvYnV0dG9uPlxyXG5cclxuLy8gICAgICAgICB7c2VsZWN0ZWRDaGFydCAmJiAoXHJcbi8vICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTRcIj5cclxuLy8gICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGRcIj5GaWx0ZXJzPC9oMz5cclxuLy8gICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtoYW5kbGVTZWxlY3RBbGx9IGNsYXNzTmFtZT1cImJnLWdyZWVuLTUwMCB0ZXh0LXdoaXRlIHB4LTIgcHktMSByb3VuZGVkIG10LTJcIj5TZWxlY3QgQWxsPC9idXR0b24+XHJcbi8vICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlQ2xlYXJBbGx9IGNsYXNzTmFtZT1cImJnLXJlZC01MDAgdGV4dC13aGl0ZSBweC0yIHB5LTEgcm91bmRlZCBtdC0yIG1sLTJcIj5DbGVhciBBbGw8L2J1dHRvbj5cclxuLy8gICAgICAgICAgICAge2NoYXJ0RGF0YVtzZWxlY3RlZENoYXJ0XT8ubGFiZWxzLm1hcChsYWJlbCA9PiAoXHJcbi8vICAgICAgICAgICAgICAgPGRpdiBrZXk9e2xhYmVsfSBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlclwiPlxyXG4vLyAgICAgICAgICAgICAgICAgPGlucHV0XHJcbi8vICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXHJcbi8vICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3NlbGVjdGVkTGFiZWxzLmluY2x1ZGVzKGxhYmVsKX1cclxuLy8gICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IGhhbmRsZUNoZWNrYm94Q2hhbmdlKGxhYmVsKX1cclxuLy8gICAgICAgICAgICAgICAgIC8+XHJcbi8vICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwibWwtMlwiPntsYWJlbH08L2xhYmVsPlxyXG4vLyAgICAgICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICAgICApKX1cclxuLy8gICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICl9XHJcblxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBzcGFjZS15LTIgbXQtNFwiPlxyXG4vLyAgICAgICAgICAge1tcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIiwgXCJzY2F0dGVyQ2hhcnREYXRhXCIsIFwicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0ubWFwKFxyXG4vLyAgICAgICAgICAgICAodHlwZSkgPT4gKFxyXG4vLyAgICAgICAgICAgICAgIDxidXR0b25cclxuLy8gICAgICAgICAgICAgICAgIGtleT17dHlwZX1cclxuLy8gICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcclxuLy8gICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRDaGFydCh0eXBlKTtcclxuLy8gICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRMYWJlbHMoW10pO1xyXG4vLyAgICAgICAgICAgICAgICAgfX1cclxuLy8gICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInAtMiBiZy1ncmF5LTMwMCByb3VuZGVkIGhvdmVyOmJnLWdyYXktNDAwXCJcclxuLy8gICAgICAgICAgICAgICA+XHJcbi8vICAgICAgICAgICAgICAgICB7dHlwZS5yZXBsYWNlKFwiQ2hhcnREYXRhXCIsIFwiIENoYXJ0XCIpfVxyXG4vLyAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgICAgICApXHJcbi8vICAgICAgICAgICApfVxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICA8L2Rpdj5cclxuXHJcbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMy80IGJnLWdyYXktMTAwIHAtNSBvdmVyZmxvdy1hdXRvXCI+XHJcbi8vICAgICAgICAge2xvYWRpbmcgPyAoXHJcbi8vICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIGgtZnVsbFwiPlxyXG4vLyAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwaW5uZXItYm9yZGVyIGFuaW1hdGUtc3BpbiBib3JkZXItdC00IGJvcmRlci1ibHVlLTUwMCByb3VuZGVkLWZ1bGwgdy0xMiBoLTEyXCI+PC9kaXY+XHJcbi8vICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICApIDogKFxyXG4vLyAgICAgICAgICAgcmVuZGVyQ2hhcnQoc2VsZWN0ZWRDaGFydCwge1xyXG4vLyAgICAgICAgICAgICBsaW5lQ2hhcnREYXRhOiBMaW5lLFxyXG4vLyAgICAgICAgICAgICBiYXJDaGFydERhdGE6IEJhcixcclxuLy8gICAgICAgICAgICAgc2NhdHRlckNoYXJ0RGF0YTogU2NhdHRlcixcclxuLy8gICAgICAgICAgICAgcGllQ2hhcnREYXRhOiBQaWUsXHJcbi8vICAgICAgICAgICAgIGRvbnV0Q2hhcnREYXRhOiBEb3VnaG51dCxcclxuLy8gICAgICAgICAgIH1bc2VsZWN0ZWRDaGFydF0pXHJcbi8vICAgICAgICAgKX1cclxuLy8gICAgICAgPC9kaXY+XHJcbi8vICAgICA8L2Rpdj5cclxuLy8gICApO1xyXG4vLyB9XHJcblxyXG5cclxuLy8gXCJ1c2UgY2xpZW50XCI7XHJcbi8vIGltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuLy8gaW1wb3J0IHsgQmFyLCBMaW5lLCBEb3VnaG51dCwgUGllLCBTY2F0dGVyIH0gZnJvbSBcInJlYWN0LWNoYXJ0anMtMlwiO1xyXG4vLyBpbXBvcnQge1xyXG4vLyAgIENoYXJ0IGFzIENoYXJ0SlMsXHJcbi8vICAgQ2F0ZWdvcnlTY2FsZSxcclxuLy8gICBMaW5lYXJTY2FsZSxcclxuLy8gICBCYXJFbGVtZW50LFxyXG4vLyAgIExpbmVFbGVtZW50LFxyXG4vLyAgIFBvaW50RWxlbWVudCxcclxuLy8gICBBcmNFbGVtZW50LFxyXG4vLyAgIFRpdGxlLFxyXG4vLyAgIFRvb2x0aXAsXHJcbi8vICAgTGVnZW5kLFxyXG4vLyB9IGZyb20gXCJjaGFydC5qc1wiO1xyXG4vLyBpbXBvcnQgeyBCc1VwbG9hZCB9IGZyb20gXCJyZWFjdC1pY29ucy9ic1wiO1xyXG4vLyBpbXBvcnQgem9vbVBsdWdpbiBmcm9tIFwiY2hhcnRqcy1wbHVnaW4tem9vbVwiO1xyXG4vLyBpbXBvcnQgeyBsb2cgfSBmcm9tIFwibm9kZTpjb25zb2xlXCI7XHJcbiBcclxuLy8gQ2hhcnRKUy5yZWdpc3RlcihcclxuLy8gICBDYXRlZ29yeVNjYWxlLFxyXG4vLyAgIExpbmVhclNjYWxlLFxyXG4vLyAgIEJhckVsZW1lbnQsXHJcbi8vICAgTGluZUVsZW1lbnQsXHJcbi8vICAgUG9pbnRFbGVtZW50LFxyXG4vLyAgIEFyY0VsZW1lbnQsXHJcbi8vICAgVGl0bGUsXHJcbi8vICAgVG9vbHRpcCxcclxuLy8gICBMZWdlbmQsXHJcbi8vICAgem9vbVBsdWdpblxyXG4vLyApO1xyXG4gXHJcbi8vIGludGVyZmFjZSBDaGFydERhdGEge1xyXG4vLyAgIGxhYmVsczogc3RyaW5nW107XHJcbi8vICAgZGF0YXNldHM6IHtcclxuLy8gICAgIGxhYmVsOiBzdHJpbmc7XHJcbi8vICAgICBkYXRhOiBudW1iZXJbXTtcclxuLy8gICAgIGJhY2tncm91bmRDb2xvcj86IHN0cmluZztcclxuLy8gICAgIGJvcmRlckNvbG9yPzogc3RyaW5nO1xyXG4vLyAgICAgZmlsbD86IGJvb2xlYW47XHJcbi8vICAgfVtdO1xyXG4vLyB9XHJcbiBcclxuLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGFzaGJvYXJkKCkge1xyXG4vLyAgIGNvbnN0IFtjaGFydERhdGEsIHNldENoYXJ0RGF0YV0gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBDaGFydERhdGEgfCBudWxsPj4oe1xyXG4vLyAgICAgc2NhdHRlckNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIHBpZUNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGRvbnV0Q2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgbGluZUNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGJhckNoYXJ0RGF0YTogbnVsbCxcclxuLy8gICB9KTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRGaWxlLCBzZXRTZWxlY3RlZEZpbGVdID0gdXNlU3RhdGU8RmlsZSB8IG51bGw+KG51bGwpO1xyXG4vLyAgIGNvbnN0IFtzZWxlY3RlZENoYXJ0LCBzZXRTZWxlY3RlZENoYXJ0XSA9IHVzZVN0YXRlPHN0cmluZz4oXCJsaW5lQ2hhcnREYXRhXCIpO1xyXG4vLyAgIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcclxuLy8gICBjb25zdCBbY2hhcnRXaWR0aCwgc2V0Q2hhcnRXaWR0aF0gPSB1c2VTdGF0ZTxudW1iZXI+KDApO1xyXG4gXHJcbi8vICAgY29uc3QgaGFuZGxlRmlsZUNoYW5nZSA9IChldmVudDogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcclxuLy8gICAgIHNldFNlbGVjdGVkRmlsZShldmVudC50YXJnZXQuZmlsZXM/LlswXSB8fCBudWxsKTtcclxuLy8gICB9O1xyXG4gXHJcbi8vICAgY29uc3QgaGFuZGxlU3VibWl0ID0gYXN5bmMgKCkgPT4ge1xyXG4vLyAgICAgaWYgKCFzZWxlY3RlZEZpbGUpIHJldHVybjtcclxuLy8gICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcbiBcclxuLy8gICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbi8vICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIHNlbGVjdGVkRmlsZSk7XHJcbiBcclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwOi8vbG9jYWxob3N0OjMwMTIvYXBpL2FuYWx5emUtZXhjZWxcIiwge1xyXG4vLyAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbi8vICAgICAgICAgYm9keTogZm9ybURhdGEsXHJcbi8vICAgICAgIH0pO1xyXG4gXHJcbi8vICAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlLlwiKTtcclxuLy8gICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4vLyAgICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gcmVzdWx0LmRhdGE/LnByb2Nlc3NlZERhdGE7XHJcbi8vIGNvbnNvbGUubG9nKFwicHJvY2Vzc2VkRGF0YVwiLHByb2Nlc3NlZERhdGEpO1xyXG4gXHJcbi8vICAgICAgIGlmICghcHJvY2Vzc2VkRGF0YSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBzdHJ1Y3R1cmUuXCIpO1xyXG4gXHJcbi8vICAgICAgIGNvbnN0IGdlbmVyYXRlQ2hhcnREYXRhID0gKGNoYXJ0VHlwZTogc3RyaW5nKTogQ2hhcnREYXRhIHwgbnVsbCA9PiB7XHJcbi8vICAgICAgICAgY29uc3QgY2hhcnRJbmZvID0gcHJvY2Vzc2VkRGF0YVtjaGFydFR5cGVdPy5bMF07XHJcbi8vICAgICAgICAgaWYgKCFjaGFydEluZm8pIHJldHVybiBudWxsO1xyXG4gXHJcbi8vICAgICAgICAgY29uc3QgbGFiZWxzID0gT2JqZWN0LmtleXMoY2hhcnRJbmZvLmRhdGEpO1xyXG4vLyAgICAgICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoY2hhcnRJbmZvLmRhdGEpO1xyXG4vLyAgY29uc29sZS5sb2coXCJsYWJlbHMubGVuZ3RoIFwiLGNoYXJ0VHlwZSxsYWJlbHMubGVuZ3RoICk7XHJcbi8vICBjb25zb2xlLmxvZyhcInZhbHVlcy5sZW5ndGggXCIsY2hhcnRUeXBlLHZhbHVlcy5sZW5ndGggKTtcclxuXHJcbiBcclxuLy8gICAgICAgICBzZXRDaGFydFdpZHRoKGxhYmVscy5sZW5ndGggKiAxNTApO1xyXG4gXHJcbi8vICAgICAgICAgcmV0dXJuIHtcclxuLy8gICAgICAgICAgIGxhYmVscyxcclxuLy8gICAgICAgICAgIGRhdGFzZXRzOiBbXHJcbi8vICAgICAgICAgICAgIHtcclxuLy8gICAgICAgICAgICAgICBsYWJlbDogY2hhcnRJbmZvLmxhYmVsIHx8IGNoYXJ0VHlwZSxcclxuLy8gICAgICAgICAgICAgICBkYXRhOiB2YWx1ZXMgYXMgbnVtYmVyW10sXHJcbi8vICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjaGFydFR5cGUuaW5jbHVkZXMoXCJCYXJcIilcclxuLy8gICAgICAgICAgICAgICAgID8gXCJyZ2JhKDU0LCAxNjIsIDIzNSwgMC41KVwiXHJcbi8vICAgICAgICAgICAgICAgICA6IFwicmdiYSgyNTUsIDk5LCAxMzIsIDAuNSlcIixcclxuLy8gICAgICAgICAgICAgICBib3JkZXJDb2xvcjogY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKVxyXG4vLyAgICAgICAgICAgICAgICAgPyBcInJnYmEoMjU1LCA5OSwgMTMyLCAxKVwiXHJcbi8vICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcclxuLy8gICAgICAgICAgICAgICBmaWxsOiAhY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIF0sXHJcbi8vICAgICAgICAgfTtcclxuLy8gICAgICAgfTtcclxuLy8gY29uc29sZS5sb2coXCJnZW5lcmF0ZUNoYXJ0RGF0YVwiLGdlbmVyYXRlQ2hhcnREYXRhKTtcclxuIFxyXG4vLyAgICAgICBzZXRDaGFydERhdGEoe1xyXG4vLyAgICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiU2NhdHRlciBQbG90XCIpLFxyXG4vLyAgICAgICAgIHBpZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJQaWUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgZG9udXRDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiRG9udXQgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgbGluZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJMaW5lIENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGJhckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJCYXIgQ2hhcnRcIiksXHJcbi8vICAgICAgIH0pO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlOlwiLCBlcnJvcik7XHJcbi8vICAgICB9IGZpbmFsbHkge1xyXG4vLyAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuLy8gICAgIH1cclxuLy8gICB9O1xyXG4gXHJcbi8vICAgY29uc3QgZ2V0Q2hhcnRPcHRpb25zID0gKHR5cGU6IHN0cmluZykgPT4gKHtcclxuICAgXHJcbi8vICAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4vLyAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXHJcbi8vICAgICBzY2FsZXM6IFtcInBpZUNoYXJ0RGF0YVwiLCBcImRvbnV0Q2hhcnREYXRhXCJdLmluY2x1ZGVzKHR5cGUpXHJcbi8vICAgICAgID8ge31cclxuLy8gICAgICAgOiB7XHJcbi8vICAgICAgICAgeDoge1xyXG4vLyAgICAgICAgICAgdGlja3M6IHtcclxuLy8gICAgICAgICAgICAgYXV0b1NraXA6IGZhbHNlLFxyXG4vLyAgICAgICAgICAgICBtYXhSb3RhdGlvbjogdHlwZSA9PT0gJ2JhckNoYXJ0RGF0YScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXJDaGFydERhdGEnID8gMjAgOiAxMDAsXHJcbi8vICAgICAgICAgbWluUm90YXRpb246IHR5cGUgPT09ICdiYXJDaGFydERhdGEnIHx8IHR5cGUgPT09ICdzY2F0dGVyQ2hhcnREYXRhJyA/IDAgOiA5MCxcclxuLy8gICAgICAgICAgICAgYXV0b1NraXBQYWRkaW5nOiAyMCxcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICBncmlkOiB7XHJcbi8vICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbi8vICAgICAgICAgICAgIGRyYXdUaWNrczogZmFsc2UsXHJcbi8vICAgICAgICAgICAgIHRpY2tMZW5ndGg6IDEwMCxcclxuLy8gICAgICAgICAgICAgbGluZVdpZHRoOiAxXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICB5OiB7XHJcbi8vICAgICAgICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxyXG4vLyAgICAgICAgICAgICB0aWNrczoge1xyXG4vLyAgICAgICAgICAgICAgIHByZWNpc2lvbjogMCxcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgIHBsdWdpbnM6IHtcclxuLy8gICAgICAgbGVnZW5kOiB7XHJcbi8vICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICBwb3NpdGlvbjogXCJ0b3BcIixcclxuLy8gICAgICAgfSxcclxuLy8gICAgICAgdG9vbHRpcDoge1xyXG4vLyAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICB9LFxyXG4vLyAgIH0pO1xyXG4gXHJcbi8vICAgY29uc3QgcmVuZGVyQ2hhcnQgPSAodHlwZTogc3RyaW5nLCBDaGFydENvbXBvbmVudDogYW55KSA9PiB7XHJcbi8vICAgICBjb25zdCBkYXRhID0gY2hhcnREYXRhW3R5cGVdO1xyXG4vLyAgICAgaWYgKCFsb2FkaW5nICYmIGRhdGEpIHtcclxuLy8gICAgICAgcmV0dXJuIChcclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQgcC00IGJvcmRlciByb3VuZGVkIHNoYWRvdy1zbVwiPlxyXG4vLyAgICAgICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogXCIxMDAlXCIsIG92ZXJmbG93WDogXCJhdXRvXCIgfX0+XHJcbi8vICAgICAgICAgICAgIDxkaXZcclxuLy8gICAgICAgICAgICAgICBzdHlsZT17e1xyXG4vLyAgICAgICAgICAgICAgICAgbWluV2lkdGg6IFtcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSlcclxuLy8gICAgICAgICAgICAgICAgICAgPyBgJHtjaGFydFdpZHRofXB4YFxyXG4vLyAgICAgICAgICAgICAgICAgICA6IFwiYXV0b1wiLFxyXG4vLyAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjQwMHB4XCIsXHJcbi8vICAgICAgICAgICAgICAgfX1cclxuLy8gICAgICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgICAgIDxDaGFydENvbXBvbmVudCBkYXRhPXtkYXRhfSBvcHRpb25zPXtnZXRDaGFydE9wdGlvbnModHlwZSl9IC8+XHJcbi8vICAgICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICk7XHJcbi8vICAgICB9XHJcbi8vICAgICByZXR1cm4gbnVsbDtcclxuLy8gICB9O1xyXG4gXHJcbi8vICAgcmV0dXJuIChcclxuLy8gICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBtZDpmbGV4LXJvdyBoLXNjcmVlbiBib3JkZXIgYm9yZGVyLWJsYWNrXCI+XHJcbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMS80IGJnLXdoaXRlIHAtNSBib3JkZXItdCBtZDpib3JkZXItbCBtZDpib3JkZXItYmxhY2tcIj5cclxuLy8gICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPlVwbG9hZCBGaWxlPC9oMj5cclxuLy8gICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIiBvbkNoYW5nZT17aGFuZGxlRmlsZUNoYW5nZX0gY2xhc3NOYW1lPVwiYm9yZGVyIHAtMiB3LWZ1bGxcIiAvPlxyXG4vLyAgICAgICAgIDxidXR0b25cclxuLy8gICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVN1Ym1pdH1cclxuLy8gICAgICAgICAgIGNsYXNzTmFtZT1cImJnLWJsdWUtNTAwIHRleHQtd2hpdGUgcC0yIHJvdW5kZWQgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgbXQtNFwiXHJcbi8vICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgPEJzVXBsb2FkIGNsYXNzTmFtZT1cIm1yLTJcIiAvPiBTdWJtaXRcclxuLy8gICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgc3BhY2UteS0yIG10LTRcIj5cclxuLy8gICAgICAgICAgIHtbXCJsaW5lQ2hhcnREYXRhXCIsIFwiYmFyQ2hhcnREYXRhXCIsIFwic2NhdHRlckNoYXJ0RGF0YVwiLCBcInBpZUNoYXJ0RGF0YVwiLCBcImRvbnV0Q2hhcnREYXRhXCJdLm1hcChcclxuLy8gICAgICAgICAgICAgKHR5cGUpID0+IChcclxuLy8gICAgICAgICAgICAgICA8YnV0dG9uXHJcbi8vICAgICAgICAgICAgICAgICBrZXk9e3R5cGV9XHJcbi8vICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTZWxlY3RlZENoYXJ0KHR5cGUpfVxyXG4vLyAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicC0yIGJnLWdyYXktMzAwIHJvdW5kZWQgaG92ZXI6YmctZ3JheS00MDBcIlxyXG4vLyAgICAgICAgICAgICAgID5cclxuLy8gICAgICAgICAgICAgICAgIHt0eXBlLnJlcGxhY2UoXCJDaGFydERhdGFcIiwgXCIgQ2hhcnRcIil9XHJcbi8vICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgICAgIClcclxuLy8gICAgICAgICAgICl9XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgIDwvZGl2PlxyXG4gXHJcbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMy80IGJnLWdyYXktMTAwIHAtNSBvdmVyZmxvdy1hdXRvXCI+XHJcbi8vICAgICAgICAge2xvYWRpbmcgPyAoXHJcbi8vICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIGgtZnVsbFwiPlxyXG4vLyAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwaW5uZXItYm9yZGVyIGFuaW1hdGUtc3BpbiBib3JkZXItdC00IGJvcmRlci1ibHVlLTUwMCByb3VuZGVkLWZ1bGwgdy0xMiBoLTEyXCI+PC9kaXY+XHJcbi8vICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICApIDogKFxyXG4vLyAgICAgICAgICAgcmVuZGVyQ2hhcnQoc2VsZWN0ZWRDaGFydCwge1xyXG4vLyAgICAgICAgICAgICBsaW5lQ2hhcnREYXRhOiBMaW5lLFxyXG4vLyAgICAgICAgICAgICBiYXJDaGFydERhdGE6IEJhcixcclxuLy8gICAgICAgICAgICAgc2NhdHRlckNoYXJ0RGF0YTogU2NhdHRlcixcclxuLy8gICAgICAgICAgICAgcGllQ2hhcnREYXRhOiBQaWUsXHJcbi8vICAgICAgICAgICAgIGRvbnV0Q2hhcnREYXRhOiBEb3VnaG51dCxcclxuLy8gICAgICAgICAgIH1bc2VsZWN0ZWRDaGFydF0pXHJcbi8vICAgICAgICAgKX1cclxuLy8gICAgICAgPC9kaXY+XHJcbi8vICAgICA8L2Rpdj5cclxuLy8gICApO1xyXG4vLyB9XHJcblxyXG5cclxuLy8gXCJ1c2UgY2xpZW50XCI7XHJcbi8vIGltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuLy8gaW1wb3J0IHsgQmFyLCBMaW5lLCBEb3VnaG51dCwgUGllLCBTY2F0dGVyIH0gZnJvbSBcInJlYWN0LWNoYXJ0anMtMlwiO1xyXG4vLyBpbXBvcnQge1xyXG4vLyAgIENoYXJ0IGFzIENoYXJ0SlMsXHJcbi8vICAgQ2F0ZWdvcnlTY2FsZSxcclxuLy8gICBMaW5lYXJTY2FsZSxcclxuLy8gICBCYXJFbGVtZW50LFxyXG4vLyAgIExpbmVFbGVtZW50LFxyXG4vLyAgIFBvaW50RWxlbWVudCxcclxuLy8gICBBcmNFbGVtZW50LFxyXG4vLyAgIFRpdGxlLFxyXG4vLyAgIFRvb2x0aXAsXHJcbi8vICAgTGVnZW5kLFxyXG4vLyB9IGZyb20gXCJjaGFydC5qc1wiO1xyXG4vLyBpbXBvcnQgeyBCc1VwbG9hZCB9IGZyb20gXCJyZWFjdC1pY29ucy9ic1wiO1xyXG4vLyBpbXBvcnQgem9vbVBsdWdpbiBmcm9tIFwiY2hhcnRqcy1wbHVnaW4tem9vbVwiO1xyXG4vLyBpbXBvcnQgeyBsb2cgfSBmcm9tIFwibm9kZTpjb25zb2xlXCI7XHJcblxyXG4vLyBDaGFydEpTLnJlZ2lzdGVyKFxyXG4vLyAgIENhdGVnb3J5U2NhbGUsXHJcbi8vICAgTGluZWFyU2NhbGUsXHJcbi8vICAgQmFyRWxlbWVudCxcclxuLy8gICBMaW5lRWxlbWVudCxcclxuLy8gICBQb2ludEVsZW1lbnQsXHJcbi8vICAgQXJjRWxlbWVudCxcclxuLy8gICBUaXRsZSxcclxuLy8gICBUb29sdGlwLFxyXG4vLyAgIExlZ2VuZCxcclxuLy8gICB6b29tUGx1Z2luXHJcbi8vICk7XHJcblxyXG4vLyBpbnRlcmZhY2UgQ2hhcnREYXRhIHtcclxuLy8gICBsYWJlbHM6IHN0cmluZ1tdO1xyXG4vLyAgIGRhdGFzZXRzOiB7XHJcbi8vICAgICBsYWJlbDogc3RyaW5nO1xyXG4vLyAgICAgZGF0YTogbnVtYmVyW107XHJcbi8vICAgICBiYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmcgfCBzdHJpbmdbXTtcclxuLy8gICAgIGJvcmRlckNvbG9yPzogc3RyaW5nO1xyXG4vLyAgICAgZmlsbD86IGJvb2xlYW47XHJcbi8vICAgfVtdO1xyXG4vLyB9XHJcblxyXG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEYXNoYm9hcmQoKSB7XHJcbi8vICAgY29uc3QgW2NoYXJ0RGF0YSwgc2V0Q2hhcnREYXRhXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIENoYXJ0RGF0YSB8IG51bGw+Pih7XHJcbi8vICAgICBzY2F0dGVyQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgcGllQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgZG9udXRDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBsaW5lQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgYmFyQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgIH0pO1xyXG4vLyAgIGNvbnN0IFtzZWxlY3RlZEZpbGUsIHNldFNlbGVjdGVkRmlsZV0gPSB1c2VTdGF0ZTxGaWxlIHwgbnVsbD4obnVsbCk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkQ2hhcnQsIHNldFNlbGVjdGVkQ2hhcnRdID0gdXNlU3RhdGU8c3RyaW5nPihcImxpbmVDaGFydERhdGFcIik7XHJcbi8vICAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG4vLyAgIGNvbnN0IFtjaGFydFdpZHRoLCBzZXRDaGFydFdpZHRoXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZUZpbGVDaGFuZ2UgPSAoZXZlbnQ6IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XHJcbi8vICAgICBzZXRTZWxlY3RlZEZpbGUoZXZlbnQudGFyZ2V0LmZpbGVzPy5bMF0gfHwgbnVsbCk7XHJcbi8vICAgfTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlU3VibWl0ID0gYXN5bmMgKCkgPT4ge1xyXG4vLyAgICAgaWYgKCFzZWxlY3RlZEZpbGUpIHJldHVybjtcclxuLy8gICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcblxyXG4vLyAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuLy8gICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgc2VsZWN0ZWRGaWxlKTtcclxuXHJcbi8vICAgICB0cnkge1xyXG4vLyAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cDovL2xvY2FsaG9zdDozMDEyL2FwaS9hbmFseXplLWV4Y2VsXCIsIHtcclxuLy8gICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4vLyAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxyXG4vLyAgICAgICB9KTtcclxuXHJcbi8vICAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlLlwiKTtcclxuLy8gICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4vLyAgICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gcmVzdWx0LmRhdGE/LnByb2Nlc3NlZERhdGE7XHJcblxyXG4vLyAgICAgICBpZiAoIXByb2Nlc3NlZERhdGEpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzcG9uc2Ugc3RydWN0dXJlLlwiKTtcclxuXHJcbi8vICAgICAgIGNvbnN0IGxpZ2h0Q29sb3JzID0gW1xyXG4vLyAgICAgICAgIFwicmdiYSgxNzMsIDIxNiwgMjMwLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDE0NCwgMjM4LCAxNDQsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjU1LCAxODIsIDE5MywgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyNTUsIDIyOCwgMTgxLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDIyMSwgMTYwLCAyMjEsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjQwLCAyMzAsIDE0MCwgMC42KVwiLFxyXG4vLyAgICAgICBdO1xyXG5cclxuLy8gICAgICAgY29uc3QgZ2VuZXJhdGVDaGFydERhdGEgPSAoY2hhcnRUeXBlOiBzdHJpbmcpOiBDaGFydERhdGEgfCBudWxsID0+IHtcclxuLy8gICAgICAgICBjb25zdCBjaGFydEluZm8gPSBwcm9jZXNzZWREYXRhW2NoYXJ0VHlwZV0/LlswXTtcclxuLy8gICAgICAgICBpZiAoIWNoYXJ0SW5mbykgcmV0dXJuIG51bGw7XHJcblxyXG4vLyAgICAgICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5rZXlzKGNoYXJ0SW5mby5kYXRhKTtcclxuLy8gICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGNoYXJ0SW5mby5kYXRhKTtcclxuXHJcbi8vICAgICAgICAgc2V0Q2hhcnRXaWR0aChsYWJlbHMubGVuZ3RoICogMTUwKTtcclxuXHJcbi8vICAgICAgICAgcmV0dXJuIHtcclxuLy8gICAgICAgICAgIGxhYmVscyxcclxuLy8gICAgICAgICAgIGRhdGFzZXRzOiBbXHJcbi8vICAgICAgICAgICAgIHtcclxuLy8gICAgICAgICAgICAgICBsYWJlbDogY2hhcnRJbmZvLmxhYmVsIHx8IGNoYXJ0VHlwZSxcclxuLy8gICAgICAgICAgICAgICBkYXRhOiB2YWx1ZXMgYXMgbnVtYmVyW10sXHJcbi8vICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbXCJQaWUgQ2hhcnRcIiwgXCJEb251dCBDaGFydFwiLCBcIkJhciBDaGFydFwiXS5pbmNsdWRlcyhjaGFydFR5cGUpXHJcbi8vICAgICAgICAgICAgICAgICA/IGxpZ2h0Q29sb3JzLnNsaWNlKDAsIGxhYmVscy5sZW5ndGgpXHJcbi8vICAgICAgICAgICAgICAgICA6IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAwLjYpXCIsXHJcbi8vICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIilcclxuLy8gICAgICAgICAgICAgICAgID8gXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDEpXCJcclxuLy8gICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxyXG4vLyAgICAgICAgICAgICAgIGZpbGw6ICFjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgXSxcclxuLy8gICAgICAgICB9O1xyXG4vLyAgICAgICB9O1xyXG5cclxuLy8gICAgICAgc2V0Q2hhcnREYXRhKHtcclxuLy8gICAgICAgICBzY2F0dGVyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlNjYXR0ZXIgUGxvdFwiKSxcclxuLy8gICAgICAgICBwaWVDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiUGllIENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGRvbnV0Q2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkRvbnV0IENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGxpbmVDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiTGluZSBDaGFydFwiKSxcclxuLy8gICAgICAgICBiYXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiQmFyIENoYXJ0XCIpLFxyXG4vLyAgICAgICB9KTtcclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZTpcIiwgZXJyb3IpO1xyXG4vLyAgICAgfSBmaW5hbGx5IHtcclxuLy8gICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbi8vICAgICB9XHJcbi8vICAgfTtcclxuXHJcbi8vICAgY29uc3QgZ2V0Q2hhcnRPcHRpb25zID0gKHR5cGU6IHN0cmluZykgPT4gKHtcclxuLy8gICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbi8vICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcclxuLy8gICAgIHNjYWxlczogW1wicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSlcclxuLy8gICAgICAgPyB7fVxyXG4vLyAgICAgICA6IHtcclxuICAgICAgICAvLyB4OiB7XHJcbiAgICAgICAgLy8gICB0aWNrczoge1xyXG4gICAgICAgIC8vICAgICBhdXRvU2tpcDogZmFsc2UsXHJcbiAgICAgICAgLy8gICAgIG1heFJvdGF0aW9uOiB0eXBlID09PSAnYmFyQ2hhcnREYXRhJyB8fCB0eXBlID09PSAnc2NhdHRlckNoYXJ0RGF0YScgPyAyMCA6IDEwMCxcclxuICAgICAgICAvLyBtaW5Sb3RhdGlvbjogdHlwZSA9PT0gJ2JhckNoYXJ0RGF0YScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXJDaGFydERhdGEnID8gMCA6IDkwLFxyXG4gICAgICAgIC8vICAgICBhdXRvU2tpcFBhZGRpbmc6IDIwLFxyXG4gICAgICAgIC8vICAgfSxcclxuICAgICAgICAvLyAgIGdyaWQ6IHtcclxuICAgICAgICAvLyAgICAgZGlzcGxheTogdHJ1ZSxcclxuICAgICAgICAvLyAgICAgZHJhd1RpY2tzOiBmYWxzZSxcclxuICAgICAgICAvLyAgICAgdGlja0xlbmd0aDogMTAwLFxyXG4gICAgICAgIC8vICAgICBsaW5lV2lkdGg6IDFcclxuICAgICAgICAvLyAgIH0sXHJcbiAgICAgICAgLy8gfSxcclxuLy8gICAgICAgICAgIHk6IHtcclxuLy8gICAgICAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXHJcbi8vICAgICAgICAgICAgIHRpY2tzOiB7XHJcbi8vICAgICAgICAgICAgICAgcHJlY2lzaW9uOiAwLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgcGx1Z2luczoge1xyXG4vLyAgICAgICBsZWdlbmQ6IHtcclxuLy8gICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4vLyAgICAgICAgIHBvc2l0aW9uOiBcInRvcFwiLFxyXG4vLyAgICAgICB9LFxyXG4vLyAgICAgICB0b29sdGlwOiB7XHJcbi8vICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuLy8gICAgICAgfSxcclxuLy8gICAgIH0sXHJcbi8vICAgfSk7XHJcblxyXG4vLyAgIGNvbnN0IHJlbmRlckNoYXJ0ID0gKHR5cGU6IHN0cmluZywgQ2hhcnRDb21wb25lbnQ6IGFueSkgPT4ge1xyXG4vLyAgICAgY29uc3QgZGF0YSA9IGNoYXJ0RGF0YVt0eXBlXTtcclxuLy8gICAgIGlmICghbG9hZGluZyAmJiBkYXRhKSB7XHJcbi8vICAgICAgIHJldHVybiAoXHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkIHAtNCBib3JkZXIgcm91bmRlZCBzaGFkb3ctc21cIj5cclxuLy8gICAgICAgICAgIDxkaXYgc3R5bGU9e3sgd2lkdGg6IFwiMTAwJVwiLCBvdmVyZmxvd1g6IFwiYXV0b1wiIH19PlxyXG4vLyAgICAgICAgICAgICA8ZGl2XHJcbi8vICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuLy8gICAgICAgICAgICAgICAgIG1pbldpZHRoOiBbXCJsaW5lQ2hhcnREYXRhXCIsIFwiYmFyQ2hhcnREYXRhXCJdLmluY2x1ZGVzKHR5cGUpXHJcbi8vICAgICAgICAgICAgICAgICAgID8gYCR7Y2hhcnRXaWR0aH1weGBcclxuLy8gICAgICAgICAgICAgICAgICAgOiBcImF1dG9cIixcclxuLy8gICAgICAgICAgICAgICAgIGhlaWdodDogXCI0MDBweFwiLFxyXG4vLyAgICAgICAgICAgICAgIH19XHJcbi8vICAgICAgICAgICAgID5cclxuLy8gICAgICAgICAgICAgICA8Q2hhcnRDb21wb25lbnQgZGF0YT17ZGF0YX0gb3B0aW9ucz17Z2V0Q2hhcnRPcHRpb25zKHR5cGUpfSAvPlxyXG4vLyAgICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICApO1xyXG4vLyAgICAgfVxyXG4vLyAgICAgcmV0dXJuIG51bGw7XHJcbi8vICAgfTtcclxuXHJcbi8vICAgcmV0dXJuIChcclxuLy8gICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBtZDpmbGV4LXJvdyBoLXNjcmVlbiBib3JkZXIgYm9yZGVyLWJsYWNrXCI+XHJcbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMS80IGJnLXdoaXRlIHAtNSBib3JkZXItdCBtZDpib3JkZXItbCBtZDpib3JkZXItYmxhY2tcIj5cclxuLy8gICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPlVwbG9hZCBGaWxlPC9oMj5cclxuLy8gICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIiBvbkNoYW5nZT17aGFuZGxlRmlsZUNoYW5nZX0gY2xhc3NOYW1lPVwiYm9yZGVyIHAtMiB3LWZ1bGxcIiAvPlxyXG4vLyAgICAgICAgIDxidXR0b25cclxuLy8gICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVN1Ym1pdH1cclxuLy8gICAgICAgICAgIGNsYXNzTmFtZT1cImJnLWJsdWUtNTAwIHRleHQtd2hpdGUgcC0yIHJvdW5kZWQgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgbXQtNFwiXHJcbi8vICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgPEJzVXBsb2FkIGNsYXNzTmFtZT1cIm1yLTJcIiAvPiBTdWJtaXRcclxuLy8gICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgc3BhY2UteS0yIG10LTRcIj5cclxuLy8gICAgICAgICAgIHtbXCJsaW5lQ2hhcnREYXRhXCIsIFwiYmFyQ2hhcnREYXRhXCIsIFwic2NhdHRlckNoYXJ0RGF0YVwiLCBcInBpZUNoYXJ0RGF0YVwiLCBcImRvbnV0Q2hhcnREYXRhXCJdLm1hcChcclxuLy8gICAgICAgICAgICAgKHR5cGUpID0+IChcclxuLy8gICAgICAgICAgICAgICA8YnV0dG9uXHJcbi8vICAgICAgICAgICAgICAgICBrZXk9e3R5cGV9XHJcbi8vICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTZWxlY3RlZENoYXJ0KHR5cGUpfVxyXG4vLyAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicC0yIGJnLWdyYXktMzAwIHJvdW5kZWQgaG92ZXI6YmctZ3JheS00MDBcIlxyXG4vLyAgICAgICAgICAgICAgID5cclxuLy8gICAgICAgICAgICAgICAgIHt0eXBlLnJlcGxhY2UoXCJDaGFydERhdGFcIiwgXCIgQ2hhcnRcIil9XHJcbi8vICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgICAgIClcclxuLy8gICAgICAgICAgICl9XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgIDwvZGl2PlxyXG5cclxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0zLzQgYmctZ3JheS0xMDAgcC01IG92ZXJmbG93LWF1dG9cIj5cclxuLy8gICAgICAgICB7bG9hZGluZyA/IChcclxuLy8gICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgaC1mdWxsXCI+XHJcbi8vICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3Bpbm5lci1ib3JkZXIgYW5pbWF0ZS1zcGluIGJvcmRlci10LTQgYm9yZGVyLWJsdWUtNTAwIHJvdW5kZWQtZnVsbCB3LTEyIGgtMTJcIj48L2Rpdj5cclxuLy8gICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICkgOiAoXHJcbi8vICAgICAgICAgICByZW5kZXJDaGFydChzZWxlY3RlZENoYXJ0LCB7XHJcbi8vICAgICAgICAgICAgIGxpbmVDaGFydERhdGE6IExpbmUsXHJcbi8vICAgICAgICAgICAgIGJhckNoYXJ0RGF0YTogQmFyLFxyXG4vLyAgICAgICAgICAgICBzY2F0dGVyQ2hhcnREYXRhOiBTY2F0dGVyLFxyXG4vLyAgICAgICAgICAgICBwaWVDaGFydERhdGE6IFBpZSxcclxuLy8gICAgICAgICAgICAgZG9udXRDaGFydERhdGE6IERvdWdobnV0LFxyXG4vLyAgICAgICAgICAgfVtzZWxlY3RlZENoYXJ0XSlcclxuLy8gICAgICAgICApfVxyXG4vLyAgICAgICA8L2Rpdj5cclxuLy8gICAgIDwvZGl2PlxyXG4vLyAgICk7XHJcbi8vIH1cclxuXHJcblxyXG4vLyBcInVzZSBjbGllbnRcIjtcclxuLy8gaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG4vLyBpbXBvcnQgeyBCYXIsIExpbmUsIERvdWdobnV0LCBQaWUsIFNjYXR0ZXIgfSBmcm9tIFwicmVhY3QtY2hhcnRqcy0yXCI7XHJcbi8vIGltcG9ydCB7XHJcbi8vICAgQ2hhcnQgYXMgQ2hhcnRKUyxcclxuLy8gICBDYXRlZ29yeVNjYWxlLFxyXG4vLyAgIExpbmVhclNjYWxlLFxyXG4vLyAgIEJhckVsZW1lbnQsXHJcbi8vICAgTGluZUVsZW1lbnQsXHJcbi8vICAgUG9pbnRFbGVtZW50LFxyXG4vLyAgIEFyY0VsZW1lbnQsXHJcbi8vICAgVGl0bGUsXHJcbi8vICAgVG9vbHRpcCxcclxuLy8gICBMZWdlbmQsXHJcbi8vIH0gZnJvbSBcImNoYXJ0LmpzXCI7XHJcbi8vIGltcG9ydCB7IEJzVXBsb2FkIH0gZnJvbSBcInJlYWN0LWljb25zL2JzXCI7XHJcbi8vIGltcG9ydCB6b29tUGx1Z2luIGZyb20gXCJjaGFydGpzLXBsdWdpbi16b29tXCI7XHJcblxyXG4vLyBDaGFydEpTLnJlZ2lzdGVyKFxyXG4vLyAgIENhdGVnb3J5U2NhbGUsXHJcbi8vICAgTGluZWFyU2NhbGUsXHJcbi8vICAgQmFyRWxlbWVudCxcclxuLy8gICBMaW5lRWxlbWVudCxcclxuLy8gICBQb2ludEVsZW1lbnQsXHJcbi8vICAgQXJjRWxlbWVudCxcclxuLy8gICBUaXRsZSxcclxuLy8gICBUb29sdGlwLFxyXG4vLyAgIExlZ2VuZCxcclxuLy8gICB6b29tUGx1Z2luXHJcbi8vICk7XHJcblxyXG4vLyBpbnRlcmZhY2UgQ2hhcnREYXRhIHtcclxuLy8gICBsYWJlbHM6IHN0cmluZ1tdO1xyXG4vLyAgIGRhdGFzZXRzOiB7XHJcbi8vICAgICBsYWJlbDogc3RyaW5nO1xyXG4vLyAgICAgZGF0YTogbnVtYmVyW107XHJcbi8vICAgICBiYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmcgfCBzdHJpbmdbXTtcclxuLy8gICAgIGJvcmRlckNvbG9yPzogc3RyaW5nO1xyXG4vLyAgICAgZmlsbD86IGJvb2xlYW47XHJcbi8vICAgfVtdO1xyXG4vLyB9XHJcblxyXG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEYXNoYm9hcmQoKSB7XHJcbi8vICAgY29uc3QgW2NoYXJ0RGF0YSwgc2V0Q2hhcnREYXRhXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIENoYXJ0RGF0YSB8IG51bGw+Pih7XHJcbi8vICAgICBzY2F0dGVyQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgcGllQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgZG9udXRDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBsaW5lQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgYmFyQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgIH0pO1xyXG4vLyAgIGNvbnN0IFtzZWxlY3RlZEZpbGUsIHNldFNlbGVjdGVkRmlsZV0gPSB1c2VTdGF0ZTxGaWxlIHwgbnVsbD4obnVsbCk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkQ2hhcnQsIHNldFNlbGVjdGVkQ2hhcnRdID0gdXNlU3RhdGU8c3RyaW5nPihcImxpbmVDaGFydERhdGFcIik7XHJcbi8vICAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG4vLyAgIGNvbnN0IFtjaGFydFdpZHRoLCBzZXRDaGFydFdpZHRoXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XHJcbi8vICAgY29uc3QgW2lucHV0VmFsdWUsIHNldElucHV0VmFsdWVdID0gdXNlU3RhdGU8c3RyaW5nPihcIlwiKTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlRmlsZUNoYW5nZSA9IChldmVudDogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcclxuLy8gICAgIHNldFNlbGVjdGVkRmlsZShldmVudC50YXJnZXQuZmlsZXM/LlswXSB8fCBudWxsKTtcclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVTdWJtaXQgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICBpZiAoIXNlbGVjdGVkRmlsZSkgcmV0dXJuO1xyXG4vLyAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuXHJcbi8vICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4vLyAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBzZWxlY3RlZEZpbGUpO1xyXG5cclxuLy8gICAgIHRyeSB7XHJcbi8vICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwOi8vbG9jYWxob3N0OjMwMTIvYXBpL2FuYWx5emUtZXhjZWxcIiwge1xyXG4vLyAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbi8vICAgICAgICAgYm9keTogZm9ybURhdGEsXHJcbi8vICAgICAgIH0pO1xyXG5cclxuLy8gICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGUuXCIpO1xyXG4vLyAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbi8vICAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSByZXN1bHQuZGF0YT8ucHJvY2Vzc2VkRGF0YTtcclxuXHJcbi8vICAgICAgIGlmICghcHJvY2Vzc2VkRGF0YSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBzdHJ1Y3R1cmUuXCIpO1xyXG5cclxuLy8gICAgICAgY29uc3QgbGlnaHRDb2xvcnMgPSBbXHJcbi8vICAgICAgICAgXCJyZ2JhKDE3MywgMjE2LCAyMzAsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMTQ0LCAyMzgsIDE0NCwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyNTUsIDE4MiwgMTkzLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDI1NSwgMjI4LCAxODEsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjIxLCAxNjAsIDIyMSwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyNDAsIDIzMCwgMTQwLCAwLjYpXCIsXHJcbi8vICAgICAgIF07XHJcblxyXG4vLyAgICAgICBjb25zdCBnZW5lcmF0ZUNoYXJ0RGF0YSA9IChjaGFydFR5cGU6IHN0cmluZyk6IENoYXJ0RGF0YSB8IG51bGwgPT4ge1xyXG4vLyAgICAgICAgIGNvbnN0IGNoYXJ0SW5mbyA9IHByb2Nlc3NlZERhdGFbY2hhcnRUeXBlXT8uWzBdO1xyXG4vLyAgICAgICAgIGlmICghY2hhcnRJbmZvKSByZXR1cm4gbnVsbDtcclxuXHJcbi8vICAgICAgICAgY29uc3QgbGFiZWxzID0gT2JqZWN0LmtleXMoY2hhcnRJbmZvLmRhdGEpO1xyXG4vLyAgICAgICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoY2hhcnRJbmZvLmRhdGEpO1xyXG5cclxuLy8gICAgICAgICBzZXRDaGFydFdpZHRoKGxhYmVscy5sZW5ndGggKiAxNTApO1xyXG5cclxuLy8gICAgICAgICByZXR1cm4ge1xyXG4vLyAgICAgICAgICAgbGFiZWxzLFxyXG4vLyAgICAgICAgICAgZGF0YXNldHM6IFtcclxuLy8gICAgICAgICAgICAge1xyXG4vLyAgICAgICAgICAgICAgIGxhYmVsOiBjaGFydEluZm8ubGFiZWwgfHwgY2hhcnRUeXBlLFxyXG4vLyAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlcyBhcyBudW1iZXJbXSxcclxuLy8gICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcIlBpZSBDaGFydFwiLCBcIkRvbnV0IENoYXJ0XCIsIFwiQmFyIENoYXJ0XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSlcclxuLy8gICAgICAgICAgICAgICAgID8gbGlnaHRDb2xvcnMuc2xpY2UoMCwgbGFiZWxzLmxlbmd0aClcclxuLy8gICAgICAgICAgICAgICAgIDogXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDAuNilcIixcclxuLy8gICAgICAgICAgICAgICBib3JkZXJDb2xvcjogY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKVxyXG4vLyAgICAgICAgICAgICAgICAgPyBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMSlcIlxyXG4vLyAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXHJcbi8vICAgICAgICAgICAgICAgZmlsbDogIWNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIiksXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICBdLFxyXG4vLyAgICAgICAgIH07XHJcbi8vICAgICAgIH07XHJcblxyXG4vLyAgICAgICBzZXRDaGFydERhdGEoe1xyXG4vLyAgICAgICAgIHNjYXR0ZXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiU2NhdHRlciBQbG90XCIpLFxyXG4vLyAgICAgICAgIHBpZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJQaWUgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgZG9udXRDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiRG9udXQgQ2hhcnRcIiksXHJcbi8vICAgICAgICAgbGluZUNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJMaW5lIENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGJhckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJCYXIgQ2hhcnRcIiksXHJcbi8vICAgICAgIH0pO1xyXG4vLyAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuLy8gICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlOlwiLCBlcnJvcik7XHJcbi8vICAgICB9IGZpbmFsbHkge1xyXG4vLyAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuLy8gICAgIH1cclxuLy8gICB9O1xyXG5cclxuLy8gICBjb25zdCBoYW5kbGVTZW5kID0gKCkgPT4ge1xyXG4vLyAgICAgY29uc29sZS5sb2coXCJJbnB1dCBWYWx1ZTpcIiwgaW5wdXRWYWx1ZSk7XHJcbi8vICAgfTtcclxuXHJcbi8vICAgY29uc3QgZ2V0Q2hhcnRPcHRpb25zID0gKHR5cGU6IHN0cmluZykgPT4gKHtcclxuLy8gICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbi8vICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcclxuLy8gICAgIHNjYWxlczogW1wicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSlcclxuLy8gICAgICAgPyB7fVxyXG4vLyAgICAgICA6IHtcclxuLy8gICAgICAgICB4OiB7XHJcbi8vICAgICAgICAgICB0aWNrczoge1xyXG4vLyAgICAgICAgICAgICBhdXRvU2tpcDogZmFsc2UsXHJcbi8vICAgICAgICAgICAgIG1heFJvdGF0aW9uOiB0eXBlID09PSAnYmFyQ2hhcnREYXRhJyB8fCB0eXBlID09PSAnc2NhdHRlckNoYXJ0RGF0YScgPyAyMCA6IDEwMCxcclxuLy8gICAgICAgICBtaW5Sb3RhdGlvbjogdHlwZSA9PT0gJ2JhckNoYXJ0RGF0YScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXJDaGFydERhdGEnID8gMCA6IDkwLFxyXG4vLyAgICAgICAgICAgICBhdXRvU2tpcFBhZGRpbmc6IDIwLFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIGdyaWQ6IHtcclxuLy8gICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuLy8gICAgICAgICAgICAgZHJhd1RpY2tzOiBmYWxzZSxcclxuLy8gICAgICAgICAgICAgdGlja0xlbmd0aDogMTAwLFxyXG4vLyAgICAgICAgICAgICBsaW5lV2lkdGg6IDFcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgICAgICAgIHk6IHtcclxuLy8gICAgICAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXHJcbi8vICAgICAgICAgICAgIHRpY2tzOiB7XHJcbi8vICAgICAgICAgICAgICAgcHJlY2lzaW9uOiAwLFxyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgcGx1Z2luczoge1xyXG4vLyAgICAgICBsZWdlbmQ6IHtcclxuLy8gICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4vLyAgICAgICAgIHBvc2l0aW9uOiBcInRvcFwiLFxyXG4vLyAgICAgICB9LFxyXG4vLyAgICAgICB0b29sdGlwOiB7XHJcbi8vICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuLy8gICAgICAgfSxcclxuLy8gICAgIH0sXHJcbi8vICAgfSk7XHJcblxyXG4vLyAgIGNvbnN0IHJlbmRlckNoYXJ0ID0gKHR5cGU6IHN0cmluZywgQ2hhcnRDb21wb25lbnQ6IGFueSkgPT4ge1xyXG4vLyAgICAgY29uc3QgZGF0YSA9IGNoYXJ0RGF0YVt0eXBlXTtcclxuLy8gICAgIGlmICghbG9hZGluZyAmJiBkYXRhKSB7XHJcbi8vICAgICAgIHJldHVybiAoXHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkIHAtNCBib3JkZXIgcm91bmRlZCBzaGFkb3ctc21cIj5cclxuLy8gICAgICAgICAgIDxkaXYgc3R5bGU9e3sgd2lkdGg6IFwiMTAwJVwiLCBvdmVyZmxvd1g6IFwiYXV0b1wiIH19PlxyXG4vLyAgICAgICAgICAgICA8ZGl2XHJcbi8vICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuLy8gICAgICAgICAgICAgICAgIG1pbldpZHRoOiBbXCJsaW5lQ2hhcnREYXRhXCIsIFwiYmFyQ2hhcnREYXRhXCJdLmluY2x1ZGVzKHR5cGUpXHJcbi8vICAgICAgICAgICAgICAgICAgID8gYCR7Y2hhcnRXaWR0aH1weGBcclxuLy8gICAgICAgICAgICAgICAgICAgOiBcImF1dG9cIixcclxuLy8gICAgICAgICAgICAgICAgIGhlaWdodDogXCI0MDBweFwiLFxyXG4vLyAgICAgICAgICAgICAgIH19XHJcbi8vICAgICAgICAgICAgID5cclxuLy8gICAgICAgICAgICAgICA8Q2hhcnRDb21wb25lbnQgZGF0YT17ZGF0YX0gb3B0aW9ucz17Z2V0Q2hhcnRPcHRpb25zKHR5cGUpfSAvPlxyXG4vLyAgICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICApO1xyXG4vLyAgICAgfVxyXG4vLyAgICAgcmV0dXJuIG51bGw7XHJcbi8vICAgfTtcclxuXHJcbi8vICAgcmV0dXJuIChcclxuLy8gICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBtZDpmbGV4LXJvdyBoLXNjcmVlbiBib3JkZXIgYm9yZGVyLWJsYWNrXCI+XHJcbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMS80IGJnLXdoaXRlIHAtNSBib3JkZXItdCBtZDpib3JkZXItbCBtZDpib3JkZXItYmxhY2tcIj5cclxuLy8gICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPlVwbG9hZCBGaWxlPC9oMj5cclxuLy8gICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIiBvbkNoYW5nZT17aGFuZGxlRmlsZUNoYW5nZX0gY2xhc3NOYW1lPVwiYm9yZGVyIHAtMiB3LWZ1bGxcIiAvPlxyXG4vLyAgICAgICAgIDxidXR0b25cclxuLy8gICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVN1Ym1pdH1cclxuLy8gICAgICAgICAgIGNsYXNzTmFtZT1cImJnLWJsdWUtNTAwIHRleHQtd2hpdGUgcC0yIHJvdW5kZWQgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgbXQtNFwiXHJcbi8vICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgPEJzVXBsb2FkIGNsYXNzTmFtZT1cIm1yLTJcIiAvPiBTdWJtaXRcclxuLy8gICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgc3BhY2UteS0yIG10LTRcIj5cclxuLy8gICAgICAgICAgIHtbXCJsaW5lQ2hhcnREYXRhXCIsIFwiYmFyQ2hhcnREYXRhXCIsIFwic2NhdHRlckNoYXJ0RGF0YVwiLCBcInBpZUNoYXJ0RGF0YVwiLCBcImRvbnV0Q2hhcnREYXRhXCJdLm1hcChcclxuLy8gICAgICAgICAgICAgKHR5cGUpID0+IChcclxuLy8gICAgICAgICAgICAgICA8YnV0dG9uXHJcbi8vICAgICAgICAgICAgICAgICBrZXk9e3R5cGV9XHJcbi8vICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTZWxlY3RlZENoYXJ0KHR5cGUpfVxyXG4vLyAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicC0yIGJnLWdyYXktMzAwIHJvdW5kZWQgaG92ZXI6YmctZ3JheS00MDBcIlxyXG4vLyAgICAgICAgICAgICAgID5cclxuLy8gICAgICAgICAgICAgICAgIHt0eXBlLnJlcGxhY2UoXCJDaGFydERhdGFcIiwgXCIgQ2hhcnRcIil9XHJcbi8vICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgICAgICAgIClcclxuLy8gICAgICAgICAgICl9XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgIDwvZGl2PlxyXG5cclxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0zLzQgYmctZ3JheS0xMDAgcC01IG92ZXJmbG93LWF1dG9cIj5cclxuLy8gICAgICAgICB7bG9hZGluZyA/IChcclxuLy8gICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgaC1mdWxsXCI+XHJcbi8vICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3Bpbm5lci1ib3JkZXIgYW5pbWF0ZS1zcGluIGJvcmRlci10LTQgYm9yZGVyLWJsdWUtNTAwIHJvdW5kZWQtZnVsbCB3LTEyIGgtMTJcIj48L2Rpdj5cclxuLy8gICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICkgOiAoXHJcbi8vICAgICAgICAgICByZW5kZXJDaGFydChzZWxlY3RlZENoYXJ0LCB7XHJcbi8vICAgICAgICAgICAgIGxpbmVDaGFydERhdGE6IExpbmUsXHJcbi8vICAgICAgICAgICAgIGJhckNoYXJ0RGF0YTogQmFyLFxyXG4vLyAgICAgICAgICAgICBzY2F0dGVyQ2hhcnREYXRhOiBTY2F0dGVyLFxyXG4vLyAgICAgICAgICAgICBwaWVDaGFydERhdGE6IFBpZSxcclxuLy8gICAgICAgICAgICAgZG9udXRDaGFydERhdGE6IERvdWdobnV0LFxyXG4vLyAgICAgICAgICAgfVtzZWxlY3RlZENoYXJ0XSlcclxuLy8gICAgICAgICApfVxyXG5cclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTQgZmxleFwiPlxyXG4vLyAgICAgICAgICAgPGlucHV0XHJcbi8vICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcclxuLy8gICAgICAgICAgICAgdmFsdWU9e2lucHV0VmFsdWV9XHJcbi8vICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0SW5wdXRWYWx1ZShlLnRhcmdldC52YWx1ZSl9XHJcbi8vICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJvcmRlciBwLTIgZmxleC1ncm93IG1yLTIgcm91bmRlZFwiXHJcbi8vICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiRW50ZXIgeW91ciB0ZXh0IGhlcmVcIlxyXG4vLyAgICAgICAgICAgLz5cclxuLy8gICAgICAgICAgIDxidXR0b25cclxuLy8gICAgICAgICAgICAgb25DbGljaz17aGFuZGxlU2VuZH1cclxuLy8gICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctZ3JlZW4tNTAwIHRleHQtd2hpdGUgcC0yIHJvdW5kZWRcIlxyXG4vLyAgICAgICAgICAgPlxyXG4vLyAgICAgICAgICAgICBTZW5kXHJcbi8vICAgICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgPC9kaXY+XHJcbi8vICAgICA8L2Rpdj5cclxuLy8gICApO1xyXG4vLyB9XHJcblxyXG5cclxuXHJcbi8vIFwidXNlIGNsaWVudFwiO1xyXG4vLyBpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XHJcbi8vIGltcG9ydCB7IEJhciwgTGluZSwgRG91Z2hudXQsIFBpZSwgU2NhdHRlciB9IGZyb20gXCJyZWFjdC1jaGFydGpzLTJcIjtcclxuLy8gaW1wb3J0IHsgQ2hhcnQgYXMgQ2hhcnRKUywgQ2F0ZWdvcnlTY2FsZSwgTGluZWFyU2NhbGUsIEJhckVsZW1lbnQsIExpbmVFbGVtZW50LCBQb2ludEVsZW1lbnQsIEFyY0VsZW1lbnQsIFRpdGxlLCBUb29sdGlwLCBMZWdlbmQgfSBmcm9tIFwiY2hhcnQuanNcIjtcclxuLy8gaW1wb3J0IHsgQnNVcGxvYWQgfSBmcm9tIFwicmVhY3QtaWNvbnMvYnNcIjtcclxuLy8gaW1wb3J0IHpvb21QbHVnaW4gZnJvbSBcImNoYXJ0anMtcGx1Z2luLXpvb21cIjtcclxuXHJcbi8vIENoYXJ0SlMucmVnaXN0ZXIoQ2F0ZWdvcnlTY2FsZSwgTGluZWFyU2NhbGUsIEJhckVsZW1lbnQsIExpbmVFbGVtZW50LCBQb2ludEVsZW1lbnQsIEFyY0VsZW1lbnQsIFRpdGxlLCBUb29sdGlwLCBMZWdlbmQsIHpvb21QbHVnaW4pO1xyXG5cclxuLy8gaW50ZXJmYWNlIENoYXJ0RGF0YSB7XHJcbi8vICAgbGFiZWxzOiBzdHJpbmdbXTtcclxuLy8gICBkYXRhc2V0czoge1xyXG4vLyAgICAgbGFiZWw6IHN0cmluZztcclxuLy8gICAgIGRhdGE6IG51bWJlcltdO1xyXG4vLyAgICAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nIHwgc3RyaW5nW107XHJcbi8vICAgICBib3JkZXJDb2xvcj86IHN0cmluZztcclxuLy8gICAgIGZpbGw/OiBib29sZWFuO1xyXG4vLyAgIH1bXVxyXG4vLyAgIG1ldGE/OiB7XHJcbi8vICAgICBoZWFkZXI6IHN0cmluZztcclxuLy8gICAgIHZhbHVlTmFtZTogc3RyaW5nO1xyXG4vLyAgIH07XHJcbi8vIH1cclxuXHJcbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhc2hib2FyZCgpIHtcclxuLy8gICBjb25zdCBbY2hhcnREYXRhLCBzZXRDaGFydERhdGFdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgQ2hhcnREYXRhIHwgbnVsbD4+KHtcclxuLy8gICAgIHNjYXR0ZXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBwaWVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBkb251dENoYXJ0RGF0YTogbnVsbCxcclxuLy8gICAgIGxpbmVDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBiYXJDaGFydERhdGE6IG51bGwsXHJcbi8vICAgfSk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkRmlsZSwgc2V0U2VsZWN0ZWRGaWxlXSA9IHVzZVN0YXRlPEZpbGUgfCBudWxsPihudWxsKTtcclxuLy8gICBjb25zdCBbc2VsZWN0ZWRDaGFydCwgc2V0U2VsZWN0ZWRDaGFydF0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwibGluZUNoYXJ0RGF0YVwiKTtcclxuLy8gICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XHJcbi8vICAgY29uc3QgW2NoYXJ0V2lkdGgsIHNldENoYXJ0V2lkdGhdID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcclxuLy8gICBjb25zdCBbaW5wdXRWYWx1ZSwgc2V0SW5wdXRWYWx1ZV0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiXCIpO1xyXG4vLyAgIGNvbnN0IFtzdG9yZWRQcm9jZXNzZWREYXRhLCBzZXRTdG9yZWRQcm9jZXNzZWREYXRhXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7IC8vIE5ldyBzdGF0ZSB0byBzdG9yZSBwcm9jZXNzZWQgZGF0YVxyXG4vLyAgIGNvbnN0IFtjb21iaW5lZEluc2lnaHRzLCBzZXRDb21iaW5lZEluc2lnaHRzXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZUZpbGVDaGFuZ2UgPSAoZXZlbnQ6IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XHJcbi8vICAgICBzZXRTZWxlY3RlZEZpbGUoZXZlbnQudGFyZ2V0LmZpbGVzPy5bMF0gfHwgbnVsbCk7XHJcbi8vICAgfTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlU3VibWl0ID0gYXN5bmMgKCkgPT4ge1xyXG4vLyAgICAgaWYgKCFzZWxlY3RlZEZpbGUpIHJldHVybjtcclxuLy8gICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcblxyXG4vLyAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuLy8gICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgc2VsZWN0ZWRGaWxlKTtcclxuXHJcbi8vICAgICB0cnkge1xyXG4vLyAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cDovL2xvY2FsaG9zdDozMDEyL2FwaS9hbmFseXplLWV4Y2VsXCIsIHtcclxuLy8gICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4vLyAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxyXG4vLyAgICAgICB9KTtcclxuXHJcbi8vICAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlLlwiKTtcclxuLy8gICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4vLyAgICAgICBjb25zdCBjb21iaW5lZEluc2lnaHRzID0gcmVzdWx0LmRhdGE/LmNvbWJpbmVkSW5zaWdodHM7XHJcbi8vICAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSByZXN1bHQuZGF0YT8ucHJvY2Vzc2VkRGF0YTtcclxuXHJcbi8vICAgICAgIGlmICghcHJvY2Vzc2VkRGF0YSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBzdHJ1Y3R1cmUuXCIpO1xyXG4vLyBjb25zb2xlLmxvZyhcInByb2Nlc3NlZERhdGFcIixwcm9jZXNzZWREYXRhKTtcclxuXHJcbi8vICAgICAgIHNldFN0b3JlZFByb2Nlc3NlZERhdGEocHJvY2Vzc2VkRGF0YSk7IC8vIFN0b3JlIHRoZSBwcm9jZXNzZWQgZGF0YVxyXG4vLyAgICAgICBzZXRDb21iaW5lZEluc2lnaHRzKGNvbWJpbmVkSW5zaWdodHMpO1xyXG4vLyAgICAgICBjb25zdCBsaWdodENvbG9ycyA9IFtcclxuLy8gICAgICAgICBcInJnYmEoMTczLCAyMTYsIDIzMCwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgxNDQsIDIzOCwgMTQ0LCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDI1NSwgMTgyLCAxOTMsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjU1LCAyMjgsIDE4MSwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyMjEsIDE2MCwgMjIxLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDI0MCwgMjMwLCAxNDAsIDAuNilcIixcclxuLy8gICAgICAgXTtcclxuXHJcbi8vICAgICAgIGNvbnN0IGdlbmVyYXRlQ2hhcnREYXRhID0gKGNoYXJ0VHlwZTogc3RyaW5nKTogQ2hhcnREYXRhIHwgbnVsbCA9PiB7XHJcbi8vICAgICAgICAgY29uc3QgY2hhcnRJbmZvID0gcHJvY2Vzc2VkRGF0YVtjaGFydFR5cGVdPy5bMF07XHJcbi8vICAgICAgICAgaWYgKCFjaGFydEluZm8pIHJldHVybiBudWxsO1xyXG5cclxuLy8gICAgICAgICBjb25zdCBsYWJlbHMgPSBPYmplY3Qua2V5cyhjaGFydEluZm8uZGF0YSk7XHJcbi8vICAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhjaGFydEluZm8uZGF0YSk7XHJcblxyXG4vLyAgICAgICAgIHNldENoYXJ0V2lkdGgobGFiZWxzLmxlbmd0aCAqIDE1MCk7XHJcblxyXG4vLyAgICAgICAgIHJldHVybiB7XHJcbi8vICAgICAgICAgICBsYWJlbHMsXHJcbi8vICAgICAgICAgICBkYXRhc2V0czogW1xyXG4vLyAgICAgICAgICAgICB7XHJcbi8vICAgICAgICAgICAgICAgbGFiZWw6IGNoYXJ0SW5mby5sYWJlbCB8fCBjaGFydFR5cGUsXHJcbi8vICAgICAgICAgICAgICAgZGF0YTogdmFsdWVzIGFzIG51bWJlcltdLFxyXG4vLyAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogW1wiUGllIENoYXJ0XCIsIFwiRG9udXQgQ2hhcnRcIiwgXCJCYXIgQ2hhcnRcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKVxyXG4vLyAgICAgICAgICAgICAgICAgPyBsaWdodENvbG9ycy5zbGljZSgwLCBsYWJlbHMubGVuZ3RoKVxyXG4vLyAgICAgICAgICAgICAgICAgOiBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMC42KVwiLFxyXG4vLyAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpID8gXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDEpXCIgOiB1bmRlZmluZWQsXHJcbi8vICAgICAgICAgICAgICAgZmlsbDogIWNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIiksXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICBdLFxyXG4vLyAgICAgICAgICAgbWV0YToge1xyXG4vLyAgICAgICAgICAgICBoZWFkZXI6IGNoYXJ0SW5mby5oZWFkZXIgfHwgXCJkZWZhdWx0X2hlYWRlclwiLFxyXG4vLyAgICAgICAgICAgICB2YWx1ZU5hbWU6IGNoYXJ0SW5mby52YWx1ZU5hbWUgfHwgXCJkZWZhdWx0X3ZhbHVlTmFtZVwiLFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICB9O1xyXG4vLyAgICAgICB9O1xyXG5cclxuLy8gICAgICAgc2V0Q2hhcnREYXRhKHtcclxuLy8gICAgICAgICBzY2F0dGVyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlNjYXR0ZXIgUGxvdFwiKSxcclxuLy8gICAgICAgICBwaWVDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiUGllIENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGRvbnV0Q2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkRvbnV0IENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGxpbmVDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiTGluZSBDaGFydFwiKSxcclxuLy8gICAgICAgICBiYXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiQmFyIENoYXJ0XCIpLFxyXG4vLyAgICAgICB9KTtcclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZTpcIiwgZXJyb3IpO1xyXG4vLyAgICAgfSBmaW5hbGx5IHtcclxuLy8gICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbi8vICAgICB9XHJcbi8vICAgfTtcclxuXHJcbiBcclxuLy8gICBjb25zdCBoYW5kbGVTZW5kID0gYXN5bmMgKCkgPT4ge1xyXG4vLyAgICAgaWYgKCFpbnB1dFZhbHVlKSByZXR1cm47XHJcbiAgXHJcbi8vICAgICBjb25zdCBncmFwaERhdGEgPSBjaGFydERhdGFbc2VsZWN0ZWRDaGFydF07XHJcbi8vICAgICBpZiAoIWdyYXBoRGF0YSkgcmV0dXJuO1xyXG4gIFxyXG4vLyAgICAgY29uc3QgbGFiZWxzID0gZ3JhcGhEYXRhLmxhYmVscztcclxuLy8gICAgIGNvbnN0IHZhbHVlcyA9IGdyYXBoRGF0YS5kYXRhc2V0c1swXS5kYXRhO1xyXG4gIFxyXG4vLyAgICAgY29uc3QgZGF0YU9iamVjdCA9IGxhYmVscy5yZWR1Y2UoKG9iajogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSwgbGFiZWwsIGluZGV4KSA9PiB7XHJcbi8vICAgICAgIG9ialtsYWJlbF0gPSB2YWx1ZXNbaW5kZXhdO1xyXG4vLyAgICAgICByZXR1cm4gb2JqO1xyXG4vLyAgICAgfSwge30pO1xyXG4gIFxyXG4vLyAgICAgY29uc3QgY2hhcnRUeXBlTWFwcGluZzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcclxuLy8gICAgICAgbGluZUNoYXJ0RGF0YTogXCJMaW5lIENoYXJ0XCIsXHJcbi8vICAgICAgIHBpZUNoYXJ0RGF0YTogXCJQaWUgQ2hhcnRcIixcclxuLy8gICAgICAgZG9udXRDaGFydERhdGE6IFwiRG9udXQgQ2hhcnRcIixcclxuLy8gICAgICAgYmFyQ2hhcnREYXRhOiBcIkJhciBDaGFydFwiLFxyXG4vLyAgICAgICBzY2F0dGVyQ2hhcnREYXRhOiBcIlNjYXR0ZXIgUGxvdFwiLFxyXG4vLyAgICAgfTtcclxuICBcclxuLy8gICAgIGNvbnN0IHNlbGVjdGVkQ2hhcnRUeXBlID0gY2hhcnRUeXBlTWFwcGluZ1tzZWxlY3RlZENoYXJ0XSB8fCBzZWxlY3RlZENoYXJ0O1xyXG4gIFxyXG4vLyAgICAgLy8gRmlsdGVyIHRoZSBzdG9yZWQgcHJvY2Vzc2VkIGRhdGEgdG8gaW5jbHVkZSBvbmx5IHRoZSBzZWxlY3RlZCBjaGFydCdzIGRhdGFcclxuLy8gICAgIGNvbnN0IGZpbHRlcmVkUHJvY2Vzc2VkRGF0YSA9IHtcclxuLy8gICAgICAgW3NlbGVjdGVkQ2hhcnRUeXBlXTogc3RvcmVkUHJvY2Vzc2VkRGF0YVtzZWxlY3RlZENoYXJ0VHlwZV0sXHJcbi8vICAgICB9O1xyXG4gIFxyXG4vLyAgICAgY29uc29sZS5sb2coXCIuLi5maWx0ZXJlZFByb2Nlc3NlZERhdGEsXCIsIGZpbHRlcmVkUHJvY2Vzc2VkRGF0YVtzZWxlY3RlZENoYXJ0VHlwZV0/LlswXT8uZGF0YSk7XHJcbi8vICAgICBjb25zb2xlLmxvZyhcImRhdGFPYmplY3QsXCIsIGRhdGFPYmplY3QpO1xyXG4gIFxyXG4vLyAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XHJcbi8vICAgICAgIHF1ZXN0aW9uOiBpbnB1dFZhbHVlLFxyXG4vLyAgICAgICBwcm9jZXNzZWREYXRhOiB7XHJcbi8vICAgICAgICAgLy8gSW5jbHVkZSB0aGUgc3RvcmVkIHByb2Nlc3NlZCBkYXRhXHJcbi8vICAgICAgICAgW3NlbGVjdGVkQ2hhcnRUeXBlXTogW1xyXG4vLyAgICAgICAgICAge1xyXG4vLyAgICAgICAgICAgICBoZWFkZXI6IGdyYXBoRGF0YS5tZXRhPy5oZWFkZXIgfHwgXCJkZWZhdWx0X2hlYWRlclwiLFxyXG4vLyAgICAgICAgICAgICB2YWx1ZU5hbWU6IGdyYXBoRGF0YS5tZXRhPy52YWx1ZU5hbWUgfHwgXCJkZWZhdWx0X3ZhbHVlTmFtZVwiLFxyXG4vLyAgICAgICAgICAgICBsYWJlbDogZ3JhcGhEYXRhLmRhdGFzZXRzWzBdLmxhYmVsLFxyXG4vLyAgICAgICAgICAgICBkYXRhOiBmaWx0ZXJlZFByb2Nlc3NlZERhdGFbc2VsZWN0ZWRDaGFydFR5cGVdPy5bMF0/LmRhdGEsXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIF0sXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICB9O1xyXG4gIFxyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuLy8gICAgICAgICBgaHR0cDovL2xvY2FsaG9zdDozMDEyL2FwaS9hbnN3ZXItYW5hbHl6ZS1leGNlbD9xdWVzdGlvbj0ke2VuY29kZVVSSUNvbXBvbmVudChpbnB1dFZhbHVlKX1gLFxyXG4vLyAgICAgICAgIHtcclxuLy8gICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbi8vICAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXHJcbi8vICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgICApO1xyXG4gIFxyXG4vLyAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZS5cIik7XHJcbi8vICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuLy8gICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHJlc3VsdC5kYXRhPy5wcm9jZXNzZWREYXRhO1xyXG4gIFxyXG4vLyAgICAgICBpZiAoIXByb2Nlc3NlZERhdGEpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzcG9uc2Ugc3RydWN0dXJlLlwiKTtcclxuICBcclxuLy8gICAgICAgY29uc29sZS5sb2coXCJVcGRhdGVkIEFQSSBSZXNwb25zZSBEYXRhOlwiLCBwcm9jZXNzZWREYXRhKTtcclxuICBcclxuLy8gICAgICAgY29uc3QgZ2VuZXJhdGVDaGFydERhdGEgPSAoY2hhcnRUeXBlOiBzdHJpbmcpOiBDaGFydERhdGEgfCBudWxsID0+IHtcclxuLy8gICAgICAgICBjb25zdCBjaGFydEluZm8gPSBwcm9jZXNzZWREYXRhW2NoYXJ0VHlwZV0/LlswXTsgLy8gVXNlIG9ubHkgQVBJIHJlc3BvbnNlIGRhdGFcclxuLy8gICAgICAgICBpZiAoIWNoYXJ0SW5mbykgcmV0dXJuIG51bGw7XHJcbiAgXHJcbi8vICAgICAgICAgY29uc3QgbGFiZWxzID0gT2JqZWN0LmtleXMoY2hhcnRJbmZvLmRhdGEpO1xyXG4vLyAgICAgICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoY2hhcnRJbmZvLmRhdGEpO1xyXG4gIFxyXG4vLyAgICAgICAgIHNldENoYXJ0V2lkdGgobGFiZWxzLmxlbmd0aCAqIDE1MCk7XHJcbiAgXHJcbi8vICAgICAgICAgcmV0dXJuIHtcclxuLy8gICAgICAgICAgIGxhYmVscyxcclxuLy8gICAgICAgICAgIGRhdGFzZXRzOiBbXHJcbi8vICAgICAgICAgICAgIHtcclxuLy8gICAgICAgICAgICAgICBsYWJlbDogY2hhcnRJbmZvLmxhYmVsIHx8IGNoYXJ0VHlwZSxcclxuLy8gICAgICAgICAgICAgICBkYXRhOiB2YWx1ZXMgYXMgbnVtYmVyW10sXHJcbi8vICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbXCJQaWUgQ2hhcnRcIiwgXCJEb251dCBDaGFydFwiLCBcIkJhciBDaGFydFwiXS5pbmNsdWRlcyhjaGFydFR5cGUpXHJcbi8vICAgICAgICAgICAgICAgICA/IFtcInJnYmEoMTczLCAyMTYsIDIzMCwgMC42KVwiLCBcInJnYmEoMTQ0LCAyMzgsIDE0NCwgMC42KVwiLCBcInJnYmEoMjU1LCAxODIsIDE5MywgMC42KVwiXVxyXG4vLyAgICAgICAgICAgICAgICAgOiBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMC42KVwiLFxyXG4vLyAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpID8gXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDEpXCIgOiB1bmRlZmluZWQsXHJcbi8vICAgICAgICAgICAgICAgZmlsbDogIWNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIiksXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICBdLFxyXG4vLyAgICAgICAgICAgbWV0YToge1xyXG4vLyAgICAgICAgICAgICBoZWFkZXI6IGNoYXJ0SW5mby5oZWFkZXIgfHwgXCJkZWZhdWx0X2hlYWRlclwiLFxyXG4vLyAgICAgICAgICAgICB2YWx1ZU5hbWU6IGNoYXJ0SW5mby52YWx1ZU5hbWUgfHwgXCJkZWZhdWx0X3ZhbHVlTmFtZVwiLFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICB9O1xyXG4vLyAgICAgICB9O1xyXG4gIFxyXG4vLyAgICAgICAvLyBPbmx5IHVwZGF0ZSBjaGFydERhdGEgd2l0aG91dCBzdG9yaW5nIGluIHN0b3JlZFByb2Nlc3NlZERhdGFcclxuLy8gICAgICAgc2V0Q2hhcnREYXRhKChwcmV2Q2hhcnREYXRhKSA9PiAoe1xyXG4vLyAgICAgICAgIC4uLnByZXZDaGFydERhdGEsXHJcbi8vICAgICAgICAgW3NlbGVjdGVkQ2hhcnRdOiBnZW5lcmF0ZUNoYXJ0RGF0YShzZWxlY3RlZENoYXJ0VHlwZSksXHJcbi8vICAgICAgIH0pKTtcclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzZW5kaW5nIHJlcXVlc3Q6XCIsIGVycm9yKTtcclxuLy8gICAgIH0gZmluYWxseSB7XHJcbi8vICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH07XHJcbiAgXHJcblxyXG4vLyAgIGNvbnN0IGdldENoYXJ0T3B0aW9ucyA9ICh0eXBlOiBzdHJpbmcpID0+ICh7XHJcbi8vICAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4vLyAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXHJcbi8vICAgICBzY2FsZXM6IFtcInBpZUNoYXJ0RGF0YVwiLCBcImRvbnV0Q2hhcnREYXRhXCJdLmluY2x1ZGVzKHR5cGUpXHJcbi8vICAgICAgID8ge31cclxuLy8gICAgICAgOiB7XHJcbi8vICAgICAgICAgeDoge1xyXG4vLyAgICAgICAgICAgdGlja3M6IHtcclxuLy8gICAgICAgICAgICAgYXV0b1NraXA6IGZhbHNlLFxyXG4vLyAgICAgICAgICAgICBtYXhSb3RhdGlvbjogdHlwZSA9PT0gJ2JhckNoYXJ0RGF0YScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXJDaGFydERhdGEnID8gMjAgOiAxMDAsXHJcbi8vICAgICAgICAgbWluUm90YXRpb246IHR5cGUgPT09ICdiYXJDaGFydERhdGEnIHx8IHR5cGUgPT09ICdzY2F0dGVyQ2hhcnREYXRhJyA/IDAgOiA5MCxcclxuLy8gICAgICAgICAgICAgYXV0b1NraXBQYWRkaW5nOiAyMCxcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICBncmlkOiB7XHJcbi8vICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbi8vICAgICAgICAgICAgIGRyYXdUaWNrczogZmFsc2UsXHJcbi8vICAgICAgICAgICAgIHRpY2tMZW5ndGg6IDEwMCxcclxuLy8gICAgICAgICAgICAgbGluZVdpZHRoOiAxXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICAgICAgeToge1xyXG4vLyAgICAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXHJcbi8vICAgICAgICAgICB0aWNrczogeyBwcmVjaXNpb246IDAgfSxcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgICB9LFxyXG4vLyAgICAgcGx1Z2luczoge1xyXG4vLyAgICAgICBsZWdlbmQ6IHsgZGlzcGxheTogdHJ1ZSwgcG9zaXRpb246IFwidG9wXCIgfSxcclxuLy8gICAgICAgdG9vbHRpcDogeyBlbmFibGVkOiB0cnVlIH0sXHJcbi8vICAgICB9LFxyXG4vLyAgIH0pO1xyXG5cclxuLy8gICBjb25zdCByZW5kZXJDaGFydCA9ICh0eXBlOiBzdHJpbmcsIENoYXJ0Q29tcG9uZW50OiBhbnkpID0+IHtcclxuLy8gICAgIGNvbnN0IGRhdGEgPSBjaGFydERhdGFbdHlwZV07XHJcbi8vICAgICBpZiAoIWxvYWRpbmcgJiYgZGF0YSkge1xyXG4vLyAgICAgICByZXR1cm4gKFxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZCBwLTQgYm9yZGVyIHJvdW5kZWQgc2hhZG93LXNtXCI+XHJcbi8vICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiBcIjEwMCVcIiwgb3ZlcmZsb3dYOiBcImF1dG9cIiB9fT5cclxuLy8gICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBtaW5XaWR0aDogW1wibGluZUNoYXJ0RGF0YVwiLCBcImJhckNoYXJ0RGF0YVwiXS5pbmNsdWRlcyh0eXBlKSA/IGAke2NoYXJ0V2lkdGh9cHhgIDogXCJhdXRvXCIsIGhlaWdodDogXCI0MDBweFwiIH19PlxyXG4vLyAgICAgICAgICAgICAgIDxDaGFydENvbXBvbmVudCBkYXRhPXtkYXRhfSBvcHRpb25zPXtnZXRDaGFydE9wdGlvbnModHlwZSl9IC8+XHJcbi8vICAgICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICk7XHJcbi8vICAgICB9XHJcbi8vICAgICByZXR1cm4gbnVsbDtcclxuLy8gICB9O1xyXG4vLyAgIHJldHVybiAoXHJcbi8vICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgbWQ6ZmxleC1yb3cgaC1zY3JlZW4gYm9yZGVyIGJvcmRlci1ibGFja1wiPlxyXG4vLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTEvNCBiZy13aGl0ZSBwLTUgYm9yZGVyLXQgbWQ6Ym9yZGVyLWwgbWQ6Ym9yZGVyLWJsYWNrXCI+XHJcbi8vICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5VcGxvYWQgRmlsZTwvaDI+XHJcbi8vICAgICAgICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgb25DaGFuZ2U9e2hhbmRsZUZpbGVDaGFuZ2V9IGNsYXNzTmFtZT1cImJvcmRlciBwLTIgdy1mdWxsXCIgLz5cclxuLy8gICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2hhbmRsZVN1Ym1pdH0gY2xhc3NOYW1lPVwiYmctYmx1ZS01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBtdC00XCI+XHJcbi8vICAgICAgICAgICA8QnNVcGxvYWQgY2xhc3NOYW1lPVwibXItMlwiIC8+IFN1Ym1pdFxyXG4vLyAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBzcGFjZS15LTIgbXQtNFwiPlxyXG4vLyAgICAgICAgICAge1tcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIiwgXCJzY2F0dGVyQ2hhcnREYXRhXCIsIFwicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0ubWFwKCh0eXBlKSA9PiAoXHJcbi8vICAgICAgICAgICAgIDxidXR0b24ga2V5PXt0eXBlfSBvbkNsaWNrPXsoKSA9PiBzZXRTZWxlY3RlZENoYXJ0KHR5cGUpfSBjbGFzc05hbWU9XCJwLTIgYmctZ3JheS0zMDAgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTQwMFwiPlxyXG4vLyAgICAgICAgICAgICAgIHt0eXBlLnJlcGxhY2UoXCJDaGFydERhdGFcIiwgXCIgQ2hhcnRcIil9XHJcbi8vICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgICAgKSl9XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTMvNCBiZy1ncmF5LTEwMCBwLTUgb3ZlcmZsb3ctYXV0b1wiPlxyXG4vLyAgICAgICAgIHtsb2FkaW5nID8gKFxyXG4vLyAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBoLWZ1bGxcIj5cclxuLy8gICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGlubmVyLWJvcmRlciBhbmltYXRlLXNwaW4gYm9yZGVyLXQtNCBib3JkZXItYmx1ZS01MDAgcm91bmRlZC1mdWxsIHctMTIgaC0xMlwiPjwvZGl2PlxyXG4vLyAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgKSA6IChcclxuLy8gICAgICAgICAgIHNlbGVjdGVkQ2hhcnQgJiYgcmVuZGVyQ2hhcnQoc2VsZWN0ZWRDaGFydCwgeyBsaW5lQ2hhcnREYXRhOiBMaW5lLCBiYXJDaGFydERhdGE6IEJhciwgc2NhdHRlckNoYXJ0RGF0YTogU2NhdHRlciwgcGllQ2hhcnREYXRhOiBQaWUsIGRvbnV0Q2hhcnREYXRhOiBEb3VnaG51dCB9W3NlbGVjdGVkQ2hhcnRdKVxyXG4vLyAgICAgICAgICl9XHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC00IGZsZXhcIj5cclxuLy8gICAgICAgICAgIDxpbnB1dFxyXG4vLyAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXHJcbi8vICAgICAgICAgICAgIHZhbHVlPXtpbnB1dFZhbHVlfVxyXG4vLyAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldElucHV0VmFsdWUoZS50YXJnZXQudmFsdWUpfVxyXG4vLyAgICAgICAgICAgICBjbGFzc05hbWU9XCJib3JkZXIgcC0yIGZsZXgtZ3JvdyBtci0yIHJvdW5kZWRcIlxyXG4vLyAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkVudGVyIHlvdXIgdGV4dCBoZXJlXCJcclxuLy8gICAgICAgICAgIC8+XHJcbi8vICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2hhbmRsZVNlbmR9IGNsYXNzTmFtZT1cImJnLWdyZWVuLTUwMCB0ZXh0LXdoaXRlIHAtMiByb3VuZGVkXCI+XHJcbi8vICAgICAgICAgICAgIFNlbmRcclxuLy8gICAgICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtNCBwLTQgYm9yZGVyIGJvcmRlci1ncmF5LTMwMCByb3VuZGVkIGJnLXdoaXRlXCI+XHJcbi8vICAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5JbnNpZ2h0czwvaDM+XHJcbi8vICAgICAgICAge2NvbWJpbmVkSW5zaWdodHMgPyAoXHJcbi8vICAgICAgICAgICAgIDxvbCBjbGFzc05hbWU9XCJsaXN0LWRlY2ltYWwgbGlzdC1pbnNpZGUgdGV4dC1zbSB0ZXh0LWdyYXktNzAwIGJnLWdyYXktMTAwIHAtMiByb3VuZGVkIG92ZXJmbG93LWF1dG9cIj5cclxuLy8gICAgICAgICAgICAge2NvbWJpbmVkSW5zaWdodHMuc3BsaXQoJ1xcbicpLm1hcCgoaW5zaWdodCwgaW5kZXgpID0+IChcclxuLy8gICAgICAgICAgICAgICA8dWwga2V5PXtpbmRleH0+e2luc2lnaHR9PC91bD5cclxuLy8gICAgICAgICAgICAgKSl9XHJcbi8vICAgICAgICAgICA8L29sPlxyXG4vLyAgICAgICAgICkgOiAoXHJcbi8vICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNTAwXCI+Tm8gaW5zaWdodHMgYXZhaWxhYmxlLjwvcD5cclxuLy8gICAgICAgICApfVxyXG4vLyAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgPC9kaXY+XHJcbi8vICAgICA8L2Rpdj5cclxuLy8gICApO1xyXG4vLyB9XHJcblxyXG4vLyBcInVzZSBjbGllbnRcIjtcclxuLy8gaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XHJcbi8vIGltcG9ydCB7IEJhciwgTGluZSwgRG91Z2hudXQsIFBpZSwgU2NhdHRlciB9IGZyb20gXCJyZWFjdC1jaGFydGpzLTJcIjtcclxuLy8gaW1wb3J0IHsgQ2hhcnQgYXMgQ2hhcnRKUywgQ2F0ZWdvcnlTY2FsZSwgTGluZWFyU2NhbGUsIEJhckVsZW1lbnQsIExpbmVFbGVtZW50LCBQb2ludEVsZW1lbnQsIEFyY0VsZW1lbnQsIFRpdGxlLCBUb29sdGlwLCBMZWdlbmQgfSBmcm9tIFwiY2hhcnQuanNcIjtcclxuLy8gaW1wb3J0IHsgQnNVcGxvYWQgfSBmcm9tIFwicmVhY3QtaWNvbnMvYnNcIjtcclxuLy8gaW1wb3J0IHpvb21QbHVnaW4gZnJvbSBcImNoYXJ0anMtcGx1Z2luLXpvb21cIjtcclxuLy8gaW1wb3J0IGh0bWwyY2FudmFzIGZyb20gXCJodG1sMmNhbnZhc1wiO1xyXG4vLyBpbXBvcnQganNQREYgZnJvbSBcImpzcGRmXCI7XHJcblxyXG4vLyBDaGFydEpTLnJlZ2lzdGVyKENhdGVnb3J5U2NhbGUsIExpbmVhclNjYWxlLCBCYXJFbGVtZW50LCBMaW5lRWxlbWVudCwgUG9pbnRFbGVtZW50LCBBcmNFbGVtZW50LCBUaXRsZSwgVG9vbHRpcCwgTGVnZW5kLCB6b29tUGx1Z2luKTtcclxuXHJcbi8vIGludGVyZmFjZSBDaGFydERhdGEge1xyXG4vLyAgIGxhYmVsczogc3RyaW5nW107XHJcbi8vICAgZGF0YXNldHM6IHtcclxuLy8gICAgIGxhYmVsOiBzdHJpbmc7XHJcbi8vICAgICBkYXRhOiBudW1iZXJbXTtcclxuLy8gICAgIGJhY2tncm91bmRDb2xvcj86IHN0cmluZyB8IHN0cmluZ1tdO1xyXG4vLyAgICAgYm9yZGVyQ29sb3I/OiBzdHJpbmc7XHJcbi8vICAgICBmaWxsPzogYm9vbGVhbjtcclxuLy8gICB9W11cclxuLy8gICBtZXRhPzoge1xyXG4vLyAgICAgaGVhZGVyOiBzdHJpbmc7XHJcbi8vICAgICB2YWx1ZU5hbWU6IHN0cmluZztcclxuLy8gICB9O1xyXG4vLyB9XHJcblxyXG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEYXNoYm9hcmQoKSB7XHJcbi8vICAgY29uc3QgW2NoYXJ0RGF0YSwgc2V0Q2hhcnREYXRhXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIENoYXJ0RGF0YSB8IG51bGw+Pih7XHJcbi8vICAgICBzY2F0dGVyQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgcGllQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgZG9udXRDaGFydERhdGE6IG51bGwsXHJcbi8vICAgICBsaW5lQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgICAgYmFyQ2hhcnREYXRhOiBudWxsLFxyXG4vLyAgIH0pO1xyXG4vLyAgIGNvbnN0IFtzZWxlY3RlZEZpbGUsIHNldFNlbGVjdGVkRmlsZV0gPSB1c2VTdGF0ZTxGaWxlIHwgbnVsbD4obnVsbCk7XHJcbi8vICAgY29uc3QgW3NlbGVjdGVkQ2hhcnQsIHNldFNlbGVjdGVkQ2hhcnRdID0gdXNlU3RhdGU8c3RyaW5nPihcImxpbmVDaGFydERhdGFcIik7XHJcbi8vICAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG4vLyAgIGNvbnN0IFtjaGFydFdpZHRoLCBzZXRDaGFydFdpZHRoXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XHJcbi8vICAgY29uc3QgW2lucHV0VmFsdWUsIHNldElucHV0VmFsdWVdID0gdXNlU3RhdGU8c3RyaW5nPihcIlwiKTtcclxuLy8gICBjb25zdCBbc3RvcmVkUHJvY2Vzc2VkRGF0YSwgc2V0U3RvcmVkUHJvY2Vzc2VkRGF0YV0gPSB1c2VTdGF0ZTxhbnk+KG51bGwpOyAvLyBOZXcgc3RhdGUgdG8gc3RvcmUgcHJvY2Vzc2VkIGRhdGFcclxuLy8gICBjb25zdCBbY29tYmluZWRJbnNpZ2h0cywgc2V0Q29tYmluZWRJbnNpZ2h0c10gPSB1c2VTdGF0ZTxhbnk+KG51bGwpO1xyXG4vLyAgIGNvbnN0IGNoYXJ0UmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTsgLy8gUmVmIGZvciB0aGUgY2hhcnQgY29udGFpbmVyXHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZUZpbGVDaGFuZ2UgPSAoZXZlbnQ6IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XHJcbi8vICAgICBzZXRTZWxlY3RlZEZpbGUoZXZlbnQudGFyZ2V0LmZpbGVzPy5bMF0gfHwgbnVsbCk7XHJcbi8vICAgfTtcclxuXHJcbi8vICAgY29uc3QgaGFuZGxlU3VibWl0ID0gYXN5bmMgKCkgPT4ge1xyXG4vLyAgICAgaWYgKCFzZWxlY3RlZEZpbGUpIHJldHVybjtcclxuLy8gICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcblxyXG4vLyAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuLy8gICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgc2VsZWN0ZWRGaWxlKTtcclxuXHJcbi8vICAgICB0cnkge1xyXG4vLyAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cDovL2xvY2FsaG9zdDozMDEyL2FwaS9hbmFseXplLWV4Y2VsXCIsIHtcclxuLy8gICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4vLyAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxyXG4vLyAgICAgICB9KTtcclxuXHJcbi8vICAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlLlwiKTtcclxuLy8gICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4vLyAgICAgICBjb25zdCBjb21iaW5lZEluc2lnaHRzID0gcmVzdWx0LmRhdGE/LmNvbWJpbmVkSW5zaWdodHM7XHJcbi8vICAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSByZXN1bHQuZGF0YT8ucHJvY2Vzc2VkRGF0YTtcclxuXHJcbi8vICAgICAgIGlmICghcHJvY2Vzc2VkRGF0YSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBzdHJ1Y3R1cmUuXCIpO1xyXG4vLyBjb25zb2xlLmxvZyhcInByb2Nlc3NlZERhdGFcIixwcm9jZXNzZWREYXRhKTtcclxuXHJcbi8vICAgICAgIHNldFN0b3JlZFByb2Nlc3NlZERhdGEocHJvY2Vzc2VkRGF0YSk7IC8vIFN0b3JlIHRoZSBwcm9jZXNzZWQgZGF0YVxyXG4vLyAgICAgICBzZXRDb21iaW5lZEluc2lnaHRzKGNvbWJpbmVkSW5zaWdodHMpO1xyXG4vLyAgICAgICBjb25zdCBsaWdodENvbG9ycyA9IFtcclxuLy8gICAgICAgICBcInJnYmEoMTczLCAyMTYsIDIzMCwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgxNDQsIDIzOCwgMTQ0LCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDI1NSwgMTgyLCAxOTMsIDAuNilcIixcclxuLy8gICAgICAgICBcInJnYmEoMjU1LCAyMjgsIDE4MSwgMC42KVwiLFxyXG4vLyAgICAgICAgIFwicmdiYSgyMjEsIDE2MCwgMjIxLCAwLjYpXCIsXHJcbi8vICAgICAgICAgXCJyZ2JhKDI0MCwgMjMwLCAxNDAsIDAuNilcIixcclxuLy8gICAgICAgXTtcclxuXHJcbi8vICAgICAgIGNvbnN0IGdlbmVyYXRlQ2hhcnREYXRhID0gKGNoYXJ0VHlwZTogc3RyaW5nKTogQ2hhcnREYXRhIHwgbnVsbCA9PiB7XHJcbi8vICAgICAgICAgY29uc3QgY2hhcnRJbmZvID0gcHJvY2Vzc2VkRGF0YVtjaGFydFR5cGVdPy5bMF07XHJcbi8vICAgICAgICAgaWYgKCFjaGFydEluZm8pIHJldHVybiBudWxsO1xyXG5cclxuLy8gICAgICAgICBjb25zdCBsYWJlbHMgPSBPYmplY3Qua2V5cyhjaGFydEluZm8uZGF0YSk7XHJcbi8vICAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhjaGFydEluZm8uZGF0YSk7XHJcblxyXG4vLyAgICAgICAgIHNldENoYXJ0V2lkdGgobGFiZWxzLmxlbmd0aCAqIDE1MCk7XHJcblxyXG4vLyAgICAgICAgIHJldHVybiB7XHJcbi8vICAgICAgICAgICBsYWJlbHMsXHJcbi8vICAgICAgICAgICBkYXRhc2V0czogW1xyXG4vLyAgICAgICAgICAgICB7XHJcbi8vICAgICAgICAgICAgICAgbGFiZWw6IGNoYXJ0SW5mby5sYWJlbCB8fCBjaGFydFR5cGUsXHJcbi8vICAgICAgICAgICAgICAgZGF0YTogdmFsdWVzIGFzIG51bWJlcltdLFxyXG4vLyAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogW1wiUGllIENoYXJ0XCIsIFwiRG9udXQgQ2hhcnRcIiwgXCJCYXIgQ2hhcnRcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKVxyXG4vLyAgICAgICAgICAgICAgICAgPyBsaWdodENvbG9ycy5zbGljZSgwLCBsYWJlbHMubGVuZ3RoKVxyXG4vLyAgICAgICAgICAgICAgICAgOiBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMC42KVwiLFxyXG4vLyAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpID8gXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDEpXCIgOiB1bmRlZmluZWQsXHJcbi8vICAgICAgICAgICAgICAgZmlsbDogIWNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIiksXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICBdLFxyXG4vLyAgICAgICAgICAgbWV0YToge1xyXG4vLyAgICAgICAgICAgICBoZWFkZXI6IGNoYXJ0SW5mby5oZWFkZXIgfHwgXCJkZWZhdWx0X2hlYWRlclwiLFxyXG4vLyAgICAgICAgICAgICB2YWx1ZU5hbWU6IGNoYXJ0SW5mby52YWx1ZU5hbWUgfHwgXCJkZWZhdWx0X3ZhbHVlTmFtZVwiLFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICB9O1xyXG4vLyAgICAgICB9O1xyXG5cclxuLy8gICAgICAgc2V0Q2hhcnREYXRhKHtcclxuLy8gICAgICAgICBzY2F0dGVyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlNjYXR0ZXIgUGxvdFwiKSxcclxuLy8gICAgICAgICBwaWVDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiUGllIENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGRvbnV0Q2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkRvbnV0IENoYXJ0XCIpLFxyXG4vLyAgICAgICAgIGxpbmVDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiTGluZSBDaGFydFwiKSxcclxuLy8gICAgICAgICBiYXJDaGFydERhdGE6IGdlbmVyYXRlQ2hhcnREYXRhKFwiQmFyIENoYXJ0XCIpLFxyXG4vLyAgICAgICB9KTtcclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZTpcIiwgZXJyb3IpO1xyXG4vLyAgICAgfSBmaW5hbGx5IHtcclxuLy8gICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbi8vICAgICB9XHJcbi8vICAgfTtcclxuXHJcbiBcclxuLy8gICBjb25zdCBoYW5kbGVTZW5kID0gYXN5bmMgKCkgPT4ge1xyXG4vLyAgICAgaWYgKCFpbnB1dFZhbHVlKSByZXR1cm47XHJcbiAgXHJcbi8vICAgICBjb25zdCBncmFwaERhdGEgPSBjaGFydERhdGFbc2VsZWN0ZWRDaGFydF07XHJcbi8vICAgICBpZiAoIWdyYXBoRGF0YSkgcmV0dXJuO1xyXG4gIFxyXG4vLyAgICAgY29uc3QgbGFiZWxzID0gZ3JhcGhEYXRhLmxhYmVscztcclxuLy8gICAgIGNvbnN0IHZhbHVlcyA9IGdyYXBoRGF0YS5kYXRhc2V0c1swXS5kYXRhO1xyXG4gIFxyXG4vLyAgICAgY29uc3QgZGF0YU9iamVjdCA9IGxhYmVscy5yZWR1Y2UoKG9iajogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSwgbGFiZWwsIGluZGV4KSA9PiB7XHJcbi8vICAgICAgIG9ialtsYWJlbF0gPSB2YWx1ZXNbaW5kZXhdO1xyXG4vLyAgICAgICByZXR1cm4gb2JqO1xyXG4vLyAgICAgfSwge30pO1xyXG4gIFxyXG4vLyAgICAgY29uc3QgY2hhcnRUeXBlTWFwcGluZzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcclxuLy8gICAgICAgbGluZUNoYXJ0RGF0YTogXCJMaW5lIENoYXJ0XCIsXHJcbi8vICAgICAgIHBpZUNoYXJ0RGF0YTogXCJQaWUgQ2hhcnRcIixcclxuLy8gICAgICAgZG9udXRDaGFydERhdGE6IFwiRG9udXQgQ2hhcnRcIixcclxuLy8gICAgICAgYmFyQ2hhcnREYXRhOiBcIkJhciBDaGFydFwiLFxyXG4vLyAgICAgICBzY2F0dGVyQ2hhcnREYXRhOiBcIlNjYXR0ZXIgUGxvdFwiLFxyXG4vLyAgICAgfTtcclxuICBcclxuLy8gICAgIGNvbnN0IHNlbGVjdGVkQ2hhcnRUeXBlID0gY2hhcnRUeXBlTWFwcGluZ1tzZWxlY3RlZENoYXJ0XSB8fCBzZWxlY3RlZENoYXJ0O1xyXG4gIFxyXG4vLyAgICAgLy8gRmlsdGVyIHRoZSBzdG9yZWQgcHJvY2Vzc2VkIGRhdGEgdG8gaW5jbHVkZSBvbmx5IHRoZSBzZWxlY3RlZCBjaGFydCdzIGRhdGFcclxuLy8gICAgIGNvbnN0IGZpbHRlcmVkUHJvY2Vzc2VkRGF0YSA9IHtcclxuLy8gICAgICAgW3NlbGVjdGVkQ2hhcnRUeXBlXTogc3RvcmVkUHJvY2Vzc2VkRGF0YVtzZWxlY3RlZENoYXJ0VHlwZV0sXHJcbi8vICAgICB9O1xyXG4gIFxyXG4vLyAgICAgY29uc29sZS5sb2coXCIuLi5maWx0ZXJlZFByb2Nlc3NlZERhdGEsXCIsIGZpbHRlcmVkUHJvY2Vzc2VkRGF0YVtzZWxlY3RlZENoYXJ0VHlwZV0/LlswXT8uZGF0YSk7XHJcbi8vICAgICBjb25zb2xlLmxvZyhcImRhdGFPYmplY3QsXCIsIGRhdGFPYmplY3QpO1xyXG4gIFxyXG4vLyAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XHJcbi8vICAgICAgIHF1ZXN0aW9uOiBpbnB1dFZhbHVlLFxyXG4vLyAgICAgICBwcm9jZXNzZWREYXRhOiB7XHJcbi8vICAgICAgICAgLy8gSW5jbHVkZSB0aGUgc3RvcmVkIHByb2Nlc3NlZCBkYXRhXHJcbi8vICAgICAgICAgW3NlbGVjdGVkQ2hhcnRUeXBlXTogW1xyXG4vLyAgICAgICAgICAge1xyXG4vLyAgICAgICAgICAgICBoZWFkZXI6IGdyYXBoRGF0YS5tZXRhPy5oZWFkZXIgfHwgXCJkZWZhdWx0X2hlYWRlclwiLFxyXG4vLyAgICAgICAgICAgICB2YWx1ZU5hbWU6IGdyYXBoRGF0YS5tZXRhPy52YWx1ZU5hbWUgfHwgXCJkZWZhdWx0X3ZhbHVlTmFtZVwiLFxyXG4vLyAgICAgICAgICAgICBsYWJlbDogZ3JhcGhEYXRhLmRhdGFzZXRzWzBdLmxhYmVsLFxyXG4vLyAgICAgICAgICAgICBkYXRhOiBmaWx0ZXJlZFByb2Nlc3NlZERhdGFbc2VsZWN0ZWRDaGFydFR5cGVdPy5bMF0/LmRhdGEsXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIF0sXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICB9O1xyXG4gIFxyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuLy8gICAgICAgICBgaHR0cDovL2xvY2FsaG9zdDozMDEyL2FwaS9hbnN3ZXItYW5hbHl6ZS1leGNlbD9xdWVzdGlvbj0ke2VuY29kZVVSSUNvbXBvbmVudChpbnB1dFZhbHVlKX1gLFxyXG4vLyAgICAgICAgIHtcclxuLy8gICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbi8vICAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXHJcbi8vICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgICApO1xyXG4gIFxyXG4vLyAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZS5cIik7XHJcbi8vICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuLy8gICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHJlc3VsdC5kYXRhPy5wcm9jZXNzZWREYXRhO1xyXG4gIFxyXG4vLyAgICAgICBpZiAoIXByb2Nlc3NlZERhdGEpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzcG9uc2Ugc3RydWN0dXJlLlwiKTtcclxuICBcclxuLy8gICAgICAgY29uc29sZS5sb2coXCJVcGRhdGVkIEFQSSBSZXNwb25zZSBEYXRhOlwiLCBwcm9jZXNzZWREYXRhKTtcclxuICBcclxuLy8gICAgICAgY29uc3QgZ2VuZXJhdGVDaGFydERhdGEgPSAoY2hhcnRUeXBlOiBzdHJpbmcpOiBDaGFydERhdGEgfCBudWxsID0+IHtcclxuLy8gICAgICAgICBjb25zdCBjaGFydEluZm8gPSBwcm9jZXNzZWREYXRhW2NoYXJ0VHlwZV0/LlswXTsgLy8gVXNlIG9ubHkgQVBJIHJlc3BvbnNlIGRhdGFcclxuLy8gICAgICAgICBpZiAoIWNoYXJ0SW5mbykgcmV0dXJuIG51bGw7XHJcbiAgXHJcbi8vICAgICAgICAgY29uc3QgbGFiZWxzID0gT2JqZWN0LmtleXMoY2hhcnRJbmZvLmRhdGEpO1xyXG4vLyAgICAgICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoY2hhcnRJbmZvLmRhdGEpO1xyXG4gIFxyXG4vLyAgICAgICAgIHNldENoYXJ0V2lkdGgobGFiZWxzLmxlbmd0aCAqIDE1MCk7XHJcbiAgXHJcbi8vICAgICAgICAgcmV0dXJuIHtcclxuLy8gICAgICAgICAgIGxhYmVscyxcclxuLy8gICAgICAgICAgIGRhdGFzZXRzOiBbXHJcbi8vICAgICAgICAgICAgIHtcclxuLy8gICAgICAgICAgICAgICBsYWJlbDogY2hhcnRJbmZvLmxhYmVsIHx8IGNoYXJ0VHlwZSxcclxuLy8gICAgICAgICAgICAgICBkYXRhOiB2YWx1ZXMgYXMgbnVtYmVyW10sXHJcbi8vICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbXCJQaWUgQ2hhcnRcIiwgXCJEb251dCBDaGFydFwiLCBcIkJhciBDaGFydFwiXS5pbmNsdWRlcyhjaGFydFR5cGUpXHJcbi8vICAgICAgICAgICAgICAgICA/IFtcInJnYmEoMTczLCAyMTYsIDIzMCwgMC42KVwiLCBcInJnYmEoMTQ0LCAyMzgsIDE0NCwgMC42KVwiLCBcInJnYmEoMjU1LCAxODIsIDE5MywgMC42KVwiXVxyXG4vLyAgICAgICAgICAgICAgICAgOiBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMC42KVwiLFxyXG4vLyAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpID8gXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDEpXCIgOiB1bmRlZmluZWQsXHJcbi8vICAgICAgICAgICAgICAgZmlsbDogIWNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIiksXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICBdLFxyXG4vLyAgICAgICAgICAgbWV0YToge1xyXG4vLyAgICAgICAgICAgICBoZWFkZXI6IGNoYXJ0SW5mby5oZWFkZXIgfHwgXCJkZWZhdWx0X2hlYWRlclwiLFxyXG4vLyAgICAgICAgICAgICB2YWx1ZU5hbWU6IGNoYXJ0SW5mby52YWx1ZU5hbWUgfHwgXCJkZWZhdWx0X3ZhbHVlTmFtZVwiLFxyXG4vLyAgICAgICAgICAgfSxcclxuLy8gICAgICAgICB9O1xyXG4vLyAgICAgICB9O1xyXG4gIFxyXG4vLyAgICAgICAvLyBPbmx5IHVwZGF0ZSBjaGFydERhdGEgd2l0aG91dCBzdG9yaW5nIGluIHN0b3JlZFByb2Nlc3NlZERhdGFcclxuLy8gICAgICAgc2V0Q2hhcnREYXRhKChwcmV2Q2hhcnREYXRhKSA9PiAoe1xyXG4vLyAgICAgICAgIC4uLnByZXZDaGFydERhdGEsXHJcbi8vICAgICAgICAgW3NlbGVjdGVkQ2hhcnRdOiBnZW5lcmF0ZUNoYXJ0RGF0YShzZWxlY3RlZENoYXJ0VHlwZSksXHJcbi8vICAgICAgIH0pKTtcclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzZW5kaW5nIHJlcXVlc3Q6XCIsIGVycm9yKTtcclxuLy8gICAgIH0gZmluYWxseSB7XHJcbi8vICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH07XHJcbiAgXHJcblxyXG4vLyAgIGNvbnN0IGdldENoYXJ0T3B0aW9ucyA9ICh0eXBlOiBzdHJpbmcpID0+ICh7XHJcbi8vICAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4vLyAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXHJcbi8vICAgICBzY2FsZXM6IFtcInBpZUNoYXJ0RGF0YVwiLCBcImRvbnV0Q2hhcnREYXRhXCJdLmluY2x1ZGVzKHR5cGUpXHJcbi8vICAgICAgID8ge31cclxuLy8gICAgICAgOiB7XHJcbi8vICAgICAgICAgeDoge1xyXG4vLyAgICAgICAgICAgdGlja3M6IHtcclxuLy8gICAgICAgICAgICAgYXV0b1NraXA6IGZhbHNlLFxyXG4vLyAgICAgICAgICAgICBtYXhSb3RhdGlvbjogdHlwZSA9PT0gJ2JhckNoYXJ0RGF0YScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXJDaGFydERhdGEnID8gMjAgOiAxMDAsXHJcbi8vICAgICAgICAgbWluUm90YXRpb246IHR5cGUgPT09ICdiYXJDaGFydERhdGEnIHx8IHR5cGUgPT09ICdzY2F0dGVyQ2hhcnREYXRhJyA/IDAgOiA5MCxcclxuLy8gICAgICAgICAgICAgYXV0b1NraXBQYWRkaW5nOiAyMCxcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICBncmlkOiB7XHJcbi8vICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbi8vICAgICAgICAgICAgIGRyYXdUaWNrczogZmFsc2UsXHJcbi8vICAgICAgICAgICAgIHRpY2tMZW5ndGg6IDEwMCxcclxuLy8gICAgICAgICAgICAgbGluZVdpZHRoOiAxXHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICAgICAgeToge1xyXG4vLyAgICAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXHJcbi8vICAgICAgICAgICB0aWNrczogeyBwcmVjaXNpb246IDAgfSxcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgICB9LFxyXG4vLyAgICAgcGx1Z2luczoge1xyXG4vLyAgICAgICBsZWdlbmQ6IHsgZGlzcGxheTogdHJ1ZSwgcG9zaXRpb246IFwidG9wXCIgfSxcclxuLy8gICAgICAgdG9vbHRpcDogeyBlbmFibGVkOiB0cnVlIH0sXHJcbi8vICAgICB9LFxyXG4vLyAgIH0pO1xyXG4vLyAgIGNvbnN0IHJlbmRlckNoYXJ0ID0gKHR5cGU6IHN0cmluZywgQ2hhcnRDb21wb25lbnQ6IGFueSkgPT4ge1xyXG4vLyAgICAgY29uc3QgZGF0YSA9IGNoYXJ0RGF0YVt0eXBlXTtcclxuLy8gICAgIGlmICghbG9hZGluZyAmJiBkYXRhKSB7XHJcbi8vICAgICAgIHJldHVybiAoXHJcbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkIHAtNCBib3JkZXIgcm91bmRlZCBzaGFkb3ctc21cIj5cclxuLy8gICAgICAgICAgIDxkaXYgc3R5bGU9e3sgd2lkdGg6IFwiMTAwJVwiLCBvdmVyZmxvd1g6IFwiYXV0b1wiIH19PlxyXG4vLyAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IG1pbldpZHRoOiBbXCJsaW5lQ2hhcnREYXRhXCIsIFwiYmFyQ2hhcnREYXRhXCJdLmluY2x1ZGVzKHR5cGUpID8gYCR7Y2hhcnRXaWR0aH1weGAgOiBcImF1dG9cIiwgaGVpZ2h0OiBcIjQwMHB4XCIgfX0+XHJcbi8vICAgICAgICAgICAgICAgPENoYXJ0Q29tcG9uZW50IGRhdGE9e2RhdGF9IG9wdGlvbnM9e2dldENoYXJ0T3B0aW9ucyh0eXBlKX0gLz5cclxuLy8gICAgICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgKTtcclxuLy8gICAgIH1cclxuLy8gICAgIHJldHVybiBudWxsO1xyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IGhhbmRsZURvd25sb2FkUERGID0gYXN5bmMgKCkgPT4ge1xyXG4vLyAgICAgaWYgKCFjaGFydFJlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgXHJcbi8vICAgICAvLyBUZW1wb3JhcmlseSBzZXQgdGhlIGNoYXJ0IGNvbnRhaW5lciB0byBpdHMgZnVsbCBoZWlnaHQgdG8gY2FwdHVyZSBhbGwgY29udGVudFxyXG4vLyAgICAgY29uc3Qgb3JpZ2luYWxIZWlnaHQgPSBjaGFydFJlZi5jdXJyZW50LnN0eWxlLmhlaWdodDtcclxuLy8gICAgIGNoYXJ0UmVmLmN1cnJlbnQuc3R5bGUuaGVpZ2h0ID0gYCR7Y2hhcnRSZWYuY3VycmVudC5zY3JvbGxIZWlnaHR9cHhgO1xyXG4gIFxyXG4vLyAgICAgY29uc3QgY2FudmFzID0gYXdhaXQgaHRtbDJjYW52YXMoY2hhcnRSZWYuY3VycmVudCwge1xyXG4vLyAgICAgICBzY3JvbGxYOiAwLFxyXG4vLyAgICAgICBzY3JvbGxZOiAtd2luZG93LnNjcm9sbFksXHJcbi8vICAgICAgIHdpZHRoOiBjaGFydFJlZi5jdXJyZW50LnNjcm9sbFdpZHRoLFxyXG4vLyAgICAgICBoZWlnaHQ6IGNoYXJ0UmVmLmN1cnJlbnQuc2Nyb2xsSGVpZ2h0LFxyXG4vLyAgICAgfSk7XHJcbiAgXHJcbi8vICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBoZWlnaHQgb2YgdGhlIGNoYXJ0IGNvbnRhaW5lclxyXG4vLyAgICAgY2hhcnRSZWYuY3VycmVudC5zdHlsZS5oZWlnaHQgPSBvcmlnaW5hbEhlaWdodDtcclxuICBcclxuLy8gICAgIGNvbnN0IGltZ0RhdGEgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xyXG4vLyAgICAgY29uc3QgcGRmID0gbmV3IGpzUERGKFwibGFuZHNjYXBlXCIsIFwibW1cIiwgXCJhNFwiKTtcclxuLy8gICAgIGNvbnN0IGltZ1Byb3BzID0gcGRmLmdldEltYWdlUHJvcGVydGllcyhpbWdEYXRhKTtcclxuLy8gICAgIGNvbnN0IHBkZldpZHRoID0gcGRmLmludGVybmFsLnBhZ2VTaXplLmdldFdpZHRoKCk7XHJcbi8vICAgICBjb25zdCBwZGZIZWlnaHQgPSAoaW1nUHJvcHMuaGVpZ2h0ICogcGRmV2lkdGgpIC8gaW1nUHJvcHMud2lkdGg7XHJcbiAgXHJcbi8vICAgICBwZGYuYWRkSW1hZ2UoaW1nRGF0YSwgXCJQTkdcIiwgMCwgMCwgcGRmV2lkdGgsIHBkZkhlaWdodCk7XHJcbi8vICAgICBwZGYuc2F2ZShcImNoYXJ0LnBkZlwiKTtcclxuLy8gICB9O1xyXG5cclxuLy8gICByZXR1cm4gKFxyXG4vLyAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIG1kOmZsZXgtcm93IGgtc2NyZWVuIGJvcmRlciBib3JkZXItYmxhY2tcIj5cclxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0xLzQgYmctd2hpdGUgcC01IGJvcmRlci10IG1kOmJvcmRlci1sIG1kOmJvcmRlci1ibGFja1wiPlxyXG4vLyAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+VXBsb2FkIEZpbGU8L2gyPlxyXG4vLyAgICAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIG9uQ2hhbmdlPXtoYW5kbGVGaWxlQ2hhbmdlfSBjbGFzc05hbWU9XCJib3JkZXIgcC0yIHctZnVsbFwiIC8+XHJcbi8vICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtoYW5kbGVTdWJtaXR9IGNsYXNzTmFtZT1cImJnLWJsdWUtNTAwIHRleHQtd2hpdGUgcC0yIHJvdW5kZWQgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgbXQtNFwiPlxyXG4vLyAgICAgICAgICAgPEJzVXBsb2FkIGNsYXNzTmFtZT1cIm1yLTJcIiAvPiBTdWJtaXRcclxuLy8gICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgc3BhY2UteS0yIG10LTRcIj5cclxuLy8gICAgICAgICAgIHtbXCJsaW5lQ2hhcnREYXRhXCIsIFwiYmFyQ2hhcnREYXRhXCIsIFwic2NhdHRlckNoYXJ0RGF0YVwiLCBcInBpZUNoYXJ0RGF0YVwiLCBcImRvbnV0Q2hhcnREYXRhXCJdLm1hcCgodHlwZSkgPT4gKFxyXG4vLyAgICAgICAgICAgICA8YnV0dG9uIGtleT17dHlwZX0gb25DbGljaz17KCkgPT4gc2V0U2VsZWN0ZWRDaGFydCh0eXBlKX0gY2xhc3NOYW1lPVwicC0yIGJnLWdyYXktMzAwIHJvdW5kZWQgaG92ZXI6YmctZ3JheS00MDBcIj5cclxuLy8gICAgICAgICAgICAgICB7dHlwZS5yZXBsYWNlKFwiQ2hhcnREYXRhXCIsIFwiIENoYXJ0XCIpfVxyXG4vLyAgICAgICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgICAgICkpfVxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0zLzQgYmctZ3JheS0xMDAgcC01IG92ZXJmbG93LWF1dG9cIj5cclxuLy8gICAgICAgICB7bG9hZGluZyA/IChcclxuLy8gICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgaC1mdWxsXCI+XHJcbi8vICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3Bpbm5lci1ib3JkZXIgYW5pbWF0ZS1zcGluIGJvcmRlci10LTQgYm9yZGVyLWJsdWUtNTAwIHJvdW5kZWQtZnVsbCB3LTEyIGgtMTJcIj48L2Rpdj5cclxuLy8gICAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICAgICkgOiAoXHJcbi8vICAgICAgICAgICBzZWxlY3RlZENoYXJ0ICYmIHJlbmRlckNoYXJ0KHNlbGVjdGVkQ2hhcnQsIHsgbGluZUNoYXJ0RGF0YTogTGluZSwgYmFyQ2hhcnREYXRhOiBCYXIsIHNjYXR0ZXJDaGFydERhdGE6IFNjYXR0ZXIsIHBpZUNoYXJ0RGF0YTogUGllLCBkb251dENoYXJ0RGF0YTogRG91Z2hudXQgfVtzZWxlY3RlZENoYXJ0XSlcclxuLy8gICAgICAgICApfVxyXG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtNCBmbGV4XCI+XHJcbi8vICAgICAgICAgICA8aW5wdXRcclxuLy8gICAgICAgICAgICAgdHlwZT1cInRleHRcIlxyXG4vLyAgICAgICAgICAgICB2YWx1ZT17aW5wdXRWYWx1ZX1cclxuLy8gICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRJbnB1dFZhbHVlKGUudGFyZ2V0LnZhbHVlKX1cclxuLy8gICAgICAgICAgICAgY2xhc3NOYW1lPVwiYm9yZGVyIHAtMiBmbGV4LWdyb3cgbXItMiByb3VuZGVkXCJcclxuLy8gICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJFbnRlciB5b3VyIHRleHQgaGVyZVwiXHJcbi8vICAgICAgICAgICAvPlxyXG4vLyAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtoYW5kbGVTZW5kfSBjbGFzc05hbWU9XCJiZy1ncmVlbi01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZFwiPlxyXG4vLyAgICAgICAgICAgICBTZW5kXHJcbi8vICAgICAgICAgICA8L2J1dHRvbj5cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTQgcC00IGJvcmRlciBib3JkZXItZ3JheS0zMDAgcm91bmRlZCBiZy13aGl0ZVwiPlxyXG4vLyAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5JbnNpZ2h0czwvaDM+XHJcbi8vICAgICAgICAgICB7Y29tYmluZWRJbnNpZ2h0cyA/IChcclxuLy8gICAgICAgICAgICAgPG9sIGNsYXNzTmFtZT1cImxpc3QtZGVjaW1hbCBsaXN0LWluc2lkZSB0ZXh0LXNtIHRleHQtZ3JheS03MDAgYmctZ3JheS0xMDAgcC0yIHJvdW5kZWQgb3ZlcmZsb3ctYXV0b1wiPlxyXG4vLyAgICAgICAgICAgICAgIHtjb21iaW5lZEluc2lnaHRzLnNwbGl0KCdcXG4nKS5tYXAoKGluc2lnaHQsIGluZGV4KSA9PiAoXHJcbi8vICAgICAgICAgICAgICAgICA8dWwga2V5PXtpbmRleH0+e2luc2lnaHR9PC91bD5cclxuLy8gICAgICAgICAgICAgICApKX1cclxuLy8gICAgICAgICAgICAgPC9vbD5cclxuLy8gICAgICAgICAgICkgOiAoXHJcbi8vICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtZ3JheS01MDBcIj5ObyBpbnNpZ2h0cyBhdmFpbGFibGUuPC9wPlxyXG4vLyAgICAgICAgICAgKX1cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2hhbmRsZURvd25sb2FkUERGfSBjbGFzc05hbWU9XCJiZy1yZWQtNTAwIHRleHQtd2hpdGUgcC0yIHJvdW5kZWQgbXQtNFwiPlxyXG4vLyAgICAgICAgICAgRG93bmxvYWQgYXMgUERGXHJcbi8vICAgICAgICAgPC9idXR0b24+XHJcbi8vICAgICAgIDwvZGl2PlxyXG4vLyAgICAgPC9kaXY+XHJcbi8vICAgKTtcclxuLy8gfVxyXG5cclxuXHJcblxyXG5cInVzZSBjbGllbnRcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmLCBBd2FpdGVkUmVhY3ROb2RlLCBKU1hFbGVtZW50Q29uc3RydWN0b3IsIEtleSwgUmVhY3RFbGVtZW50LCBSZWFjdE5vZGUsIFJlYWN0UG9ydGFsIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IEJhciwgTGluZSwgRG91Z2hudXQsIFBpZSwgU2NhdHRlciB9IGZyb20gXCJyZWFjdC1jaGFydGpzLTJcIjtcclxuaW1wb3J0IHsgQ2hhcnQgYXMgQ2hhcnRKUywgQ2F0ZWdvcnlTY2FsZSwgTGluZWFyU2NhbGUsIEJhckVsZW1lbnQsIExpbmVFbGVtZW50LCBQb2ludEVsZW1lbnQsIEFyY0VsZW1lbnQsIFRpdGxlLCBUb29sdGlwLCBMZWdlbmQgfSBmcm9tIFwiY2hhcnQuanNcIjtcclxuaW1wb3J0IHsgQnNVcGxvYWQgfSBmcm9tIFwicmVhY3QtaWNvbnMvYnNcIjtcclxuaW1wb3J0IHpvb21QbHVnaW4gZnJvbSBcImNoYXJ0anMtcGx1Z2luLXpvb21cIjtcclxuaW1wb3J0IGh0bWwyY2FudmFzIGZyb20gXCJodG1sMmNhbnZhc1wiO1xyXG5pbXBvcnQganNQREYgZnJvbSBcImpzcGRmXCI7XHJcbmltcG9ydCBDaGFydCBmcm9tIFwicmVhY3QtYXBleGNoYXJ0c1wiO1xyXG5DaGFydEpTLnJlZ2lzdGVyKENhdGVnb3J5U2NhbGUsIExpbmVhclNjYWxlLCBCYXJFbGVtZW50LCBMaW5lRWxlbWVudCwgUG9pbnRFbGVtZW50LCBBcmNFbGVtZW50LCBUaXRsZSwgVG9vbHRpcCwgTGVnZW5kLCB6b29tUGx1Z2luKTtcclxuXHJcbmludGVyZmFjZSBDaGFydERhdGEge1xyXG4gIGxhYmVsczogc3RyaW5nW107XHJcbiAgZGF0YXNldHM6IHtcclxuICAgIGxhYmVsOiBzdHJpbmc7XHJcbiAgICBkYXRhOiBudW1iZXJbXTtcclxuICAgIGJhY2tncm91bmRDb2xvcj86IHN0cmluZyB8IHN0cmluZ1tdO1xyXG4gICAgYm9yZGVyQ29sb3I/OiBzdHJpbmc7XHJcbiAgICBmaWxsPzogYm9vbGVhbjtcclxuICB9W11cclxuICBtZXRhPzoge1xyXG4gICAgaGVhZGVyOiBzdHJpbmc7XHJcbiAgICB2YWx1ZU5hbWU6IHN0cmluZztcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEYXNoYm9hcmQoKSB7XHJcbiAgY29uc3QgW2NoYXJ0RGF0YSwgc2V0Q2hhcnREYXRhXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIENoYXJ0RGF0YSB8IG51bGw+Pih7XHJcbiAgICBzY2F0dGVyQ2hhcnREYXRhOiBudWxsLFxyXG4gICAgcGllQ2hhcnREYXRhOiBudWxsLFxyXG4gICAgZG9udXRDaGFydERhdGE6IG51bGwsXHJcbiAgICBsaW5lQ2hhcnREYXRhOiBudWxsLFxyXG4gICAgYmFyQ2hhcnREYXRhOiBudWxsLFxyXG4gIH0pO1xyXG4gIGNvbnN0IFtzZWxlY3RlZEZpbGUsIHNldFNlbGVjdGVkRmlsZV0gPSB1c2VTdGF0ZTxGaWxlIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW3NlbGVjdGVkQ2hhcnQsIHNldFNlbGVjdGVkQ2hhcnRdID0gdXNlU3RhdGU8c3RyaW5nPihcImxpbmVDaGFydERhdGFcIik7XHJcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xyXG4gIGNvbnN0IFtjaGFydFdpZHRoLCBzZXRDaGFydFdpZHRoXSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XHJcbiAgY29uc3QgW2lucHV0VmFsdWUsIHNldElucHV0VmFsdWVdID0gdXNlU3RhdGU8c3RyaW5nPihcIlwiKTtcclxuICBjb25zdCBbc3RvcmVkUHJvY2Vzc2VkRGF0YSwgc2V0U3RvcmVkUHJvY2Vzc2VkRGF0YV0gPSB1c2VTdGF0ZTxhbnk+KG51bGwpOyAvLyBOZXcgc3RhdGUgdG8gc3RvcmUgcHJvY2Vzc2VkIGRhdGFcclxuICBjb25zdCBbY29tYmluZWRJbnNpZ2h0cywgc2V0Q29tYmluZWRJbnNpZ2h0c10gPSB1c2VTdGF0ZTxhbnk+KG51bGwpO1xyXG4gIGNvbnN0IGNoYXJ0UmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTsgLy8gUmVmIGZvciB0aGUgY2hhcnQgY29udGFpbmVyXHJcblxyXG4gIGNvbnN0IGhhbmRsZUZpbGVDaGFuZ2UgPSAoZXZlbnQ6IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XHJcbiAgICBzZXRTZWxlY3RlZEZpbGUoZXZlbnQudGFyZ2V0LmZpbGVzPy5bMF0gfHwgbnVsbCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKCFzZWxlY3RlZEZpbGUpIHJldHVybjtcclxuICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcblxyXG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgc2VsZWN0ZWRGaWxlKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cDovL2xvY2FsaG9zdDozMDEyL2FwaS9hbmFseXplLWV4Y2VsXCIsIHtcclxuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICAgIGJvZHk6IGZvcm1EYXRhLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHVwbG9hZGluZyBmaWxlLlwiKTtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBjb25zdCBjb21iaW5lZEluc2lnaHRzID0gcmVzdWx0LmRhdGE/LmNvbWJpbmVkSW5zaWdodHM7XHJcbiAgICAgIGNvbnN0IHByb2Nlc3NlZERhdGEgPSByZXN1bHQuZGF0YT8ucHJvY2Vzc2VkRGF0YTtcclxuXHJcbiAgICAgIGlmICghcHJvY2Vzc2VkRGF0YSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBzdHJ1Y3R1cmUuXCIpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcInByb2Nlc3NlZERhdGFcIiwgcHJvY2Vzc2VkRGF0YSk7XHJcblxyXG4gICAgICBzZXRTdG9yZWRQcm9jZXNzZWREYXRhKHByb2Nlc3NlZERhdGEpOyAvLyBTdG9yZSB0aGUgcHJvY2Vzc2VkIGRhdGFcclxuICAgICAgc2V0Q29tYmluZWRJbnNpZ2h0cyhjb21iaW5lZEluc2lnaHRzKTtcclxuICAgICAgY29uc3QgbGlnaHRDb2xvcnMgPSBbXHJcbiAgICAgICAgXCJyZ2JhKDE3MywgMjE2LCAyMzAsIDAuNilcIixcclxuICAgICAgICBcInJnYmEoMTQ0LCAyMzgsIDE0NCwgMC42KVwiLFxyXG4gICAgICAgIFwicmdiYSgyNTUsIDE4MiwgMTkzLCAwLjYpXCIsXHJcbiAgICAgICAgXCJyZ2JhKDI1NSwgMjI4LCAxODEsIDAuNilcIixcclxuICAgICAgICBcInJnYmEoMjIxLCAxNjAsIDIyMSwgMC42KVwiLFxyXG4gICAgICAgIFwicmdiYSgyNDAsIDIzMCwgMTQwLCAwLjYpXCIsXHJcbiAgICAgIF07XHJcblxyXG4gICAgICBjb25zdCBnZW5lcmF0ZUNoYXJ0RGF0YSA9IChjaGFydFR5cGU6IHN0cmluZyk6IENoYXJ0RGF0YSB8IG51bGwgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNoYXJ0SW5mbyA9IHByb2Nlc3NlZERhdGFbY2hhcnRUeXBlXT8uWzBdO1xyXG4gICAgICAgIGlmICghY2hhcnRJbmZvKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgY29uc3QgbGFiZWxzID0gT2JqZWN0LmtleXMoY2hhcnRJbmZvLmRhdGEpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoY2hhcnRJbmZvLmRhdGEpO1xyXG5jb25zb2xlLmxvZyhcImNoYXJ0VHlwZVwiLGNoYXJ0VHlwZSk7XHJcblxyXG4gICAgICAgIGxldCBjaGFydFdpZHRoID0gMDtcclxuICAgICAgICBpZiAoW1wiTGluZSBDaGFydFwiXS5pbmNsdWRlcyhjaGFydFR5cGUpKSB7XHJcbiAgICAgICAgICBjaGFydFdpZHRoID0gbGFiZWxzLmxlbmd0aCAqIDE1MDtcclxuICAgICAgICB9IGVsc2UgaWYgKFtcIkJhciBDaGFydFwiXS5pbmNsdWRlcyhjaGFydFR5cGUpKSB7XHJcbiAgICAgICAgICBjaGFydFdpZHRoID0gbGFiZWxzLmxlbmd0aCAqIDE1MDsgLy8gQWRqdXN0IHRoZSB3aWR0aCBmb3IgYmFyIGNoYXJ0XHJcbiAgICAgICAgfSBcclxuICAgICAgICBlbHNlIGlmIChbXCJTY2F0dGVyIFBsb3RcIl0uaW5jbHVkZXMoY2hhcnRUeXBlKSkge1xyXG4gICAgICAgICAgY2hhcnRXaWR0aCA9IGxhYmVscy5sZW5ndGggKiAxNTA7IC8vIEFkanVzdCB0aGUgd2lkdGggZm9yIGJhciBjaGFydFxyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgIGNoYXJ0V2lkdGggPSA0MDA7IC8vIERlZmF1bHQgd2lkdGggZm9yIG90aGVyIGNoYXJ0IHR5cGVzXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZXRDaGFydFdpZHRoKGNoYXJ0V2lkdGgpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgbGFiZWxzLFxyXG4gICAgICAgICAgZGF0YXNldHM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIGxhYmVsOiBjaGFydEluZm8ubGFiZWwgfHwgY2hhcnRUeXBlLFxyXG4gICAgICAgICAgICAgIGRhdGE6IHZhbHVlcyBhcyBudW1iZXJbXSxcclxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcIlBpZSBDaGFydFwiLCBcIkRvbnV0IENoYXJ0XCIsIFwiQmFyIENoYXJ0XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSlcclxuICAgICAgICAgICAgICAgID8gbGlnaHRDb2xvcnMuc2xpY2UoMCwgbGFiZWxzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIDogXCJyZ2JhKDEzNSwgMjA2LCAyNTAsIDAuNilcIixcclxuICAgICAgICAgICAgICBib3JkZXJDb2xvcjogY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSA/IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAxKVwiIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgIGZpbGw6ICFjaGFydFR5cGUuaW5jbHVkZXMoXCJMaW5lXCIpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgXSxcclxuICAgICAgICAgIG1ldGE6IHtcclxuICAgICAgICAgICAgaGVhZGVyOiBjaGFydEluZm8uaGVhZGVyIHx8IFwiZGVmYXVsdF9oZWFkZXJcIixcclxuICAgICAgICAgICAgdmFsdWVOYW1lOiBjaGFydEluZm8udmFsdWVOYW1lIHx8IFwiZGVmYXVsdF92YWx1ZU5hbWVcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHNldENoYXJ0RGF0YSh7XHJcbiAgICAgICAgc2NhdHRlckNoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJTY2F0dGVyIFBsb3RcIiksXHJcbiAgICAgICAgcGllQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIlBpZSBDaGFydFwiKSxcclxuICAgICAgICBkb251dENoYXJ0RGF0YTogZ2VuZXJhdGVDaGFydERhdGEoXCJEb251dCBDaGFydFwiKSxcclxuICAgICAgICBsaW5lQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkxpbmUgQ2hhcnRcIiksXHJcbiAgICAgICAgYmFyQ2hhcnREYXRhOiBnZW5lcmF0ZUNoYXJ0RGF0YShcIkJhciBDaGFydFwiKSxcclxuICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXBsb2FkaW5nIGZpbGU6XCIsIGVycm9yKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZVNlbmQgPSBhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAoIWlucHV0VmFsdWUpIHJldHVybjtcclxuICBcclxuICAgIGNvbnN0IGdyYXBoRGF0YSA9IGNoYXJ0RGF0YVtzZWxlY3RlZENoYXJ0XTtcclxuICAgIGlmICghZ3JhcGhEYXRhKSByZXR1cm47XHJcbiAgXHJcbiAgICBjb25zdCBsYWJlbHMgPSBncmFwaERhdGEubGFiZWxzO1xyXG4gICAgY29uc3QgdmFsdWVzID0gZ3JhcGhEYXRhLmRhdGFzZXRzWzBdLmRhdGE7XHJcbiAgXHJcbiAgICBjb25zdCBkYXRhT2JqZWN0ID0gbGFiZWxzLnJlZHVjZSgob2JqOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9LCBsYWJlbCwgaW5kZXgpID0+IHtcclxuICAgICAgb2JqW2xhYmVsXSA9IHZhbHVlc1tpbmRleF07XHJcbiAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9LCB7fSk7XHJcbiAgXHJcbiAgICBjb25zdCBjaGFydFR5cGVNYXBwaW5nOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xyXG4gICAgICBsaW5lQ2hhcnREYXRhOiBcIkxpbmUgQ2hhcnRcIixcclxuICAgICAgcGllQ2hhcnREYXRhOiBcIlBpZSBDaGFydFwiLFxyXG4gICAgICBkb251dENoYXJ0RGF0YTogXCJEb251dCBDaGFydFwiLFxyXG4gICAgICBiYXJDaGFydERhdGE6IFwiQmFyIENoYXJ0XCIsXHJcbiAgICAgIHNjYXR0ZXJDaGFydERhdGE6IFwiU2NhdHRlciBQbG90XCIsXHJcbiAgICB9O1xyXG4gIFxyXG4gICAgY29uc3Qgc2VsZWN0ZWRDaGFydFR5cGUgPSBjaGFydFR5cGVNYXBwaW5nW3NlbGVjdGVkQ2hhcnRdIHx8IHNlbGVjdGVkQ2hhcnQ7XHJcbiAgXHJcbiAgICAvLyBGaWx0ZXIgdGhlIHN0b3JlZCBwcm9jZXNzZWQgZGF0YSB0byBpbmNsdWRlIG9ubHkgdGhlIHNlbGVjdGVkIGNoYXJ0J3MgZGF0YVxyXG4gICAgY29uc3QgZmlsdGVyZWRQcm9jZXNzZWREYXRhID0ge1xyXG4gICAgICBbc2VsZWN0ZWRDaGFydFR5cGVdOiBzdG9yZWRQcm9jZXNzZWREYXRhW3NlbGVjdGVkQ2hhcnRUeXBlXSxcclxuICAgIH07XHJcbiAgXHJcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcclxuICAgICAgcXVlc3Rpb246IGlucHV0VmFsdWUsXHJcbiAgICAgIHByb2Nlc3NlZERhdGE6IHtcclxuICAgICAgICAvLyBJbmNsdWRlIHRoZSBzdG9yZWQgcHJvY2Vzc2VkIGRhdGFcclxuICAgICAgICBbc2VsZWN0ZWRDaGFydFR5cGVdOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGhlYWRlcjogZ3JhcGhEYXRhLm1ldGE/LmhlYWRlciB8fCBcImRlZmF1bHRfaGVhZGVyXCIsXHJcbiAgICAgICAgICAgIHZhbHVlTmFtZTogZ3JhcGhEYXRhLm1ldGE/LnZhbHVlTmFtZSB8fCBcImRlZmF1bHRfdmFsdWVOYW1lXCIsXHJcbiAgICAgICAgICAgIGxhYmVsOiBncmFwaERhdGEuZGF0YXNldHNbMF0ubGFiZWwsXHJcbiAgICAgICAgICAgIGRhdGE6IGZpbHRlcmVkUHJvY2Vzc2VkRGF0YVtzZWxlY3RlZENoYXJ0VHlwZV0/LlswXT8uZGF0YSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgICBgaHR0cDovL2xvY2FsaG9zdDozMDEyL2FwaS9hbnN3ZXItYW5hbHl6ZS1leGNlbD9xdWVzdGlvbj0ke2VuY29kZVVSSUNvbXBvbmVudChpbnB1dFZhbHVlKX1gLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXHJcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gIFxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB1cGxvYWRpbmcgZmlsZS5cIik7XHJcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwicmVzdWx0LmRhdGFcIixyZXN1bHQuZGF0YS5kYXRhLmNvbWJpbmVkSW5zaWdodHMpXHJcbiAgICAgIHNldENvbWJpbmVkSW5zaWdodHMocmVzdWx0LmRhdGEuZGF0YS5jb21iaW5lZEluc2lnaHRzKVxyXG4gICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gcmVzdWx0LmRhdGE/LnByb2Nlc3NlZERhdGE7XHJcbiAgXHJcbiAgICAgIGlmICghcHJvY2Vzc2VkRGF0YSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBzdHJ1Y3R1cmUuXCIpO1xyXG4gIFxyXG4gICAgICBjb25zdCBnZW5lcmF0ZUNoYXJ0RGF0YSA9IChjaGFydFR5cGU6IHN0cmluZyk6IENoYXJ0RGF0YSB8IG51bGwgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNoYXJ0SW5mbyA9IHByb2Nlc3NlZERhdGFbY2hhcnRUeXBlXT8uWzBdOyAvLyBVc2Ugb25seSBBUEkgcmVzcG9uc2UgZGF0YVxyXG4gICAgICAgIGlmICghY2hhcnRJbmZvKSByZXR1cm4gbnVsbDtcclxuICBcclxuICAgICAgICBjb25zdCBsYWJlbHMgPSBPYmplY3Qua2V5cyhjaGFydEluZm8uZGF0YSk7XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhjaGFydEluZm8uZGF0YSk7XHJcbiAgICAgICAgbGV0IGNoYXJ0V2lkdGggPSAwO1xyXG4gICAgICAgIGlmIChbXCJMaW5lIENoYXJ0XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSkpIHtcclxuICAgICAgICAgIGNoYXJ0V2lkdGggPSBsYWJlbHMubGVuZ3RoICogMTUwO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoW1wiQmFyIENoYXJ0XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSkpIHtcclxuICAgICAgICAgIGNoYXJ0V2lkdGggPSBsYWJlbHMubGVuZ3RoICogMTUwOyAvLyBBZGp1c3QgdGhlIHdpZHRoIGZvciBiYXIgY2hhcnRcclxuICAgICAgICB9IFxyXG4gICAgICAgIGVsc2UgaWYgKFtcIlNjYXR0ZXIgUGxvdFwiXS5pbmNsdWRlcyhjaGFydFR5cGUpKSB7XHJcbiAgICAgICAgICBjaGFydFdpZHRoID0gbGFiZWxzLmxlbmd0aCAqIDE1MDsgLy8gQWRqdXN0IHRoZSB3aWR0aCBmb3IgYmFyIGNoYXJ0XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgY2hhcnRXaWR0aCA9IDQwMDsgLy8gRGVmYXVsdCB3aWR0aCBmb3Igb3RoZXIgY2hhcnQgdHlwZXNcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0Q2hhcnRXaWR0aChjaGFydFdpZHRoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgbGFiZWxzLFxyXG4gICAgICAgICAgZGF0YXNldHM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIGxhYmVsOiBjaGFydEluZm8ubGFiZWwgfHwgY2hhcnRUeXBlLFxyXG4gICAgICAgICAgICAgIGRhdGE6IHZhbHVlcyBhcyBudW1iZXJbXSxcclxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcIlBpZSBDaGFydFwiLCBcIkRvbnV0IENoYXJ0XCIsIFwiQmFyIENoYXJ0XCJdLmluY2x1ZGVzKGNoYXJ0VHlwZSlcclxuICAgICAgICAgICAgICAgID8gW1wicmdiYSgxNzMsIDIxNiwgMjMwLCAwLjYpXCIsIFwicmdiYSgxNDQsIDIzOCwgMTQ0LCAwLjYpXCIsIFwicmdiYSgyNTUsIDE4MiwgMTkzLCAwLjYpXCJdXHJcbiAgICAgICAgICAgICAgICA6IFwicmdiYSgxMzUsIDIwNiwgMjUwLCAwLjYpXCIsXHJcbiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNoYXJ0VHlwZS5pbmNsdWRlcyhcIkxpbmVcIikgPyBcInJnYmEoMTM1LCAyMDYsIDI1MCwgMSlcIiA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICBmaWxsOiAhY2hhcnRUeXBlLmluY2x1ZGVzKFwiTGluZVwiKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIF0sXHJcbiAgICAgICAgICBtZXRhOiB7XHJcbiAgICAgICAgICAgIGhlYWRlcjogY2hhcnRJbmZvLmhlYWRlciB8fCBcImRlZmF1bHRfaGVhZGVyXCIsXHJcbiAgICAgICAgICAgIHZhbHVlTmFtZTogY2hhcnRJbmZvLnZhbHVlTmFtZSB8fCBcImRlZmF1bHRfdmFsdWVOYW1lXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgIH07XHJcbiAgXHJcbiAgICAgIC8vIE9ubHkgdXBkYXRlIGNoYXJ0RGF0YSB3aXRob3V0IHN0b3JpbmcgaW4gc3RvcmVkUHJvY2Vzc2VkRGF0YVxyXG4gICAgICBzZXRDaGFydERhdGEoKHByZXZDaGFydERhdGEpID0+ICh7XHJcbiAgICAgICAgLi4ucHJldkNoYXJ0RGF0YSxcclxuICAgICAgICBbc2VsZWN0ZWRDaGFydF06IGdlbmVyYXRlQ2hhcnREYXRhKHNlbGVjdGVkQ2hhcnRUeXBlKSxcclxuICAgICAgfSkpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgLy8gY29uc29sZS5lcnJvcihcIkVycm9yIHNlbmRpbmcgcmVxdWVzdDpcIiwgZXJyb3IpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCByZW5kZXJDaGFydCA9ICh0eXBlOiBzdHJpbmcsIENoYXJ0Q29tcG9uZW50OiBhbnkpID0+IHtcclxuICAgIGNvbnN0IGRhdGEgPSBjaGFydERhdGE/Llt0eXBlXTtcclxuICBcclxuICAgIGlmICghbG9hZGluZyAmJiBkYXRhKSB7XHJcbiAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBkYXRhLmxhYmVscz8ubGVuZ3RoIHx8IDA7XHJcbiAgICAgIGNvbnN0IG1heFRpY2tzID0gTWF0aC5mbG9vcig2MDAgLyAzMCk7IC8vIEFwcHJveCAzMHB4IHBlciB2ZXJ0aWNhbCBsYWJlbFxyXG4gIFxyXG4gICAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG92ZXJmbG93LXgtYXV0byBvdmVyZmxvdy15LWhpZGRlbiBiZy13aGl0ZSBwLTQgcm91bmRlZC1sZyBzaGFkb3dcIj5cclxuICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICB3aWR0aDogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgbWluV2lkdGg6IFtcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIl0uaW5jbHVkZXModHlwZSlcclxuICAgICAgICAgICAgICAgID8gTWF0aC5tYXgoNjAwLCBkYXRhTGVuZ3RoICogMzApICsgXCJweFwiXHJcbiAgICAgICAgICAgICAgICA6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICAgIGhlaWdodDogXCI0MDBweFwiLFxyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJyZWxhdGl2ZVwiXHJcbiAgICAgICAgICA+XHJcbiAgICAgICAgICAgIDxDaGFydENvbXBvbmVudFxyXG4gICAgICAgICAgICAgIGRhdGE9e2RhdGF9XHJcbiAgICAgICAgICAgICAgb3B0aW9ucz17e1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2NhbGVzOiB7XHJcbiAgICAgICAgICAgICAgICAgIHg6IHtcclxuICAgICAgICAgICAgICAgICAgICBtaW46IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgdGlja3M6IHtcclxuICAgICAgICAgICAgICAgICAgICAgIGF1dG9Ta2lwOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgIG1heFRpY2tzTGltaXQ6IG1heFRpY2tzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgbWF4Um90YXRpb246IDkwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgbWluUm90YXRpb246IDkwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMTAsIC8vIEluY3JlYXNlZCBwYWRkaW5nIGZvciBiZXR0ZXIgc3BhY2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgZm9udDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiAxMixcclxuICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICBhbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgbGFzdCBsYWJlbHMgZG9uJ3Qgb3ZlcmxhcFxyXG4gICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKF92YWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBpbmRleDogbnVtYmVyLCB2YWx1ZXM6IGFueVtdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcmVuZGVyaW5nIGlmIHRvbyBjbG9zZSB0byB0aGUgZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdmFsdWVzLmxlbmd0aCAtIDEgJiYgZGF0YUxlbmd0aCA+IG1heFRpY2tzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIEhpZGUgbGFzdCBsYWJlbCBpZiBpdCBtaWdodCBvdmVybGFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBncmlkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICB5OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcGx1Z2luczoge1xyXG4gICAgICAgICAgICAgICAgICBsZWdlbmQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInRvcFwiLFxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICB0b29sdGlwOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6ICdpbmRleCcsXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbGF5b3V0OiB7XHJcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAzMCwgIC8vIEluY3JlYXNlZCB0byBwcmV2ZW50IGxlZnQgZWRnZSBvdmVybGFwXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDMwLCAvLyBJbmNyZWFzZWQgdG8gcHJldmVudCByaWdodCBlZGdlIG92ZXJsYXBcclxuICAgICAgICAgICAgICAgICAgICBib3R0b206IDQwLCAvLyBJbmNyZWFzZWQgZm9yIHZlcnRpY2FsIGxhYmVsc1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9O1xyXG5cclxuXHJcbiAgXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCB3LWZ1bGwgbWQ6ZmxleC1yb3cgaC1zY3JlZW4gYm9yZGVyIGJvcmRlci1ibGFja1wiPlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTEvNCBiZy13aGl0ZSBwLTUgYm9yZGVyLXQgbWQ6Ym9yZGVyLWwgbWQ6Ym9yZGVyLWJsYWNrXCI+XHJcbiAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5VcGxvYWQgRmlsZTwvaDI+XHJcbiAgICAgICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgb25DaGFuZ2U9e2hhbmRsZUZpbGVDaGFuZ2V9IGNsYXNzTmFtZT1cImJvcmRlciBwLTIgdy1mdWxsXCIgLz5cclxuICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2hhbmRsZVN1Ym1pdH0gY2xhc3NOYW1lPVwiYmctYmx1ZS01MDAgdGV4dC13aGl0ZSBwLTIgcm91bmRlZCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBtdC00XCI+XHJcbiAgICAgICAgICA8QnNVcGxvYWQgY2xhc3NOYW1lPVwibXItMlwiIC8+IFN1Ym1pdFxyXG4gICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBzcGFjZS15LTIgbXQtNFwiPlxyXG4gICAgICAgICAge1tcImxpbmVDaGFydERhdGFcIiwgXCJiYXJDaGFydERhdGFcIiwgXCJzY2F0dGVyQ2hhcnREYXRhXCIsIFwicGllQ2hhcnREYXRhXCIsIFwiZG9udXRDaGFydERhdGFcIl0ubWFwKCh0eXBlKSA9PiAoXHJcbiAgICAgICAgICAgIDxidXR0b24ga2V5PXt0eXBlfSBvbkNsaWNrPXsoKSA9PiBzZXRTZWxlY3RlZENoYXJ0KHR5cGUpfSBjbGFzc05hbWU9XCJwLTIgYmctZ3JheS0zMDAgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTQwMFwiPlxyXG4gICAgICAgICAgICAgIHt0eXBlLnJlcGxhY2UoXCJDaGFydERhdGFcIiwgXCIgQ2hhcnRcIil9XHJcbiAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgKSl9XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTMvNCBiZy1ncmF5LTEwMCBwLTVcIj5cclxuICB7bG9hZGluZyA/IChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgaC1mdWxsXCI+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3Bpbm5lci1ib3JkZXIgYW5pbWF0ZS1zcGluIGJvcmRlci10LTQgYm9yZGVyLWJsdWUtNTAwIHJvdW5kZWQtZnVsbCB3LTEyIGgtMTJcIj48L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICkgOiAoXHJcbiAgICBzZWxlY3RlZENoYXJ0ICYmIHJlbmRlckNoYXJ0KHNlbGVjdGVkQ2hhcnQsIHsgXHJcbiAgICAgIGxpbmVDaGFydERhdGE6IExpbmUsIFxyXG4gICAgICBiYXJDaGFydERhdGE6IEJhciwgXHJcbiAgICAgIHNjYXR0ZXJDaGFydERhdGE6IFNjYXR0ZXIsIFxyXG4gICAgICBwaWVDaGFydERhdGE6IFBpZSwgXHJcbiAgICAgIGRvbnV0Q2hhcnREYXRhOiBEb3VnaG51dCBcclxuICAgIH1bc2VsZWN0ZWRDaGFydF0pXHJcbiAgKX1cclxuICA8ZGl2IGNsYXNzTmFtZT1cIm10LTQgZmxleFwiPlxyXG4gICAgPGlucHV0XHJcbiAgICAgIHR5cGU9XCJ0ZXh0XCJcclxuICAgICAgdmFsdWU9e2lucHV0VmFsdWV9XHJcbiAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0SW5wdXRWYWx1ZShlLnRhcmdldC52YWx1ZSl9XHJcbiAgICAgIGNsYXNzTmFtZT1cImJvcmRlciBwLTIgZmxleC1ncm93IG1yLTIgcm91bmRlZFwiXHJcbiAgICAgIHBsYWNlaG9sZGVyPVwiRW50ZXIgeW91ciB0ZXh0IGhlcmVcIlxyXG4gICAgLz5cclxuICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlU2VuZH0gY2xhc3NOYW1lPVwiYmctZ3JlZW4tNTAwIHRleHQtd2hpdGUgcC0yIHJvdW5kZWRcIj5cclxuICAgICAgU2VuZFxyXG4gICAgPC9idXR0b24+XHJcbiAgPC9kaXY+XHJcbiAgPGRpdiBjbGFzc05hbWU9XCJtdC00IHAtNCBib3JkZXIgYm9yZGVyLWdyYXktMzAwIHJvdW5kZWQgYmctd2hpdGVcIj5cclxuICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+SW5zaWdodHM8L2gzPlxyXG4gICAge2NvbWJpbmVkSW5zaWdodHMgPyAoXHJcbiAgICAgIDxvbCBjbGFzc05hbWU9XCJsaXN0LWRlY2ltYWwgbGlzdC1pbnNpZGUgdGV4dC1zbSB0ZXh0LWdyYXktNzAwIGJnLWdyYXktMTAwIHAtMiByb3VuZGVkIG1heC1oLTYwIG92ZXJmbG93LXktYXV0b1wiPlxyXG4gICAgICAgIHtjb21iaW5lZEluc2lnaHRzLnNwbGl0KCdcXG4nKS5tYXAoKGluc2lnaHQ6IHN0cmluZyB8IG51bWJlciB8IGJpZ2ludCB8IGJvb2xlYW4gfCBSZWFjdEVsZW1lbnQ8YW55LCBzdHJpbmcgfCBKU1hFbGVtZW50Q29uc3RydWN0b3I8YW55Pj4gfCBJdGVyYWJsZTxSZWFjdE5vZGU+IHwgUmVhY3RQb3J0YWwgfCBQcm9taXNlPEF3YWl0ZWRSZWFjdE5vZGU+IHwgbnVsbCB8IHVuZGVmaW5lZCwgaW5kZXg6IEtleSB8IG51bGwgfCB1bmRlZmluZWQpID0+IChcclxuICAgICAgICAgIDxsaSBrZXk9e2luZGV4fSBjbGFzc05hbWU9XCJweS0xXCI+e2luc2lnaHR9PC9saT5cclxuICAgICAgICApKX1cclxuICAgICAgPC9vbD5cclxuICAgICkgOiAoXHJcbiAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtZ3JheS01MDBcIj5ObyBpbnNpZ2h0cyBhdmFpbGFibGUuPC9wPlxyXG4gICAgKX1cclxuICA8L2Rpdj5cclxuPC9kaXY+XHJcblxyXG48c3R5bGUganN4PntgXHJcbiAgLm92ZXJmbG93LXgtYXV0byB7XHJcbiAgICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2g7XHJcbiAgICBzY3JvbGxiYXItd2lkdGg6IHRoaW47XHJcbiAgICBzY3JvbGxiYXItY29sb3I6ICM4ODggI2YxZjFmMTtcclxuICB9XHJcblxyXG4gIC5vdmVyZmxvdy14LWF1dG86Oi13ZWJraXQtc2Nyb2xsYmFyIHtcclxuICAgIGhlaWdodDogOHB4O1xyXG4gIH1cclxuXHJcbiAgLm92ZXJmbG93LXgtYXV0bzo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWIge1xyXG4gICAgYmFja2dyb3VuZDogIzg4ODtcclxuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcclxuICB9XHJcblxyXG4gIC5vdmVyZmxvdy14LWF1dG86Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrIHtcclxuICAgIGJhY2tncm91bmQ6ICNmMWYxZjE7XHJcbiAgfVxyXG5cclxuICBAbWVkaWEgKG1heC13aWR0aDogNzY4cHgpIHtcclxuICAgIC5vdmVyZmxvdy14LWF1dG8gPiBkaXYge1xyXG4gICAgICBtaW4td2lkdGg6IDQwMHB4O1xyXG4gICAgICBoZWlnaHQ6IDMwMHB4O1xyXG4gICAgfVxyXG4gIH1cclxuYH08L3N0eWxlPlxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufSJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZVJlZiIsIkJhciIsIkxpbmUiLCJEb3VnaG51dCIsIlBpZSIsIlNjYXR0ZXIiLCJDaGFydCIsIkNoYXJ0SlMiLCJDYXRlZ29yeVNjYWxlIiwiTGluZWFyU2NhbGUiLCJCYXJFbGVtZW50IiwiTGluZUVsZW1lbnQiLCJQb2ludEVsZW1lbnQiLCJBcmNFbGVtZW50IiwiVGl0bGUiLCJUb29sdGlwIiwiTGVnZW5kIiwiQnNVcGxvYWQiLCJ6b29tUGx1Z2luIiwicmVnaXN0ZXIiLCJEYXNoYm9hcmQiLCJjaGFydERhdGEiLCJzZXRDaGFydERhdGEiLCJzY2F0dGVyQ2hhcnREYXRhIiwicGllQ2hhcnREYXRhIiwiZG9udXRDaGFydERhdGEiLCJsaW5lQ2hhcnREYXRhIiwiYmFyQ2hhcnREYXRhIiwic2VsZWN0ZWRGaWxlIiwic2V0U2VsZWN0ZWRGaWxlIiwic2VsZWN0ZWRDaGFydCIsInNldFNlbGVjdGVkQ2hhcnQiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImNoYXJ0V2lkdGgiLCJzZXRDaGFydFdpZHRoIiwiaW5wdXRWYWx1ZSIsInNldElucHV0VmFsdWUiLCJzdG9yZWRQcm9jZXNzZWREYXRhIiwic2V0U3RvcmVkUHJvY2Vzc2VkRGF0YSIsImNvbWJpbmVkSW5zaWdodHMiLCJzZXRDb21iaW5lZEluc2lnaHRzIiwiY2hhcnRSZWYiLCJoYW5kbGVGaWxlQ2hhbmdlIiwiZXZlbnQiLCJ0YXJnZXQiLCJmaWxlcyIsImhhbmRsZVN1Ym1pdCIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJyZXN1bHQiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiYm9keSIsIm9rIiwiRXJyb3IiLCJqc29uIiwiZGF0YSIsInByb2Nlc3NlZERhdGEiLCJjb25zb2xlIiwibG9nIiwibGlnaHRDb2xvcnMiLCJnZW5lcmF0ZUNoYXJ0RGF0YSIsImNoYXJ0VHlwZSIsImNoYXJ0SW5mbyIsImxhYmVscyIsIk9iamVjdCIsImtleXMiLCJ2YWx1ZXMiLCJpbmNsdWRlcyIsImxlbmd0aCIsImRhdGFzZXRzIiwibGFiZWwiLCJiYWNrZ3JvdW5kQ29sb3IiLCJzbGljZSIsImJvcmRlckNvbG9yIiwidW5kZWZpbmVkIiwiZmlsbCIsIm1ldGEiLCJoZWFkZXIiLCJ2YWx1ZU5hbWUiLCJlcnJvciIsImhhbmRsZVNlbmQiLCJncmFwaERhdGEiLCJmaWx0ZXJlZFByb2Nlc3NlZERhdGEiLCJkYXRhT2JqZWN0IiwicmVkdWNlIiwib2JqIiwiaW5kZXgiLCJjaGFydFR5cGVNYXBwaW5nIiwic2VsZWN0ZWRDaGFydFR5cGUiLCJyZXF1ZXN0Qm9keSIsInF1ZXN0aW9uIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiaGVhZGVycyIsIkpTT04iLCJzdHJpbmdpZnkiLCJwcmV2Q2hhcnREYXRhIiwicmVuZGVyQ2hhcnQiLCJ0eXBlIiwiQ2hhcnRDb21wb25lbnQiLCJkYXRhTGVuZ3RoIiwibWF4VGlja3MiLCJNYXRoIiwiZmxvb3IiLCJkaXYiLCJjbGFzc05hbWUiLCJzdHlsZSIsIndpZHRoIiwibWluV2lkdGgiLCJtYXgiLCJoZWlnaHQiLCJvcHRpb25zIiwicmVzcG9uc2l2ZSIsIm1haW50YWluQXNwZWN0UmF0aW8iLCJzY2FsZXMiLCJ4IiwibWluIiwidGlja3MiLCJhdXRvU2tpcCIsIm1heFRpY2tzTGltaXQiLCJtYXhSb3RhdGlvbiIsIm1pblJvdGF0aW9uIiwicGFkZGluZyIsImZvbnQiLCJzaXplIiwiYWxpZ24iLCJjYWxsYmFjayIsIl92YWx1ZSIsImdyaWQiLCJkaXNwbGF5IiwieSIsImJlZ2luQXRaZXJvIiwicGx1Z2lucyIsImxlZ2VuZCIsInBvc2l0aW9uIiwidG9vbHRpcCIsImVuYWJsZWQiLCJpbnRlcnNlY3QiLCJtb2RlIiwibGF5b3V0IiwibGVmdCIsInJpZ2h0IiwiYm90dG9tIiwiaDIiLCJpbnB1dCIsIm9uQ2hhbmdlIiwiYnV0dG9uIiwib25DbGljayIsIm1hcCIsInJlcGxhY2UiLCJ2YWx1ZSIsImUiLCJwbGFjZWhvbGRlciIsImgzIiwib2wiLCJzcGxpdCIsImluc2lnaHQiLCJsaSIsInAiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/pages/Upload/Upload.tsx\n"));

/***/ })

});