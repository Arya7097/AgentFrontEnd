"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ag-charts-community";
exports.ids = ["vendor-chunks/ag-charts-community"];
exports.modules = {

/***/ "(ssr)/./node_modules/ag-charts-community/dist/package/main.esm.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/ag-charts-community/dist/package/main.esm.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AG_CHARTS_LOCALE_EN_US: () => (/* binding */ AG_CHARTS_LOCALE_EN_US),\n/* harmony export */   AgCharts: () => (/* binding */ AgCharts),\n/* harmony export */   AgChartsCommunityModule: () => (/* binding */ AgChartsCommunityModule),\n/* harmony export */   AgErrorBarSupportedSeriesTypes: () => (/* binding */ AgErrorBarSupportedSeriesTypes),\n/* harmony export */   AgTooltipPositionType: () => (/* binding */ AgTooltipPositionType),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   _ModuleSupport: () => (/* binding */ module_support_exports),\n/* harmony export */   _Scene: () => (/* binding */ integrated_charts_scene_exports),\n/* harmony export */   _Theme: () => (/* binding */ integrated_charts_theme_exports),\n/* harmony export */   _Util: () => (/* binding */ integrated_charts_util_exports),\n/* harmony export */   _Widget: () => (/* binding */ exports_exports),\n/* harmony export */   setupCommunityModules: () => (/* binding */ registerInbuiltModules),\n/* harmony export */   time: () => (/* binding */ time_exports)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp(target, key, result);\n  return result;\n};\n\n// packages/ag-charts-core/src/globals/logger.ts\nvar logger_exports = {};\n__export(logger_exports, {\n  error: () => error,\n  errorOnce: () => errorOnce,\n  log: () => log,\n  logGroup: () => logGroup,\n  reset: () => reset,\n  table: () => table,\n  warn: () => warn,\n  warnOnce: () => warnOnce\n});\nvar doOnceCache = /* @__PURE__ */ new Set();\nfunction log(...logContent) {\n  console.log(...logContent);\n}\nfunction warn(message, ...logContent) {\n  console.warn(`AG Charts - ${message}`, ...logContent);\n}\nfunction error(message, ...logContent) {\n  if (typeof message === \"object\") {\n    console.error(`AG Charts error`, message, ...logContent);\n  } else {\n    console.error(`AG Charts - ${message}`, ...logContent);\n  }\n}\nfunction table(...logContent) {\n  console.table(...logContent);\n}\nfunction warnOnce(message, ...logContent) {\n  const cacheKey = `Logger.warn: ${message}`;\n  if (doOnceCache.has(cacheKey))\n    return;\n  warn(message, ...logContent);\n  doOnceCache.add(cacheKey);\n}\nfunction errorOnce(message, ...logContent) {\n  const cacheKey = `Logger.error: ${message}`;\n  if (doOnceCache.has(cacheKey))\n    return;\n  error(message, ...logContent);\n  doOnceCache.add(cacheKey);\n}\nfunction reset() {\n  doOnceCache.clear();\n}\nfunction logGroup(name, cb) {\n  console.groupCollapsed(name);\n  try {\n    return cb();\n  } finally {\n    console.groupEnd();\n  }\n}\n\n// packages/ag-charts-core/src/globals/moduleRegistry.ts\nvar ModuleRegistry = class {\n  static [Symbol.iterator]() {\n    return this.registeredModules.values();\n  }\n  static register(definition) {\n    const existingDefinition = this.registeredModules.get(definition.name);\n    if (existingDefinition && (existingDefinition.enterprise || !definition.enterprise)) {\n      throw new Error(`AG Charts - Module '${definition.name}' already registered`);\n    }\n    this.registeredModules.set(definition.name, definition);\n  }\n  static registerMany(definitions) {\n    for (const definition of definitions) {\n      this.register(definition);\n    }\n  }\n  static reset() {\n    this.registeredModules.clear();\n  }\n  static detectChartDefinition(options) {\n    return this.detectDefinition(\"chart\" /* Chart */, options);\n  }\n  static detectSeriesDefinition(options) {\n    return this.detectDefinition(\"series\" /* Series */, options);\n  }\n  static detectDefinition(moduleType, options) {\n    for (const definition of this.registeredModules.values()) {\n      if (definition.type === moduleType && definition.detect(options)) {\n        return definition;\n      }\n    }\n    throw new Error(\n      `AG Charts - Unknown ${moduleType} type; Check options are correctly structured and series types are specified`\n    );\n  }\n};\nModuleRegistry.registeredModules = /* @__PURE__ */ new Map();\n\n// packages/ag-charts-core/src/classes/eventEmitter.ts\nvar EventEmitter = class {\n  constructor() {\n    this.events = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Registers an event listener.\n   * @param eventName The event name to listen for.\n   * @param listener The callback to be invoked on the event.\n   * @returns A function to unregister the listener.\n   */\n  on(eventName, listener) {\n    if (!this.events.has(eventName)) {\n      this.events.set(eventName, /* @__PURE__ */ new Set());\n    }\n    this.events.get(eventName)?.add(listener);\n    return () => this.off(eventName, listener);\n  }\n  /**\n   * Unregisters an event listener.\n   * @param eventName The event name to stop listening for.\n   * @param listener The callback to be removed.\n   */\n  off(eventName, listener) {\n    const eventListeners = this.events.get(eventName);\n    if (eventListeners) {\n      eventListeners.delete(listener);\n      if (eventListeners.size === 0) {\n        this.events.delete(eventName);\n      }\n    }\n  }\n  /**\n   * Emits an event to all registered listeners.\n   * @param eventName The name of the event to emit.\n   * @param event The event payload.\n   */\n  emit(eventName, event) {\n    this.events.get(eventName)?.forEach((callback2) => callback2(event));\n  }\n  /**\n   * Clears all listeners for a specific event or all events if no event name is provided.\n   * @param eventName (Optional) The name of the event to clear listeners for. If not provided, all listeners for all events are cleared.\n   */\n  clear(eventName) {\n    if (eventName) {\n      this.events.delete(eventName);\n    } else {\n      this.events.clear();\n    }\n  }\n};\n\n// packages/ag-charts-core/src/utils/arrays.ts\nfunction toArray(value) {\n  if (typeof value === \"undefined\") {\n    return [];\n  }\n  return Array.isArray(value) ? value : [value];\n}\nfunction unique(array2) {\n  return Array.from(new Set(array2));\n}\nfunction groupBy(array2, iteratee) {\n  return array2.reduce((result, item) => {\n    const groupKey = iteratee(item);\n    result[groupKey] ?? (result[groupKey] = []);\n    result[groupKey].push(item);\n    return result;\n  }, {});\n}\nfunction arraysEqual(a, b) {\n  if (a == null || b == null || a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (Array.isArray(a[i]) && Array.isArray(b[i])) {\n      if (!arraysEqual(a[i], b[i])) {\n        return false;\n      }\n    } else if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction circularSliceArray(data, size, offset4 = 0) {\n  if (data.length === 0) {\n    return [];\n  }\n  const result = [];\n  for (let i = 0; i < size; i++) {\n    result.push(data.at((i + offset4) % data.length));\n  }\n  return result;\n}\nfunction sortBasedOnArray(baseArray, orderArray) {\n  const orderMap = /* @__PURE__ */ new Map();\n  orderArray.forEach((item, index) => {\n    orderMap.set(item, index);\n  });\n  return baseArray.sort((a, b) => {\n    const indexA = orderMap.get(a) ?? Infinity;\n    const indexB = orderMap.get(b) ?? Infinity;\n    return indexA - indexB;\n  });\n}\n\n// packages/ag-charts-core/src/utils/binarySearch.ts\nfunction findMaxIndex(min, max, iteratee) {\n  if (min > max)\n    return;\n  let found;\n  while (max >= min) {\n    const index = Math.floor((max + min) / 2);\n    const value = iteratee(index);\n    if (value) {\n      found = index;\n      min = index + 1;\n    } else {\n      max = index - 1;\n    }\n  }\n  return found;\n}\nfunction findMinIndex(min, max, iteratee) {\n  if (min > max)\n    return;\n  let found;\n  while (max >= min) {\n    const index = Math.floor((max + min) / 2);\n    const value = iteratee(index);\n    if (value) {\n      found = index;\n      max = index - 1;\n    } else {\n      min = index + 1;\n    }\n  }\n  return found;\n}\nfunction findMinValue(min, max, iteratee) {\n  if (min > max)\n    return;\n  let found;\n  while (max >= min) {\n    const index = Math.floor((max + min) / 2);\n    const value = iteratee(index);\n    if (value == null) {\n      min = index + 1;\n    } else {\n      found = value;\n      max = index - 1;\n    }\n  }\n  return found;\n}\n\n// packages/ag-charts-core/src/utils/diff.ts\nfunction diffArrays(previous, current) {\n  const size = Math.max(previous.length, current.length);\n  const added = /* @__PURE__ */ new Set();\n  const removed = /* @__PURE__ */ new Set();\n  for (let i = 0; i < size; i++) {\n    const prev = previous[i];\n    const curr = current[i];\n    if (prev === curr)\n      continue;\n    if (removed.has(curr)) {\n      removed.delete(curr);\n    } else if (curr) {\n      added.add(curr);\n    }\n    if (added.has(prev)) {\n      added.delete(prev);\n    } else if (prev) {\n      removed.add(prev);\n    }\n  }\n  return { changed: added.size > 0 || removed.size > 0, added, removed };\n}\n\n// packages/ag-charts-core/src/utils/functions.ts\nfunction throttle(callback2, waitMs, options) {\n  const { leading = true, trailing = true } = options ?? {};\n  let timerId;\n  let lastArgs;\n  let shouldWait = false;\n  function timeoutHandler() {\n    if (trailing && lastArgs) {\n      timerId = setTimeout(timeoutHandler, waitMs);\n      callback2(...lastArgs);\n    } else {\n      shouldWait = false;\n    }\n    lastArgs = null;\n  }\n  function throttleCallback(...args) {\n    if (shouldWait) {\n      lastArgs = args;\n    } else {\n      shouldWait = true;\n      timerId = setTimeout(timeoutHandler, waitMs);\n      if (leading) {\n        callback2(...args);\n      } else {\n        lastArgs = args;\n      }\n    }\n  }\n  return Object.assign(throttleCallback, {\n    cancel() {\n      clearTimeout(timerId);\n      shouldWait = false;\n      lastArgs = null;\n    }\n  });\n}\n\n// packages/ag-charts-core/src/utils/iterators.ts\nfunction* iterate(...iterators) {\n  for (const iterator of iterators) {\n    yield* iterator;\n  }\n}\nfunction toIterable(value) {\n  return value != null && typeof value === \"object\" && Symbol.iterator in value ? value : [value];\n}\nfunction first(iterable) {\n  for (const value of iterable) {\n    return value;\n  }\n  throw new Error(\"AG Charts - no first() value found\");\n}\n\n// packages/ag-charts-core/src/utils/strings.ts\nfunction joinFormatted(values, conjunction = \"and\", format = String, maxItems = Infinity) {\n  if (values.length === 1) {\n    return format(values[0]);\n  }\n  values = values.map(format);\n  const lastValue = values.pop();\n  if (values.length >= maxItems) {\n    const remainingCount = values.length - (maxItems - 1);\n    return `${values.slice(0, maxItems - 1).join(\", \")}, and ${remainingCount} more ${conjunction} ${lastValue}`;\n  }\n  return `${values.join(\", \")} ${conjunction} ${lastValue}`;\n}\nfunction stringifyValue(value, maxLength = Infinity) {\n  switch (typeof value) {\n    case \"undefined\":\n      return \"undefined\";\n    case \"number\":\n      if (isNaN(value)) {\n        return \"NaN\";\n      } else if (value === Infinity) {\n        return \"Infinity\";\n      } else if (value === -Infinity) {\n        return \"-Infinity\";\n      }\n    default:\n      value = JSON.stringify(value);\n      if (value.length > maxLength) {\n        return `${value.slice(0, maxLength)}... (+${value.length - maxLength} characters)`;\n      }\n      return value;\n  }\n}\nfunction countLines(text2) {\n  let count = 1;\n  for (let i = 0; i < text2.length; i++) {\n    if (text2.charCodeAt(i) === 10) {\n      count++;\n    }\n  }\n  return count;\n}\n\n// packages/ag-charts-core/src/utils/typeGuards.ts\nfunction isDefined(val) {\n  return val != null;\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isBoolean(value) {\n  return typeof value === \"boolean\";\n}\nfunction isDate(value) {\n  return value instanceof Date;\n}\nfunction isValidDate(value) {\n  return isDate(value) && !isNaN(Number(value));\n}\nfunction isRegExp(value) {\n  return value instanceof RegExp;\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null && !isArray(value);\n}\nfunction isPlainObject(value) {\n  return typeof value === \"object\" && value !== null && Object.getPrototypeOf(value) === Object.prototype;\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\nfunction isFiniteNumber(value) {\n  return Number.isFinite(value);\n}\nfunction isHtmlElement(value) {\n  return typeof window !== \"undefined\" && value instanceof HTMLElement;\n}\nfunction isEnumValue(enumObject, enumValue) {\n  return Object.values(enumObject).includes(enumValue);\n}\nfunction isSymbol(value) {\n  return typeof value === \"symbol\";\n}\n\n// packages/ag-charts-core/src/utils/validation.ts\nvar descriptionSymbol = Symbol(\"description\");\nvar requiredSymbol = Symbol(\"required\");\nfunction validate(options, optionsDefs, path = \"\") {\n  if (!isObject(options)) {\n    return {\n      valid: null,\n      errors: [{ path, value: options, message: validateMessage(path, options, \"an object\") }]\n    };\n  }\n  const optionsKeys = new Set(Object.keys(options));\n  const errors = [];\n  const valid = {};\n  function extendPath(key) {\n    if (isArray(optionsDefs)) {\n      return `${path}[${key}]`;\n    }\n    return path ? `${path}.${key}` : key;\n  }\n  for (const [key, validatorOrDefs] of Object.entries(optionsDefs)) {\n    optionsKeys.delete(key);\n    const value = options[key];\n    if (!validatorOrDefs[requiredSymbol] && typeof value === \"undefined\")\n      continue;\n    if (isFunction(validatorOrDefs)) {\n      if (validatorOrDefs(value, options)) {\n        valid[key] = value;\n      } else {\n        errors.push({ key, path, value, message: validateMessage(extendPath(key), value, validatorOrDefs) });\n      }\n    } else {\n      const nestedResult = validate(value, validatorOrDefs, extendPath(key));\n      valid[key] = nestedResult.valid;\n      errors.push(...nestedResult.errors);\n    }\n  }\n  for (const key of optionsKeys) {\n    errors.push({\n      key,\n      path,\n      unknown: true,\n      message: `Unknown option \\`${extendPath(key)}\\`, ignoring.`\n    });\n  }\n  return { valid, errors };\n}\nfunction validateMessage(path, value, validatorOrDefs) {\n  const description = isString(validatorOrDefs) ? validatorOrDefs : validatorOrDefs[descriptionSymbol];\n  const expecting = description ? `; expecting ${description}` : \"\";\n  const prefix = path ? `Option \\`${path}\\`` : \"Value\";\n  return `${prefix} cannot be set to \\`${stringifyValue(value)}\\`${expecting}, ignoring.`;\n}\nfunction attachDescription(validator, description) {\n  return Object.assign((value, context) => validator(value, context), {\n    [descriptionSymbol]: description\n  });\n}\nvar and = (...validators) => attachDescription(\n  (value, context) => validators.every((validator) => validator(value, context)),\n  validators.map((v) => v[descriptionSymbol]).filter(Boolean).join(\" and \")\n);\nvar or = (...validators) => attachDescription(\n  (value, context) => validators.some((validator) => validator(value, context)),\n  validators.map((v) => v[descriptionSymbol]).filter(Boolean).join(\" or \")\n);\nvar array = attachDescription(isArray, \"an array\");\nvar boolean = attachDescription(isBoolean, \"a boolean\");\nvar callback = attachDescription(isFunction, \"a function\");\nvar number = attachDescription(isFiniteNumber, \"a number\");\nvar object = attachDescription(isObject, \"an object\");\nvar string = attachDescription(isString, \"a string\");\nvar date = attachDescription(\n  (value) => isDate(value) || (isFiniteNumber(value) || isString(value)) && isValidDate(new Date(value)),\n  \"a date\"\n);\nvar numberMin = (min, inclusive = true) => attachDescription(\n  (value) => isFiniteNumber(value) && (value > min || inclusive && value === min),\n  `a number greater than ${inclusive ? \"or equal to \" : \"\"}${min}`\n);\nvar numberRange = (min, max) => attachDescription(\n  (value) => isFiniteNumber(value) && value >= min && value <= max,\n  `a number between ${min} and ${max} inclusive`\n);\nvar positiveNumber = numberMin(0);\nvar ratio = numberRange(0, 1);\nvar isComparable = (value) => isFiniteNumber(value) || isValidDate(value);\nvar lessThan = (otherField) => attachDescription(\n  (value, context) => !isComparable(value) || !isComparable(context[otherField]) || value < context[otherField],\n  `to be less than ${otherField}`\n);\nfunction union(...allowed) {\n  if (isObject(allowed[0])) {\n    allowed = Object.values(allowed[0]);\n  }\n  const keywords = joinFormatted(allowed, \"or\", (value) => `'${value}'`, 6);\n  return attachDescription((value) => allowed.includes(value), `a keyword such as ${keywords}`);\n}\nvar arrayOf = (validator, description) => attachDescription(\n  (value, context) => isArray(value) && value.every((v) => validator(v, context)),\n  description ?? `${validator[descriptionSymbol]} array`\n);\n\n// packages/ag-charts-community/src/motion/fromToMotion.ts\nvar fromToMotion_exports = {};\n__export(fromToMotion_exports, {\n  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,\n  fromToMotion: () => fromToMotion,\n  staticFromToMotion: () => staticFromToMotion\n});\n\n// packages/ag-charts-community/src/core/globalsProxy.ts\nvar verifiedGlobals = {};\nif (typeof window !== \"undefined\") {\n  verifiedGlobals.window = window;\n} else if (typeof global !== \"undefined\") {\n  verifiedGlobals.window = global.window;\n}\nif (typeof document !== \"undefined\") {\n  verifiedGlobals.document = document;\n} else if (typeof global !== \"undefined\") {\n  verifiedGlobals.document = global.document;\n}\nfunction getDocument(propertyName) {\n  return propertyName ? verifiedGlobals.document?.[propertyName] : verifiedGlobals.document;\n}\nfunction getWindow(propertyName) {\n  return propertyName ? verifiedGlobals.window?.[propertyName] : verifiedGlobals.window;\n}\nfunction setDocument(document2) {\n  verifiedGlobals.document = document2;\n}\nfunction setWindow(window2) {\n  verifiedGlobals.window = window2;\n}\n\n// packages/ag-charts-community/src/core/domElements.ts\nfunction createElement(tagName, className, style) {\n  const element2 = getDocument().createElement(tagName);\n  if (typeof className === \"object\") {\n    style = className;\n    className = void 0;\n  }\n  if (className) {\n    for (const name of className.split(\" \")) {\n      element2.classList.add(name);\n    }\n  }\n  if (style) {\n    Object.assign(element2.style, style);\n  }\n  return element2;\n}\nfunction createSvgElement(elementName) {\n  return getDocument().createElementNS(\"http://www.w3.org/2000/svg\", elementName);\n}\n\n// packages/ag-charts-community/src/core/domDownload.ts\nfunction downloadUrl(dataUrl, fileName) {\n  const body = getDocument(\"body\");\n  const element2 = createElement(\"a\", { display: \"none\" });\n  element2.href = dataUrl;\n  element2.download = fileName;\n  body.appendChild(element2);\n  element2.click();\n  setTimeout(() => body.removeChild(element2));\n}\n\n// packages/ag-charts-community/src/util/id.ts\nvar ID_MAP = /* @__PURE__ */ new Map();\nfunction resetIds() {\n  ID_MAP.clear();\n}\nfunction createId(instance) {\n  const constructor = instance.constructor;\n  const className = Object.hasOwn(constructor, \"className\") ? constructor.className : constructor.name;\n  if (!className) {\n    throw new Error(`The ${constructor} is missing the 'className' property.`);\n  }\n  const nextId = (ID_MAP.get(className) ?? 0) + 1;\n  ID_MAP.set(className, nextId);\n  return `${className}-${nextId}`;\n}\nfunction generateUUID() {\n  return crypto.randomUUID?.() ?? generateUUIDv4();\n}\nfunction generateUUIDv4() {\n  const uuidArray = new Uint8Array(16);\n  crypto.getRandomValues(uuidArray);\n  uuidArray[6] = uuidArray[6] & 15 | 64;\n  uuidArray[8] = uuidArray[8] & 63 | 128;\n  let uuid = \"\";\n  for (let i = 0; i < uuidArray.length; i++) {\n    if (i === 4 || i === 6 || i === 8 || i === 10) {\n      uuid += \"-\";\n    }\n    uuid += uuidArray[i].toString(16).padStart(2, \"0\");\n  }\n  return uuid;\n}\n\n// packages/ag-charts-community/src/util/bboxinterface.ts\nvar BBoxValues = { containsPoint, isEmpty, normalize };\nfunction containsPoint(bbox, x, y) {\n  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;\n}\nfunction isEmpty(bbox) {\n  return bbox == null || bbox.height === 0 || bbox.width === 0 || isNaN(bbox.height) || isNaN(bbox.width);\n}\nfunction normalize(bbox) {\n  let { x, y, width: width2, height: height2 } = bbox;\n  if ((width2 == null || width2 > 0) && (height2 == null || height2 > 0))\n    return bbox;\n  if (x != null && width2 != null && width2 < 0) {\n    width2 = -width2;\n    x = x - width2;\n  }\n  if (y != null && height2 != null && height2 < 0) {\n    height2 = -height2;\n    y = y - height2;\n  }\n  return { x, y, width: width2, height: height2 };\n}\n\n// packages/ag-charts-community/src/util/interpolating.ts\nvar interpolate = Symbol(\"interpolate\");\nvar isInterpolating = (x) => x[interpolate] != null;\n\n// packages/ag-charts-community/src/util/nearest.ts\nfunction nearestSquared(x, y, objects, maxDistanceSquared = Infinity) {\n  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };\n  for (const obj of objects) {\n    const thisDistance = obj.distanceSquared(x, y);\n    if (thisDistance === 0) {\n      return { nearest: obj, distanceSquared: 0 };\n    } else if (thisDistance < result.distanceSquared) {\n      result.nearest = obj;\n      result.distanceSquared = thisDistance;\n    }\n  }\n  return result;\n}\nfunction nearestSquaredInContainer(x, y, container, maxDistanceSquared = Infinity) {\n  const { x: tx = x, y: ty = y } = container.transformPoint?.(x, y) ?? {};\n  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };\n  for (const child of container.children) {\n    const { nearest, distanceSquared: distanceSquared2 } = child.nearestSquared(tx, ty, result.distanceSquared);\n    if (distanceSquared2 === 0) {\n      return { nearest, distanceSquared: distanceSquared2 };\n    } else if (distanceSquared2 < result.distanceSquared) {\n      result.nearest = nearest;\n      result.distanceSquared = distanceSquared2;\n    }\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/util/number.ts\nfunction clamp(min, value, max) {\n  return Math.min(max, Math.max(min, value));\n}\nfunction clampArray(value, array2) {\n  const [min, max] = findMinMax(array2);\n  return clamp(min, value, max);\n}\nfunction findMinMax(array2) {\n  if (array2.length === 0)\n    return [];\n  const result = [Infinity, -Infinity];\n  for (const val of array2) {\n    if (val < result[0])\n      result[0] = val;\n    if (val > result[1])\n      result[1] = val;\n  }\n  return result;\n}\nfunction findRangeExtent(array2) {\n  const [min, max] = findMinMax(array2);\n  return max - min;\n}\nfunction inRange(value, range3, epsilon2 = 1e-10) {\n  return value >= range3[0] - epsilon2 && value <= range3[1] + epsilon2;\n}\nfunction isNumberEqual(a, b, epsilon2 = 1e-10) {\n  return a === b || Math.abs(a - b) < epsilon2;\n}\nfunction isNegative(value) {\n  return Math.sign(value) === -1 || Object.is(value, -0);\n}\nfunction isInteger(value) {\n  return value % 1 === 0;\n}\nfunction round(value, decimals = 2) {\n  const base = 10 ** decimals;\n  return Math.round(value * base) / base;\n}\nfunction mod(n, m) {\n  return Math.floor(n % m + (n < 0 ? m : 0));\n}\nfunction countFractionDigits(value) {\n  if (Math.floor(value) === value)\n    return 0;\n  let valueString = String(value);\n  let exponent = 0;\n  if (value < 1e-6 || value >= 1e21) {\n    let exponentString;\n    [valueString, exponentString] = valueString.split(\"e\");\n    if (exponentString != null) {\n      exponent = Number(exponentString);\n    }\n  }\n  const decimalPlaces2 = valueString.split(\".\")[1]?.length ?? 0;\n  return Math.max(decimalPlaces2 - exponent, 0);\n}\n\n// packages/ag-charts-community/src/scene/bbox.ts\nvar _BBox = class _BBox {\n  constructor(x, y, width2, height2) {\n    this.x = x;\n    this.y = y;\n    this.width = width2;\n    this.height = height2;\n  }\n  static fromDOMRect({ x, y, width: width2, height: height2 }) {\n    return new _BBox(x, y, width2, height2);\n  }\n  static merge(boxes) {\n    let left = Infinity;\n    let top = Infinity;\n    let right = -Infinity;\n    let bottom = -Infinity;\n    for (const box of boxes) {\n      if (box.x < left) {\n        left = box.x;\n      }\n      if (box.y < top) {\n        top = box.y;\n      }\n      if (box.x + box.width > right) {\n        right = box.x + box.width;\n      }\n      if (box.y + box.height > bottom) {\n        bottom = box.y + box.height;\n      }\n    }\n    return new _BBox(left, top, right - left, bottom - top);\n  }\n  static nearestBox(x, y, boxes) {\n    return nearestSquared(x, y, boxes);\n  }\n  toDOMRect() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height,\n      top: this.y,\n      left: this.x,\n      right: this.x + this.width,\n      bottom: this.y + this.height,\n      toJSON() {\n        return {};\n      }\n    };\n  }\n  clone() {\n    const { x, y, width: width2, height: height2 } = this;\n    return new _BBox(x, y, width2, height2);\n  }\n  equals(other) {\n    return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;\n  }\n  containsPoint(x, y) {\n    return BBoxValues.containsPoint(this, x, y);\n  }\n  intersection(other) {\n    if (!this.collidesBBox(other))\n      return;\n    const newX1 = clamp(other.x, this.x, other.x + other.width);\n    const newY1 = clamp(other.y, this.y, other.y + other.height);\n    const newX2 = clamp(other.x, this.x + this.width, other.x + other.width);\n    const newY2 = clamp(other.y, this.y + this.height, other.y + other.height);\n    return new _BBox(newX1, newY1, newX2 - newX1, newY2 - newY1);\n  }\n  collidesBBox(other) {\n    return this.x < other.x + other.width && this.x + this.width > other.x && this.y < other.y + other.height && this.y + this.height > other.y;\n  }\n  computeCenter() {\n    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };\n  }\n  isFinite() {\n    return Number.isFinite(this.x) && Number.isFinite(this.y) && Number.isFinite(this.width) && Number.isFinite(this.height);\n  }\n  distanceSquared(x, y) {\n    if (this.containsPoint(x, y)) {\n      return 0;\n    }\n    const dx = x - clamp(this.x, x, this.x + this.width);\n    const dy = y - clamp(this.y, y, this.y + this.height);\n    return dx * dx + dy * dy;\n  }\n  shrink(amount, position) {\n    if (typeof amount === \"number\") {\n      this.applyMargin(amount, position);\n    } else {\n      for (const [key, value] of Object.entries(amount)) {\n        this.applyMargin(value, key);\n      }\n    }\n    if (this.width < 0) {\n      this.width = 0;\n    }\n    if (this.height < 0) {\n      this.height = 0;\n    }\n    return this;\n  }\n  grow(amount, position) {\n    if (typeof amount === \"number\") {\n      this.applyMargin(-amount, position);\n    } else {\n      for (const [key, value] of Object.entries(amount)) {\n        this.applyMargin(-value, key);\n      }\n    }\n    return this;\n  }\n  applyMargin(value, position) {\n    switch (position) {\n      case \"top\":\n        this.y += value;\n      case \"bottom\":\n        this.height -= value;\n        break;\n      case \"left\":\n        this.x += value;\n      case \"right\":\n        this.width -= value;\n        break;\n      case \"vertical\":\n        this.y += value;\n        this.height -= value * 2;\n        break;\n      case \"horizontal\":\n        this.x += value;\n        this.width -= value * 2;\n        break;\n      case void 0:\n        this.x += value;\n        this.y += value;\n        this.width -= value * 2;\n        this.height -= value * 2;\n        break;\n    }\n  }\n  translate(x, y) {\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n  [interpolate](other, d) {\n    return new _BBox(\n      this.x * (1 - d) + other.x * d,\n      this.y * (1 - d) + other.y * d,\n      this.width * (1 - d) + other.width * d,\n      this.height * (1 - d) + other.height * d\n    );\n  }\n};\n_BBox.zero = Object.freeze(new _BBox(0, 0, 0, 0));\n_BBox.NaN = Object.freeze(new _BBox(NaN, NaN, NaN, NaN));\nvar BBox = _BBox;\n\n// packages/ag-charts-community/src/scene/changeDetectable.ts\nfunction SceneChangeDetection(opts) {\n  return function(target, key) {\n    const privateKey = `__${key}`;\n    if (target[key]) {\n      return;\n    }\n    prepareGetSet(target, key, privateKey, opts);\n  };\n}\nfunction prepareGetSet(target, key, privateKey, opts) {\n  const { type = \"normal\", changeCb, convertor, checkDirtyOnAssignment = false } = opts ?? {};\n  const requiredOpts = { type, changeCb, checkDirtyOnAssignment, convertor };\n  let setter;\n  switch (type) {\n    case \"normal\":\n      setter = buildNormalSetter(privateKey, requiredOpts);\n      break;\n    case \"transform\":\n      setter = buildTransformSetter(privateKey);\n      break;\n    case \"path\":\n      setter = buildPathSetter(privateKey);\n      break;\n  }\n  setter = buildCheckDirtyChain(\n    buildChangeCallbackChain(buildConvertorChain(setter, requiredOpts), requiredOpts),\n    requiredOpts\n  );\n  const getter = function() {\n    return this[privateKey];\n  };\n  Object.defineProperty(target, key, {\n    set: setter,\n    get: getter,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction buildConvertorChain(setterFn, opts) {\n  const { convertor } = opts;\n  if (convertor) {\n    return function(value) {\n      setterFn.call(this, convertor(value));\n    };\n  }\n  return setterFn;\n}\nvar NO_CHANGE = Symbol(\"no-change\");\nfunction buildChangeCallbackChain(setterFn, opts) {\n  const { changeCb } = opts;\n  if (changeCb) {\n    return function(value) {\n      const change = setterFn.call(this, value);\n      if (change !== NO_CHANGE) {\n        changeCb.call(this, this);\n      }\n      return change;\n    };\n  }\n  return setterFn;\n}\nfunction buildCheckDirtyChain(setterFn, opts) {\n  const { checkDirtyOnAssignment } = opts;\n  if (checkDirtyOnAssignment) {\n    return function(value) {\n      const change = setterFn.call(this, value);\n      if (value?._dirty === true) {\n        this.markDirty();\n      }\n      return change;\n    };\n  }\n  return setterFn;\n}\nfunction buildNormalSetter(privateKey, opts) {\n  const { changeCb } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      this.markDirty();\n      changeCb?.(this);\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildTransformSetter(privateKey) {\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      this.markDirtyTransform();\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildPathSetter(privateKey) {\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      if (!this._dirtyPath) {\n        this._dirtyPath = true;\n        this.markDirty();\n      }\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\n\n// packages/ag-charts-community/src/scene/node.ts\nvar PointerEvents = /* @__PURE__ */ ((PointerEvents2) => {\n  PointerEvents2[PointerEvents2[\"All\"] = 0] = \"All\";\n  PointerEvents2[PointerEvents2[\"None\"] = 1] = \"None\";\n  return PointerEvents2;\n})(PointerEvents || {});\nvar _Node = class _Node {\n  constructor(options) {\n    /** Unique number to allow creation order to be easily determined. */\n    this.serialNumber = _Node._nextSerialNumber++;\n    this.childNodeCounts = { groups: 0, nonGroups: 0, thisComplexity: 0, complexity: 0 };\n    /** Unique node ID in the form `ClassName-NaturalNumber`. */\n    this.id = createId(this);\n    this.pointerEvents = 0 /* All */;\n    this._dirty = true;\n    this.dirtyZIndex = false;\n    /**\n     * To simplify the type system (especially in Selections) we don't have the `Parent` node\n     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\n     * But we still need to distinguish regular leaf nodes from container leafs somehow.\n     */\n    this.isContainerNode = false;\n    this.visible = true;\n    this.zIndex = 0;\n    this.name = options?.name;\n    this.tag = options?.tag ?? NaN;\n    this.zIndex = options?.zIndex ?? 0;\n  }\n  static toSVG(node, width2, height2) {\n    const svg = node?.toSVG();\n    if (svg == null || !svg.elements.length && !svg.defs?.length)\n      return;\n    const root = createSvgElement(\"svg\");\n    root.setAttribute(\"width\", String(width2));\n    root.setAttribute(\"height\", String(height2));\n    root.setAttribute(\"viewBox\", `0 0 ${width2} ${height2}`);\n    if (svg.defs?.length) {\n      const defs = createSvgElement(\"defs\");\n      defs.append(...svg.defs);\n      root.append(defs);\n    }\n    root.append(...svg.elements);\n    return root.outerHTML;\n  }\n  static *extractBBoxes(nodes, skipInvisible) {\n    for (const n of nodes) {\n      if (!skipInvisible || n.visible && !n.transitionOut) {\n        const bbox = n.getBBox();\n        if (bbox)\n          yield bbox;\n      }\n    }\n  }\n  /**\n   * Some arbitrary data bound to the node.\n   */\n  get datum() {\n    return this._datum ?? this.parentNode?.datum;\n  }\n  set datum(datum) {\n    if (this._datum !== datum) {\n      this._previousDatum = this._datum;\n      this._datum = datum;\n    }\n  }\n  get previousDatum() {\n    return this._previousDatum;\n  }\n  get layerManager() {\n    return this._layerManager;\n  }\n  get dirty() {\n    return this._dirty;\n  }\n  /** Perform any pre-rendering initialization. */\n  preRender(renderCtx, thisComplexity = 1) {\n    this.childNodeCounts.groups = 0;\n    this.childNodeCounts.nonGroups = 1;\n    this.childNodeCounts.complexity = thisComplexity;\n    this.childNodeCounts.thisComplexity = thisComplexity;\n    for (const child of this.children()) {\n      const childCounts = child.preRender(renderCtx);\n      this.childNodeCounts.groups += childCounts.groups;\n      this.childNodeCounts.nonGroups += childCounts.nonGroups;\n      this.childNodeCounts.complexity += childCounts.complexity;\n    }\n    return this.childNodeCounts;\n  }\n  render(renderCtx) {\n    const { stats } = renderCtx;\n    this._dirty = false;\n    if (renderCtx.debugNodeSearch) {\n      const idOrName = this.name ?? this.id;\n      if (renderCtx.debugNodeSearch.some((v) => typeof v === \"string\" ? v === idOrName : v.test(idOrName))) {\n        renderCtx.debugNodes[this.name ?? this.id] = this;\n      }\n    }\n    if (stats) {\n      stats.nodesRendered++;\n      stats.opsPerformed += this.childNodeCounts.thisComplexity;\n    }\n  }\n  _setLayerManager(value) {\n    this._layerManager = value;\n    this._debug = value?.debug;\n    for (const child of this.children()) {\n      child._setLayerManager(value);\n    }\n  }\n  sortChildren(compareFn) {\n    this.dirtyZIndex = false;\n    if (!this.childNodes)\n      return;\n    const sortedChildren = [...this.childNodes].sort(compareFn);\n    this.childNodes.clear();\n    for (const child of sortedChildren) {\n      this.childNodes.add(child);\n    }\n  }\n  *traverseUp(includeSelf) {\n    let node = this;\n    if (includeSelf) {\n      yield node;\n    }\n    while (node = node.parentNode) {\n      yield node;\n    }\n  }\n  *children() {\n    if (!this.childNodes)\n      return;\n    for (const child of this.childNodes) {\n      yield child;\n    }\n  }\n  *descendants() {\n    for (const child of this.children()) {\n      yield child;\n      yield* child.descendants();\n    }\n  }\n  /**\n   * Checks if the node is a leaf (has no children).\n   */\n  isLeaf() {\n    return !this.childNodes?.size;\n  }\n  /**\n   * Checks if the node is the root (has no parent).\n   */\n  isRoot() {\n    return !this.parentNode;\n  }\n  /**\n   * Appends one or more new node instances to this parent.\n   * If one needs to:\n   * - move a child to the end of the list of children\n   * - move a child from one parent to another (including parents in other scenes)\n   * one should use the {@link insertBefore} method instead.\n   * @param nodes A node or nodes to append.\n   */\n  append(nodes) {\n    this.childNodes ?? (this.childNodes = /* @__PURE__ */ new Set());\n    for (const node of toIterable(nodes)) {\n      node.parentNode?.removeChild(node);\n      this.childNodes.add(node);\n      node.parentNode = this;\n      node._setLayerManager(this.layerManager);\n    }\n    this.invalidateCachedBBox();\n    this.dirtyZIndex = true;\n    this.markDirty();\n  }\n  appendChild(node) {\n    this.append(node);\n    return node;\n  }\n  removeChild(node) {\n    if (!this.childNodes?.delete(node)) {\n      return false;\n    }\n    delete node.parentNode;\n    node._setLayerManager();\n    this.invalidateCachedBBox();\n    this.dirtyZIndex = true;\n    this.markDirty();\n    return true;\n  }\n  remove() {\n    return this.parentNode?.removeChild(this) ?? false;\n  }\n  clear() {\n    for (const child of this.children()) {\n      delete child.parentNode;\n      child._setLayerManager();\n    }\n    this.childNodes?.clear();\n    this.invalidateCachedBBox();\n  }\n  destroy() {\n    this.parentNode?.removeChild(this);\n  }\n  setProperties(styles, pickKeys) {\n    if (pickKeys) {\n      for (const key of pickKeys) {\n        this[key] = styles[key];\n      }\n    } else {\n      Object.assign(this, styles);\n    }\n    return this;\n  }\n  containsPoint(_x, _y) {\n    return false;\n  }\n  /**\n   * Hit testing method.\n   * Recursively checks if the given point is inside this node or any of its children.\n   * Returns the first matching node or `undefined`.\n   * Nodes that render later (show on top) are hit tested first.\n   */\n  pickNode(x, y, _localCoords = false) {\n    if (!this.visible || this.pointerEvents === 1 /* None */ || !this.containsPoint(x, y)) {\n      return;\n    }\n    const children = [...this.children()];\n    if (children.length > 1e3) {\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const containsPoint3 = child.containsPoint(x, y);\n        const hit = containsPoint3 ? child.pickNode(x, y) : void 0;\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (children.length) {\n      for (let i = children.length - 1; i >= 0; i--) {\n        const hit = children[i].pickNode(x, y);\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (!this.isContainerNode) {\n      return this;\n    }\n  }\n  invalidateCachedBBox() {\n    if (this.cachedBBox != null) {\n      this.cachedBBox = void 0;\n      this.parentNode?.invalidateCachedBBox();\n    }\n  }\n  getBBox() {\n    if (this.cachedBBox == null) {\n      this.cachedBBox = Object.freeze(this.computeBBox());\n    }\n    return this.cachedBBox;\n  }\n  computeBBox() {\n    return;\n  }\n  markDirty() {\n    const { _dirty } = this;\n    const noParentCachedBBox = this.cachedBBox == null;\n    if (noParentCachedBBox && _dirty)\n      return;\n    this.invalidateCachedBBox();\n    this._dirty = true;\n    if (this.parentNode) {\n      this.parentNode.markDirty();\n    }\n  }\n  markClean() {\n    if (!this._dirty)\n      return;\n    this._dirty = false;\n    for (const child of this.children()) {\n      child.markClean();\n    }\n  }\n  onZIndexChange() {\n    const { parentNode } = this;\n    if (parentNode) {\n      parentNode.dirtyZIndex = true;\n    }\n  }\n  toSVG() {\n    return;\n  }\n};\n_Node._nextSerialNumber = 0;\n__decorateClass([\n  SceneChangeDetection()\n], _Node.prototype, \"visible\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    changeCb: (target) => target.onZIndexChange()\n  })\n], _Node.prototype, \"zIndex\", 2);\nvar Node = _Node;\n\n// packages/ag-charts-community/src/util/color.ts\nvar lerp = (x, y, t) => x * (1 - t) + y * t;\nvar srgbToLinear = (value) => {\n  const sign = value < 0 ? -1 : 1;\n  const abs = Math.abs(value);\n  if (abs <= 0.04045)\n    return value / 12.92;\n  return sign * ((abs + 0.055) / 1.055) ** 2.4;\n};\nvar srgbFromLinear = (value) => {\n  const sign = value < 0 ? -1 : 1;\n  const abs = Math.abs(value);\n  if (abs > 31308e-7) {\n    return sign * (1.055 * abs ** (1 / 2.4) - 0.055);\n  }\n  return 12.92 * value;\n};\nvar _Color = class _Color {\n  /**\n   * Every color component should be in the [0, 1] range.\n   * Some easing functions (such as elastic easing) can overshoot the target value by some amount.\n   * So, when animating colors, if the source or target color components are already near\n   * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color\n   * component value to end up outside of that range mid-animation. For this reason the constructor\n   * performs range checking/constraining.\n   * @param r Red component.\n   * @param g Green component.\n   * @param b Blue component.\n   * @param a Alpha (opacity) component.\n   */\n  constructor(r, g, b, a = 1) {\n    this.r = clamp(0, r || 0, 1);\n    this.g = clamp(0, g || 0, 1);\n    this.b = clamp(0, b || 0, 1);\n    this.a = clamp(0, a || 0, 1);\n  }\n  /**\n   * A color string can be in one of the following formats to be valid:\n   * - #rgb\n   * - #rrggbb\n   * - rgb(r, g, b)\n   * - rgba(r, g, b, a)\n   * - CSS color name such as 'white', 'orange', 'cyan', etc.\n   */\n  static validColorString(str) {\n    if (str.indexOf(\"#\") >= 0) {\n      return !!_Color.parseHex(str);\n    }\n    if (str.indexOf(\"rgb\") >= 0) {\n      return !!_Color.stringToRgba(str);\n    }\n    return _Color.nameToHex.has(str.toLowerCase());\n  }\n  /**\n   * The given string can be in one of the following formats:\n   * - #rgb\n   * - #rrggbb\n   * - rgb(r, g, b)\n   * - rgba(r, g, b, a)\n   * - CSS color name such as 'white', 'orange', 'cyan', etc.\n   * @param str\n   */\n  static fromString(str) {\n    if (str.indexOf(\"#\") >= 0) {\n      return _Color.fromHexString(str);\n    }\n    const hex = _Color.nameToHex.get(str.toLowerCase());\n    if (hex) {\n      return _Color.fromHexString(hex);\n    }\n    if (str.indexOf(\"rgb\") >= 0) {\n      return _Color.fromRgbaString(str);\n    }\n    throw new Error(`Invalid color string: '${str}'`);\n  }\n  // See https://drafts.csswg.org/css-color/#hex-notation\n  static parseHex(input) {\n    input = input.replace(/ /g, \"\").slice(1);\n    let parts;\n    switch (input.length) {\n      case 6:\n      case 8:\n        parts = [];\n        for (let i = 0; i < input.length; i += 2) {\n          parts.push(parseInt(`${input[i]}${input[i + 1]}`, 16));\n        }\n        break;\n      case 3:\n      case 4:\n        parts = input.split(\"\").map((p) => parseInt(p, 16)).map((p) => p + p * 16);\n        break;\n    }\n    if (parts?.length >= 3 && parts.every((p) => p >= 0)) {\n      if (parts.length === 3) {\n        parts.push(255);\n      }\n      return parts;\n    }\n  }\n  static fromHexString(str) {\n    const values = _Color.parseHex(str);\n    if (values) {\n      const [r, g, b, a] = values;\n      return new _Color(r / 255, g / 255, b / 255, a / 255);\n    }\n    throw new Error(`Malformed hexadecimal color string: '${str}'`);\n  }\n  static stringToRgba(str) {\n    let po = -1;\n    let pc = -1;\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i];\n      if (po === -1 && c === \"(\") {\n        po = i;\n      } else if (c === \")\") {\n        pc = i;\n        break;\n      }\n    }\n    if (po === -1 || pc === -1)\n      return;\n    const contents = str.substring(po + 1, pc);\n    const parts = contents.split(\",\");\n    const rgba = [];\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n      let value = parseFloat(part);\n      if (!Number.isFinite(value)) {\n        return;\n      }\n      if (part.indexOf(\"%\") >= 0) {\n        value = clamp(0, value, 100);\n        value /= 100;\n      } else if (i === 3) {\n        value = clamp(0, value, 1);\n      } else {\n        value = clamp(0, value, 255);\n        value /= 255;\n      }\n      rgba.push(value);\n    }\n    return rgba;\n  }\n  static fromRgbaString(str) {\n    const rgba = _Color.stringToRgba(str);\n    if (rgba) {\n      if (rgba.length === 3) {\n        return new _Color(rgba[0], rgba[1], rgba[2]);\n      } else if (rgba.length === 4) {\n        return new _Color(rgba[0], rgba[1], rgba[2], rgba[3]);\n      }\n    }\n    throw new Error(`Malformed rgb/rgba color string: '${str}'`);\n  }\n  static fromArray(arr) {\n    if (arr.length === 4) {\n      return new _Color(arr[0], arr[1], arr[2], arr[3]);\n    }\n    if (arr.length === 3) {\n      return new _Color(arr[0], arr[1], arr[2]);\n    }\n    throw new Error(\"The given array should contain 3 or 4 color components (numbers).\");\n  }\n  static fromHSB(h, s, b, alpha = 1) {\n    const rgb = _Color.HSBtoRGB(h, s, b);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static fromHSL(h, s, l, alpha = 1) {\n    const rgb = _Color.HSLtoRGB(h, s, l);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static fromOKLCH(l, c, h, alpha = 1) {\n    const rgb = _Color.OKLCHtoRGB(l, c, h);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static padHex(str) {\n    return str.length === 1 ? \"0\" + str : str;\n  }\n  toHexString() {\n    let hex = \"#\" + _Color.padHex(Math.round(this.r * 255).toString(16)) + _Color.padHex(Math.round(this.g * 255).toString(16)) + _Color.padHex(Math.round(this.b * 255).toString(16));\n    if (this.a < 1) {\n      hex += _Color.padHex(Math.round(this.a * 255).toString(16));\n    }\n    return hex;\n  }\n  toRgbaString(fractionDigits = 3) {\n    const components = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];\n    const k = Math.pow(10, fractionDigits);\n    if (this.a !== 1) {\n      components.push(Math.round(this.a * k) / k);\n      return `rgba(${components.join(\", \")})`;\n    }\n    return `rgb(${components.join(\", \")})`;\n  }\n  toString() {\n    if (this.a === 1) {\n      return this.toHexString();\n    }\n    return this.toRgbaString();\n  }\n  toHSB() {\n    return _Color.RGBtoHSB(this.r, this.g, this.b);\n  }\n  static RGBtoOKLCH(r, g, b) {\n    const LSRGB0 = srgbToLinear(r);\n    const LSRGB1 = srgbToLinear(g);\n    const LSRGB2 = srgbToLinear(b);\n    const LMS0 = Math.cbrt(0.4122214708 * LSRGB0 + 0.5363325363 * LSRGB1 + 0.0514459929 * LSRGB2);\n    const LMS1 = Math.cbrt(0.2119034982 * LSRGB0 + 0.6806995451 * LSRGB1 + 0.1073969566 * LSRGB2);\n    const LMS2 = Math.cbrt(0.0883024619 * LSRGB0 + 0.2817188376 * LSRGB1 + 0.6299787005 * LSRGB2);\n    const OKLAB0 = 0.2104542553 * LMS0 + 0.793617785 * LMS1 - 0.0040720468 * LMS2;\n    const OKLAB1 = 1.9779984951 * LMS0 - 2.428592205 * LMS1 + 0.4505937099 * LMS2;\n    const OKLAB2 = 0.0259040371 * LMS0 + 0.7827717662 * LMS1 - 0.808675766 * LMS2;\n    const hue = Math.atan2(OKLAB2, OKLAB1) * 180 / Math.PI;\n    const OKLCH0 = OKLAB0;\n    const OKLCH1 = Math.hypot(OKLAB1, OKLAB2);\n    const OKLCH2 = hue >= 0 ? hue : hue + 360;\n    return [OKLCH0, OKLCH1, OKLCH2];\n  }\n  static OKLCHtoRGB(l, c, h) {\n    const OKLAB0 = l;\n    const OKLAB1 = c * Math.cos(h * Math.PI / 180);\n    const OKLAB2 = c * Math.sin(h * Math.PI / 180);\n    const LMS0 = (OKLAB0 + 0.3963377774 * OKLAB1 + 0.2158037573 * OKLAB2) ** 3;\n    const LMS1 = (OKLAB0 - 0.1055613458 * OKLAB1 - 0.0638541728 * OKLAB2) ** 3;\n    const LMS2 = (OKLAB0 - 0.0894841775 * OKLAB1 - 1.291485548 * OKLAB2) ** 3;\n    const LSRGB0 = 4.0767416621 * LMS0 - 3.3077115913 * LMS1 + 0.2309699292 * LMS2;\n    const LSRGB1 = -1.2684380046 * LMS0 + 2.6097574011 * LMS1 - 0.3413193965 * LMS2;\n    const LSRGB2 = -0.0041960863 * LMS0 - 0.7034186147 * LMS1 + 1.707614701 * LMS2;\n    const SRGB0 = srgbFromLinear(LSRGB0);\n    const SRGB1 = srgbFromLinear(LSRGB1);\n    const SRGB2 = srgbFromLinear(LSRGB2);\n    return [SRGB0, SRGB1, SRGB2];\n  }\n  static RGBtoHSL(r, g, b) {\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n    const l = (max + min) / 2;\n    let h;\n    let s;\n    if (max === min) {\n      h = 0;\n      s = 0;\n    } else {\n      const delta3 = max - min;\n      s = l > 0.5 ? delta3 / (2 - max - min) : delta3 / (max + min);\n      if (max === r) {\n        h = (g - b) / delta3 + (g < b ? 6 : 0);\n      } else if (max === g) {\n        h = (b - r) / delta3 + 2;\n      } else {\n        h = (r - g) / delta3 + 4;\n      }\n      h *= 360 / 6;\n    }\n    return [h, s, l];\n  }\n  static HSLtoRGB(h, s, l) {\n    h = (h % 360 + 360) % 360;\n    if (s === 0) {\n      return [l, l, l];\n    }\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    function hueToRgb(t) {\n      if (t < 0)\n        t += 1;\n      if (t > 1)\n        t -= 1;\n      if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n      if (t < 1 / 2)\n        return q;\n      if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    }\n    const r = hueToRgb(h / 360 + 1 / 3);\n    const g = hueToRgb(h / 360);\n    const b = hueToRgb(h / 360 - 1 / 3);\n    return [r, g, b];\n  }\n  /**\n   * Converts the given RGB triple to an array of HSB (HSV) components.\n   */\n  static RGBtoHSB(r, g, b) {\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n    const S = max === 0 ? 0 : (max - min) / max;\n    let H = 0;\n    if (min !== max) {\n      const delta3 = max - min;\n      const rc = (max - r) / delta3;\n      const gc = (max - g) / delta3;\n      const bc = (max - b) / delta3;\n      if (r === max) {\n        H = bc - gc;\n      } else if (g === max) {\n        H = 2 + rc - bc;\n      } else {\n        H = 4 + gc - rc;\n      }\n      H /= 6;\n      if (H < 0) {\n        H = H + 1;\n      }\n    }\n    return [H * 360, S, max];\n  }\n  /**\n   * Converts the given HSB (HSV) triple to an array of RGB components.\n   */\n  static HSBtoRGB(H, S, B) {\n    H = (H % 360 + 360) % 360 / 360;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    if (S === 0) {\n      r = g = b = B;\n    } else {\n      const h = (H - Math.floor(H)) * 6;\n      const f = h - Math.floor(h);\n      const p = B * (1 - S);\n      const q = B * (1 - S * f);\n      const t = B * (1 - S * (1 - f));\n      switch (h >> 0) {\n        case 0:\n          r = B;\n          g = t;\n          b = p;\n          break;\n        case 1:\n          r = q;\n          g = B;\n          b = p;\n          break;\n        case 2:\n          r = p;\n          g = B;\n          b = t;\n          break;\n        case 3:\n          r = p;\n          g = q;\n          b = B;\n          break;\n        case 4:\n          r = t;\n          g = p;\n          b = B;\n          break;\n        case 5:\n          r = B;\n          g = p;\n          b = q;\n          break;\n      }\n    }\n    return [r, g, b];\n  }\n  static mix(c0, c1, t) {\n    return new _Color(lerp(c0.r, c1.r, t), lerp(c0.g, c1.g, t), lerp(c0.b, c1.b, t), lerp(c0.a, c1.a, t));\n  }\n};\n/**\n * CSS Color Module Level 4:\n * https://drafts.csswg.org/css-color/#named-colors\n */\n_Color.nameToHex = /* @__PURE__ */ new Map([\n  [\"aliceblue\", \"#F0F8FF\"],\n  [\"antiquewhite\", \"#FAEBD7\"],\n  [\"aqua\", \"#00FFFF\"],\n  [\"aquamarine\", \"#7FFFD4\"],\n  [\"azure\", \"#F0FFFF\"],\n  [\"beige\", \"#F5F5DC\"],\n  [\"bisque\", \"#FFE4C4\"],\n  [\"black\", \"#000000\"],\n  [\"blanchedalmond\", \"#FFEBCD\"],\n  [\"blue\", \"#0000FF\"],\n  [\"blueviolet\", \"#8A2BE2\"],\n  [\"brown\", \"#A52A2A\"],\n  [\"burlywood\", \"#DEB887\"],\n  [\"cadetblue\", \"#5F9EA0\"],\n  [\"chartreuse\", \"#7FFF00\"],\n  [\"chocolate\", \"#D2691E\"],\n  [\"coral\", \"#FF7F50\"],\n  [\"cornflowerblue\", \"#6495ED\"],\n  [\"cornsilk\", \"#FFF8DC\"],\n  [\"crimson\", \"#DC143C\"],\n  [\"cyan\", \"#00FFFF\"],\n  [\"darkblue\", \"#00008B\"],\n  [\"darkcyan\", \"#008B8B\"],\n  [\"darkgoldenrod\", \"#B8860B\"],\n  [\"darkgray\", \"#A9A9A9\"],\n  [\"darkgreen\", \"#006400\"],\n  [\"darkgrey\", \"#A9A9A9\"],\n  [\"darkkhaki\", \"#BDB76B\"],\n  [\"darkmagenta\", \"#8B008B\"],\n  [\"darkolivegreen\", \"#556B2F\"],\n  [\"darkorange\", \"#FF8C00\"],\n  [\"darkorchid\", \"#9932CC\"],\n  [\"darkred\", \"#8B0000\"],\n  [\"darksalmon\", \"#E9967A\"],\n  [\"darkseagreen\", \"#8FBC8F\"],\n  [\"darkslateblue\", \"#483D8B\"],\n  [\"darkslategray\", \"#2F4F4F\"],\n  [\"darkslategrey\", \"#2F4F4F\"],\n  [\"darkturquoise\", \"#00CED1\"],\n  [\"darkviolet\", \"#9400D3\"],\n  [\"deeppink\", \"#FF1493\"],\n  [\"deepskyblue\", \"#00BFFF\"],\n  [\"dimgray\", \"#696969\"],\n  [\"dimgrey\", \"#696969\"],\n  [\"dodgerblue\", \"#1E90FF\"],\n  [\"firebrick\", \"#B22222\"],\n  [\"floralwhite\", \"#FFFAF0\"],\n  [\"forestgreen\", \"#228B22\"],\n  [\"fuchsia\", \"#FF00FF\"],\n  [\"gainsboro\", \"#DCDCDC\"],\n  [\"ghostwhite\", \"#F8F8FF\"],\n  [\"gold\", \"#FFD700\"],\n  [\"goldenrod\", \"#DAA520\"],\n  [\"gray\", \"#808080\"],\n  [\"green\", \"#008000\"],\n  [\"greenyellow\", \"#ADFF2F\"],\n  [\"grey\", \"#808080\"],\n  [\"honeydew\", \"#F0FFF0\"],\n  [\"hotpink\", \"#FF69B4\"],\n  [\"indianred\", \"#CD5C5C\"],\n  [\"indigo\", \"#4B0082\"],\n  [\"ivory\", \"#FFFFF0\"],\n  [\"khaki\", \"#F0E68C\"],\n  [\"lavender\", \"#E6E6FA\"],\n  [\"lavenderblush\", \"#FFF0F5\"],\n  [\"lawngreen\", \"#7CFC00\"],\n  [\"lemonchiffon\", \"#FFFACD\"],\n  [\"lightblue\", \"#ADD8E6\"],\n  [\"lightcoral\", \"#F08080\"],\n  [\"lightcyan\", \"#E0FFFF\"],\n  [\"lightgoldenrodyellow\", \"#FAFAD2\"],\n  [\"lightgray\", \"#D3D3D3\"],\n  [\"lightgreen\", \"#90EE90\"],\n  [\"lightgrey\", \"#D3D3D3\"],\n  [\"lightpink\", \"#FFB6C1\"],\n  [\"lightsalmon\", \"#FFA07A\"],\n  [\"lightseagreen\", \"#20B2AA\"],\n  [\"lightskyblue\", \"#87CEFA\"],\n  [\"lightslategray\", \"#778899\"],\n  [\"lightslategrey\", \"#778899\"],\n  [\"lightsteelblue\", \"#B0C4DE\"],\n  [\"lightyellow\", \"#FFFFE0\"],\n  [\"lime\", \"#00FF00\"],\n  [\"limegreen\", \"#32CD32\"],\n  [\"linen\", \"#FAF0E6\"],\n  [\"magenta\", \"#FF00FF\"],\n  [\"maroon\", \"#800000\"],\n  [\"mediumaquamarine\", \"#66CDAA\"],\n  [\"mediumblue\", \"#0000CD\"],\n  [\"mediumorchid\", \"#BA55D3\"],\n  [\"mediumpurple\", \"#9370DB\"],\n  [\"mediumseagreen\", \"#3CB371\"],\n  [\"mediumslateblue\", \"#7B68EE\"],\n  [\"mediumspringgreen\", \"#00FA9A\"],\n  [\"mediumturquoise\", \"#48D1CC\"],\n  [\"mediumvioletred\", \"#C71585\"],\n  [\"midnightblue\", \"#191970\"],\n  [\"mintcream\", \"#F5FFFA\"],\n  [\"mistyrose\", \"#FFE4E1\"],\n  [\"moccasin\", \"#FFE4B5\"],\n  [\"navajowhite\", \"#FFDEAD\"],\n  [\"navy\", \"#000080\"],\n  [\"oldlace\", \"#FDF5E6\"],\n  [\"olive\", \"#808000\"],\n  [\"olivedrab\", \"#6B8E23\"],\n  [\"orange\", \"#FFA500\"],\n  [\"orangered\", \"#FF4500\"],\n  [\"orchid\", \"#DA70D6\"],\n  [\"palegoldenrod\", \"#EEE8AA\"],\n  [\"palegreen\", \"#98FB98\"],\n  [\"paleturquoise\", \"#AFEEEE\"],\n  [\"palevioletred\", \"#DB7093\"],\n  [\"papayawhip\", \"#FFEFD5\"],\n  [\"peachpuff\", \"#FFDAB9\"],\n  [\"peru\", \"#CD853F\"],\n  [\"pink\", \"#FFC0CB\"],\n  [\"plum\", \"#DDA0DD\"],\n  [\"powderblue\", \"#B0E0E6\"],\n  [\"purple\", \"#800080\"],\n  [\"rebeccapurple\", \"#663399\"],\n  [\"red\", \"#FF0000\"],\n  [\"rosybrown\", \"#BC8F8F\"],\n  [\"royalblue\", \"#4169E1\"],\n  [\"saddlebrown\", \"#8B4513\"],\n  [\"salmon\", \"#FA8072\"],\n  [\"sandybrown\", \"#F4A460\"],\n  [\"seagreen\", \"#2E8B57\"],\n  [\"seashell\", \"#FFF5EE\"],\n  [\"sienna\", \"#A0522D\"],\n  [\"silver\", \"#C0C0C0\"],\n  [\"skyblue\", \"#87CEEB\"],\n  [\"slateblue\", \"#6A5ACD\"],\n  [\"slategray\", \"#708090\"],\n  [\"slategrey\", \"#708090\"],\n  [\"snow\", \"#FFFAFA\"],\n  [\"springgreen\", \"#00FF7F\"],\n  [\"steelblue\", \"#4682B4\"],\n  [\"tan\", \"#D2B48C\"],\n  [\"teal\", \"#008080\"],\n  [\"thistle\", \"#D8BFD8\"],\n  [\"tomato\", \"#FF6347\"],\n  [\"transparent\", \"#00000000\"],\n  [\"turquoise\", \"#40E0D0\"],\n  [\"violet\", \"#EE82EE\"],\n  [\"wheat\", \"#F5DEB3\"],\n  [\"white\", \"#FFFFFF\"],\n  [\"whitesmoke\", \"#F5F5F5\"],\n  [\"yellow\", \"#FFFF00\"],\n  [\"yellowgreen\", \"#9ACD32\"]\n]);\nvar Color = _Color;\n\n// packages/ag-charts-community/src/util/interpolate.ts\nfunction interpolateNumber(a, b) {\n  return (d) => Number(a) * (1 - d) + Number(b) * d;\n}\nfunction interpolateColor(a, b) {\n  if (typeof a === \"string\") {\n    try {\n      a = Color.fromString(a);\n    } catch {\n      a = Color.fromArray([0, 0, 0]);\n    }\n  }\n  if (typeof b === \"string\") {\n    try {\n      b = Color.fromString(b);\n    } catch {\n      b = Color.fromArray([0, 0, 0]);\n    }\n  }\n  return (d) => Color.mix(a, b, d).toRgbaString();\n}\n\n// packages/ag-charts-community/src/util/decorator.ts\nvar BREAK_TRANSFORM_CHAIN = Symbol(\"BREAK\");\nvar CONFIG_KEY = \"__decorator_config\";\nfunction initialiseConfig(target, propertyKeyOrSymbol) {\n  if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {\n    Object.defineProperty(target, CONFIG_KEY, { value: {} });\n  }\n  const config = target[CONFIG_KEY];\n  const propertyKey = propertyKeyOrSymbol.toString();\n  if (typeof config[propertyKey] !== \"undefined\") {\n    return config[propertyKey];\n  }\n  const valuesMap = /* @__PURE__ */ new WeakMap();\n  config[propertyKey] = { setters: [], getters: [], observers: [], valuesMap };\n  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);\n  const prevSet = descriptor?.set;\n  const prevGet = descriptor?.get;\n  const getter = function() {\n    let value = prevGet ? prevGet.call(this) : valuesMap.get(this);\n    for (const transformFn of config[propertyKey].getters) {\n      value = transformFn(this, propertyKeyOrSymbol, value);\n      if (value === BREAK_TRANSFORM_CHAIN) {\n        return;\n      }\n    }\n    return value;\n  };\n  const setter = function(value) {\n    const { setters, observers } = config[propertyKey];\n    let oldValue;\n    if (setters.some((f) => f.length > 2)) {\n      oldValue = prevGet ? prevGet.call(this) : valuesMap.get(this);\n    }\n    for (const transformFn of setters) {\n      value = transformFn(this, propertyKeyOrSymbol, value, oldValue);\n      if (value === BREAK_TRANSFORM_CHAIN) {\n        return;\n      }\n    }\n    if (prevSet) {\n      prevSet.call(this, value);\n    } else {\n      valuesMap.set(this, value);\n    }\n    for (const observerFn of observers) {\n      observerFn(this, value, oldValue);\n    }\n  };\n  Object.defineProperty(target, propertyKeyOrSymbol, {\n    set: setter,\n    get: getter,\n    enumerable: true,\n    configurable: false\n  });\n  return config[propertyKey];\n}\nfunction addTransformToInstanceProperty(setTransform, getTransform, configMetadata) {\n  return (target, propertyKeyOrSymbol) => {\n    const config = initialiseConfig(target, propertyKeyOrSymbol);\n    config.setters.push(setTransform);\n    if (getTransform) {\n      config.getters.unshift(getTransform);\n    }\n    if (configMetadata) {\n      Object.assign(config, configMetadata);\n    }\n  };\n}\nfunction addObserverToInstanceProperty(setObserver) {\n  return (target, propertyKeyOrSymbol) => {\n    initialiseConfig(target, propertyKeyOrSymbol).observers.push(setObserver);\n  };\n}\nfunction isDecoratedObject(target) {\n  return typeof target !== \"undefined\" && CONFIG_KEY in target;\n}\nfunction listDecoratedProperties(target) {\n  const targets = /* @__PURE__ */ new Set();\n  while (isDecoratedObject(target)) {\n    targets.add(target?.[CONFIG_KEY]);\n    target = Object.getPrototypeOf(target);\n  }\n  return Array.from(targets).flatMap((configMap) => Object.keys(configMap));\n}\nfunction extractDecoratedProperties(target) {\n  return listDecoratedProperties(target).reduce((result, key) => {\n    result[key] = target[key] ?? null;\n    return result;\n  }, {});\n}\nfunction extractDecoratedPropertyMetadata(target, propertyKeyOrSymbol) {\n  const propertyKey = propertyKeyOrSymbol.toString();\n  while (isDecoratedObject(target)) {\n    const config = target[CONFIG_KEY];\n    if (Object.hasOwn(config, propertyKey)) {\n      return config[propertyKey];\n    }\n    target = Object.getPrototypeOf(target);\n  }\n}\n\n// packages/ag-charts-community/src/util/object.ts\nfunction objectsEqual(a, b) {\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b))\n      return false;\n    if (a.length !== b.length)\n      return false;\n    return a.every((av, i) => objectsEqual(av, b[i]));\n  } else if (isPlainObject(a)) {\n    if (!isPlainObject(b))\n      return false;\n    return objectsEqualWith(a, b, objectsEqual);\n  }\n  return a === b;\n}\nfunction objectsEqualWith(a, b, cmp2) {\n  for (const key of Object.keys(b)) {\n    if (!(key in a))\n      return false;\n  }\n  for (const key of Object.keys(a)) {\n    if (!(key in b))\n      return false;\n    if (!cmp2(a[key], b[key]))\n      return false;\n  }\n  return true;\n}\nfunction mergeDefaults(...sources) {\n  const target = {};\n  for (const source of sources) {\n    if (!isObject(source))\n      continue;\n    const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);\n    for (const key of keys) {\n      if (isPlainObject(target[key]) && isPlainObject(source[key])) {\n        target[key] = mergeDefaults(target[key], source[key]);\n      } else {\n        target[key] ?? (target[key] = source[key]);\n      }\n    }\n  }\n  return target;\n}\nfunction mergeArrayDefaults(dataArray, ...itemDefaults) {\n  if (itemDefaults && isArray(dataArray)) {\n    return dataArray.map((item) => mergeDefaults(item, ...itemDefaults));\n  }\n  return dataArray;\n}\nfunction mapValues(object2, mapper) {\n  return Object.entries(object2).reduce(\n    (result, [key, value]) => {\n      result[key] = mapper(value, key, object2);\n      return result;\n    },\n    {}\n  );\n}\nfunction without(object2, keys) {\n  const clone2 = { ...object2 };\n  for (const key of keys) {\n    delete clone2[key];\n  }\n  return clone2;\n}\nfunction getPath(object2, path) {\n  const pathArray = isArray(path) ? path : path.split(\".\");\n  return pathArray.reduce((value, pathKey) => value[pathKey], object2);\n}\nvar SKIP_JS_BUILTINS = /* @__PURE__ */ new Set([\"__proto__\", \"constructor\", \"prototype\"]);\nfunction setPath(object2, path, newValue) {\n  const pathArray = isArray(path) ? path.slice() : path.split(\".\");\n  const lastKey = pathArray.pop();\n  if (pathArray.some((p) => SKIP_JS_BUILTINS.has(p)))\n    return;\n  const lastObject = pathArray.reduce((value, pathKey) => value[pathKey], object2);\n  lastObject[lastKey] = newValue;\n  return lastObject[lastKey];\n}\nfunction partialAssign(keysToCopy, target, source) {\n  if (source === void 0) {\n    return target;\n  }\n  for (const key of keysToCopy) {\n    const value = source[key];\n    if (value !== void 0) {\n      target[key] = value;\n    }\n  }\n  return target;\n}\nfunction deepFreeze(obj) {\n  Object.freeze(obj);\n  Object.getOwnPropertyNames(obj).forEach((prop) => {\n    const value = obj[prop];\n    if (value !== null && (typeof value === \"object\" || typeof value === \"function\") && !Object.isFrozen(value)) {\n      deepFreeze(value);\n    }\n  });\n  return obj;\n}\n\n// packages/ag-charts-community/src/motion/easing.ts\nvar easing_exports = {};\n__export(easing_exports, {\n  easeIn: () => easeIn,\n  easeInOut: () => easeInOut,\n  easeInOutQuad: () => easeInOutQuad,\n  easeInQuad: () => easeInQuad,\n  easeOut: () => easeOut,\n  easeOutQuad: () => easeOutQuad,\n  inverseEaseOut: () => inverseEaseOut,\n  linear: () => linear\n});\nvar linear = (n) => n;\nvar easeIn = (n) => 1 - Math.cos(n * Math.PI / 2);\nvar easeOut = (n) => Math.sin(n * Math.PI / 2);\nvar easeInOut = (n) => -(Math.cos(n * Math.PI) - 1) / 2;\nvar easeInQuad = (n) => n * n;\nvar easeOutQuad = (n) => 1 - (1 - n) ** 2;\nvar easeInOutQuad = (n) => n < 0.5 ? 2 * n * n : 1 - (-2 * n + 2) ** 2 / 2;\nvar inverseEaseOut = (x) => 2 * Math.asin(x) / Math.PI;\n\n// packages/ag-charts-community/src/motion/animation.ts\nvar QUICK_TRANSITION = 0.2;\nvar PHASE_ORDER = [\"initial\", \"remove\", \"update\", \"add\", \"trailing\", \"end\", \"none\"];\nvar PHASE_METADATA = {\n  initial: {\n    animationDuration: 1,\n    animationDelay: 0\n  },\n  add: {\n    animationDuration: 0.25,\n    animationDelay: 0.75\n  },\n  remove: {\n    animationDuration: 0.25,\n    animationDelay: 0\n  },\n  update: {\n    animationDuration: 0.5,\n    animationDelay: 0.25\n  },\n  trailing: {\n    animationDuration: QUICK_TRANSITION,\n    animationDelay: 1,\n    skipIfNoEarlierAnimations: true\n  },\n  end: {\n    animationDelay: 1 + QUICK_TRANSITION,\n    animationDuration: 0,\n    skipIfNoEarlierAnimations: true\n  },\n  none: {\n    animationDuration: 0,\n    animationDelay: 0\n  }\n};\nvar RepeatType = /* @__PURE__ */ ((RepeatType2) => {\n  RepeatType2[\"Loop\"] = \"loop\";\n  RepeatType2[\"Reverse\"] = \"reverse\";\n  return RepeatType2;\n})(RepeatType || {});\nfunction isNodeArray(array2) {\n  return array2.every((n) => n instanceof Node);\n}\nfunction deconstructSelectionsOrNodes(selectionsOrNodes) {\n  return isNodeArray(selectionsOrNodes) ? { nodes: selectionsOrNodes, selections: [] } : { nodes: [], selections: selectionsOrNodes };\n}\nfunction animationValuesEqual(a, b) {\n  if (a === b) {\n    return true;\n  } else if (Array.isArray(a) && Array.isArray(b)) {\n    return a.length === b.length && a.every((v, i) => animationValuesEqual(v, b[i]));\n  } else if (isInterpolating(a) && isInterpolating(b)) {\n    return a.equals(b);\n  } else if (isPlainObject(a) && isPlainObject(b)) {\n    return objectsEqualWith(a, b, animationValuesEqual);\n  }\n  return false;\n}\nvar Animation = class {\n  constructor(opts) {\n    this.isComplete = false;\n    this.elapsed = 0;\n    this.iteration = 0;\n    this.isPlaying = false;\n    this.isReverse = false;\n    this.id = opts.id;\n    this.groupId = opts.groupId;\n    this.autoplay = opts.autoplay ?? true;\n    this.ease = opts.ease ?? linear;\n    this.phase = opts.phase;\n    const durationProportion = opts.duration ?? PHASE_METADATA[this.phase].animationDuration;\n    this.duration = durationProportion * opts.defaultDuration;\n    this.delay = (opts.delay ?? 0) * opts.defaultDuration;\n    this.onComplete = opts.onComplete;\n    this.onPlay = opts.onPlay;\n    this.onStop = opts.onStop;\n    this.onUpdate = opts.onUpdate;\n    this.interpolate = this.createInterpolator(opts.from, opts.to);\n    this.from = opts.from;\n    if (opts.skip === true) {\n      this.onUpdate?.(opts.to, false, this);\n      this.onStop?.(this);\n      this.onComplete?.(this);\n      this.isComplete = true;\n    }\n    if (opts.collapsable !== false) {\n      this.duration = this.checkCollapse(opts, this.duration);\n    }\n  }\n  checkCollapse(opts, calculatedDuration) {\n    return animationValuesEqual(opts.from, opts.to) ? 0 : calculatedDuration;\n  }\n  play(initialUpdate = false) {\n    if (this.isPlaying || this.isComplete)\n      return;\n    this.isPlaying = true;\n    this.onPlay?.(this);\n    if (!this.autoplay)\n      return;\n    this.autoplay = false;\n    if (!initialUpdate)\n      return;\n    this.onUpdate?.(this.from, true, this);\n  }\n  stop() {\n    this.isPlaying = false;\n    if (!this.isComplete) {\n      this.isComplete = true;\n      this.onStop?.(this);\n    }\n  }\n  update(time2) {\n    if (this.isComplete)\n      return time2;\n    if (!this.isPlaying && this.autoplay) {\n      this.play(true);\n    }\n    const previousElapsed = this.elapsed;\n    this.elapsed += time2;\n    if (this.delay > this.elapsed)\n      return 0;\n    const value = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);\n    this.onUpdate?.(value, false, this);\n    const totalDuration = this.delay + this.duration;\n    if (this.elapsed >= totalDuration) {\n      this.stop();\n      this.isComplete = true;\n      this.onComplete?.(this);\n      return time2 - (totalDuration - previousElapsed);\n    }\n    return 0;\n  }\n  get delta() {\n    return this.ease(clamp(0, (this.elapsed - this.delay) / this.duration, 1));\n  }\n  createInterpolator(from3, to) {\n    if (typeof to !== \"object\" || isInterpolating(to)) {\n      return this.interpolateValue(from3, to);\n    }\n    const interpolatorEntries = [];\n    for (const key of Object.keys(to)) {\n      const interpolator = this.interpolateValue(from3[key], to[key]);\n      if (interpolator != null) {\n        interpolatorEntries.push([key, interpolator]);\n      }\n    }\n    return (d) => {\n      const result = {};\n      for (const [key, interpolator] of interpolatorEntries) {\n        result[key] = interpolator(d);\n      }\n      return result;\n    };\n  }\n  interpolateValue(a, b) {\n    if (a == null || b == null) {\n      return;\n    } else if (isInterpolating(a)) {\n      return (d) => a[interpolate](b, d);\n    }\n    try {\n      switch (typeof a) {\n        case \"number\":\n          return interpolateNumber(a, b);\n        case \"string\":\n          return interpolateColor(a, b);\n        case \"boolean\":\n          if (a === b) {\n            return () => a;\n          }\n          break;\n      }\n    } catch {\n    }\n    throw new Error(`Unable to interpolate values: ${a}, ${b}`);\n  }\n};\n\n// packages/ag-charts-community/src/motion/fromToMotion.ts\nvar NODE_UPDATE_STATE_TO_PHASE_MAPPING = {\n  added: \"add\",\n  updated: \"update\",\n  removed: \"remove\",\n  unknown: \"initial\",\n  \"no-op\": \"none\"\n};\nfunction fromToMotion(groupId, subId, animationManager, selectionsOrNodes, fns, getDatumId, diff2) {\n  const { fromFn, toFn, applyFn = (node, props) => node.setProperties(props) } = fns;\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  const processNodes = (liveNodes, subNodes) => {\n    let prevFromProps;\n    let liveNodeIndex = 0;\n    let nodeIndex = 0;\n    for (const node of subNodes) {\n      const isLive = liveNodes[liveNodeIndex] === node;\n      const ctx = {\n        last: nodeIndex >= subNodes.length - 1,\n        lastLive: liveNodeIndex >= liveNodes.length - 1,\n        prev: subNodes[nodeIndex - 1],\n        prevFromProps,\n        prevLive: liveNodes[liveNodeIndex - 1],\n        next: subNodes[nodeIndex + 1],\n        nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)]\n      };\n      const animationId = `${groupId}_${subId}_${node.id}`;\n      animationManager.stopByAnimationId(animationId);\n      let status = \"unknown\";\n      if (!isLive) {\n        status = \"removed\";\n      } else if (getDatumId && diff2) {\n        status = calculateStatus(node, node.datum, getDatumId, diff2);\n      }\n      node.transitionOut = status === \"removed\";\n      const { phase, start: start2, finish, delay, duration, ...from3 } = fromFn(node, node.datum, status, ctx);\n      const {\n        phase: toPhase,\n        start: toStart,\n        finish: toFinish,\n        delay: toDelay,\n        duration: toDuration,\n        ...to\n      } = toFn(node, node.datum, status, ctx);\n      const collapsable = finish == null;\n      animationManager.animate({\n        id: animationId,\n        groupId,\n        phase: phase ?? toPhase ?? \"update\",\n        duration: duration ?? toDuration,\n        delay: delay ?? toDelay,\n        from: from3,\n        to,\n        ease: easeOut,\n        collapsable,\n        onPlay: () => {\n          const startProps = { ...start2, ...toStart, ...from3 };\n          applyFn(node, startProps, \"start\");\n        },\n        onUpdate(props) {\n          applyFn(node, props, \"update\");\n        },\n        onStop: () => {\n          const endProps = {\n            ...start2,\n            ...toStart,\n            ...from3,\n            ...to,\n            ...finish,\n            ...toFinish\n          };\n          applyFn(node, endProps, \"end\");\n        }\n      });\n      if (isLive) {\n        liveNodeIndex++;\n      }\n      nodeIndex++;\n      prevFromProps = from3;\n    }\n  };\n  let selectionIndex = 0;\n  for (const selection of selections) {\n    const selectionNodes = selection.nodes();\n    const liveNodes = selectionNodes.filter((n) => !selection.isGarbage(n));\n    processNodes(liveNodes, selectionNodes);\n    animationManager.animate({\n      id: `${groupId}_${subId}_selection_${selectionIndex}`,\n      groupId,\n      phase: \"end\",\n      from: 0,\n      to: 1,\n      ease: easeOut,\n      onStop() {\n        selection.cleanup();\n      }\n    });\n    selectionIndex++;\n  }\n  processNodes(nodes, nodes);\n}\nfunction staticFromToMotion(groupId, subId, animationManager, selectionsOrNodes, from3, to, extraOpts) {\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  const { start: start2, finish, phase } = extraOpts;\n  animationManager.animate({\n    id: `${groupId}_${subId}`,\n    groupId,\n    phase: phase ?? \"update\",\n    from: from3,\n    to,\n    ease: easeOut,\n    onPlay: () => {\n      if (!start2)\n        return;\n      for (const node of nodes) {\n        node.setProperties(start2);\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties(start2);\n        }\n      }\n    },\n    onUpdate(props) {\n      for (const node of nodes) {\n        node.setProperties(props);\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties(props);\n        }\n      }\n    },\n    onStop: () => {\n      for (const node of nodes) {\n        node.setProperties({ ...to, ...finish });\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties({ ...to, ...finish });\n        }\n        selection.cleanup();\n      }\n    }\n  });\n}\nfunction calculateStatus(node, datum, getDatumId, diff2) {\n  const id = getDatumId(node, datum);\n  if (diff2.added.has(id)) {\n    return \"added\";\n  }\n  if (diff2.removed.has(id)) {\n    return \"removed\";\n  }\n  return \"updated\";\n}\n\n// packages/ag-charts-community/src/scale/abstractScale.ts\nvar AbstractScale = class {\n  ticks(_ticks, _domain, _visibleRange) {\n    return void 0;\n  }\n  niceDomain(_ticks, domain = this.domain) {\n    return domain;\n  }\n  tickFormatter(_params) {\n    return void 0;\n  }\n  datumFormatter(_params) {\n    return void 0;\n  }\n  get bandwidth() {\n    return void 0;\n  }\n  get step() {\n    return void 0;\n  }\n  get inset() {\n    return void 0;\n  }\n};\n\n// packages/ag-charts-community/src/scale/continuousScale.ts\nvar _ContinuousScale = class _ContinuousScale extends AbstractScale {\n  constructor(domain = [], range3 = []) {\n    super();\n    this.domain = domain;\n    this.range = range3;\n    this.defaultClamp = false;\n  }\n  static is(value) {\n    return value instanceof _ContinuousScale;\n  }\n  normalizeDomains(...domains) {\n    let min;\n    let minValue = Infinity;\n    let max;\n    let maxValue = -Infinity;\n    for (const domain of domains) {\n      for (const d of domain) {\n        const value = d.valueOf();\n        if (value < minValue) {\n          minValue = value;\n          min = d;\n        }\n        if (value > maxValue) {\n          maxValue = value;\n          max = d;\n        }\n      }\n    }\n    if (min != null && max != null) {\n      const domain = [min, max];\n      return { domain, animatable: true };\n    } else {\n      return { domain: [], animatable: false };\n    }\n  }\n  transform(x) {\n    return x;\n  }\n  transformInvert(x) {\n    return x;\n  }\n  calcBandwidth(smallestInterval = 1) {\n    const { domain } = this;\n    const rangeDistance = this.getPixelRange();\n    if (domain.length === 0)\n      return rangeDistance;\n    const intervals = Math.abs(domain[1].valueOf() - domain[0].valueOf()) / smallestInterval + 1;\n    const maxBands = Math.floor(rangeDistance);\n    const bands = Math.min(intervals, maxBands);\n    return rangeDistance / Math.max(1, bands);\n  }\n  convert(value, clamp2 = this.defaultClamp) {\n    const { domain } = this;\n    if (!domain || domain.length < 2) {\n      return NaN;\n    }\n    const d0 = Number(this.transform(domain[0]));\n    const d1 = Number(this.transform(domain[1]));\n    const x = Number(this.transform(value));\n    const { range: range3 } = this;\n    const [r0, r1] = range3;\n    if (clamp2) {\n      const [start2, stop] = findMinMax([d0, d1]);\n      if (x < start2) {\n        return r0;\n      } else if (x > stop) {\n        return r1;\n      }\n    }\n    if (d0 === d1) {\n      return (r0 + r1) / 2;\n    } else if (x === d0) {\n      return r0;\n    } else if (x === d1) {\n      return r1;\n    }\n    return r0 + (x - d0) / (d1 - d0) * (r1 - r0);\n  }\n  invert(x, _nearest) {\n    const domain = this.domain.map((d2) => this.transform(d2));\n    const [d0, d1] = domain;\n    const { range: range3 } = this;\n    const [r0, r1] = range3;\n    let d;\n    if (r0 === r1) {\n      d = this.toDomain((Number(d0) + Number(d1)) / 2);\n    } else {\n      d = this.toDomain(Number(d0) + (x - r0) / (r1 - r0) * (Number(d1) - Number(d0)));\n    }\n    return this.transformInvert(d);\n  }\n  getPixelRange() {\n    const [a, b] = this.range;\n    return Math.abs(b - a);\n  }\n};\n_ContinuousScale.defaultTickCount = 5;\nvar ContinuousScale = _ContinuousScale;\n\n// packages/ag-charts-community/src/util/time/index.ts\nvar time_exports = {};\n__export(time_exports, {\n  TimeInterval: () => TimeInterval,\n  day: () => day,\n  friday: () => friday,\n  hour: () => hour,\n  millisecond: () => millisecond,\n  minute: () => minute,\n  monday: () => monday,\n  month: () => month,\n  saturday: () => saturday,\n  second: () => second,\n  sunday: () => sunday,\n  thursday: () => thursday,\n  tuesday: () => tuesday,\n  utcDay: () => utcDay,\n  utcHour: () => utcHour,\n  utcMinute: () => utcMinute,\n  utcMonth: () => utcMonth,\n  utcYear: () => utcYear,\n  wednesday: () => wednesday,\n  year: () => year\n});\n\n// packages/ag-charts-community/src/util/time/interval.ts\nvar TimeInterval = class {\n  constructor(_encode, _decode, _rangeCallback) {\n    this._encode = _encode;\n    this._decode = _decode;\n    this._rangeCallback = _rangeCallback;\n  }\n  /**\n   * Returns a new date representing the latest interval boundary date before or equal to date.\n   * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.\n   * @param date\n   */\n  floor(date2) {\n    const d = new Date(date2);\n    const e = this._encode(d);\n    return this._decode(e);\n  }\n  /**\n   * Returns a new date representing the earliest interval boundary date after or equal to date.\n   * @param date\n   */\n  ceil(date2) {\n    const d = new Date(Number(date2) - 1);\n    const e = this._encode(d);\n    return this._decode(e + 1);\n  }\n  /**\n   * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).\n   * @param start Range start.\n   * @param stop Range end.\n   * @param extend If specified, the requested range will be extended to the closest \"nice\" values.\n   */\n  range(start2, stop, { extend = false, visibleRange = [0, 1] } = {}) {\n    let reversed = false;\n    if (start2.getTime() > stop.getTime()) {\n      [start2, stop] = [stop, start2];\n      reversed = true;\n    }\n    const rangeCallback = this._rangeCallback?.(start2, stop);\n    const e0 = this._encode(extend ? this.floor(start2) : this.ceil(start2));\n    const e1 = this._encode(extend ? this.ceil(stop) : this.floor(stop));\n    if (e1 < e0) {\n      return [];\n    }\n    const de = e1 - e0;\n    let startIndex;\n    let endIndex;\n    if (reversed) {\n      startIndex = Math.ceil(e0 + (1 - visibleRange[1]) * de);\n      endIndex = Math.floor(e0 + (1 - visibleRange[0]) * de);\n    } else {\n      startIndex = Math.floor(e0 + visibleRange[0] * de);\n      endIndex = Math.ceil(e0 + visibleRange[1] * de);\n    }\n    const range3 = [];\n    for (let e = startIndex; e <= endIndex; e += 1) {\n      const d = this._decode(e);\n      range3.push(d);\n    }\n    rangeCallback?.();\n    return range3;\n  }\n};\nvar CountableTimeInterval = class extends TimeInterval {\n  getOffset(snapTo, step) {\n    return Math.floor(this._encode(new Date(snapTo))) % step;\n  }\n  /**\n   * Returns a filtered view of this interval representing every step'th date.\n   * It can be a number of minutes, hours, days etc.\n   * Must be a positive integer.\n   * @param step\n   */\n  every(step, options) {\n    let offset4 = 0;\n    let rangeCallback;\n    const unsafeStep = step;\n    step = Math.max(1, Math.round(step));\n    if (unsafeStep !== step) {\n      logger_exports.warnOnce(`interval step of [${unsafeStep}] rounded to [${step}].`);\n    }\n    const { snapTo = \"start\" } = options ?? {};\n    if (typeof snapTo === \"string\") {\n      const initialOffset = offset4;\n      rangeCallback = (start2, stop) => {\n        const s = snapTo === \"start\" ? start2 : stop;\n        offset4 = this.getOffset(s, step);\n        return () => offset4 = initialOffset;\n      };\n    } else if (typeof snapTo === \"number\") {\n      offset4 = this.getOffset(new Date(snapTo), step);\n    } else if (snapTo instanceof Date) {\n      offset4 = this.getOffset(snapTo, step);\n    }\n    const encode13 = (date2) => Math.floor((this._encode(date2) - offset4) / step);\n    const decode13 = (encoded) => this._decode(encoded * step + offset4);\n    return new TimeInterval(encode13, decode13, rangeCallback);\n  }\n};\n\n// packages/ag-charts-community/src/util/time/millisecond.ts\nfunction encode(date2) {\n  return date2.getTime();\n}\nfunction decode(encoded) {\n  return new Date(encoded);\n}\nvar millisecond = new CountableTimeInterval(encode, decode);\n\n// packages/ag-charts-community/src/util/time/duration.ts\nvar durationSecond = 1e3;\nvar durationMinute = durationSecond * 60;\nvar durationHour = durationMinute * 60;\nvar durationDay = durationHour * 24;\nvar durationWeek = durationDay * 7;\nvar durationMonth = durationDay * 30;\nvar durationYear = durationDay * 365;\n\n// packages/ag-charts-community/src/util/time/second.ts\nvar offset = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode2(date2) {\n  return Math.floor((date2.getTime() - offset) / durationSecond);\n}\nfunction decode2(encoded) {\n  return new Date(offset + encoded * durationSecond);\n}\nvar second = new CountableTimeInterval(encode2, decode2);\n\n// packages/ag-charts-community/src/util/time/minute.ts\nvar offset2 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode3(date2) {\n  return Math.floor((date2.getTime() - offset2) / durationMinute);\n}\nfunction decode3(encoded) {\n  return new Date(offset2 + encoded * durationMinute);\n}\nvar minute = new CountableTimeInterval(encode3, decode3);\n\n// packages/ag-charts-community/src/util/time/hour.ts\nvar offset3 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode4(date2) {\n  return Math.floor((date2.getTime() - offset3) / durationHour);\n}\nfunction decode4(encoded) {\n  return new Date(offset3 + encoded * durationHour);\n}\nvar hour = new CountableTimeInterval(encode4, decode4);\n\n// packages/ag-charts-community/src/util/time/day.ts\nfunction encode5(date2) {\n  const tzOffsetMs = date2.getTimezoneOffset() * durationMinute;\n  return Math.floor((date2.getTime() - tzOffsetMs) / durationDay);\n}\nfunction decode5(encoded) {\n  const d = new Date(1970, 0, 1);\n  d.setDate(d.getDate() + encoded);\n  return d;\n}\nvar day = new CountableTimeInterval(encode5, decode5);\n\n// packages/ag-charts-community/src/util/time/week.ts\nfunction weekday(weekStart) {\n  const thursday2 = 4;\n  const dayShift = (7 + weekStart - thursday2) % 7;\n  function encode13(date2) {\n    const tzOffsetMs = date2.getTimezoneOffset() * durationMinute;\n    return Math.floor((date2.getTime() - tzOffsetMs) / durationWeek - dayShift / 7);\n  }\n  function decode13(encoded) {\n    const d = new Date(1970, 0, 1);\n    d.setDate(d.getDate() + encoded * 7 + dayShift);\n    return d;\n  }\n  return new CountableTimeInterval(encode13, decode13);\n}\nvar sunday = weekday(0);\nvar monday = weekday(1);\nvar tuesday = weekday(2);\nvar wednesday = weekday(3);\nvar thursday = weekday(4);\nvar friday = weekday(5);\nvar saturday = weekday(6);\n\n// packages/ag-charts-community/src/util/time/month.ts\nfunction encode6(date2) {\n  return date2.getFullYear() * 12 + date2.getMonth();\n}\nfunction decode6(encoded) {\n  const year2 = Math.floor(encoded / 12);\n  const month2 = encoded - year2 * 12;\n  return new Date(year2, month2, 1);\n}\nvar month = new CountableTimeInterval(encode6, decode6);\n\n// packages/ag-charts-community/src/util/time/year.ts\nfunction encode7(date2) {\n  return date2.getFullYear();\n}\nfunction decode7(encoded) {\n  const d = /* @__PURE__ */ new Date();\n  d.setFullYear(encoded);\n  d.setMonth(0, 1);\n  d.setHours(0, 0, 0, 0);\n  return d;\n}\nvar year = new CountableTimeInterval(encode7, decode7);\n\n// packages/ag-charts-community/src/util/time/utcMinute.ts\nfunction encode8(date2) {\n  return Math.floor(date2.getTime() / durationMinute);\n}\nfunction decode8(encoded) {\n  return new Date(encoded * durationMinute);\n}\nvar utcMinute = new CountableTimeInterval(encode8, decode8);\n\n// packages/ag-charts-community/src/util/time/utcHour.ts\nfunction encode9(date2) {\n  return Math.floor(date2.getTime() / durationHour);\n}\nfunction decode9(encoded) {\n  return new Date(encoded * durationHour);\n}\nvar utcHour = new CountableTimeInterval(encode9, decode9);\n\n// packages/ag-charts-community/src/util/time/utcDay.ts\nfunction encode10(date2) {\n  return Math.floor(date2.getTime() / durationDay);\n}\nfunction decode10(encoded) {\n  const d = /* @__PURE__ */ new Date(0);\n  d.setUTCDate(d.getUTCDate() + encoded);\n  d.setUTCHours(0, 0, 0, 0);\n  return d;\n}\nvar utcDay = new CountableTimeInterval(encode10, decode10);\n\n// packages/ag-charts-community/src/util/time/utcMonth.ts\nfunction encode11(date2) {\n  return date2.getUTCFullYear() * 12 + date2.getUTCMonth();\n}\nfunction decode11(encoded) {\n  const year2 = Math.floor(encoded / 12);\n  const month2 = encoded - year2 * 12;\n  return new Date(Date.UTC(year2, month2, 1));\n}\nvar utcMonth = new CountableTimeInterval(encode11, decode11);\n\n// packages/ag-charts-community/src/util/time/utcYear.ts\nfunction encode12(date2) {\n  return date2.getUTCFullYear();\n}\nfunction decode12(encoded) {\n  const d = /* @__PURE__ */ new Date();\n  d.setUTCFullYear(encoded);\n  d.setUTCMonth(0, 1);\n  d.setUTCHours(0, 0, 0, 0);\n  return d;\n}\nvar utcYear = new CountableTimeInterval(encode12, decode12);\n\n// packages/ag-charts-community/src/util/timeFormat.ts\nvar CONSTANTS = {\n  periods: [\"AM\", \"PM\"],\n  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  months: [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\"\n  ],\n  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n};\nfunction dayOfYear(date2, startOfYear = new Date(date2.getFullYear(), 0, 1)) {\n  const startOffset = date2.getTimezoneOffset() - startOfYear.getTimezoneOffset();\n  const timeDiff = date2.getTime() - startOfYear.getTime() + startOffset * 6e4;\n  const timeOneDay = 36e5 * 24;\n  return Math.floor(timeDiff / timeOneDay);\n}\nfunction weekOfYear(date2, startDay) {\n  const startOfYear = new Date(date2.getFullYear(), 0, 1);\n  const startOfYearDay = startOfYear.getDay();\n  const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;\n  const startOffset = new Date(date2.getFullYear(), 0, firstWeekStartOffset + 1);\n  if (startOffset <= date2) {\n    return Math.floor(dayOfYear(date2, startOffset) / 7) + 1;\n  }\n  return 0;\n}\nvar SUNDAY = 0;\nvar MONDAY = 1;\nvar THURSDAY = 4;\nfunction isoWeekOfYear(date2, year2 = date2.getFullYear()) {\n  const firstOfYear = new Date(year2, 0, 1);\n  const firstOfYearDay = firstOfYear.getDay();\n  const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;\n  const startOffset = new Date(year2, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);\n  if (startOffset <= date2) {\n    return Math.floor(dayOfYear(date2, startOffset) / 7) + 1;\n  }\n  return isoWeekOfYear(date2, year2 - 1);\n}\nfunction timezone(date2) {\n  const offset4 = date2.getTimezoneOffset();\n  const unsignedOffset = Math.abs(offset4);\n  const sign = offset4 > 0 ? \"-\" : \"+\";\n  return `${sign}${pad(Math.floor(unsignedOffset / 60), 2, \"0\")}${pad(Math.floor(unsignedOffset % 60), 2, \"0\")}`;\n}\nvar FORMATTERS = {\n  a: (d) => CONSTANTS.shortDays[d.getDay()],\n  A: (d) => CONSTANTS.days[d.getDay()],\n  b: (d) => CONSTANTS.shortMonths[d.getMonth()],\n  B: (d) => CONSTANTS.months[d.getMonth()],\n  c: \"%x, %X\",\n  d: (d, p) => pad(d.getDate(), 2, p ?? \"0\"),\n  e: \"%_d\",\n  f: (d, p) => pad(d.getMilliseconds() * 1e3, 6, p ?? \"0\"),\n  H: (d, p) => pad(d.getHours(), 2, p ?? \"0\"),\n  I: (d, p) => {\n    const hours = d.getHours() % 12;\n    return hours === 0 ? \"12\" : pad(hours, 2, p ?? \"0\");\n  },\n  j: (d, p) => pad(dayOfYear(d) + 1, 3, p ?? \"0\"),\n  m: (d, p) => pad(d.getMonth() + 1, 2, p ?? \"0\"),\n  M: (d, p) => pad(d.getMinutes(), 2, p ?? \"0\"),\n  L: (d, p) => pad(d.getMilliseconds(), 3, p ?? \"0\"),\n  p: (d) => d.getHours() < 12 ? \"AM\" : \"PM\",\n  Q: (d) => String(d.getTime()),\n  s: (d) => String(Math.floor(d.getTime() / 1e3)),\n  S: (d, p) => pad(d.getSeconds(), 2, p ?? \"0\"),\n  u: (d) => {\n    let day2 = d.getDay();\n    if (day2 < 1)\n      day2 += 7;\n    return String(day2 % 7);\n  },\n  U: (d, p) => pad(weekOfYear(d, SUNDAY), 2, p ?? \"0\"),\n  V: (d, p) => pad(isoWeekOfYear(d), 2, p ?? \"0\"),\n  w: (d, p) => pad(d.getDay(), 2, p ?? \"0\"),\n  W: (d, p) => pad(weekOfYear(d, MONDAY), 2, p ?? \"0\"),\n  x: \"%-m/%-d/%Y\",\n  X: \"%-I:%M:%S %p\",\n  y: (d, p) => pad(d.getFullYear() % 100, 2, p ?? \"0\"),\n  Y: (d, p) => pad(d.getFullYear(), 4, p ?? \"0\"),\n  Z: (d) => timezone(d),\n  \"%\": () => \"%\"\n};\nvar PADS = {\n  _: \" \",\n  \"0\": \"0\",\n  \"-\": \"\"\n};\nfunction pad(value, size, padChar) {\n  const output = String(Math.floor(value));\n  if (output.length >= size) {\n    return output;\n  }\n  return `${padChar.repeat(size - output.length)}${output}`;\n}\nfunction buildFormatter(formatString) {\n  const formatParts = [];\n  while (formatString.length > 0) {\n    let nextEscapeIdx = formatString.indexOf(\"%\");\n    if (nextEscapeIdx !== 0) {\n      const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;\n      formatParts.push(literalPart);\n    }\n    if (nextEscapeIdx < 0)\n      break;\n    const maybePadSpecifier = formatString[nextEscapeIdx + 1];\n    const maybePad = PADS[maybePadSpecifier];\n    if (maybePad != null) {\n      nextEscapeIdx++;\n    }\n    const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];\n    const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];\n    if (typeof maybeFormatter === \"function\") {\n      formatParts.push([maybeFormatter, maybePad]);\n    } else if (typeof maybeFormatter === \"string\") {\n      const formatter = buildFormatter(maybeFormatter);\n      formatParts.push([formatter, maybePad]);\n    } else {\n      formatParts.push(`${maybePad ?? \"\"}${maybeFormatterSpecifier}`);\n    }\n    formatString = formatString.substring(nextEscapeIdx + 2);\n  }\n  return (dateTime) => {\n    const dateTimeAsDate = typeof dateTime === \"number\" ? new Date(dateTime) : dateTime;\n    return formatParts.map((c) => typeof c === \"string\" ? c : c[0](dateTimeAsDate, c[1])).join(\"\");\n  };\n}\n\n// packages/ag-charts-community/src/util/timeFormatDefaults.ts\nfunction dateToNumber(value) {\n  return value instanceof Date ? value.getTime() : value;\n}\nfunction defaultTimeTickFormat(ticks, domain, formatOffset) {\n  const formatString = calculateDefaultTimeTickFormat(ticks, domain, formatOffset);\n  const formatter = buildFormatter(formatString);\n  return (date2) => formatter(date2);\n}\nfunction calculateDefaultTimeTickFormat(ticks, domain, formatOffset = 0) {\n  let minInterval = Infinity;\n  for (let i = 1; i < ticks.length; i++) {\n    minInterval = Math.min(minInterval, Math.abs(ticks[i].valueOf() - ticks[i - 1].valueOf()));\n  }\n  const [d0, d1] = domain.length === 0 ? [0, 0] : findMinMax([domain[0].valueOf(), domain[domain.length - 1].valueOf()]);\n  const startYear = new Date(d0).getFullYear();\n  const stopYear = new Date(d1).getFullYear();\n  const yearChange = stopYear - startYear > 0;\n  const timeFormat = isFinite(minInterval) ? getIntervalLowestGranularityFormat(minInterval, ticks) : getLowestGranularityFormat(ticks[0]);\n  return formatStringBuilder(Math.max(timeFormat - formatOffset, 0), yearChange, ticks);\n}\nfunction getIntervalLowestGranularityFormat(value, ticks) {\n  if (value < durationSecond) {\n    return 0 /* MILLISECOND */;\n  } else if (value < durationMinute) {\n    return 1 /* SECOND */;\n  } else if (value < durationHour) {\n    return 2 /* MINUTE */;\n  } else if (value < durationDay) {\n    return 3 /* HOUR */;\n  } else if (value < durationWeek) {\n    return 4 /* WEEK_DAY */;\n  } else if (value < durationDay * 28 || value < durationDay * 31 && hasDuplicateMonth(ticks)) {\n    return 5 /* SHORT_MONTH */;\n  } else if (value < durationYear) {\n    return 6 /* MONTH */;\n  }\n  return 7 /* YEAR */;\n}\nfunction getLowestGranularityFormat(value) {\n  if (second.floor(value) < value) {\n    return 0 /* MILLISECOND */;\n  } else if (minute.floor(value) < value) {\n    return 1 /* SECOND */;\n  } else if (hour.floor(value) < value) {\n    return 2 /* MINUTE */;\n  } else if (day.floor(value) < value) {\n    return 3 /* HOUR */;\n  } else if (month.floor(value) < value) {\n    if (sunday.floor(value) < value) {\n      return 4 /* WEEK_DAY */;\n    }\n    return 5 /* SHORT_MONTH */;\n  } else if (year.floor(value) < value) {\n    return 6 /* MONTH */;\n  }\n  return 7 /* YEAR */;\n}\nfunction hasDuplicateMonth(ticks) {\n  let prevMonth = new Date(ticks[0]).getMonth();\n  for (let i = 1; i < ticks.length; i++) {\n    const tickMonth = new Date(ticks[i]).getMonth();\n    if (prevMonth === tickMonth) {\n      return true;\n    }\n    prevMonth = tickMonth;\n  }\n  return false;\n}\nfunction formatStringBuilder(defaultTimeFormat, yearChange, ticks) {\n  const firstTick = dateToNumber(ticks[0]);\n  const lastTick = dateToNumber(ticks.at(-1));\n  const extent2 = Math.abs(lastTick - firstTick);\n  const activeYear = yearChange || defaultTimeFormat === 7 /* YEAR */;\n  const activeDate = extent2 === 0;\n  const parts = [\n    [\"hour\", 6 * durationHour, 14 * durationDay, 3 /* HOUR */, \"%I %p\"],\n    [\"hour\", durationMinute, 6 * durationHour, 3 /* HOUR */, \"%I:%M\"],\n    [\"second\", 1e3, 6 * durationHour, 1 /* SECOND */, \":%S\"],\n    [\"ms\", 0, 6 * durationHour, 0 /* MILLISECOND */, \".%L\"],\n    [\"am/pm\", durationMinute, 6 * durationHour, 3 /* HOUR */, \"%p\"],\n    \" \",\n    [\"day\", durationDay, durationWeek, 4 /* WEEK_DAY */, \"%a\"],\n    [\"month\", activeDate ? 0 : durationWeek, 52 * durationWeek, 5 /* SHORT_MONTH */, \"%b %d\"],\n    [\"month\", 5 * durationWeek, 10 * durationYear, 6 /* MONTH */, \"%B\"],\n    \" \",\n    [\"year\", activeYear ? 0 : durationYear, Infinity, 7 /* YEAR */, \"%Y\"]\n  ];\n  const formatParts = parts.filter((v) => {\n    if (typeof v === \"string\") {\n      return true;\n    }\n    const [_, min, max, format] = v;\n    return format >= defaultTimeFormat && min <= extent2 && extent2 < max;\n  }).reduce(\n    (r, next) => {\n      if (typeof next === \"string\") {\n        r.result.push(next);\n      } else if (!r.used.has(next[0])) {\n        r.result.push(next);\n        r.used.add(next[0]);\n      }\n      return r;\n    },\n    { result: [], used: /* @__PURE__ */ new Set() }\n  ).result;\n  const firstFormat = formatParts.findIndex((v) => typeof v !== \"string\");\n  const lastFormat = formatParts.findLastIndex((v) => typeof v !== \"string\");\n  return formatParts.slice(firstFormat, lastFormat + 1).map((v) => typeof v === \"string\" ? v : v[4]).join(\"\").replaceAll(/\\s+/g, \" \").trim();\n}\n\n// packages/ag-charts-community/src/scale/invalidating.ts\nvar Invalidating = (target, propertyKey) => {\n  const mappedProperty = Symbol(String(propertyKey));\n  target[mappedProperty] = void 0;\n  Object.defineProperty(target, propertyKey, {\n    get() {\n      return this[mappedProperty];\n    },\n    set(newValue) {\n      const oldValue = this[mappedProperty];\n      if (oldValue !== newValue) {\n        this[mappedProperty] = newValue;\n        this.invalid = true;\n      }\n    },\n    enumerable: true,\n    configurable: false\n  });\n};\n\n// packages/ag-charts-community/src/scale/scaleUtil.ts\nfunction filterVisibleTicks(ticks, reversed, visibleRange) {\n  if (visibleRange == null || visibleRange[0] === 0 && visibleRange[1] === 1)\n    return ticks;\n  const vt0 = clamp(0, Math.floor(visibleRange[0] * ticks.length), ticks.length);\n  const vt1 = clamp(0, Math.ceil(visibleRange[1] * ticks.length), ticks.length);\n  const t0 = reversed ? ticks.length - vt1 : vt0;\n  const t1 = reversed ? ticks.length - vt0 : vt1;\n  return ticks.slice(t0, t1);\n}\n\n// packages/ag-charts-community/src/scale/bandScale.ts\nvar _BandScale = class _BandScale extends AbstractScale {\n  constructor() {\n    super(...arguments);\n    this.invalid = true;\n    this.range = [0, 1];\n    this.round = false;\n    this.interval = void 0;\n    this._bandwidth = 1;\n    this._step = 1;\n    this._inset = 1;\n    this._rawBandwidth = 1;\n    /**\n     * The ratio of the range that is reserved for space between bands.\n     */\n    this._paddingInner = 0;\n    /**\n     * The ratio of the range that is reserved for space before the first\n     * and after the last band.\n     */\n    this._paddingOuter = 0;\n  }\n  static is(value) {\n    return value instanceof _BandScale;\n  }\n  get bandwidth() {\n    this.refresh();\n    return this._bandwidth;\n  }\n  get step() {\n    this.refresh();\n    return this._step;\n  }\n  get inset() {\n    this.refresh();\n    return this._inset;\n  }\n  get rawBandwidth() {\n    this.refresh();\n    return this._rawBandwidth;\n  }\n  set padding(value) {\n    value = clamp(0, value, 1);\n    this._paddingInner = value;\n    this._paddingOuter = value;\n  }\n  get padding() {\n    return this._paddingInner;\n  }\n  set paddingInner(value) {\n    this.invalid = true;\n    this._paddingInner = clamp(0, value, 1);\n  }\n  get paddingInner() {\n    return this._paddingInner;\n  }\n  set paddingOuter(value) {\n    this.invalid = true;\n    this._paddingOuter = clamp(0, value, 1);\n  }\n  get paddingOuter() {\n    return this._paddingOuter;\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      logger_exports.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n  ticks(_params, domain = this.domain, visibleRange) {\n    return filterVisibleTicks(domain, false, visibleRange);\n  }\n  convert(d, _clamp) {\n    this.refresh();\n    const i = this.getIndex(d);\n    if (i == null || i < 0 || i >= this.domain.length) {\n      return NaN;\n    }\n    return this.ordinalRange(i);\n  }\n  invertNearestIndex(position) {\n    this.refresh();\n    const { domain } = this;\n    if (domain.length === 0)\n      return -1;\n    let low = 0;\n    let high = domain.length - 1;\n    let closestDistance = Infinity;\n    let closestIndex = 0;\n    while (low <= high) {\n      const mid = (high + low) / 2 | 0;\n      const p = this.ordinalRange(mid);\n      const distance2 = Math.abs(p - position);\n      if (distance2 === 0)\n        return mid;\n      if (distance2 < closestDistance) {\n        closestDistance = distance2;\n        closestIndex = mid;\n      }\n      if (p < position) {\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n    return closestIndex;\n  }\n  update() {\n    const count = this.domain.length;\n    if (count === 0)\n      return;\n    const [r0, r1] = this.range;\n    let { _paddingInner: paddingInner } = this;\n    const { _paddingOuter: paddingOuter, round: round5 } = this;\n    const rangeDistance = r1 - r0;\n    let rawStep;\n    if (count === 1) {\n      paddingInner = 0;\n      rawStep = rangeDistance * (1 - paddingOuter * 2);\n    } else {\n      rawStep = rangeDistance / Math.max(1, count - paddingInner + paddingOuter * 2);\n    }\n    const step = round5 ? Math.floor(rawStep) : rawStep;\n    let inset = r0 + (rangeDistance - step * (count - paddingInner)) / 2;\n    let bandwidth = step * (1 - paddingInner);\n    if (round5) {\n      inset = Math.round(inset);\n      bandwidth = Math.round(bandwidth);\n    }\n    this._step = step;\n    this._inset = inset;\n    this._bandwidth = bandwidth;\n    this._rawBandwidth = rawStep * (1 - paddingInner);\n  }\n  ordinalRange(i) {\n    const { _inset: inset, _step: step, range: range3 } = this;\n    const min = Math.min(range3[0], range3[1]);\n    const max = Math.max(range3[0], range3[1]);\n    return clamp(min, inset + step * i, max);\n  }\n};\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"range\", 2);\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"round\", 2);\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"interval\", 2);\nvar BandScale = _BandScale;\n\n// packages/ag-charts-community/src/scale/categoryScale.ts\nvar CategoryScale = class extends BandScale {\n  constructor() {\n    super(...arguments);\n    this.type = \"band\";\n    /**\n     * Maps datum to its index in the {@link domain} array.\n     * Used to check for duplicate data (not allowed).\n     */\n    this.index = void 0;\n    /**\n     * Contains unique data only.\n     */\n    this._domain = [];\n  }\n  set domain(values) {\n    if (this._domain === values)\n      return;\n    this.invalid = true;\n    this._domain = values;\n    this.index = void 0;\n  }\n  get domain() {\n    return this._domain;\n  }\n  normalizeDomains(...domains) {\n    let normalizedDomain = void 0;\n    const seenDomains = /* @__PURE__ */ new Set();\n    let animatable = true;\n    for (const domain of domains) {\n      if (seenDomains.has(domain))\n        continue;\n      seenDomains.add(domain);\n      if (normalizedDomain == null) {\n        normalizedDomain = deduplicateCategories(domain);\n      } else {\n        animatable && (animatable = domainOrderedToNormalizedDomain(domain, normalizedDomain));\n        normalizedDomain = deduplicateCategories([...normalizedDomain, ...domain]);\n      }\n    }\n    normalizedDomain ?? (normalizedDomain = []);\n    return { domain: normalizedDomain, animatable };\n  }\n  toDomain(_value) {\n    return void 0;\n  }\n  invert(position, nearest = false) {\n    this.refresh();\n    const offset4 = nearest ? this.bandwidth / 2 : 0;\n    const index = this.invertNearestIndex(Math.max(0, position - offset4));\n    const matches = nearest || position === this.ordinalRange(index);\n    return matches ? this.domain[index] : void 0;\n  }\n  getIndex(value) {\n    let { index } = this;\n    if (index == null) {\n      const { domain } = this;\n      index = /* @__PURE__ */ new Map();\n      for (let i = 0; i < domain.length; i++) {\n        index.set(dateToNumber(domain[i]), i);\n      }\n      this.index = index;\n    }\n    return index.get(dateToNumber(value));\n  }\n};\nfunction deduplicateCategories(d) {\n  let domain;\n  const uniqueValues = /* @__PURE__ */ new Set();\n  for (const value of d) {\n    const key = dateToNumber(value);\n    const lastSize = uniqueValues.size;\n    uniqueValues.add(key);\n    const isUniqueValue = uniqueValues.size !== lastSize;\n    if (isUniqueValue) {\n      domain?.push(value);\n    } else {\n      domain ?? (domain = d.slice(0, uniqueValues.size));\n    }\n  }\n  return domain ?? d;\n}\nfunction domainOrderedToNormalizedDomain(domain, normalizedDomain) {\n  let normalizedIndex = -1;\n  for (const value of domain) {\n    const normalizedNextIndex = normalizedDomain.indexOf(value);\n    if (normalizedNextIndex === -1) {\n      normalizedIndex = Infinity;\n    } else if (normalizedNextIndex <= normalizedIndex) {\n      return false;\n    } else {\n      normalizedIndex = normalizedNextIndex;\n    }\n  }\n  return true;\n}\n\n// packages/ag-charts-community/src/util/properties.ts\nvar BaseProperties = class {\n  set(properties) {\n    const { className = this.constructor.name } = this.constructor;\n    if (typeof properties !== \"object\") {\n      logger_exports.warn(`unable to set ${className} - expecting a properties object`);\n      return this;\n    }\n    const keys = new Set(Object.keys(properties));\n    for (const propertyKey of listDecoratedProperties(this)) {\n      if (keys.has(propertyKey)) {\n        const value = properties[propertyKey];\n        const self = this;\n        if (isProperties(self[propertyKey])) {\n          if (self[propertyKey] instanceof PropertiesArray) {\n            const array2 = self[propertyKey].reset(value);\n            if (array2 != null) {\n              self[propertyKey] = array2;\n            } else {\n              logger_exports.warn(`unable to set [${propertyKey}] - expecting a properties array`);\n            }\n          } else {\n            self[propertyKey].set(value);\n          }\n        } else {\n          self[propertyKey] = value;\n        }\n        keys.delete(propertyKey);\n      }\n    }\n    for (const unknownKey of keys) {\n      logger_exports.warn(`unable to set [${unknownKey}] in ${className} - property is unknown`);\n    }\n    return this;\n  }\n  isValid(warningPrefix) {\n    return listDecoratedProperties(this).every((propertyKey) => {\n      const { optional } = extractDecoratedPropertyMetadata(this, propertyKey);\n      const valid = optional === true || typeof this[propertyKey] !== \"undefined\";\n      if (!valid) {\n        logger_exports.warnOnce(`${warningPrefix ?? \"\"}[${propertyKey}] is required.`);\n      }\n      return valid;\n    });\n  }\n  toJson() {\n    return listDecoratedProperties(this).reduce((object2, propertyKey) => {\n      const propertyValue = this[propertyKey];\n      object2[propertyKey] = isProperties(propertyValue) ? propertyValue.toJson() : propertyValue;\n      return object2;\n    }, {});\n  }\n};\nvar PropertiesArray = class _PropertiesArray extends Array {\n  constructor(itemFactory, ...properties) {\n    super(properties.length);\n    const isConstructor = (value2) => Boolean(value2?.prototype?.constructor?.name);\n    const value = isConstructor(itemFactory) ? (params) => new itemFactory().set(params) : itemFactory;\n    Object.defineProperty(this, \"itemFactory\", { value, enumerable: false, configurable: false });\n    this.set(properties);\n  }\n  set(properties) {\n    if (isArray(properties)) {\n      this.length = properties.length;\n      for (let i = 0; i < properties.length; i++) {\n        this[i] = this.itemFactory(properties[i]);\n      }\n    }\n    return this;\n  }\n  reset(properties) {\n    if (Array.isArray(properties)) {\n      return new _PropertiesArray(this.itemFactory, ...properties);\n    }\n  }\n  toJson() {\n    return this.map((value) => value?.toJson?.() ?? value);\n  }\n};\nfunction isProperties(value) {\n  return value instanceof BaseProperties || value instanceof PropertiesArray;\n}\n\n// packages/ag-charts-community/src/util/validation.ts\nfunction Validate(predicate, options = {}) {\n  const { optional = false, property: overrideProperty } = options;\n  return addTransformToInstanceProperty(\n    (target, property, value) => {\n      const context = { ...options, target, property };\n      if (optional && typeof value === \"undefined\" || predicate(value, context)) {\n        if (isProperties(target[property]) && !isProperties(value)) {\n          target[property].set(value);\n          return target[property];\n        }\n        return value;\n      }\n      const cleanKey = overrideProperty ?? String(property).replace(/^_*/, \"\");\n      const targetName = target.constructor.className ?? target.constructor.name.replace(/Properties$/, \"\");\n      const valueString = stringifyValue(value, 50);\n      logger_exports.warn(\n        `Property [${cleanKey}] of [${targetName}] cannot be set to [${valueString}]${predicate.message ? `; expecting ${getPredicateMessage(predicate, context)}` : \"\"}, ignoring.`\n      );\n      return BREAK_TRANSFORM_CHAIN;\n    },\n    void 0,\n    { optional }\n  );\n}\nvar AND = (...predicates) => {\n  const messages = [];\n  return predicateWithMessage(\n    (value, ctx) => {\n      messages.length = 0;\n      return predicates.every((predicate) => {\n        const isValid = predicate(value, ctx);\n        if (!isValid) {\n          messages.push(getPredicateMessage(predicate, ctx));\n        }\n        return isValid;\n      });\n    },\n    () => messages.filter(Boolean).join(\" AND \")\n  );\n};\nvar OR = (...predicates) => predicateWithMessage(\n  (value, ctx) => predicates.some((predicate) => predicate(value, ctx)),\n  (ctx) => predicates.map(getPredicateMessageMapper(ctx)).filter(Boolean).join(\" OR \")\n);\nvar OBJECT = attachObjectRestrictions(\n  predicateWithMessage(\n    (value, ctx) => isProperties(value) || isObject(value) && isProperties(ctx.target[ctx.property]),\n    \"a properties object\"\n  )\n);\nvar PLAIN_OBJECT = attachObjectRestrictions(predicateWithMessage((value) => isObject(value), \"an object\"));\nvar BOOLEAN = predicateWithMessage(isBoolean, \"a boolean\");\nvar FUNCTION = predicateWithMessage(isFunction, \"a function\");\nvar STRING = predicateWithMessage(isString, \"a string\");\nvar NUMBER = attachNumberRestrictions(predicateWithMessage(isFiniteNumber, \"a number\"));\nvar REAL_NUMBER = predicateWithMessage((value) => isNumber(value) && !isNaN(value), \"a real number\");\nvar NAN = predicateWithMessage((value) => isNumber(value) && isNaN(value), \"NaN\");\nvar POSITIVE_NUMBER = NUMBER.restrict({ min: 0 });\nvar RATIO = NUMBER.restrict({ min: 0, max: 1 });\nvar NUMBER_OR_NAN = OR(NUMBER, NAN);\nvar ARRAY = attachArrayRestrictions(predicateWithMessage(isArray, \"an array\"));\nvar ARRAY_OF = (predicate, message) => predicateWithMessage(\n  (value, ctx) => isArray(value) && value.every((item) => predicate(item, ctx)),\n  (ctx) => {\n    const arrayMessage = getPredicateMessage(ARRAY, ctx) ?? \"\";\n    if (typeof message === \"function\") {\n      return `${arrayMessage} of ${message(ctx)}`;\n    }\n    return message ? `${arrayMessage} of ${message}` : arrayMessage;\n  }\n);\nvar isComparable2 = (value) => isFiniteNumber(value) || isValidDate(value);\nvar LESS_THAN = (otherField) => predicateWithMessage(\n  (v, ctx) => !isComparable2(v) || !isComparable2(ctx.target[otherField]) || v < ctx.target[otherField],\n  `to be less than ${otherField}`\n);\nvar GREATER_THAN = (otherField) => predicateWithMessage(\n  (v, ctx) => !isComparable2(v) || !isComparable2(ctx.target[otherField]) || v > ctx.target[otherField],\n  `to be greater than ${otherField}`\n);\nvar DATE = predicateWithMessage(isValidDate, \"Date object\");\nvar DATE_OR_DATETIME_MS = OR(DATE, POSITIVE_NUMBER);\nvar colorMessage = `A color string can be in one of the following formats to be valid: #rgb, #rrggbb, rgb(r, g, b), rgba(r, g, b, a) or a CSS color name such as 'white', 'orange', 'cyan', etc`;\nvar COLOR_STRING = predicateWithMessage(\n  (v) => isString(v) && Color.validColorString(v),\n  `color String. ${colorMessage}`\n);\nvar COLOR_GRADIENT = attachObjectRestrictions(\n  predicateWithMessage((value) => isObject(value) && value.type === \"gradient\", \"a color gradient object\")\n);\nvar COLOR_STRING_ARRAY = predicateWithMessage(ARRAY_OF(COLOR_STRING), `color strings. ${colorMessage}`);\nvar BOOLEAN_ARRAY = ARRAY_OF(BOOLEAN, \"boolean values\");\nvar NUMBER_ARRAY = ARRAY_OF(NUMBER, \"numbers\");\nvar STRING_ARRAY = ARRAY_OF(STRING, \"strings\");\nvar DATE_ARRAY = predicateWithMessage(ARRAY_OF(DATE), \"Date objects\");\nvar OBJECT_ARRAY = predicateWithMessage(ARRAY_OF(OBJECT), \"objects\");\nvar LINE_CAP = UNION([\"butt\", \"round\", \"square\"], \"a line cap\");\nvar LINE_JOIN = UNION([\"round\", \"bevel\", \"miter\"], \"a line join\");\nvar LINE_STYLE = UNION([\"solid\", \"dashed\", \"dotted\"], \"a line style\");\nvar LINE_DASH = predicateWithMessage(\n  ARRAY_OF(POSITIVE_NUMBER),\n  \"numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels.\"\n);\nvar POSITION = UNION([\"top\", \"right\", \"bottom\", \"left\"], \"a position\");\nvar FONT_STYLE = UNION([\"normal\", \"italic\", \"oblique\"], \"a font style\");\nvar FONT_WEIGHT = OR(\n  UNION([\"normal\", \"bold\", \"bolder\", \"lighter\"], \"a font weight\"),\n  NUMBER.restrict({ min: 1, max: 1e3 })\n);\nvar TEXT_WRAP = UNION([\"never\", \"always\", \"hyphenate\", \"on-space\"], \"a text wrap strategy\");\nvar TEXT_ALIGN = UNION([\"left\", \"center\", \"right\"], \"a text align\");\nvar VERTICAL_ALIGN = UNION([\"top\", \"middle\", \"bottom\"], \"a vertical align\");\nvar OVERFLOW_STRATEGY = UNION([\"ellipsis\", \"hide\"], \"an overflow strategy\");\nvar DIRECTION = UNION([\"horizontal\", \"vertical\"], \"a direction\");\nvar PLACEMENT = UNION([\"inside\", \"outside\"], \"a placement\");\nvar INTERACTION_RANGE = OR(UNION([\"exact\", \"nearest\"], \"interaction range\"), NUMBER);\nvar LABEL_PLACEMENT = UNION([\"top\", \"bottom\", \"left\", \"right\"]);\nfunction UNION(options, message = \"a\") {\n  return predicateWithMessage(\n    (v, ctx) => {\n      const option = options.find((o) => {\n        const value = typeof o === \"string\" ? o : o.value;\n        return v === value;\n      });\n      if (option == null)\n        return false;\n      if (typeof option !== \"string\" && (option.deprecated === true || option.deprecatedTo != null)) {\n        const messages = [`Property [%s] with value '${option.value}' is deprecated.`];\n        if (option.deprecatedTo) {\n          messages.push(`Use ${option.deprecatedTo} instead.`);\n        }\n        logger_exports.warnOnce(messages.join(\" \"), ctx.property);\n      }\n      return true;\n    },\n    `${message} keyword such as ${joinUnionOptions(options)}`\n  );\n}\nvar MIN_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), LESS_THAN(\"maxSpacing\")), NAN);\nvar MAX_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), GREATER_THAN(\"minSpacing\")), NAN);\nfunction predicateWithMessage(predicate, message) {\n  predicate.message = message;\n  return predicate;\n}\nfunction joinUnionOptions(options) {\n  const values = options.filter((option) => typeof option === \"string\" || option.undocumented !== true).map((option) => `'${typeof option === \"string\" ? option : option.value}'`);\n  if (values.length === 1) {\n    return values[0];\n  }\n  const lastValue = values.pop();\n  return `${values.join(\", \")} or ${lastValue}`;\n}\nfunction getPredicateMessage(predicate, ctx) {\n  return isFunction(predicate.message) ? predicate.message(ctx) : predicate.message;\n}\nfunction getPredicateMessageMapper(ctx) {\n  return (predicate) => getPredicateMessage(predicate, ctx);\n}\nfunction attachArrayRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict({ length: length2, minLength } = {}) {\n      let message = \"an array\";\n      if (isNumber(minLength) && minLength > 0) {\n        message = \"a non-empty array\";\n      } else if (isNumber(length2)) {\n        message = `an array of length ${length2}`;\n      }\n      return predicateWithMessage(\n        (value) => isArray(value) && (isNumber(length2) ? value.length === length2 : true) && (isNumber(minLength) ? value.length >= minLength : true),\n        message\n      );\n    }\n  });\n}\nfunction attachNumberRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict({ min, max } = {}) {\n      const message = [\"a number\"];\n      const hasMin = isNumber(min);\n      const hasMax = isNumber(max);\n      if (hasMin && hasMax) {\n        message.push(`between ${min} and ${max} inclusive`);\n      } else if (hasMin) {\n        message.push(`greater than or equal to ${min}`);\n      } else if (hasMax) {\n        message.push(`less than or equal to ${max}`);\n      }\n      return predicateWithMessage(\n        (value) => isFiniteNumber(value) && (hasMin ? value >= min : true) && (hasMax ? value <= max : true),\n        message.join(\" \")\n      );\n    }\n  });\n}\nfunction attachObjectRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict(objectType) {\n      return predicateWithMessage(\n        (value) => value instanceof objectType,\n        (ctx) => getPredicateMessage(predicate, ctx) ?? `an instance of ${objectType.name}`\n      );\n    }\n  });\n}\n\n// packages/ag-charts-community/src/motion/resetMotion.ts\nvar resetMotion_exports = {};\n__export(resetMotion_exports, {\n  resetMotion: () => resetMotion\n});\nfunction resetMotion(selectionsOrNodes, propsFn) {\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  for (const selection of selections) {\n    for (const node of selection.nodes()) {\n      const from3 = propsFn(node, node.datum);\n      node.setProperties(from3);\n    }\n    selection.cleanup();\n  }\n  for (const node of nodes) {\n    const from3 = propsFn(node, node.datum);\n    node.setProperties(from3);\n  }\n}\n\n// packages/ag-charts-community/src/util/debug.ts\nvar LONG_TIME_PERIOD_THRESHOLD = 2e3;\nvar timeOfLastLog = Date.now();\nvar logTimeGap = () => {\n  const timeSinceLastLog = Date.now() - timeOfLastLog;\n  if (timeSinceLastLog > LONG_TIME_PERIOD_THRESHOLD) {\n    const prettyDuration = (Math.floor(timeSinceLastLog / 100) / 10).toFixed(1);\n    logger_exports.log(`**** ${prettyDuration}s since last log message ****`);\n  }\n  timeOfLastLog = Date.now();\n};\nvar Debug = {\n  create(...debugSelectors) {\n    const resultFn = (...logContent) => {\n      if (Debug.check(...debugSelectors)) {\n        if (typeof logContent[0] === \"function\") {\n          logContent = toArray(logContent[0]());\n        }\n        logTimeGap();\n        logger_exports.log(...logContent);\n      }\n    };\n    return Object.assign(resultFn, {\n      check: () => Debug.check(...debugSelectors),\n      group: (name, cb) => {\n        if (Debug.check(...debugSelectors)) {\n          return logger_exports.logGroup(name, cb);\n        }\n        return cb();\n      }\n    });\n  },\n  check(...debugSelectors) {\n    if (debugSelectors.length === 0) {\n      debugSelectors.push(true);\n    }\n    const chartDebug = toArray(getWindow(\"agChartsDebug\"));\n    return chartDebug.some((selector) => debugSelectors.includes(selector));\n  }\n};\n\n// packages/ag-charts-community/src/scene/canvas/canvasUtil.ts\nfunction clearContext({\n  context,\n  pixelRatio,\n  width: width2,\n  height: height2\n}) {\n  context.save();\n  context.resetTransform();\n  context.clearRect(0, 0, Math.ceil(width2 * pixelRatio), Math.ceil(height2 * pixelRatio));\n  context.restore();\n}\nfunction debugContext(ctx) {\n  if (Debug.check(\"canvas\")) {\n    const save = ctx.save.bind(ctx);\n    const restore = ctx.restore.bind(ctx);\n    let depth = 0;\n    Object.assign(ctx, {\n      save() {\n        save();\n        depth++;\n      },\n      restore() {\n        if (depth === 0) {\n          throw new Error(\"AG Charts - Unable to restore() past depth 0\");\n        }\n        restore();\n        depth--;\n      },\n      verifyDepthZero() {\n        if (depth !== 0) {\n          throw new Error(`AG Charts - Save/restore depth is non-zero: ${depth}`);\n        }\n      }\n    });\n  }\n}\n\n// packages/ag-charts-community/src/scene/canvas/hdpiOffscreenCanvas.ts\nfunction canvasDimensions(width2, height2, pixelRatio) {\n  return [Math.round(width2 * pixelRatio), Math.round(height2 * pixelRatio)];\n}\nvar HdpiOffscreenCanvas = class {\n  constructor(options) {\n    const { width: width2, height: height2, pixelRatio, willReadFrequently = false } = options;\n    this.width = width2;\n    this.height = height2;\n    this.pixelRatio = pixelRatio;\n    const [canvasWidth, canvasHeight] = canvasDimensions(width2, height2, pixelRatio);\n    this.canvas = new OffscreenCanvas(canvasWidth, canvasHeight);\n    this.context = this.canvas.getContext(\"2d\", { willReadFrequently });\n    this.context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    debugContext(this.context);\n  }\n  drawImage(context, dx = 0, dy = 0) {\n    return context.drawImage(this.canvas, dx, dy);\n  }\n  transferToImageBitmap() {\n    return this.canvas.transferToImageBitmap();\n  }\n  resize(width2, height2, pixelRatio) {\n    if (!(width2 > 0 && height2 > 0))\n      return;\n    const { canvas, context } = this;\n    if (width2 !== this.width || height2 !== this.height || pixelRatio !== this.pixelRatio) {\n      const [canvasWidth, canvasHeight] = canvasDimensions(width2, height2, pixelRatio);\n      canvas.width = canvasWidth;\n      canvas.height = canvasHeight;\n    }\n    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    this.width = width2;\n    this.height = height2;\n    this.pixelRatio = pixelRatio;\n  }\n  clear() {\n    clearContext(this);\n  }\n  destroy() {\n    this.canvas.width = 0;\n    this.canvas.height = 0;\n    this.context.clearRect(0, 0, 0, 0);\n    this.canvas = null;\n    this.context = null;\n    Object.freeze(this);\n  }\n};\n\n// packages/ag-charts-community/src/scale/colorScale.ts\nvar convertColorStringToOklcha = (v) => {\n  const color = Color.fromString(v);\n  const [l, c, h] = Color.RGBtoOKLCH(color.r, color.g, color.b);\n  return { l, c, h, a: color.a };\n};\nvar delta = 1e-6;\nvar isAchromatic = (x) => x.c < delta || x.l < delta || x.l > 1 - delta;\nvar interpolateOklch = (x, y, d) => {\n  d = clamp(0, d, 1);\n  let h;\n  if (isAchromatic(x)) {\n    h = y.h;\n  } else if (isAchromatic(y)) {\n    h = x.h;\n  } else {\n    const xH = x.h;\n    let yH = y.h;\n    const deltaH = y.h - x.h;\n    if (deltaH > 180) {\n      yH -= 360;\n    } else if (deltaH < -180) {\n      yH += 360;\n    }\n    h = xH * (1 - d) + yH * d;\n  }\n  const c = x.c * (1 - d) + y.c * d;\n  const l = x.l * (1 - d) + y.l * d;\n  const a = x.a * (1 - d) + y.a * d;\n  return Color.fromOKLCH(l, c, h, a);\n};\nvar ColorScale = class extends AbstractScale {\n  constructor() {\n    super(...arguments);\n    this.type = \"color\";\n    this.invalid = true;\n    this.domain = [0, 1];\n    this.range = [\"red\", \"blue\"];\n    this.parsedRange = this.range.map(convertColorStringToOklcha);\n  }\n  update() {\n    const { domain, range: range3 } = this;\n    if (domain.length < 2) {\n      logger_exports.warnOnce(\"`colorDomain` should have at least 2 values.\");\n      if (domain.length === 0) {\n        domain.push(0, 1);\n      } else if (domain.length === 1) {\n        domain.push(domain[0] + 1);\n      }\n    }\n    for (let i = 1; i < domain.length; i++) {\n      const a = domain[i - 1];\n      const b = domain[i];\n      if (a >= b) {\n        logger_exports.warnOnce(\"`colorDomain` values should be supplied in ascending order.\");\n        domain.sort((a2, b2) => a2 - b2);\n        break;\n      }\n    }\n    if (range3.length < domain.length) {\n      for (let i = range3.length; i < domain.length; i++) {\n        range3.push(range3.length > 0 ? range3[0] : \"black\");\n      }\n    }\n    this.parsedRange = this.range.map(convertColorStringToOklcha);\n  }\n  normalizeDomains(...domains) {\n    return { domain: domains.flat(), animatable: true };\n  }\n  toDomain() {\n    return;\n  }\n  convert(x) {\n    this.refresh();\n    const { domain, range: range3, parsedRange } = this;\n    const d0 = domain[0];\n    const d1 = domain.at(-1);\n    const r0 = range3[0];\n    const r1 = range3[range3.length - 1];\n    if (x <= d0) {\n      return r0;\n    }\n    if (x >= d1) {\n      return r1;\n    }\n    let index;\n    let q;\n    if (domain.length === 2) {\n      const t = (x - d0) / (d1 - d0);\n      const step = 1 / (range3.length - 1);\n      index = range3.length <= 2 ? 0 : Math.min(Math.floor(t * (range3.length - 1)), range3.length - 2);\n      q = (t - index * step) / step;\n    } else {\n      for (index = 0; index < domain.length - 2; index++) {\n        if (x < domain[index + 1]) {\n          break;\n        }\n      }\n      const a = domain[index];\n      const b = domain[index + 1];\n      q = (x - a) / (b - a);\n    }\n    const c0 = parsedRange[index];\n    const c1 = parsedRange[index + 1];\n    return interpolateOklch(c0, c1, q).toRgbaString();\n  }\n  invert() {\n    return;\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      logger_exports.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n};\n__decorateClass([\n  Invalidating\n], ColorScale.prototype, \"domain\", 2);\n__decorateClass([\n  Invalidating\n], ColorScale.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/scene/gradient/gradient.ts\nvar Gradient = class {\n  constructor(colorSpace, stops = [], bbox) {\n    this.colorSpace = colorSpace;\n    this.stops = stops;\n    this.bbox = bbox;\n    this._cache = void 0;\n  }\n  createGradient(ctx, shapeBbox) {\n    const bbox = this.bbox ?? shapeBbox;\n    if (this._cache != null && this._cache.ctx === ctx && this._cache.bbox.equals(bbox)) {\n      return this._cache.gradient;\n    }\n    const { stops, colorSpace } = this;\n    if (stops.length === 0)\n      return;\n    if (stops.length === 1)\n      return stops[0].color;\n    let gradient2 = this.createCanvasGradient(ctx, bbox);\n    if (gradient2 == null)\n      return;\n    const isOkLch = colorSpace === \"oklch\";\n    const step = 0.05;\n    let c0 = stops[0];\n    gradient2.addColorStop(c0.offset, c0.color);\n    for (let i = 1; i < stops.length; i += 1) {\n      const c1 = stops[i];\n      if (isOkLch) {\n        const scale2 = new ColorScale();\n        scale2.domain = [c0.offset, c1.offset];\n        scale2.range = [c0.color, c1.color];\n        for (let offset4 = c0.offset + step; offset4 < c1.offset; offset4 += step) {\n          gradient2.addColorStop(offset4, scale2.convert(offset4));\n        }\n      }\n      gradient2.addColorStop(c1.offset, c1.color);\n      c0 = c1;\n    }\n    if (\"createPattern\" in gradient2) {\n      gradient2 = gradient2.createPattern();\n    }\n    this._cache = { ctx, bbox, gradient: gradient2 };\n    return gradient2;\n  }\n};\n\n// packages/ag-charts-community/src/util/angle.ts\nvar twoPi = Math.PI * 2;\nvar halfPi = Math.PI / 2;\nfunction normalizeAngle360(radians) {\n  radians %= twoPi;\n  radians += twoPi;\n  radians %= twoPi;\n  return radians;\n}\nfunction normalizeAngle360Inclusive(radians) {\n  radians %= twoPi;\n  radians += twoPi;\n  if (radians !== twoPi) {\n    radians %= twoPi;\n  }\n  return radians;\n}\nfunction normalizeAngle180(radians) {\n  radians %= twoPi;\n  if (radians < -Math.PI) {\n    radians += twoPi;\n  } else if (radians >= Math.PI) {\n    radians -= twoPi;\n  }\n  return radians;\n}\nfunction isBetweenAngles(targetAngle, startAngle, endAngle) {\n  const t = normalizeAngle360(targetAngle);\n  const a0 = normalizeAngle360(startAngle);\n  const a1 = normalizeAngle360(endAngle);\n  if (a0 < a1) {\n    return a0 <= t && t <= a1;\n  } else if (a0 > a1) {\n    return a0 <= t || t <= a1;\n  } else {\n    return true;\n  }\n}\nfunction toRadians(degrees) {\n  return degrees / 180 * Math.PI;\n}\nfunction toDegrees(radians) {\n  return radians / Math.PI * 180;\n}\nfunction angleBetween(angle0, angle1) {\n  angle0 = normalizeAngle360(angle0);\n  angle1 = normalizeAngle360(angle1);\n  return angle1 - angle0 + (angle0 > angle1 ? twoPi : 0);\n}\nfunction getAngleRatioRadians(angle2) {\n  const normalizedAngle = normalizeAngle360(angle2);\n  if (normalizedAngle <= halfPi) {\n    return normalizedAngle / halfPi;\n  } else if (normalizedAngle <= Math.PI) {\n    return (Math.PI - normalizedAngle) / halfPi;\n  } else if (normalizedAngle <= 1.5 * Math.PI) {\n    return (normalizedAngle - Math.PI) / halfPi;\n  } else {\n    return (twoPi - normalizedAngle) / halfPi;\n  }\n}\n\n// packages/ag-charts-community/src/scene/gradient/linearGradient.ts\nvar LinearGradient = class extends Gradient {\n  constructor(colorSpace, stops, angle2 = 0, bbox) {\n    super(colorSpace, stops, bbox);\n    this.angle = angle2;\n  }\n  createCanvasGradient(ctx, bbox) {\n    const angleOffset = 90;\n    const { angle: angle2 } = this;\n    const radians = normalizeAngle360(toRadians(angle2 + angleOffset));\n    const cos = Math.cos(radians);\n    const sin = Math.sin(radians);\n    const w = bbox.width;\n    const h = bbox.height;\n    const cx = bbox.x + w * 0.5;\n    const cy = bbox.y + h * 0.5;\n    const diagonal = Math.sqrt(h * h + w * w) / 2;\n    const diagonalAngle = Math.atan2(h, w);\n    let quarteredAngle;\n    if (radians < Math.PI / 2) {\n      quarteredAngle = radians;\n    } else if (radians < Math.PI) {\n      quarteredAngle = Math.PI - radians;\n    } else if (radians < 1.5 * Math.PI) {\n      quarteredAngle = radians - Math.PI;\n    } else {\n      quarteredAngle = 2 * Math.PI - radians;\n    }\n    const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));\n    return ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);\n  }\n};\n\n// packages/ag-charts-community/src/scene/gradient/stops.ts\nvar StopProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.color = \"black\";\n  }\n};\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], StopProperties.prototype, \"stop\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], StopProperties.prototype, \"color\", 2);\nfunction stopsAreAscending(fills) {\n  let currentStop;\n  for (const { stop } of fills) {\n    if (stop == null) {\n      continue;\n    } else if (currentStop != null && stop < currentStop) {\n      return false;\n    }\n    currentStop = stop;\n  }\n  return true;\n}\nfunction discreteColorStops(colorStops) {\n  return colorStops.flatMap((colorStop, i) => {\n    const { offset: offset4 } = colorStop;\n    const nextColor = colorStops.at(i + 1)?.color;\n    return nextColor != null ? [colorStop, { offset: offset4, color: nextColor }] : [colorStop];\n  });\n}\nfunction getDefaultColorStops(defaultColorStops, fillMode) {\n  const stopOffset = fillMode === \"discrete\" ? 1 : 0;\n  const colorStops = defaultColorStops.map(\n    (color, index, { length: length2 }) => ({\n      offset: (index + stopOffset) / (length2 - 1 + stopOffset),\n      color\n    })\n  );\n  return fillMode === \"discrete\" ? discreteColorStops(colorStops) : colorStops;\n}\nfunction getColorStops(fills, defaultColorStops, domain, fillMode = \"continuous\") {\n  if (fills.length === 0) {\n    return getDefaultColorStops(defaultColorStops, fillMode);\n  } else if (!stopsAreAscending(fills)) {\n    logger_exports.warnOnce(`[fills] must have the stops defined in ascending order`);\n    return [];\n  }\n  const d0 = Math.min(...domain);\n  const d1 = Math.max(...domain);\n  const isDiscrete = fillMode === \"discrete\";\n  const offsets = new Float64Array(fills.length);\n  let previousDefinedStopIndex = 0;\n  let nextDefinedStopIndex = -1;\n  for (let i = 0; i < fills.length; i += 1) {\n    const colorStop = fills[i];\n    if (i >= nextDefinedStopIndex) {\n      nextDefinedStopIndex = fills.length - 1;\n      for (let j = i + 1; j < fills.length; j += 1) {\n        if (fills[j].stop != null) {\n          nextDefinedStopIndex = j;\n          break;\n        }\n      }\n    }\n    let { stop } = colorStop;\n    if (stop == null) {\n      const stop0 = fills[previousDefinedStopIndex].stop;\n      const stop1 = fills[nextDefinedStopIndex].stop;\n      const value0 = stop0 ?? d0;\n      const value1 = stop1 ?? d1;\n      const stopOffset = isDiscrete && stop0 == null ? 1 : 0;\n      stop = value0 + (value1 - value0) * (i - previousDefinedStopIndex + stopOffset) / (nextDefinedStopIndex - previousDefinedStopIndex + stopOffset);\n    } else {\n      previousDefinedStopIndex = i;\n    }\n    offsets[i] = Math.max(0, Math.min(1, (stop - d0) / (d1 - d0)));\n  }\n  let lastDefinedColor = fills.find((c) => c.color != null)?.color;\n  let colorScale;\n  const colorStops = fills.map(({ color }, i) => {\n    const offset4 = offsets[i];\n    if (color != null) {\n      lastDefinedColor = color;\n    } else if (lastDefinedColor != null) {\n      color = lastDefinedColor;\n    } else {\n      if (colorScale == null) {\n        colorScale = new ColorScale();\n        colorScale.domain = [0, 1];\n        colorScale.range = defaultColorStops;\n      }\n      color = colorScale.convert(offset4);\n    }\n    return { offset: offset4, color };\n  });\n  return fillMode === \"discrete\" ? discreteColorStops(colorStops) : colorStops;\n}\n\n// packages/ag-charts-community/src/scene/util/fill.ts\nfunction isGradientFill(fill) {\n  return fill !== null && isObject(fill) && fill.type == \"gradient\";\n}\n\n// packages/ag-charts-community/src/scene/util/pixel.ts\nfunction align(pixelRatio, start2, length2) {\n  const alignedStart = Math.round(start2 * pixelRatio) / pixelRatio;\n  if (length2 == null) {\n    return alignedStart;\n  } else if (length2 === 0) {\n    return 0;\n  } else if (length2 < 1) {\n    return Math.ceil(length2 * pixelRatio) / pixelRatio;\n  }\n  return Math.round((length2 + start2) * pixelRatio) / pixelRatio - alignedStart;\n}\nfunction alignBefore(pixelRatio, start2) {\n  return Math.floor(start2 * pixelRatio) / pixelRatio;\n}\n\n// packages/ag-charts-community/src/scene/shape/shape.ts\nvar LINEAR_GRADIENT_REGEXP = /^linear-gradient\\((-?[\\d.]+)deg,(.*?)\\)$/i;\nvar _Shape = class _Shape extends Node {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.fill = _Shape.defaultStyles.fill;\n    this.stroke = _Shape.defaultStyles.stroke;\n    this.strokeWidth = _Shape.defaultStyles.strokeWidth;\n    this.lineDash = _Shape.defaultStyles.lineDash;\n    this.lineDashOffset = _Shape.defaultStyles.lineDashOffset;\n    this.lineCap = _Shape.defaultStyles.lineCap;\n    this.lineJoin = _Shape.defaultStyles.lineJoin;\n    this.miterLimit = void 0;\n    this.opacity = _Shape.defaultStyles.opacity;\n    this.fillShadow = _Shape.defaultStyles.fillShadow;\n    this.gradientFillOptions = {\n      domain: [0, 1],\n      defaultColorRange: _Shape.defaultStyles.defaultColorRange\n    };\n  }\n  /**\n   * Restores the default styles introduced by this subclass.\n   */\n  restoreOwnStyles() {\n    const { defaultStyles } = this.constructor;\n    Object.assign(this, defaultStyles);\n  }\n  getGradient(pattern) {\n    let linearGradientMatch;\n    if (pattern instanceof Gradient) {\n      return pattern;\n    } else if (typeof pattern === \"string\" && pattern?.startsWith(\"linear-gradient\") && (linearGradientMatch = LINEAR_GRADIENT_REGEXP.exec(pattern))) {\n      const angle2 = parseFloat(linearGradientMatch[1]);\n      const colors = [];\n      const colorsPart = linearGradientMatch[2];\n      const colorRegex = /(#[0-9a-f]+)|(rgba?\\(.+?\\))|([a-z]+)/gi;\n      let c;\n      while (c = colorRegex.exec(colorsPart)) {\n        colors.push(c[0]);\n      }\n      return new LinearGradient(\n        \"rgb\",\n        colors.map((color, index) => ({ color, offset: index / (colors.length - 1) })),\n        angle2\n      );\n    } else if (isGradientFill(pattern)) {\n      return this.createLinearGradient(pattern);\n    }\n    return void 0;\n  }\n  createLinearGradient(fill) {\n    const { colorStops = [], direction } = fill;\n    const isHorizontal = direction === \"horizontal\";\n    const { domain, defaultColorRange = [] } = this.gradientFillOptions;\n    const stops = getColorStops(colorStops, defaultColorRange, domain);\n    return new LinearGradient(\"oklch\", stops, isHorizontal ? 0 : 90);\n  }\n  onFillChange() {\n    this.fillGradient = this.getGradient(this.fill);\n  }\n  onStrokeChange() {\n    this.strokeGradient = this.getGradient(this.stroke);\n  }\n  /**\n   * Returns a device-pixel aligned coordinate (or length if length is supplied).\n   *\n   * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle\n   * of a device pixel.\n   */\n  align(start2, length2) {\n    return align(this.layerManager?.canvas?.pixelRatio ?? 1, start2, length2);\n  }\n  fillStroke(ctx, path) {\n    this.renderFill(ctx, path);\n    this.renderStroke(ctx, path);\n  }\n  renderFill(ctx, path) {\n    if (this.fill) {\n      const { globalAlpha } = ctx;\n      this.applyFill(ctx);\n      this.applyFillAlpha(ctx);\n      this.applyShadow(ctx);\n      this.executeFill(ctx, path);\n      ctx.globalAlpha = globalAlpha;\n    }\n    ctx.shadowColor = \"rgba(0, 0, 0, 0)\";\n  }\n  executeFill(ctx, path) {\n    if (path) {\n      ctx.fill(path);\n    } else {\n      ctx.fill();\n    }\n  }\n  applyFill(ctx) {\n    const bbox = this.gradientFillOptions.bbox ?? this.getBBox();\n    ctx.fillStyle = this.fillGradient?.createGradient(ctx, bbox) ?? (typeof this.fill === \"string\" ? this.fill : void 0) ?? \"black\";\n  }\n  applyStroke(ctx) {\n    ctx.strokeStyle = this.strokeGradient?.createGradient(ctx, this.getBBox()) ?? (typeof this.stroke === \"string\" ? this.stroke : void 0) ?? \"black\";\n  }\n  applyFillAlpha(ctx) {\n    ctx.globalAlpha *= this.opacity * this.fillOpacity;\n  }\n  applyShadow(ctx) {\n    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;\n    const fillShadow = this.fillShadow;\n    if (fillShadow?.enabled) {\n      ctx.shadowColor = fillShadow.color;\n      ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n      ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n      ctx.shadowBlur = fillShadow.blur * pixelRatio;\n    }\n  }\n  renderStroke(ctx, path) {\n    if (this.stroke && this.strokeWidth) {\n      const { globalAlpha } = ctx;\n      this.applyStroke(ctx);\n      ctx.globalAlpha *= this.opacity * this.strokeOpacity;\n      ctx.lineWidth = this.strokeWidth;\n      if (this.lineDash) {\n        ctx.setLineDash(this.lineDash);\n      }\n      if (this.lineDashOffset) {\n        ctx.lineDashOffset = this.lineDashOffset;\n      }\n      if (this.lineCap) {\n        ctx.lineCap = this.lineCap;\n      }\n      if (this.lineJoin) {\n        ctx.lineJoin = this.lineJoin;\n      }\n      if (this.miterLimit != null) {\n        ctx.miterLimit = this.miterLimit;\n      }\n      this.executeStroke(ctx, path);\n      ctx.globalAlpha = globalAlpha;\n    }\n  }\n  executeStroke(ctx, path) {\n    if (path) {\n      ctx.stroke(path);\n    } else {\n      ctx.stroke();\n    }\n  }\n  containsPoint(x, y) {\n    return this.isPointInPath(x, y);\n  }\n  applySvgFillAttributes(element2) {\n    const { fill, fillOpacity } = this;\n    element2.setAttribute(\"fill\", typeof fill === \"string\" ? fill : \"none\");\n    element2.setAttribute(\"fill-opacity\", String(fillOpacity));\n  }\n  applySvgStrokeAttributes(element2) {\n    const { stroke: stroke2, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = this;\n    if (stroke2 != null) {\n      element2.setAttribute(\"stroke\", typeof stroke2 === \"string\" ? stroke2 : \"none\");\n      element2.setAttribute(\"stroke-opacity\", String(strokeOpacity));\n      element2.setAttribute(\"stroke-width\", String(strokeWidth));\n    }\n    if (lineDash?.some((d) => d !== 0) === true) {\n      const svgLineDash = lineDash.length % 2 === 1 ? [...lineDash, ...lineDash] : lineDash;\n      element2.setAttribute(\"stroke-dasharray\", svgLineDash.join(\" \"));\n      element2.setAttribute(\"stroke-dashoffset\", String(lineDashOffset));\n    }\n  }\n};\n/**\n * Defaults for style properties. Note that properties that affect the position\n * and shape of the node are not considered style properties, for example:\n * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.\n * Can be used to reset to the original styling after some custom styling\n * has been applied (using the `restoreOwnStyles` method).\n * These static defaults are meant to be inherited by subclasses.\n */\n_Shape.defaultStyles = {\n  fill: \"black\",\n  stroke: void 0,\n  strokeWidth: 0,\n  lineDash: void 0,\n  lineDashOffset: 0,\n  lineCap: void 0,\n  lineJoin: void 0,\n  opacity: 1,\n  fillShadow: void 0,\n  defaultColorRange: [\"#5090dc\", \"#ef5452\"]\n};\n__decorateClass([\n  SceneChangeDetection()\n], _Shape.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Shape.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ changeCb: (s) => s.onFillChange() })\n], _Shape.prototype, \"fill\", 2);\n__decorateClass([\n  SceneChangeDetection({ changeCb: (s) => s.onStrokeChange() })\n], _Shape.prototype, \"stroke\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Shape.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Shape.prototype, \"lineDash\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Shape.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Shape.prototype, \"lineCap\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Shape.prototype, \"lineJoin\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Shape.prototype, \"miterLimit\", 2);\n__decorateClass([\n  SceneChangeDetection({ convertor: (v) => clamp(0, v, 1) })\n], _Shape.prototype, \"opacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ checkDirtyOnAssignment: true })\n], _Shape.prototype, \"fillShadow\", 2);\n__decorateClass([\n  SceneChangeDetection({ changeCb: (s) => s.onFillChange() })\n], _Shape.prototype, \"gradientFillOptions\", 2);\nvar Shape = _Shape;\n\n// packages/ag-charts-community/src/scene/matrix.ts\nvar IDENTITY_MATRIX_ELEMENTS = [1, 0, 0, 1, 0, 0];\nvar Matrix = class _Matrix {\n  get e() {\n    return [...this.elements];\n  }\n  constructor(elements = IDENTITY_MATRIX_ELEMENTS) {\n    this.elements = [...elements];\n  }\n  setElements(elements) {\n    const e = this.elements;\n    e[0] = elements[0];\n    e[1] = elements[1];\n    e[2] = elements[2];\n    e[3] = elements[3];\n    e[4] = elements[4];\n    e[5] = elements[5];\n    return this;\n  }\n  get identity() {\n    const e = this.elements;\n    return isNumberEqual(e[0], 1) && isNumberEqual(e[1], 0) && isNumberEqual(e[2], 0) && isNumberEqual(e[3], 1) && isNumberEqual(e[4], 0) && isNumberEqual(e[5], 0);\n  }\n  /**\n   * Performs the AxB matrix multiplication and saves the result\n   * to `C`, if given, or to `A` otherwise.\n   */\n  AxB(A, B, C2) {\n    const a = A[0] * B[0] + A[2] * B[1], b = A[1] * B[0] + A[3] * B[1], c = A[0] * B[2] + A[2] * B[3], d = A[1] * B[2] + A[3] * B[3], e = A[0] * B[4] + A[2] * B[5] + A[4], f = A[1] * B[4] + A[3] * B[5] + A[5];\n    C2 = C2 ?? A;\n    C2[0] = a;\n    C2[1] = b;\n    C2[2] = c;\n    C2[3] = d;\n    C2[4] = e;\n    C2[5] = f;\n  }\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns the current matrix.\n   * @param other\n   */\n  multiplySelf(other) {\n    this.AxB(this.elements, other.elements);\n    return this;\n  }\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns a new matrix.\n   * @param other\n   */\n  multiply(other) {\n    const elements = new Array(6);\n    if (other instanceof _Matrix) {\n      this.AxB(this.elements, other.elements, elements);\n    } else {\n      this.AxB(this.elements, [other.a, other.b, other.c, other.d, other.e, other.f], elements);\n    }\n    return new _Matrix(elements);\n  }\n  preMultiplySelf(other) {\n    this.AxB(other.elements, this.elements, this.elements);\n    return this;\n  }\n  /**\n   * Returns the inverse of this matrix as a new matrix.\n   */\n  inverse() {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    return new _Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n  }\n  invertSelf() {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    el[0] = d;\n    el[1] = -b;\n    el[2] = -c;\n    el[3] = a;\n    el[4] = c * f - d * e;\n    el[5] = b * e - a * f;\n    return this;\n  }\n  transformPoint(x, y) {\n    const e = this.elements;\n    return {\n      x: x * e[0] + y * e[2] + e[4],\n      y: x * e[1] + y * e[3] + e[5]\n    };\n  }\n  transformBBox(bbox, target) {\n    const el = this.elements;\n    const xx = el[0];\n    const xy = el[1];\n    const yx = el[2];\n    const yy = el[3];\n    const h_w = bbox.width * 0.5;\n    const h_h = bbox.height * 0.5;\n    const cx = bbox.x + h_w;\n    const cy = bbox.y + h_h;\n    const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);\n    const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);\n    target ?? (target = new BBox(0, 0, 0, 0));\n    target.x = cx * xx + cy * yx + el[4] - w;\n    target.y = cx * xy + cy * yy + el[5] - h;\n    target.width = w + w;\n    target.height = h + h;\n    return target;\n  }\n  toContext(ctx) {\n    if (this.identity) {\n      return;\n    }\n    const e = this.elements;\n    ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\n  }\n  static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {\n    const sx = scalingX;\n    const sy = scalingY;\n    let scx;\n    let scy;\n    if (sx === 1 && sy === 1) {\n      scx = 0;\n      scy = 0;\n    } else {\n      scx = opts?.scalingCenterX ?? 0;\n      scy = opts?.scalingCenterY ?? 0;\n    }\n    const r = rotation;\n    const cos = Math.cos(r);\n    const sin = Math.sin(r);\n    let rcx;\n    let rcy;\n    if (r === 0) {\n      rcx = 0;\n      rcy = 0;\n    } else {\n      rcx = opts?.rotationCenterX ?? 0;\n      rcy = opts?.rotationCenterY ?? 0;\n    }\n    const tx = translationX;\n    const ty = translationY;\n    const tx4 = scx * (1 - sx) - rcx;\n    const ty4 = scy * (1 - sy) - rcy;\n    matrix.setElements([\n      cos * sx,\n      sin * sx,\n      -sin * sy,\n      cos * sy,\n      cos * tx4 - sin * ty4 + rcx + tx,\n      sin * tx4 + cos * ty4 + rcy + ty\n    ]);\n    return matrix;\n  }\n};\n\n// packages/ag-charts-community/src/scene/transformable.ts\nfunction isMatrixTransform(node) {\n  return isMatrixTransformType(node.constructor);\n}\nvar MATRIX_TRANSFORM_TYPE = Symbol(\"isMatrixTransform\");\nfunction isMatrixTransformType(cstr) {\n  return cstr[MATRIX_TRANSFORM_TYPE] === true;\n}\nfunction MatrixTransform(Parent) {\n  var _a, _b;\n  const ParentNode = Parent;\n  if (isMatrixTransformType(Parent)) {\n    return Parent;\n  }\n  const TRANSFORM_MATRIX = Symbol(\"matrix_combined_transform\");\n  class MatrixTransformInternal extends ParentNode {\n    constructor() {\n      super(...arguments);\n      this[_b] = new Matrix();\n      this._dirtyTransform = true;\n    }\n    markDirtyTransform() {\n      this._dirtyTransform = true;\n      super.markDirty();\n    }\n    updateMatrix(_matrix) {\n    }\n    computeTransformMatrix() {\n      if (!this._dirtyTransform)\n        return;\n      this[TRANSFORM_MATRIX].setElements(IDENTITY_MATRIX_ELEMENTS);\n      this.updateMatrix(this[TRANSFORM_MATRIX]);\n      this._dirtyTransform = false;\n    }\n    toParent(bbox) {\n      this.computeTransformMatrix();\n      if (this[TRANSFORM_MATRIX].identity)\n        return bbox.clone();\n      return this[TRANSFORM_MATRIX].transformBBox(bbox);\n    }\n    toParentPoint(x, y) {\n      this.computeTransformMatrix();\n      if (this[TRANSFORM_MATRIX].identity)\n        return { x, y };\n      return this[TRANSFORM_MATRIX].transformPoint(x, y);\n    }\n    fromParent(bbox) {\n      this.computeTransformMatrix();\n      if (this[TRANSFORM_MATRIX].identity)\n        return bbox.clone();\n      return this[TRANSFORM_MATRIX].inverse().transformBBox(bbox);\n    }\n    fromParentPoint(x, y) {\n      this.computeTransformMatrix();\n      if (this[TRANSFORM_MATRIX].identity)\n        return { x, y };\n      return this[TRANSFORM_MATRIX].inverse().transformPoint(x, y);\n    }\n    computeBBox() {\n      const bbox = super.computeBBox();\n      if (!bbox)\n        return bbox;\n      return this.toParent(bbox);\n    }\n    computeBBoxWithoutTransforms() {\n      return super.computeBBox();\n    }\n    pickNode(x, y, localCoords = false) {\n      if (!localCoords) {\n        ({ x, y } = this.fromParentPoint(x, y));\n      }\n      return super.pickNode(x, y);\n    }\n    render(renderCtx) {\n      this.computeTransformMatrix();\n      const { ctx } = renderCtx;\n      const matrix = this[TRANSFORM_MATRIX];\n      let performRestore = false;\n      if (!matrix.identity) {\n        ctx.save();\n        performRestore = true;\n        matrix.toContext(ctx);\n      }\n      super.render(renderCtx);\n      if (performRestore) {\n        ctx.restore();\n      }\n    }\n    toSVG() {\n      this.computeTransformMatrix();\n      const svg = super.toSVG();\n      const matrix = this[TRANSFORM_MATRIX];\n      if (matrix.identity || svg == null)\n        return svg;\n      const g = createSvgElement(\"g\");\n      g.append(...svg.elements);\n      const [a, b, c, d, e, f] = matrix.e;\n      g.setAttribute(\"transform\", `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);\n      return {\n        elements: [g],\n        defs: svg.defs\n      };\n    }\n  }\n  _a = MATRIX_TRANSFORM_TYPE, _b = TRANSFORM_MATRIX;\n  MatrixTransformInternal[_a] = true;\n  return MatrixTransformInternal;\n}\nfunction Rotatable(Parent) {\n  var _a;\n  const ParentNode = Parent;\n  const ROTATABLE_MATRIX = Symbol(\"matrix_rotation\");\n  class RotatableInternal extends MatrixTransform(ParentNode) {\n    constructor() {\n      super(...arguments);\n      this[_a] = new Matrix();\n      this.rotationCenterX = null;\n      this.rotationCenterY = null;\n      this.rotation = 0;\n    }\n    updateMatrix(matrix) {\n      super.updateMatrix(matrix);\n      const { rotation, rotationCenterX, rotationCenterY } = this;\n      if (rotation === 0)\n        return;\n      Matrix.updateTransformMatrix(this[ROTATABLE_MATRIX], 1, 1, rotation, 0, 0, {\n        rotationCenterX,\n        rotationCenterY\n      });\n      matrix.multiplySelf(this[ROTATABLE_MATRIX]);\n    }\n  }\n  _a = ROTATABLE_MATRIX;\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], RotatableInternal.prototype, \"rotationCenterX\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], RotatableInternal.prototype, \"rotationCenterY\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], RotatableInternal.prototype, \"rotation\", 2);\n  return RotatableInternal;\n}\nfunction Scalable(Parent) {\n  var _a;\n  const ParentNode = Parent;\n  const SCALABLE_MATRIX = Symbol(\"matrix_scale\");\n  class ScalableInternal extends MatrixTransform(ParentNode) {\n    constructor() {\n      super(...arguments);\n      this[_a] = new Matrix();\n      this.scalingX = 1;\n      this.scalingY = 1;\n      this.scalingCenterX = null;\n      this.scalingCenterY = null;\n    }\n    updateMatrix(matrix) {\n      super.updateMatrix(matrix);\n      const { scalingX, scalingY, scalingCenterX, scalingCenterY } = this;\n      if (scalingX === 1 && scalingY === 1)\n        return;\n      Matrix.updateTransformMatrix(this[SCALABLE_MATRIX], scalingX, scalingY, 0, 0, 0, {\n        scalingCenterX,\n        scalingCenterY\n      });\n      matrix.multiplySelf(this[SCALABLE_MATRIX]);\n    }\n  }\n  _a = SCALABLE_MATRIX;\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], ScalableInternal.prototype, \"scalingX\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], ScalableInternal.prototype, \"scalingY\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], ScalableInternal.prototype, \"scalingCenterX\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], ScalableInternal.prototype, \"scalingCenterY\", 2);\n  return ScalableInternal;\n}\nfunction Translatable(Parent) {\n  var _a;\n  const ParentNode = Parent;\n  const TRANSLATABLE_MATRIX = Symbol(\"matrix_translation\");\n  class TranslatableInternal extends MatrixTransform(ParentNode) {\n    constructor() {\n      super(...arguments);\n      this[_a] = new Matrix();\n      this.translationX = 0;\n      this.translationY = 0;\n    }\n    updateMatrix(matrix) {\n      super.updateMatrix(matrix);\n      const { translationX, translationY } = this;\n      if (translationX === 0 && translationY === 0)\n        return;\n      Matrix.updateTransformMatrix(this[TRANSLATABLE_MATRIX], 1, 1, 0, translationX, translationY);\n      matrix.multiplySelf(this[TRANSLATABLE_MATRIX]);\n    }\n  }\n  _a = TRANSLATABLE_MATRIX;\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], TranslatableInternal.prototype, \"translationX\", 2);\n  __decorateClass([\n    SceneChangeDetection({ type: \"transform\" })\n  ], TranslatableInternal.prototype, \"translationY\", 2);\n  return TranslatableInternal;\n}\nvar Transformable = class {\n  /**\n   * Converts a BBox from canvas coordinate space into the coordinate space of the given Node.\n   */\n  static fromCanvas(node, bbox) {\n    const parents = [];\n    for (const parent of node.traverseUp()) {\n      if (isMatrixTransform(parent)) {\n        parents.unshift(parent);\n      }\n    }\n    for (const parent of parents) {\n      bbox = parent.fromParent(bbox);\n    }\n    if (isMatrixTransform(node)) {\n      bbox = node.fromParent(bbox);\n    }\n    return bbox;\n  }\n  /**\n   * Converts a Nodes BBox (or an arbitrary BBox if supplied) from local Node coordinate space\n   * into the Canvas coordinate space.\n   */\n  static toCanvas(node, bbox) {\n    if (bbox == null) {\n      bbox = node.getBBox();\n    } else if (isMatrixTransform(node)) {\n      bbox = node.toParent(bbox);\n    }\n    for (const parent of node.traverseUp()) {\n      if (isMatrixTransform(parent)) {\n        bbox = parent.toParent(bbox);\n      }\n    }\n    return bbox;\n  }\n  /**\n   * Converts a point from canvas coordinate space into the coordinate space of the given Node.\n   */\n  static fromCanvasPoint(node, x, y) {\n    const parents = [];\n    for (const parent of node.traverseUp()) {\n      if (isMatrixTransform(parent)) {\n        parents.unshift(parent);\n      }\n    }\n    for (const parent of parents) {\n      ({ x, y } = parent.fromParentPoint(x, y));\n    }\n    if (isMatrixTransform(node)) {\n      ({ x, y } = node.fromParentPoint(x, y));\n    }\n    return { x, y };\n  }\n  /**\n   * Converts a point from a Nodes local coordinate space into the Canvas coordinate space.\n   */\n  static toCanvasPoint(node, x, y) {\n    if (isMatrixTransform(node)) {\n      ({ x, y } = node.toParentPoint(x, y));\n    }\n    for (const parent of node.traverseUp()) {\n      if (isMatrixTransform(parent)) {\n        ({ x, y } = parent.toParentPoint(x, y));\n      }\n    }\n    return { x, y };\n  }\n};\n\n// packages/ag-charts-community/src/scene/zIndex.ts\nvar cmp = (a, b) => Math.sign(a - b);\nfunction compareZIndex(a, b) {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return cmp(a, b);\n  }\n  const aArray = typeof a === \"number\" ? [a] : a;\n  const bArray = typeof b === \"number\" ? [b] : b;\n  const length2 = Math.min(aArray.length, bArray.length);\n  for (let i = 0; i < length2; i += 1) {\n    const diff2 = cmp(aArray[i], bArray[i]);\n    if (diff2 !== 0)\n      return diff2;\n  }\n  return cmp(aArray.length, bArray.length);\n}\n\n// packages/ag-charts-community/src/scene/group.ts\nvar sharedOffscreenCanvas;\nvar _Group = class _Group extends Node {\n  // optimizeForInfrequentRedraws: true\n  constructor(opts) {\n    super(opts);\n    this.opacity = 1;\n    this.renderToOffscreenCanvas = false;\n    this.optimizeForInfrequentRedraws = false;\n    // Used when renderToOffscreenCanvas: true\n    this.layer = void 0;\n    // optimizeForInfrequentRedraws: false\n    this.image = void 0;\n    this._lastWidth = NaN;\n    this._lastHeight = NaN;\n    this._lastDevicePixelRatio = NaN;\n    this.isContainerNode = true;\n    this.renderToOffscreenCanvas = opts?.renderToOffscreenCanvas === true;\n  }\n  static is(value) {\n    return value instanceof _Group;\n  }\n  static computeChildrenBBox(nodes, skipInvisible = true) {\n    return BBox.merge(Node.extractBBoxes(nodes, skipInvisible));\n  }\n  static compareChildren(a, b) {\n    return compareZIndex(a.zIndex, b.zIndex) || a.serialNumber - b.serialNumber;\n  }\n  // We consider a group to be boundless, thus any point belongs to it.\n  containsPoint(_x, _y) {\n    return true;\n  }\n  computeBBox() {\n    return _Group.computeChildrenBBox(this.children());\n  }\n  computeSafeClippingBBox(pixelRatio) {\n    const bbox = this.computeBBox();\n    if (!bbox.isFinite())\n      return;\n    let strokeWidth = 0;\n    const strokeMiterAmount = 4;\n    for (const child of this.descendants()) {\n      if (child instanceof Shape) {\n        strokeWidth = Math.max(strokeWidth, child.strokeWidth);\n      }\n    }\n    const padding = Math.max(\n      // Account for anti-aliasing artefacts\n      1,\n      // Account for strokes (incl. miters) - this may not be the best place to include this\n      strokeWidth / 2 * strokeMiterAmount\n    );\n    const { x: originX, y: originY } = Transformable.toCanvasPoint(this, 0, 0);\n    const x = alignBefore(pixelRatio, originX + bbox.x - padding) - originX;\n    const y = alignBefore(pixelRatio, originY + bbox.y - padding) - originY;\n    const width2 = Math.ceil(bbox.x + bbox.width - x + padding);\n    const height2 = Math.ceil(bbox.y + bbox.height - y + padding);\n    return new BBox(x, y, width2, height2);\n  }\n  prepareSharedCanvas(width2, height2, pixelRatio) {\n    if (sharedOffscreenCanvas == null || sharedOffscreenCanvas.pixelRatio !== pixelRatio) {\n      sharedOffscreenCanvas = new HdpiOffscreenCanvas({ width: width2, height: height2, pixelRatio });\n    } else {\n      sharedOffscreenCanvas.resize(width2, height2, pixelRatio);\n    }\n    return sharedOffscreenCanvas;\n  }\n  isDirty(renderCtx) {\n    const { width: width2, height: height2, devicePixelRatio } = renderCtx;\n    const { dirty, dirtyZIndex, layer } = this;\n    const layerResized = layer != null && (this._lastWidth !== width2 || this._lastHeight !== height2);\n    const pixelRatioChanged = this._lastDevicePixelRatio !== devicePixelRatio;\n    this._lastWidth = width2;\n    this._lastHeight = height2;\n    this._lastDevicePixelRatio = devicePixelRatio;\n    if (dirty || dirtyZIndex || layerResized || pixelRatioChanged)\n      return true;\n    for (const child of this.children()) {\n      if (child.dirty)\n        return true;\n    }\n    return false;\n  }\n  preRender(renderCtx) {\n    const counts = super.preRender(renderCtx, 0);\n    counts.groups += 1;\n    counts.nonGroups -= 1;\n    if (this.renderToOffscreenCanvas && !this.optimizeForInfrequentRedraws && counts.nonGroups > 0 && this.getVisibility()) {\n      this.layer ?? (this.layer = this._layerManager?.addLayer({ name: this.name }));\n    } else if (this.layer != null) {\n      this._layerManager?.removeLayer(this.layer);\n      this.layer = void 0;\n    }\n    return counts;\n  }\n  render(renderCtx) {\n    const { layer, renderToOffscreenCanvas } = this;\n    const childRenderCtx = { ...renderCtx };\n    if (!renderToOffscreenCanvas) {\n      this.renderInContext(childRenderCtx);\n      super.render(childRenderCtx);\n      return;\n    }\n    const { ctx, stats, devicePixelRatio: pixelRatio } = renderCtx;\n    let { image } = this;\n    if (this.isDirty(renderCtx)) {\n      image?.bitmap.close();\n      image = void 0;\n      const bbox = layer ? void 0 : this.computeSafeClippingBBox(pixelRatio);\n      const renderOffscreen = (offscreenCanvas, ...transform) => {\n        const offscreenCtx = offscreenCanvas.context;\n        childRenderCtx.ctx = offscreenCtx;\n        offscreenCanvas.clear();\n        offscreenCtx.save();\n        offscreenCtx.setTransform(...transform);\n        offscreenCtx.globalAlpha = 1;\n        this.renderInContext(childRenderCtx);\n        offscreenCtx.restore();\n        offscreenCtx.verifyDepthZero?.();\n      };\n      if (layer) {\n        renderOffscreen(layer, ctx.getTransform());\n      } else if (bbox) {\n        const { x, y, width: width2, height: height2 } = bbox;\n        const canvas = this.prepareSharedCanvas(width2, height2, pixelRatio);\n        renderOffscreen(canvas, pixelRatio, 0, 0, pixelRatio, -x * pixelRatio, -y * pixelRatio);\n        image = { bitmap: canvas.transferToImageBitmap(), x, y, width: width2, height: height2 };\n      } else if (this.dirtyZIndex) {\n        this.sortChildren(_Group.compareChildren);\n      }\n      this.image = image;\n      if (stats)\n        stats.layersRendered++;\n    } else {\n      this.skipRender(childRenderCtx);\n      if (stats)\n        stats.layersSkipped++;\n    }\n    const { globalAlpha } = ctx;\n    ctx.globalAlpha = globalAlpha * this.opacity;\n    if (layer) {\n      ctx.save();\n      ctx.resetTransform();\n      layer.drawImage(ctx);\n      ctx.restore();\n    } else if (image) {\n      const { bitmap, x, y, width: width2, height: height2 } = image;\n      ctx.drawImage(bitmap, 0, 0, width2 * pixelRatio, height2 * pixelRatio, x, y, width2, height2);\n    }\n    ctx.globalAlpha = globalAlpha;\n    super.render(childRenderCtx);\n  }\n  skipRender(childRenderCtx) {\n    const { stats } = childRenderCtx;\n    for (const child of this.children()) {\n      child.markClean();\n      if (stats) {\n        stats.nodesSkipped += this.childNodeCounts.groups + this.childNodeCounts.nonGroups;\n        stats.opsSkipped += this.childNodeCounts.complexity;\n      }\n    }\n  }\n  applyClip(ctx, clipRect) {\n    const { x, y, width: width2, height: height2 } = clipRect;\n    ctx.beginPath();\n    ctx.rect(x, y, width2, height2);\n    ctx.clip();\n  }\n  renderInContext(childRenderCtx) {\n    const { ctx, stats } = childRenderCtx;\n    if (this.dirtyZIndex) {\n      this.sortChildren(_Group.compareChildren);\n    }\n    ctx.save();\n    ctx.globalAlpha *= this.opacity;\n    if (this.clipRect != null) {\n      this.applyClip(ctx, this.clipRect);\n      childRenderCtx.clipBBox = Transformable.toCanvas(this, this.clipRect);\n    }\n    for (const child of this.children()) {\n      if (!child.visible) {\n        child.markClean();\n        if (stats) {\n          stats.nodesSkipped += child.childNodeCounts.nonGroups + child.childNodeCounts.groups;\n          stats.opsSkipped += child.childNodeCounts.complexity;\n        }\n        continue;\n      }\n      ctx.save();\n      child.render(childRenderCtx);\n      ctx.restore();\n    }\n    ctx.restore();\n  }\n  /**\n   * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and\n   * sets this group's clipRect to the transformed bbox.\n   * @param bbox clipRect bbox in the canvas coordinate space.\n   */\n  setClipRect(bbox) {\n    this.clipRect = bbox ? Transformable.fromCanvas(this, bbox) : void 0;\n  }\n  /**\n   * Set the clip rect within the canvas coordinate space.\n   * @param bbox clipRect bbox in the canvas coordinate space.\n   */\n  setClipRectCanvasSpace(bbox) {\n    this.clipRect = bbox;\n  }\n  _setLayerManager(layersManager) {\n    if (this.layer) {\n      this._layerManager?.removeLayer(this.layer);\n      this.layer = void 0;\n    }\n    super._setLayerManager(layersManager);\n  }\n  getVisibility() {\n    for (const node of this.traverseUp(true)) {\n      if (!node.visible) {\n        return false;\n      }\n    }\n    return true;\n  }\n  toSVG() {\n    if (!this.visible)\n      return;\n    const defs = [];\n    const elements = [];\n    for (const child of this.children()) {\n      const svg = child.toSVG();\n      if (svg != null) {\n        elements.push(...svg.elements);\n        if (svg.defs != null) {\n          defs.push(...svg.defs);\n        }\n      }\n    }\n    return { elements, defs };\n  }\n};\n_Group.className = \"Group\";\n__decorateClass([\n  SceneChangeDetection({ convertor: (v) => clamp(0, v, 1) })\n], _Group.prototype, \"opacity\", 2);\nvar Group = _Group;\nvar ScalableGroup = class extends Scalable(Group) {\n};\nvar RotatableGroup = class extends Rotatable(Group) {\n};\nvar TranslatableGroup = class extends Translatable(Group) {\n};\nvar TransformableGroup = class extends Rotatable(Translatable(Group)) {\n};\n\n// packages/ag-charts-community/src/util/canvas.util.ts\nfunction createCanvasContext(width2 = 0, height2 = 0) {\n  return new OffscreenCanvas(width2, height2).getContext(\"2d\");\n}\n\n// packages/ag-charts-community/src/util/lruCache.ts\nvar LRUCache = class {\n  constructor(maxCacheSize = 5) {\n    this.maxCacheSize = maxCacheSize;\n    this.store = /* @__PURE__ */ new Map();\n  }\n  get(key) {\n    if (!this.store.has(key))\n      return void 0;\n    const hit = this.store.get(key);\n    this.store.delete(key);\n    this.store.set(key, hit);\n    return hit;\n  }\n  has(key) {\n    return this.store.has(key);\n  }\n  set(key, value) {\n    this.store.set(key, value);\n    if (this.store.size > this.maxCacheSize) {\n      const iterator = this.store.keys();\n      let evictCount = this.store.size - this.maxCacheSize;\n      while (evictCount > 0) {\n        const evictKeyIterator = iterator.next();\n        if (!evictKeyIterator.done) {\n          this.store.delete(evictKeyIterator.value);\n        }\n        evictCount--;\n      }\n    }\n    return value;\n  }\n  clear() {\n    this.store.clear();\n  }\n};\n\n// packages/ag-charts-community/src/util/textMeasurer.ts\nvar CachedTextMeasurerPool = class {\n  // Measures the dimensions of the provided text, handling multiline if needed.\n  static measureText(text2, options) {\n    const textMeasurer = this.getMeasurer(options);\n    return textMeasurer.measureText(text2);\n  }\n  static measureLines(text2, options) {\n    const textMeasurer = this.getMeasurer(options);\n    return textMeasurer.measureLines(text2);\n  }\n  // Gets a TextMeasurer instance, configuring text alignment and baseline if provided.\n  static getMeasurer(options) {\n    const font2 = typeof options.font === \"string\" ? options.font : TextUtils.toFontString(options.font);\n    const key = `${font2}-${options.textAlign ?? \"start\"}-${options.textBaseline ?? \"alphabetic\"}`;\n    return this.instanceMap.get(key) ?? this.createFontMeasurer(font2, options, key);\n  }\n  // Creates or retrieves a TextMeasurer instance for a specific font.\n  static createFontMeasurer(font2, options, key) {\n    const ctx = createCanvasContext();\n    ctx.font = font2;\n    ctx.textAlign = options.textAlign ?? \"start\";\n    ctx.textBaseline = options.textBaseline ?? \"alphabetic\";\n    const measurer2 = new CachedTextMeasurer(ctx, options);\n    this.instanceMap.set(key, measurer2);\n    return measurer2;\n  }\n};\nCachedTextMeasurerPool.instanceMap = new LRUCache(10);\nvar CachedTextMeasurer = class {\n  constructor(ctx, options) {\n    this.ctx = ctx;\n    // cached text measurements\n    this.measureMap = new LRUCache(100);\n    if (options.textAlign) {\n      ctx.textAlign = options.textAlign;\n    }\n    if (options.textBaseline) {\n      ctx.textBaseline = options.textBaseline;\n    }\n    ctx.font = typeof options.font === \"string\" ? options.font : TextUtils.toFontString(options.font);\n    this.textMeasurer = new SimpleTextMeasurer(\n      (t) => this.cachedCtxMeasureText(t),\n      options.textBaseline ?? \"alphabetic\"\n    );\n  }\n  textWidth(text2, estimate) {\n    return this.textMeasurer.textWidth(text2, estimate);\n  }\n  measureText(text2) {\n    return this.textMeasurer.measureText(text2);\n  }\n  measureLines(text2) {\n    return this.textMeasurer.measureLines(text2);\n  }\n  cachedCtxMeasureText(text2) {\n    if (!this.measureMap.has(text2)) {\n      const rawResult = this.ctx.measureText(text2);\n      this.measureMap.set(text2, {\n        actualBoundingBoxAscent: rawResult.actualBoundingBoxAscent,\n        emHeightAscent: rawResult.emHeightAscent,\n        emHeightDescent: rawResult.emHeightDescent,\n        actualBoundingBoxDescent: rawResult.actualBoundingBoxDescent,\n        actualBoundingBoxLeft: rawResult.actualBoundingBoxLeft,\n        actualBoundingBoxRight: rawResult.actualBoundingBoxRight,\n        alphabeticBaseline: rawResult.alphabeticBaseline,\n        fontBoundingBoxAscent: rawResult.fontBoundingBoxAscent,\n        fontBoundingBoxDescent: rawResult.fontBoundingBoxDescent,\n        hangingBaseline: rawResult.hangingBaseline,\n        ideographicBaseline: rawResult.ideographicBaseline,\n        width: rawResult.width\n      });\n    }\n    return this.measureMap.get(text2);\n  }\n};\nvar TextUtils = class {\n  static toFontString({ fontSize = 10, fontStyle, fontWeight, fontFamily, lineHeight }) {\n    let fontString = \"\";\n    if (fontStyle) {\n      fontString += `${fontStyle} `;\n    }\n    if (fontWeight) {\n      fontString += `${fontWeight} `;\n    }\n    fontString += `${fontSize}px`;\n    if (lineHeight) {\n      fontString += `/${lineHeight}px`;\n    }\n    fontString += ` ${fontFamily}`;\n    return fontString.trim();\n  }\n  static getLineHeight(fontSize) {\n    return Math.ceil(fontSize * this.defaultLineHeight);\n  }\n  // Determines vertical offset modifier based on text baseline.\n  static getVerticalModifier(textBaseline) {\n    switch (textBaseline) {\n      case \"hanging\":\n      case \"top\":\n        return 0;\n      case \"middle\":\n        return 0.5;\n      case \"alphabetic\":\n      case \"bottom\":\n      case \"ideographic\":\n      default:\n        return 1;\n    }\n  }\n};\nTextUtils.EllipsisChar = \"\\u2026\";\n// Representation for text clipping.\nTextUtils.defaultLineHeight = 1.15;\n// Normally between 1.1 and 1.2\nTextUtils.lineSplitter = /\\r?\\n/g;\nvar SimpleTextMeasurer = class {\n  constructor(measureTextFn, textBaseline = \"alphabetic\") {\n    this.measureTextFn = measureTextFn;\n    this.textBaseline = textBaseline;\n    // local chars width cache per TextMeasurer\n    this.charMap = /* @__PURE__ */ new Map();\n  }\n  // Measures metrics for a single line of text.\n  getMetrics(text2) {\n    const m = this.measureTextFn(text2);\n    m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);\n    m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);\n    return {\n      width: m.width,\n      height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,\n      lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,\n      offsetTop: m.actualBoundingBoxAscent,\n      offsetLeft: m.actualBoundingBoxLeft\n    };\n  }\n  // Calculates aggregated metrics for multiline text.\n  getMultilineMetrics(lines) {\n    let width2 = 0;\n    let height2 = 0;\n    let offsetTop = 0;\n    let offsetLeft = 0;\n    let baselineDistance = 0;\n    const verticalModifier = TextUtils.getVerticalModifier(this.textBaseline);\n    const lineMetrics = [];\n    let index = 0;\n    const length2 = lines.length;\n    for (const line of lines) {\n      const m = this.measureTextFn(line);\n      m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);\n      m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);\n      if (width2 < m.width) {\n        width2 = m.width;\n      }\n      if (offsetLeft < m.actualBoundingBoxLeft) {\n        offsetLeft = m.actualBoundingBoxLeft;\n      }\n      if (index === 0) {\n        height2 += m.actualBoundingBoxAscent;\n        offsetTop += m.actualBoundingBoxAscent;\n      } else {\n        baselineDistance += m.fontBoundingBoxAscent;\n      }\n      if (index === length2 - 1) {\n        height2 += m.actualBoundingBoxDescent;\n      } else {\n        baselineDistance += m.fontBoundingBoxDescent;\n      }\n      lineMetrics.push({\n        text: line,\n        width: m.width,\n        height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,\n        lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,\n        offsetTop: m.actualBoundingBoxAscent,\n        offsetLeft: m.actualBoundingBoxLeft\n      });\n      index++;\n    }\n    height2 += baselineDistance;\n    offsetTop += baselineDistance * verticalModifier;\n    return { width: width2, height: height2, offsetTop, offsetLeft, lineMetrics };\n  }\n  textWidth(text2, estimate) {\n    if (estimate) {\n      let estimatedWidth = 0;\n      for (let i = 0; i < text2.length; i++) {\n        estimatedWidth += this.textWidth(text2.charAt(i));\n      }\n      return estimatedWidth;\n    }\n    if (text2.length > 1) {\n      return this.measureTextFn(text2).width;\n    }\n    return this.charMap.get(text2) ?? this.charWidth(text2);\n  }\n  measureText(text2) {\n    return this.getMetrics(text2);\n  }\n  // Measures the dimensions of the provided text, handling multiline if needed.\n  measureLines(text2) {\n    const lines = typeof text2 === \"string\" ? text2.split(TextUtils.lineSplitter) : text2;\n    return this.getMultilineMetrics(lines);\n  }\n  charWidth(char) {\n    const { width: width2 } = this.measureTextFn(char);\n    this.charMap.set(char, width2);\n    return width2;\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/text.ts\nvar _Text = class _Text extends Shape {\n  constructor() {\n    super(...arguments);\n    this.x = 0;\n    this.y = 0;\n    this.lines = [];\n    this.text = void 0;\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.textAlign = _Text.defaultStyles.textAlign;\n    this.textBaseline = _Text.defaultStyles.textBaseline;\n  }\n  onTextChange() {\n    this.lines = this.text?.split(\"\\n\").map((s) => s.trim()) ?? [];\n  }\n  static computeBBox(lines, x, y, opts) {\n    const { offsetTop, offsetLeft, width: width2, height: height2 } = CachedTextMeasurerPool.measureLines(lines, opts);\n    return new BBox(x - offsetLeft, y - offsetTop, width2, height2);\n  }\n  computeBBox() {\n    const { x, y, lines, textBaseline, textAlign } = this;\n    return _Text.computeBBox(lines, x, y, { font: this, textBaseline, textAlign });\n  }\n  isPointInPath(x, y) {\n    const bbox = this.getBBox();\n    return bbox ? bbox.containsPoint(x, y) : false;\n  }\n  render(renderCtx) {\n    const { ctx, stats } = renderCtx;\n    if (!this.lines.length || !this.layerManager) {\n      if (stats)\n        stats.nodesSkipped += 1;\n      return super.render(renderCtx);\n    }\n    const { fill, stroke: stroke2, strokeWidth } = this;\n    const { pixelRatio } = this.layerManager.canvas;\n    ctx.font = TextUtils.toFontString(this);\n    ctx.textAlign = this.textAlign;\n    ctx.textBaseline = this.textBaseline;\n    if (fill) {\n      this.applyFill(ctx);\n      ctx.globalAlpha *= this.opacity * this.fillOpacity;\n      const { fillShadow } = this;\n      if (fillShadow?.enabled) {\n        ctx.shadowColor = fillShadow.color;\n        ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n        ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n        ctx.shadowBlur = fillShadow.blur * pixelRatio;\n      }\n      this.renderLines((line, x, y) => ctx.fillText(line, x, y));\n    }\n    if (stroke2 && strokeWidth) {\n      this.applyStroke(ctx);\n      ctx.lineWidth = strokeWidth;\n      ctx.globalAlpha *= this.opacity * this.strokeOpacity;\n      const { lineDash, lineDashOffset, lineCap, lineJoin } = this;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      this.renderLines((line, x, y) => ctx.strokeText(line, x, y));\n    }\n    super.render(renderCtx);\n  }\n  renderLines(renderCallback) {\n    const { lines, x, y } = this;\n    const lineHeight = this.lineHeight ?? TextUtils.getLineHeight(this.fontSize);\n    let offsetY = (lineHeight - lineHeight * lines.length) * TextUtils.getVerticalModifier(this.textBaseline);\n    for (const line of lines) {\n      renderCallback(line, x, y + offsetY);\n      offsetY += lineHeight;\n    }\n  }\n  setFont(props) {\n    this.fontFamily = props.fontFamily;\n    this.fontSize = props.fontSize;\n    this.fontStyle = props.fontStyle;\n    this.fontWeight = props.fontWeight;\n  }\n  setAlign(props) {\n    this.textAlign = props.textAlign;\n    this.textBaseline = props.textBaseline;\n  }\n  toSVG() {\n    if (!this.visible || !this.text)\n      return;\n    const element2 = createSvgElement(\"text\");\n    this.applySvgFillAttributes(element2);\n    element2.setAttribute(\"font-family\", this.fontFamily?.split(\",\")[0] ?? \"\");\n    element2.setAttribute(\"font-size\", String(this.fontSize));\n    element2.setAttribute(\"font-style\", this.fontStyle ?? \"\");\n    element2.setAttribute(\"font-weight\", String(this.fontWeight ?? \"\"));\n    element2.setAttribute(\n      \"text-anchor\",\n      {\n        center: \"middle\",\n        left: \"start\",\n        right: \"end\",\n        start: \"start\",\n        end: \"end\"\n      }[this.textAlign ?? \"start\"]\n    );\n    element2.setAttribute(\n      \"alignment-baseline\",\n      {\n        alphabetic: \"alphabetic\",\n        top: \"top\",\n        bottom: \"bottom\",\n        hanging: \"hanging\",\n        middle: \"middle\",\n        ideographic: \"ideographic\"\n      }[this.textBaseline ?? \"alphabetic\"]\n    );\n    element2.setAttribute(\"x\", String(this.x));\n    element2.setAttribute(\"y\", String(this.y));\n    element2.textContent = this.text ?? \"\";\n    return { elements: [element2] };\n  }\n};\n_Text.className = \"Text\";\n_Text.defaultStyles = {\n  ...Shape.defaultStyles,\n  textAlign: \"start\",\n  fontStyle: void 0,\n  fontWeight: void 0,\n  fontSize: 10,\n  fontFamily: \"sans-serif\",\n  textBaseline: \"alphabetic\"\n};\n__decorateClass([\n  SceneChangeDetection()\n], _Text.prototype, \"x\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Text.prototype, \"y\", 2);\n__decorateClass([\n  SceneChangeDetection({ changeCb: (o) => o.onTextChange() })\n], _Text.prototype, \"text\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Text.prototype, \"fontStyle\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Text.prototype, \"fontWeight\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Text.prototype, \"fontSize\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Text.prototype, \"fontFamily\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Text.prototype, \"textAlign\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Text.prototype, \"textBaseline\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], _Text.prototype, \"lineHeight\", 2);\nvar Text = _Text;\nvar RotatableText = class extends Rotatable(Text) {\n};\nvar TransformableText = class extends Rotatable(Translatable(Text)) {\n};\n\n// packages/ag-charts-community/src/util/stateMachine.ts\nvar debugColor = \"color: green\";\nvar debugQuietColor = \"color: grey\";\nfunction StateMachineProperty() {\n  return addObserverToInstanceProperty(() => {\n  });\n}\nfunction applyProperties(parentState, childState) {\n  const childProperties = listDecoratedProperties(childState);\n  if (childProperties.length === 0)\n    return;\n  const properties = extractDecoratedProperties(parentState);\n  for (const property of childProperties) {\n    if (property in properties) {\n      childState[property] = properties[property];\n    }\n  }\n}\nvar AbstractStateMachine = class {\n  transitionRoot(event, data) {\n    if (this.parent) {\n      this.parent.transitionRoot(event, data);\n    } else {\n      this.transition(event, data);\n    }\n  }\n};\nvar _StateMachine = class _StateMachine extends AbstractStateMachine {\n  constructor(defaultState, states, enterEach) {\n    super();\n    this.defaultState = defaultState;\n    this.states = states;\n    this.enterEach = enterEach;\n    this.debug = Debug.create(true, \"animation\");\n    this.state = defaultState;\n    this.debug(`%c${this.constructor.name} | init -> ${defaultState}`, debugColor);\n  }\n  // TODO: handle events which do not require data without requiring `undefined` to be passed as as parameter, while\n  // also still requiring data to be passed to those events which do require it.\n  transition(event, data) {\n    const shouldTransitionSelf = this.transitionChild(event, data);\n    if (!shouldTransitionSelf || this.state === _StateMachine.child || this.state === _StateMachine.parent) {\n      return;\n    }\n    const currentState = this.state;\n    const currentStateConfig = this.states[this.state];\n    let destination = currentStateConfig[event];\n    const debugPrefix = `%c${this.constructor.name} | ${this.state} -> ${event} ->`;\n    if (Array.isArray(destination)) {\n      destination = destination.find((transition) => {\n        if (!transition.guard)\n          return true;\n        const valid = transition.guard(data);\n        if (!valid) {\n          this.debug(`${debugPrefix} (guarded)`, transition.target, debugQuietColor);\n        }\n        return valid;\n      });\n    } else if (typeof destination === \"object\" && !(destination instanceof _StateMachine) && destination.guard && !destination.guard(data)) {\n      this.debug(`${debugPrefix} (guarded)`, destination.target, debugQuietColor);\n      return;\n    }\n    if (!destination) {\n      this.debug(`${debugPrefix} ${this.state}`, debugQuietColor);\n      return;\n    }\n    const destinationState = this.getDestinationState(destination);\n    const exitFn = destinationState === this.state ? void 0 : currentStateConfig.onExit;\n    this.debug(`${debugPrefix} ${destinationState}`, debugColor);\n    this.state = destinationState;\n    if (typeof destination === \"function\") {\n      destination(data);\n    } else if (typeof destination === \"object\" && !(destination instanceof _StateMachine)) {\n      destination.action?.(data);\n    }\n    exitFn?.();\n    this.enterEach?.(currentState, destinationState);\n    if (destinationState !== currentState && destinationState !== _StateMachine.child && destinationState !== _StateMachine.parent) {\n      this.states[destinationState].onEnter?.(currentState, data);\n    }\n  }\n  transitionAsync(event, data) {\n    setTimeout(() => {\n      this.transition(event, data);\n    }, 0);\n  }\n  is(value) {\n    if (this.state === _StateMachine.child && this.childState) {\n      return this.childState.is(value);\n    }\n    return this.state === value;\n  }\n  resetHierarchy() {\n    this.debug(\n      `%c${this.constructor.name} | ${this.state} -> [resetHierarchy] -> ${this.defaultState}`,\n      \"color: green\"\n    );\n    this.state = this.defaultState;\n  }\n  transitionChild(event, data) {\n    if (this.state !== _StateMachine.child || !this.childState)\n      return true;\n    applyProperties(this, this.childState);\n    this.childState.transition(event, data);\n    if (!this.childState.is(_StateMachine.parent))\n      return true;\n    this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.defaultState}`, debugColor);\n    this.state = this.defaultState;\n    this.states[this.state].onEnter?.();\n    this.childState.resetHierarchy();\n    return false;\n  }\n  getDestinationState(destination) {\n    let state = this.state;\n    if (typeof destination === \"string\") {\n      state = destination;\n    } else if (destination instanceof _StateMachine) {\n      this.childState = destination;\n      this.childState.parent = this;\n      state = _StateMachine.child;\n    } else if (typeof destination === \"object\") {\n      if (destination.target instanceof _StateMachine) {\n        this.childState = destination.target;\n        this.childState.parent = this;\n        state = _StateMachine.child;\n      } else if (destination.target != null) {\n        state = destination.target;\n      }\n    }\n    return state;\n  }\n};\n_StateMachine.child = \"__child\";\n_StateMachine.parent = \"__parent\";\nvar StateMachine = _StateMachine;\nvar ParallelStateMachine = class extends AbstractStateMachine {\n  constructor(...stateMachines) {\n    super();\n    this.stateMachines = stateMachines;\n    for (const stateMachine of stateMachines) {\n      stateMachine.parent = this;\n    }\n  }\n  transition(event, data) {\n    for (const stateMachine of this.stateMachines) {\n      applyProperties(this, stateMachine);\n      stateMachine.transition(event, data);\n    }\n  }\n  transitionAsync(event, data) {\n    for (const stateMachine of this.stateMachines) {\n      applyProperties(this, stateMachine);\n      stateMachine.transitionAsync(event, data);\n    }\n  }\n};\n\n// packages/ag-charts-community/src/util/proxy.ts\nfunction ProxyProperty(proxyPath, configMetadata) {\n  const pathArray = isArray(proxyPath) ? proxyPath : proxyPath.split(\".\");\n  if (pathArray.length === 1) {\n    const [property] = pathArray;\n    return addTransformToInstanceProperty(\n      (target, _, value) => target[property] = value,\n      (target) => target[property],\n      configMetadata\n    );\n  }\n  return addTransformToInstanceProperty(\n    (target, _, value) => setPath(target, pathArray, value),\n    (target) => getPath(target, pathArray),\n    configMetadata\n  );\n}\nfunction ProxyOnWrite(proxyProperty) {\n  return addTransformToInstanceProperty((target, _, value) => target[proxyProperty] = value);\n}\nfunction ProxyPropertyOnWrite(childName, childProperty) {\n  return addTransformToInstanceProperty((target, key, value) => target[childName][childProperty ?? key] = value);\n}\nfunction ActionOnSet(opts) {\n  const { newValue: newValueFn, oldValue: oldValueFn, changeValue: changeValueFn } = opts;\n  return addTransformToInstanceProperty((target, _, newValue, oldValue) => {\n    if (newValue !== oldValue) {\n      if (oldValue !== void 0) {\n        oldValueFn?.call(target, oldValue);\n      }\n      if (newValue !== void 0) {\n        newValueFn?.call(target, newValue);\n      }\n      changeValueFn?.call(target, newValue, oldValue);\n    }\n    return newValue;\n  });\n}\nfunction ObserveChanges(observerFn) {\n  return addObserverToInstanceProperty(observerFn);\n}\n\n// packages/ag-charts-community/src/util/textWrapper.ts\nvar TextWrapper = class {\n  static wrapText(text2, options) {\n    return this.wrapLines(text2, options).join(\"\\n\");\n  }\n  static wrapLines(text2, options) {\n    const clippedResult = this.textWrap(text2, options);\n    if (options.overflow === \"hide\" && clippedResult.some((l) => l.endsWith(TextUtils.EllipsisChar))) {\n      return [];\n    }\n    return clippedResult;\n  }\n  static appendEllipsis(text2) {\n    return text2.replace(/[.,]{1,5}$/, \"\") + TextUtils.EllipsisChar;\n  }\n  static truncateLine(text2, measurer2, maxWidth, ellipsisForce) {\n    const ellipsisWidth = measurer2.textWidth(TextUtils.EllipsisChar);\n    let estimatedWidth = 0;\n    let i = 0;\n    for (; i < text2.length; i++) {\n      const charWidth = measurer2.textWidth(text2.charAt(i));\n      if (estimatedWidth + charWidth > maxWidth)\n        break;\n      estimatedWidth += charWidth;\n    }\n    if (text2.length === i && (!ellipsisForce || estimatedWidth + ellipsisWidth <= maxWidth)) {\n      return ellipsisForce ? text2 + TextUtils.EllipsisChar : text2;\n    }\n    text2 = text2.slice(0, i).trimEnd();\n    while (text2.length && measurer2.textWidth(text2) + ellipsisWidth > maxWidth) {\n      text2 = text2.slice(0, -1).trimEnd();\n    }\n    return text2 + TextUtils.EllipsisChar;\n  }\n  static textWrap(text2, options) {\n    const lines = text2.split(TextUtils.lineSplitter);\n    const measurer2 = CachedTextMeasurerPool.getMeasurer(options);\n    if (options.textWrap === \"never\") {\n      return lines.map((line) => this.truncateLine(line.trimEnd(), measurer2, options.maxWidth));\n    }\n    const result = [];\n    const wrapHyphenate = options.textWrap === \"hyphenate\";\n    const wrapOnSpace = options.textWrap == null || options.textWrap === \"on-space\";\n    for (const untrimmedLine of lines) {\n      let line = untrimmedLine.trimEnd();\n      if (line === \"\") {\n        result.push(line);\n        continue;\n      }\n      let i = 0;\n      let estimatedWidth = 0;\n      let lastSpaceIndex = 0;\n      while (i < line.length) {\n        const char = line.charAt(i);\n        estimatedWidth += measurer2.textWidth(char);\n        if (char === \" \") {\n          lastSpaceIndex = i;\n        }\n        if (estimatedWidth > options.maxWidth) {\n          if (i === 0)\n            break;\n          const actualWidth = measurer2.textWidth(line.slice(0, i + 1));\n          if (actualWidth <= options.maxWidth) {\n            estimatedWidth = actualWidth;\n            i++;\n            continue;\n          }\n          if (lastSpaceIndex) {\n            const nextWord = this.getWordAt(line, lastSpaceIndex + 1);\n            const textWidth = measurer2.textWidth(nextWord);\n            if (textWidth <= options.maxWidth) {\n              result.push(line.slice(0, lastSpaceIndex).trimEnd());\n              line = line.slice(lastSpaceIndex).trimStart();\n              i = 0;\n              estimatedWidth = 0;\n              lastSpaceIndex = 0;\n              continue;\n            } else if (wrapOnSpace && textWidth > options.maxWidth) {\n              result.push(\n                line.slice(0, lastSpaceIndex).trimEnd(),\n                this.truncateLine(\n                  line.slice(lastSpaceIndex).trimStart(),\n                  measurer2,\n                  options.maxWidth,\n                  true\n                )\n              );\n            }\n          } else if (wrapOnSpace) {\n            result.push(this.truncateLine(line, measurer2, options.maxWidth, true));\n          }\n          if (wrapOnSpace) {\n            line = \"\";\n            break;\n          }\n          const postfix = wrapHyphenate ? \"-\" : \"\";\n          let newLine = line.slice(0, i).trim();\n          while (newLine.length && measurer2.textWidth(newLine + postfix) > options.maxWidth) {\n            newLine = newLine.slice(0, -1).trimEnd();\n          }\n          result.push(newLine + postfix);\n          if (!newLine.length) {\n            line = \"\";\n            break;\n          }\n          line = line.slice(newLine.length).trimStart();\n          i = -1;\n          estimatedWidth = 0;\n          lastSpaceIndex = 0;\n        }\n        i++;\n      }\n      if (line) {\n        result.push(line);\n      }\n    }\n    this.avoidOrphans(result, measurer2, options);\n    return this.clipLines(result, measurer2, options);\n  }\n  static getWordAt(text2, position) {\n    const nextSpaceIndex = text2.indexOf(\" \", position);\n    return nextSpaceIndex === -1 ? text2.slice(position) : text2.slice(position, nextSpaceIndex);\n  }\n  static clipLines(lines, measurer2, options) {\n    if (!options.maxHeight) {\n      return lines;\n    }\n    const { height: height2, lineMetrics } = measurer2.measureLines(lines);\n    if (height2 <= options.maxHeight) {\n      return lines;\n    }\n    for (let i = 0, cumulativeHeight = 0; i < lineMetrics.length; i++) {\n      const { lineHeight } = lineMetrics[i];\n      cumulativeHeight += lineHeight;\n      if (cumulativeHeight > options.maxHeight) {\n        if (options.overflow === \"hide\") {\n          return [];\n        }\n        const clippedResults = lines.slice(0, i || 1);\n        const lastLine = clippedResults.pop();\n        return clippedResults.concat(this.truncateLine(lastLine, measurer2, options.maxWidth, true));\n      }\n    }\n    return lines;\n  }\n  static avoidOrphans(lines, measurer2, options) {\n    if (options.avoidOrphans === false || lines.length < 2)\n      return;\n    const { length: length2 } = lines;\n    const lastLine = lines[length2 - 1];\n    const beforeLast = lines[length2 - 2];\n    if (beforeLast.length < lastLine.length)\n      return;\n    const lastSpaceIndex = beforeLast.lastIndexOf(\" \");\n    if (lastSpaceIndex === -1 || lastSpaceIndex === beforeLast.indexOf(\" \") || lastLine.includes(\" \"))\n      return;\n    const lastWord = beforeLast.slice(lastSpaceIndex + 1);\n    if (measurer2.textWidth(lastLine + lastWord) <= options.maxWidth) {\n      lines[length2 - 2] = beforeLast.slice(0, lastSpaceIndex);\n      lines[length2 - 1] = lastWord + \" \" + lastLine;\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/caption.ts\nvar Caption = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.id = createId(this);\n    this.node = new RotatableText({ zIndex: 1 }).setProperties({\n      textAlign: \"center\",\n      pointerEvents: 1 /* None */\n    });\n    this.enabled = false;\n    this.textAlign = \"center\";\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.wrapping = \"always\";\n    this.padding = 0;\n    this.layoutStyle = \"block\";\n    this.truncated = false;\n  }\n  registerInteraction(moduleCtx, where) {\n    return moduleCtx.layoutManager.addListener(\"layout:complete\", () => this.updateA11yText(moduleCtx, where));\n  }\n  computeTextWrap(containerWidth, containerHeight) {\n    const { text: text2, padding, wrapping } = this;\n    const maxWidth = Math.min(this.maxWidth ?? Infinity, containerWidth) - padding * 2;\n    const maxHeight = this.maxHeight ?? containerHeight - padding * 2;\n    if (!isFinite(maxWidth) && !isFinite(maxHeight)) {\n      this.node.text = text2;\n      return;\n    }\n    const wrappedText = TextWrapper.wrapText(text2 ?? \"\", { maxWidth, maxHeight, font: this, textWrap: wrapping });\n    this.node.text = wrappedText;\n    this.truncated = wrappedText.includes(TextUtils.EllipsisChar);\n  }\n  updateA11yText(moduleCtx, where) {\n    const { proxyInteractionService } = moduleCtx;\n    if (this.enabled && this.text) {\n      const bbox = Transformable.toCanvas(this.node);\n      if (bbox) {\n        const { id: domManagerId } = this;\n        this.proxyText ?? (this.proxyText = proxyInteractionService.createProxyElement({ type: \"text\", domManagerId, where }));\n        this.proxyText.textContent = this.text;\n        this.proxyText.setBounds(bbox);\n        this.proxyText.addListener(\"mousemove\", (ev) => this.handleMouseMove(moduleCtx, ev));\n        this.proxyText.addListener(\"mouseleave\", (ev) => this.handleMouseLeave(moduleCtx, ev));\n      }\n    } else {\n      this.proxyText?.destroy();\n      this.proxyText = void 0;\n    }\n  }\n  handleMouseMove(moduleCtx, event) {\n    if (event != null && this.enabled && this.node.visible && this.truncated) {\n      const { x, y } = Transformable.toCanvas(this.node);\n      const canvasX = event.sourceEvent.offsetX + x;\n      const canvasY = event.sourceEvent.offsetY + y;\n      const lastPointerEvent = { type: \"pointermove\", canvasX, canvasY };\n      moduleCtx.tooltipManager.updateTooltip(\n        this.id,\n        { canvasX, canvasY, lastPointerEvent, showArrow: false },\n        { type: \"structured\", title: this.text }\n      );\n    }\n  }\n  handleMouseLeave(moduleCtx, _event) {\n    moduleCtx.tooltipManager.removeTooltip(this.id);\n  }\n};\nCaption.SMALL_PADDING = 10;\nCaption.LARGE_PADDING = 20;\n__decorateClass([\n  Validate(BOOLEAN),\n  ProxyPropertyOnWrite(\"node\", \"visible\")\n], Caption.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"text\", 2);\n__decorateClass([\n  Validate(TEXT_ALIGN, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"textAlign\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"node\", \"fill\")\n], Caption.prototype, \"color\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"maxHeight\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], Caption.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Caption.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(STRING)\n], Caption.prototype, \"layoutStyle\", 2);\n\n// packages/ag-charts-community/src/chart/chartAxisDirection.ts\nvar ChartAxisDirection = /* @__PURE__ */ ((ChartAxisDirection2) => {\n  ChartAxisDirection2[\"X\"] = \"x\";\n  ChartAxisDirection2[\"Y\"] = \"y\";\n  return ChartAxisDirection2;\n})(ChartAxisDirection || {});\n\n// packages/ag-charts-community/src/module/moduleMap.ts\nvar ModuleMap = class {\n  constructor() {\n    this.moduleMap = /* @__PURE__ */ new Map();\n  }\n  *modules() {\n    for (const m of this.moduleMap.values()) {\n      yield m.moduleInstance;\n    }\n  }\n  addModule(module, moduleFactory) {\n    if (this.moduleMap.has(module.optionsKey)) {\n      throw new Error(`AG Charts - module already initialised: ${module.optionsKey}`);\n    }\n    this.moduleMap.set(module.optionsKey, { module, moduleInstance: moduleFactory(module) });\n  }\n  removeModule(module) {\n    const moduleKey = isString(module) ? module : module.optionsKey;\n    this.moduleMap.get(moduleKey)?.moduleInstance.destroy();\n    this.moduleMap.delete(moduleKey);\n  }\n  getModule(module) {\n    return this.moduleMap.get(isString(module) ? module : module.optionsKey)?.moduleInstance;\n  }\n  isEnabled(module) {\n    return this.moduleMap.has(isString(module) ? module : module.optionsKey);\n  }\n  mapModules(callback2) {\n    return Array.from(this.moduleMap.values(), (m, i) => callback2(m.moduleInstance, i));\n  }\n  destroy() {\n    for (const moduleKey of this.moduleMap.keys()) {\n      this.moduleMap.get(moduleKey)?.moduleInstance.destroy();\n    }\n    this.moduleMap.clear();\n  }\n};\n\n// packages/ag-charts-community/src/util/date.ts\nfunction compareDates(a, b) {\n  return a.valueOf() - b.valueOf();\n}\nfunction deduplicateSortedArray(values) {\n  let v0 = NaN;\n  const out = [];\n  for (const v of values) {\n    const v1 = v.valueOf();\n    if (v0 !== v1)\n      out.push(v);\n    v0 = v1;\n  }\n  return out;\n}\nfunction sortAndUniqueDates(values) {\n  const sortedValues = values.slice().sort(compareDates);\n  return datesSortOrder(sortedValues) == null ? deduplicateSortedArray(sortedValues) : sortedValues;\n}\nfunction datesSortOrder(d) {\n  if (d.length === 0)\n    return 1;\n  const sign = Number(d[d.length - 1]) > Number(d[0]) ? 1 : -1;\n  let v0 = -Infinity * sign;\n  for (const v of d) {\n    const v1 = v.valueOf();\n    if (Math.sign(v1 - v0) !== sign)\n      return;\n    v0 = v1;\n  }\n  return sign;\n}\n\n// packages/ag-charts-community/src/util/numberFormat.ts\nfunction parseFormat(format) {\n  let prefix;\n  let suffix;\n  const surrounded = surroundedRegEx.exec(format);\n  if (surrounded) {\n    [, prefix, format, suffix] = surrounded;\n  }\n  const match = formatRegEx.exec(format);\n  if (!match) {\n    throw new Error(`The number formatter is invalid: ${format}`);\n  }\n  const [, fill, align2, sign, symbol, zero, width2, comma, precision, trim, type] = match;\n  return {\n    fill,\n    align: align2,\n    sign,\n    symbol,\n    zero,\n    width: parseInt(width2),\n    comma,\n    precision: parseInt(precision),\n    trim: Boolean(trim),\n    type,\n    prefix,\n    suffix\n  };\n}\nfunction numberFormat(format) {\n  const options = typeof format === \"string\" ? parseFormat(format) : format;\n  const { fill, align: align2, sign = \"-\", symbol, zero, width: width2, comma, type, prefix = \"\", suffix = \"\", precision } = options;\n  let { trim } = options;\n  const precisionIsNaN = precision == null || isNaN(precision);\n  let formatBody;\n  if (!type) {\n    formatBody = decimalTypes[\"g\"];\n    trim = true;\n  } else if (type in decimalTypes && type in integerTypes) {\n    formatBody = precisionIsNaN ? integerTypes[type] : decimalTypes[type];\n  } else if (type in decimalTypes) {\n    formatBody = decimalTypes[type];\n  } else if (type in integerTypes) {\n    formatBody = integerTypes[type];\n  } else {\n    throw new Error(`The number formatter type is invalid: ${type}`);\n  }\n  let formatterPrecision;\n  if (precision == null || precisionIsNaN) {\n    formatterPrecision = type ? 6 : 12;\n  } else {\n    formatterPrecision = precision;\n  }\n  return (n) => {\n    let result = formatBody(n, formatterPrecision);\n    if (trim) {\n      result = removeTrailingZeros(result);\n    }\n    if (comma) {\n      result = insertSeparator(result, comma);\n    }\n    result = addSign(n, result, sign);\n    if (symbol && symbol !== \"#\") {\n      result = `${symbol}${result}`;\n    }\n    if (symbol === \"#\" && type === \"x\") {\n      result = `0x${result}`;\n    }\n    if (type === \"s\") {\n      result = `${result}${getSIPrefix(n)}`;\n    }\n    if (type === \"%\" || type === \"p\") {\n      result = `${result}%`;\n    }\n    if (width2 != null && !isNaN(width2)) {\n      result = addPadding(result, width2, fill ?? zero, align2);\n    }\n    result = `${prefix}${result}${suffix}`;\n    return result;\n  };\n}\nvar formatRegEx = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(?:\\.(\\d+))?(~)?([%a-z])?$/i;\nvar surroundedRegEx = /^((?:[^#]|#[^{])*)#{([^}]+)}(.*)$/;\nvar integerTypes = {\n  b: (n) => absFloor(n).toString(2),\n  c: (n) => String.fromCharCode(n),\n  d: (n) => Math.round(Math.abs(n)).toFixed(0),\n  o: (n) => absFloor(n).toString(8),\n  x: (n) => absFloor(n).toString(16),\n  X: (n) => integerTypes.x(n).toUpperCase(),\n  n: (n) => integerTypes.d(n),\n  \"%\": (n) => `${absFloor(n * 100).toFixed(0)}`\n};\nvar decimalTypes = {\n  e: (n, f) => Math.abs(n).toExponential(f),\n  E: (n, f) => decimalTypes.e(n, f).toUpperCase(),\n  f: (n, f) => Math.abs(n).toFixed(f),\n  F: (n, f) => decimalTypes.f(n, f).toUpperCase(),\n  g: (n, f) => {\n    if (n === 0) {\n      return \"0\";\n    }\n    const a = Math.abs(n);\n    const p = Math.floor(Math.log10(a));\n    if (p >= -4 && p < f) {\n      return a.toFixed(f - 1 - p);\n    }\n    return a.toExponential(f - 1);\n  },\n  G: (n, f) => decimalTypes.g(n, f).toUpperCase(),\n  n: (n, f) => decimalTypes.g(n, f),\n  p: (n, f) => decimalTypes.r(n * 100, f),\n  r: (n, f) => {\n    if (n === 0) {\n      return \"0\";\n    }\n    const a = Math.abs(n);\n    const p = Math.floor(Math.log10(a));\n    const q = p - (f - 1);\n    if (q <= 0) {\n      return a.toFixed(-q);\n    }\n    const x = 10 ** q;\n    return (Math.round(a / x) * x).toFixed();\n  },\n  s: (n, f) => {\n    const p = getSIPrefixPower(n);\n    return decimalTypes.r(n / 10 ** p, f);\n  },\n  \"%\": (n, f) => decimalTypes.f(n * 100, f)\n};\nvar minSIPrefix = -24;\nvar maxSIPrefix = 24;\nvar siPrefixes = {\n  [minSIPrefix]: \"y\",\n  [-21]: \"z\",\n  [-18]: \"a\",\n  [-15]: \"f\",\n  [-12]: \"p\",\n  [-9]: \"n\",\n  [-6]: \"\\xB5\",\n  [-3]: \"m\",\n  [0]: \"\",\n  [3]: \"k\",\n  [6]: \"M\",\n  [9]: \"G\",\n  [12]: \"T\",\n  [15]: \"P\",\n  [18]: \"E\",\n  [21]: \"Z\",\n  [maxSIPrefix]: \"Y\"\n};\nvar minusSign = \"\\u2212\";\nfunction absFloor(n) {\n  return Math.floor(Math.abs(n));\n}\nfunction removeTrailingZeros(numString) {\n  return numString.replace(/\\.0+$/, \"\").replace(/(\\.[1-9])0+$/, \"$1\");\n}\nfunction insertSeparator(numString, separator) {\n  let dotIndex = numString.indexOf(\".\");\n  if (dotIndex < 0) {\n    dotIndex = numString.length;\n  }\n  const integerChars = numString.substring(0, dotIndex).split(\"\");\n  const fractionalPart = numString.substring(dotIndex);\n  for (let i = integerChars.length - 3; i > 0; i -= 3) {\n    integerChars.splice(i, 0, separator);\n  }\n  return `${integerChars.join(\"\")}${fractionalPart}`;\n}\nfunction getSIPrefix(n) {\n  return siPrefixes[getSIPrefixPower(n)];\n}\nfunction getSIPrefixPower(n) {\n  return clamp(minSIPrefix, n ? Math.floor(Math.log10(Math.abs(n)) / 3) * 3 : 0, maxSIPrefix);\n}\nfunction addSign(num, numString, signType = \"\") {\n  if (signType === \"(\") {\n    return num >= 0 ? numString : `(${numString})`;\n  }\n  const plusSign = signType === \"+\" ? \"+\" : \"\";\n  return `${num >= 0 ? plusSign : minusSign}${numString}`;\n}\nfunction addPadding(numString, width2, fill = \" \", align2 = \">\") {\n  let result = numString;\n  if (align2 === \">\" || !align2) {\n    result = result.padStart(width2, fill);\n  } else if (align2 === \"<\") {\n    result = result.padEnd(width2, fill);\n  } else if (align2 === \"^\") {\n    const padWidth = Math.max(0, width2 - result.length);\n    const padLeft = Math.ceil(padWidth / 2);\n    const padRight = Math.floor(padWidth / 2);\n    result = result.padStart(padLeft + result.length, fill);\n    result = result.padEnd(padRight + result.length, fill);\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/util/ticks.ts\nvar tInterval = (timeInterval, baseDuration, step) => ({\n  duration: baseDuration * step,\n  timeInterval,\n  step\n});\nvar TickIntervals = [\n  tInterval(second, durationSecond, 1),\n  tInterval(second, durationSecond, 5),\n  tInterval(second, durationSecond, 15),\n  tInterval(second, durationSecond, 30),\n  tInterval(minute, durationMinute, 1),\n  tInterval(minute, durationMinute, 5),\n  tInterval(minute, durationMinute, 15),\n  tInterval(minute, durationMinute, 30),\n  tInterval(hour, durationHour, 1),\n  tInterval(hour, durationHour, 3),\n  tInterval(hour, durationHour, 6),\n  tInterval(hour, durationHour, 12),\n  tInterval(day, durationDay, 1),\n  tInterval(day, durationDay, 2),\n  tInterval(sunday, durationWeek, 1),\n  tInterval(sunday, durationWeek, 2),\n  tInterval(sunday, durationWeek, 3),\n  tInterval(month, durationMonth, 1),\n  tInterval(month, durationMonth, 2),\n  tInterval(month, durationMonth, 3),\n  tInterval(month, durationMonth, 4),\n  tInterval(month, durationMonth, 6),\n  tInterval(year, durationYear, 1)\n];\nvar TickMultipliers = [1, 2, 5, 10];\nfunction isCloseToInteger(n, delta3) {\n  return Math.abs(Math.round(n) - n) < delta3;\n}\nfunction createTicks(start2, stop, count, minCount, maxCount, visibleRange) {\n  if (count < 2) {\n    return [start2, stop];\n  }\n  const step = tickStep(start2, stop, count, minCount, maxCount);\n  if (!Number.isFinite(step)) {\n    return [];\n  }\n  if (!isCloseToInteger(start2 / step, 1e-12)) {\n    start2 = Math.ceil(start2 / step) * step;\n  }\n  if (!isCloseToInteger(stop / step, 1e-12)) {\n    stop = Math.floor(stop / step) * step;\n  }\n  if (visibleRange != null && visibleRange[0] !== 0 && visibleRange[1] !== 1) {\n    const rangeExtent = stop - start2;\n    const adjustedStart = start2 + rangeExtent * visibleRange[0];\n    const adjustedEnd = stop - rangeExtent * (1 - visibleRange[1]);\n    return range(adjustedStart - adjustedStart % step, adjustedEnd + adjustedEnd % step, step);\n  }\n  return range(start2, stop, step);\n}\nfunction getTickInterval(start2, stop, count, minCount, maxCount, targetInterval) {\n  const target = targetInterval ?? Math.abs(stop - start2) / Math.max(count, 1);\n  let i = 0;\n  for (const tickInterval of TickIntervals) {\n    if (target <= tickInterval.duration)\n      break;\n    i++;\n  }\n  if (i === 0) {\n    const step2 = Math.max(tickStep(start2, stop, count, minCount, maxCount), 1);\n    return millisecond.every(step2);\n  } else if (i === TickIntervals.length) {\n    const step2 = targetInterval == null ? tickStep(start2 / durationYear, stop / durationYear, count, minCount, maxCount) : 1;\n    return year.every(step2);\n  }\n  const i0 = TickIntervals[i - 1];\n  const i1 = TickIntervals[i];\n  const { timeInterval, step } = target - i0.duration < i1.duration - target ? i0 : i1;\n  return timeInterval.every(step);\n}\nfunction tickStep(start2, end2, count, minCount = 0, maxCount = Infinity) {\n  if (start2 === end2) {\n    return clamp(1, minCount, maxCount);\n  } else if (count < 1) {\n    return NaN;\n  }\n  const extent2 = Math.abs(end2 - start2);\n  const step = 10 ** Math.floor(Math.log10(extent2 / count));\n  let m = NaN, minDiff = Infinity, isInBounds = false;\n  for (const multiplier of TickMultipliers) {\n    const c = Math.ceil(extent2 / (multiplier * step));\n    const validBounds = c >= minCount && c <= maxCount;\n    if (isInBounds && !validBounds)\n      continue;\n    const diffCount = Math.abs(c - count);\n    if (minDiff > diffCount || isInBounds !== validBounds) {\n      isInBounds || (isInBounds = validBounds);\n      minDiff = diffCount;\n      m = multiplier;\n    }\n  }\n  return m * step;\n}\nfunction decimalPlaces(decimal) {\n  for (let i = decimal.length - 1; i >= 0; i -= 1) {\n    if (decimal[i] !== \"0\") {\n      return i + 1;\n    }\n  }\n  return 0;\n}\nfunction tickFormat(ticks, format) {\n  const options = parseFormat(format ?? \",f\");\n  if (options.precision == null || isNaN(options.precision)) {\n    if (!options.type || \"eEFgGnprs\".includes(options.type)) {\n      options.precision = Math.max(\n        ...ticks.map((x) => {\n          if (!Number.isFinite(x))\n            return 0;\n          const [integer, decimal] = x.toExponential((options.type ? 6 : 12) - 1).split(/[.e]/g);\n          return (integer !== \"1\" && integer !== \"-1\" ? 1 : 0) + decimalPlaces(decimal) + 1;\n        })\n      );\n    } else if (\"f%\".includes(options.type)) {\n      options.precision = Math.max(\n        ...ticks.map((x) => {\n          if (!Number.isFinite(x) || x === 0)\n            return 0;\n          const l = Math.floor(Math.log10(Math.abs(x)));\n          const digits = options.type ? 6 : 12;\n          const decimal = x.toExponential(digits - 1).split(/[.e]/g)[1];\n          const decimalLength = decimalPlaces(decimal);\n          return Math.max(0, decimalLength - l);\n        })\n      );\n    }\n  }\n  const formatter = numberFormat(options);\n  return (n) => formatter(Number(n));\n}\nfunction range(start2, end2, step) {\n  if (!Number.isFinite(step) || step <= 0) {\n    return [];\n  }\n  const f = 10 ** countFractionDigits(step);\n  const d0 = Math.min(start2, end2);\n  const d1 = Math.max(start2, end2);\n  const out = [];\n  for (let i = 0; ; i += 1) {\n    const p = Math.round((d0 + step * i) * f) / f;\n    if (p > d1)\n      break;\n    out.push(p);\n  }\n  return out;\n}\nfunction isDenseInterval(count, availableRange) {\n  if (count >= availableRange) {\n    logger_exports.warnOnce(\n      `the configured interval results in more than 1 item per pixel, ignoring. Supply a larger interval or omit this configuration`\n    );\n    return true;\n  }\n  return false;\n}\nfunction niceTicksDomain(start2, end2) {\n  const extent2 = Math.abs(end2 - start2);\n  const step = 10 ** Math.floor(Math.log10(extent2));\n  let minError = Infinity, ticks = [start2, end2];\n  for (const multiplier of TickMultipliers) {\n    const m = multiplier * step;\n    const d0 = Math.floor(start2 / m) * m;\n    const d1 = Math.ceil(end2 / m) * m;\n    const error2 = 1 - extent2 / Math.abs(d1 - d0);\n    if (minError > error2) {\n      minError = error2;\n      ticks = [d0, d1];\n    }\n  }\n  return ticks;\n}\nfunction estimateTickCount(rangeExtent, zoomExtent, minSpacing, maxSpacing, defaultTickCount, defaultMinSpacing) {\n  defaultMinSpacing = Math.max(defaultMinSpacing, rangeExtent / (defaultTickCount + 1));\n  if (isNaN(minSpacing)) {\n    minSpacing = defaultMinSpacing;\n  }\n  if (isNaN(maxSpacing)) {\n    maxSpacing = rangeExtent;\n  }\n  if (minSpacing > maxSpacing) {\n    if (minSpacing === defaultMinSpacing) {\n      minSpacing = maxSpacing;\n    } else {\n      maxSpacing = minSpacing;\n    }\n  }\n  const maxTickCount = Math.max(1, Math.floor(rangeExtent / (zoomExtent * minSpacing)));\n  const minTickCount = Math.min(maxTickCount, Math.ceil(rangeExtent / (zoomExtent * maxSpacing)));\n  const tickCount = clamp(minTickCount, Math.floor(defaultTickCount / zoomExtent), maxTickCount);\n  return { minTickCount, maxTickCount, tickCount };\n}\n\n// packages/ag-charts-community/src/scale/timeScale.ts\nvar TimeScale = class extends ContinuousScale {\n  constructor() {\n    super([], [0, 1]);\n    this.type = \"time\";\n  }\n  toDomain(d) {\n    return new Date(d);\n  }\n  convert(value, clamp2) {\n    if (!(value instanceof Date))\n      value = new Date(value);\n    return super.convert(value, clamp2);\n  }\n  invert(value) {\n    return new Date(super.invert(value));\n  }\n  niceDomain(ticks, domain = this.domain) {\n    if (domain.length < 2)\n      return [];\n    const maxAttempts = 4;\n    let [d0, d1] = domain;\n    for (let i = 0; i < maxAttempts; i++) {\n      const [n0, n1] = updateNiceDomainIteration(d0, d1, ticks);\n      if (dateToNumber(d0) === dateToNumber(n0) && dateToNumber(d1) === dateToNumber(n1)) {\n        break;\n      }\n      d0 = n0;\n      d1 = n1;\n    }\n    return [d0, d1];\n  }\n  /**\n   * Returns uniformly-spaced dates that represent the scale's domain.\n   */\n  ticks(params, domain = this.domain, visibleRange = [0, 1]) {\n    const { nice, interval, tickCount = ContinuousScale.defaultTickCount, minTickCount, maxTickCount } = params;\n    if (domain.length < 2)\n      return [];\n    const timestamps = domain.map(dateToNumber);\n    const start2 = timestamps[0];\n    const stop = timestamps[timestamps.length - 1];\n    if (interval != null) {\n      const availableRange = this.getPixelRange();\n      return getDateTicksForInterval({ start: start2, stop, interval, availableRange, visibleRange }) ?? getDefaultDateTicks({ start: start2, stop, tickCount, minTickCount, maxTickCount, visibleRange });\n    } else if (nice && tickCount === 2) {\n      return domain;\n    } else if (nice && tickCount === 1) {\n      return domain.slice(0, 1);\n    }\n    return getDefaultDateTicks({ start: start2, stop, tickCount, minTickCount, maxTickCount, visibleRange });\n  }\n  _tickFormatter({ domain, ticks, specifier }, formatOffset) {\n    return specifier != null ? buildFormatter(specifier) : defaultTimeTickFormat(ticks, domain, formatOffset);\n  }\n  /**\n   * Returns a time format function suitable for displaying tick values.\n   *\n   * @param ticks Optional array of tick values for custom formatting.\n   * @param domain Optional array representing the [min, max] values of the time axis.\n   * @param specifier Optional format specifier string for custom date formatting (e.g., `%Y`, `%m`, `%d`).\n   * @param formatOffset Optional number for applying an offset to the format (e.g., timezone shifts).\n   * @returns A function that formats a `Date` object into a string based on the provided specifier or default format.\n   */\n  tickFormatter(params) {\n    return this._tickFormatter(params);\n  }\n  datumFormatter(params) {\n    return this._tickFormatter(params, 1);\n  }\n};\nfunction getDefaultDateTicks({\n  start: start2,\n  stop,\n  tickCount,\n  minTickCount,\n  maxTickCount,\n  visibleRange\n}) {\n  const t = getTickInterval(start2, stop, tickCount, minTickCount, maxTickCount);\n  return t ? t.range(new Date(start2), new Date(stop), { visibleRange }) : [];\n}\nfunction getDateTicksForInterval({\n  start: start2,\n  stop,\n  interval,\n  availableRange,\n  visibleRange\n}) {\n  if (!interval) {\n    return [];\n  }\n  if (interval instanceof TimeInterval) {\n    const ticks2 = interval.range(new Date(start2), new Date(stop), { visibleRange });\n    if (isDenseInterval(ticks2.length, availableRange)) {\n      return;\n    }\n    return ticks2;\n  }\n  const absInterval = Math.abs(interval);\n  if (isDenseInterval(Math.abs(stop - start2) / absInterval, availableRange))\n    return;\n  const timeInterval = TickIntervals.findLast((tickInterval) => absInterval % tickInterval.duration === 0);\n  if (timeInterval) {\n    const i = timeInterval.timeInterval.every(absInterval / (timeInterval.duration / timeInterval.step));\n    return i.range(new Date(start2), new Date(stop), { visibleRange });\n  }\n  let date2 = new Date(Math.min(start2, stop));\n  const stopDate = new Date(Math.max(start2, stop));\n  const ticks = [];\n  while (date2 <= stopDate) {\n    ticks.push(date2);\n    date2 = new Date(date2);\n    date2.setMilliseconds(date2.getMilliseconds() + absInterval);\n  }\n  return ticks;\n}\nfunction updateNiceDomainIteration(d0, d1, ticks) {\n  const { interval } = ticks;\n  const start2 = Math.min(dateToNumber(d0), dateToNumber(d1));\n  const stop = Math.max(dateToNumber(d0), dateToNumber(d1));\n  const isReversed = d0 > d1;\n  let i;\n  if (interval instanceof TimeInterval) {\n    i = interval;\n  } else {\n    const tickCount = typeof interval === \"number\" ? (stop - start2) / Math.max(interval, 1) : ticks.tickCount ?? ContinuousScale.defaultTickCount;\n    i = getTickInterval(start2, stop, tickCount, ticks.minTickCount, ticks.maxTickCount);\n  }\n  if (i) {\n    const intervalRange = i.range(new Date(start2), new Date(stop), { extend: true });\n    const domain = isReversed ? [...intervalRange].reverse() : intervalRange;\n    const n0 = domain[0];\n    const n1 = domain.at(-1);\n    return [n0, n1];\n  } else {\n    return [d0, d1];\n  }\n}\n\n// packages/ag-charts-community/src/scale/ordinalTimeScale.ts\nvar OrdinalTimeScale = class _OrdinalTimeScale extends BandScale {\n  constructor() {\n    super(...arguments);\n    this.type = \"ordinal-time\";\n    this._domain = [];\n    this.isReversed = false;\n  }\n  static is(value) {\n    return value instanceof _OrdinalTimeScale;\n  }\n  set domain(domain) {\n    if (domain === this._domain)\n      return;\n    this.invalid = true;\n    this._domain = domain;\n    this.isReversed = domain.length > 0 && domain[0] > domain[domain.length - 1];\n    this.sortedTimestamps = void 0;\n    this.precomputedSteps = void 0;\n  }\n  get domain() {\n    return this._domain;\n  }\n  toDomain(value) {\n    return new Date(value);\n  }\n  normalizeDomains(...domains) {\n    const sortedDomains = domains.filter((domain2) => domain2.length > 0).map((domain2) => {\n      let sortOrder = datesSortOrder(domain2);\n      if (sortOrder == null) {\n        domain2 = sortAndUniqueDates(domain2.slice());\n        sortOrder = 1;\n      }\n      return { domain: domain2, sortOrder };\n    });\n    if (sortedDomains.length === 0)\n      return { domain: [], animatable: false };\n    if (sortedDomains.length === 1)\n      return { domain: sortedDomains[0].domain, animatable: true };\n    let domain = sortedDomains.flatMap((s) => s.domain);\n    domain = sortAndUniqueDates(domain);\n    if (sortedDomains.every((s) => s.sortOrder === -1)) {\n      domain.reverse();\n    }\n    return { domain, animatable: true };\n  }\n  ticks({ interval, maxTickCount }, domain = this.domain, visibleRange = [0, 1]) {\n    if (!domain.length) {\n      return [];\n    }\n    this.refresh();\n    const { isReversed } = this;\n    if (interval == null) {\n      return getDefaultTicks(domain, maxTickCount, isReversed, visibleRange);\n    }\n    const [t0, t1] = [domain[0].valueOf(), domain.at(-1).valueOf()];\n    const start2 = Math.min(t0, t1);\n    const stop = Math.max(t0, t1);\n    const [r0, r1] = this.range;\n    const availableRange = Math.abs(r1 - r0);\n    const ticks = getDateTicksForInterval({ start: start2, stop, interval, availableRange, visibleRange }) ?? [];\n    let lastIndex = -1;\n    return ticks.filter((tick) => {\n      const index = this.findInterval(tick.valueOf());\n      const duplicated = index === lastIndex;\n      lastIndex = index;\n      return !duplicated;\n    });\n  }\n  getSortedTimestamps() {\n    let { sortedTimestamps } = this;\n    if (sortedTimestamps == null) {\n      sortedTimestamps = this.domain.map(dateToNumber);\n      if (this.isReversed)\n        sortedTimestamps.reverse();\n      this.sortedTimestamps = sortedTimestamps;\n    }\n    return sortedTimestamps;\n  }\n  getPrecomputedSteps() {\n    const { domain } = this;\n    let { precomputedSteps } = this;\n    const computedStepCount = domain.length < 1e4 ? domain.length : Math.ceil(domain.length / 16);\n    if (precomputedSteps != null || computedStepCount <= 1)\n      return precomputedSteps;\n    const sortedTimestamps = this.getSortedTimestamps();\n    precomputedSteps = new Int32Array(computedStepCount);\n    const d0 = sortedTimestamps[0];\n    const d1 = sortedTimestamps[sortedTimestamps.length - 1];\n    const dRange = d1 - d0;\n    const low = 0;\n    const high = sortedTimestamps.length - 1;\n    for (let i = 0; i < precomputedSteps.length; i += 1) {\n      precomputedSteps[i] = this.findIntervalInRange(d0 + i / computedStepCount * dRange, low, high);\n    }\n    this.precomputedSteps = precomputedSteps;\n  }\n  findIntervalInRange(target, low, high) {\n    const sortedTimestamps = this.getSortedTimestamps();\n    while (low <= high) {\n      const mid = (low + high) / 2 | 0;\n      if (sortedTimestamps[mid] === target) {\n        return mid;\n      } else if (sortedTimestamps[mid] < target) {\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n    return low;\n  }\n  findInterval(target) {\n    const precomputedSteps = this.getPrecomputedSteps();\n    let low;\n    let high;\n    if (precomputedSteps == null) {\n      low = 0;\n      high = this.domain.length - 1;\n    } else {\n      const sortedTimestamps = this.getSortedTimestamps();\n      const d0 = sortedTimestamps[0];\n      const d1 = sortedTimestamps[sortedTimestamps.length - 1];\n      const i = Math.min(\n        (target - d0) / (d1 - d0) * precomputedSteps.length | 0,\n        precomputedSteps.length - 1 | 0\n      );\n      low = precomputedSteps[i];\n      high = i < precomputedSteps.length - 2 ? precomputedSteps[i + 1] : sortedTimestamps.length - 1;\n    }\n    return this.findIntervalInRange(target, low, high);\n  }\n  /**\n   * Returns a time format function suitable for displaying tick values.\n   * @param specifier If the specifier string is provided, this method is equivalent to\n   * the {@link TimeLocaleObject.format} method.\n   * If no specifier is provided, this method returns the default time format function.\n   */\n  tickFormatter({ domain, ticks, specifier }) {\n    return specifier != null ? buildFormatter(specifier) : defaultTimeTickFormat(ticks, domain);\n  }\n  datumFormatter(params) {\n    return this.tickFormatter(params);\n  }\n  invert(position, nearest = false) {\n    this.refresh();\n    const { domain } = this;\n    if (nearest) {\n      const index = this.invertNearestIndex(position - this.bandwidth / 2);\n      return index != null ? domain[index] : void 0;\n    }\n    const closest = findMinValue(0, domain.length - 1, (i) => {\n      const p = this.ordinalRange(i);\n      return p >= position ? domain[i] : void 0;\n    });\n    return closest ?? domain[0];\n  }\n  getIndex(value) {\n    const sortedTimestamps = this.getSortedTimestamps();\n    const n = Number(value);\n    if (n < sortedTimestamps[0]) {\n      return void 0;\n    }\n    let i = this.findInterval(n);\n    if (this.isReversed) {\n      i = this.domain.length - i - 1;\n    }\n    return i;\n  }\n};\nfunction getDefaultTicks(domain, maxTickCount, isReversed, visibleRange) {\n  const ticks = [];\n  const tickEvery = Math.ceil(domain.length / maxTickCount);\n  const tickOffset = Math.floor(tickEvery / 2);\n  const startIndex = Math.floor(visibleRange[0] * domain.length);\n  const endIndex = Math.ceil(visibleRange[1] * domain.length);\n  for (let index = startIndex; index < endIndex; index += 1) {\n    const tickIndex = isReversed ? domain.length - 1 - index : index;\n    if (tickEvery <= 0 || (tickIndex + tickOffset) % tickEvery === 0) {\n      ticks.push(domain[index]);\n    }\n  }\n  if (isReversed) {\n    ticks.reverse();\n  }\n  return ticks;\n}\n\n// packages/ag-charts-community/src/scene/selection.ts\nvar Selection = class _Selection {\n  constructor(parentNode, classOrFactory, autoCleanup = true) {\n    this.parentNode = parentNode;\n    this.autoCleanup = autoCleanup;\n    this.garbageBin = /* @__PURE__ */ new Set();\n    this._nodesMap = /* @__PURE__ */ new Map();\n    this._nodes = [];\n    this.data = [];\n    this.debug = Debug.create(true, \"scene\", \"scene:selections\");\n    this.nodeFactory = Object.prototype.isPrototypeOf.call(Node, classOrFactory) ? () => new classOrFactory() : classOrFactory;\n  }\n  static select(parent, classOrFactory, garbageCollection = true) {\n    return new _Selection(parent, classOrFactory, garbageCollection);\n  }\n  static selectAll(parent, predicate) {\n    const results = [];\n    const traverse = (node) => {\n      if (predicate(node)) {\n        results.push(node);\n      }\n      for (const child of node.children()) {\n        traverse(child);\n      }\n    };\n    traverse(parent);\n    return results;\n  }\n  static selectByClass(node, ...Classes) {\n    return _Selection.selectAll(node, (n) => Classes.some((C2) => n instanceof C2));\n  }\n  static selectByTag(node, tag) {\n    return _Selection.selectAll(node, (n) => n.tag === tag);\n  }\n  createNode(datum, initializer, idx) {\n    const node = this.nodeFactory(datum);\n    node.datum = datum;\n    initializer?.(node);\n    if (idx == null) {\n      this._nodes.push(node);\n    } else {\n      this._nodes.splice(idx, 0, node);\n    }\n    this.parentNode.appendChild(node);\n    return node;\n  }\n  /**\n   * Update the data in a selection. If an `getDatumId()` function is provided, maintain a list of ids related to\n   * the nodes. Otherwise, take the more efficient route of simply creating and destroying nodes at the end\n   * of the array.\n   */\n  update(data, initializer, getDatumId) {\n    if (this.garbageBin.size > 0) {\n      this.debug(`Selection - update() called with pending garbage`, data);\n    }\n    if (getDatumId) {\n      const dataMap = new Map(\n        data.map((datum, idx) => [getDatumId(datum), [datum, idx]])\n      );\n      for (const [node, datumId] of this._nodesMap.entries()) {\n        if (dataMap.has(datumId)) {\n          const [newDatum] = dataMap.get(datumId);\n          node.datum = newDatum;\n          this.garbageBin.delete(node);\n          dataMap.delete(datumId);\n        } else {\n          this.garbageBin.add(node);\n        }\n      }\n      for (const [datumId, [datum, idx]] of dataMap.entries()) {\n        this._nodesMap.set(this.createNode(datum, initializer, idx), datumId);\n      }\n    } else {\n      const maxLength = Math.max(data.length, this.data.length);\n      for (let i = 0; i < maxLength; i++) {\n        if (i >= data.length) {\n          this.garbageBin.add(this._nodes[i]);\n        } else if (i >= this._nodes.length) {\n          this.createNode(data[i], initializer);\n        } else {\n          this._nodes[i].datum = data[i];\n          this.garbageBin.delete(this._nodes[i]);\n        }\n      }\n    }\n    this.data = data.slice();\n    if (this.autoCleanup) {\n      this.cleanup();\n    }\n    return this;\n  }\n  cleanup() {\n    if (this.garbageBin.size === 0) {\n      return this;\n    }\n    this._nodes = this._nodes.filter((node) => {\n      if (this.garbageBin.has(node)) {\n        this._nodesMap.delete(node);\n        this.garbageBin.delete(node);\n        node.destroy();\n        return false;\n      }\n      return true;\n    });\n    return this;\n  }\n  clear() {\n    this.update([]);\n    return this;\n  }\n  isGarbage(node) {\n    return this.garbageBin.has(node);\n  }\n  each(iterate2) {\n    for (const entry of this._nodes.entries()) {\n      iterate2(entry[1], entry[1].datum, entry[0]);\n    }\n    return this;\n  }\n  *[Symbol.iterator]() {\n    for (let index = 0; index < this._nodes.length; index++) {\n      const node = this._nodes[index];\n      yield { node, datum: node.datum, index };\n    }\n  }\n  select(predicate) {\n    return _Selection.selectAll(this.parentNode, predicate);\n  }\n  selectByClass(Class) {\n    return _Selection.selectByClass(this.parentNode, Class);\n  }\n  selectByTag(tag) {\n    return _Selection.selectByTag(this.parentNode, tag);\n  }\n  nodes() {\n    return this._nodes;\n  }\n  at(index) {\n    return this._nodes.at(index);\n  }\n  get length() {\n    return this._nodes.length;\n  }\n};\n\n// packages/ag-charts-community/src/util/distance.ts\nfunction pointsDistanceSquared(x1, y1, x2, y2) {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return dx * dx + dy * dy;\n}\nfunction lineDistanceSquared(x, y, x1, y1, x2, y2, best) {\n  if (x1 === x2 && y1 === y2) {\n    return Math.min(best, pointsDistanceSquared(x, y, x1, y1));\n  }\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const t = Math.max(0, Math.min(1, ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy)));\n  const ix = x1 + t * dx;\n  const iy = y1 + t * dy;\n  return Math.min(best, pointsDistanceSquared(x, y, ix, iy));\n}\nfunction arcDistanceSquared(x, y, cx, cy, radius, startAngle, endAngle, counterClockwise, best) {\n  if (counterClockwise) {\n    [endAngle, startAngle] = [startAngle, endAngle];\n  }\n  const angle2 = Math.atan2(y - cy, x - cx);\n  if (!isBetweenAngles(angle2, startAngle, endAngle)) {\n    const startX = cx + Math.cos(startAngle) * radius;\n    const startY = cy + Math.sin(startAngle) * radius;\n    const endX = cx + Math.cos(startAngle) * radius;\n    const endY = cy + Math.sin(startAngle) * radius;\n    return Math.min(best, pointsDistanceSquared(x, y, startX, startY), pointsDistanceSquared(x, y, endX, endY));\n  }\n  const distToArc = radius - Math.sqrt(pointsDistanceSquared(x, y, cx, cy));\n  return Math.min(best, distToArc * distToArc);\n}\n\n// packages/ag-charts-community/src/scene/shape/line.ts\nvar Line = class extends Shape {\n  constructor(opts = {}) {\n    super(opts);\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.restoreOwnStyles();\n  }\n  set x(value) {\n    this.x1 = value;\n    this.x2 = value;\n  }\n  set y(value) {\n    this.y1 = value;\n    this.y2 = value;\n  }\n  get midPoint() {\n    return { x: (this.x1 + this.x2) / 2, y: (this.y1 + this.y2) / 2 };\n  }\n  computeBBox() {\n    return new BBox(\n      Math.min(this.x1, this.x2),\n      Math.min(this.y1, this.y2),\n      Math.abs(this.x2 - this.x1),\n      Math.abs(this.y2 - this.y1)\n    );\n  }\n  isPointInPath(x, y) {\n    if (this.x1 === this.x2 || this.y1 === this.y2) {\n      return this.getBBox().clone().grow(this.strokeWidth / 2).containsPoint(x, y);\n    }\n    return false;\n  }\n  distanceSquared(px, py) {\n    const { x1, y1, x2, y2 } = this;\n    return lineDistanceSquared(px, py, x1, y1, x2, y2, Infinity);\n  }\n  render(renderCtx) {\n    const { ctx, devicePixelRatio } = renderCtx;\n    let { x1, y1, x2, y2 } = this;\n    if (x1 === x2) {\n      const { strokeWidth } = this;\n      const x = Math.round(x1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);\n      x1 = x;\n      x2 = x;\n    } else if (y1 === y2) {\n      const { strokeWidth } = this;\n      const y = Math.round(y1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);\n      y1 = y;\n      y2 = y;\n    }\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    this.fillStroke(ctx);\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n  toSVG() {\n    if (!this.visible)\n      return;\n    const element2 = createSvgElement(\"line\");\n    element2.setAttribute(\"x1\", String(this.x1));\n    element2.setAttribute(\"y1\", String(this.y1));\n    element2.setAttribute(\"x2\", String(this.x2));\n    element2.setAttribute(\"y2\", String(this.y2));\n    this.applySvgStrokeAttributes(element2);\n    return {\n      elements: [element2]\n    };\n  }\n};\nLine.className = \"Line\";\nLine.defaultStyles = { ...Shape.defaultStyles, fill: void 0, strokeWidth: 1 };\n__decorateClass([\n  SceneChangeDetection()\n], Line.prototype, \"x1\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], Line.prototype, \"y1\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], Line.prototype, \"x2\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], Line.prototype, \"y2\", 2);\n\n// packages/ag-charts-community/src/util/format.util.ts\nvar defaultNumberFormatter = new Intl.NumberFormat(\"en-US\", { maximumFractionDigits: 2, useGrouping: false });\nvar percentFormatter = new Intl.NumberFormat(\"en-US\", { style: \"percent\" });\nfunction formatValue(value, maximumFractionDigits = 2) {\n  if (typeof value === \"number\") {\n    return formatNumber(value, maximumFractionDigits);\n  }\n  return String(value ?? \"\");\n}\nfunction formatPercent(value) {\n  return percentFormatter.format(value);\n}\nfunction formatNumber(value, maximumFractionDigits) {\n  if (maximumFractionDigits === 2) {\n    return defaultNumberFormatter.format(value);\n  }\n  return new Intl.NumberFormat(\"en-US\", { maximumFractionDigits, useGrouping: false }).format(value);\n}\n\n// packages/ag-charts-community/src/scene/shape/range.ts\nvar Range = class extends Shape {\n  constructor(opts = {}) {\n    super(opts);\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.startLine = false;\n    this.endLine = false;\n    this.isRange = false;\n    this.restoreOwnStyles();\n  }\n  computeBBox() {\n    return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);\n  }\n  isPointInPath(_x, _y) {\n    return false;\n  }\n  render(renderCtx) {\n    const { ctx } = renderCtx;\n    let { x1, y1, x2, y2 } = this;\n    x1 = this.align(x1);\n    y1 = this.align(y1);\n    x2 = this.align(x2);\n    y2 = this.align(y2);\n    const { fill, opacity, isRange } = this;\n    const fillActive = !!(isRange && fill);\n    if (fillActive) {\n      const { fillOpacity } = this;\n      this.applyFill(ctx);\n      ctx.globalAlpha = opacity * fillOpacity;\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y1);\n      ctx.lineTo(x2, y2);\n      ctx.lineTo(x1, y2);\n      ctx.closePath();\n      ctx.fill();\n    }\n    const { stroke: stroke2, strokeWidth, startLine, endLine } = this;\n    const strokeActive = !!((startLine || endLine) && stroke2 && strokeWidth);\n    if (strokeActive) {\n      const { strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin } = this;\n      this.applyStroke(ctx);\n      ctx.globalAlpha = opacity * strokeOpacity;\n      ctx.lineWidth = strokeWidth;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      ctx.beginPath();\n      if (startLine) {\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y1);\n      }\n      if (endLine) {\n        ctx.moveTo(x2, y2);\n        ctx.lineTo(x1, y2);\n      }\n      ctx.stroke();\n    }\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n};\nRange.className = \"Range\";\nRange.defaultStyles = {\n  ...Shape.defaultStyles,\n  strokeWidth: 1\n};\n__decorateClass([\n  SceneChangeDetection()\n], Range.prototype, \"x1\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], Range.prototype, \"y1\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], Range.prototype, \"x2\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], Range.prototype, \"y2\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], Range.prototype, \"startLine\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], Range.prototype, \"endLine\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], Range.prototype, \"isRange\", 2);\n\n// packages/ag-charts-community/src/chart/label.ts\nvar Label = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n  getFont() {\n    return TextUtils.toFontString(this);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Label.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], Label.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], Label.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], Label.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Label.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], Label.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], Label.prototype, \"formatter\", 2);\nfunction calculateLabelRotation(opts) {\n  const { parallelFlipRotation = 0, regularFlipRotation = 0 } = opts;\n  const configuredRotation = opts.rotation ? normalizeAngle360(toRadians(opts.rotation)) : 0;\n  const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n  const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n  let defaultRotation = 0;\n  if (opts.parallel) {\n    defaultRotation = parallelFlipFlag * Math.PI / 2;\n  } else if (regularFlipFlag === -1) {\n    defaultRotation = Math.PI;\n  }\n  return { configuredRotation, defaultRotation, parallelFlipFlag, regularFlipFlag };\n}\nfunction getLabelSpacing(minSpacing, rotated) {\n  if (!isNaN(minSpacing)) {\n    return minSpacing;\n  }\n  return rotated ? 0 : 10;\n}\nfunction getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag) {\n  if (parallel && !labelRotation) {\n    return sideFlag * parallelFlipFlag === -1 ? \"hanging\" : \"bottom\";\n  }\n  return \"middle\";\n}\nfunction getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {\n  const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;\n  const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;\n  const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;\n  if (parallel) {\n    if (labelRotation || labelAutoRotation) {\n      if (sideFlag * alignFlag === -1) {\n        return \"end\";\n      }\n    } else {\n      return \"center\";\n    }\n  } else if (sideFlag * regularFlipFlag === -1) {\n    return \"end\";\n  }\n  return \"start\";\n}\nfunction createLabelData(tickData, labelX, labelMatrix, textMeasurer) {\n  const labelData = [];\n  for (const { tickLabel: text2, translationY } of tickData) {\n    if (!text2)\n      continue;\n    const { width: width2, height: height2 } = textMeasurer.measureLines(text2);\n    const bbox = new BBox(labelX, translationY, width2, height2);\n    const translatedBBox = new BBox(labelX, translationY, 0, 0);\n    labelMatrix.transformBBox(translatedBBox, bbox);\n    const { x, y } = bbox;\n    labelData.push({\n      point: { x, y },\n      label: { text: text2, width: width2, height: height2 }\n    });\n  }\n  return labelData;\n}\n\n// packages/ag-charts-community/src/util/value.ts\nfunction isStringObject(value) {\n  return value != null && Object.hasOwn(value, \"toString\") && isString(value.toString());\n}\nfunction isNumberObject(value) {\n  return value != null && Object.hasOwn(value, \"valueOf\") && isFiniteNumber(value.valueOf());\n}\nfunction isContinuous(value) {\n  return isFiniteNumber(value) || isValidDate(value) || isNumberObject(value);\n}\nfunction checkDatum(value, isContinuousScale) {\n  return value != null && (!isContinuousScale || isContinuous(value));\n}\nfunction transformIntegratedCategoryValue(value) {\n  if (isStringObject(value) && Object.hasOwn(value, \"id\")) {\n    return value.id;\n  }\n  return value;\n}\n\n// packages/ag-charts-community/src/chart/crossline/crossLine.ts\nvar MATCHING_CROSSLINE_TYPE = (property) => {\n  return property === \"value\" ? predicateWithMessage(\n    (_, ctx) => ctx.target[\"type\"] === \"line\",\n    (ctx) => ctx.target[\"type\"] === \"range\" ? `crossLine type 'range' to have a 'range' property instead of 'value'` : `crossLine property 'type' to be 'line'`\n  ) : predicateWithMessage(\n    (_, ctx) => ctx.target[\"type\"] === \"range\",\n    (ctx) => ctx.target.type === \"line\" ? `crossLine type 'line' to have a 'value' property instead of 'range'` : `crossLine property 'type' to be 'range'`\n  );\n};\nvar validateCrossLineValues = (type, value, range3, scale2, visibilityCheck) => {\n  const lineCrossLine = type === \"line\" && value !== void 0;\n  const rangeCrossLine = type === \"range\" && range3 !== void 0;\n  if (!lineCrossLine && !rangeCrossLine) {\n    return true;\n  }\n  const [start2, end2] = range3 ?? [value, void 0];\n  const isContinuous2 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n  const validStart = checkDatum(start2, isContinuous2) && !isNaN(scale2.convert(start2));\n  const validEnd = checkDatum(end2, isContinuous2) && !isNaN(scale2.convert(end2));\n  if (lineCrossLine && validStart || rangeCrossLine && validStart && validEnd) {\n    return visibilityCheck?.() ?? true;\n  }\n  const message = [`Expecting crossLine`];\n  if (rangeCrossLine) {\n    if (!validStart) {\n      message.push(`range start ${stringifyValue(start2)}`);\n    }\n    if (!validEnd) {\n      message.push(`${validStart ? \"\" : \"and \"}range end ${stringifyValue(end2)}`);\n    }\n  } else {\n    message.push(`value ${stringifyValue(start2)}`);\n  }\n  message.push(`to match the axis scale domain.`);\n  logger_exports.warnOnce(message.join(\" \"));\n  return false;\n};\n\n// packages/ag-charts-community/src/chart/crossline/crossLineLabelPosition.ts\nvar horizontalCrosslineTranslationDirections = {\n  top: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  bottom: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  left: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  right: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  \"top-left\": { xTranslationDirection: 1, yTranslationDirection: -1 },\n  \"top-right\": { xTranslationDirection: -1, yTranslationDirection: -1 },\n  \"bottom-left\": { xTranslationDirection: 1, yTranslationDirection: 1 },\n  \"bottom-right\": { xTranslationDirection: -1, yTranslationDirection: 1 },\n  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\n  \"inside-left\": { xTranslationDirection: 1, yTranslationDirection: 0 },\n  \"inside-right\": { xTranslationDirection: -1, yTranslationDirection: 0 },\n  \"inside-top\": { xTranslationDirection: 0, yTranslationDirection: 1 },\n  \"inside-bottom\": { xTranslationDirection: 0, yTranslationDirection: -1 },\n  \"inside-top-left\": { xTranslationDirection: 1, yTranslationDirection: 1 },\n  \"inside-bottom-left\": { xTranslationDirection: 1, yTranslationDirection: -1 },\n  \"inside-top-right\": { xTranslationDirection: -1, yTranslationDirection: 1 },\n  \"inside-bottom-right\": { xTranslationDirection: -1, yTranslationDirection: -1 }\n};\nvar verticalCrossLineTranslationDirections = {\n  top: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  bottom: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  left: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  right: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  \"top-left\": { xTranslationDirection: -1, yTranslationDirection: -1 },\n  \"top-right\": { xTranslationDirection: -1, yTranslationDirection: 1 },\n  \"bottom-left\": { xTranslationDirection: 1, yTranslationDirection: -1 },\n  \"bottom-right\": { xTranslationDirection: 1, yTranslationDirection: 1 },\n  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\n  \"inside-left\": { xTranslationDirection: 0, yTranslationDirection: 1 },\n  \"inside-right\": { xTranslationDirection: 0, yTranslationDirection: -1 },\n  \"inside-top\": { xTranslationDirection: -1, yTranslationDirection: 0 },\n  \"inside-bottom\": { xTranslationDirection: 1, yTranslationDirection: 0 },\n  \"inside-top-left\": { xTranslationDirection: -1, yTranslationDirection: 1 },\n  \"inside-bottom-left\": { xTranslationDirection: 1, yTranslationDirection: 1 },\n  \"inside-top-right\": { xTranslationDirection: -1, yTranslationDirection: -1 },\n  \"inside-bottom-right\": { xTranslationDirection: 1, yTranslationDirection: -1 }\n};\nfunction calculateLabelTranslation({\n  yDirection,\n  padding = 0,\n  position = \"top\",\n  bbox\n}) {\n  const crossLineTranslationDirections = yDirection ? horizontalCrosslineTranslationDirections : verticalCrossLineTranslationDirections;\n  const { xTranslationDirection, yTranslationDirection } = crossLineTranslationDirections[position];\n  const xTranslation = xTranslationDirection * (padding + bbox.width / 2);\n  const yTranslation = yTranslationDirection * (padding + bbox.height / 2);\n  return {\n    xTranslation,\n    yTranslation\n  };\n}\nfunction calculateLabelChartPadding({\n  yDirection,\n  bbox,\n  padding = 0,\n  position = \"top\"\n}) {\n  const chartPadding = {};\n  if (position.startsWith(\"inside\"))\n    return chartPadding;\n  if (position === \"top\" && !yDirection) {\n    chartPadding.top = padding + bbox.height;\n  } else if (position === \"bottom\" && !yDirection) {\n    chartPadding.bottom = padding + bbox.height;\n  } else if (position === \"left\" && yDirection) {\n    chartPadding.left = padding + bbox.width;\n  } else if (position === \"right\" && yDirection) {\n    chartPadding.right = padding + bbox.width;\n  }\n  return chartPadding;\n}\nvar POSITION_TOP_COORDINATES = ({ direction, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xEnd / 2, y: yStart };\n  } else {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  }\n};\nvar POSITION_LEFT_COORDINATES = ({ direction, xStart, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  } else {\n    return { x: xEnd / 2, y: yStart };\n  }\n};\nvar POSITION_RIGHT_COORDINATES = ({ direction, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  } else {\n    return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar POSITION_BOTTOM_COORDINATES = ({ direction, xStart, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  }\n};\nvar POSITION_INSIDE_COORDINATES = ({ xEnd, yStart, yEnd }) => {\n  return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n};\nvar POSITION_TOP_LEFT_COORDINATES = ({ direction, xStart, xEnd, yStart }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xStart / 2, y: yStart };\n  } else {\n    return { x: xEnd, y: yStart };\n  }\n};\nvar POSITION_BOTTOM_LEFT_COORDINATES = ({ direction, xStart, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: yStart };\n  }\n};\nvar POSITION_TOP_RIGHT_COORDINATES = ({ direction, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xEnd, y: yStart };\n  } else {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar POSITION_BOTTOM_RIGHT_COORDINATES = ({ direction, xStart, xEnd, yStart, yEnd }) => {\n  if (direction === \"y\" /* Y */) {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar labelDirectionHandling = {\n  top: { c: POSITION_TOP_COORDINATES },\n  bottom: { c: POSITION_BOTTOM_COORDINATES },\n  left: { c: POSITION_LEFT_COORDINATES },\n  right: { c: POSITION_RIGHT_COORDINATES },\n  \"top-left\": { c: POSITION_TOP_LEFT_COORDINATES },\n  \"top-right\": { c: POSITION_TOP_RIGHT_COORDINATES },\n  \"bottom-left\": { c: POSITION_BOTTOM_LEFT_COORDINATES },\n  \"bottom-right\": { c: POSITION_BOTTOM_RIGHT_COORDINATES },\n  inside: { c: POSITION_INSIDE_COORDINATES },\n  \"inside-left\": { c: POSITION_LEFT_COORDINATES },\n  \"inside-right\": { c: POSITION_RIGHT_COORDINATES },\n  \"inside-top\": { c: POSITION_TOP_COORDINATES },\n  \"inside-bottom\": { c: POSITION_BOTTOM_COORDINATES },\n  \"inside-top-left\": { c: POSITION_TOP_LEFT_COORDINATES },\n  \"inside-bottom-left\": { c: POSITION_BOTTOM_LEFT_COORDINATES },\n  \"inside-top-right\": { c: POSITION_TOP_RIGHT_COORDINATES },\n  \"inside-bottom-right\": { c: POSITION_BOTTOM_RIGHT_COORDINATES }\n};\n\n// packages/ag-charts-community/src/chart/crossline/cartesianCrossLine.ts\nvar CROSSLINE_LABEL_POSITION = UNION(\n  [\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"top-left\",\n    \"top-right\",\n    \"bottom-left\",\n    \"bottom-right\",\n    \"inside\",\n    \"inside-left\",\n    \"inside-right\",\n    \"inside-top\",\n    \"inside-bottom\",\n    \"inside-top-left\",\n    \"inside-bottom-left\",\n    \"inside-top-right\",\n    \"inside-bottom-right\"\n  ],\n  \"crossLine label position\"\n);\nvar CartesianCrossLineLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fontSize = 14;\n    this.fontFamily = \"Verdana, sans-serif\";\n    this.padding = 5;\n    this.color = \"rgba(87, 87, 87, 1)\";\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianCrossLineLabel.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], CartesianCrossLineLabel.prototype, \"text\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], CartesianCrossLineLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], CartesianCrossLineLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], CartesianCrossLineLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], CartesianCrossLineLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], CartesianCrossLineLabel.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], CartesianCrossLineLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(CROSSLINE_LABEL_POSITION, { optional: true })\n], CartesianCrossLineLabel.prototype, \"position\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], CartesianCrossLineLabel.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianCrossLineLabel.prototype, \"parallel\", 2);\nvar CartesianCrossLine = class extends BaseProperties {\n  constructor() {\n    super();\n    this.id = createId(this);\n    this.label = new CartesianCrossLineLabel();\n    this.scale = void 0;\n    this.clippedRange = [-Infinity, Infinity];\n    this.gridLength = 0;\n    this.sideFlag = -1;\n    this.parallelFlipRotation = 0;\n    this.regularFlipRotation = 0;\n    this.direction = \"x\" /* X */;\n    this.rangeGroup = new Group({ name: this.id });\n    this.lineGroup = new Group({ name: this.id });\n    this.labelGroup = new Group({ name: this.id });\n    this.crossLineRange = new Range();\n    this.crossLineLabel = new TransformableText();\n    this.labelPoint = void 0;\n    this.data = [];\n    this.startLine = false;\n    this.endLine = false;\n    this.isRange = false;\n    this._isRange = void 0;\n    this.lineGroup.append(this.crossLineRange);\n    this.labelGroup.append(this.crossLineLabel);\n    this.crossLineRange.pointerEvents = 1 /* None */;\n  }\n  update(visible) {\n    const { enabled, data, type, value, range: range3, scale: scale2 } = this;\n    if (!type || !scale2 || !enabled || !visible || !validateCrossLineValues(type, value, range3, scale2) || data.length === 0) {\n      this.rangeGroup.visible = false;\n      this.lineGroup.visible = false;\n      this.labelGroup.visible = false;\n      return;\n    }\n    this.rangeGroup.visible = visible;\n    this.lineGroup.visible = visible;\n    this.labelGroup.visible = visible;\n    this.updateNodes();\n    const { isRange } = this;\n    if (isRange !== this._isRange) {\n      if (isRange) {\n        this.rangeGroup.appendChild(this.crossLineRange);\n      } else {\n        this.lineGroup.appendChild(this.crossLineRange);\n      }\n    }\n    this._isRange = isRange;\n  }\n  calculateLayout(visible, reversedAxis) {\n    if (!visible)\n      return;\n    const {\n      scale: scale2,\n      gridLength,\n      sideFlag,\n      direction,\n      label: { position = \"top\" },\n      clippedRange,\n      strokeWidth = 0\n    } = this;\n    this.data = [];\n    if (!scale2)\n      return;\n    const bandwidth = scale2.bandwidth ?? 0;\n    const step = scale2.step ?? 0;\n    const padding = (reversedAxis ? -1 : 1) * (scale2 instanceof BandScale ? (step - bandwidth) / 2 : 0);\n    const [xStart, xEnd] = [0, sideFlag * gridLength];\n    let [yStart, yEnd] = this.getRange();\n    const ordinalTimeScalePadding = yEnd === void 0 && OrdinalTimeScale.is(scale2) ? bandwidth / 2 + padding : 0;\n    let [clampedYStart, clampedYEnd] = [\n      Number(scale2.convert(yStart, true)) - padding + ordinalTimeScalePadding,\n      scale2.convert(yEnd, true) + bandwidth + padding\n    ];\n    clampedYStart = clampArray(clampedYStart, clippedRange);\n    clampedYEnd = clampArray(clampedYEnd, clippedRange);\n    [yStart, yEnd] = [Number(scale2.convert(yStart)) + ordinalTimeScalePadding, scale2.convert(yEnd) + bandwidth];\n    const validRange = (yStart === clampedYStart || yEnd === clampedYEnd || clampedYStart !== clampedYEnd) && Math.abs(clampedYEnd - clampedYStart) > 0;\n    if (validRange && clampedYStart > clampedYEnd) {\n      [clampedYStart, clampedYEnd] = [clampedYEnd, clampedYStart];\n      [yStart, yEnd] = [yEnd, yStart];\n    }\n    if (yStart - padding >= clampedYStart)\n      yStart -= padding;\n    if (yEnd + padding <= clampedYEnd)\n      yEnd += padding;\n    this.isRange = validRange;\n    this.startLine = strokeWidth > 0 && yStart >= clampedYStart && yStart <= clampedYStart + padding;\n    this.endLine = strokeWidth > 0 && yEnd >= clampedYEnd - bandwidth - padding && yEnd <= clampedYEnd;\n    if (!validRange && !this.startLine && !this.endLine)\n      return;\n    this.data = [clampedYStart, clampedYEnd];\n    if (!this.label.enabled)\n      return;\n    const { c = POSITION_TOP_COORDINATES } = labelDirectionHandling[position] ?? {};\n    const { x: labelX, y: labelY } = c({\n      direction,\n      xStart,\n      xEnd,\n      yStart: clampedYStart,\n      yEnd: clampedYEnd\n    });\n    this.labelPoint = {\n      x: labelX,\n      y: labelY\n    };\n  }\n  updateNodes() {\n    this.updateRangeNode();\n    if (this.label.enabled) {\n      this.updateLabel();\n      this.positionLabel();\n    }\n  }\n  updateRangeNode() {\n    const {\n      crossLineRange,\n      sideFlag,\n      gridLength,\n      data,\n      startLine,\n      endLine,\n      isRange,\n      fill,\n      fillOpacity,\n      stroke: stroke2,\n      strokeWidth,\n      lineDash\n    } = this;\n    crossLineRange.x1 = 0;\n    crossLineRange.x2 = sideFlag * gridLength;\n    crossLineRange.y1 = data[0];\n    crossLineRange.y2 = data[1];\n    crossLineRange.startLine = startLine;\n    crossLineRange.endLine = endLine;\n    crossLineRange.isRange = isRange;\n    crossLineRange.fill = fill;\n    crossLineRange.fillOpacity = fillOpacity ?? 1;\n    crossLineRange.stroke = stroke2;\n    crossLineRange.strokeWidth = strokeWidth ?? 1;\n    crossLineRange.strokeOpacity = this.strokeOpacity ?? 1;\n    crossLineRange.lineDash = lineDash;\n  }\n  updateLabel() {\n    const { crossLineLabel, label } = this;\n    if (!label.text)\n      return;\n    crossLineLabel.fontStyle = label.fontStyle;\n    crossLineLabel.fontWeight = label.fontWeight;\n    crossLineLabel.fontSize = label.fontSize;\n    crossLineLabel.fontFamily = label.fontFamily;\n    crossLineLabel.fill = label.color;\n    crossLineLabel.text = label.text;\n  }\n  positionLabel() {\n    const {\n      crossLineLabel,\n      labelPoint: { x = void 0, y = void 0 } = {},\n      label: { parallel, rotation, position = \"top\", padding = 0 },\n      direction,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this;\n    if (x === void 0 || y === void 0)\n      return;\n    const { defaultRotation, configuredRotation } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    crossLineLabel.rotation = defaultRotation + configuredRotation;\n    crossLineLabel.textBaseline = \"middle\";\n    crossLineLabel.textAlign = \"center\";\n    const bbox = crossLineLabel.getBBox();\n    if (!bbox)\n      return;\n    const yDirection = direction === \"y\" /* Y */;\n    const { xTranslation, yTranslation } = calculateLabelTranslation({\n      yDirection,\n      padding,\n      position,\n      bbox\n    });\n    crossLineLabel.translationX = x + xTranslation;\n    crossLineLabel.translationY = y + yTranslation;\n  }\n  getRange() {\n    const { value, range: range3, scale: scale2 } = this;\n    const isContinuous2 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const start2 = range3?.[0] ?? value;\n    let end2 = range3?.[1];\n    if (!isContinuous2 && end2 === void 0) {\n      end2 = start2;\n    }\n    if (isContinuous2 && start2 === end2) {\n      end2 = void 0;\n    }\n    return [start2, end2];\n  }\n  computeLabelBBox() {\n    const { label } = this;\n    if (!label.enabled)\n      return;\n    const tempText = new TransformableText();\n    tempText.fontFamily = label.fontFamily;\n    tempText.fontSize = label.fontSize;\n    tempText.fontStyle = label.fontStyle;\n    tempText.fontWeight = label.fontWeight;\n    tempText.text = label.text;\n    const {\n      labelPoint: { x = void 0, y = void 0 } = {},\n      label: { parallel, rotation, position = \"top\", padding = 0 },\n      direction,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this;\n    if (x === void 0 || y === void 0)\n      return;\n    const { configuredRotation } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    tempText.rotation = configuredRotation;\n    tempText.textBaseline = \"middle\";\n    tempText.textAlign = \"center\";\n    const bbox = tempText.getBBox();\n    if (!bbox)\n      return;\n    const yDirection = direction === \"y\" /* Y */;\n    const { xTranslation, yTranslation } = calculateLabelTranslation({\n      yDirection,\n      padding,\n      position,\n      bbox\n    });\n    tempText.x = x + xTranslation;\n    tempText.y = y + yTranslation;\n    return tempText.getBBox();\n  }\n  calculatePadding(padding) {\n    const {\n      isRange,\n      startLine,\n      endLine,\n      direction,\n      label: { padding: labelPadding = 0, position = \"top\" }\n    } = this;\n    if (!isRange && !startLine && !endLine)\n      return;\n    const crossLineLabelBBox = this.computeLabelBBox();\n    if (crossLineLabelBBox?.x == null || crossLineLabelBBox?.y == null)\n      return;\n    const chartPadding = calculateLabelChartPadding({\n      yDirection: direction === \"y\" /* Y */,\n      padding: labelPadding,\n      position,\n      bbox: crossLineLabelBBox\n    });\n    padding.left = Math.max(padding.left ?? 0, chartPadding.left ?? 0);\n    padding.right = Math.max(padding.right ?? 0, chartPadding.right ?? 0);\n    padding.top = Math.max(padding.top ?? 0, chartPadding.top ?? 0);\n    padding.bottom = Math.max(padding.bottom ?? 0, chartPadding.bottom ?? 0);\n  }\n};\nCartesianCrossLine.className = \"CrossLine\";\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianCrossLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(UNION([\"range\", \"line\"], \"a crossLine type\"), { optional: true })\n], CartesianCrossLine.prototype, \"type\", 2);\n__decorateClass([\n  Validate(AND(MATCHING_CROSSLINE_TYPE(\"range\"), ARRAY.restrict({ length: 2 })), {\n    optional: true\n  })\n], CartesianCrossLine.prototype, \"range\", 2);\n__decorateClass([\n  Validate(MATCHING_CROSSLINE_TYPE(\"value\"), { optional: true })\n], CartesianCrossLine.prototype, \"value\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], CartesianCrossLine.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], CartesianCrossLine.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], CartesianCrossLine.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], CartesianCrossLine.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], CartesianCrossLine.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH, { optional: true })\n], CartesianCrossLine.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], CartesianCrossLine.prototype, \"label\", 2);\n\n// packages/ag-charts-community/src/chart/zIndexMap.ts\nvar ZIndexMap = /* @__PURE__ */ ((ZIndexMap2) => {\n  ZIndexMap2[ZIndexMap2[\"CHART_BACKGROUND\"] = 0] = \"CHART_BACKGROUND\";\n  ZIndexMap2[ZIndexMap2[\"AXIS_GRID\"] = 1] = \"AXIS_GRID\";\n  ZIndexMap2[ZIndexMap2[\"AXIS\"] = 2] = \"AXIS\";\n  ZIndexMap2[ZIndexMap2[\"ZOOM_SELECTION\"] = 3] = \"ZOOM_SELECTION\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_CROSSLINE_RANGE\"] = 4] = \"SERIES_CROSSLINE_RANGE\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_LAYER\"] = 5] = \"SERIES_LAYER\";\n  ZIndexMap2[ZIndexMap2[\"AXIS_FOREGROUND\"] = 6] = \"AXIS_FOREGROUND\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_CROSSHAIR\"] = 7] = \"SERIES_CROSSHAIR\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_CROSSLINE_LINE\"] = 8] = \"SERIES_CROSSLINE_LINE\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_ANNOTATION\"] = 9] = \"SERIES_ANNOTATION\";\n  ZIndexMap2[ZIndexMap2[\"CHART_ANNOTATION\"] = 10] = \"CHART_ANNOTATION\";\n  ZIndexMap2[ZIndexMap2[\"CHART_ANNOTATION_FOCUSED\"] = 11] = \"CHART_ANNOTATION_FOCUSED\";\n  ZIndexMap2[ZIndexMap2[\"STATUS_BAR\"] = 12] = \"STATUS_BAR\";\n  ZIndexMap2[ZIndexMap2[\"SERIES_LABEL\"] = 13] = \"SERIES_LABEL\";\n  ZIndexMap2[ZIndexMap2[\"LEGEND\"] = 14] = \"LEGEND\";\n  ZIndexMap2[ZIndexMap2[\"NAVIGATOR\"] = 15] = \"NAVIGATOR\";\n  ZIndexMap2[ZIndexMap2[\"FOREGROUND\"] = 16] = \"FOREGROUND\";\n  return ZIndexMap2;\n})(ZIndexMap || {});\n\n// packages/ag-charts-community/src/chart/axis/axisGridLine.ts\nvar GRID_STYLE_KEYS = [\"stroke\", \"lineDash\"];\nvar GRID_STYLE = ARRAY_OF(\n  (value) => isObject(value) && Object.keys(value).every((key) => GRID_STYLE_KEYS.includes(key)),\n  \"objects with gridline style properties such as 'stroke' or 'lineDash'\"\n);\nvar AxisGridLine = class {\n  constructor() {\n    this.enabled = true;\n    this.width = 1;\n    this.style = [\n      {\n        stroke: void 0,\n        lineDash: []\n      }\n    ];\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisGridLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisGridLine.prototype, \"width\", 2);\n__decorateClass([\n  Validate(GRID_STYLE)\n], AxisGridLine.prototype, \"style\", 2);\n\n// packages/ag-charts-community/src/util/default.ts\nfunction Default(defaultValue, replaces = [void 0]) {\n  return addTransformToInstanceProperty((_, __, v) => {\n    if (replaces.includes(v)) {\n      return isFunction(defaultValue) ? defaultValue(v) : defaultValue;\n    }\n    return v;\n  });\n}\n\n// packages/ag-charts-community/src/chart/axis/axisInterval.ts\nvar TICK_INTERVAL = predicateWithMessage(\n  (value) => isFiniteNumber(value) && value > 0 || value instanceof TimeInterval,\n  `a non-zero positive Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'`\n);\nvar AxisInterval = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.minSpacing = NaN;\n    this.maxSpacing = NaN;\n  }\n};\n__decorateClass([\n  Validate(TICK_INTERVAL, { optional: true })\n], AxisInterval.prototype, \"step\", 2);\n__decorateClass([\n  Validate(ARRAY, { optional: true })\n], AxisInterval.prototype, \"values\", 2);\n__decorateClass([\n  Validate(MIN_SPACING),\n  Default(NaN)\n], AxisInterval.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(MAX_SPACING),\n  Default(NaN)\n], AxisInterval.prototype, \"maxSpacing\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisLabel.ts\nvar AxisLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n    this.spacing = 5;\n    this.minSpacing = NaN;\n    this.color = \"#575757\";\n    this.avoidCollisions = true;\n    this.mirrored = false;\n    this.parallel = false;\n  }\n  /**\n   * The side of the axis line to position the labels on.\n   * -1 = left (default)\n   * 1 = right\n   */\n  getSideFlag() {\n    return this.mirrored ? 1 : -1;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], AxisLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], AxisLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(NUMBER.restrict({ min: 1 }))\n], AxisLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], AxisLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisLabel.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate(NUMBER_OR_NAN),\n  Default(NaN)\n], AxisLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], AxisLabel.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"avoidCollisions\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"mirrored\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"parallel\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], AxisLabel.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], AxisLabel.prototype, \"formatter\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AxisLabel.prototype, \"format\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisLine.ts\nvar AxisLine = class {\n  constructor() {\n    this.enabled = true;\n    this.width = 1;\n    this.stroke = void 0;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisLine.prototype, \"width\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisLine.prototype, \"stroke\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisTick.ts\nvar AxisTick = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.width = 1;\n    this.size = 6;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisTick.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTick.prototype, \"width\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTick.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisTick.prototype, \"stroke\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisTitle.ts\nvar AxisTitle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.caption = new Caption();\n    this.enabled = false;\n    this.spacing = Caption.SMALL_PADDING;\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.wrapping = \"always\";\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisTitle.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AxisTitle.prototype, \"text\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], AxisTitle.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], AxisTitle.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], AxisTitle.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTitle.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], AxisTitle.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisTitle.prototype, \"color\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], AxisTitle.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], AxisTitle.prototype, \"formatter\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisUtil.ts\nvar NiceMode = /* @__PURE__ */ ((NiceMode2) => {\n  NiceMode2[NiceMode2[\"TickAndDomain\"] = 0] = \"TickAndDomain\";\n  NiceMode2[NiceMode2[\"TicksOnly\"] = 1] = \"TicksOnly\";\n  NiceMode2[NiceMode2[\"Off\"] = 2] = \"Off\";\n  return NiceMode2;\n})(NiceMode || {});\nfunction prepareAxisAnimationContext(axis) {\n  const [requestedRangeMin, requestedRangeMax] = findMinMax(axis.range);\n  const min = Math.floor(requestedRangeMin);\n  const max = Math.ceil(requestedRangeMax);\n  return { min, max, visible: min !== max };\n}\nvar fullCircle = Math.PI * 2;\nvar halfCircle = fullCircle / 2;\nfunction normaliseEndRotation(start2, end2) {\n  const directDistance = Math.abs(end2 - start2);\n  if (directDistance < halfCircle) {\n    return end2;\n  } else if (start2 > end2) {\n    return end2 + fullCircle;\n  }\n  return end2 - fullCircle;\n}\nfunction prepareAxisAnimationFunctions(ctx) {\n  const outOfBounds = (y, range3) => {\n    const [min = ctx.min, max = ctx.max] = findMinMax(range3 ?? []);\n    return y < min || y > max;\n  };\n  const tick = {\n    fromFn(node, datum, status) {\n      let y = node.y1 + node.translationY;\n      let opacity = node.opacity;\n      if (status === \"added\" || outOfBounds(node.datum.translationY, node.datum.range)) {\n        y = datum.translationY;\n        opacity = 0;\n      }\n      return { y: 0, translationY: y, opacity, phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] };\n    },\n    toFn(_node, datum, status) {\n      const y = datum.translationY;\n      let opacity = 1;\n      if (status === \"removed\") {\n        opacity = 0;\n      }\n      return {\n        y: 0,\n        translationY: y,\n        opacity,\n        finish: {\n          // Set explicit y after animation so it's pixel aligned\n          y,\n          translationY: 0\n        }\n      };\n    },\n    applyFn(node, props) {\n      node.setProperties(props);\n      node.visible = !outOfBounds(node.y);\n    }\n  };\n  const label = {\n    fromFn(node, newDatum, status) {\n      const datum = node.previousDatum ?? newDatum;\n      const x = datum.x;\n      const y = datum.y;\n      const rotationCenterX = datum.rotationCenterX;\n      let translationY = Math.round(node.translationY);\n      let rotation = datum.rotation;\n      let opacity = node.opacity;\n      if (status === \"removed\" || outOfBounds(datum.y, datum.range)) {\n        rotation = newDatum.rotation;\n      } else if (status === \"added\" || outOfBounds(node.datum.y, node.datum.range)) {\n        translationY = Math.round(datum.translationY);\n        opacity = 0;\n        rotation = newDatum.rotation;\n      }\n      return {\n        x,\n        y,\n        rotationCenterX,\n        translationY,\n        rotation,\n        opacity,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n      };\n    },\n    toFn(node, datum, status) {\n      const x = datum.x;\n      const y = datum.y;\n      const rotationCenterX = datum.rotationCenterX;\n      const translationY = Math.round(datum.translationY);\n      let rotation = 0;\n      let opacity = 1;\n      if (status === \"added\") {\n        rotation = datum.rotation;\n      } else if (status === \"removed\") {\n        opacity = 0;\n        rotation = datum.rotation;\n      } else {\n        rotation = normaliseEndRotation(node.previousDatum?.rotation ?? datum.rotation, datum.rotation);\n      }\n      return { x, y, rotationCenterX, translationY, rotation, opacity, finish: { rotation: datum.rotation } };\n    }\n  };\n  const line = {\n    fromFn(node, datum) {\n      return {\n        ...node.previousDatum ?? datum,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"updated\"]\n      };\n    },\n    toFn(_node, datum) {\n      return { ...datum };\n    }\n  };\n  const group = {\n    fromFn(node, _datum) {\n      const { rotation, translationX, translationY } = node;\n      return {\n        rotation,\n        translationX,\n        translationY,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"updated\"]\n      };\n    },\n    toFn(_node, datum) {\n      const { rotation, translationX, translationY } = datum;\n      return {\n        rotation,\n        translationX,\n        translationY\n      };\n    }\n  };\n  return { tick, line, label, group };\n}\nfunction resetAxisGroupFn() {\n  return (_node, datum) => {\n    return {\n      rotation: datum.rotation,\n      rotationCenterX: datum.rotationCenterX,\n      rotationCenterY: datum.rotationCenterY,\n      translationX: datum.translationX,\n      translationY: datum.translationY\n    };\n  };\n}\nfunction resetAxisSelectionFn(ctx) {\n  const { visible: rangeVisible, min, max } = ctx;\n  return (_node, datum) => {\n    const y = datum.translationY;\n    const visible = rangeVisible && y >= min && y <= max;\n    return {\n      y,\n      translationY: 0,\n      opacity: 1,\n      visible\n    };\n  };\n}\nfunction resetAxisLabelSelectionFn() {\n  return (_node, datum) => {\n    return {\n      x: datum.x,\n      y: datum.y,\n      translationY: datum.translationY,\n      rotation: datum.rotation,\n      rotationCenterX: datum.rotationCenterX\n    };\n  };\n}\nfunction resetAxisLineSelectionFn() {\n  return (_node, datum) => {\n    return { ...datum };\n  };\n}\n\n// packages/ag-charts-community/src/chart/axis/axis.ts\nvar TranslatableLine = class extends Translatable(Line) {\n};\nvar AxisGroupZIndexMap = /* @__PURE__ */ ((AxisGroupZIndexMap2) => {\n  AxisGroupZIndexMap2[AxisGroupZIndexMap2[\"TickLines\"] = 0] = \"TickLines\";\n  AxisGroupZIndexMap2[AxisGroupZIndexMap2[\"AxisLine\"] = 1] = \"AxisLine\";\n  AxisGroupZIndexMap2[AxisGroupZIndexMap2[\"TickLabels\"] = 2] = \"TickLabels\";\n  return AxisGroupZIndexMap2;\n})(AxisGroupZIndexMap || {});\nvar _Axis = class _Axis {\n  constructor(moduleCtx, scale2) {\n    this.moduleCtx = moduleCtx;\n    this.scale = scale2;\n    this.id = createId(this);\n    this.nice = true;\n    this.reverse = false;\n    this.keys = [];\n    this.interval = new AxisInterval();\n    this.dataDomain = { domain: [], clipped: false };\n    this.layoutConstraints = {\n      stacked: true,\n      align: \"start\",\n      width: 100,\n      unit: \"percent\"\n    };\n    this.boundSeries = [];\n    this.includeInvisibleDomains = false;\n    this.interactionEnabled = true;\n    this.axisGroup = new TransformableGroup({ name: `${this.id}-axis` });\n    // Order is important to apply the correct z-index.\n    this.tickLineGroup = this.axisGroup.appendChild(\n      new Group({ name: `${this.id}-Axis-tick-lines`, zIndex: 0 /* TickLines */ })\n    );\n    this.tickLabelGroup = this.axisGroup.appendChild(\n      new Group({ name: `${this.id}-Axis-tick-labels`, zIndex: 2 /* TickLabels */ })\n    );\n    this.labelGroup = new Group({\n      name: `${this.id}-Labels`,\n      zIndex: 9 /* SERIES_ANNOTATION */\n    });\n    this.gridGroup = new TransformableGroup({ name: `${this.id}-Axis-grid`, zIndex: 1 /* AXIS_GRID */ });\n    this.gridLineGroup = this.gridGroup.appendChild(new Group({ name: `${this.id}-gridLines` }));\n    this.crossLineRangeGroup = new TransformableGroup({\n      name: `${this.id}-CrossLines-Range`,\n      zIndex: 4 /* SERIES_CROSSLINE_RANGE */\n    });\n    this.crossLineLineGroup = new TransformableGroup({\n      name: `${this.id}-CrossLines-Line`,\n      zIndex: 8 /* SERIES_CROSSLINE_LINE */\n    });\n    this.crossLineLabelGroup = new TransformableGroup({\n      name: `${this.id}-CrossLines-Label`,\n      zIndex: 13 /* SERIES_LABEL */\n    });\n    this.tickLineGroupSelection = Selection.select(\n      this.tickLineGroup,\n      TranslatableLine,\n      false\n    );\n    this.tickLabelGroupSelection = Selection.select(\n      this.tickLabelGroup,\n      TransformableText,\n      false\n    );\n    this.gridLineGroupSelection = Selection.select(\n      this.gridLineGroup,\n      TranslatableLine,\n      false\n    );\n    this._crossLines = [];\n    this.line = new AxisLine();\n    this.tick = new AxisTick();\n    this.gridLine = new AxisGridLine();\n    this.label = this.createLabel();\n    this.defaultTickMinSpacing = _Axis.defaultTickMinSpacing;\n    this.translation = { x: 0, y: 0 };\n    this.rotation = 0;\n    // axis rotation angle in degrees\n    this.layout = {\n      label: {\n        fractionDigits: 0,\n        spacing: this.label.spacing,\n        format: this.label.format\n      }\n    };\n    this.axisContext = void 0;\n    this.labelFormatter = void 0;\n    this.datumFormatter = void 0;\n    this.scaleFormatterParams = void 0;\n    this.destroyFns = [];\n    this.range = [0, 1];\n    this.visibleRange = [0, 1];\n    this.title = new AxisTitle();\n    this.gridLength = 0;\n    /**\n     * The distance between the grid ticks and the axis ticks.\n     */\n    this.gridPadding = 0;\n    /**\n     * Is used to avoid collisions between axis labels and series.\n     */\n    this.seriesAreaPadding = 0;\n    this.animatable = true;\n    this._scaleNiceDomainInputDomain = void 0;\n    this._scaleNiceDomainRangeExtent = NaN;\n    this.moduleMap = new ModuleMap();\n    this.range = this.scale.range.slice();\n    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));\n  }\n  get type() {\n    return this.constructor.type ?? \"\";\n  }\n  get labelNodes() {\n    return this.tickLabelGroupSelection.nodes();\n  }\n  set crossLines(value) {\n    const { CrossLineConstructor } = this.constructor;\n    this._crossLines.forEach((crossLine) => this.detachCrossLine(crossLine));\n    this._crossLines = value.map((crossLine) => {\n      const instance = new CrossLineConstructor();\n      instance.set(crossLine);\n      return instance;\n    });\n    this._crossLines.forEach((crossLine) => {\n      this.attachCrossLine(crossLine);\n      this.initCrossLine(crossLine);\n    });\n  }\n  get crossLines() {\n    return this._crossLines;\n  }\n  resetAnimation(_phase) {\n  }\n  attachCrossLine(crossLine) {\n    this.crossLineRangeGroup.appendChild(crossLine.rangeGroup);\n    this.crossLineLineGroup.appendChild(crossLine.lineGroup);\n    this.crossLineLabelGroup.appendChild(crossLine.labelGroup);\n  }\n  detachCrossLine(crossLine) {\n    this.crossLineRangeGroup.removeChild(crossLine.rangeGroup);\n    this.crossLineLineGroup.removeChild(crossLine.lineGroup);\n    this.crossLineLabelGroup.removeChild(crossLine.labelGroup);\n  }\n  destroy() {\n    this.moduleMap.destroy();\n    this.destroyFns.forEach((f) => f());\n  }\n  updateScale() {\n    const { range: rr, visibleRange: vr, scale: scale2 } = this;\n    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    const shift = span * vr[0];\n    const start2 = rr[0] - shift;\n    scale2.range = [start2, start2 + span];\n    this.crossLines.forEach((crossLine) => {\n      crossLine.clippedRange = [rr[0], rr[1]];\n    });\n  }\n  setCrossLinesVisible(visible) {\n    this.crossLineRangeGroup.visible = visible;\n    this.crossLineLineGroup.visible = visible;\n    this.crossLineLabelGroup.visible = visible;\n  }\n  attachAxis(groups) {\n    groups.gridNode.appendChild(this.gridGroup);\n    groups.axisNode.appendChild(this.axisGroup);\n    groups.labelNode.appendChild(this.labelGroup);\n    groups.crossLineRangeNode.appendChild(this.crossLineRangeGroup);\n    groups.crossLineLineNode.appendChild(this.crossLineLineGroup);\n    groups.crossLineLabelNode.appendChild(this.crossLineLabelGroup);\n  }\n  detachAxis(groups) {\n    groups.gridNode.removeChild(this.gridGroup);\n    groups.axisNode.removeChild(this.axisGroup);\n    groups.labelNode.removeChild(this.labelGroup);\n    groups.crossLineRangeNode.removeChild(this.crossLineRangeGroup);\n    groups.crossLineLineNode.removeChild(this.crossLineLineGroup);\n    groups.crossLineLabelNode.removeChild(this.crossLineLabelGroup);\n  }\n  attachLabel(axisLabelNode) {\n    this.labelGroup.append(axisLabelNode);\n  }\n  /**\n   * Checks if a point or an object is in range.\n   * @param value A point (or object's starting point).\n   * @param tolerance Expands the range on both ends by this amount.\n   */\n  inRange(value, tolerance = 0) {\n    const [min, max] = findMinMax(this.range);\n    return value >= min - tolerance && value <= max + tolerance;\n  }\n  defaultDatumFormatter(datum, fractionDigits) {\n    return formatValue(datum, fractionDigits + 1);\n  }\n  defaultLabelFormatter(datum, fractionDigits) {\n    return formatValue(datum, fractionDigits);\n  }\n  onGridLengthChange(value, prevValue) {\n    if (prevValue ^ value) {\n      this.onGridVisibilityChange();\n    }\n    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));\n  }\n  onGridVisibilityChange() {\n    this.gridLineGroupSelection.clear();\n  }\n  createLabel() {\n    return new AxisLabel();\n  }\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   */\n  update() {\n    this.updatePosition();\n    this.updateSelections();\n    this.tickLineGroup.visible = this.tick.enabled;\n    this.gridLineGroup.visible = this.gridLine.enabled;\n    this.tickLabelGroup.visible = this.label.enabled;\n    this.updateLabels();\n    this.updateGridLines();\n    this.updateTickLines();\n    this.updateCrossLines();\n  }\n  getAxisLineCoordinates() {\n    const [min, max] = findMinMax(this.range);\n    return { x: 0, y1: min, y2: max };\n  }\n  getLabelStyles(params, additionalStyles) {\n    const { label } = this;\n    const defaultStyle = {\n      color: label.color,\n      spacing: label.spacing,\n      fontFamily: label.fontFamily,\n      fontSize: label.fontSize,\n      fontStyle: label.fontStyle,\n      fontWeight: label.fontWeight\n    };\n    let stylerOutput;\n    if (label.itemStyler) {\n      stylerOutput = this.moduleCtx.callbackCache.call(label.itemStyler, {\n        ...params,\n        ...defaultStyle\n      });\n    }\n    const {\n      color: fill,\n      fontFamily,\n      fontSize,\n      fontStyle,\n      fontWeight,\n      spacing\n    } = mergeDefaults(stylerOutput, additionalStyles, defaultStyle);\n    return { fill, fontFamily, fontSize, fontStyle, fontWeight, spacing };\n  }\n  getTickSize() {\n    return this.tick.enabled ? this.tick.size : 0;\n  }\n  setTitleProps(caption, params) {\n    const { title } = this;\n    if (!title.enabled) {\n      caption.enabled = false;\n      caption.node.visible = false;\n      return;\n    }\n    caption.enabled = true;\n    caption.color = title.color;\n    caption.fontFamily = title.fontFamily;\n    caption.fontSize = title.fontSize;\n    caption.fontStyle = title.fontStyle;\n    caption.fontWeight = title.fontWeight;\n    caption.wrapping = title.wrapping;\n    const titleNode = caption.node;\n    const padding = (title.spacing ?? 0) + params.spacing;\n    const sideFlag = this.label.getSideFlag();\n    const parallelFlipRotation = normalizeAngle360(this.rotation);\n    const titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n    const rotation = titleRotationFlag * sideFlag * Math.PI / 2;\n    const textBaseline = titleRotationFlag === 1 ? \"bottom\" : \"top\";\n    const { range: range3 } = this;\n    const x = Math.floor(titleRotationFlag * sideFlag * (range3[0] + range3[1]) / 2);\n    const y = sideFlag === -1 ? Math.floor(titleRotationFlag * -padding) : Math.floor(-padding);\n    const { callbackCache } = this.moduleCtx;\n    const { formatter = (p) => p.defaultValue } = title;\n    const text2 = callbackCache.call(formatter, this.getTitleFormatterParams());\n    caption.text = text2;\n    titleNode.setProperties({ visible: true, text: text2, textBaseline, x, y, rotation });\n  }\n  processData() {\n    const { includeInvisibleDomains, boundSeries, direction } = this;\n    const visibleSeries = includeInvisibleDomains ? boundSeries : boundSeries.filter((s) => s.isEnabled());\n    const domains = visibleSeries.map((series) => series.getDomain(direction));\n    this.setDomains(...domains);\n  }\n  setDomains(...domains) {\n    let domain;\n    let animatable;\n    if (domains.length > 0) {\n      ({ domain, animatable } = this.scale.normalizeDomains(...domains));\n    } else {\n      domain = [];\n      animatable = true;\n    }\n    this.dataDomain = this.normaliseDataDomain(domain);\n    if (this.reverse) {\n      this.dataDomain.domain.reverse();\n    }\n    this.animatable = animatable;\n  }\n  calculateLayout(initialPrimaryTickCount) {\n    const { scale: scale2, label, visibleRange, nice } = this;\n    this.updateScale();\n    const rangeExtent = findRangeExtent(this.range);\n    const domain = this.dataDomain.domain;\n    let tickLayoutDomain;\n    if (visibleRange[0] === 0 && visibleRange[1] === 1) {\n      tickLayoutDomain = void 0;\n    } else if (!nice) {\n      tickLayoutDomain = domain;\n    } else if (this._scaleNiceDomainInputDomain === domain && this._scaleNiceDomainRangeExtent === rangeExtent) {\n      tickLayoutDomain = this.scale.domain;\n    } else {\n      tickLayoutDomain = this.calculateTickLayout(domain, 0 /* TickAndDomain */, [0, 1]).niceDomain;\n    }\n    let niceMode;\n    if (!nice) {\n      niceMode = 2 /* Off */;\n    } else if (tickLayoutDomain == null) {\n      niceMode = 0 /* TickAndDomain */;\n    } else {\n      niceMode = 1 /* TicksOnly */;\n    }\n    const { niceDomain, primaryTickCount, ticks, tickDomain, fractionDigits, bbox } = this.calculateTickLayout(\n      tickLayoutDomain ?? domain,\n      niceMode,\n      visibleRange,\n      initialPrimaryTickCount\n    );\n    this.scale.domain = niceDomain;\n    this._scaleNiceDomainInputDomain = nice ? domain : void 0;\n    this._scaleNiceDomainRangeExtent = nice ? rangeExtent : NaN;\n    const specifier = label.format;\n    this.labelFormatter = scale2.tickFormatter({ domain: tickDomain, specifier, ticks, fractionDigits }) ?? ((value) => this.defaultLabelFormatter(value, fractionDigits));\n    this.datumFormatter = scale2.datumFormatter({ domain: tickDomain, specifier, ticks, fractionDigits }) ?? ((value) => this.defaultDatumFormatter(value, fractionDigits));\n    this.scaleFormatterParams = { domain: tickDomain, ticks, fractionDigits };\n    this.layout.label = {\n      fractionDigits,\n      spacing: this.label.spacing,\n      format: this.label.format\n    };\n    const sideFlag = label.getSideFlag();\n    const anySeriesActive = this.isAnySeriesActive();\n    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\n    this.crossLines.forEach((crossLine) => {\n      var _a;\n      crossLine.sideFlag = -sideFlag;\n      crossLine.direction = rotation === -Math.PI / 2 ? \"x\" /* X */ : \"y\" /* Y */;\n      if (crossLine instanceof CartesianCrossLine) {\n        (_a = crossLine.label).parallel ?? (_a.parallel = label.parallel);\n      }\n      crossLine.parallelFlipRotation = parallelFlipRotation;\n      crossLine.regularFlipRotation = regularFlipRotation;\n      crossLine.calculateLayout?.(anySeriesActive, this.reverse);\n    });\n    return { primaryTickCount, bbox };\n  }\n  getTransformBox(bbox) {\n    const matrix = new Matrix();\n    const { rotation, translationX, translationY } = this.getAxisTransform();\n    Matrix.updateTransformMatrix(matrix, 1, 1, rotation, translationX, translationY);\n    return matrix.transformBBox(bbox);\n  }\n  calculateRotations() {\n    const rotation = toRadians(this.rotation);\n    const parallelFlipRotation = normalizeAngle360(rotation);\n    const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n    return { rotation, parallelFlipRotation, regularFlipRotation };\n  }\n  updateCrossLines() {\n    const anySeriesActive = this.isAnySeriesActive();\n    this.crossLines.forEach((crossLine) => {\n      crossLine.update(anySeriesActive);\n    });\n  }\n  updateTickLines() {\n    const { tick, label } = this;\n    const sideFlag = label.getSideFlag();\n    this.tickLineGroupSelection.each((line, datum) => {\n      line.strokeWidth = datum.tickWidth ?? tick.width;\n      line.stroke = datum.tickStroke ?? tick.stroke;\n      line.x1 = sideFlag * (datum.tickSize ?? this.getTickSize());\n      line.x2 = 0;\n    });\n  }\n  getAxisTransform() {\n    return {\n      rotation: toRadians(this.rotation),\n      translationX: Math.floor(this.translation.x),\n      translationY: Math.floor(this.translation.y)\n    };\n  }\n  updatePosition() {\n    const { crossLineRangeGroup, crossLineLineGroup, crossLineLabelGroup, gridGroup, translation } = this;\n    const { rotation } = this.calculateRotations();\n    const translationX = Math.floor(translation.x);\n    const translationY = Math.floor(translation.y);\n    crossLineRangeGroup.setProperties({ rotation, translationX, translationY });\n    crossLineLineGroup.setProperties({ rotation, translationX, translationY });\n    crossLineLabelGroup.setProperties({ rotation, translationX, translationY });\n    gridGroup.setProperties({ rotation, translationX, translationY });\n  }\n  updateGridLines() {\n    const sideFlag = this.label.getSideFlag();\n    const {\n      gridLine: { style, width: width2 },\n      gridPadding,\n      gridLength\n    } = this;\n    if (gridLength === 0 || style.length === 0) {\n      return;\n    }\n    this.gridLineGroupSelection.each((line, _, index) => {\n      const { stroke: stroke2, lineDash } = style[index % style.length];\n      line.setProperties({\n        x1: gridPadding,\n        x2: -sideFlag * gridLength + gridPadding,\n        stroke: stroke2,\n        strokeWidth: width2,\n        lineDash\n      });\n    });\n  }\n  // For formatting (nice rounded) tick values.\n  formatTick(value, index, fractionDigits, defaultFormatter) {\n    const {\n      labelFormatter,\n      label: { formatter },\n      moduleCtx: { callbackCache }\n    } = this;\n    let result;\n    if (formatter) {\n      result = callbackCache.call(formatter, { value, index, fractionDigits });\n    } else if (defaultFormatter) {\n      result = defaultFormatter(value);\n    } else if (labelFormatter) {\n      result = labelFormatter(value);\n    }\n    return String(result ?? value);\n  }\n  // For formatting arbitrary values between the ticks.\n  formatDatum(value) {\n    const {\n      label: { formatter },\n      moduleCtx: { callbackCache },\n      datumFormatter: valueFormatter = this.labelFormatter\n    } = this;\n    let result;\n    if (formatter) {\n      result = callbackCache.call(formatter, { value, index: NaN });\n    } else if (valueFormatter) {\n      result = callbackCache.call(valueFormatter, value);\n    } else if (isArray(value)) {\n      result = value.filter(Boolean).join(\" - \");\n    }\n    return String(result ?? value);\n  }\n  getScaleValueFormatter(format) {\n    const { scaleFormatterParams } = this;\n    let formatter;\n    try {\n      if (format != null && scaleFormatterParams != null) {\n        formatter = this.scale.tickFormatter({ ...scaleFormatterParams, specifier: format });\n      }\n    } catch {\n      logger_exports.warnOnce(`the format string ${format} is invalid, ignoring.`);\n    }\n    formatter ?? (formatter = (value) => this.formatDatum(value));\n    return formatter;\n  }\n  getBBox() {\n    return this.axisGroup.getBBox();\n  }\n  initCrossLine(crossLine) {\n    crossLine.scale = this.scale;\n    crossLine.gridLength = this.gridLength;\n  }\n  isAnySeriesActive() {\n    return this.boundSeries.some((s) => this.includeInvisibleDomains || s.isEnabled());\n  }\n  clipTickLines(x, y, width2, height2) {\n    this.tickLineGroup.setClipRect(new BBox(x, y, width2, height2));\n  }\n  clipGrid(x, y, width2, height2) {\n    this.gridGroup.setClipRect(new BBox(x, y, width2, height2));\n  }\n  getTitleFormatterParams() {\n    const { direction } = this;\n    const boundSeries = [];\n    for (const series of this.boundSeries) {\n      const keys = series.getKeys(direction);\n      const names = series.getNames(direction);\n      for (let idx = 0; idx < keys.length; idx++) {\n        boundSeries.push({ key: keys[idx], name: names[idx] });\n      }\n    }\n    return { direction, boundSeries, defaultValue: this.title?.text };\n  }\n  normaliseDataDomain(d) {\n    return { domain: [...d], clipped: false };\n  }\n  getLayoutState() {\n    return {\n      id: this.id,\n      rect: this.getBBox(),\n      gridPadding: this.gridPadding,\n      seriesAreaPadding: this.seriesAreaPadding,\n      tickSize: this.getTickSize(),\n      direction: this.direction,\n      domain: this.dataDomain.domain,\n      scale: this.scale,\n      ...this.layout\n    };\n  }\n  getModuleMap() {\n    return this.moduleMap;\n  }\n  createModuleContext() {\n    this.axisContext ?? (this.axisContext = this.createAxisContext());\n    return { ...this.moduleCtx, parent: this.axisContext };\n  }\n  createAxisContext() {\n    const { scale: scale2 } = this;\n    return {\n      axisId: this.id,\n      scale: this.scale,\n      direction: this.direction,\n      continuous: ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2),\n      getCanvasBounds: () => {\n        return Transformable.toCanvas(this.axisGroup);\n      },\n      seriesKeyProperties: () => this.boundSeries.reduce((keys, series) => {\n        const seriesKeys = series.getKeyProperties(this.direction);\n        seriesKeys.forEach((key) => keys.add(key));\n        return keys;\n      }, /* @__PURE__ */ new Set()),\n      seriesIds: () => this.boundSeries.map((series) => series.id),\n      scaleValueFormatter: (specifier) => this.getScaleValueFormatter(specifier),\n      scaleInvert: (val) => scale2.invert(val, true),\n      scaleInvertNearest: (val) => scale2.invert(val, true),\n      attachLabel: (node) => this.attachLabel(node),\n      inRange: (x, tolerance) => this.inRange(x, tolerance)\n    };\n  }\n  isReversed() {\n    return this.reverse;\n  }\n};\n_Axis.defaultTickMinSpacing = 50;\n_Axis.CrossLineConstructor = CartesianCrossLine;\n__decorateClass([\n  Validate(BOOLEAN)\n], _Axis.prototype, \"nice\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], _Axis.prototype, \"reverse\", 2);\n__decorateClass([\n  Validate(STRING_ARRAY)\n], _Axis.prototype, \"keys\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Axis.prototype, \"interval\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Axis.prototype, \"title\", 2);\n__decorateClass([\n  ObserveChanges((target, value, oldValue) => target.onGridLengthChange(value, oldValue))\n], _Axis.prototype, \"gridLength\", 2);\nvar Axis = _Axis;\n\n// packages/ag-charts-community/src/scene/util/labelPlacement.ts\nfunction circleRectOverlap(c, unitCenter, x, y, w, h) {\n  if (c.size === 0) {\n    return false;\n  }\n  let cx = c.x;\n  let cy = c.y;\n  if (unitCenter != null) {\n    cx -= (unitCenter.x - 0.5) * c.size;\n    cy -= (unitCenter.y - 0.5) * c.size;\n  }\n  let edgeX = cx;\n  if (cx < x) {\n    edgeX = x;\n  } else if (cx > x + w) {\n    edgeX = x + w;\n  }\n  let edgeY = cy;\n  if (cy < y) {\n    edgeY = y;\n  } else if (cy > y + h) {\n    edgeY = y + h;\n  }\n  const dx = cx - edgeX;\n  const dy = cy - edgeY;\n  const d = Math.sqrt(dx * dx + dy * dy);\n  return d <= c.size * 0.5;\n}\nfunction rectRectOverlap(r1, x2, y2, w2, h2) {\n  const xOverlap = r1.x + r1.width > x2 && r1.x < x2 + w2;\n  const yOverlap = r1.y + r1.height > y2 && r1.y < y2 + h2;\n  return xOverlap && yOverlap;\n}\nfunction rectContainsRect(r1, r2x, r2y, r2w, r2h) {\n  return r2x + r2w < r1.x + r1.width && r2x > r1.x && r2y > r1.y && r2y + r2h < r1.y + r1.height;\n}\nfunction isPointLabelDatum(x) {\n  return x != null && typeof x.point === \"object\" && typeof x.label === \"object\";\n}\nvar labelPlacements = {\n  top: { x: 0, y: -1 },\n  bottom: { x: 0, y: 1 },\n  left: { x: -1, y: 0 },\n  right: { x: 1, y: 0 },\n  \"top-left\": { x: -1, y: -1 },\n  \"top-right\": { x: 1, y: -1 },\n  \"bottom-left\": { x: -1, y: 1 },\n  \"bottom-right\": { x: 1, y: 1 }\n};\nfunction placeLabels(data, bounds, padding = 5) {\n  const result = /* @__PURE__ */ new Map();\n  const previousResults = [];\n  const sortedDataClone = new Map(\n    [...data.entries()].map(([k, d]) => [k, d.toSorted((a, b) => b.point.size - a.point.size)])\n  );\n  const dataValues = [...sortedDataClone.values()].flat();\n  for (const [seriesId, datums] of sortedDataClone.entries()) {\n    const labels = [];\n    if (!datums[0]?.label)\n      continue;\n    for (let index = 0, ln = datums.length; index < ln; index++) {\n      const d = datums[index];\n      const { point, label, anchor } = d;\n      const { text: text2, width: width2, height: height2 } = label;\n      const r = point.size * 0.5;\n      let dx = 0;\n      let dy = 0;\n      if (r > 0 && d.placement != null) {\n        const placement = labelPlacements[d.placement];\n        dx = (width2 * 0.5 + r + padding) * placement.x;\n        dy = (height2 * 0.5 + r + padding) * placement.y;\n      }\n      const x = point.x - width2 * 0.5 + dx - ((anchor?.x ?? 0.5) - 0.5) * point.size;\n      const y = point.y - height2 * 0.5 + dy - ((anchor?.y ?? 0.5) - 0.5) * point.size;\n      const withinBounds = !bounds || rectContainsRect(bounds, x, y, width2, height2);\n      if (!withinBounds)\n        continue;\n      const overlapPoints = dataValues.some(\n        (dataDatum) => circleRectOverlap(dataDatum.point, dataDatum.anchor, x, y, width2, height2)\n      );\n      if (overlapPoints)\n        continue;\n      const overlapLabels = previousResults.some((pr) => rectRectOverlap(pr, x, y, width2, height2));\n      if (overlapLabels)\n        continue;\n      const resultDatum = { index, text: text2, x, y, width: width2, height: height2, datum: d };\n      labels.push(resultDatum);\n      previousResults.push(resultDatum);\n    }\n    result.set(seriesId, labels);\n  }\n  return result;\n}\nfunction axisLabelsOverlap(data, padding = 0) {\n  const result = [];\n  for (let index = 0; index < data.length; index++) {\n    const datum = data[index];\n    const {\n      point: { x, y },\n      label: { text: text2 }\n    } = datum;\n    let { width: width2, height: height2 } = datum.label;\n    width2 += padding;\n    height2 += padding;\n    if (result.some((l) => rectRectOverlap(l, x, y, width2, height2))) {\n      return true;\n    }\n    result.push({ index, text: text2, x, y, width: width2, height: height2, datum });\n  }\n  return false;\n}\n\n// packages/ag-charts-community/src/util/secondaryAxisTicks.ts\nfunction calculateNiceSecondaryAxis(domain, primaryTickCount, reverse) {\n  let [start2, stop] = findMinMax(domain);\n  start2 = calculateNiceStart(Math.floor(start2), stop, primaryTickCount);\n  const step = getTickStep(start2, stop, primaryTickCount);\n  const segments = primaryTickCount - 1;\n  stop = start2 + segments * step;\n  const d = reverse ? [stop, start2] : [start2, stop];\n  const ticks = getTicks(start2, step, primaryTickCount);\n  return { domain: d, ticks };\n}\nfunction calculateNiceStart(a, b, count) {\n  const rawStep = Math.abs(b - a) / (count - 1);\n  const order = Math.floor(Math.log10(rawStep));\n  const magnitude = Math.pow(10, order);\n  return Math.floor(a / magnitude) * magnitude;\n}\nfunction getTicks(start2, step, count) {\n  const stepPower = Math.floor(Math.log10(step));\n  const fractionDigits = step > 0 && step < 1 ? Math.abs(stepPower) : 0;\n  const f = Math.pow(10, fractionDigits);\n  const ticks = [];\n  for (let i = 0; i < count; i++) {\n    const tick = start2 + step * i;\n    ticks[i] = Math.round(tick * f) / f;\n  }\n  return ticks;\n}\nfunction getTickStep(start2, stop, count) {\n  const segments = count - 1;\n  const rawStep = (stop - start2) / segments;\n  return calculateNextNiceStep(rawStep);\n}\nfunction calculateNextNiceStep(rawStep) {\n  const order = Math.floor(Math.log10(rawStep));\n  const magnitude = Math.pow(10, order);\n  const step = rawStep / magnitude * 10;\n  if (step > 0 && step <= 1) {\n    return magnitude / 10;\n  }\n  if (step > 1 && step <= 2) {\n    return 2 * magnitude / 10;\n  }\n  if (step > 1 && step <= 5) {\n    return 5 * magnitude / 10;\n  }\n  if (step > 5 && step <= 10) {\n    return 10 * magnitude / 10;\n  }\n  if (step > 10 && step <= 20) {\n    return 20 * magnitude / 10;\n  }\n  if (step > 20 && step <= 40) {\n    return 40 * magnitude / 10;\n  }\n  if (step > 40 && step <= 50) {\n    return 50 * magnitude / 10;\n  }\n  if (step > 50 && step <= 100) {\n    return 100 * magnitude / 10;\n  }\n  return step;\n}\n\n// packages/ag-charts-community/src/util/tempUtils.ts\nfunction createIdsGenerator() {\n  const idsCounter = /* @__PURE__ */ new Map();\n  return (name) => {\n    const counter = idsCounter.get(name);\n    if (counter) {\n      idsCounter.set(name, counter + 1);\n      return `${name}_${counter}`;\n    }\n    idsCounter.set(name, 1);\n    return name;\n  };\n}\n\n// packages/ag-charts-community/src/chart/axis/axisTickGenerator.ts\nvar AxisTickGenerator = class {\n  constructor(axis) {\n    this.axis = axis;\n  }\n  estimateTickCount(visibleRange, minSpacing, maxSpacing) {\n    return estimateTickCount(\n      findRangeExtent(this.axis.range),\n      findRangeExtent(visibleRange),\n      minSpacing,\n      maxSpacing,\n      ContinuousScale.defaultTickCount,\n      this.axis.defaultTickMinSpacing\n    );\n  }\n  filterTicks(ticks, tickCount) {\n    const { minSpacing, maxSpacing } = this.axis.interval;\n    const tickSpacing = !isNaN(minSpacing) || !isNaN(maxSpacing);\n    const keepEvery = tickSpacing ? Math.ceil(ticks.length / tickCount) : 2;\n    const offset4 = ticks.length % keepEvery ? -1 : 0;\n    return ticks.filter((_, i) => (i + offset4) % keepEvery === 0);\n  }\n  generateTicks({\n    domain,\n    primaryTickCount,\n    visibleRange,\n    niceMode,\n    parallelFlipRotation,\n    regularFlipRotation,\n    labelX,\n    sideFlag\n  }) {\n    const {\n      scale: scale2,\n      label,\n      interval: { minSpacing, maxSpacing }\n    } = this.axis;\n    const { parallel, rotation, fontFamily, fontSize, fontStyle, fontWeight } = label;\n    const secondaryAxis = primaryTickCount !== void 0;\n    const { defaultRotation, configuredRotation, parallelFlipFlag, regularFlipFlag } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    const initialRotation = configuredRotation + defaultRotation;\n    const labelMatrix = new Matrix();\n    const { maxTickCount } = this.estimateTickCount(visibleRange, minSpacing, maxSpacing);\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\n    let textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\n    const textBaseline = getTextBaseline(parallel, configuredRotation, sideFlag, parallelFlipFlag);\n    const font2 = TextUtils.toFontString({ fontFamily, fontSize, fontStyle, fontWeight });\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font: font2 });\n    const textProps = {\n      fontFamily,\n      fontSize,\n      fontStyle,\n      fontWeight,\n      textBaseline,\n      textAlign\n    };\n    const checkLabelOverlap = label.enabled && label.avoidCollisions;\n    const getLabelOverlap = ({ ticks }, iterationRotation) => {\n      if (!checkLabelOverlap)\n        return false;\n      const rotated = configuredRotation !== 0 || iterationRotation !== 0;\n      const labelRotation = initialRotation + iterationRotation;\n      const labelSpacing = getLabelSpacing(label.minSpacing, rotated);\n      Matrix.updateTransformMatrix(labelMatrix, 1, 1, labelRotation, 0, 0);\n      const labelData = createLabelData(ticks, labelX, labelMatrix, textMeasurer);\n      return axisLabelsOverlap(labelData, labelSpacing);\n    };\n    let tickData = {\n      tickDomain: [],\n      ticks: [],\n      rawTicks: [],\n      fractionDigits: 0,\n      niceDomain: void 0\n    };\n    let index = 0;\n    let autoRotation = 0;\n    let labelOverlap = true;\n    let terminate = false;\n    while (!terminate && labelOverlap && index <= maxIterations) {\n      autoRotation = 0;\n      for (const strategy of this.getTickStrategies({ domain, niceMode, secondaryAxis, index })) {\n        ({ tickData, index, autoRotation, terminate } = strategy({\n          index,\n          tickData,\n          textProps,\n          terminate,\n          primaryTickCount,\n          visibleRange,\n          // Lazily generate as only one strategy actually uses this, and it's expensive to compute\n          get labelOverlap() {\n            return getLabelOverlap(tickData, autoRotation);\n          }\n        }));\n      }\n      labelOverlap = getLabelOverlap(tickData, autoRotation);\n    }\n    textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);\n    const combinedRotation = defaultRotation + configuredRotation + autoRotation;\n    if (!secondaryAxis && tickData.rawTicks.length > 0) {\n      primaryTickCount = tickData.rawTicks.length;\n    }\n    return { tickData, primaryTickCount, combinedRotation, textBaseline, textAlign };\n  }\n  getTickStrategies({\n    domain,\n    niceMode,\n    index: iteration,\n    secondaryAxis\n  }) {\n    const { scale: scale2, label, interval } = this.axis;\n    const { minSpacing } = interval;\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const avoidLabelCollisions = label.enabled && label.avoidCollisions;\n    const filterTicks = !continuous && iteration !== 0 && avoidLabelCollisions;\n    const autoRotate = label.autoRotate === true && label.rotation === void 0;\n    const strategies = [];\n    let tickGenerationType;\n    if (interval.values) {\n      tickGenerationType = 3 /* VALUES */;\n    } else if (secondaryAxis) {\n      tickGenerationType = 1 /* CREATE_SECONDARY */;\n    } else if (filterTicks) {\n      tickGenerationType = 2 /* FILTER */;\n    } else {\n      tickGenerationType = 0 /* CREATE */;\n    }\n    const tickGenerationStrategy = ({\n      index,\n      tickData,\n      primaryTickCount,\n      visibleRange,\n      terminate\n    }) => this.createTickData(\n      domain,\n      niceMode,\n      visibleRange,\n      primaryTickCount,\n      tickGenerationType,\n      index,\n      tickData,\n      terminate\n    );\n    strategies.push(tickGenerationStrategy);\n    if (!continuous && !isNaN(minSpacing)) {\n      const tickFilterStrategy = ({\n        index,\n        tickData,\n        primaryTickCount,\n        visibleRange,\n        terminate\n      }) => this.createTickData(\n        domain,\n        niceMode,\n        visibleRange,\n        primaryTickCount,\n        2 /* FILTER */,\n        index,\n        tickData,\n        terminate\n      );\n      strategies.push(tickFilterStrategy);\n    }\n    if (avoidLabelCollisions && autoRotate) {\n      const autoRotateStrategy = ({ index, tickData, labelOverlap, terminate }) => ({\n        index,\n        tickData,\n        autoRotation: labelOverlap ? normalizeAngle360(toRadians(label.autoRotateAngle ?? 0)) : 0,\n        terminate\n      });\n      strategies.push(autoRotateStrategy);\n    }\n    return strategies;\n  }\n  createTickData(domain, niceMode, visibleRange, primaryTickCount, tickGenerationType, index, tickData, terminate) {\n    const { scale: scale2, interval } = this.axis;\n    const { step, values, minSpacing, maxSpacing } = interval;\n    const { maxTickCount, minTickCount, tickCount } = this.estimateTickCount(visibleRange, minSpacing, maxSpacing);\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\n    const countTicks = (i) => continuous ? Math.max(tickCount - i, minTickCount) : maxTickCount;\n    const regenerateTicks = step == null && values == null && countTicks(index) > minTickCount && (continuous || tickGenerationType === 2 /* FILTER */);\n    while (index <= maxIterations) {\n      const previousTicks = tickData.rawTicks;\n      tickData = this.getTicks({\n        domain,\n        niceMode,\n        visibleRange,\n        tickGenerationType,\n        previousTicks,\n        minTickCount,\n        maxTickCount,\n        primaryTickCount,\n        tickCount: countTicks(index)\n      });\n      index++;\n      if (!regenerateTicks || !arraysEqual(tickData.rawTicks, previousTicks))\n        break;\n    }\n    terminate || (terminate = step != null || values != null);\n    return { tickData, index, autoRotation: 0, terminate };\n  }\n  getTicks({\n    domain,\n    niceMode,\n    visibleRange,\n    tickGenerationType,\n    previousTicks,\n    tickCount,\n    minTickCount,\n    maxTickCount,\n    primaryTickCount\n  }) {\n    const { axis } = this;\n    const { label, range: range3, scale: scale2, interval } = axis;\n    const idGenerator = createIdsGenerator();\n    const domainParams = {\n      nice: niceMode === 0 /* TickAndDomain */,\n      interval: interval.step,\n      tickCount,\n      minTickCount,\n      maxTickCount\n    };\n    const tickParams = {\n      ...domainParams,\n      nice: niceMode === 0 /* TickAndDomain */ || niceMode === 1 /* TicksOnly */\n    };\n    let niceDomain = niceMode === 0 /* TickAndDomain */ ? scale2.niceDomain(domainParams, domain) : domain;\n    let tickDomain = niceDomain;\n    let rawTicks;\n    switch (tickGenerationType) {\n      case 3 /* VALUES */:\n        tickDomain = interval.values;\n        rawTicks = interval.values;\n        if (ContinuousScale.is(scale2)) {\n          const [d0, d1] = findMinMax(niceDomain.map(Number));\n          rawTicks = rawTicks.filter((value) => Number(value) >= d0 && Number(value) <= d1).sort((a, b) => Number(a) - Number(b));\n        }\n        break;\n      case 1 /* CREATE_SECONDARY */:\n        if (ContinuousScale.is(scale2)) {\n          const secondaryAxisTicks = calculateNiceSecondaryAxis(\n            domain.map(Number),\n            primaryTickCount ?? 0,\n            axis.reverse\n          );\n          rawTicks = secondaryAxisTicks.ticks;\n          niceDomain = secondaryAxisTicks.domain.map((d) => scale2.toDomain(d));\n        } else {\n          rawTicks = scale2.ticks(tickParams, niceDomain, visibleRange) ?? [];\n        }\n        break;\n      case 2 /* FILTER */:\n        rawTicks = this.filterTicks(previousTicks, tickCount);\n        break;\n      default:\n        rawTicks = scale2.ticks(tickParams, niceDomain, visibleRange) ?? [];\n    }\n    const fractionDigits = rawTicks.reduce(\n      (max, tick) => Math.max(max, typeof tick === \"number\" ? countFractionDigits(tick) : 0),\n      0\n    );\n    const formatParams = {\n      domain: tickDomain,\n      ticks: rawTicks,\n      fractionDigits,\n      specifier: label.format\n    };\n    const labelFormatter = scale2.tickFormatter(formatParams);\n    const scaleDomain = scale2.domain;\n    scale2.domain = niceDomain;\n    const halfBandwidth = (scale2.bandwidth ?? 0) / 2;\n    const ticks = [];\n    for (let i = 0; i < rawTicks.length; i++) {\n      const tick = rawTicks[i];\n      const translationY = scale2.convert(tick) + halfBandwidth;\n      if (range3.length > 0 && !axis.inRange(translationY, 1e-3))\n        continue;\n      const tickLabel = label.enabled ? axis.formatTick(tick, i, fractionDigits, labelFormatter) : \"\";\n      ticks.push({ tick, tickId: idGenerator(tickLabel), tickLabel, translationY: Math.floor(translationY) });\n    }\n    scale2.domain = scaleDomain;\n    return {\n      tickDomain,\n      rawTicks,\n      fractionDigits,\n      ticks,\n      niceDomain\n    };\n  }\n};\n\n// packages/ag-charts-community/src/chart/axis/cartesianAxisLabel.ts\nvar CartesianAxisLabel = class extends AxisLabel {\n  constructor() {\n    super(...arguments);\n    this.autoRotateAngle = 335;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianAxisLabel.prototype, \"autoRotate\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], CartesianAxisLabel.prototype, \"autoRotateAngle\", 2);\n\n// packages/ag-charts-community/src/chart/axis/cartesianAxis.ts\nvar _CartesianAxis = class _CartesianAxis extends Axis {\n  constructor(moduleCtx, scale2) {\n    super(moduleCtx, scale2);\n    this.lineNode = this.axisGroup.appendChild(\n      new TranslatableLine({\n        name: `${this.id}-Axis-line`,\n        zIndex: 1 /* AxisLine */\n      })\n    );\n    this.tempText = new TransformableText();\n    this.tempCaption = new Caption();\n    this.tickGenerator = new AxisTickGenerator(this);\n    this.generatedTicks = void 0;\n    this.animationManager = moduleCtx.animationManager;\n    this.animationState = new StateMachine(\"empty\", {\n      empty: {\n        update: {\n          target: \"ready\",\n          action: () => this.resetSelectionNodes()\n        },\n        reset: \"empty\"\n      },\n      ready: {\n        update: (data) => this.animateReadyUpdate(data),\n        resize: () => this.resetSelectionNodes(),\n        reset: \"empty\"\n      }\n    });\n    this.axisGroup.appendChild(this.title.caption.node);\n    let previousSize = void 0;\n    this.destroyFns.push(\n      moduleCtx.layoutManager.addListener(\"layout:complete\", (e) => {\n        const size = [e.chart.width, e.chart.height];\n        if (previousSize != null && !arraysEqual(size, previousSize)) {\n          this.animationState.transition(\"resize\");\n        }\n        previousSize = size;\n      }),\n      this.title.caption.registerInteraction(this.moduleCtx, \"afterend\")\n    );\n  }\n  static is(value) {\n    return value instanceof _CartesianAxis;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    }\n  }\n  get direction() {\n    return this.position === \"top\" || this.position === \"bottom\" ? \"x\" /* X */ : \"y\" /* Y */;\n  }\n  createAxisContext() {\n    return { ...super.createAxisContext(), position: this.position };\n  }\n  createLabel() {\n    return new CartesianAxisLabel();\n  }\n  updateDirection() {\n    switch (this.position) {\n      case \"top\":\n        this.rotation = -90;\n        this.label.mirrored = true;\n        this.label.parallel = true;\n        break;\n      case \"right\":\n        this.rotation = 0;\n        this.label.mirrored = true;\n        this.label.parallel = false;\n        break;\n      case \"bottom\":\n        this.rotation = -90;\n        this.label.mirrored = false;\n        this.label.parallel = true;\n        break;\n      case \"left\":\n        this.rotation = 0;\n        this.label.mirrored = false;\n        this.label.parallel = false;\n        break;\n    }\n    if (this.axisContext) {\n      this.axisContext.position = this.position;\n      this.axisContext.direction = this.direction;\n    }\n  }\n  calculateLayout(primaryTickCount) {\n    this.updateDirection();\n    return super.calculateLayout(primaryTickCount);\n  }\n  calculateTickLayout(domain, niceMode, visibleRange, initialPrimaryTickCount) {\n    const sideFlag = this.label.getSideFlag();\n    const { parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\n    const labelX = sideFlag * (this.getTickSize() + this.label.spacing + this.seriesAreaPadding);\n    const tickGenerationResult = this.tickGenerator.generateTicks({\n      domain,\n      niceMode,\n      visibleRange,\n      primaryTickCount: initialPrimaryTickCount,\n      parallelFlipRotation,\n      regularFlipRotation,\n      labelX,\n      sideFlag\n    });\n    const { tickData, primaryTickCount = initialPrimaryTickCount } = tickGenerationResult;\n    const { ticks, tickDomain, rawTicks, fractionDigits, niceDomain = domain } = tickData;\n    const labels = ticks.map((d) => this.getTickLabelProps(d, tickGenerationResult));\n    const bbox = this.tickBBox(ticks, labels);\n    this.generatedTicks = { ticks, labels };\n    return { ticks: rawTicks, tickDomain, niceDomain, primaryTickCount, fractionDigits, bbox };\n  }\n  update() {\n    this.updateDirection();\n    const previousTicksIds = Array.from(this.tickLabelGroupSelection.nodes(), (node) => node.datum.tickId);\n    super.update();\n    if (!this.animatable) {\n      this.moduleCtx.animationManager.skipCurrentBatch();\n    }\n    if (this.generatedTicks) {\n      const { ticks } = this.generatedTicks;\n      if (this.animationManager.isSkipped()) {\n        this.resetSelectionNodes();\n      } else {\n        const tickIds = ticks.map((datum) => datum.tickId);\n        const diff2 = diffArrays(previousTicksIds, tickIds);\n        this.animationState.transition(\"update\", diff2);\n      }\n    }\n    const { enabled, stroke: stroke2, width: width2 } = this.line;\n    this.lineNode.setProperties({ stroke: stroke2, strokeWidth: enabled ? width2 : 0 });\n    this.updateTitle(!this.generatedTicks?.ticks.length);\n  }\n  updatePosition() {\n    super.updatePosition();\n    this.axisGroup.datum = this.getAxisTransform();\n  }\n  tickBBox(ticks, labels) {\n    const sideFlag = this.label.getSideFlag();\n    const boxes = [];\n    const { x, y1, y2 } = this.getAxisLineCoordinates();\n    const lineBox = new BBox(\n      x + Math.min(sideFlag * this.seriesAreaPadding, 0),\n      y1,\n      this.seriesAreaPadding,\n      y2 - y1\n    );\n    boxes.push(lineBox);\n    if (this.tick.enabled) {\n      for (const datum of ticks) {\n        const { x1, x2, y } = this.getTickLineCoordinates(datum);\n        const tickLineBox = new BBox(x1, y, x2 - x1, 0);\n        boxes.push(tickLineBox);\n      }\n    }\n    const { tempText } = this;\n    if (this.label.enabled) {\n      for (const datum of labels) {\n        if (!datum.visible)\n          continue;\n        tempText.setProperties({\n          ...datum,\n          translationY: Math.round(datum.translationY)\n        });\n        const box = tempText.getBBox();\n        if (box) {\n          boxes.push(box);\n        }\n      }\n    }\n    if (this.title?.enabled) {\n      const spacing = BBox.merge(boxes).width;\n      this.setTitleProps(this.tempCaption, { spacing });\n      const titleBox = this.tempCaption.node.getBBox();\n      if (titleBox) {\n        boxes.push(titleBox);\n      }\n    }\n    const bbox = BBox.merge(boxes);\n    return this.getTransformBox(bbox);\n  }\n  getTickLabelProps(datum, tickGenerationResult) {\n    const { combinedRotation, textBaseline, textAlign } = tickGenerationResult;\n    const { range: range3 } = this.scale;\n    const text2 = datum.tickLabel;\n    const sideFlag = this.label.getSideFlag();\n    const labelX = sideFlag * (this.getTickSize() + this.label.spacing + this.seriesAreaPadding);\n    const visible = text2 !== \"\" && text2 != null;\n    return {\n      ...this.getLabelStyles({ value: datum.tickLabel }),\n      tickId: datum.tickId,\n      rotation: combinedRotation,\n      rotationCenterX: labelX,\n      translationY: datum.translationY,\n      text: text2,\n      textAlign,\n      textBaseline,\n      visible,\n      x: labelX,\n      y: 0,\n      range: range3\n    };\n  }\n  getTickLineCoordinates(datum) {\n    const sideFlag = this.label.getSideFlag();\n    const x = sideFlag * this.getTickSize();\n    const x1 = Math.min(0, x);\n    const x2 = x1 + Math.abs(x);\n    const y = datum.translationY;\n    return { x1, x2, y };\n  }\n  updateSelections() {\n    if (!this.generatedTicks)\n      return;\n    const lineData = this.getAxisLineCoordinates();\n    const { ticks, labels } = this.generatedTicks;\n    const getDatumId = (datum) => datum.tickId;\n    this.lineNode.datum = lineData;\n    this.gridLineGroupSelection.update(this.gridLength ? ticks : [], void 0, getDatumId);\n    this.tickLineGroupSelection.update(ticks, void 0, getDatumId);\n    this.tickLabelGroupSelection.update(labels, void 0, getDatumId);\n  }\n  updateTitle(noVisibleTicks, spacing) {\n    const { title, tickLineGroup, tickLabelGroup, lineNode } = this;\n    if (title.enabled && !noVisibleTicks && spacing == null) {\n      const tickBBox = Group.computeChildrenBBox([tickLineGroup, tickLabelGroup, lineNode]);\n      spacing = tickBBox.width + (tickLabelGroup.visible ? 0 : this.seriesAreaPadding);\n    }\n    spacing ?? (spacing = 0);\n    this.setTitleProps(title.caption, { spacing });\n  }\n  updateLabels() {\n    if (!this.label.enabled)\n      return;\n    this.tickLabelGroupSelection.each((node, datum) => {\n      node.fill = datum.fill;\n      node.fontFamily = datum.fontFamily;\n      node.fontSize = datum.fontSize;\n      node.fontStyle = datum.fontStyle;\n      node.fontWeight = datum.fontWeight;\n      node.text = datum.text;\n      node.textBaseline = datum.textBaseline;\n      node.textAlign = datum.textAlign ?? \"center\";\n    });\n  }\n  animateReadyUpdate(diff2) {\n    const { animationManager } = this.moduleCtx;\n    const selectionCtx = prepareAxisAnimationContext(this);\n    const fns = prepareAxisAnimationFunctions(selectionCtx);\n    fromToMotion(this.id, \"axis-group\", animationManager, [this.axisGroup], fns.group);\n    fromToMotion(this.id, \"line\", animationManager, [this.lineNode], fns.line);\n    fromToMotion(\n      this.id,\n      \"line-paths\",\n      animationManager,\n      [this.gridLineGroupSelection, this.tickLineGroupSelection],\n      fns.tick,\n      (_, d) => d.tickId,\n      diff2\n    );\n    fromToMotion(\n      this.id,\n      \"tick-labels\",\n      animationManager,\n      [this.tickLabelGroupSelection],\n      fns.label,\n      (_, d) => d.tickId,\n      diff2\n    );\n  }\n  resetSelectionNodes() {\n    const selectionCtx = prepareAxisAnimationContext(this);\n    resetMotion([this.axisGroup], resetAxisGroupFn());\n    resetMotion([this.gridLineGroupSelection, this.tickLineGroupSelection], resetAxisSelectionFn(selectionCtx));\n    resetMotion([this.tickLabelGroupSelection], resetAxisLabelSelectionFn());\n    resetMotion([this.lineNode], resetAxisLineSelectionFn());\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], _CartesianAxis.prototype, \"thickness\", 2);\n__decorateClass([\n  Validate(POSITION)\n], _CartesianAxis.prototype, \"position\", 2);\nvar CartesianAxis = _CartesianAxis;\n\n// packages/ag-charts-community/src/chart/axis/categoryAxis.ts\nvar _CategoryAxis = class _CategoryAxis extends CartesianAxis {\n  constructor(moduleCtx, scale2 = new CategoryScale()) {\n    super(moduleCtx, scale2);\n    this.groupPaddingInner = 0.1;\n    this.includeInvisibleDomains = true;\n  }\n  static is(value) {\n    return value instanceof _CategoryAxis;\n  }\n  normaliseDataDomain(domain) {\n    return { domain, clipped: false };\n  }\n  updateScale() {\n    super.updateScale();\n    let { paddingInner, paddingOuter } = this;\n    if (!isFiniteNumber(paddingInner) || !isFiniteNumber(paddingOuter)) {\n      const padding = this.reduceBandScalePadding();\n      paddingInner ?? (paddingInner = padding.inner);\n      paddingOuter ?? (paddingOuter = padding.outer);\n    }\n    this.scale.paddingInner = paddingInner ?? 0;\n    this.scale.paddingOuter = paddingOuter ?? 0;\n  }\n  reduceBandScalePadding() {\n    return this.boundSeries.reduce(\n      (result, series) => {\n        const padding = series.getBandScalePadding?.();\n        if (padding) {\n          if (result.inner > padding.inner) {\n            result.inner = padding.inner;\n          }\n          if (result.outer < padding.outer) {\n            result.outer = padding.outer;\n          }\n        }\n        return result;\n      },\n      { inner: Infinity, outer: -Infinity }\n    );\n  }\n};\n_CategoryAxis.className = \"CategoryAxis\";\n_CategoryAxis.type = \"category\";\n__decorateClass([\n  Validate(RATIO)\n], _CategoryAxis.prototype, \"groupPaddingInner\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CategoryAxis.prototype, \"paddingInner\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CategoryAxis.prototype, \"paddingOuter\", 2);\nvar CategoryAxis = _CategoryAxis;\n\n// packages/ag-charts-community/src/module/module.ts\nvar BaseModuleInstance = class {\n  constructor() {\n    this.destroyFns = [];\n  }\n  destroy() {\n    for (const destroyFn of this.destroyFns) {\n      destroyFn();\n    }\n  }\n};\nvar ModuleRegistry2 = class {\n  constructor() {\n    this.modules = [];\n    this.dependencies = /* @__PURE__ */ new Map();\n    this.modulesByOptionKey = /* @__PURE__ */ new Map();\n  }\n  register(...modules) {\n    for (const module of modules) {\n      this.registerDependencies(module);\n      const otherModule = this.modules.find(\n        (other) => module.type === other.type && (\"optionsKey\" in module && \"optionsKey\" in other ? module.optionsKey === other.optionsKey : true) && module.identifier === other.identifier\n      );\n      if (otherModule) {\n        if (module.packageType === \"enterprise\" && otherModule.packageType === \"community\") {\n          const index = this.modules.indexOf(otherModule);\n          this.modules.splice(index, 1, module);\n          if (\"optionsKey\" in module) {\n            this.modulesByOptionKey.set(module.optionsKey, module);\n          }\n        }\n      } else {\n        this.modules.push(module);\n        if (\"optionsKey\" in module) {\n          this.modulesByOptionKey.set(module.optionsKey, module);\n        }\n      }\n    }\n  }\n  hasEnterpriseModules() {\n    return this.modules.some((m) => m.packageType === \"enterprise\");\n  }\n  *byType(...types) {\n    const yielded = /* @__PURE__ */ new Set();\n    const modulesByType = this.modules.filter((module) => types.includes(module.type));\n    const calculateDependencies = (module) => {\n      const deps = this.dependencies.get(module);\n      return deps?.flatMap(calculateDependencies).concat(deps) ?? [];\n    };\n    const unresolvable = [];\n    for (const module of modulesByType) {\n      const uniqueKey = \"optionsKey\" in module ? module.optionsKey : module.contextKey;\n      if (yielded.has(uniqueKey))\n        continue;\n      for (const dependency of calculateDependencies(uniqueKey)) {\n        if (yielded.has(dependency))\n          continue;\n        const dependencyModule = this.modulesByOptionKey.get(dependency);\n        if (!dependencyModule) {\n          unresolvable.push(dependency);\n          continue;\n        }\n        if (!types.includes(dependencyModule.type))\n          continue;\n        yield dependencyModule;\n        yielded.add(dependency);\n      }\n      yield module;\n      yielded.add(uniqueKey);\n    }\n    if (unresolvable.length > 0) {\n      throw new Error(`Could not resolve module dependencies: ${unresolvable}`);\n    }\n  }\n  registerDependencies(module) {\n    if (module.dependencies == null || module.dependencies.length === 0)\n      return;\n    const uniqueKey = \"optionsKey\" in module ? module.optionsKey : module.contextKey;\n    this.dependencies.set(uniqueKey, module.dependencies);\n  }\n};\nvar moduleRegistry = new ModuleRegistry2();\n\n// packages/ag-charts-community/src/util/async.ts\nvar AsyncAwaitQueue = class {\n  constructor() {\n    this.queue = [];\n  }\n  await(timeout = 50) {\n    return new Promise((resolve) => {\n      const successFn = () => {\n        clearTimeout(timeoutHandle);\n        resolve(true);\n      };\n      const timeoutFn = () => {\n        const queueIndex = this.queue.indexOf(successFn);\n        if (queueIndex < 0)\n          return;\n        this.queue.splice(queueIndex, 1);\n        resolve(false);\n      };\n      const timeoutHandle = setTimeout(timeoutFn, timeout);\n      this.queue.push(successFn);\n    });\n  }\n  notify() {\n    this.queue.splice(0).forEach((cb) => cb());\n  }\n};\nfunction pause() {\n  return new Promise((resolve) => {\n    setTimeout(resolve, 0);\n  });\n}\n\n// packages/ag-charts-community/src/util/dom.ts\nfunction setElementBBox(element2, bbox) {\n  if (!element2)\n    return;\n  bbox = BBoxValues.normalize(bbox);\n  if (bbox.width == null) {\n    element2.style.removeProperty(\"width\");\n  } else {\n    element2.style.width = `${bbox.width}px`;\n  }\n  if (bbox.height == null) {\n    element2.style.removeProperty(\"height\");\n  } else {\n    element2.style.height = `${bbox.height}px`;\n  }\n  if (bbox.x == null) {\n    element2.style.removeProperty(\"left\");\n  } else {\n    element2.style.left = `${bbox.x}px`;\n  }\n  if (bbox.y == null) {\n    element2.style.removeProperty(\"top\");\n  } else {\n    element2.style.top = `${bbox.y}px`;\n  }\n}\nfunction getElementBBox(element2) {\n  const width2 = parseFloat(element2.style.width) || element2.offsetWidth;\n  const height2 = parseFloat(element2.style.height) || element2.offsetHeight;\n  const x = parseFloat(element2.style.left) || element2.offsetLeft;\n  const y = parseFloat(element2.style.top) || element2.offsetTop;\n  return { x, y, width: width2, height: height2 };\n}\nfunction focusCursorAtEnd(element2) {\n  element2.focus({ preventScroll: true });\n  if (element2.lastChild?.textContent == null)\n    return;\n  const range3 = getDocument().createRange();\n  range3.setStart(element2.lastChild, element2.lastChild.textContent.length);\n  range3.setEnd(element2.lastChild, element2.lastChild.textContent.length);\n  const selection = getWindow().getSelection();\n  selection?.removeAllRanges();\n  selection?.addRange(range3);\n}\nvar _id = 0;\nfunction createElementId(label) {\n  return `${label ?? \"ag-charts-element\"}-${_id++}`;\n}\nfunction isInputPending() {\n  const navigator = getWindow(\"navigator\");\n  if (\"scheduling\" in navigator) {\n    const scheduling = navigator.scheduling;\n    if (\"isInputPending\" in scheduling) {\n      return scheduling.isInputPending({ includeContinuous: true });\n    }\n  }\n  return false;\n}\nfunction getIconClassNames(icon) {\n  return `ag-charts-icon ag-charts-icon-${icon}`;\n}\n\n// packages/ag-charts-community/src/util/json.ts\nvar CLASS_INSTANCE_TYPE = \"class-instance\";\nfunction jsonDiff(source, target, skip) {\n  if (isArray(target)) {\n    if (!isArray(source) || source.length !== target.length || target.some((v, i) => jsonDiff(source[i], v) != null)) {\n      return target;\n    }\n  } else if (isPlainObject(target)) {\n    if (!isPlainObject(source)) {\n      return target;\n    }\n    const result = {};\n    const allKeys = /* @__PURE__ */ new Set([\n      ...Object.keys(source),\n      ...Object.keys(target)\n    ]);\n    for (const key of allKeys) {\n      if (source[key] === target[key] || skip?.includes(key)) {\n        continue;\n      }\n      if (typeof source[key] === typeof target[key]) {\n        const diff2 = jsonDiff(source[key], target[key]);\n        if (diff2 !== null) {\n          result[key] = diff2;\n        }\n      } else {\n        result[key] = target[key];\n      }\n    }\n    return Object.keys(result).length ? result : null;\n  } else if (source !== target) {\n    return target;\n  }\n  return null;\n}\nfunction jsonPropertyCompare(source, target) {\n  for (const key of Object.keys(source)) {\n    if (source[key] === target?.[key])\n      continue;\n    return false;\n  }\n  return true;\n}\nfunction deepClone(source, shallow) {\n  if (isArray(source)) {\n    return source.map((item) => deepClone(item, shallow));\n  }\n  if (isPlainObject(source)) {\n    return clonePlainObject(source, shallow);\n  }\n  if (source instanceof Map) {\n    return new Map(deepClone(Array.from(source)));\n  }\n  return shallowClone(source);\n}\nfunction clonePlainObject(source, shallow) {\n  const target = {};\n  for (const key of Object.keys(source)) {\n    target[key] = shallow?.has(key) ? shallowClone(source[key]) : deepClone(source[key], shallow);\n  }\n  return target;\n}\nfunction shallowClone(source) {\n  if (isArray(source)) {\n    return source.slice(0);\n  }\n  if (isPlainObject(source)) {\n    return { ...source };\n  }\n  if (isDate(source)) {\n    return new Date(source);\n  }\n  if (isRegExp(source)) {\n    return new RegExp(source.source, source.flags);\n  }\n  return source;\n}\nfunction jsonWalk(json, visit, skip, parallelJson, ctx, acc) {\n  if (isArray(json)) {\n    acc = visit(json, parallelJson, ctx, acc);\n    let index = 0;\n    for (const node of json) {\n      acc = jsonWalk(node, visit, skip, parallelJson?.[index], ctx, acc);\n      index++;\n    }\n  } else if (isPlainObject(json)) {\n    acc = visit(json, parallelJson, ctx, acc);\n    for (const key of Object.keys(json)) {\n      if (skip?.has(key)) {\n        continue;\n      }\n      const value = json[key];\n      acc = jsonWalk(value, visit, skip, parallelJson?.[key], ctx, acc);\n    }\n  }\n  return acc;\n}\nfunction jsonApply(target, source, params = {}) {\n  const { path, matcherPath = path?.replace(/(\\[[0-9+]+])/i, \"[]\"), skip = [] } = params;\n  if (target == null) {\n    throw new Error(`AG Charts - target is uninitialised: ${path ?? \"<root>\"}`);\n  }\n  if (source == null) {\n    return target;\n  }\n  if (isProperties(target)) {\n    return target.set(source);\n  }\n  const targetAny = target;\n  const targetType = classify(target);\n  for (const property of Object.keys(source)) {\n    if (SKIP_JS_BUILTINS.has(property))\n      continue;\n    const propertyMatcherPath = `${matcherPath ? matcherPath + \".\" : \"\"}${property}`;\n    if (skip.includes(propertyMatcherPath))\n      continue;\n    const newValue = source[property];\n    const propertyPath = `${path ? path + \".\" : \"\"}${property}`;\n    const targetClass = targetAny.constructor;\n    const currentValue = targetAny[property];\n    try {\n      const currentValueType = classify(currentValue);\n      const newValueType = classify(newValue);\n      if (targetType === CLASS_INSTANCE_TYPE && !(property in target)) {\n        if (newValue === void 0)\n          continue;\n        logger_exports.warn(`unable to set [${propertyPath}] in ${targetClass?.name} - property is unknown`);\n        continue;\n      }\n      if (currentValueType != null && newValueType != null && newValueType !== currentValueType && (currentValueType !== CLASS_INSTANCE_TYPE || newValueType !== \"object\")) {\n        logger_exports.warn(\n          `unable to set [${propertyPath}] in ${targetClass?.name} - can't apply type of [${newValueType}], allowed types are: [${currentValueType}]`\n        );\n        continue;\n      }\n      if (isProperties(currentValue)) {\n        targetAny[property].set(newValue);\n      } else if (newValueType === \"object\") {\n        if (currentValue == null) {\n          logger_exports.warn(`unable to set [${propertyPath}] in ${targetClass?.name} - property is unknown`);\n          continue;\n        }\n        jsonApply(currentValue, newValue, {\n          ...params,\n          path: propertyPath,\n          matcherPath: propertyMatcherPath\n        });\n      } else {\n        targetAny[property] = newValue;\n      }\n    } catch (error2) {\n      logger_exports.warn(`unable to set [${propertyPath}] in [${targetClass?.name}]; nested error is: ${error2.message}`);\n    }\n  }\n  return target;\n}\nfunction classify(value) {\n  if (value == null) {\n    return null;\n  }\n  if (isHtmlElement(value) || isDate(value)) {\n    return \"primitive\";\n  }\n  if (isArray(value)) {\n    return \"array\";\n  }\n  if (isObject(value)) {\n    return isPlainObject(value) ? \"object\" : CLASS_INSTANCE_TYPE;\n  }\n  if (isFunction(value)) {\n    return \"function\";\n  }\n  return \"primitive\";\n}\nfunction jsonResolveOperations(source, params, skip) {\n  return jsonResolveInner(source, params, source, skip);\n}\nfunction jsonResolveInner(json, params, source, skip, path = [], modifiedPaths = {}) {\n  if (isArray(json)) {\n    jsonResolveVisitor(json, params, source, path, modifiedPaths);\n    let index = 0;\n    for (const node of json) {\n      jsonResolveInner(node, params, source, skip, [...path, `${index}`], modifiedPaths);\n      index++;\n    }\n  } else if (isPlainObject(json)) {\n    jsonResolveVisitor(json, params, source, path, modifiedPaths);\n    for (const key of Object.keys(json)) {\n      if (skip?.has(key)) {\n        continue;\n      }\n      const value = json[key];\n      jsonResolveInner(value, params, source, skip, [...path, key], modifiedPaths);\n    }\n  }\n  return modifiedPaths;\n}\nfunction jsonResolveVisitor(node, params, source, path, modifiedPaths) {\n  if (isArray(node)) {\n    for (let i = 0; i < node.length; i++) {\n      node[i] = jsonResolveVisitorValue(node[i], params, source, [...path, `${i}`], modifiedPaths);\n    }\n  } else {\n    for (const [name, value] of Object.entries(node)) {\n      node[name] = jsonResolveVisitorValue(value, params, source, [...path, name], modifiedPaths);\n    }\n  }\n}\nfunction jsonResolveVisitorValue(value, params, source, path, modifiedPaths) {\n  const { operation, values } = getOperation(value);\n  if (!operation)\n    return value;\n  modifiedPaths[path.join(\".\")] = value;\n  return resolveOperation(operation, values, params, source, path, /* @__PURE__ */ new Set());\n}\nvar Operation = /* @__PURE__ */ ((Operation2) => {\n  Operation2[\"Ref\"] = \"$ref\";\n  Operation2[\"Path\"] = \"$path\";\n  Operation2[\"If\"] = \"$if\";\n  Operation2[\"Eq\"] = \"$eq\";\n  Operation2[\"Not\"] = \"$not\";\n  Operation2[\"Or\"] = \"$or\";\n  Operation2[\"And\"] = \"$and\";\n  Operation2[\"Mul\"] = \"$mul\";\n  Operation2[\"Round\"] = \"$round\";\n  Operation2[\"Rem\"] = \"$rem\";\n  Operation2[\"Mix\"] = \"$mix\";\n  Operation2[\"ForegroundBackgroundMix\"] = \"$foregroundBackgroundMix\";\n  Operation2[\"ForegroundBackgroundAccentMix\"] = \"$foregroundBackgroundAccentMix\";\n  return Operation2;\n})(Operation || {});\nvar operationKeys = new Set(Object.values(Operation));\nfunction getOperation(value) {\n  if (!isPlainObject(value))\n    return {};\n  const [operation, ...otherKeys] = Object.keys(value);\n  if (otherKeys.length !== 0 || !operationKeys.has(operation))\n    return {};\n  return { operation, values: value[operation] };\n}\nfunction resolveOperation(operation, value, params, source, path, referencedParams) {\n  if (isArray(value)) {\n    value = value.map((v) => {\n      const { operation: nestedOperation, values } = getOperation(v);\n      if (!nestedOperation)\n        return v;\n      return resolveOperation(nestedOperation, values, params, source, path, referencedParams);\n    });\n  }\n  return operations[operation](value, params, source, path, referencedParams);\n}\nfunction isRatio(value) {\n  return isNumber(value) && value >= 0 && value <= 1;\n}\nvar operations = {\n  $ref: (key, params, source, path, referencedParams) => {\n    if (isString(key) && key in params) {\n      const { operation, values } = getOperation(params[key]);\n      if (operation !== \"$ref\" /* Ref */) {\n        return params[key];\n      }\n      if (referencedParams?.has(values)) {\n        logger_exports.warnOnce(\n          `\\`$ref\\` json operation failed on [${String(key)}] at [${path.join(\".\")}], circular reference detected with [${[...referencedParams].join(\", \")}].`\n        );\n        return;\n      }\n      referencedParams?.add(values);\n      return operations.$ref(values, params, source, path, referencedParams);\n    }\n    logger_exports.warnOnce(\n      `\\`$ref\\` json operation failed on [${String(key)}] at [${path.join(\".\")}], expecting one of [${Object.keys(params).join(\", \")}].`\n    );\n  },\n  $path: (relativePath, _params, source, currentPath) => {\n    if (!isString(relativePath)) {\n      logger_exports.warnOnce(\n        `\\`$path\\` json operation failed on [${String(relativePath)}] at [${currentPath.join(\".\")}], expecting a string.`\n      );\n      return;\n    }\n    const relativePathParts = relativePath.split(\"/\");\n    const resolvedPath = [...currentPath];\n    for (const part of relativePathParts) {\n      if (part === \"..\") {\n        resolvedPath.pop();\n        resolvedPath.pop();\n      } else if (part === \".\") {\n        resolvedPath.pop();\n      } else {\n        resolvedPath.push(part);\n      }\n    }\n    let resolvedValue = source;\n    for (const part of resolvedPath) {\n      if (!(part in resolvedValue)) {\n        logger_exports.warnOnce(\n          `\\`$path\\` json operation failed on [${String(relativePath)}] at [${currentPath.join(\".\")}], could not find path in object.`\n        );\n        return;\n      }\n      resolvedValue = resolvedValue[part];\n    }\n    return resolvedValue;\n  },\n  $if: ([condition, thenValue, elseValue]) => condition ? thenValue : elseValue,\n  $eq: ([a, b]) => a === b,\n  $not: ([a, b]) => a !== b,\n  $or: ([a, b]) => a || b,\n  $and: ([a, b]) => a && b,\n  $mul: ([a, b], _params, _source, path) => {\n    if (typeof a === \"number\" && typeof b === \"number\")\n      return a * b;\n    logger_exports.warnOnce(\n      `\\`$mul\\` json operation failed on [${String(a)}] and [${String(b)}] at [${path.join(\".\")}], expecting two numbers.`\n    );\n  },\n  $round: ([a], _params, _source, path) => {\n    if (typeof a === \"number\")\n      return Math.round(a);\n    logger_exports.warnOnce(\n      `\\`$round\\` json operation failed on [${String(a)}] at [${path.join(\".\")}], expecting a number.`\n    );\n  },\n  $rem: ([a], params) => {\n    if (typeof a === \"number\")\n      return Math.round(a * params.fontSize);\n  },\n  $mix: ([a, b, c], _params, _source, path) => {\n    if (typeof a === \"string\" && typeof b === \"string\" && isRatio(c)) {\n      try {\n        return Color.mix(Color.fromString(a), Color.fromString(b), c).toString();\n      } catch {\n      }\n    }\n    logger_exports.warnOnce(\n      `\\`$mix\\` json operation failed on [${String(a)}, ${String(b)}, ${String(c)}] at [${path.join(\".\")}], expecting two colors and a number between 0 and 1.`\n    );\n  },\n  $foregroundBackgroundMix: ([a], params, _source, path) => {\n    if (isRatio(a)) {\n      return Color.mix(\n        Color.fromString(params.foregroundColor),\n        Color.fromString(params.backgroundColor),\n        a\n      ).toString();\n    }\n    logger_exports.warnOnce(\n      `\\`$foregroundBackgroundMix\\` json operation failed on [${String(a)}}}] at [${path.join(\".\")}], expecting a number between 0 and 1.`\n    );\n  },\n  $foregroundBackgroundAccentMix: ([background, accent], params, _source, path) => {\n    if (isRatio(background) && isRatio(accent)) {\n      return Color.mix(\n        Color.mix(\n          Color.fromString(params.foregroundColor),\n          Color.fromString(params.backgroundColor),\n          background\n        ),\n        Color.fromString(params.accentColor),\n        accent\n      ).toString();\n    }\n    logger_exports.warnOnce(\n      `\\`$foregroundBackgroundAccentMix\\` json operation failed on [${String(background)}, ${String(accent)}}] at [${path.join(\".\")}], expecting two numbers between 0 and 1.`\n    );\n  }\n};\n\n// packages/ag-charts-community/src/util/mutex.ts\nvar Mutex = class {\n  constructor() {\n    this.available = true;\n    this.acquireQueue = [];\n  }\n  acquire(cb) {\n    return new Promise((resolve) => {\n      this.acquireQueue.push([cb, resolve]);\n      if (this.available) {\n        this.dispatchNext().catch((e) => logger_exports.errorOnce(e));\n      }\n    });\n  }\n  async acquireImmediately(cb) {\n    if (!this.available) {\n      return false;\n    }\n    await this.acquire(cb);\n    return true;\n  }\n  async waitForClearAcquireQueue() {\n    return this.acquire(() => Promise.resolve(void 0));\n  }\n  async dispatchNext() {\n    this.available = false;\n    let [next, done] = this.acquireQueue.shift() ?? [];\n    while (next) {\n      try {\n        await next();\n        done?.();\n      } catch (error2) {\n        logger_exports.error(\"mutex callback error\", error2);\n        done?.();\n      }\n      [next, done] = this.acquireQueue.shift() ?? [];\n    }\n    this.available = true;\n  }\n};\n\n// packages/ag-charts-community/src/util/observable.ts\nvar Observable = class {\n  constructor() {\n    this.eventListeners = /* @__PURE__ */ new Map();\n  }\n  addEventListener(eventType, listener) {\n    if (typeof listener !== \"function\") {\n      throw new Error(\"AG Charts - listener must be a Function\");\n    }\n    const eventTypeListeners = this.eventListeners.get(eventType);\n    if (eventTypeListeners) {\n      eventTypeListeners.add(listener);\n    } else {\n      this.eventListeners.set(eventType, /* @__PURE__ */ new Set([listener]));\n    }\n  }\n  removeEventListener(type, listener) {\n    this.eventListeners.get(type)?.delete(listener);\n    if (this.eventListeners.size === 0) {\n      this.eventListeners.delete(type);\n    }\n  }\n  hasEventListener(type) {\n    return this.eventListeners.has(type);\n  }\n  clearEventListeners() {\n    this.eventListeners.clear();\n  }\n  fireEvent(event) {\n    this.eventListeners.get(event.type)?.forEach((listener) => listener(event));\n  }\n};\n\n// packages/ag-charts-community/src/util/padding.ts\nvar Padding = class extends BaseProperties {\n  constructor(top = 0, right = top, bottom = top, left = right) {\n    super();\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n    this.left = left;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"top\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"right\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"bottom\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"left\", 2);\n\n// packages/ag-charts-community/src/util/render.ts\nfunction debouncedAnimationFrame(cb) {\n  return buildScheduler((innerCb, _delayMs) => getWindow().requestAnimationFrame(innerCb), cb);\n}\nfunction debouncedCallback(cb) {\n  return buildScheduler((innerCb, delayMs = 0) => {\n    if (delayMs === 0) {\n      queueMicrotask(innerCb);\n    } else {\n      setTimeout(innerCb, delayMs);\n    }\n  }, cb);\n}\nfunction buildScheduler(scheduleFn, cb) {\n  let scheduleCount = 0;\n  let promiseRunning = false;\n  let awaitingPromise;\n  let awaitingDone;\n  const busy = () => {\n    return promiseRunning;\n  };\n  const done = () => {\n    promiseRunning = false;\n    awaitingDone?.();\n    awaitingDone = void 0;\n    awaitingPromise = void 0;\n    if (scheduleCount > 0) {\n      scheduleFn(scheduleCb);\n    }\n  };\n  const scheduleCb = () => {\n    const count = scheduleCount;\n    scheduleCount = 0;\n    promiseRunning = true;\n    const maybePromise = cb({ count });\n    if (!maybePromise) {\n      done();\n      return;\n    }\n    maybePromise.then(done, done);\n  };\n  return {\n    schedule(delayMs) {\n      if (scheduleCount === 0 && !busy()) {\n        scheduleFn(scheduleCb, delayMs);\n      }\n      scheduleCount++;\n    },\n    async await() {\n      if (!busy()) {\n        return;\n      }\n      if (awaitingPromise == null) {\n        awaitingPromise = new Promise((resolve) => {\n          awaitingDone = resolve;\n        });\n      }\n      while (busy()) {\n        await awaitingPromise;\n      }\n    }\n  };\n}\n\n// packages/ag-charts-community/src/util/attributeUtil.ts\nfunction booleanParser(value) {\n  return value === \"true\";\n}\nfunction numberParser(value) {\n  return Number(value);\n}\nfunction stringParser(value) {\n  return value;\n}\nvar AttributeTypeParsers = {\n  role: stringParser,\n  \"aria-checked\": booleanParser,\n  \"aria-controls\": stringParser,\n  \"aria-describedby\": stringParser,\n  \"aria-disabled\": booleanParser,\n  \"aria-expanded\": booleanParser,\n  \"aria-haspopup\": booleanParser,\n  \"aria-hidden\": booleanParser,\n  \"aria-label\": stringParser,\n  \"aria-labelledby\": stringParser,\n  \"aria-live\": stringParser,\n  \"aria-orientation\": stringParser,\n  \"aria-selected\": booleanParser,\n  \"data-preventdefault\": booleanParser,\n  class: stringParser,\n  id: stringParser,\n  tabindex: numberParser,\n  title: stringParser,\n  placeholder: stringParser\n};\nfunction setAttribute(e, qualifiedName, value) {\n  if (value == null || value === \"\" || value === \"\") {\n    e?.removeAttribute(qualifiedName);\n  } else {\n    e?.setAttribute(qualifiedName, value.toString());\n  }\n}\nfunction setAttributes(e, attrs) {\n  if (attrs == null)\n    return;\n  for (const [key, value] of Object.entries(attrs)) {\n    if (key === \"class\")\n      continue;\n    setAttribute(e, key, value);\n  }\n}\nfunction getAttribute(e, qualifiedName, defaultValue) {\n  if (!(e instanceof HTMLElement))\n    return void 0;\n  const value = e.getAttribute(qualifiedName);\n  if (value === null)\n    return defaultValue;\n  return AttributeTypeParsers[qualifiedName]?.(value) ?? void 0;\n}\nfunction setElementStyle(e, property, value) {\n  if (e == null)\n    return;\n  if (value == null) {\n    e.style.removeProperty(property);\n  } else {\n    e.style.setProperty(property, value.toString());\n  }\n}\nfunction setElementStyles(e, styles) {\n  for (const [key, value] of Object.entries(styles)) {\n    setElementStyle(e, key, value);\n  }\n}\n\n// packages/ag-charts-community/src/widget/widgetEvents.ts\nvar WIDGET_HTML_EVENTS = [\n  \"blur\",\n  \"change\",\n  \"contextmenu\",\n  \"focus\",\n  \"keydown\",\n  \"keyup\",\n  \"click\",\n  \"dblclick\",\n  \"mouseenter\",\n  \"mousemove\",\n  \"mouseleave\",\n  \"wheel\",\n  \"touchstart\",\n  \"touchmove\",\n  \"touchend\",\n  \"touchcancel\"\n];\nfunction allocMouseEvent(type, sourceEvent, current) {\n  const { offsetX, offsetY, clientX, clientY } = sourceEvent;\n  const { currentX, currentY } = WidgetEventUtil.calcCurrentXY(current, sourceEvent);\n  return { type, offsetX, offsetY, clientX, clientY, currentX, currentY, sourceEvent };\n}\nfunction allocTouchEvent(type, sourceEvent, _current) {\n  return { type, sourceEvent };\n}\nvar WidgetAllocators = {\n  blur: (sourceEvent) => {\n    return { type: \"blur\", sourceEvent };\n  },\n  change: (sourceEvent) => {\n    return { type: \"change\", sourceEvent };\n  },\n  contextmenu: (sourceEvent, current) => {\n    return allocMouseEvent(\"contextmenu\", sourceEvent, current);\n  },\n  focus: (sourceEvent) => {\n    return { type: \"focus\", sourceEvent };\n  },\n  keydown: (sourceEvent) => {\n    return { type: \"keydown\", sourceEvent };\n  },\n  keyup: (sourceEvent) => {\n    return { type: \"keyup\", sourceEvent };\n  },\n  click: (sourceEvent, current) => {\n    return allocMouseEvent(\"click\", sourceEvent, current);\n  },\n  dblclick: (sourceEvent, current) => {\n    return allocMouseEvent(\"dblclick\", sourceEvent, current);\n  },\n  mouseenter: (sourceEvent, current) => {\n    return allocMouseEvent(\"mouseenter\", sourceEvent, current);\n  },\n  mousemove: (sourceEvent, current) => {\n    return allocMouseEvent(\"mousemove\", sourceEvent, current);\n  },\n  mouseleave: (sourceEvent, current) => {\n    return allocMouseEvent(\"mouseleave\", sourceEvent, current);\n  },\n  wheel: (sourceEvent) => {\n    const { offsetX, offsetY, clientX, clientY } = sourceEvent;\n    const factor = sourceEvent.deltaMode === 0 ? 0.01 : 1;\n    const deltaX = sourceEvent.deltaX * factor;\n    const deltaY = sourceEvent.deltaY * factor;\n    return { type: \"wheel\", offsetX, offsetY, clientX, clientY, deltaX, deltaY, sourceEvent };\n  },\n  touchstart: (sourceEvent, current) => {\n    return allocTouchEvent(\"touchstart\", sourceEvent, current);\n  },\n  touchmove: (sourceEvent, current) => {\n    return allocTouchEvent(\"touchmove\", sourceEvent, current);\n  },\n  touchend: (sourceEvent, current) => {\n    return allocTouchEvent(\"touchend\", sourceEvent, current);\n  },\n  touchcancel: (sourceEvent, current) => {\n    return allocTouchEvent(\"touchcancel\", sourceEvent, current);\n  }\n};\nvar WidgetEventUtil = class {\n  static alloc(type, sourceEvent, current) {\n    return WidgetAllocators[type](sourceEvent, current);\n  }\n  static isHTMLEvent(type) {\n    const htmlTypes = WIDGET_HTML_EVENTS;\n    return htmlTypes.includes(type);\n  }\n  static calcCurrentXY(current, event) {\n    const currentRect = current.getBoundingClientRect();\n    return { currentX: event.clientX - currentRect.x, currentY: event.clientY - currentRect.y };\n  }\n};\n\n// packages/ag-charts-community/src/widget/widgetListenerHTML.ts\nvar WidgetListenerHTML = class {\n  constructor() {\n    this.widgetListeners = {};\n    this.sourceListeners = {};\n  }\n  initSourceHandler(type, handler) {\n    this.sourceListeners ?? (this.sourceListeners = {});\n    this.sourceListeners[type] = handler;\n  }\n  lazyGetWidgetListeners(type, target) {\n    var _a;\n    if (!(type in (this.sourceListeners ?? {}))) {\n      const sourceHandler = (sourceEvent) => {\n        const widgetEvent = WidgetEventUtil.alloc(type, sourceEvent, target.getElement());\n        for (const widgetListener of this.widgetListeners?.[type] ?? []) {\n          widgetListener(widgetEvent, target);\n        }\n      };\n      const opts = {};\n      if (type.startsWith(\"touch\"))\n        opts.passive = false;\n      this.initSourceHandler(type, sourceHandler);\n      target.getElement().addEventListener(type, sourceHandler, opts);\n    }\n    this.widgetListeners ?? (this.widgetListeners = {});\n    (_a = this.widgetListeners)[type] ?? (_a[type] = []);\n    return this.widgetListeners[type];\n  }\n  add(type, target, handler) {\n    const listeners = this.lazyGetWidgetListeners(type, target);\n    listeners.push(handler);\n  }\n  remove(type, target, handler) {\n    const listeners = this.lazyGetWidgetListeners(type, target);\n    const index = listeners.indexOf(handler);\n    if (index > -1)\n      listeners.splice(index, 1);\n  }\n  destroy(target) {\n    for (const [key, sourceHandler] of Object.entries(this.sourceListeners ?? {})) {\n      const type = key;\n      target.getElement().removeEventListener(type, sourceHandler);\n    }\n    this.widgetListeners = void 0;\n    this.sourceListeners = void 0;\n  }\n};\n\n// packages/ag-charts-community/src/widget/mouseDragger.ts\nvar MouseDragger = class {\n  constructor(glob, self, myCallbacks, downEvent) {\n    this.glob = glob;\n    this.self = self;\n    this.window = getWindow();\n    this.mousegeneral = (generalEvent) => {\n      generalEvent.stopPropagation();\n      generalEvent.stopImmediatePropagation();\n    };\n    this.mousemove = (moveEvent) => {\n      moveEvent.stopPropagation();\n      moveEvent.stopImmediatePropagation();\n      this.glob.globalMouseDragCallbacks?.mousemove(moveEvent);\n    };\n    this.mouseup = (upEvent) => {\n      if (upEvent.button === 0) {\n        upEvent.stopPropagation();\n        upEvent.stopImmediatePropagation();\n        this.glob.globalMouseDragCallbacks?.mouseup(upEvent);\n        this.destroy();\n      }\n    };\n    const { window: window2, mousegeneral, mousemove, mouseup } = this;\n    window2.addEventListener(\"mousedown\", mousegeneral, { capture: true });\n    window2.addEventListener(\"mouseenter\", mousegeneral, { capture: true });\n    window2.addEventListener(\"mouseleave\", mousegeneral, { capture: true });\n    window2.addEventListener(\"mouseout\", mousegeneral, { capture: true });\n    window2.addEventListener(\"mouseover\", mousegeneral, { capture: true });\n    window2.addEventListener(\"mousemove\", mousemove, { capture: true });\n    window2.addEventListener(\"mouseup\", mouseup, { capture: true });\n    self.mouseDragger = this;\n    glob.globalMouseDragCallbacks = myCallbacks;\n    glob.globalMouseDragCallbacks.mousedown(downEvent);\n  }\n  destroy() {\n    const { window: window2, mousegeneral, mousemove, mouseup } = this;\n    window2.removeEventListener(\"mousedown\", mousegeneral, { capture: true });\n    window2.removeEventListener(\"mouseenter\", mousegeneral, { capture: true });\n    window2.removeEventListener(\"mouseleave\", mousegeneral, { capture: true });\n    window2.removeEventListener(\"mouseout\", mousegeneral, { capture: true });\n    window2.removeEventListener(\"mouseover\", mousegeneral, { capture: true });\n    window2.removeEventListener(\"mousemove\", mousemove, { capture: true });\n    window2.removeEventListener(\"mouseup\", mouseup, { capture: true });\n    this.glob.globalMouseDragCallbacks = void 0;\n    this.self.mouseDragger = void 0;\n  }\n};\nfunction startMouseDrag(glob, self, myCallbacks, downEvent) {\n  if (glob.globalMouseDragCallbacks != null)\n    return void 0;\n  return new MouseDragger(glob, self, myCallbacks, downEvent);\n}\n\n// packages/ag-charts-community/src/widget/touchDragger.ts\nvar LONG_TAP_DURATION_MS = 500;\nvar LONG_TAP_INTERRUPT_MIN_TOUCHMOVE_PXPX = 100;\nfunction deltaClientSquared(a, b) {\n  const dx = a.clientX - b.clientX;\n  const dy = a.clientY - b.clientY;\n  return dx * dx + dy * dy;\n}\nvar gIsInLongTap = false;\nvar TouchDragger = class {\n  constructor(glob, self, myCallbacks, initialTouch, target) {\n    this.glob = glob;\n    this.self = self;\n    this.initialTouch = initialTouch;\n    this.target = target;\n    this.longTapInterrupted = false;\n    this.longtap = () => {\n      const { target, initialTouch } = this;\n      if (!this.longTapInterrupted) {\n        target.dispatchEvent(new TouchEvent(\"touchcancel\", { touches: [initialTouch], bubbles: true }));\n        gIsInLongTap = true;\n        const longTapMove = (e) => {\n          e.preventDefault();\n        };\n        const longTapEnd = (e) => {\n          gIsInLongTap = false;\n          e.preventDefault();\n          target.removeEventListener(\"touchmove\", longTapMove);\n          target.removeEventListener(\"touchend\", longTapEnd);\n          target.removeEventListener(\"touchcancel\", longTapEnd);\n        };\n        target.addEventListener(\"touchmove\", longTapMove, { passive: false });\n        target.addEventListener(\"touchend\", longTapEnd, { passive: false });\n        target.addEventListener(\"touchcancel\", longTapEnd, { passive: false });\n        const { clientX, clientY } = initialTouch;\n        const contextMenuEvent = new PointerEvent(\"contextmenu\", {\n          bubbles: true,\n          cancelable: true,\n          view: getWindow(),\n          clientX,\n          clientY,\n          pointerType: \"touch\"\n        });\n        target.dispatchEvent(contextMenuEvent);\n      }\n    };\n    this.touchmove = (moveEvent) => {\n      const { glob, self, initialTouch } = this;\n      const touch = this.findInitialFinger(moveEvent.targetTouches);\n      if (touch != null) {\n        this.longTapInterrupted = this.longTapInterrupted || deltaClientSquared(initialTouch, touch) > LONG_TAP_INTERRUPT_MIN_TOUCHMOVE_PXPX;\n        if (self.dragTouchEnabled && touch != null) {\n          glob.globalTouchDragCallbacks?.touchmove(moveEvent, touch);\n        }\n      }\n    };\n    this.touchend = (endEvent) => {\n      this.longTapInterrupted = true;\n      const touch = this.findInitialFinger(endEvent.changedTouches, endEvent.touches);\n      if (touch != null) {\n        this.glob.globalTouchDragCallbacks?.touchend(endEvent, touch);\n      }\n      this.destroy();\n    };\n    this.longtapTimer = setTimeout(this.longtap, LONG_TAP_DURATION_MS);\n    const { touchmove, touchend } = this;\n    target.addEventListener(\"touchmove\", touchmove, { passive: false });\n    target.addEventListener(\"touchstart\", touchend, { passive: false });\n    target.addEventListener(\"touchend\", touchend, { passive: false });\n    target.addEventListener(\"touchcancel\", touchend, { passive: false });\n    self.touchDragger = this;\n    glob.globalTouchDragCallbacks = myCallbacks;\n  }\n  destroy() {\n    const { longtapTimer, touchmove, touchend } = this;\n    clearTimeout(longtapTimer);\n    this.target.removeEventListener(\"touchstart\", touchend);\n    this.target.removeEventListener(\"touchmove\", touchmove);\n    this.target.removeEventListener(\"touchend\", touchend);\n    this.target.removeEventListener(\"touchcancel\", touchend);\n    this.glob.globalTouchDragCallbacks = void 0;\n    this.self.touchDragger = void 0;\n  }\n  findInitialFinger(...touchLists) {\n    const touches = touchLists.map((touchList) => Array.from(touchList)).flat();\n    return Array.from(touches).find((v) => v.identifier === this.initialTouch.identifier);\n  }\n};\nfunction startOneFingerTouch(glob, self, myCallbacks, initialTouch, target) {\n  if (glob.globalTouchDragCallbacks != null || gIsInLongTap)\n    return void 0;\n  return new TouchDragger(glob, self, myCallbacks, initialTouch, target);\n}\n\n// packages/ag-charts-community/src/widget/widgetListenerInternal.ts\nfunction makeMouseDrag(current, type, origin3, sourceEvent) {\n  const { currentX, currentY } = WidgetEventUtil.calcCurrentXY(current.getElement(), sourceEvent);\n  const originDeltaX = sourceEvent.pageX - origin3.pageX;\n  const originDeltaY = sourceEvent.pageY - origin3.pageY;\n  return {\n    type,\n    device: \"mouse\",\n    offsetX: origin3.offsetX + originDeltaX,\n    offsetY: origin3.offsetY + originDeltaY,\n    clientX: sourceEvent.clientX,\n    clientY: sourceEvent.clientY,\n    currentX,\n    currentY,\n    originDeltaX,\n    originDeltaY,\n    sourceEvent\n  };\n}\nfunction getTouchOffsets(current, { pageX, pageY }) {\n  const { x, y } = current.getElement().getBoundingClientRect();\n  return { offsetX: pageX - x, offsetY: pageY - y };\n}\nfunction makeTouchDrag(current, type, origin3, sourceEvent, touch) {\n  const { currentX, currentY } = WidgetEventUtil.calcCurrentXY(current.getElement(), touch);\n  const originDeltaX = touch.pageX - origin3.pageX;\n  const originDeltaY = touch.pageY - origin3.pageY;\n  return {\n    type,\n    device: \"touch\",\n    offsetX: origin3.offsetX + originDeltaX,\n    offsetY: origin3.offsetY + originDeltaY,\n    clientX: touch.clientX,\n    clientY: touch.clientY,\n    currentX,\n    currentY,\n    originDeltaX,\n    originDeltaY,\n    sourceEvent\n  };\n}\nvar GlobalCallbacks = {};\nvar WidgetListenerInternal = class {\n  constructor(dispatchCallback) {\n    this.dispatchCallback = dispatchCallback;\n    this.dragTouchEnabled = true;\n  }\n  destroy() {\n    this.dragTriggerRemover?.();\n    this.dragTriggerRemover = void 0;\n    this.dragStartListeners = void 0;\n    this.dragMoveListeners = void 0;\n    this.dragEndListeners = void 0;\n    this.mouseDragger?.destroy();\n    this.touchDragger?.destroy();\n  }\n  add(type, target, handler) {\n    switch (type) {\n      case \"drag-start\": {\n        this.dragStartListeners ?? (this.dragStartListeners = []);\n        this.dragStartListeners.push(handler);\n        this.registerDragTrigger(target);\n        break;\n      }\n      case \"drag-move\": {\n        this.dragMoveListeners ?? (this.dragMoveListeners = []);\n        this.dragMoveListeners.push(handler);\n        this.registerDragTrigger(target);\n        break;\n      }\n      case \"drag-end\": {\n        this.dragEndListeners ?? (this.dragEndListeners = []);\n        this.dragEndListeners.push(handler);\n        this.registerDragTrigger(target);\n        break;\n      }\n    }\n  }\n  remove(type, _target, handler) {\n    switch (type) {\n      case \"drag-start\":\n        return this.removeHandler(this.dragStartListeners, handler);\n      case \"drag-move\":\n        return this.removeHandler(this.dragMoveListeners, handler);\n      case \"drag-end\":\n        return this.removeHandler(this.dragEndListeners, handler);\n    }\n  }\n  removeHandler(array2, handler) {\n    const index = array2?.indexOf(handler);\n    if (index !== void 0)\n      array2?.splice(index, 1);\n  }\n  registerDragTrigger(target) {\n    if (this.dragTriggerRemover == null) {\n      const mouseTrigger = (event) => this.triggerMouseDrag(target, event);\n      const touchTrigger = (event) => this.triggerTouchDrag(target, event);\n      target.getElement().addEventListener(\"mousedown\", mouseTrigger);\n      target.getElement().addEventListener(\"touchstart\", touchTrigger, { passive: false });\n      this.dragTriggerRemover = () => {\n        target.getElement().removeEventListener(\"mousedown\", mouseTrigger);\n        target.getElement().removeEventListener(\"touchstart\", touchTrigger);\n      };\n    }\n  }\n  triggerMouseDrag(current, downEvent) {\n    if (downEvent.button === 0) {\n      this.startMouseDrag(current, downEvent);\n    }\n  }\n  startMouseDrag(current, initialDownEvent) {\n    const origin3 = { pageX: NaN, pageY: NaN, offsetX: NaN, offsetY: NaN };\n    partialAssign([\"pageX\", \"pageY\", \"offsetX\", \"offsetY\"], origin3, initialDownEvent);\n    const dragCallbacks = {\n      mousedown: (downEvent) => {\n        const dragStartEvent = makeMouseDrag(current, \"drag-start\", origin3, downEvent);\n        this.dispatch(\"drag-start\", current, dragStartEvent);\n      },\n      mousemove: (moveEvent) => {\n        const dragMoveEvent = makeMouseDrag(current, \"drag-move\", origin3, moveEvent);\n        this.dispatch(\"drag-move\", current, dragMoveEvent);\n      },\n      mouseup: (upEvent) => {\n        const dragEndEvent = makeMouseDrag(current, \"drag-end\", origin3, upEvent);\n        this.dispatch(\"drag-end\", current, dragEndEvent);\n        this.endDrag(current, dragEndEvent);\n      }\n    };\n    this.mouseDragger = startMouseDrag(GlobalCallbacks, this, dragCallbacks, initialDownEvent);\n  }\n  endDrag(target, { sourceEvent, clientX, clientY }) {\n    const elem = target.getElement();\n    const rect = elem.getBoundingClientRect();\n    if (!BBoxValues.containsPoint(rect, clientX, clientY)) {\n      elem.dispatchEvent(new MouseEvent(\"mouseleave\", sourceEvent));\n      sourceEvent.target?.dispatchEvent(new MouseEvent(\"mouseenter\", sourceEvent));\n    }\n  }\n  triggerTouchDrag(current, startEvent) {\n    const touch = startEvent.targetTouches.item(0);\n    if (startEvent.targetTouches.length === 1 && touch != null) {\n      this.startOneFingerTouch(current, startEvent, touch);\n    }\n  }\n  startOneFingerTouch(current, initialEvent, initialTouch) {\n    const origin3 = { pageX: NaN, pageY: NaN, ...getTouchOffsets(current, initialTouch) };\n    partialAssign([\"pageX\", \"pageY\"], origin3, initialTouch);\n    const dragCallbacks = {\n      touchmove: (moveEvent, touch) => {\n        const dragMoveEvent = makeTouchDrag(current, \"drag-move\", origin3, moveEvent, touch);\n        this.dispatch(\"drag-move\", current, dragMoveEvent);\n      },\n      touchend: (cancelEvent, touch) => {\n        const dragMoveEvent = makeTouchDrag(current, \"drag-end\", origin3, cancelEvent, touch);\n        this.dispatch(\"drag-end\", current, dragMoveEvent);\n      }\n    };\n    const target = current.getElement();\n    this.touchDragger = startOneFingerTouch(GlobalCallbacks, this, dragCallbacks, initialTouch, target);\n    const dragStartEvent = makeTouchDrag(current, \"drag-start\", origin3, initialEvent, initialTouch);\n    this.dispatch(\"drag-start\", current, dragStartEvent);\n  }\n  dispatch(type, current, event) {\n    switch (type) {\n      case \"drag-start\":\n        this.dragStartListeners?.forEach((handler) => handler(event, current));\n        break;\n      case \"drag-move\":\n        this.dragMoveListeners?.forEach((handler) => handler(event, current));\n        break;\n      case \"drag-end\":\n        this.dragEndListeners?.forEach((handler) => handler(event, current));\n        break;\n    }\n    this.dispatchCallback(type, event);\n  }\n};\n\n// packages/ag-charts-community/src/widget/widget.ts\nvar WidgetBounds = class {\n  constructor(elem) {\n    this.elem = elem;\n  }\n  setBounds(bounds) {\n    setElementBBox(this.elemContainer ?? this.elem, bounds);\n  }\n  getBounds() {\n    return getElementBBox(this.elemContainer ?? this.elem);\n  }\n  static setElementContainer(widget, elemContainer) {\n    const currentBounds = widget.getBounds();\n    setElementBBox(elemContainer, currentBounds);\n    setElementStyles(widget.elem, { width: \"100%\", height: \"100%\" });\n    widget.elem.remove();\n    widget.elemContainer = elemContainer;\n    widget.elemContainer.replaceChildren(widget.elem);\n  }\n};\nvar Widget = class extends WidgetBounds {\n  constructor(elem) {\n    super(elem);\n    this.elem = elem;\n    this.index = NaN;\n    this.children = [];\n  }\n  getElement() {\n    return this.elem;\n  }\n  getBoundingClientRect() {\n    return this.elem.getBoundingClientRect();\n  }\n  get clientWidth() {\n    return this.elem.clientWidth;\n  }\n  get clientHeight() {\n    return this.elem.clientHeight;\n  }\n  destroy() {\n    this.parent?.removeChild(this);\n    this.children.forEach((child) => {\n      child.parent = void 0;\n      child.destroy();\n    });\n    this.children.length = 0;\n    this.destructor();\n    this.elem.remove();\n    this.elemContainer?.remove();\n    this.internalListener?.destroy();\n    this.htmlListener?.destroy(this);\n  }\n  setHidden(hidden) {\n    setElementStyle(this.elem, \"display\", hidden ? \"none\" : void 0);\n  }\n  isHidden() {\n    return getWindow()?.getComputedStyle?.(this.elem).display === \"none\";\n  }\n  setCursor(cursor) {\n    setElementStyle(this.elem, \"cursor\", cursor);\n  }\n  setTextContent(textContent) {\n    this.elem.textContent = textContent ?? null;\n  }\n  setAriaDescribedBy(ariaDescribedBy) {\n    setAttribute(this.elem, \"aria-describedby\", ariaDescribedBy);\n  }\n  setAriaHidden(ariaHidden) {\n    setAttribute(this.elem, \"aria-hidden\", ariaHidden);\n  }\n  setAriaLabel(ariaLabel) {\n    setAttribute(this.elem, \"aria-label\", ariaLabel);\n  }\n  setInnerHTML(html) {\n    this.elem.innerHTML = html;\n  }\n  isDisabled() {\n    return getAttribute(this.elem, \"aria-disabled\", false);\n  }\n  parseFloat(s) {\n    return s === \"\" ? 0 : parseFloat(s);\n  }\n  cssLeft() {\n    return this.parseFloat(this.elem.style.left);\n  }\n  cssTop() {\n    return this.parseFloat(this.elem.style.top);\n  }\n  cssWidth() {\n    return this.parseFloat(this.elem.style.width);\n  }\n  cssHeight() {\n    return this.parseFloat(this.elem.style.height);\n  }\n  focus() {\n    this.elem.focus();\n  }\n  setPreventsDefault(preventDefault) {\n    setAttribute(this.elem, \"data-preventdefault\", preventDefault);\n  }\n  setTabIndex(tabIndex) {\n    setAttribute(this.elem, \"tabindex\", tabIndex);\n  }\n  addChild(child) {\n    this.addChildToDOM(child, this.getBefore(child));\n    this.children.push(child);\n    child.index = this.children.length - 1;\n    child.parent = this;\n    this.onChildAdded(child);\n  }\n  removeChild(child) {\n    const i = this.children.findIndex((value) => value === child);\n    this.children.splice(i, 1);\n    this.removeChildFromDOM(child);\n    this.onChildRemoved(child);\n  }\n  moveChild(child, domIndex) {\n    if (child.domIndex === domIndex)\n      return;\n    child.domIndex = domIndex;\n    this.removeChildFromDOM(child);\n    this.addChildToDOM(child, this.getBefore(child));\n  }\n  addClass(...tokens) {\n    this.elem.classList.add(...tokens);\n  }\n  removeClass(...tokens) {\n    this.elem.classList.remove(...tokens);\n  }\n  toggleClass(token, force) {\n    this.elem.classList.toggle(token, force);\n  }\n  appendOrInsert(child, before) {\n    if (before) {\n      before.getElement().insertAdjacentElement(\"beforebegin\", child);\n    } else {\n      this.elem.appendChild(child);\n    }\n  }\n  addChildToDOM(child, before) {\n    this.appendOrInsert(child.getElement(), before);\n  }\n  removeChildFromDOM(child) {\n    this.elem.removeChild(child.getElement());\n  }\n  onChildAdded(_child) {\n  }\n  onChildRemoved(_child) {\n  }\n  getBefore({ domIndex }) {\n    if (domIndex === void 0)\n      return void 0;\n    return this.children.filter((child) => child.domIndex !== void 0 && child.domIndex > domIndex).reduce((prev, curr) => !prev || curr.domIndex < prev.domIndex ? curr : prev, void 0);\n  }\n  addListener(type, listener) {\n    if (WidgetEventUtil.isHTMLEvent(type)) {\n      this.htmlListener ?? (this.htmlListener = new WidgetListenerHTML());\n      this.htmlListener.add(type, this, listener);\n    } else {\n      this.internalListener ?? (this.internalListener = new WidgetListenerInternal(this.onDispatch.bind(this)));\n      this.internalListener.add(type, this, listener);\n    }\n    return () => this.removeListener(type, listener);\n  }\n  removeListener(type, listener) {\n    if (WidgetEventUtil.isHTMLEvent(type)) {\n      this.htmlListener?.remove(type, this, listener);\n    } else if (this.htmlListener != null) {\n      this.internalListener?.remove(type, this, listener);\n    }\n  }\n  setDragTouchEnabled(dragTouchEnabled) {\n    this.internalListener ?? (this.internalListener = new WidgetListenerInternal(this.onDispatch.bind(this)));\n    this.internalListener.dragTouchEnabled = dragTouchEnabled;\n  }\n  onDispatch(type, event) {\n    if (!event.sourceEvent.bubbles)\n      return;\n    let { parent } = this;\n    while (parent != null) {\n      const { internalListener } = parent;\n      if (internalListener != null) {\n        const parentEvent = { ...event, ...WidgetEventUtil.calcCurrentXY(parent.getElement(), event) };\n        internalListener.dispatch(type, parent, parentEvent);\n      }\n      parent = parent.parent;\n    }\n  }\n  static addWindowEvent(_type, listener) {\n    const pagehideHandler = (event) => {\n      if (event.persisted) {\n        return;\n      }\n      listener();\n    };\n    getWindow().addEventListener(\"pagehide\", pagehideHandler);\n    return () => getWindow().removeEventListener(\"pagehide\", pagehideHandler);\n  }\n};\n\n// packages/ag-charts-community/src/chart/layout/layoutManager.ts\nvar LayoutElement = /* @__PURE__ */ ((LayoutElement2) => {\n  LayoutElement2[LayoutElement2[\"Caption\"] = 0] = \"Caption\";\n  LayoutElement2[LayoutElement2[\"Legend\"] = 1] = \"Legend\";\n  LayoutElement2[LayoutElement2[\"ToolbarLeft\"] = 2] = \"ToolbarLeft\";\n  LayoutElement2[LayoutElement2[\"ToolbarBottom\"] = 3] = \"ToolbarBottom\";\n  LayoutElement2[LayoutElement2[\"Navigator\"] = 4] = \"Navigator\";\n  LayoutElement2[LayoutElement2[\"Overlay\"] = 5] = \"Overlay\";\n  return LayoutElement2;\n})(LayoutElement || {});\nvar LayoutManager = class {\n  constructor() {\n    this.events = new EventEmitter();\n    this.elements = /* @__PURE__ */ new Map();\n  }\n  addListener(eventName, listener) {\n    return this.events.on(eventName, listener);\n  }\n  registerElement(element2, listener) {\n    if (this.elements.has(element2)) {\n      this.elements.get(element2).add(listener);\n    } else {\n      this.elements.set(element2, /* @__PURE__ */ new Set([listener]));\n    }\n    return () => this.elements.get(element2)?.delete(listener);\n  }\n  createContext(width2, height2) {\n    const context = new LayoutContext(width2, height2);\n    for (const element2 of Object.values(LayoutElement)) {\n      if (typeof element2 !== \"number\")\n        continue;\n      this.elements.get(element2)?.forEach((listener) => listener(context));\n    }\n    return context;\n  }\n  emitLayoutComplete(context, options) {\n    const eventType = \"layout:complete\";\n    const { width: width2, height: height2 } = context;\n    this.events.emit(eventType, {\n      type: eventType,\n      axes: options.axes ?? [],\n      chart: { width: width2, height: height2 },\n      clipSeries: options.clipSeries ?? false,\n      series: options.series\n    });\n  }\n};\nvar LayoutContext = class {\n  constructor(width2, height2) {\n    this.width = width2;\n    this.height = height2;\n    this.layoutBox = new BBox(0, 0, width2, height2);\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartCaptions.ts\nvar ChartCaptions = class {\n  constructor() {\n    this.title = new Caption();\n    this.subtitle = new Caption();\n    this.footnote = new Caption();\n  }\n  positionCaptions(ctx) {\n    const { title, subtitle, footnote } = this;\n    const maxHeight = ctx.layoutBox.height / 10;\n    if (title.enabled) {\n      const { spacing = subtitle.enabled ? Caption.SMALL_PADDING : Caption.LARGE_PADDING } = title;\n      this.positionCaption(\"top\", title, ctx.layoutBox, maxHeight);\n      this.shrinkLayoutByCaption(\"top\", title, ctx.layoutBox, spacing);\n    }\n    if (subtitle.enabled) {\n      this.positionCaption(\"top\", subtitle, ctx.layoutBox, maxHeight);\n      this.shrinkLayoutByCaption(\"top\", subtitle, ctx.layoutBox, subtitle.spacing);\n    }\n    if (footnote.enabled) {\n      this.positionCaption(\"bottom\", footnote, ctx.layoutBox, maxHeight);\n      this.shrinkLayoutByCaption(\"bottom\", footnote, ctx.layoutBox, footnote.spacing);\n    }\n  }\n  positionAbsoluteCaptions(ctx) {\n    const { title, subtitle, footnote } = this;\n    const { rect } = ctx.series;\n    for (const caption of [title, subtitle, footnote]) {\n      if (caption.layoutStyle !== \"overlay\")\n        continue;\n      if (caption.textAlign === \"left\") {\n        caption.node.x = rect.x + caption.padding;\n      } else if (caption.textAlign === \"right\") {\n        const bbox = caption.node.getBBox();\n        caption.node.x = rect.x + rect.width - bbox.width - caption.padding;\n      }\n    }\n  }\n  computeX(align2, layoutBox) {\n    if (align2 === \"left\") {\n      return layoutBox.x;\n    } else if (align2 === \"right\") {\n      return layoutBox.x + layoutBox.width;\n    }\n    return layoutBox.x + layoutBox.width / 2;\n  }\n  positionCaption(vAlign, caption, layoutBox, maxHeight) {\n    const containerHeight = Math.max(TextUtils.getLineHeight(caption.fontSize), maxHeight);\n    caption.node.x = this.computeX(caption.textAlign, layoutBox) + caption.padding;\n    caption.node.y = layoutBox.y + (vAlign === \"top\" ? 0 : layoutBox.height) + caption.padding;\n    caption.node.textBaseline = vAlign;\n    caption.computeTextWrap(layoutBox.width, containerHeight);\n  }\n  shrinkLayoutByCaption(vAlign, caption, layoutBox, spacing = 0) {\n    if (caption.layoutStyle === \"block\") {\n      const bbox = caption.node.getBBox();\n      layoutBox.shrink(\n        vAlign === \"top\" ? Math.ceil(bbox.y - layoutBox.y + bbox.height + spacing) : Math.ceil(layoutBox.y + layoutBox.height - bbox.y + spacing),\n        vAlign\n      );\n    }\n  }\n};\n__decorateClass([\n  Validate(OBJECT)\n], ChartCaptions.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartCaptions.prototype, \"subtitle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartCaptions.prototype, \"footnote\", 2);\n\n// packages/ag-charts-community/src/api/preset/chartTypeOriginator.ts\nvar chartTypes = [\n  \"candlestick\",\n  \"hollow-candlestick\",\n  \"ohlc\",\n  \"line\",\n  \"step-line\",\n  \"hlc\",\n  \"high-low\"\n];\nvar ChartTypeOriginator = class {\n  constructor(chartService) {\n    this.chartService = chartService;\n    this.mementoOriginatorKey = \"chartType\";\n  }\n  createMemento() {\n    let chartType = this.chartService.publicApi?.getOptions()?.chartType;\n    if (chartType == null)\n      chartType = \"candlestick\";\n    return chartType;\n  }\n  guardMemento(blob) {\n    return blob == null || chartTypes.includes(blob);\n  }\n  restoreMemento(_version, _mementoVersion, memento) {\n    if (memento == null)\n      return;\n    const options = { chartType: memento };\n    this.chartService.publicApi?.updateDelta(options).catch((e) => logger_exports.error(\"error restoring state\", e));\n  }\n};\n\n// packages/ag-charts-community/src/util/destroy.ts\nvar DestroyFns = class {\n  constructor() {\n    this.destroyFns = [];\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n    this.destroyFns.length = 0;\n  }\n  setFns(destroyFns) {\n    this.destroy();\n    this.destroyFns = destroyFns;\n  }\n  push(...destroyFns) {\n    this.destroyFns.push(...destroyFns);\n  }\n};\n\n// packages/ag-charts-community/src/version.ts\nvar VERSION = \"11.1.1\";\n\n// packages/ag-charts-community/src/api/state/historyManager.ts\nvar NOT_FOUND = Symbol(\"previous-memento-not-found\");\nvar HistoryManager = class {\n  constructor(chartEventManager) {\n    this.history = [];\n    this.historyIndex = -1;\n    this.originators = /* @__PURE__ */ new Map();\n    this.clearState = /* @__PURE__ */ new Map();\n    this.maxHistoryLength = 100;\n    this.debug = Debug.create(true, \"history\");\n    this.destroyFns = new DestroyFns();\n    this.destroyFns.setFns([\n      chartEventManager.addListener(\"series-undo\", this.undo.bind(this)),\n      chartEventManager.addListener(\"series-redo\", this.redo.bind(this))\n    ]);\n  }\n  destroy() {\n    this.destroyFns.destroy();\n  }\n  addMementoOriginator(originator) {\n    this.originators.set(originator.mementoOriginatorKey, originator);\n    this.clearState.set(originator.mementoOriginatorKey, originator.createMemento());\n    this.debugEvent(\"History add originator:\", originator.mementoOriginatorKey);\n  }\n  clear() {\n    this.debug(`History clear:`, Object.keys(this.originators));\n    this.history = [];\n    this.historyIndex = -1;\n    for (const [mementoOriginatorKey, originator] of this.originators.entries()) {\n      this.clearState.set(mementoOriginatorKey, originator.createMemento());\n    }\n  }\n  record(label, ...originators) {\n    if (this.historyIndex < this.history.length - 1) {\n      this.history = this.history.slice(0, this.historyIndex + 1);\n    }\n    if (this.history.length > this.maxHistoryLength) {\n      this.history = this.history.slice(-this.maxHistoryLength);\n    }\n    const mementos = /* @__PURE__ */ new Map();\n    for (const originator of originators) {\n      if (!this.originators.has(originator.mementoOriginatorKey)) {\n        throw new Error(\n          `Originator [${originator.mementoOriginatorKey}] has not been added to the HistoryManager.`\n        );\n      }\n      mementos.set(originator.mementoOriginatorKey, originator.createMemento());\n    }\n    this.history.push({ label, mementos });\n    this.historyIndex = this.history.length - 1;\n    this.debugEvent(`History record: [${label}]`);\n  }\n  undo() {\n    const undoAction = this.history[this.historyIndex];\n    if (!undoAction)\n      return;\n    for (const mementoOriginatorKey of undoAction.mementos.keys()) {\n      const previousMemento = this.findPreviousMemento(mementoOriginatorKey);\n      if (previousMemento === NOT_FOUND) {\n        throw new Error(`Could not find previous memento for [${mementoOriginatorKey}].`);\n      }\n      this.restoreMemento(mementoOriginatorKey, previousMemento);\n    }\n    this.historyIndex -= 1;\n    this.debugEvent(`History undo: [${undoAction.label}]`);\n  }\n  redo() {\n    const redoAction = this.history[this.historyIndex + 1];\n    if (!redoAction)\n      return;\n    for (const [mementoOriginatorKey, memento] of redoAction.mementos.entries()) {\n      this.restoreMemento(mementoOriginatorKey, memento);\n    }\n    this.historyIndex += 1;\n    this.debugEvent(`History redo: [${redoAction.label}]`);\n  }\n  findPreviousMemento(mementoOriginatorKey) {\n    for (let i = this.historyIndex - 1; i >= 0; i--) {\n      if (this.history[i].mementos.has(mementoOriginatorKey)) {\n        return this.history[i].mementos.get(mementoOriginatorKey);\n      }\n    }\n    if (this.clearState.has(mementoOriginatorKey)) {\n      return this.clearState.get(mementoOriginatorKey);\n    }\n    return NOT_FOUND;\n  }\n  restoreMemento(mementoOriginatorKey, memento) {\n    this.originators.get(mementoOriginatorKey)?.restoreMemento(VERSION, VERSION, memento);\n  }\n  debugEvent(...logContent) {\n    this.debug(\n      ...logContent,\n      this.history.map((action, index) => index === this.historyIndex ? `** ${action.label} **` : action.label)\n    );\n  }\n};\n\n// packages/ag-charts-community/src/api/state/memento.ts\nvar MementoCaretaker = class _MementoCaretaker {\n  constructor(version) {\n    this.version = version.split(\"-\")[0];\n  }\n  save(...originators) {\n    const packet = { version: this.version };\n    for (const originator of Object.values(originators)) {\n      packet[originator.mementoOriginatorKey] = this.encode(originator, originator.createMemento());\n    }\n    return packet;\n  }\n  restore(blob, ...originators) {\n    if (typeof blob !== \"object\") {\n      logger_exports.warnOnce(`Could not restore data of type [${typeof blob}], expecting an object, ignoring.`);\n      return;\n    }\n    if (blob == null) {\n      logger_exports.warnOnce(`Could not restore data of type [null], expecting an object, ignoring.`);\n      return;\n    }\n    if (!(\"version\" in blob) || typeof blob.version !== \"string\") {\n      logger_exports.warnOnce(`Could not restore data, missing [version] string in object, ignoring.`);\n      return;\n    }\n    for (const originator of originators) {\n      const memento = this.decode(originator, blob[originator.mementoOriginatorKey]);\n      const messages = [];\n      if (!originator.guardMemento(memento, messages)) {\n        const messagesString = messages.length > 0 ? `\n\n${messages.join(\"\\n\\n\")}\n\n` : \"\";\n        logger_exports.warnOnce(\n          `Could not restore [${originator.mementoOriginatorKey}] data, value was invalid, ignoring.${messagesString}`,\n          memento\n        );\n        return;\n      }\n      originator.restoreMemento(this.version, blob.version, memento);\n    }\n  }\n  /**\n   * Encode a memento as a serializable object, encoding any non-serializble types.\n   */\n  encode(originator, memento) {\n    try {\n      return JSON.parse(JSON.stringify(memento, _MementoCaretaker.encodeTypes));\n    } catch (error2) {\n      throw new Error(`Failed to encode [${originator.mementoOriginatorKey}] value [${error2}].`, {\n        cause: error2\n      });\n    }\n  }\n  /**\n   * Decode an encoded memento, decoding any non-serializable types.\n   */\n  decode(originator, encoded) {\n    if (encoded == null)\n      return encoded;\n    try {\n      return JSON.parse(JSON.stringify(encoded), _MementoCaretaker.decodeTypes);\n    } catch (error2) {\n      throw new Error(`Failed to decode [${originator.mementoOriginatorKey}] value [${error2}].`, {\n        cause: error2\n      });\n    }\n  }\n  static encodeTypes(key, value) {\n    if (isDate(this[key])) {\n      return { __type: \"date\", value: this[key].toISOString() };\n    }\n    return value;\n  }\n  static decodeTypes(key, value) {\n    if (isObject(this[key]) && \"__type\" in this[key] && this[key].__type === \"date\") {\n      return new Date(this[key].value);\n    }\n    return value;\n  }\n};\n\n// packages/ag-charts-community/src/api/state/stateManager.ts\nvar StateManager = class {\n  constructor() {\n    this.caretaker = new MementoCaretaker(VERSION);\n    this.state = /* @__PURE__ */ new Map();\n  }\n  setState(originator, value) {\n    if (objectsEqual(this.state.get(originator.mementoOriginatorKey), value)) {\n      return;\n    }\n    this.setStateAndRestore(originator, value);\n  }\n  setStateAndRestore(originator, value) {\n    this.state.set(originator.mementoOriginatorKey, value);\n    this.restoreState(originator);\n  }\n  restoreState(originator) {\n    const { caretaker, state } = this;\n    if (!state.has(originator.mementoOriginatorKey))\n      return;\n    const value = state.get(originator.mementoOriginatorKey);\n    caretaker.restore({ version: caretaker.version, [originator.mementoOriginatorKey]: value }, originator);\n  }\n};\n\n// packages/ag-charts-community/src/styles.css\nvar styles_default = '.ag-charts-wrapper,.ag-charts-wrapper:after,.ag-charts-wrapper:before,.ag-charts-wrapper *,.ag-charts-wrapper *:after,.ag-charts-wrapper *:before{box-sizing:border-box}.ag-charts-wrapper{--align-items: center;--justify-content: center;position:relative;user-select:none;-webkit-user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.ag-charts-wrapper--safe-horizontal{--justify-content: flex-start}.ag-charts-wrapper--safe-vertical{--align-items: flex-start}.ag-charts-tab-guard{width:0%;height:0%;position:absolute;pointer-events:none}.ag-charts-canvas-center{width:100%;height:100%;position:absolute;touch-action:auto;pointer-events:auto;display:flex;align-items:var(--align-items);justify-content:var(--justify-content)}.ag-charts-canvas-container,.ag-charts-canvas{position:relative;user-select:none;-webkit-user-select:none}.ag-charts-canvas-container>*,.ag-charts-canvas>*{display:block;pointer-events:none}.ag-charts-series-area{outline:none;pointer-events:auto;position:absolute}.ag-charts-swapchain{outline:none;opacity:0;pointer-events:none;position:absolute;width:100%;height:100%}.ag-charts-swapchain:focus-visible{opacity:1}.ag-charts-canvas-proxy,.ag-charts-canvas-overlay{inset:0;pointer-events:none;position:absolute;user-select:none;-webkit-user-select:none}.ag-charts-canvas-overlay>*{position:absolute;pointer-events:auto}.ag-charts-theme-default,.ag-charts-theme-default-dark{--ag-charts-accent-color: #2196f3;--ag-charts-background-color: #fff;--ag-charts-border-color: #dddddd;--ag-charts-foreground-color: #464646;--ag-charts-font-family: Verdana, sans-serif;--ag-charts-font-size: 12px;--ag-charts-font-weight: 400;--ag-charts-padding: 20px;--ag-charts-shadow-color: #00000080;--ag-charts-subtle-text-color: #8c8c8c;--ag-charts-text-color: #464646;--ag-charts-chrome-background-color: #fafafa;--ag-charts-chrome-font-family: Verdana, sans-serif;--ag-charts-chrome-font-size: 12px;--ag-charts-chrome-font-weight: 400;--ag-charts-chrome-subtle-text-color: #8c8c8c;--ag-charts-chrome-text-color: #181d1f;--ag-charts-input-background-color: #fff;--ag-charts-input-text-color: #464646;--ag-charts-crosshair-label-background-color: #fff;--ag-charts-crosshair-label-text-color: #464646;--ag-charts-spacing: 4px;--ag-charts-border-radius: 4px;--ag-charts-shadow: 0 2px 8px 0 color-mix(in srgb, black 8%, transparent);--ag-charts-focus-shadow: 0 0 0 3px var(--ag-charts-accent-color);--ag-charts-focus-color: color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-accent-color) 12%);--ag-charts-input-border-color: var(--ag-charts-border-color);--ag-charts-input-border-radius: var(--ag-charts-border-radius);--ag-charts-input-focus-border-color: var(--ag-charts-accent-color);--ag-charts-input-focus-text-color: var(--ag-charts-accent-color);--ag-charts-input-disabled-background-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-foreground-color) 6% );--ag-charts-input-disabled-border-color: var(--ag-charts-border-color);--ag-charts-input-disabled-text-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-input-text-color) 50% );--ag-charts-input-placeholder-text-color: color-mix( in srgb, var(--ag-charts-input-background-color), var(--ag-charts-input-text-color) 60% );--ag-charts-button-background-color: var(--ag-charts-background-color);--ag-charts-button-border-color: var(--ag-charts-border-color);--ag-charts-button-border-radius: var(--ag-charts-border-radius);--ag-charts-button-text-color: var(--ag-charts-text-color);--ag-charts-button-focus-background-color: color-mix( in srgb, var(--ag-charts-button-background-color), var(--ag-charts-accent-color) 12% );--ag-charts-button-focus-border-color: var(--ag-charts-accent-color);--ag-charts-button-focus-text-color: var(--ag-charts-accent-color);--ag-charts-button-disabled-background-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-foreground-color) 6% );--ag-charts-button-disabled-border-color: var(--ag-charts-border-color);--ag-charts-button-disabled-text-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-chrome-text-color) 50% );--ag-charts-checkbox-background-color: color-mix( in srgb, var(--ag-charts-background-color), var(--ag-charts-foreground-color) 35% );--ag-charts-checkbox-checked-background-color: var(--ag-charts-accent-color);--ag-charts-chrome-font-size-small: var(--ag-charts-chrome-font-size);--ag-charts-chrome-font-size-medium: calc(var(--ag-charts-chrome-font-size) * (13 / 12));--ag-charts-chrome-font-size-large: calc(var(--ag-charts-chrome-font-size) * (14 / 12));--ag-charts-border: solid 1px var(--ag-charts-border-color);--ag-charts-focus-border: solid 1px var(--ag-charts-accent-color);--ag-charts-focus-border-shadow: 0 0 0 3px color-mix(in srgb, transparent, var(--ag-charts-accent-color) 20%);--ag-charts-layer-menu: 6;--ag-charts-layer-ui-overlay: 5;--ag-charts-layer-tooltip: 4;--ag-charts-layer-toolbar: 3;--ag-charts-layer-crosshair: 2;--ag-charts-layer-annotations: 1}.ag-charts-theme-default-dark{--ag-charts-shadow: 0 2px 12px 0 color-mix(in srgb, black 33.3%, transparent);--ag-charts-focus-color: color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-accent-color) 22%)}.ag-chart-canvas-wrapper .ag-charts-theme-default{--ag-charts-border-radius: var(--ag-border-radius, 4px);--ag-charts-border: var(--ag-borders-critical, solid 1px) var(--ag-charts-border-color);--ag-charts-focus-shadow: var(--ag-focus-shadow, 0 0 0 3px var(--ag-charts-accent-color));--ag-charts-focus-border-shadow: var( --ag-focus-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-charts-accent-color) 20%) )}.ag-charts-icon{display:block;width:20px;height:20px;speak:none;speak:never;mask:var(--icon) center / contain no-repeat;background-color:currentColor;transition:background-color .25s ease-in-out}.ag-charts-icon-align-center{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNNyAxMGg2djFIN3pNNCA3aDEydjFINHptMSA2aDEwdjFINXoiLz48L3N2Zz4=)}.ag-charts-icon-align-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNNCAxMGg2djFINHptMC0zaDEydjFINHptMCA2aDEwdjFINHoiLz48L3N2Zz4=)}.ag-charts-icon-align-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTAgMTBoNnYxaC02ek00IDdoMTJ2MUg0em0yIDZoMTB2MUg2eiIvPjwvc3ZnPg==)}.ag-charts-icon-arrow-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1LjI5MyA0LjVIMTIuNXYtMUgxN3Y0aC0xVjUuMjA3bC05LjY0NiA5LjY0Ny0uNzA4LS43MDh6IiBmaWxsPSIjMDAwIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03IDE2YTIuNSAyLjUgMCAxIDEtNSAwIDIuNSAyLjUgMCAwIDEgNSAwbS0yLjUgMS41YTEuNSAxLjUgMCAxIDAgMC0zIDEuNSAxLjUgMCAwIDAgMCAzIiBmaWxsPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-arrow-down-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02IDhMMS41IDhMMTAgMThMMTguNSA4TDE0IDhMMTQgM0w2IDNMNiA4Wk03IDRMNyA5SDMuNjYyNDRMMTAgMTYuNDU2TDE2LjMzNzYgOUwxMyA5TDEzIDRMNyA0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-arrow-up-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNCAxMkgxOC41TDEwIDJMMS41IDEySDZMNi4wMDAwMiAxN0gxNFYxMlpNMTMgMTZWMTFIMTYuMzM3NkwxMCAzLjU0NDA1TDMuNjYyNDQgMTFIN0w3LjAwMDAyIDE2SDEzWiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-callout-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtNC41MTRhMjYgMjYgMCAwIDAtMi4wMTcgMS41NGwtLjMxNC4yNmMtLjU1LjQ1Ny0xLjExNS45MjYtMS43NiAxLjQtLjY2OS40OTEtMS41NjItLjAxMi0xLjU2Mi0uOFYxNEg0LjVBMS41IDEuNSAwIDAgMSAzIDEyLjV6TTQuNSA0YS41LjUgMCAwIDAtLjUuNXY4YS41LjUgMCAwIDAgLjUuNWgxLjgzM3YzLjM3MmEzNiAzNiAwIDAgMCAxLjY3OC0xLjMzOGwuMzItLjI2NWEyNiAyNiAwIDAgMSAyLjIyNS0xLjY4NWwuMTI2LS4wODRIMTUuNWEuNS41IDAgMCAwIC41LS41di04YS41LjUgMCAwIDAtLjUtLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyAxdjNoMnYxMkg3djNINnYtM0g0VjRoMlYxek01IDVoM3YxMEg1ek0xMSAxNFY2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6bTEtN2gzdjZoLTN6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-close{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtNSA1IDEwIDEwTTUgMTUgMTUgNSIgc3Ryb2tlPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-comment-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy41MTMgMy45OTVhNi41IDYuNSAwIDAgMSA2LjA5OCAxMS40MWMtLjU4OC4zOTMtMS4yMTcuNTM2LTEuODI5LjU4NWExMyAxMyAwIDAgMS0xLjI3LjAxN0EyNyAyNyAwIDAgMCAxMCAxNkg0LjVhLjUuNSAwIDAgMS0uNS0uNVYxMHEwLS4yNDctLjAwNy0uNTEzYy0uMDA4LS40MTYtLjAxNi0uODU3LjAxNy0xLjI2OS4wNS0uNjEyLjE5Mi0xLjI0LjU4NS0xLjgzYTYuNSA2LjUgMCAwIDEgMi45MTgtMi4zOTNtMy41Ni42MWE1LjUgNS41IDAgMCAwLTUuNjQ2IDIuMzRjLS4yNjYuMzk3LS4zNzkuODQyLS40MiAxLjM1NC0uMDMuMzYtLjAyMi43MTgtLjAxNSAxLjEwOFE1IDkuNjg5IDUgMTB2NWg1cS4zMTEuMDAxLjU5My4wMDhjLjM5LjAwNy43NDcuMDE1IDEuMTA4LS4wMTUuNTEyLS4wNDEuOTU3LS4xNTQgMS4zNTUtLjQyYTUuNSA1LjUgMCAwIDAtMS45ODMtOS45NjciIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-crosshair-add-line{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-date-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMiAyaDF2MTZIMnptMTUgMGgxdjE2aC0xeiIgZmlsbD0iIzE4MUQxRiIvPjxwYXRoIGQ9Ik0xMy4xNTcgMTFINXYtMWg3Ljc5M0wxMSA4LjIwN2wuNzA3LS43MDcgMy4xODIgMy4xODItMy4xODIgMy4xODItLjcwNy0uNzA3eiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-date-price-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMyAySDJ2MTZoMXptMy41MDcgNC44OUw4LjUgNC44OTVWMTBINXYxaDMuNXY3aDF2LTdoNS4wODhsLTEuOTU3IDEuOTU3LjcwNy43MDcgMy4xODItMy4xODJMMTMuMzM4IDcuM2wtLjcwNy43MDdMMTQuNjI0IDEwSDkuNVY0LjkzMmwxLjk1NyAxLjk1Ny43MDctLjcwN0w4Ljk4MiAzIDUuOCA2LjE4MnoiIGZpbGw9IiMxODFEMUYiLz48L3N2Zz4=)}.ag-charts-icon-delete{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTguNDk2IDguOTk2QS41LjUgMCAwIDEgOSA5LjQ5MnY0YS41LjUgMCAxIDEtMSAuMDA4di00YS41LjUgMCAwIDEgLjQ5Ni0uNTA0TTEyIDkuNWEuNS41IDAgMCAwLTEgMHY0YS41LjUgMCAwIDAgMSAweiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTYgNVYzLjVBMi41IDIuNSAwIDAgMSA4LjUgMWgzQTIuNSAyLjUgMCAwIDEgMTQgMy41VjVoMi44MzNhLjUuNSAwIDAgMSAwIDFIMTV2MTAuMjVjMCAuNDE1LS4wNjYuODYzLS4zIDEuMjIxLS4yNTcuMzk0LS42NzIuNjEyLTEuMi42MTJoLTdjLS41MjggMC0uOTQzLS4yMTgtMS4yLS42MTItLjIzNC0uMzU4LS4zLS44MDYtLjMtMS4yMjFWNkgzLjMzM2EuNS41IDAgMCAxIDAtMXptMS0xLjVBMS41IDEuNSAwIDAgMSA4LjUgMmgzQTEuNSAxLjUgMCAwIDEgMTMgMy41VjVIN3pNNiAxNi4yNVY2aDh2MTAuMjVjMCAuMzM1LS4wNTkuNTU0LS4xMzguNjc1LS4wNTUuMDg1LS4xNC4xNTgtLjM2Mi4xNThoLTdjLS4yMjIgMC0uMzA3LS4wNzMtLjM2Mi0uMTU4LS4wOC0uMTIxLS4xMzgtLjM0LS4xMzgtLjY3NSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-disjoint-channel,.ag-charts-icon-disjoint-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTkuMDI4IDE3LjQ2YTIuMjUgMi4yNSAwIDAgMC00LjA5Mi0xLjg1bC05LjUxMS0yLjM3OGEyLjI1IDIuMjUgMCAxIDAtLjIyNS45NzRsOS40NzUgMi4zNjlhMi4yNTEgMi4yNTEgMCAwIDAgNC4zNTMuODg2bS0xLjY2Mi0xLjk2NWExLjI1IDEuMjUgMCAxIDEtLjg4NSAyLjMzOCAxLjI1IDEuMjUgMCAwIDEgLjg4NS0yLjMzOE00LjM0MyAxMy42NjlhMS4yNSAxLjI1IDAgMSAwLTIuMzM4LS44ODUgMS4yNSAxLjI1IDAgMCAwIDIuMzM4Ljg4NU0zLjk3IDguNzY5YTIuMjUgMi4yNSAwIDAgMCAxLjQ1NS0yLjExbDkuNTExLTIuMzc4YTIuMjUgMi4yNSAwIDEgMC0uMjYtLjk2NUw1LjIgNS42ODVhMi4yNSAyLjI1IDAgMSAwLTEuMjMgMy4wODRtLjM3My0yLjU0N2ExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjc1LTMuNDM4YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-drag-handle{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSI1Ljc1IiBjeT0iNy43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjcuNzUiIHI9Ii43NSIgZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNSIvPjxjaXJjbGUgY3g9IjEzLjc1IiBjeT0iNy43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iMTMuNzUiIGN5PSIxMS43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjExLjc1IiByPSIuNzUiIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjUiLz48Y2lyY2xlIGN4PSI1Ljc1IiBjeT0iMTEuNzUiIHI9Ii43NSIgZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNSIvPjwvc3ZnPg==)}.ag-charts-icon-fibonacci-retracement-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA1aDEydjFIMnoiLz48Y2lyY2xlIGN4PSIxNS43NSIgY3k9IjUuNSIgcj0iMS43NSIgc3Ryb2tlPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC4yNSIgY3k9IjE0LjUiIHI9IjEuNzUiIHN0cm9rZT0iIzAwMCIvPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik0xOCAxNUg2di0xaDEyem0wLTQuNUgydi0xaDE2eiIvPjwvc3ZnPg==)}.ag-charts-icon-fibonacci-retracement-trend-based-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJtNC45OTYgMTIuNjc0IDMuMjkxLTUuNzQzLjg2OC40OTctMy4yOTEgNS43NDN6Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjUuNSIgcj0iMS43NSIgc3Ryb2tlPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC4zNTEiIGN5PSIxNC41IiByPSIxLjc1IiBzdHJva2U9IiMwMDAiLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTggNmgtN1Y1aDd6bTAgNC41aC03di0xaDd6bTAgNC41SDZ2LTFoMTJ6Ii8+PC9zdmc+)}.ag-charts-icon-fill-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtOC4wNzEgNC4wNi0uOTI0LS45MjQuNzA3LS43MDcgNy4yODggNy4yODgtNC45NSA0Ljk1YTMuNSAzLjUgMCAwIDEtNC45NSAwbC0xLjQxNC0xLjQxNGEzLjUgMy41IDAgMCAxIDAtNC45NXptLjcwNy43MDhMNC41MzYgOS4wMWEyLjUgMi41IDAgMCAwIDAgMy41MzZMNS45NSAxMy45NmEyLjUgMi41IDAgMCAwIDMuNTM1IDBsNC4yNDMtNC4yNDN6bTYuOSA3LjIwMi0uMzQ1LjM2My0uMzQ0LS4zNjNhLjUuNSAwIDAgMSAuNjg4IDBtLS4zNDUgMS4wOGE4IDggMCAwIDAtLjI4LjMyMyA0LjMgNC4zIDAgMCAwLS40MDkuNTgyYy0uMTEzLjIwMS0uMTQ0LjMyNi0uMTQ0LjM3OGEuODMzLjgzMyAwIDAgMCAxLjY2NyAwYzAtLjA1Mi0uMDMxLS4xNzctLjE0NC0uMzc4YTQuMyA0LjMgMCAwIDAtLjQxLS41ODIgOCA4IDAgMCAwLS4yOC0uMzIybS0uMzQ0LTEuMDguMzQ0LjM2My4zNDQtLjM2My4wMDIuMDAyLjAwNC4wMDQuMDEzLjAxMmE2IDYgMCAwIDEgLjIwNi4yMDhjLjEzMS4xMzYuMzA4LjMyNy40ODUuNTQ1LjE3Ni4yMTUuMzYzLjQ2Ny41MDcuNzI0LjEzNy4yNDMuMjczLjU1My4yNzMuODY4YTEuODMzIDEuODMzIDAgMSAxLTMuNjY3IDBjMC0uMzE1LjEzNi0uNjI1LjI3My0uODY4LjE0NC0uMjU3LjMzLS41MDkuNTA3LS43MjRhOSA5IDAgMCAxIC42NDUtLjcwOGwuMDQ2LS4wNDUuMDEzLS4wMTIuMDA0LS4wMDR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-hollow-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1vcGFjaXR5PSIuMTUiIGQ9Ik01IDVoM3YxMEg1eiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTcgMXYzaDJ2MTJIN3YzSDZ2LTNINFY0aDJWMXpNNSA1aDN2MTBINXptNyAyaDN2NmgtM3ptLTEgN1Y2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-horizontal-line,.ag-charts-icon-horizontal-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNLjUgOS41aDcuMzA2YTIuMjUgMi4yNSAwIDAgMSA0LjM4OCAwSDE5LjV2MWgtNy4zMDZhMi4yNSAyLjI1IDAgMCAxLTQuMzg4IDBILjV6bTkuNSAxLjc1YTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTQuMjQyIDIuNzIyYy0uNjEyIDAtMS4yLjI0My0xLjYzMi42NzVsLTEuMzQzIDEuMzQ0YS41LjUgMCAwIDAtLjExMi4xMTJMNC4wNSAxMS45NTljLS4yMDcuMjA3LS4zNi40Ni0uNDQ2Ljc0di4wMDFsLS42OSAyLjc2N3YuMDAyYS44Mi44MiAwIDAgMCAxLjAyMiAxLjAyMWguMDAybDIuNjM0LS44MjJjLjI4LS4wODUuNTM0LS4yMzcuNzQtLjQ0M2w3LjEwNy03LjEwOGEuNS41IDAgMCAwIC4xMTItLjExMmwxLjM0My0xLjM0M2EyLjMwOCAyLjMwOCAwIDAgMC0xLjYzMi0zLjk0TTE0LjEyMiA3bDEuMDQ0LTEuMDQ1YTEuMzA4IDEuMzA4IDAgMSAwLTEuODQ5LTEuODVMMTIuMjcxIDUuMTV6bS0yLjU1OC0xLjE0Mi02LjgwNyA2LjgwOWEuOC44IDAgMCAwLS4xOTYuMzI1bC0uNzUgMi40NjggMi40Ny0uNzQ5YS44LjggMCAwIDAgLjMyNS0uMTk0bDYuODA4LTYuODF6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTcuMzYyIDQuODczLTQuNTk0IDYuNjU0LTQuODUtMy4zMTctNC4yNTEgNi45NzctLjg1NC0uNTJMNy42MTIgNi43OWw0Ljg5OSAzLjM1IDQuMDI4LTUuODM2eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-line-style-dashed{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA5aDR2MUgyem0xMiAwaDR2MWgtNHpNOCA5aDR2MUg4eiIvPjwvc3ZnPg==)}.ag-charts-icon-line-style-dotted{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSIyLjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC41IiBjeT0iOS41IiByPSIuNSIgZmlsbD0iIzAwMCIvPjxjaXJjbGUgY3g9IjYuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48Y2lyY2xlIGN4PSI4LjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTAuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48Y2lyY2xlIGN4PSIxMi41IiBjeT0iOS41IiByPSIuNSIgZmlsbD0iIzAwMCIvPjxjaXJjbGUgY3g9IjE0LjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTYuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-line-style-solid{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA5aDE2djFIMnoiLz48L3N2Zz4=)}.ag-charts-icon-line-with-markers-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTk4IDQuODg4LTMuNTU2IDQuOTE4YTIuMjUgMi4yNSAwIDEgMS0zLjg2Ni43NWwtMS40MzItLjlhMi4yNCAyLjI0IDAgMCAxLTIuMDA5LjQzNWwtMy44MjggNi40MjgtLjg2LS41MTJMNi40NSA5LjYyM2EyLjI1IDIuMjUgMCAxIDEgMy41MS0uNzYxbDEuMzI5LjgzNWEyLjI0IDIuMjQgMCAwIDEgMi41NTctLjQ5N2wzLjU0Mi00Ljg5OHptLTQuOTYgNS4xNTNhMS4yNSAxLjI1IDAgMSAwLS42NCAyLjQxOSAxLjI1IDEuMjUgMCAwIDAgLjY0LTIuNDE5TTkuMSA4LjMyMXEuMDY2LS4xOTIuMDY3LS40MDRhMS4yNSAxLjI1IDAgMSAwLS4wNjcuNDA0IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-lock,.ag-charts-icon-locked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuMjA3IDMuNzY0YTIuODk0IDIuODk0IDAgMCAwLTIuODk1IDIuODk0VjloNS43ODlWNi42NThhMi44OTQgMi44OTQgMCAwIDAtMi44OTUtMi44OTRNMTQuMSA5VjYuNjU4YTMuODk0IDMuODk0IDAgMSAwLTcuNzg5IDB2Mi4zNDlBMi41IDIuNSAwIDAgMCA0IDExLjV2M0EyLjUgMi41IDAgMCAwIDYuNSAxN2g4YTIuNSAyLjUgMCAwIDAgMi41LTIuNXYtM0EyLjUgMi41IDAgMCAwIDE0LjUgOXpNNi41IDEwQTEuNSAxLjUgMCAwIDAgNSAxMS41djNBMS41IDEuNSAwIDAgMCA2LjUgMTZoOGExLjUgMS41IDAgMCAwIDEuNS0xLjV2LTNhMS41IDEuNSAwIDAgMC0xLjUtMS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-measurer-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibTQuNDYxIDEyLjcxIDEuNTMyLTEuNTMxIDEuNDE0IDEuNDE0LjcwNy0uNzA3TDYuNyAxMC40NzJsMS41MzItMS41MzMgMiAyIC43MDctLjcwNy0yLTIgNi4wMS02LjAxIDIuODMgMi44MjhMNS4wNSAxNy43NzggMi4yMjIgMTQuOTVsMS41MzItMS41MzIgMS40MTQgMS40MTQuNzA3LS43MDd6TS44MDggMTQuOTVsLjcwNy0uNzA3TDE0LjI0MyAxLjUxNWwuNzA3LS43MDcuNzA3LjcwNyAyLjgyOCAyLjgyOC43MDcuNzA3LS43MDcuNzA3TDUuNzU3IDE4LjQ4NWwtLjcwNy43MDctLjcwNy0uNzA3LTIuODI4LTIuODI4em0xMS4wNzgtNi44MzVMMTAuNDcgNi43bC43MDctLjcwNyAxLjQxNSAxLjQxNHptLjgyNC0zLjY1NCAxIDEgLjcwOC0uNzA3LTEtMXoiIGZpbGw9IiMxODFEMUYiLz48L3N2Zz4=)}.ag-charts-icon-note-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtMy4yMWwtMS40NjkgMi41N2ExIDEgMCAwIDEtMS42ODIuMDg1TDcuMjQzIDE0SDQuNUExLjUgMS41IDAgMCAxIDMgMTIuNXpNNC41IDRhLjUuNSAwIDAgMC0uNS41djhhLjUuNSAwIDAgMCAuNS41aDMuMjU3bDIuMTk2IDMuMDc0TDExLjcxIDEzaDMuNzlhLjUuNSAwIDAgMCAuNS0uNXYtOGEuNS41IDAgMCAwLS41LS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNi41IDYuNUEuNS41IDAgMCAxIDcgNmg2YS41LjUgMCAwIDEgMCAxSDdhLjUuNSAwIDAgMS0uNS0uNU02LjUgOS41QS41LjUgMCAwIDEgNyA5aDZhLjUuNSAwIDAgMSAwIDFIN2EuNS41IDAgMCAxLS41LS41IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-ohlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTEzIDExaC0zdi0xaDNWM2gxdjJoNHYxaC00djExaC0xek02IDE3di0yaDN2LTFINlY0SDV2MUgydjFoM3YxMXoiLz48L3N2Zz4=)}.ag-charts-icon-pan-end{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0ibTYuNjQ2IDEzLjgxMy0uMzUzLjM1NC43MDcuNzA3LjM1NC0uMzU0ek0xMS4xNjYgMTBsLjM1NC4zNTQuMzU0LS4zNTQtLjM1NC0uMzU0ek03LjM1NSA1LjQ4IDcgNS4xMjZsLS43MDcuNzA3LjM1My4zNTR6bTAgOS4wNCA0LjE2Ni00LjE2Ni0uNzA3LS43MDgtNC4xNjcgNC4xNjd6bTQuMTY2LTQuODc0TDcuMzU0IDUuNDhsLS43MDguNzA3IDQuMTY3IDQuMTY3ek0xMy4wODMgNXYxMGgxVjV6Ii8+PC9zdmc+)}.ag-charts-icon-pan-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuNzkgNS44MzMgOC42MjUgMTBsNC4xNjYgNC4xNjctLjcwNy43MDdMNy4yMSAxMGw0Ljg3My00Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy4yMSAxNC4xNjcgMTEuMzc2IDEwIDcuMjEgNS44MzNsLjcwNy0uNzA3TDEyLjc5IDEwbC00Ljg3MyA0Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-start{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgNXYxMGgxVjV6TTkuNjI0IDEwbDQuMTY2LTQuMTY3LS43MDctLjcwN0w4LjIxIDEwbDQuODc0IDQuODc0LjcwNy0uNzA3eiIvPjwvc3ZnPg==)}.ag-charts-icon-parallel-channel,.ag-charts-icon-parallel-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTcuNzIgNS4zMzFBMi4yNSAyLjI1IDAgMSAwIDE0LjcwNSAzLjZsLTkuNDkgNC41NjJhMi4yNSAyLjI1IDAgMSAwIC4yMDkgMS4wMWw5LjY2Mi00LjY0NmEyLjI1IDIuMjUgMCAwIDAgMi42MzQuODA1bS4zNzMtMi41NDdhMS4yNSAxLjI1IDAgMSAxLTIuMzM4Ljg4NSAxLjI1IDEuMjUgMCAwIDEgMi4zMzgtLjg4NU00LjM0MyA4LjY3YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODVNNS4zMDcgMTYuNzI4YTIuMjUgMi4yNSAwIDEgMS0uNTI1LS44NThsOS45MjMtNC43N2EyLjI1IDIuMjUgMCAxIDEgLjM4MS45MjZ6bS0uOTY0LjI3NGExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjAyMy01LjEwNmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-position-bottom{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4yNSIgZD0iTTMgMTBoMTR2MUgzem0zLTNoOHYxSDZ6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgMTNoOHYxSDZ6Ii8+PC9zdmc+)}.ag-charts-icon-position-center{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMyAxMGgxNHYxSDN6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMjUiIGQ9Ik02IDdoOHYxSDZ6bTAgNmg4djFINnoiLz48L3N2Zz4=)}.ag-charts-icon-position-top{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4yNSIgZD0iTTMgMTBoMTR2MUgzeiIvPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik02IDdoOHYxSDZ6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMjUiIGQ9Ik02IDEzaDh2MUg2eiIvPjwvc3ZnPg==)}.ag-charts-icon-price-label-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNC41IDNBMS41IDEuNSAwIDAgMCAzIDQuNVYxM2ExLjUgMS41IDAgMCAwIDEuNSAxLjVoLjgzM3YuMDU3Yy4yNDItLjI5OS41OTctLjUwMyAxLS41NDhWMTMuNUg0LjVBLjUuNSAwIDAgMSA0IDEzVjQuNWEuNS41IDAgMCAxIC41LS41aDExYS41LjUgMCAwIDEgLjUuNXY4YS41LjUgMCAwIDEtLjUuNWgtNC44MThsLS4xMjYuMDg0YTI2IDI2IDAgMCAwLTIuMjI1IDEuNjg1bC0uMzIuMjY1LS4wNjguMDU2YTEuNSAxLjUgMCAwIDEtMi42MDkgMS4zNTRjLjAzMy43NjMuOTA1IDEuMjM4IDEuNTYuNzU2LjY0Ni0uNDc0IDEuMjEtLjk0MyAxLjc2MS0xLjRsLjMxMy0uMjZBMjYgMjYgMCAwIDEgMTAuOTg2IDE0SDE1LjVhMS41IDEuNSAwIDAgMCAxLjUtMS41di04QTEuNSAxLjUgMCAwIDAgMTUuNSAzeiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43MTYgMTQuODE1YTIuMjUgMi4yNSAwIDEgMS00LjIxIDEuNTkzIDIuMjUgMi4yNSAwIDAgMSA0LjIxLTEuNTkzbS0xLjY2MiAxLjk2NmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-price-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNOS4wNDYgMTVWNS44NzdoLjk0MlYxNXoiIGZpbGw9IiMxODFEMUYiLz48cGF0aCBkPSJNOS4wNDYgMTVWNS44NzdoLjk0MlYxNXoiIGZpbGw9IiMxODFEMUYiLz48cGF0aCBkPSJNOS41IDYuMjI4IDcuMTY3IDguMzc2IDYuNSA3Ljc2MiA5LjUgNWwzIDIuNzYyLS42NjcuNjE0eiIgZmlsbD0iIzAwMCIvPjxwYXRoIGQ9Ik0yIDE4di0xaDE2djF6TTIgM1YyaDE2djF6IiBmaWxsPSIjMTgxRDFGIi8+PC9zdmc+)}.ag-charts-icon-reset{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuMDQgNC40NDVhNS44MSA1LjgxIDAgMCAwLTcuMjU3IDIuNDUzLjUuNSAwIDAgMS0uODY1LS41MDJBNi44MSA2LjgxIDAgMSAxIDMgOS44MTNhLjUuNSAwIDAgMSAxIDAgNS44MSA1LjgxIDAgMSAwIDguMDQtNS4zNjgiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTQuMjg5IDMuMDAyYS41LjUgMCAwIDEgLjUuNXYyLjY1NWgyLjY1NWEuNS41IDAgMCAxIDAgMUg0LjI5YS41LjUgMCAwIDEtLjUtLjVWMy41MDJhLjUuNSAwIDAgMSAuNS0uNSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-settings{--icon: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkIj48cGF0aCBkPSJNMTAgMTNhMyAzIDAgMSAwIDAtNiAzIDMgMCAwIDAgMCA2bTAtMWEyIDIgMCAxIDEtLjAwMS0zLjk5OUEyIDIgMCAwIDEgMTAgMTIiLz48cGF0aCBkPSJNMi4zMSAxNC4zNDVjLS44MTctMS40OTEuMDI3LTIuNDk5LjQ3NC0yLjg2NS41MzEtLjQzNC45NjktLjM2NS45NzItMS40OC0uMDAzLTEuMTE1LS40NDEtMS4wNDYtLjk3Mi0xLjQ4MS0uNDU0LS4zNzEtMS4zMTctMS40MDUtLjQzNC0yLjkzNmwuMDA1LS4wMDljLjg4NC0xLjUyIDIuMjA3LTEuMjkgMi43NTUtMS4wODMuNjQxLjI0My44MDEuNjU2IDEuNzY4LjEwMS45NjQtLjU2LjY4Ni0uOTA0Ljc5Ni0xLjU4Mi4wOTQtLjU3OC41NTktMS44NDMgMi4zMjYtMS44NDNoLjAxYzEuNzU5LjAwNSAyLjIyMiAxLjI2NiAyLjMxNiAxLjg0My4xMS42NzgtLjE2OCAxLjAyMi43OTYgMS41ODIuOTY3LjU1NSAxLjEyNy4xNDIgMS43NjgtLjEwMS41NDktLjIwOCAxLjg3Ni0uNDM4IDIuNzYgMS4wOTJzLjAyIDIuNTY1LS40MzQgMi45MzZjLS41MzEuNDM1LS45NjkuMzY2LS45NzIgMS40ODEuMDAzIDEuMTE1LjQ0MSAxLjA0Ni45NzIgMS40OC40NTQuMzcyIDEuMzE3IDEuNDA2LjQzNCAyLjkzN2wtLjAwNS4wMDljLS44ODQgMS41Mi0yLjIwNyAxLjI5LTIuNzU1IDEuMDgzLS42NDEtLjI0My0uODAxLS42NTYtMS43NjgtLjEwMS0uOTY0LjU2LS42ODYuOTA0LS43OTYgMS41ODEtLjA5NC41NzktLjU1OSAxLjg0NC0yLjMyNiAxLjg0NGgtLjAxYy0xLjc1OS0uMDA1LTIuMjIyLTEuMjY2LTIuMzE2LTEuODQ0LS4xMS0uNjc3LjE2OC0xLjAyMS0uNzk2LTEuNTgxLS45NjctLjU1NS0xLjEyNy0uMTQyLTEuNzY4LjEwMS0uNTQ5LjIwOC0xLjg3Ni40MzgtMi43Ni0xLjA5MmwtLjAyLS4wMzZ6TTkuOTg0IDIuMTYySDEwYzEuMzU1IDAgMS4zNDIgMS4wMzkgMS4zNTMgMS40MjUuMDA4LjMxMi4wNCAxLjE2IDEuMjU5IDEuODcybC4wMTUuMDA4YzEuMjI1LjcgMS45NzYuMzA0IDIuMjUxLjE1NS4zMzctLjE4MyAxLjIyNi0uNzExIDEuOTAyLjQ0NWwuMDA4LjAxNGMuNjc4IDEuMTczLS4yMjkgMS42ODItLjU1OCAxLjg4NC0uMjY2LjE2My0uOTg0LjYxNS0uOTkxIDIuMDI3di4wMTZjLjAwNyAxLjQxMi43MjUgMS44NjQuOTkxIDIuMDI3LjMyOC4yMDEgMS4yMjkuNzA3LjU2NiAxLjg3bC0uMDA4LjAxNGMtLjY3NyAxLjE3NC0xLjU3MS42NDMtMS45MS40NTktLjI3NS0uMTQ5LTEuMDI2LS41NDUtMi4yNTEuMTU0bC0uMDE1LjAwOWMtMS4yMTkuNzEyLTEuMjUxIDEuNTYtMS4yNTkgMS44NzItLjAxMS4zODYuMDAyIDEuNDI1LTEuMzUzIDEuNDI1cy0xLjM0Mi0xLjAzOS0xLjM1My0xLjQyNWMtLjAwOC0uMzEyLS4wNC0xLjE2LTEuMjU5LTEuODcybC0uMDE1LS4wMDljLTEuMjI1LS42OTktMS45NzYtLjMwMy0yLjI1MS0uMTU0LS4zMzYuMTgzLTEuMjE5LjcwNi0xLjg5NC0uNDMybC0uMDE2LS4wMjdjLS42NzgtMS4xNzQuMjI5LTEuNjgyLjU1OC0xLjg4NC4yNjYtLjE2My45ODQtLjYxNS45OTEtMi4wMjd2LS4wMTZjLS4wMDctMS40MTItLjcyNS0xLjg2NC0uOTkxLTIuMDI3LS4zMjgtLjIwMS0xLjIyOS0uNzA3LS41NjYtMS44N2wuMDA4LS4wMTRjLjY3Ny0xLjE3NCAxLjU3MS0uNjQzIDEuOTEtLjQ1OS4yNzUuMTQ5IDEuMDI2LjU0NSAyLjI1MS0uMTU1bC4wMTUtLjAwOGMxLjIxOS0uNzEyIDEuMjUxLTEuNTYgMS4yNTktMS44NzIuMDEtLjM4NC0uMDAyLTEuNDE3IDEuMzM3LTEuNDI1Ii8+PC9zdmc+)}.ag-charts-icon-step-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzE4MUQxRiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNiA0aDV2OGgzVjhoNXYxaC00djRoLTVWNUg3djEwSDJ2LTFoNHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-text-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00IDRIMTZWN0gxNVY1SDEwLjVWMTVIMTRWMTZINlYxNUg5LjVWNUg1VjdINFY0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-trend-line,.ag-charts-icon-trend-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS4zMTQgMTAuOTM4YTIuMjUgMi4yNSAwIDEgMSAuMDEtMWg5LjM1MmEyLjI1IDIuMjUgMCAxIDEgLjAxIDF6bS0yLjE4OS43MjlhMS4yNSAxLjI1IDAgMSAwIDAtMi41IDEuMjUgMS4yNSAwIDAgMCAwIDIuNW0xMy43NSAwYTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock,.ag-charts-icon-unlocked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNjUxIDMuNWEyLjg5NCAyLjg5NCAwIDAgMC0yLjg5NCAyLjg5NFY5SDE0LjVhMi41IDIuNSAwIDAgMSAyLjUgMi41djNhMi41IDIuNSAwIDAgMS0yLjUgMi41aC04QTIuNSAyLjUgMCAwIDEgNCAxNC41di0zQTIuNSAyLjUgMCAwIDEgNi41IDloLjI1N1Y2LjM5NGEzLjg5NCAzLjg5NCAwIDEgMSA3Ljc4OSAwIC41LjUgMCAwIDEtMSAwQTIuODk0IDIuODk0IDAgMCAwIDEwLjY1IDMuNU02LjUgMTBBMS41IDEuNSAwIDAgMCA1IDExLjV2M0ExLjUgMS41IDAgMCAwIDYuNSAxNmg4YTEuNSAxLjUgMCAwIDAgMS41LTEuNXYtM2ExLjUgMS41IDAgMCAwLTEuNS0xLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-vertical-line,.ag-charts-icon-vertical-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNSA3LjgwNmEyLjI1IDIuMjUgMCAwIDEgMCA0LjM4OFYxOS41aC0xdi03LjMwNmEyLjI1IDIuMjUgMCAwIDEgMC00LjM4OFYuNWgxem0tLjUuOTQ0YTEuMjUgMS4yNSAwIDEgMSAwIDIuNSAxLjI1IDEuMjUgMCAwIDEgMC0yLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-zoom-in{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS41IDEwYS41LjUgMCAwIDEgLjUtLjVoOGEuNS41IDAgMCAxIDAgMUg2YS41LjUgMCAwIDEtLjUtLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-high-low-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyA0aDJ2MTJINFY0aDNNNSA1aDN2MTBINXpNMTEgMTRWNmg1djhoLTVtMS03aDN2NmgtM3oiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-hlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTYzIDEuODM3LTUuMzM0IDExLjYyMUw2Ljk1NyA4LjEybC00LjE5OSA5LjYyMi0uOTE2LS40IDQuNzU2LTEwLjlMMTIuNDkgMTEuOCAxNy4yNTQgMS40MnoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTUuODI1IDIuNzA0LjU1IDEzLjc4NWwuOTAyLjQzIDQuNzI0LTkuOTE5IDYuMDM0IDUuMDI5IDMuMjU1LTguMTQtLjkyOC0uMzctMi43NDUgNi44NnptNy44NTIgMTQuNjM2IDUuNzgtMTMuMTM5LS45MTUtLjQwMi01LjIxOSAxMS44Ni02LjAwNS01LjUwNC0zLjI3OCA3LjY0OC45Mi4zOTQgMi43MjItNi4zNTJ6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-alt{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20taW4iPjxjaXJjbGUgY3g9IjExIiBjeT0iMTEiIHI9IjgiLz48bGluZSB4MT0iMjEiIHgyPSIxNi42NSIgeTE9IjIxIiB5Mj0iMTYuNjUiLz48bGluZSB4MT0iMTEiIHgyPSIxMSIgeTE9IjgiIHkyPSIxNCIvPjxsaW5lIHgxPSI4IiB4Mj0iMTQiIHkxPSIxMSIgeTI9IjExIi8+PC9zdmc+)}.ag-charts-icon-zoom-out-alt{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20tb3V0Ij48Y2lyY2xlIGN4PSIxMSIgY3k9IjExIiByPSI4Ii8+PGxpbmUgeDE9IjIxIiB4Mj0iMTYuNjUiIHkxPSIyMSIgeTI9IjE2LjY1Ii8+PGxpbmUgeDE9IjgiIHgyPSIxNCIgeTE9IjExIiB5Mj0iMTEiLz48L3N2Zz4=)}.ag-charts-input{--input-layer-active: 1;--input-layer-focus: 2;--input-padding: calc(var(--ag-charts-spacing) * 2);--input-padding-large: calc(var(--ag-charts-spacing) * 2.5);color:var(--ag-charts-input-text-color);font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size-large);transition-duration:.25s;transition-property:none;transition-timing-function:ease-out}.ag-charts-input:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:var(--input-layer-focus)}.ag-charts-button{background:var(--ag-charts-button-background-color);border:1px solid var(--ag-charts-border-color);border-radius:var(--ag-charts-button-border-radius);color:var(--ag-charts-button-text-color);cursor:pointer;padding:var(--input-padding);transition-property:background,border-color}.ag-charts-button:hover{background:var(--ag-charts-focus-color)}.ag-charts-button:has(.ag-charts-icon){padding:2px}.ag-charts-checkbox{--checkbox-transition-duration: .1s;appearance:none;background:var(--ag-charts-checkbox-background-color);border-radius:calc(var(--ag-charts-border-radius) * 9);cursor:pointer;height:18px;margin:0;transition-duration:var(--checkbox-transition-duration);transition-property:margin;width:29px}.ag-charts-checkbox:before{display:block;background:var(--ag-charts-input-background-color);border-radius:calc(var(--ag-charts-border-radius) * 7);content:\" \";height:14px;margin:2px;transition-duration:var(--checkbox-transition-duration);transition-property:margin;transition-timing-function:var(--ag-charts-input-transition-easing);width:14px}.ag-charts-checkbox:checked{background:var(--ag-charts-checkbox-checked-background-color)}.ag-charts-checkbox:checked:before{margin-left:13px}.ag-charts-select{background:var(--ag-charts-input-background-color);border:1px solid var(--ag-charts-input-border-color);border-radius:var(--ag-charts-input-border-radius);padding:3px 2px 4px;font-size:inherit}.ag-charts-textarea{--textarea-line-height: 1.38;background:var(--ag-charts-input-background-color);border:1px solid var(--ag-charts-border-color);border-radius:var(--ag-charts-input-border-radius);line-height:var(--textarea-line-height);font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size-large);padding:var(--input-padding-large) var(--input-padding)}.ag-charts-textarea::placeholder{color:var(--ag-charts-input-placeholder-text-color)}.ag-charts-proxy-container{pointer-events:none;position:absolute}.ag-charts-proxy-elem{-webkit-appearance:none;appearance:none;background:none;border:none;color:#0000;overflow:hidden;pointer-events:auto;position:absolute}.ag-charts-proxy-elem::-moz-range-thumb,.ag-charts-proxy-elem::-moz-range-track{opacity:0}.ag-charts-proxy-elem::-webkit-slider-runnable-track,.ag-charts-proxy-elem::-webkit-slider-thumb{opacity:0}.ag-charts-proxy-elem:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-focus-indicator{position:absolute;display:block;pointer-events:none;user-select:none;-webkit-user-select:none;width:100%;height:100%}.ag-charts-focus-indicator>div{position:absolute;outline:solid 1px var(--ag-charts-chrome-background-color);box-shadow:var(--ag-charts-focus-shadow)}.ag-charts-focus-indicator>svg{width:100%;height:100%;fill:none;overflow:visible}.ag-charts-focus-svg-outer-path{stroke:var(--ag-charts-chrome-background-color);stroke-width:4px}.ag-charts-focus-svg-inner-path{stroke:var(--ag-charts-accent-color);stroke-width:2px}.ag-charts-overlay{color:#181d1f;pointer-events:none}.ag-charts-overlay.ag-charts-dark-overlay{color:#fff}.ag-charts-overlay--loading{color:#8c8c8c}.ag-charts-overlay__loading-background{background:#fff;pointer-events:none}.ag-charts-overlay.ag-charts-dark-overlay .ag-charts-overlay__loading-background{background:#192232}.ag-charts-tooltip{--tooltip-arrow-size: 8px;position:fixed;inset:unset;margin:0;padding:0;overflow:visible;width:max-content;max-width:100%;font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size);font-weight:var(--ag-charts-chrome-font-weight);color:var(--ag-charts-chrome-text-color);background:var(--ag-charts-chrome-background-color);border:var(--ag-charts-border);border-radius:var(--ag-charts-border-radius);box-shadow:var(--ag-charts-shadow)}.ag-charts-tooltip--compact .ag-charts-tooltip-content{padding:3px 6px}.ag-charts-tooltip--arrow:before{content:\"\";position:absolute;top:100%;left:50%;margin:0 auto;transform:translate(-50%) translateY(calc(var(--tooltip-arrow-size) * -.5)) rotate(45deg);display:block;width:var(--tooltip-arrow-size);height:var(--tooltip-arrow-size);border:inherit;border-top:none;border-left:none;clip-path:polygon(0% 100%,100% 0%,100% 100%)}.ag-charts-tooltip--arrow:after{--tooltip-inner-size: calc(var(--tooltip-arrow-size) - 2px);content:\"\";position:absolute;top:100%;left:50%;margin:0 auto;transform:translate(-50%) translateY(calc(var(--tooltip-inner-size) * -.5)) rotate(45deg);display:block;width:var(--tooltip-inner-size);height:var(--tooltip-inner-size);border:inherit;border-color:transparent;background:inherit;clip-path:polygon(-10% 100%,100% -10%,100% 100%)}.ag-charts-tooltip--no-interaction{pointer-events:none;user-select:none;-webkit-user-select:none}.ag-charts-tooltip--wrap-always{overflow-wrap:break-word;word-break:break-word;hyphens:none}.ag-charts-tooltip--wrap-hyphenate{overflow-wrap:break-word;word-break:break-word;hyphens:auto}.ag-charts-tooltip--wrap-on-space{overflow-wrap:normal;word-break:normal}.ag-charts-tooltip--wrap-never{white-space:nowrap}.ag-charts-tooltip-heading,.ag-charts-tooltip-title,.ag-charts-tooltip-label,.ag-charts-tooltip-value{overflow:hidden;text-overflow:ellipsis}.ag-charts-tooltip-content{display:grid;grid:auto-flow minmax(1em,auto) / 1fr;padding:8px 12px;gap:8px}.ag-charts-tooltip-content:has(.ag-charts-tooltip-symbol){grid:auto-flow minmax(1em,auto) / auto 1fr}.ag-charts-tooltip-heading{grid-column:1 / -1}.ag-charts-tooltip-symbol{grid-column:1 / 2;align-self:center}.ag-charts-tooltip-symbol svg{display:block}.ag-charts-tooltip-title{grid-column:-2 / -1}.ag-charts-tooltip-row{grid-column:1 / -1;display:flex;gap:16px;align-items:baseline;justify-content:space-between;overflow:hidden}.ag-charts-tooltip-row--inline{grid-column:-2 / -1}.ag-charts-tooltip-label{flex:1;min-width:0}.ag-charts-tooltip-value{min-width:0}.ag-charts-popover{position:absolute;border:var(--ag-charts-border);border-radius:var(--ag-charts-border-radius);background:var(--ag-charts-chrome-background-color);color:var(--ag-charts-chrome-text-color);font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size);font-weight:var(--ag-charts-chrome-font-weight);box-shadow:var(--ag-charts-shadow);z-index:var(--ag-charts-layer-ui-overlay)}.ag-charts-menu{--item-padding: 6px 12px;--icon-color: var(--ag-charts-chrome-text-color);display:grid;grid:auto-flow auto / 1fr;column-gap:12px;font-size:var(--ag-charts-chrome-font-size)}.ag-charts-menu:has(.ag-charts-menu__icon,.ag-charts-menu__row--stroke-width-visible){grid:auto-flow auto / auto 1fr}.ag-charts-menu__row--stroke-width-visible:before{content:\"\";height:var(--strokeWidth);width:12px;background:var(--icon-color)}.ag-charts-menu__row--stroke-width-visible[aria-disabled=true]:before{filter:grayscale(1);opacity:.5}.ag-charts-menu__row{display:grid;grid-column:1 / -1;grid-template-columns:subgrid;align-items:center;padding:var(--item-padding)}.ag-charts-menu__row:not(.ag-charts-menu__row--active){cursor:pointer}.ag-charts-menu__row:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.ag-charts-menu__row:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.ag-charts-menu__row:focus{background:var(--ag-charts-focus-color)}.ag-charts-menu__row:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:var(--ag-charts-layer-menu)}.ag-charts-menu__row--active{--icon-color: var(--ag-charts-accent-color);background:var(--ag-charts-focus-color);color:var(--ag-charts-accent-color)}.ag-charts-menu__label{grid-column:-1 / span 1}.ag-charts-toolbar{--toolbar-gap: calc(var(--ag-charts-spacing) * 2);--toolbar-size: 34px;--toolbar-button-padding: 6px;align-items:center;display:flex;flex-wrap:nowrap;position:absolute}.ag-charts-toolbar__button{align-items:center;background:var(--ag-charts-chrome-background-color);border:var(--ag-charts-border);color:var(--ag-charts-chrome-text-color);cursor:pointer;display:flex;font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size-medium);font-weight:var(--ag-charts-chrome-font-weight);justify-content:center;min-height:var(--toolbar-size);min-width:var(--toolbar-size);padding:var(--toolbar-button-padding);position:relative;transition:background-color .25s ease-in-out,border-color .25s ease-in-out,color .25s ease-in-out;white-space:nowrap}.ag-charts-toolbar__button:hover{background:var(--ag-charts-focus-color);z-index:1}.ag-charts-toolbar__button:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:calc(var(--ag-charts-layer-ui-overlay) + 1)}.ag-charts-toolbar__button--active{background:var(--ag-charts-focus-color);border-color:var(--ag-charts-accent-color);color:var(--ag-charts-accent-color);z-index:2}.ag-charts-toolbar__button[aria-disabled=true]{background:var(--ag-charts-button-disabled-background-color);color:var(--ag-charts-button-disabled-text-color);cursor:default}.ag-charts-toolbar--horizontal{flex-direction:row;.ag-charts-toolbar__button{margin:0 0 0 -1px}.ag-charts-toolbar__button--first{border-bottom-left-radius:var(--ag-charts-border-radius);border-top-left-radius:var(--ag-charts-border-radius);margin:0}.ag-charts-toolbar__button--last{border-bottom-right-radius:var(--ag-charts-border-radius);border-top-right-radius:var(--ag-charts-border-radius)}}.ag-charts-toolbar--vertical{flex-direction:column;.ag-charts-toolbar__button{margin:-1px 0 0;max-width:100%}.ag-charts-toolbar__button--first{border-top-left-radius:var(--ag-charts-border-radius);border-top-right-radius:var(--ag-charts-border-radius);margin:0}.ag-charts-toolbar__button--last{border-bottom-left-radius:var(--ag-charts-border-radius);border-bottom-right-radius:var(--ag-charts-border-radius)}}.ag-charts-toolbar__icon+.ag-charts-toolbar__label{margin-left:var(--toolbar-gap)}.ag-charts-toolbar__icon,.ag-charts-toolbar__label{pointer-events:none}.ag-charts-floating-toolbar{border:none;display:flex;.ag-charts-toolbar{align-items:unset;position:unset}}.ag-charts-floating-toolbar__drag-handle{align-items:center;background:var(--ag-charts-chrome-background-color);border:var(--ag-charts-border);border-bottom-left-radius:var(--ag-charts-border-radius);border-top-left-radius:var(--ag-charts-border-radius);cursor:grab;display:flex;justify-content:center;min-width:24px;padding-left:0;padding-right:0}.ag-charts-floating-toolbar__drag-handle--dragging{cursor:grabbing}\\n';\n\n// packages/ag-charts-community/src/util/listeners.ts\nvar Listeners = class {\n  constructor() {\n    this.registeredListeners = /* @__PURE__ */ new Map();\n  }\n  addListener(eventType, handler) {\n    const record = { symbol: Symbol(eventType), handler };\n    if (this.registeredListeners.has(eventType)) {\n      this.registeredListeners.get(eventType).push(record);\n    } else {\n      this.registeredListeners.set(eventType, [record]);\n    }\n    return () => this.removeListener(record.symbol);\n  }\n  removeListener(eventSymbol) {\n    for (const [type, listeners] of this.registeredListeners.entries()) {\n      const matchIndex = listeners.findIndex((listener) => listener.symbol === eventSymbol);\n      if (matchIndex >= 0) {\n        listeners.splice(matchIndex, 1);\n        if (listeners.length === 0) {\n          this.registeredListeners.delete(type);\n        }\n        break;\n      }\n    }\n  }\n  dispatch(eventType, ...params) {\n    for (const listener of this.getListenersByType(eventType)) {\n      try {\n        listener.handler(...params);\n      } catch (e) {\n        logger_exports.errorOnce(String(e));\n      }\n    }\n  }\n  getListenersByType(eventType) {\n    return this.registeredListeners.get(eventType) ?? [];\n  }\n  destroy() {\n    this.registeredListeners.clear();\n  }\n};\n\n// packages/ag-charts-community/src/util/baseManager.ts\nvar BaseManager = class {\n  constructor() {\n    this.listeners = new Listeners();\n    this.destroyFns = [];\n  }\n  addListener(type, handler) {\n    return this.listeners.addListener(type, handler);\n  }\n  destroy() {\n    this.listeners.destroy();\n    this.destroyFns.forEach((fn) => fn());\n  }\n};\n\n// packages/ag-charts-community/src/util/guardedElement.ts\nvar GuardedElement = class _GuardedElement {\n  constructor(element2, topTabGuard, bottomTabGuard) {\n    this.element = element2;\n    this.topTabGuard = topTabGuard;\n    this.bottomTabGuard = bottomTabGuard;\n    this.destroyFns = [];\n    this.guardTabIndex = 0;\n    this.hasFocus = false;\n    this.initTabGuard(this.topTabGuard, (el) => this.onTab(el, false));\n    this.initTabGuard(this.bottomTabGuard, (el) => this.onTab(el, true));\n    this.element.addEventListener(\"focus\", () => this.onFocus(), { capture: true });\n    this.element.addEventListener(\"blur\", (ev) => this.onBlur(ev), { capture: true });\n  }\n  set tabIndex(index) {\n    this.guardTabIndex = index;\n    if (this.guardTabIndex === 0) {\n      this.setGuardIndices(void 0);\n    } else if (!this.hasFocus) {\n      this.setGuardIndices(this.guardTabIndex);\n    }\n  }\n  destroy() {\n    for (const fn of this.destroyFns)\n      fn();\n    this.destroyFns.length = 0;\n  }\n  initTabGuard(guard, handler) {\n    const handlerBinding = () => handler(guard);\n    guard.addEventListener(\"focus\", handlerBinding);\n    this.destroyFns.push(() => guard.removeEventListener(\"focus\", handlerBinding));\n  }\n  setGuardIndices(index) {\n    const tabindex = index;\n    setAttribute(this.topTabGuard, \"tabindex\", tabindex);\n    setAttribute(this.bottomTabGuard, \"tabindex\", tabindex);\n  }\n  onFocus() {\n    this.hasFocus = true;\n    if (this.guardTabIndex !== 0) {\n      this.setGuardIndices(0);\n    }\n  }\n  onBlur({ relatedTarget }) {\n    const { topTabGuard: top, bottomTabGuard: bot } = this;\n    this.hasFocus = false;\n    if (this.guardTabIndex !== 0 && relatedTarget !== top && relatedTarget !== bot) {\n      this.setGuardIndices(this.guardTabIndex);\n    }\n  }\n  onTab(guard, reverse) {\n    if (this.guardTabIndex !== 0) {\n      let focusTarget;\n      if (guard.tabIndex === 0) {\n        focusTarget = this.findExitTarget(!reverse);\n        this.setGuardIndices(this.guardTabIndex);\n      } else {\n        focusTarget = this.findEnterTarget(reverse);\n      }\n      focusTarget?.focus();\n    }\n  }\n  static queryFocusable(element2, selectors) {\n    const myWindow = getWindow();\n    return Array.from(element2.querySelectorAll(selectors)).filter((e) => {\n      if (e instanceof HTMLElement) {\n        const style = myWindow.getComputedStyle(e);\n        return style.display !== \"none\" && style.visibility !== \"none\";\n      }\n      return false;\n    });\n  }\n  findEnterTarget(reverse) {\n    const focusables = _GuardedElement.queryFocusable(this.element, '[tabindex=\"0\"]');\n    const index = reverse ? focusables.length - 1 : 0;\n    return focusables[index];\n  }\n  findExitTarget(reverse) {\n    const focusables = _GuardedElement.queryFocusable(getDocument(), \"[tabindex]\").filter((e) => e.tabIndex > 0).sort((a, b) => a.tabIndex - b.tabIndex);\n    const { before, after } = _GuardedElement.findBeforeAndAfter(focusables, this.guardTabIndex);\n    return reverse ? before : after;\n  }\n  static findBeforeAndAfter(elements, targetTabIndex) {\n    let left = 0;\n    let right = elements.length - 1;\n    let before = void 0;\n    let after = void 0;\n    while (left <= right) {\n      const mid = Math.floor((left + right) / 2);\n      const currentTabIndex = elements[mid].tabIndex;\n      if (currentTabIndex === targetTabIndex) {\n        before = elements[mid - 1] || void 0;\n        after = elements[mid + 1] || void 0;\n        break;\n      } else if (currentTabIndex < targetTabIndex) {\n        before = elements[mid];\n        left = mid + 1;\n      } else {\n        after = elements[mid];\n        right = mid - 1;\n      }\n    }\n    return { before, after };\n  }\n};\n\n// packages/ag-charts-community/src/util/keynavUtil.ts\nfunction addRemovableEventListener(destroyFns, elem, type, listener, options) {\n  elem.addEventListener(type, listener);\n  const remover = () => elem.removeEventListener(type, listener, options);\n  destroyFns.push(remover);\n  return remover;\n}\nfunction addEscapeEventListener(destroyFns, elem, onEscape) {\n  addRemovableEventListener(destroyFns, elem, \"keydown\", (event) => {\n    if (event.key === \"Escape\") {\n      onEscape(event);\n    }\n  });\n}\nfunction addMouseCloseListener(destroyFns, menu, hideCallback) {\n  const self = addRemovableEventListener(destroyFns, window, \"mousedown\", (event) => {\n    if ([0, 2].includes(event.button) && !containsPoint2(menu, event)) {\n      hideCallback();\n      self();\n    }\n  });\n  return self;\n}\nfunction addTouchCloseListener(destroyFns, menu, hideCallback) {\n  const self = addRemovableEventListener(destroyFns, window, \"touchstart\", (event) => {\n    const touches = Array.from(event.targetTouches);\n    if (touches.some((touch) => !containsPoint2(menu, touch))) {\n      hideCallback();\n      self();\n    }\n  });\n  return self;\n}\nfunction containsPoint2(container, event) {\n  if (event.target instanceof Element) {\n    const { x, y, width: width2, height: height2 } = container.getBoundingClientRect();\n    const { clientX: ex, clientY: ey } = event;\n    return ex >= x && ey >= y && ex <= x + width2 && ey <= y + height2;\n  }\n  return false;\n}\nfunction hasNoModifiers(event) {\n  return !(event.shiftKey || event.altKey || event.ctrlKey || event.metaKey);\n}\nfunction matchesKey(event, key, ...morekeys) {\n  return hasNoModifiers(event) && (event.key === key || morekeys.some((altkey) => event.key === altkey));\n}\nfunction linkTwoButtons(destroyFns, src, dst, key) {\n  if (!dst)\n    return;\n  addRemovableEventListener(destroyFns, src, \"keydown\", (event) => {\n    if (matchesKey(event, key)) {\n      dst.focus();\n    }\n  });\n}\nfunction linkThreeButtons(destroyFns, curr, next, nextKey, prev, prevKey) {\n  linkTwoButtons(destroyFns, curr, prev, prevKey);\n  linkTwoButtons(destroyFns, curr, next, nextKey);\n  addRemovableEventListener(destroyFns, curr, \"keydown\", (event) => {\n    if (matchesKey(event, nextKey, prevKey)) {\n      event.preventDefault();\n    }\n  });\n}\nvar PREV_NEXT_KEYS = {\n  horizontal: { nextKey: \"ArrowRight\", prevKey: \"ArrowLeft\" },\n  vertical: { nextKey: \"ArrowDown\", prevKey: \"ArrowUp\" }\n};\nfunction initRovingTabIndex(opts) {\n  const { orientation, buttons, wrapAround = false, onEscape, onFocus, onBlur } = opts;\n  const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];\n  const setTabIndices = (event) => {\n    if (event.target && \"tabIndex\" in event.target) {\n      buttons.forEach((b) => b.tabIndex = -1);\n      event.target.tabIndex = 0;\n    }\n  };\n  const [c, m] = wrapAround ? [buttons.length, buttons.length] : [0, Infinity];\n  const destroyFns = [];\n  for (let i = 0; i < buttons.length; i++) {\n    const prev = buttons[(c + i - 1) % m];\n    const curr = buttons[i];\n    const next = buttons[(c + i + 1) % m];\n    addRemovableEventListener(destroyFns, curr, \"focus\", setTabIndices);\n    if (onFocus)\n      addRemovableEventListener(destroyFns, curr, \"focus\", onFocus);\n    if (onBlur)\n      addRemovableEventListener(destroyFns, curr, \"blur\", onBlur);\n    if (onEscape)\n      addEscapeEventListener(destroyFns, curr, onEscape);\n    linkThreeButtons(destroyFns, curr, next, nextKey, prev, prevKey);\n    curr.tabIndex = i === 0 ? 0 : -1;\n  }\n  return destroyFns;\n}\nvar MenuCloserImp = class {\n  constructor(menu, lastFocus, closeCallback) {\n    this.lastFocus = lastFocus;\n    this.closeCallback = closeCallback;\n    this.destroyFns = [];\n    this.destroyFns.push(addMouseCloseListener(this.destroyFns, menu, () => this.close(true)));\n    this.destroyFns.push(addTouchCloseListener(this.destroyFns, menu, () => this.close(true)));\n  }\n  close(mousedown) {\n    this.destroyFns.forEach((d) => d());\n    this.destroyFns.length = 0;\n    this.closeCallback();\n    this.finishClosing(mousedown);\n  }\n  finishClosing(mousedown) {\n    this.destroyFns.forEach((d) => d());\n    this.destroyFns.length = 0;\n    setAttribute(this.lastFocus, \"aria-expanded\", false);\n    if (!mousedown) {\n      this.lastFocus?.focus({ preventScroll: true });\n    }\n    this.lastFocus = void 0;\n  }\n};\nfunction initMenuKeyNav(opts) {\n  const {\n    sourceEvent,\n    orientation,\n    menu,\n    buttons,\n    closeCallback,\n    overrideFocusVisible,\n    autoCloseOnBlur = false\n  } = opts;\n  const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];\n  const lastFocus = getLastFocus(sourceEvent);\n  setAttribute(lastFocus, \"aria-expanded\", true);\n  const menuCloser = new MenuCloserImp(menu, lastFocus, closeCallback);\n  const onEscape = () => menuCloser.close();\n  const { destroyFns } = menuCloser;\n  menu.role = \"menu\";\n  menu.ariaOrientation = orientation;\n  destroyFns.push(...initRovingTabIndex({ orientation, buttons, onEscape, wrapAround: true }));\n  menu.tabIndex = -1;\n  addEscapeEventListener(destroyFns, menu, onEscape);\n  addRemovableEventListener(destroyFns, menu, \"keydown\", (ev) => {\n    if (ev.target === menu && (ev.key === nextKey || ev.key === prevKey)) {\n      ev.preventDefault();\n      buttons[0]?.focus();\n    }\n  });\n  if (autoCloseOnBlur) {\n    const handler = (ev) => {\n      const buttonArray = buttons;\n      const isLeavingMenu = !buttonArray.includes(ev.relatedTarget);\n      if (isLeavingMenu) {\n        onEscape();\n      }\n    };\n    for (const button of buttons) {\n      addRemovableEventListener(destroyFns, button, \"blur\", handler);\n    }\n  }\n  buttons[0]?.focus({ preventScroll: true });\n  if (overrideFocusVisible !== void 0) {\n    buttons.forEach((b) => b.setAttribute(\"data-focus-visible-override\", overrideFocusVisible.toString()));\n    const keydownTrueOverrider = () => {\n      buttons.forEach((b) => b.setAttribute(\"data-focus-visible-override\", \"true\"));\n    };\n    addRemovableEventListener(destroyFns, menu, \"keydown\", keydownTrueOverrider, { once: true });\n  }\n  return menuCloser;\n}\nfunction makeAccessibleClickListener(element2, onclick) {\n  return (event) => {\n    if (element2.ariaDisabled === \"true\") {\n      return event.preventDefault();\n    }\n    onclick(event);\n  };\n}\nfunction isButtonClickEvent(event) {\n  if (\"button\" in event) {\n    return event.button === 0;\n  }\n  return hasNoModifiers(event) && (event.code === \"Space\" || event.key === \"Enter\");\n}\nfunction getLastFocus(sourceEvent) {\n  if (sourceEvent?.target instanceof HTMLElement && \"tabindex\" in sourceEvent.target.attributes) {\n    return sourceEvent.target;\n  }\n  return void 0;\n}\nfunction stopPageScrolling(element2) {\n  const handler = (event) => {\n    if (event.defaultPrevented)\n      return;\n    const shouldPrevent = getAttribute(event.target, \"data-preventdefault\", true);\n    if (shouldPrevent && matchesKey(event, \"ArrowRight\", \"ArrowLeft\", \"ArrowDown\", \"ArrowUp\")) {\n      event.preventDefault();\n    }\n  };\n  element2.addEventListener(\"keydown\", handler);\n  return () => element2.removeEventListener(\"keydown\", handler);\n}\n\n// packages/ag-charts-community/src/util/pixelRatioObserver.ts\nvar PixelRatioObserver = class {\n  constructor(callback2) {\n    this.callback = callback2;\n    this.devicePixelRatio = getWindow(\"devicePixelRatio\") ?? 1;\n    this.devicePixelRatioMediaQuery = void 0;\n    this.devicePixelRatioListener = (e) => {\n      if (e.matches)\n        return;\n      this.devicePixelRatio = getWindow(\"devicePixelRatio\") ?? 1;\n      this.unregisterDevicePixelRatioListener();\n      this.registerDevicePixelRatioListener();\n      this.callback(this.pixelRatio);\n    };\n  }\n  get pixelRatio() {\n    return this.devicePixelRatio;\n  }\n  observe() {\n    this.registerDevicePixelRatioListener();\n  }\n  disconnect() {\n    this.unregisterDevicePixelRatioListener();\n  }\n  unregisterDevicePixelRatioListener() {\n    this.devicePixelRatioMediaQuery?.removeEventListener(\"change\", this.devicePixelRatioListener);\n    this.devicePixelRatioMediaQuery = void 0;\n  }\n  registerDevicePixelRatioListener() {\n    const devicePixelRatioMediaQuery = getWindow(\"matchMedia\")?.(`(resolution: ${this.pixelRatio}dppx)`);\n    devicePixelRatioMediaQuery?.addEventListener(\"change\", this.devicePixelRatioListener);\n    this.devicePixelRatioMediaQuery = devicePixelRatioMediaQuery;\n  }\n};\n\n// packages/ag-charts-community/src/util/sizeMonitor.ts\nvar SizeMonitor = class {\n  constructor() {\n    this.elements = /* @__PURE__ */ new Map();\n    this.documentReady = false;\n    this.queuedObserveRequests = [];\n    this.onLoad = () => {\n      this.documentReady = true;\n      this.queuedObserveRequests.forEach(([el, cb]) => this.observe(el, cb));\n      this.queuedObserveRequests = [];\n      this.observeWindow();\n    };\n    if (typeof ResizeObserver !== \"undefined\") {\n      this.resizeObserver = new ResizeObserver((entries) => {\n        for (const {\n          target,\n          contentRect: { width: width2, height: height2 }\n        } of entries) {\n          const entry = this.elements.get(target);\n          this.checkSize(entry, target, width2, height2);\n        }\n      });\n    }\n    let animationFrame;\n    this.pixelRatioObserver = new PixelRatioObserver(() => {\n      clearTimeout(animationFrame);\n      animationFrame = setTimeout(() => this.checkPixelRatio(), 0);\n    });\n    this.documentReady = getDocument(\"readyState\") === \"complete\";\n    if (this.documentReady) {\n      this.observeWindow();\n    } else {\n      getWindow()?.addEventListener(\"load\", this.onLoad);\n    }\n  }\n  destroy() {\n    getWindow()?.removeEventListener(\"load\", this.onLoad);\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = void 0;\n    this.pixelRatioObserver?.disconnect();\n    this.pixelRatioObserver = void 0;\n  }\n  observeWindow() {\n    this.pixelRatioObserver?.observe();\n  }\n  checkPixelRatio() {\n    const pixelRatio = this.pixelRatioObserver?.pixelRatio ?? 1;\n    for (const [element2, entry] of this.elements) {\n      if (entry.size != null && entry.size.pixelRatio !== pixelRatio) {\n        const { width: width2, height: height2 } = entry.size;\n        entry.size = { width: width2, height: height2, pixelRatio };\n        entry.cb(entry.size, element2);\n      }\n    }\n  }\n  checkSize(entry, element2, width2, height2) {\n    if (!entry)\n      return;\n    if (width2 !== entry.size?.width || height2 !== entry.size?.height) {\n      const pixelRatio = this.pixelRatioObserver?.pixelRatio ?? 1;\n      entry.size = { width: width2, height: height2, pixelRatio };\n      entry.cb(entry.size, element2);\n    }\n  }\n  // Only a single callback is supported.\n  observe(element2, cb) {\n    if (!this.documentReady) {\n      this.queuedObserveRequests.push([element2, cb]);\n      return;\n    }\n    if (this.elements.has(element2)) {\n      this.removeFromQueue(element2);\n    } else {\n      this.resizeObserver?.observe(element2);\n    }\n    const entry = { cb };\n    this.elements.set(element2, entry);\n  }\n  unobserve(element2) {\n    this.resizeObserver?.unobserve(element2);\n    this.elements.delete(element2);\n    this.removeFromQueue(element2);\n    if (!this.elements.size) {\n      this.destroy();\n    }\n  }\n  removeFromQueue(element2) {\n    this.queuedObserveRequests = this.queuedObserveRequests.filter(([el]) => el !== element2);\n  }\n};\n\n// packages/ag-charts-community/src/util/stateTracker.ts\nvar StateTracker = class extends Map {\n  constructor(defaultValue, defaultState) {\n    super();\n    this.defaultValue = defaultValue;\n    this.defaultState = defaultState;\n  }\n  set(key, value) {\n    this.delete(key);\n    if (typeof value !== \"undefined\") {\n      super.set(key, value);\n    }\n    return this;\n  }\n  stateId() {\n    return Array.from(this.keys()).pop() ?? this.defaultState;\n  }\n  stateValue() {\n    return Array.from(this.values()).pop() ?? this.defaultValue;\n  }\n};\n\n// packages/ag-charts-community/src/dom/domLayout.html\nvar domLayout_default = '<div role=\"presentation\" class=\"ag-charts-wrapper ag-charts-styles\" data-ag-charts><div role=\"presentation\" class=\"ag-charts-canvas-center\"><div role=\"presentation\" class=\"ag-charts-canvas-container\"><div role=\"presentation\" class=\"ag-charts-canvas\" aria-hidden=\"true\"></div><div role=\"figure\" class=\"ag-charts-canvas-proxy\"><div role=\"presentation\" class=\"ag-charts-series-area\"></div></div><div role=\"presentation\" class=\"ag-charts-canvas-overlay\"></div></div></div></div>';\n\n// packages/ag-charts-community/src/dom/domManager.ts\nvar DOM_ELEMENT_CLASSES = [\n  \"styles\",\n  \"canvas\",\n  \"canvas-center\",\n  \"canvas-container\",\n  \"canvas-overlay\",\n  \"canvas-proxy\",\n  \"series-area\"\n];\nvar CONTAINER_MODIFIERS = {\n  safeHorizontal: \"ag-charts-wrapper--safe-horizontal\",\n  safeVertical: \"ag-charts-wrapper--safe-vertical\"\n};\nvar domElementConfig = /* @__PURE__ */ new Map([\n  [\"styles\", { childElementType: \"style\" }],\n  [\"canvas\", { childElementType: \"canvas\" }],\n  [\"canvas-proxy\", { childElementType: \"div\" }],\n  [\"canvas-overlay\", { childElementType: \"div\" }],\n  [\"canvas-center\", { childElementType: \"div\" }],\n  [\"series-area\", { childElementType: \"div\" }]\n]);\nfunction setupObserver(element2, cb) {\n  if (typeof IntersectionObserver === \"undefined\")\n    return;\n  const observer = new IntersectionObserver(\n    (entries) => {\n      for (const entry of entries) {\n        if (entry.target === element2) {\n          cb(entry.intersectionRatio);\n        }\n      }\n    },\n    { root: element2 }\n  );\n  observer.observe(element2);\n  return observer;\n}\nvar NULL_DOMRECT = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0,\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n  toJSON() {\n    return NULL_DOMRECT;\n  }\n};\nfunction createTabGuardElement(guardedElem, where) {\n  const div = createElement(\"div\");\n  div.className = \"ag-charts-tab-guard\";\n  guardedElem.insertAdjacentElement(where, div);\n  return div;\n}\nvar DOMManager = class extends BaseManager {\n  constructor(container, styleContainer) {\n    super();\n    this.styles = /* @__PURE__ */ new Map();\n    this.container = void 0;\n    this.containerSize = void 0;\n    this.sizeMonitor = new SizeMonitor();\n    this.cursorState = new StateTracker(\"default\");\n    this.minWidth = 0;\n    this.minHeight = 0;\n    const templateEl = createElement(\"div\");\n    templateEl.innerHTML = domLayout_default;\n    this.element = templateEl.children.item(0);\n    this.styleRootElement = styleContainer;\n    this.rootElements = DOM_ELEMENT_CLASSES.reduce(\n      (r, c) => {\n        const cssClass = `ag-charts-${c}`;\n        const el = this.element.classList.contains(cssClass) ? this.element : this.element.querySelector(`.${cssClass}`);\n        if (!el)\n          throw new Error(`AG Charts - unable to find DOM element ${cssClass}`);\n        r[c] = { element: el, children: /* @__PURE__ */ new Map(), listeners: [] };\n        return r;\n      },\n      {}\n    );\n    let hidden = false;\n    this.observer = setupObserver(this.element, (intersectionRatio) => {\n      if (intersectionRatio === 0 && !hidden) {\n        this.listeners.dispatch(\"hidden\", { type: \"hidden\" });\n      }\n      hidden = intersectionRatio === 0;\n    });\n    this.setSizeOptions();\n    this.updateContainerSize();\n    this.addStyles(\"ag-charts-community\", styles_default);\n    if (container) {\n      this.setContainer(container);\n    }\n    this.destroyFns.push(stopPageScrolling(this.element));\n    const guardedElement = this.element.querySelector(\".ag-charts-canvas-center\");\n    if (guardedElement == null)\n      throw new Error(\"Error initializing tab guards\");\n    const topGuard = createTabGuardElement(guardedElement, \"beforebegin\");\n    const botGuard = createTabGuardElement(guardedElement, \"afterend\");\n    this.tabGuards = new GuardedElement(guardedElement, topGuard, botGuard);\n  }\n  destroy() {\n    super.destroy();\n    this.observer?.unobserve(this.element);\n    if (this.container) {\n      this.sizeMonitor.unobserve(this.container);\n    }\n    Object.values(this.rootElements).forEach((el) => {\n      el.children.forEach((c) => c.remove());\n      el.element.remove();\n    });\n    this.element.remove();\n  }\n  setSizeOptions(minWidth = 300, minHeight = 300, optionsWidth, optionsHeight) {\n    const { style } = this.element;\n    style.width = `${optionsWidth ?? minWidth}px`;\n    style.height = `${optionsHeight ?? minHeight}px`;\n    this.minWidth = optionsWidth ?? minWidth;\n    this.minHeight = optionsHeight ?? minHeight;\n    this.updateContainerClassName();\n  }\n  updateContainerSize() {\n    const { style: centerStyle } = this.rootElements[\"canvas-center\"].element;\n    centerStyle.visibility = this.containerSize == null ? \"hidden\" : \"\";\n    if (this.containerSize) {\n      centerStyle.width = `${this.containerSize.width ?? 0}px`;\n      centerStyle.height = `${this.containerSize.height ?? 0}px`;\n    } else {\n      centerStyle.width = \"\";\n      centerStyle.height = \"\";\n    }\n    this.updateContainerClassName();\n  }\n  setTabGuardIndex(tabIndex) {\n    this.tabGuards.tabIndex = tabIndex;\n  }\n  setContainer(newContainer) {\n    if (newContainer === this.container)\n      return;\n    if (this.container) {\n      this.container.removeChild(this.element);\n      this.sizeMonitor.unobserve(this.container);\n    }\n    const isShadowDom = this.getShadowDocumentRoot(newContainer) != null;\n    if (!isShadowDom) {\n      for (const id of this.rootElements[\"styles\"].children.keys()) {\n        this.removeChild(\"styles\", id);\n      }\n    }\n    this.container = newContainer;\n    for (const [id, styles] of this.styles) {\n      this.addStyles(id, styles);\n    }\n    newContainer.appendChild(this.element);\n    this.sizeMonitor.observe(newContainer, (size) => {\n      this.containerSize = size;\n      this.updateContainerSize();\n      this.listeners.dispatch(\"resize\", { type: \"resize\" });\n    });\n    this.listeners.dispatch(\"container-changed\", { type: \"container-changed\" });\n  }\n  setThemeClass(themeClassName) {\n    const themeClassNamePrefix = \"ag-charts-theme-\";\n    this.element.classList.forEach((className) => {\n      if (className.startsWith(themeClassNamePrefix) && className !== themeClassName) {\n        this.element.classList.remove(className);\n      }\n    });\n    this.element.classList.add(themeClassName);\n  }\n  setThemeParameters(params) {\n    const keysMap = {\n      accentColor: \"accent-color\",\n      axisColor: \"axis-color\",\n      backgroundColor: \"background-color\",\n      borderColor: \"border-color\",\n      foregroundColor: \"foreground-color\",\n      fontFamily: \"font-family\",\n      fontSize: \"font-size\",\n      fontWeight: \"font-weight\",\n      gridLineColor: \"grid-line-color\",\n      padding: \"padding\",\n      subtleTextColor: \"subtle-text-color\",\n      textColor: \"text-color\",\n      chromeBackgroundColor: \"chrome-background-color\",\n      chromeFontFamily: \"chrome-font-family\",\n      chromeFontSize: \"chrome-font-size\",\n      chromeFontWeight: \"chrome-font-weight\",\n      chromeSubtleTextColor: \"chrome-subtle-text-color\",\n      chromeTextColor: \"chrome-text-color\",\n      inputBackgroundColor: \"input-background-color\",\n      inputTextColor: \"input-text-color\",\n      crosshairLabelBackgroundColor: \"crosshair-label-background-color\",\n      crosshairLabelTextColor: \"crosshair-label-text-color\"\n    };\n    const lengthKeys = [\"fontSize\", \"chromeFontSize\"];\n    for (const [key, value] of Object.entries(params)) {\n      let formattedValue = `${value}`;\n      if (lengthKeys.includes(key)) {\n        formattedValue = `${value}px`;\n      }\n      this.element.style.setProperty(`--ag-charts-${keysMap[key]}`, formattedValue);\n    }\n  }\n  updateCanvasLabel(ariaLabel) {\n    setAttribute(this.rootElements[\"canvas-proxy\"].element, \"aria-label\", ariaLabel);\n  }\n  getEventElement(defaultElem, eventType) {\n    const events = [\"focus\", \"blur\", \"keydown\", \"keyup\"];\n    return events.includes(eventType) ? this.rootElements[\"series-area\"].element : defaultElem;\n  }\n  addEventListener(type, listener, options) {\n    this.getEventElement(this.element, type).addEventListener(type, listener, options);\n  }\n  removeEventListener(type, listener, options) {\n    this.getEventElement(this.element, type).removeEventListener(type, listener, options);\n  }\n  /** Get the main chart area client bound rect. */\n  getBoundingClientRect() {\n    return this.rootElements[\"canvas\"].element.getBoundingClientRect();\n  }\n  /**\n   * Get the client bounding rect for overlay elements that might float outside the bounds of the\n   * main chart area.\n   */\n  getOverlayClientRect() {\n    const window2 = getWindow();\n    const windowBBox = new BBox(0, 0, window2.innerWidth, window2.innerHeight);\n    const containerBBox = this.getRawOverlayClientRect();\n    return windowBBox.intersection(containerBBox)?.toDOMRect() ?? NULL_DOMRECT;\n  }\n  getRawOverlayClientRect() {\n    let element2 = this.element;\n    while (element2 != null) {\n      const styleMap = element2.computedStyleMap?.();\n      const overflowY = styleMap?.get(\"overflow-y\")?.toString();\n      if (overflowY === \"auto\" || overflowY === \"scroll\") {\n        return BBox.fromDOMRect(element2.getBoundingClientRect());\n      }\n      element2 = element2.parentElement;\n    }\n    const docRoot = this.getShadowDocumentRoot();\n    if (docRoot != null)\n      return BBox.fromDOMRect(docRoot.getBoundingClientRect());\n    const { innerWidth, innerHeight } = getWindow();\n    return new BBox(0, 0, innerWidth, innerHeight);\n  }\n  getShadowDocumentRoot(current = this.container) {\n    const docRoot = current?.ownerDocument?.body ?? getDocument(\"body\");\n    while (current != null) {\n      if (current === docRoot) {\n        return void 0;\n      }\n      if (current.parentNode instanceof DocumentFragment) {\n        return current;\n      }\n      current = current.parentNode;\n    }\n    return this.container;\n  }\n  getParent(domElementClass) {\n    return this.rootElements[domElementClass].element;\n  }\n  getChildBoundingClientRect(type) {\n    const { children } = this.rootElements[type];\n    const childRects = [];\n    for (const child of children.values()) {\n      childRects.push(BBox.fromDOMRect(child.getBoundingClientRect()));\n    }\n    return BBox.merge(childRects);\n  }\n  isManagedChildDOMElement(el, domElementClass, id) {\n    const { children } = this.rootElements[domElementClass];\n    const search = children?.get(id);\n    return search != null && el.contains(search);\n  }\n  contains(element2, domElementClass) {\n    if (domElementClass == null)\n      return this.element.contains(element2);\n    return this.rootElements[domElementClass].element.contains(element2);\n  }\n  addStyles(id, styles) {\n    const dataAttribute = \"data-ag-charts\";\n    this.styles.set(id, styles);\n    if (this.container == null)\n      return;\n    const checkId = (el) => {\n      return el.getAttribute(dataAttribute) === id;\n    };\n    const addStyleElement = (el) => {\n      const metaElements = /* @__PURE__ */ new Set([\"TITLE\", \"META\"]);\n      let skippingMetaElements = true;\n      let insertAfterEl;\n      for (const child of el.children) {\n        if (skippingMetaElements && metaElements.has(child.tagName)) {\n          insertAfterEl = child;\n          continue;\n        }\n        skippingMetaElements = false;\n        if (checkId(child))\n          return;\n        if (child.hasAttribute(dataAttribute)) {\n          insertAfterEl = child;\n        }\n      }\n      const styleEl = createElement(\"style\");\n      if (insertAfterEl != null) {\n        el.insertBefore(styleEl, insertAfterEl.nextSibling);\n      } else {\n        el.prepend(styleEl);\n      }\n      return styleEl;\n    };\n    let styleElement;\n    if (this.styleRootElement) {\n      styleElement = addStyleElement(this.styleRootElement);\n    } else {\n      const documentRoot = this.getShadowDocumentRoot(this.container);\n      if (documentRoot != null) {\n        styleElement = this.addChild(\"styles\", id);\n      } else {\n        styleElement = addStyleElement(getDocument(\"head\"));\n      }\n    }\n    if (styleElement == null || checkId(styleElement))\n      return;\n    styleElement.setAttribute(dataAttribute, id);\n    styleElement.innerHTML = styles;\n  }\n  removeStyles(id) {\n    this.removeChild(\"styles\", id);\n  }\n  updateCursor(callerId, style) {\n    this.cursorState.set(callerId, style);\n    this.element.style.cursor = this.cursorState.stateValue();\n  }\n  getCursor() {\n    return this.element.style.cursor;\n  }\n  addChild(domElementClass, id, child, insert) {\n    const { element: element2, children, listeners } = this.rootElements[domElementClass];\n    if (!children) {\n      throw new Error(\"AG Charts - unable to create DOM elements after destroy()\");\n    }\n    if (children.has(id)) {\n      return children.get(id);\n    }\n    const { childElementType = \"div\" } = domElementConfig.get(domElementClass) ?? {};\n    if (child && child.tagName.toLowerCase() !== childElementType.toLowerCase()) {\n      throw new Error(\"AG Charts - mismatching DOM element type\");\n    }\n    const newChild = child ?? createElement(childElementType);\n    for (const [type, fn, opts] of listeners) {\n      newChild.addEventListener(type, fn, opts);\n    }\n    children.set(id, newChild);\n    if (insert) {\n      const queryResult = element2.querySelector(insert.query);\n      if (queryResult == null) {\n        throw new Error(`AG Charts - addChild query failed ${insert.query}`);\n      }\n      queryResult.insertAdjacentElement(insert.where, newChild);\n    } else {\n      element2?.appendChild(newChild);\n    }\n    return newChild;\n  }\n  removeChild(domElementClass, id) {\n    const { children } = this.rootElements[domElementClass];\n    if (!children)\n      return;\n    children.get(id)?.remove();\n    children.delete(id);\n  }\n  incrementDataCounter(name) {\n    const { dataset } = this.element;\n    dataset[name] ?? (dataset[name] = \"0\");\n    dataset[name] = String(Number(dataset[name]) + 1);\n  }\n  setDataBoolean(name, value) {\n    this.element.dataset[name] = String(value);\n  }\n  updateContainerClassName() {\n    const { element: element2, containerSize, minWidth, minHeight } = this;\n    element2.classList.toggle(CONTAINER_MODIFIERS.safeHorizontal, minWidth >= (containerSize?.width ?? Infinity));\n    element2.classList.toggle(CONTAINER_MODIFIERS.safeVertical, minHeight >= (containerSize?.height ?? Infinity));\n  }\n};\n\n// packages/ag-charts-community/src/widget/boundedTextWidget.ts\nvar BoundedTextWidget = class extends Widget {\n  constructor() {\n    super(createElement(\"div\"));\n    this.textElement = createSvgElement(\"text\");\n    this.textElement.role = \"presentation\";\n    this.svgElement = createSvgElement(\"svg\");\n    this.svgElement.appendChild(this.textElement);\n    this.svgElement.style.width = \"100%\";\n    this.svgElement.style.opacity = \"0\";\n    this.svgElement.role = \"presentation\";\n    this.elem.appendChild(this.svgElement);\n    this.elem.role = \"presentation\";\n  }\n  set textContent(text2) {\n    this.textElement.textContent = text2;\n    const bboxCalculator = this.textElement;\n    const bbox = bboxCalculator.getBBox?.();\n    if (bbox) {\n      this.svgElement.setAttribute(\"viewBox\", `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);\n    }\n  }\n  get textContent() {\n    return this.textElement.textContent;\n  }\n  destructor() {\n  }\n};\n\n// packages/ag-charts-community/src/widget/buttonWidget.ts\nvar ButtonWidget = class extends Widget {\n  constructor() {\n    super(createElement(\"button\"));\n    this.setEnabled(true);\n  }\n  destructor() {\n  }\n  setEnabled(enabled) {\n    setAttribute(this.elem, \"aria-disabled\", !enabled);\n    setElementStyle(this.elem, \"pointer-events\", enabled ? void 0 : \"none\");\n  }\n  addListener(type, listener) {\n    return super.addListener(type, (ev, current) => {\n      if ((type === \"click\" || type === \"dblclick\") && this.isDisabled())\n        return;\n      listener(ev, current);\n    });\n  }\n};\n\n// packages/ag-charts-community/src/widget/groupWidget.ts\nvar GroupWidget = class extends Widget {\n  constructor() {\n    super(createElement(\"div\"));\n    setAttribute(this.elem, \"role\", \"group\");\n  }\n  destructor() {\n  }\n};\n\n// packages/ag-charts-community/src/widget/rovingTabContainerWidget.ts\nvar RovingTabContainerWidget = class extends Widget {\n  constructor(initialOrientation, role) {\n    super(createElement(\"div\"));\n    this.focusedChildIndex = 0;\n    this.onChildFocus = (_event, child) => {\n      const oldFocus = this.children[this.focusedChildIndex];\n      this.focusedChildIndex = child.index;\n      oldFocus?.setTabIndex(-1);\n      child.setTabIndex(0);\n    };\n    this.onChildKeyDown = (event, child) => {\n      const rovingOrientation = this.orientation;\n      const [primaryKeys, secondaryKeys] = rovingOrientation === \"both\" ? [PREV_NEXT_KEYS[\"horizontal\"], PREV_NEXT_KEYS[\"vertical\"]] : [PREV_NEXT_KEYS[rovingOrientation], void 0];\n      let targetIndex = -1;\n      if (hasNoModifiers(event.sourceEvent)) {\n        const key = event.sourceEvent.key;\n        if (key === primaryKeys.nextKey || key === secondaryKeys?.nextKey) {\n          targetIndex = child.index + 1;\n        } else if (key === primaryKeys.prevKey || key === secondaryKeys?.prevKey) {\n          targetIndex = child.index - 1;\n        }\n      }\n      this.children[targetIndex]?.focus();\n    };\n    this.orientation = initialOrientation;\n    setAttribute(this.elem, \"role\", role);\n  }\n  get orientation() {\n    return getAttribute(this.elem, \"aria-orientation\") ?? \"both\";\n  }\n  set orientation(orientation) {\n    setAttribute(this.elem, \"aria-orientation\", orientation !== \"both\" ? orientation : void 0);\n  }\n  focus() {\n    this.children[this.focusedChildIndex]?.focus();\n  }\n  onChildAdded(child) {\n    child.addListener(\"focus\", this.onChildFocus);\n    child.addListener(\"keydown\", this.onChildKeyDown);\n    child.setTabIndex(this.children.length === 1 ? 0 : -1);\n  }\n  onChildRemoved(child) {\n    child.removeListener(\"focus\", this.onChildFocus);\n    child.removeListener(\"keydown\", this.onChildKeyDown);\n  }\n};\n\n// packages/ag-charts-community/src/widget/listWidget.ts\nvar ListWidget = class extends RovingTabContainerWidget {\n  constructor() {\n    super(\"both\", \"list\");\n    this.setHidden(true);\n  }\n  destructor() {\n    this.children.forEach((c) => c.getElement().parentElement.remove());\n  }\n  addChildToDOM(child, before) {\n    const listItem = createElement(\"div\");\n    setAttribute(listItem, \"role\", \"listitem\");\n    setElementStyle(listItem, \"position\", \"absolute\");\n    Widget.setElementContainer(child, listItem);\n    this.appendOrInsert(listItem, before);\n    this.setHidden(false);\n  }\n  removeChildFromDOM(child) {\n    child.getElement().parentElement.remove();\n    this.setHidden(this.children.length === 0);\n  }\n  setHidden(hidden) {\n    if (this.children.length === 0) {\n      hidden = true;\n    }\n    super.setHidden(hidden);\n  }\n};\n\n// packages/ag-charts-community/src/widget/nativeWidget.ts\nvar NativeWidget = class extends Widget {\n  constructor(elem) {\n    super(elem);\n  }\n  destructor() {\n  }\n};\n\n// packages/ag-charts-community/src/widget/sliderWidget.ts\nvar _SliderWidget = class _SliderWidget extends Widget {\n  constructor() {\n    super(createElement(\"input\"));\n    this._step = _SliderWidget.STEP_ONE;\n    this.orientation = \"both\";\n  }\n  get step() {\n    return this._step;\n  }\n  set step(step) {\n    this._step = step;\n    this.getElement().step = step.attributeValue;\n  }\n  get keyboardStep() {\n    return this._keyboardStep?.step ?? this._step;\n  }\n  set keyboardStep(step) {\n    if (step === this._keyboardStep?.step)\n      return;\n    if (this._keyboardStep !== void 0) {\n      this.removeListener(\"keydown\", this._keyboardStep.onKeyDown);\n      this.removeListener(\"keyup\", this._keyboardStep.onKeyUp);\n      this.removeListener(\"blur\", this._keyboardStep.onBlur);\n      this._keyboardStep = void 0;\n    }\n    if (step !== void 0) {\n      const onKeyDown = () => this.getElement().step = step.attributeValue;\n      const resetStep = () => this.getElement().step = this._step.attributeValue;\n      this._keyboardStep = { step, onKeyDown, onKeyUp: resetStep, onBlur: resetStep };\n      this.addListener(\"keydown\", this._keyboardStep.onKeyDown);\n      this.addListener(\"keyup\", this._keyboardStep.onKeyUp);\n      this.addListener(\"blur\", this._keyboardStep.onBlur);\n    }\n  }\n  get orientation() {\n    return getAttribute(this.elem, \"aria-orientation\") ?? \"both\";\n  }\n  set orientation(orientation) {\n    setAttribute(this.elem, \"aria-orientation\", orientation !== \"both\" ? orientation : void 0);\n    _SliderWidget.registerDefaultPreventers(this, orientation);\n  }\n  destructor() {\n  }\n  clampValueRatio(clampMin, clampMax) {\n    const ratio2 = this.getValueRatio();\n    const clampedRatio = clamp(clampMin, ratio2, clampMax);\n    if (clampedRatio !== ratio2) {\n      this.setValueRatio(clampedRatio);\n    }\n    return clampedRatio;\n  }\n  setValueRatio(ratio2, opts) {\n    const { divider } = this.step;\n    const value = Math.round(ratio2 * 1e4) / divider;\n    const { ariaValueText = formatPercent(value / divider) } = opts ?? {};\n    const elem = this.getElement();\n    elem.value = `${value}`;\n    elem.ariaValueText = ariaValueText;\n  }\n  getValueRatio() {\n    return parseFloat(this.getElement().value) / this.step.divider;\n  }\n  static registerDefaultPreventers(target, orientation) {\n    if (orientation === \"both\") {\n      target.removeListener(\"keydown\", _SliderWidget.onKeyDown);\n    } else {\n      target.addListener(\"keydown\", _SliderWidget.onKeyDown);\n    }\n  }\n  static onKeyDown(ev, current) {\n    let ignoredKeys = [];\n    const { orientation } = current;\n    if (orientation === \"horizontal\") {\n      ignoredKeys = [\"ArrowUp\", \"ArrowDown\"];\n    } else if (orientation === \"vertical\") {\n      ignoredKeys = [\"ArrowLeft\", \"ArrowRight\"];\n    }\n    if (ignoredKeys.includes(ev.sourceEvent.code)) {\n      ev.sourceEvent.preventDefault();\n    }\n  }\n};\n_SliderWidget.STEP_ONE = { attributeValue: \"1\", divider: 1 };\n_SliderWidget.STEP_HUNDRETH = { attributeValue: \"0.01\", divider: 100 };\nvar SliderWidget = _SliderWidget;\n\n// packages/ag-charts-community/src/widget/switchWidget.ts\nvar SwitchWidget = class extends ButtonWidget {\n  constructor() {\n    super();\n    setAttribute(this.elem, \"role\", \"switch\");\n    this.setChecked(false);\n  }\n  setChecked(checked) {\n    setAttribute(this.elem, \"aria-checked\", checked);\n  }\n};\n\n// packages/ag-charts-community/src/widget/toolbarWidget.ts\nvar ToolbarWidget = class extends RovingTabContainerWidget {\n  constructor(orientation = \"horizontal\") {\n    super(orientation, \"toolbar\");\n  }\n  destructor() {\n  }\n};\n\n// packages/ag-charts-community/src/dom/proxyInteractionService.ts\nfunction checkType(type, meta) {\n  return meta.params?.type === type;\n}\nfunction allocateResult(type) {\n  if (\"button\" === type) {\n    return new ButtonWidget();\n  } else if (\"slider\" === type) {\n    return new SliderWidget();\n  } else if (\"toolbar\" === type) {\n    return new ToolbarWidget();\n  } else if (\"group\" === type) {\n    return new GroupWidget();\n  } else if (\"list\" === type) {\n    return new ListWidget();\n  } else if (\"region\" === type) {\n    return new NativeWidget(createElement(\"div\"));\n  } else if (\"text\" === type) {\n    return new BoundedTextWidget();\n  } else if (\"listswitch\" === type) {\n    return new SwitchWidget();\n  } else {\n    throw Error(\"AG Charts - error allocating meta\");\n  }\n}\nfunction allocateMeta(params) {\n  const meta = { params, result: void 0 };\n  meta.result = allocateResult(meta.params.type);\n  return meta;\n}\nvar ProxyInteractionService = class {\n  constructor(localeManager, domManager) {\n    this.localeManager = localeManager;\n    this.domManager = domManager;\n    this.destroyFns = [];\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n  }\n  addLocalisation(fn) {\n    fn();\n    this.destroyFns.push(this.localeManager.addListener(\"locale-changed\", fn));\n  }\n  createProxyContainer(args) {\n    const meta = allocateMeta(args);\n    const { params, result } = meta;\n    const div = result.getElement();\n    this.domManager.addChild(\"canvas-proxy\", params.domManagerId, div);\n    div.classList.add(...params.classList, \"ag-charts-proxy-container\");\n    div.role = params.type;\n    if (\"ariaOrientation\" in params) {\n      div.ariaOrientation = params.ariaOrientation;\n    }\n    if (checkType(\"toolbar\", meta)) {\n      meta.result.orientation = meta.params.orientation;\n    }\n    this.addLocalisation(() => {\n      div.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);\n    });\n    return result;\n  }\n  createProxyElement(args) {\n    const meta = allocateMeta(args);\n    if (checkType(\"button\", meta)) {\n      const { params, result } = meta;\n      const button = result.getElement();\n      this.initInteract(params, result);\n      if (typeof params.textContent === \"string\") {\n        button.textContent = params.textContent;\n      } else {\n        const { textContent } = params;\n        this.addLocalisation(() => {\n          button.textContent = this.localeManager.t(textContent.id, textContent.params);\n        });\n      }\n      this.setParent(meta.params, meta.result);\n    }\n    if (checkType(\"slider\", meta)) {\n      const { params, result } = meta;\n      const slider = result.getElement();\n      this.initInteract(params, result);\n      slider.type = \"range\";\n      slider.role = \"presentation\";\n      slider.style.margin = \"0px\";\n      this.addLocalisation(() => {\n        slider.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);\n      });\n      this.setParent(meta.params, meta.result);\n    }\n    if (checkType(\"text\", meta)) {\n      const { params, result } = meta;\n      this.initElement(params, result);\n      this.setParent(meta.params, meta.result);\n    }\n    if (checkType(\"listswitch\", meta)) {\n      const { params, result: button } = meta;\n      this.initInteract(params, button);\n      button.setTextContent(params.textContent);\n      button.setChecked(params.ariaChecked);\n      button.setAriaDescribedBy(params.ariaDescribedBy);\n      this.setParent(meta.params, meta.result);\n    }\n    if (checkType(\"region\", meta)) {\n      const { params, result } = meta;\n      const region = result.getElement();\n      this.initInteract(params, result);\n      region.role = \"region\";\n      this.setParent(meta.params, meta.result);\n    }\n    return meta.result;\n  }\n  initElement(params, widget) {\n    const element2 = widget.getElement();\n    setAttribute(element2, \"id\", params.id);\n    setElementStyle(element2, \"cursor\", params.cursor);\n    element2.classList.toggle(\"ag-charts-proxy-elem\", true);\n    return element2;\n  }\n  initInteract(params, widget) {\n    const { tabIndex, domIndex } = params;\n    const element2 = this.initElement(params, widget);\n    if (tabIndex !== void 0) {\n      element2.tabIndex = tabIndex;\n    }\n    if (domIndex !== void 0) {\n      widget.domIndex = domIndex;\n    }\n  }\n  setParent(params, element2) {\n    if (\"parent\" in params) {\n      params.parent?.addChild(element2);\n    } else {\n      const insert = { where: params.where, query: \".ag-charts-series-area\" };\n      this.domManager.addChild(\"canvas-proxy\", params.domManagerId, element2.getElement(), insert);\n    }\n  }\n};\n\n// packages/ag-charts-locale/src/en-US.ts\nvar AG_CHARTS_LOCALE_EN_US = {\n  // Screen reader announcement when focusing an item in the chart\n  ariaAnnounceHoverDatum: \"${datum}\",\n  // Screen reader announcement when focusing a chart\n  ariaAnnounceChart: \"chart, ${seriesCount}[number] series\",\n  // Screen reader announcement when focusing a hierarchy chart\n  ariaAnnounceHierarchyChart: \"hierarchy chart, ${caption}\",\n  // Screen reader announcement when focusing a gauge chart\n  ariaAnnounceGaugeChart: \"gauge chart, ${caption}\",\n  // Screen reader announcement when focusing an item in a treemap or sunburst chart\n  ariaAnnounceHierarchyDatum: \"level ${level}[number], ${count}[number] children, ${description}\",\n  // Screen reader announcement when focusing a link in a Sankey or chord chart\n  ariaAnnounceFlowProportionLink: \"link ${index} of ${count}, from ${from} to ${to}, ${sizeName} ${size}\",\n  // Screen reader announcement when focusing a node in a Sankey or chord chart\n  ariaAnnounceFlowProportionNode: \"node ${index} of ${count}, ${description}\",\n  // Screen reader description for legend items\n  ariaDescriptionLegendItem: \"Press Space or Enter to toggle visibility\",\n  // Screen reader for the '+' horizontal line button on the Y-axis\n  ariaLabelAddHorizontalLine: \"Add Horizontal Line\",\n  // Screen reader text for annotation-options toolbar\n  ariaLabelAnnotationOptionsToolbar: \"Annotation Options\",\n  // Screen reader text for annotation-settings dialog\n  ariaLabelAnnotationSettingsDialog: \"Annotation Settings\",\n  // Screen reader text for the color picker dialog\n  ariaLabelColorPicker: \"Color picker\",\n  // Screen reader text for the financial charts toolbar\n  ariaLabelFinancialCharts: \"Financial Charts\",\n  // Screen reader text for the legend toolbar\n  ariaLabelLegend: \"Legend\",\n  // Screen reader text for the legend pagination button\n  ariaLabelLegendPagination: \"Legend Pagination\",\n  // Screen reader text for the previous legend page button\n  ariaLabelLegendPagePrevious: \"Previous Legend Page\",\n  // Screen reader text for the next legend page button\n  ariaLabelLegendPageNext: \"Next Legend Page\",\n  // Screen reader text for the an item in the legend\n  ariaLabelLegendItem: \"${label}, Legend item ${index}[number] of ${count}[number]\",\n  // Screen reader text for the an unknown item in the legend\n  ariaLabelLegendItemUnknown: \"Unknown legend item\",\n  // Screen reader text for the navigator element\n  ariaLabelNavigator: \"Navigator\",\n  // Screen reader text for an accessibility control that changes the position of the navigator's range\n  ariaLabelNavigatorRange: \"Range\",\n  // Screen reader text for an accessibility control that changes the start of the navigator's range\n  ariaLabelNavigatorMinimum: \"Minimum\",\n  // Screen reader text for an accessibility control that changes the end of the navigator's range\n  ariaLabelNavigatorMaximum: \"Maximum\",\n  // Screen reader text for ranges toolbar\n  ariaLabelRangesToolbar: \"Ranges\",\n  // Screen reader text for the settings dialog tab-bar\n  ariaLabelSettingsTabBar: \"Settings\",\n  // Screen reader text for zoom toolbar\n  ariaLabelZoomToolbar: \"Zoom\",\n  // Screen reader text for the value of the navigator's range\n  ariaValuePanRange: \"${min}[percent] to ${max}[percent]\",\n  // Alt-text for the solid line dash style menu item icon\n  iconAltTextLineStyleSolid: \"Solid\",\n  // Alt-text for the long-dashed line dash style menu item icon\n  iconAltTextLineStyleDashed: \"Long-dashed\",\n  // Alt-text for the short-dashed line dash style menu item icon\n  iconAltTextLineStyleDotted: \"Short-dashed\",\n  // Alt-text for the 'position-top' icon\n  iconAltTextPositionTop: \"Top\",\n  // Alt-text for the 'position-center' icon\n  iconAltTextPositionCenter: \"Center\",\n  // Alt-text for the 'position-bottom' icon\n  iconAltTextPositionBottom: \"Bottom\",\n  // Alt-text for the 'position-left' icon\n  iconAltTextAlignLeft: \"Left\",\n  // Alt-text for the 'align-center' icon\n  iconAltTextAlignCenter: \"Center\",\n  // Alt-text for the 'position-right' icon\n  iconAltTextAlignRight: \"Right\",\n  // Alt-text for the 'close' icon\n  iconAltTextClose: \"Close\",\n  // Default text for the 'loading data' overlay\n  overlayLoadingData: \"Loading data...\",\n  // Default text for the 'no data' overlay\n  overlayNoData: \"No data to display\",\n  // Default text for the 'no visible series' overlay\n  overlayNoVisibleSeries: \"No visible series\",\n  // Default text for the 'unsupported browser' overlay\n  overlayUnsupportedBrowser: \"Incompatible browser version. Please upgrade your browser.\",\n  // Text for frequency label in Histogram Series tooltip\n  seriesHistogramTooltipFrequency: \"Frequency\",\n  // Text for sum label in Histogram Series tooltip\n  seriesHistogramTooltipSum: \"${yName} (sum)\",\n  // Text for sum label in Histogram Series tooltip\n  seriesHistogramTooltipCount: \"${yName} (count)\",\n  // Text for sum label in Histogram Series tooltip\n  seriesHistogramTooltipMean: \"${yName} (mean)\",\n  // Text for the series type toolbar's chart type button\n  toolbarSeriesTypeDropdown: \"Chart Type\",\n  // Text for the series type toolbar's OHLC chart type button\n  toolbarSeriesTypeOHLC: \"OHLC\",\n  // Text for the series type toolbar's HLC chart type button\n  toolbarSeriesTypeHLC: \"HLC\",\n  // Text for the series type toolbar's high low chart type button\n  toolbarSeriesTypeHighLow: \"High Low\",\n  // Text for the series type toolbar's candles chart type button\n  toolbarSeriesTypeCandles: \"Candles\",\n  // Text for the series type toolbar's hollow candles chart type button\n  toolbarSeriesTypeHollowCandles: \"Hollow Candles\",\n  // Text for the series type toolbar's line chart type button\n  toolbarSeriesTypeLine: \"Line\",\n  // Text for the series type toolbar's line with markers chart type button\n  toolbarSeriesTypeLineWithMarkers: \"Line with Markers\",\n  // Text for the series type toolbar's line with step line chart type button\n  toolbarSeriesTypeStepLine: \"Step Line\",\n  // Text for the annotation toolbar's trend line button\n  toolbarAnnotationsTrendLine: \"Trend Line\",\n  // Text for the annotation toolbar's Fibonacci Retracement button\n  toolbarAnnotationsFibonacciRetracement: \"Fib Retracement\",\n  // Text for the annotation toolbar's Fibonacci Retracement Trend Based button\n  toolbarAnnotationsFibonacciRetracementTrendBased: \"Fib Trend Based\",\n  // Text for the annotation toolbar's horizontal line button\n  toolbarAnnotationsHorizontalLine: \"Horizontal Line\",\n  // Text for the annotation toolbar's vertical line button\n  toolbarAnnotationsVerticalLine: \"Vertical Line\",\n  // Text for the annotation toolbar's parallel channel button\n  toolbarAnnotationsParallelChannel: \"Parallel Channel\",\n  // Text for the annotation toolbar's disjoint channel button\n  toolbarAnnotationsDisjointChannel: \"Disjoint Channel\",\n  // Text for the annotation toolbar's clear all button\n  toolbarAnnotationsClearAll: \"Clear All\",\n  // Text for the annotation toolbar's fill color picker annotation button\n  toolbarAnnotationsFillColor: \"Fill Color\",\n  // Text for the annotation toolbar's line color picker annotation button\n  toolbarAnnotationsLineColor: \"Line Color\",\n  // Text for the annotation toolbar's line style type button\n  toolbarAnnotationsLineStyle: \"Line Style\",\n  // Text for the annotation toolbar's line stroke width button\n  toolbarAnnotationsLineStrokeWidth: \"Line Stroke Width\",\n  // Text for the annotation toolbar's settings annotation button\n  toolbarAnnotationsSettings: \"Settings\",\n  // Text for the annotation toolbar's text color picker annotation button\n  toolbarAnnotationsTextColor: \"Text Color\",\n  // Text for the annotation toolbar's text size picker annotation button\n  toolbarAnnotationsTextSize: \"Text Size\",\n  // Text for the annotation toolbar's lock annotation button\n  toolbarAnnotationsLock: \"Lock\",\n  // Text for the annotation toolbar's unlock annotation button\n  toolbarAnnotationsUnlock: \"Unlock\",\n  // Text for the annotation toolbar's delete annotation button\n  toolbarAnnotationsDelete: \"Delete\",\n  // Text for the annotation toolbar's drag handle\n  toolbarAnnotationsDragHandle: \"Drag Toolbar\",\n  // Text for the annotation toolbar's line drawings menu button\n  toolbarAnnotationsLineAnnotations: \"Trend Lines\",\n  // Text for the annotation toolbar's Fibonacci drawings menu button\n  toolbarAnnotationsFibonacciAnnotations: \"Fibonacci\",\n  // Text for the annotation toolbar's text annotations menu button\n  toolbarAnnotationsTextAnnotations: \"Text Annotations\",\n  // Text for the annotation toolbar's shapes menu button\n  toolbarAnnotationsShapeAnnotations: \"Arrows\",\n  // Text for the annotation toolbar's measurers menu button\n  toolbarAnnotationsMeasurerAnnotations: \"Measurers\",\n  // Text for the annotation toolbar's callout button\n  toolbarAnnotationsCallout: \"Callout\",\n  // Text for the annotation toolbar's comment button\n  toolbarAnnotationsComment: \"Comment\",\n  // Text for the annotation toolbar's note button\n  toolbarAnnotationsNote: \"Note\",\n  // Text for the annotation toolbar's text button\n  toolbarAnnotationsText: \"Text\",\n  // Text for the annotation toolbar's arrow button\n  toolbarAnnotationsArrow: \"Arrow\",\n  // Text for the annotation toolbar's arrow up button\n  toolbarAnnotationsArrowUp: \"Arrow Up\",\n  // Text for the annotation toolbar's arrow down button\n  toolbarAnnotationsArrowDown: \"Arrow Down\",\n  // Text for the annotation toolbar's date range button\n  toolbarAnnotationsDateRange: \"Date Range\",\n  // Text for the annotation toolbar's price range button\n  toolbarAnnotationsPriceRange: \"Price Range\",\n  // Text for the annotation toolbar's date and price range button\n  toolbarAnnotationsDatePriceRange: \"Date and Price\",\n  // Text for the annotation toolbar's quick date and price range button\n  toolbarAnnotationsQuickDatePriceRange: \"Measure\",\n  // Text for the range toolbar's 1 month button\n  toolbarRange1Month: \"1M\",\n  // Aria label for the range toolbar's 1 month button\n  toolbarRange1MonthAria: \"1 month\",\n  // Text for the range toolbar's 3 month button\n  toolbarRange3Months: \"3M\",\n  // Aria label for the range toolbar's 3 month button\n  toolbarRange3MonthsAria: \"3 months\",\n  // Text for the range toolbar's 6 month button\n  toolbarRange6Months: \"6M\",\n  // Aria label for the range toolbar's 6 month button\n  toolbarRange6MonthsAria: \"6 months\",\n  // Text for the range toolbar's year to date button\n  toolbarRangeYearToDate: \"YTD\",\n  // Aria label for the range toolbar's year to date month button\n  toolbarRangeYearToDateAria: \"Year to date\",\n  // Text for the range toolbar's 1 year button\n  toolbarRange1Year: \"1Y\",\n  // Aria label for the range toolbar's 1 year button\n  toolbarRange1YearAria: \"1 year\",\n  // Text for the range toolbar's full range button\n  toolbarRangeAll: \"All\",\n  // Aria label for the range toolbar's full range button\n  toolbarRangeAllAria: \"All\",\n  // Text for the zoom toolbar's zoom out button\n  toolbarZoomZoomOut: \"Zoom out\",\n  // Text for the zoom toolbar's zoom in button\n  toolbarZoomZoomIn: \"Zoom in\",\n  // Text for the zoom toolbar's pan left button\n  toolbarZoomPanLeft: \"Pan left\",\n  // Text for the zoom toolbar's pan right button\n  toolbarZoomPanRight: \"Pan right\",\n  // Text for the zoom toolbar's pan to the start button\n  toolbarZoomPanStart: \"Pan to the start\",\n  // Text for the zoom toolbar's pan to the end button\n  toolbarZoomPanEnd: \"Pan to the end\",\n  // Text for the zoom toolbar's pan reset button\n  toolbarZoomReset: \"Reset the zoom\",\n  // Text for the context menu's download button\n  contextMenuDownload: \"Download\",\n  // Text for the context menu's toggle series visibility button\n  contextMenuToggleSeriesVisibility: \"Toggle Visibility\",\n  // Text for the context menu's toggle other series visibility button\n  contextMenuToggleOtherSeries: \"Toggle Other Series\",\n  // Text for the context menu's zoom to point button\n  contextMenuZoomToCursor: \"Zoom to here\",\n  // Text for the context menu's pan to point button\n  contextMenuPanToCursor: \"Pan to here\",\n  // Text for the annotation dialog's header channel tab label\n  dialogHeaderChannel: \"Channel\",\n  // Text for the annotation dialog's header line tab label\n  dialogHeaderLine: \"Line\",\n  // Text for the annotation dialog's header fibonacci retracement line tab label\n  dialogHeaderFibonacciRange: \"Fib Retracement\",\n  // Text for the annotation dialog's header date range tab label\n  dialogHeaderDateRange: \"Date Range\",\n  // Text for the annotation dialog's header price range tab label\n  dialogHeaderPriceRange: \"Price Range\",\n  // Text for the annotation dialog's header date and price range tab label\n  dialogHeaderDatePriceRange: \"Date and Price\",\n  // Text for the annotation dialog's header text tab label\n  dialogHeaderText: \"Text\",\n  // Text for the annotation dialog's text alignment radio label\n  dialogInputAlign: \"Align\",\n  // Text for the annotation dialog's color picker label\n  dialogInputColorPicker: \"Color\",\n  // Text for the annotation dialog's color picker alt text\n  dialogInputColorPickerAltText: \"Text Color\",\n  // Text for the annotation dialog's fill color picker label\n  dialogInputFillColorPicker: \"Fill\",\n  // Text for the annotation dialog's fill color picker alt text\n  dialogInputFillColorPickerAltText: \"Fill Color\",\n  // Text for the annotation dialog's extend channel start checkbox\n  dialogInputExtendChannelStart: \"Extend channel start\",\n  // Text for the annotation dialog's extend channel end checkbox\n  dialogInputExtendChannelEnd: \"Extend channel end\",\n  // Text for the annotation dialog's extend line start checkbox\n  dialogInputExtendLineStart: \"Extend line start\",\n  // Text for the annotation dialog's extend line end checkbox\n  dialogInputExtendLineEnd: \"Extend line end\",\n  // Text for the annotation dialog's extend above checkbox\n  dialogInputExtendAbove: \"Extend above\",\n  // Text for the annotation dialog's extend below checkbox\n  dialogInputExtendBelow: \"Extend below\",\n  // Text for the annotation dialog's extend left checkbox\n  dialogInputExtendLeft: \"Extend left\",\n  // Text for the annotation dialog's extend right checkbox\n  dialogInputExtendRight: \"Extend right\",\n  // Text for the annotation dialog's reverse checkbox\n  dialogInputReverse: \"Reverse\",\n  // Text for the annotation dialog's show fill checkbox\n  dialogInputShowFill: \"Show Fill\",\n  // Text for the annotation dialog's font size select box label\n  dialogInputFontSize: \"Size\",\n  // Text for the annotation dialog's font size select box alt text\n  dialogInputFontSizeAltText: \"Font Size\",\n  // Text for the annotation dialog's line style radio label\n  dialogInputLineStyle: \"Dash\",\n  // Text for the annotation dialog's text position radio label\n  dialogInputPosition: \"Position\",\n  // Text for the annotation dialog's stroke width label\n  dialogInputStrokeWidth: \"Weight\",\n  // Text for the annotation dialog's stroke width label\n  dialogInputStrokeWidthAltText: \"Line Weight\",\n  // Text for the annotation dialog's Fibonacci bands label\n  dialogInputFibonacciBands: \"Bands\",\n  // Text for the annotation dialog's Fibonacci bands label\n  dialogInputFibonacciBandsAltText: \"Fibonacci Bands\",\n  // Text for text area input placeholders\n  inputTextareaPlaceholder: \"Add Text\",\n  // Text for the measurer statistics date range bars value\n  measurerDateRangeBars: \"${value}[number] bars\",\n  // Text for the measurer statistics price range value\n  measurerPriceRangeValue: \"${value}[number]\",\n  // Text for the measurer statistics price range percentage\n  measurerPriceRangePercent: \"${value}[percent]\",\n  // Text for the measurer statistics volume value\n  measurerVolume: \"Vol ${value}\"\n};\n\n// packages/ag-charts-community/src/locale/defaultMessageFormatter.ts\nvar messageRegExp = /\\$\\{(\\w+)}(?:\\[(\\w+)])?/gi;\nvar formatters = {\n  number: new Intl.NumberFormat(\"en-US\"),\n  percent: new Intl.NumberFormat(\"en-US\", { style: \"percent\", minimumFractionDigits: 2, maximumFractionDigits: 2 }),\n  date: new Intl.DateTimeFormat(\"en-US\", { dateStyle: \"full\" }),\n  time: new Intl.DateTimeFormat(\"en-US\", { timeStyle: \"full\" }),\n  datetime: new Intl.DateTimeFormat(\"en-US\", { dateStyle: \"full\", timeStyle: \"full\" })\n};\nvar defaultMessageFormatter = ({ defaultValue, variables }) => {\n  return defaultValue?.replaceAll(messageRegExp, (_, match, format) => {\n    const value = variables[match];\n    const formatter = format != null ? formatters[format] : null;\n    if (format != null && formatter == null) {\n      logger_exports.warnOnce(`Format style [${format}] is not supported`);\n    }\n    if (formatter != null) {\n      return formatter.format(value);\n    } else if (typeof value === \"number\") {\n      return formatters.number.format(value);\n    } else if (value instanceof Date) {\n      return formatters.datetime.format(value);\n    }\n    return String(value);\n  });\n};\n\n// packages/ag-charts-community/src/locale/localeManager.ts\nvar LocaleManager = class extends Listeners {\n  constructor() {\n    super(...arguments);\n    this.localeText = void 0;\n    this.getLocaleText = void 0;\n  }\n  setLocaleText(localeText) {\n    if (this.localeText !== localeText) {\n      this.localeText = localeText;\n      this.dispatch(\"locale-changed\");\n    }\n  }\n  setLocaleTextFormatter(getLocaleText) {\n    this.getLocaleText = getLocaleText;\n    if (this.getLocaleText !== getLocaleText) {\n      this.getLocaleText = getLocaleText;\n      this.dispatch(\"locale-changed\");\n    }\n  }\n  t(key, variables = {}) {\n    const { localeText = AG_CHARTS_LOCALE_EN_US, getLocaleText } = this;\n    const defaultValue = localeText[key];\n    return getLocaleText?.({ key, defaultValue, variables }) ?? defaultMessageFormatter({ key, defaultValue, variables }) ?? key;\n  }\n};\n\n// packages/ag-charts-community/src/scene/canvas/hdpiCanvas.ts\nvar HdpiCanvas = class {\n  constructor(options) {\n    this.enabled = true;\n    this.width = 600;\n    this.height = 300;\n    const { width: width2, height: height2, canvasElement, willReadFrequently = false } = options;\n    this.pixelRatio = options.pixelRatio ?? getWindow(\"devicePixelRatio\") ?? 1;\n    this.element = canvasElement ?? createElement(\"canvas\");\n    this.element.style.display = \"block\";\n    this.element.style.width = (width2 ?? this.width) + \"px\";\n    this.element.style.height = (height2 ?? this.height) + \"px\";\n    this.element.width = Math.round((width2 ?? this.width) * this.pixelRatio);\n    this.element.height = Math.round((height2 ?? this.height) * this.pixelRatio);\n    this.context = this.element.getContext(\"2d\", { willReadFrequently });\n    this.onEnabledChange();\n    this.resize(width2 ?? 0, height2 ?? 0, this.pixelRatio);\n    debugContext(this.context);\n  }\n  drawImage(context, dx = 0, dy = 0) {\n    return context.drawImage(this.context.canvas, dx, dy);\n  }\n  toDataURL(type) {\n    return this.element.toDataURL(type);\n  }\n  resize(width2, height2, pixelRatio) {\n    if (!(width2 > 0 && height2 > 0))\n      return;\n    const { element: element2, context } = this;\n    element2.width = Math.round(width2 * pixelRatio);\n    element2.height = Math.round(height2 * pixelRatio);\n    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    element2.style.width = width2 + \"px\";\n    element2.style.height = height2 + \"px\";\n    this.width = width2;\n    this.height = height2;\n    this.pixelRatio = pixelRatio;\n  }\n  clear() {\n    clearContext(this);\n  }\n  destroy() {\n    this.element.remove();\n    this.element.width = 0;\n    this.element.height = 0;\n    this.context.clearRect(0, 0, 0, 0);\n    Object.freeze(this);\n  }\n  onEnabledChange() {\n    if (this.element) {\n      this.element.style.display = this.enabled ? \"\" : \"none\";\n    }\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => target.onEnabledChange())\n], HdpiCanvas.prototype, \"enabled\", 2);\n\n// packages/ag-charts-community/src/scene/layersManager.ts\nvar LayersManager = class {\n  constructor(canvas) {\n    this.canvas = canvas;\n    this.debug = Debug.create(true, \"scene\");\n    this.layersMap = /* @__PURE__ */ new Map();\n    this.nextLayerId = 0;\n  }\n  get size() {\n    return this.layersMap.size;\n  }\n  resize(width2, height2, pixelRatio) {\n    this.canvas.resize(width2, height2, pixelRatio);\n    this.layersMap.forEach(({ canvas }) => canvas.resize(width2, height2, pixelRatio));\n  }\n  addLayer(opts) {\n    const { width: width2, height: height2, pixelRatio } = this.canvas;\n    const { name } = opts;\n    const canvas = new HdpiOffscreenCanvas({ width: width2, height: height2, pixelRatio });\n    this.layersMap.set(canvas, {\n      id: this.nextLayerId++,\n      name,\n      canvas\n    });\n    this.debug(\"Scene.addLayer() - layers\", this.layersMap);\n    return canvas;\n  }\n  removeLayer(canvas) {\n    if (this.layersMap.has(canvas)) {\n      this.layersMap.delete(canvas);\n      canvas.destroy();\n      this.debug(\"Scene.removeLayer() -  layers\", this.layersMap);\n    }\n  }\n  clear() {\n    for (const layer of this.layersMap.values()) {\n      layer.canvas.destroy();\n    }\n    this.layersMap.clear();\n  }\n};\n\n// packages/ag-charts-community/src/scene/sceneDebug.ts\nfunction formatBytes(value) {\n  for (const unit of [\"B\", \"KB\", \"MB\", \"GB\"]) {\n    if (value < 1536) {\n      return `${value.toFixed(1)}${unit}`;\n    }\n    value /= 1024;\n  }\n  return `${value.toFixed(1)}TB}`;\n}\nfunction memoryUsage() {\n  if (!(\"memory\" in performance))\n    return;\n  const { totalJSHeapSize, usedJSHeapSize, jsHeapSizeLimit } = performance.memory;\n  const result = [];\n  for (const amount of [usedJSHeapSize, totalJSHeapSize, jsHeapSizeLimit]) {\n    if (typeof amount !== \"number\")\n      continue;\n    result.push(formatBytes(amount));\n  }\n  return `Heap ${result.join(\" / \")}`;\n}\nfunction debugStats(layersManager, debugSplitTimes, ctx, renderCtxStats, extraDebugStats = {}, seriesRect = BBox.zero) {\n  if (!Debug.check(\"scene:stats\" /* SCENE_STATS */, \"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */))\n    return;\n  const {\n    layersRendered = 0,\n    layersSkipped = 0,\n    nodesRendered = 0,\n    nodesSkipped = 0,\n    opsPerformed = 0,\n    opsSkipped = 0\n  } = renderCtxStats ?? {};\n  const end2 = performance.now();\n  const { start: start2, ...durations } = debugSplitTimes;\n  const splits = Object.entries(durations).map(([n, t]) => {\n    return time(n, t);\n  }).filter((v) => v != null).join(\" + \");\n  const extras = Object.entries(extraDebugStats).map(([k, v]) => `${k}: ${JSON.stringify(v)}`).join(\" ; \");\n  const detailedStats = Debug.check(\"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */);\n  const memUsage = memoryUsage();\n  const stats = [\n    `${time(\"\\u23F1\\uFE0F\", start2, end2)} (${splits})`,\n    `${extras}`,\n    `Layers: ${detailedStats ? pct(layersRendered, layersSkipped) : layersManager.size}`,\n    detailedStats ? `Nodes: ${pct(nodesRendered, nodesSkipped)}` : null,\n    detailedStats ? `Ops: ${pct(opsPerformed, opsSkipped)}` : null,\n    detailedStats && memUsage ? memUsage : null\n  ].filter(isString);\n  const measurer2 = new SimpleTextMeasurer((t) => ctx.measureText(t));\n  const statsSize = new Map(stats.map((t) => [t, measurer2.measureLines(t)]));\n  const width2 = Math.max(...Array.from(statsSize.values(), (s) => s.width));\n  const height2 = accumulate(statsSize.values(), (s) => s.height);\n  const x = 2 + seriesRect.x;\n  ctx.save();\n  ctx.fillStyle = \"white\";\n  ctx.fillRect(x, 0, width2, height2);\n  ctx.fillStyle = \"black\";\n  let y = 0;\n  for (const [stat, size] of statsSize.entries()) {\n    y += size.height;\n    ctx.fillText(stat, x, y);\n  }\n  ctx.restore();\n}\nfunction prepareSceneNodeHighlight(ctx) {\n  const config = toArray(getWindow(\"agChartsSceneDebug\"));\n  const result = [];\n  for (const name of config) {\n    if (name === \"layout\") {\n      result.push(\"seriesRoot\", \"legend\", \"root\", /.*Axis-\\d+-axis.*/);\n    } else {\n      result.push(name);\n    }\n  }\n  ctx.debugNodeSearch = result;\n}\nfunction debugSceneNodeHighlight(ctx, debugNodes) {\n  ctx.save();\n  for (const [name, node] of Object.entries(debugNodes)) {\n    const bbox = Transformable.toCanvas(node);\n    if (!bbox) {\n      logger_exports.log(`Scene.render() - no bbox for debugged node [${name}].`);\n      continue;\n    }\n    ctx.globalAlpha = 0.8;\n    ctx.strokeStyle = \"red\";\n    ctx.lineWidth = 1;\n    ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);\n    ctx.fillStyle = \"red\";\n    ctx.strokeStyle = \"white\";\n    ctx.font = \"16px sans-serif\";\n    ctx.textBaseline = \"top\";\n    ctx.textAlign = \"left\";\n    ctx.lineWidth = 2;\n    ctx.strokeText(name, bbox.x, bbox.y, bbox.width);\n    ctx.fillText(name, bbox.x, bbox.y, bbox.width);\n  }\n  ctx.restore();\n}\nvar skippedProperties = /* @__PURE__ */ new Set();\nvar allowedProperties = /* @__PURE__ */ new Set([\n  \"gradient\",\n  // '_datum',\n  \"zIndex\",\n  \"clipRect\",\n  \"cachedBBox\",\n  \"childNodeCounts\",\n  \"path\",\n  \"__zIndex\",\n  \"name\",\n  \"__scalingCenterX\",\n  \"__scalingCenterY\",\n  \"__rotationCenterX\",\n  \"__rotationCenterY\",\n  \"_previousDatum\",\n  \"__fill\",\n  \"__lineDash\",\n  \"borderPath\",\n  \"borderClipPath\",\n  \"_clipPath\"\n]);\nfunction nodeProps(node) {\n  const { ...allProps } = node;\n  for (const prop of Object.keys(allProps)) {\n    if (allowedProperties.has(prop))\n      continue;\n    if (typeof allProps[prop] === \"number\")\n      continue;\n    if (typeof allProps[prop] === \"string\")\n      continue;\n    if (typeof allProps[prop] === \"boolean\")\n      continue;\n    skippedProperties.add(prop);\n    delete allProps[prop];\n  }\n  return allProps;\n}\nfunction buildTree(node, mode) {\n  if (!Debug.check(true, \"scene\" /* SCENE */)) {\n    return {};\n  }\n  let order = 0;\n  return {\n    node: mode === \"json\" ? nodeProps(node) : node,\n    name: node.name ?? node.id,\n    dirty: node.dirty,\n    ...Array.from(node.children(), (c) => buildTree(c, mode)).reduce(\n      (result, childTree) => {\n        let { name: treeNodeName } = childTree;\n        const {\n          node: { visible, opacity, zIndex, translationX, translationY, rotation, scalingX, scalingY },\n          node: childNode\n        } = childTree;\n        if (!visible || opacity <= 0) {\n          treeNodeName = `(${treeNodeName})`;\n        }\n        if (Group.is(childNode) && childNode.renderToOffscreenCanvas) {\n          treeNodeName = `*${treeNodeName}*`;\n        }\n        const zIndexString = Array.isArray(zIndex) ? `(${zIndex.join(\", \")})` : zIndex;\n        const key = [\n          `${(order++).toString().padStart(3, \"0\")}|`,\n          `${treeNodeName ?? \"<unknown>\"}`,\n          `z: ${zIndexString}`,\n          translationX && `x: ${translationX}`,\n          translationY && `y: ${translationY}`,\n          rotation && `r: ${rotation}`,\n          scalingX != null && scalingX !== 1 && `sx: ${scalingX}`,\n          scalingY != null && scalingY !== 1 && `sy: ${scalingY}`\n        ].filter((v) => !!v).join(\" \");\n        let selectedKey = key;\n        let index = 1;\n        while (result[selectedKey] != null && index < 100) {\n          selectedKey = `${key} (${index++})`;\n        }\n        result[selectedKey] = childTree;\n        return result;\n      },\n      {}\n    )\n  };\n}\nfunction buildDirtyTree(node) {\n  if (!node.dirty) {\n    return { dirtyTree: {}, paths: [] };\n  }\n  const childrenDirtyTree = Array.from(node.children(), (c) => buildDirtyTree(c)).filter((c) => c.paths.length > 0);\n  const name = Group.is(node) ? node.name ?? node.id : node.id;\n  const paths = childrenDirtyTree.length ? childrenDirtyTree.flatMap((c) => c.paths).map((p) => `${name}.${p}`) : [name];\n  return {\n    dirtyTree: {\n      name,\n      node,\n      dirty: node.dirty,\n      ...childrenDirtyTree.map((c) => c.dirtyTree).filter((t) => t.dirty != null).reduce((result, childTree) => {\n        result[childTree.name ?? \"<unknown>\"] = childTree;\n        return result;\n      }, {})\n    },\n    paths\n  };\n}\nfunction pct(rendered, skipped) {\n  const total = rendered + skipped;\n  return `${rendered} / ${total} (${Math.round(100 * rendered / total)}%)`;\n}\nfunction time(name, start2, end2) {\n  const duration = end2 != null ? end2 - start2 : start2;\n  return `${name}: ${Math.round(duration * 100) / 100}ms`;\n}\nfunction accumulate(iterator, mapper) {\n  let sum2 = 0;\n  for (const item of iterator) {\n    sum2 += mapper(item);\n  }\n  return sum2;\n}\n\n// packages/ag-charts-community/src/scene/scene.ts\nvar Scene = class {\n  constructor(canvasOptions) {\n    this.debug = Debug.create(true, \"scene\" /* SCENE */);\n    this.id = createId(this);\n    this.root = null;\n    this.pendingSize = null;\n    this.isDirty = false;\n    this.canvas = new HdpiCanvas(canvasOptions);\n    this.layersManager = new LayersManager(this.canvas);\n  }\n  get width() {\n    return this.pendingSize?.[0] ?? this.canvas.width;\n  }\n  get height() {\n    return this.pendingSize?.[1] ?? this.canvas.height;\n  }\n  get pixelRatio() {\n    return this.pendingSize?.[2] ?? this.canvas.pixelRatio;\n  }\n  /** @deprecated v10.2.0 Only used by AG Grid Sparklines */\n  setContainer(value) {\n    const { element: element2 } = this.canvas;\n    element2.parentElement?.removeChild(element2);\n    value.appendChild(element2);\n    return this;\n  }\n  setRoot(node) {\n    if (this.root === node) {\n      return this;\n    }\n    this.isDirty = true;\n    this.root?._setLayerManager();\n    this.root = node;\n    if (node) {\n      node.visible = true;\n      node._setLayerManager(this.layersManager);\n    }\n    return this;\n  }\n  clear() {\n    this.canvas.clear();\n  }\n  attachNode(node) {\n    this.appendChild(node);\n    return () => this.removeChild(node);\n  }\n  appendChild(node) {\n    this.root?.appendChild(node);\n    return this;\n  }\n  removeChild(node) {\n    this.root?.removeChild(node);\n    return this;\n  }\n  download(fileName, fileFormat) {\n    downloadUrl(this.canvas.toDataURL(fileFormat), fileName?.trim() ?? \"image\");\n  }\n  /** NOTE: Integrated Charts undocumented image download method. */\n  getDataURL(fileFormat) {\n    return this.canvas.toDataURL(fileFormat);\n  }\n  resize(width2, height2, pixelRatio) {\n    width2 = Math.round(width2);\n    height2 = Math.round(height2);\n    pixelRatio ?? (pixelRatio = this.pixelRatio);\n    if (width2 > 0 && height2 > 0 && (width2 !== this.width || height2 !== this.height || pixelRatio !== this.pixelRatio)) {\n      this.pendingSize = [width2, height2, pixelRatio];\n      this.isDirty = true;\n      return true;\n    }\n    return false;\n  }\n  render(opts) {\n    const { debugSplitTimes = { start: performance.now() }, extraDebugStats, seriesRect } = opts ?? {};\n    const {\n      canvas,\n      canvas: { context: ctx } = {},\n      root,\n      pendingSize,\n      width: width2,\n      height: height2,\n      pixelRatio: devicePixelRatio\n    } = this;\n    if (!ctx) {\n      return;\n    }\n    const renderStartTime = performance.now();\n    if (pendingSize) {\n      this.layersManager.resize(...pendingSize);\n      this.pendingSize = null;\n    }\n    if (root && !root.visible) {\n      this.isDirty = false;\n      return;\n    }\n    if (root?.dirty === false && !this.isDirty) {\n      if (this.debug.check()) {\n        this.debug(\"Scene.render() - no-op\", {\n          tree: buildTree(root, \"console\")\n        });\n      }\n      debugStats(this.layersManager, debugSplitTimes, ctx, void 0, extraDebugStats, seriesRect);\n      return;\n    }\n    const renderCtx = {\n      ctx,\n      width: width2,\n      height: height2,\n      devicePixelRatio,\n      debugNodes: {}\n    };\n    if (Debug.check(\"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */)) {\n      renderCtx.stats = {\n        layersRendered: 0,\n        layersSkipped: 0,\n        nodesRendered: 0,\n        nodesSkipped: 0,\n        opsPerformed: 0,\n        opsSkipped: 0\n      };\n    }\n    prepareSceneNodeHighlight(renderCtx);\n    let canvasCleared = false;\n    if (root?.dirty !== false) {\n      canvasCleared = true;\n      canvas.clear();\n    }\n    if (root && Debug.check(\"scene:dirtyTree\" /* SCENE_DIRTY_TREE */)) {\n      const { dirtyTree, paths } = buildDirtyTree(root);\n      Debug.create(\"scene:dirtyTree\" /* SCENE_DIRTY_TREE */)(\"Scene.render() - dirtyTree\", { dirtyTree, paths });\n    }\n    if (root && canvasCleared) {\n      if (root.visible) {\n        root.preRender(renderCtx);\n      }\n      if (this.debug.check()) {\n        const tree = buildTree(root, \"console\");\n        this.debug(\"Scene.render() - before\", {\n          canvasCleared,\n          tree\n        });\n      }\n      if (root.visible) {\n        ctx.save();\n        root.render(renderCtx);\n        ctx.restore();\n      }\n    }\n    debugSplitTimes[\"\\u270D\\uFE0F\"] = performance.now() - renderStartTime;\n    ctx.verifyDepthZero?.();\n    this.isDirty = false;\n    debugStats(this.layersManager, debugSplitTimes, ctx, renderCtx.stats, extraDebugStats, seriesRect);\n    debugSceneNodeHighlight(ctx, renderCtx.debugNodes);\n    if (root && this.debug.check()) {\n      this.debug(\"Scene.render() - after\", {\n        tree: buildTree(root, \"console\"),\n        canvasCleared\n      });\n    }\n  }\n  toSVG() {\n    const { root, width: width2, height: height2 } = this;\n    if (root == null)\n      return;\n    return Node.toSVG(root, width2, height2);\n  }\n  /** Alternative to destroy() that preserves re-usable resources. */\n  strip() {\n    const { context, pixelRatio } = this.canvas;\n    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    this.layersManager.clear();\n    this.setRoot(null);\n    this.isDirty = false;\n  }\n  destroy() {\n    this.strip();\n    this.canvas.destroy();\n    Object.assign(this, { canvas: void 0 });\n  }\n};\nScene.className = \"Scene\";\n\n// packages/ag-charts-community/src/util/callbackCache.ts\nvar CallbackCache = class {\n  constructor() {\n    this.cache = /* @__PURE__ */ new WeakMap();\n  }\n  call(fn, ...params) {\n    let serialisedParams;\n    let paramCache = this.cache.get(fn);\n    try {\n      serialisedParams = JSON.stringify(params);\n    } catch {\n      return this.invoke(fn, params, paramCache);\n    }\n    if (paramCache == null) {\n      paramCache = /* @__PURE__ */ new Map();\n      this.cache.set(fn, paramCache);\n    }\n    if (!paramCache.has(serialisedParams)) {\n      return this.invoke(fn, params, paramCache, serialisedParams);\n    }\n    return paramCache.get(serialisedParams);\n  }\n  invoke(fn, params, paramCache, serialisedParams) {\n    try {\n      const result = fn(...params);\n      if (paramCache && serialisedParams != null) {\n        paramCache.set(serialisedParams, result);\n      }\n      return result;\n    } catch (e) {\n      logger_exports.warnOnce(`User callback errored, ignoring`, e);\n      return;\n    }\n  }\n  invalidateCache() {\n    this.cache = /* @__PURE__ */ new WeakMap();\n  }\n};\n\n// packages/ag-charts-community/src/chart/annotation/annotationManager.ts\nvar AnnotationManager = class extends BaseManager {\n  constructor(annotationRoot) {\n    super();\n    this.annotationRoot = annotationRoot;\n    this.mementoOriginatorKey = \"annotations\";\n    this.annotations = [];\n  }\n  createMemento() {\n    return this.annotations;\n  }\n  guardMemento(blob) {\n    return blob == null || isArray(blob);\n  }\n  restoreMemento(_version, _mementoVersion, memento) {\n    this.annotations = this.cleanData(memento ?? []).map((annotation) => {\n      const annotationTheme = this.getAnnotationTypeStyles(annotation.type);\n      return mergeDefaults(annotation, annotationTheme);\n    });\n    this.listeners.dispatch(\"restore-annotations\", {\n      type: \"restore-annotations\",\n      annotations: this.annotations\n    });\n  }\n  updateData(annotations) {\n    this.annotations = this.cleanData(annotations ?? []);\n  }\n  attachNode(node) {\n    this.annotationRoot.append(node);\n    return () => {\n      this.annotationRoot?.removeChild(node);\n      return this;\n    };\n  }\n  setAnnotationStyles(styles) {\n    this.styles = styles;\n  }\n  getAnnotationTypeStyles(type) {\n    return this.styles?.[type];\n  }\n  cleanData(annotations) {\n    for (const annotation of annotations) {\n      if (\"textAlign\" in annotation)\n        delete annotation.textAlign;\n    }\n    return annotations;\n  }\n};\n\n// packages/ag-charts-community/src/chart/axis/axisManager.ts\nvar AxisManager = class {\n  constructor(sceneRoot) {\n    this.sceneRoot = sceneRoot;\n    this.axes = /* @__PURE__ */ new Map();\n    this.axisGridGroup = new Group({ name: \"Axes-Grids\", zIndex: 1 /* AXIS_GRID */ });\n    this.axisGroup = new Group({ name: \"Axes\", zIndex: 2 /* AXIS */ });\n    this.axisLabelGroup = new Group({ name: \"Axes-Labels\", zIndex: 13 /* SERIES_LABEL */ });\n    this.axisCrosslineRangeGroup = new Group({\n      name: \"Axes-Crosslines-Range\",\n      zIndex: 4 /* SERIES_CROSSLINE_RANGE */\n    });\n    this.axisCrosslineLineGroup = new Group({\n      name: \"Axes-Crosslines-Line\",\n      zIndex: 8 /* SERIES_CROSSLINE_LINE */\n    });\n    this.axisCrosslineLabelGroup = new Group({\n      name: \"Axes-Crosslines-Label\",\n      zIndex: 13 /* SERIES_LABEL */\n    });\n    this.sceneRoot.appendChild(this.axisGroup);\n    this.sceneRoot.appendChild(this.axisGridGroup);\n    this.sceneRoot.appendChild(this.axisLabelGroup);\n    this.sceneRoot.appendChild(this.axisCrosslineRangeGroup);\n    this.sceneRoot.appendChild(this.axisCrosslineLineGroup);\n    this.sceneRoot.appendChild(this.axisCrosslineLabelGroup);\n  }\n  updateAxes(oldAxes, newAxes) {\n    const axisNodes = {\n      axisNode: this.axisGroup,\n      gridNode: this.axisGridGroup,\n      labelNode: this.axisLabelGroup,\n      crossLineRangeNode: this.axisCrosslineRangeGroup,\n      crossLineLineNode: this.axisCrosslineLineGroup,\n      crossLineLabelNode: this.axisCrosslineLabelGroup\n    };\n    for (const axis of oldAxes) {\n      if (newAxes.includes(axis))\n        continue;\n      axis.detachAxis(axisNodes);\n      axis.destroy();\n    }\n    for (const axis of newAxes) {\n      if (oldAxes?.includes(axis))\n        continue;\n      axis.attachAxis(axisNodes);\n    }\n    this.axes.clear();\n    for (const axis of newAxes) {\n      const ctx = axis.createAxisContext();\n      if (this.axes.has(ctx.direction)) {\n        this.axes.get(ctx.direction)?.push(ctx);\n      } else {\n        this.axes.set(ctx.direction, [ctx]);\n      }\n    }\n  }\n  getAxisContext(direction) {\n    return this.axes.get(direction) ?? [];\n  }\n  destroy() {\n    this.axes.clear();\n    this.sceneRoot.removeChild(this.axisGroup);\n    this.sceneRoot.removeChild(this.axisGridGroup);\n  }\n};\n\n// packages/ag-charts-community/src/chart/data/dataService.ts\nvar DataService = class extends Listeners {\n  constructor(animationManager) {\n    super();\n    this.animationManager = animationManager;\n    this.dispatchOnlyLatest = true;\n    this.dispatchThrottle = 0;\n    this.requestThrottle = 300;\n    this.isLoadingInitialData = false;\n    this.isLoadingData = false;\n    this.freshRequests = [];\n    this.requestCounter = 0;\n    this.debug = Debug.create(true, \"data-model\", \"data-source\");\n    this.throttledFetch = this.createThrottledFetch(this.requestThrottle);\n    this.throttledDispatch = this.createThrottledDispatch(this.dispatchThrottle);\n  }\n  updateCallback(dataSourceCallback) {\n    if (typeof dataSourceCallback !== \"function\")\n      return;\n    this.debug(\"DataService - updated data source callback\");\n    this.dataSourceCallback = dataSourceCallback;\n    this.isLoadingInitialData = true;\n    this.animationManager.skip();\n    this.dispatch(\"data-source-change\");\n  }\n  clearCallback() {\n    this.dataSourceCallback = void 0;\n  }\n  load(params) {\n    this.isLoadingData = true;\n    this.throttledFetch(params);\n  }\n  isLazy() {\n    return this.dataSourceCallback != null;\n  }\n  isLoading() {\n    return this.isLazy() && (this.isLoadingInitialData || this.isLoadingData);\n  }\n  createThrottledFetch(requestThrottle) {\n    return throttle(\n      (params) => this.fetch(params).catch((e) => logger_exports.error(\"callback failed\", e)),\n      requestThrottle,\n      {\n        leading: false,\n        trailing: true\n      }\n    );\n  }\n  createThrottledDispatch(dispatchThrottle) {\n    return throttle(\n      (id, data) => {\n        this.debug(`DataService - dispatching 'data-load' | ${id}`);\n        this.dispatch(\"data-load\", { type: \"data-load\", data });\n      },\n      dispatchThrottle,\n      {\n        leading: true,\n        trailing: true\n      }\n    );\n  }\n  async fetch(params) {\n    if (!this.dataSourceCallback) {\n      throw new Error(\"DataService - [dataSource.getData] callback not initialised\");\n    }\n    const start2 = performance.now();\n    const id = this.requestCounter++;\n    this.debug(`DataService - requesting | ${id}`);\n    this.freshRequests.push(id);\n    let response;\n    try {\n      response = await this.dataSourceCallback(params);\n      this.debug(`DataService - response | ${performance.now() - start2}ms | ${id}`);\n    } catch (error2) {\n      this.debug(`DataService - request failed | ${id}`);\n      logger_exports.errorOnce(`DataService - request failed | [${error2}]`);\n    }\n    this.isLoadingInitialData = false;\n    const requestIndex = this.freshRequests.findIndex((rid) => rid === id);\n    if (requestIndex === -1 || this.dispatchOnlyLatest && requestIndex !== this.freshRequests.length - 1) {\n      this.debug(`DataService - discarding stale request | ${id}`);\n      return;\n    }\n    this.freshRequests = this.freshRequests.slice(requestIndex + 1);\n    if (this.freshRequests.length === 0) {\n      this.isLoadingData = false;\n    }\n    if (Array.isArray(response)) {\n      this.throttledDispatch(id, response);\n    } else {\n      this.dispatch(\"data-error\");\n    }\n  }\n};\n__decorateClass([\n  ActionOnSet({\n    newValue(dispatchThrottle) {\n      this.throttledDispatch = this.createThrottledDispatch(dispatchThrottle);\n    }\n  })\n], DataService.prototype, \"dispatchThrottle\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(requestThrottle) {\n      this.throttledFetch = this.createThrottledFetch(requestThrottle);\n    }\n  })\n], DataService.prototype, \"requestThrottle\", 2);\n\n// packages/ag-charts-community/src/chart/interaction/animationBatch.ts\nvar AnimationBatch = class {\n  constructor(maxAnimationTime) {\n    this.maxAnimationTime = maxAnimationTime;\n    this.debug = Debug.create(true, \"animation\");\n    this.controllers = /* @__PURE__ */ new Map();\n    this.stoppedCbs = /* @__PURE__ */ new Set();\n    this.currentPhase = 0;\n    this.phases = new Map(PHASE_ORDER.map((p) => [p, []]));\n    this.skipAnimations = false;\n    this.animationTimeConsumed = 0;\n    /** Guard against premature animation execution. */\n    this.isReady = false;\n  }\n  get size() {\n    return this.controllers.size;\n  }\n  get consumedTimeMs() {\n    return this.animationTimeConsumed;\n  }\n  isActive() {\n    return this.controllers.size > 0;\n  }\n  getActiveControllers() {\n    return this.phases.get(PHASE_ORDER[this.currentPhase]) ?? [];\n  }\n  checkOverlappingId(id) {\n    if (id != null && this.controllers.has(id)) {\n      this.controllers.get(id).stop();\n      this.debug(`Skipping animation batch due to update of existing animation: ${id}`);\n      this.skip();\n    }\n  }\n  addAnimation(animation) {\n    if (animation.isComplete)\n      return;\n    const animationPhaseIdx = PHASE_ORDER.indexOf(animation.phase);\n    if (animationPhaseIdx < this.currentPhase) {\n      this.debug(`Skipping animation due to being for an earlier phase`, animation.id);\n      animation.stop();\n      return;\n    }\n    this.controllers.set(animation.id, animation);\n    this.phases.get(animation.phase)?.push(animation);\n  }\n  removeAnimation(animation) {\n    this.controllers.delete(animation.id);\n    const phase = this.phases.get(animation.phase);\n    const index = phase?.indexOf(animation);\n    if (index != null && index >= 0) {\n      phase?.splice(index, 1);\n    }\n  }\n  progress(deltaTime) {\n    if (!this.isReady)\n      return;\n    let unusedTime = deltaTime === 0 ? 0.01 : deltaTime;\n    const refresh = () => {\n      const phase2 = PHASE_ORDER[this.currentPhase];\n      return {\n        phaseControllers: [...this.getActiveControllers()],\n        phase: phase2,\n        phaseMeta: PHASE_METADATA[phase2]\n      };\n    };\n    let { phase, phaseControllers, phaseMeta } = refresh();\n    const arePhasesComplete = () => PHASE_ORDER[this.currentPhase] == null;\n    const progressPhase = () => {\n      ({ phase, phaseControllers, phaseMeta } = refresh());\n      while (!arePhasesComplete() && phaseControllers.length === 0) {\n        this.currentPhase++;\n        ({ phase, phaseControllers, phaseMeta } = refresh());\n        this.debug(`AnimationBatch - phase changing to ${phase}`, { unusedTime }, phaseControllers);\n      }\n    };\n    const total = this.controllers.size;\n    this.debug(`AnimationBatch - ${deltaTime}ms; phase ${phase} with ${phaseControllers?.length} of ${total}`);\n    do {\n      const phaseDeltaTime = unusedTime;\n      const skipPhase = phaseMeta.skipIfNoEarlierAnimations && this.animationTimeConsumed === 0;\n      let completeCount = 0;\n      for (const controller of phaseControllers) {\n        if (skipPhase) {\n          controller.stop();\n        } else {\n          unusedTime = Math.min(controller.update(phaseDeltaTime), unusedTime);\n        }\n        if (controller.isComplete) {\n          completeCount++;\n          this.removeAnimation(controller);\n        }\n      }\n      this.animationTimeConsumed += phaseDeltaTime - unusedTime;\n      this.debug(`AnimationBatch - updated ${phaseControllers.length} controllers; ${completeCount} completed`);\n      this.debug(`AnimationBatch - animationTimeConsumed: ${this.animationTimeConsumed}`);\n      progressPhase();\n    } while (unusedTime > 0 && !arePhasesComplete());\n    if (this.animationTimeConsumed > this.maxAnimationTime) {\n      this.debug(`Animation batch exceeded max animation time, skipping`, [...this.controllers]);\n      this.stop();\n    }\n  }\n  ready() {\n    if (this.isReady)\n      return;\n    this.isReady = true;\n    this.debug(`AnimationBatch - ready; skipped: ${this.skipAnimations}`, [...this.controllers]);\n    let skipAll = true;\n    for (const [, controller] of this.controllers) {\n      if (controller.duration > 0 && PHASE_METADATA[controller.phase].skipIfNoEarlierAnimations !== true) {\n        skipAll = false;\n        break;\n      }\n    }\n    if (!skipAll) {\n      for (const [, controller] of this.controllers) {\n        if (controller.autoplay) {\n          controller.play(true);\n        }\n      }\n    }\n  }\n  skip(skip = true) {\n    if (this.skipAnimations === false && skip === true) {\n      for (const controller of this.controllers.values()) {\n        controller.stop();\n      }\n      this.controllers.clear();\n    }\n    this.skipAnimations = skip;\n  }\n  play() {\n    for (const controller of this.controllers.values()) {\n      controller.play();\n    }\n  }\n  stop() {\n    for (const controller of this.controllers.values()) {\n      try {\n        controller.stop();\n        this.removeAnimation(controller);\n      } catch (error2) {\n        logger_exports.error(\"Error during animation stop\", error2);\n      }\n    }\n    this.dispatchStopped();\n  }\n  stopByAnimationId(id) {\n    if (id != null && this.controllers.has(id)) {\n      const controller = this.controllers.get(id);\n      if (controller) {\n        controller.stop();\n        this.removeAnimation(controller);\n      }\n    }\n  }\n  stopByAnimationGroupId(id) {\n    for (const controller of this.controllers.values()) {\n      if (controller.groupId === id) {\n        this.stopByAnimationId(controller.id);\n      }\n    }\n  }\n  dispatchStopped() {\n    this.stoppedCbs.forEach((cb) => cb());\n    this.stoppedCbs.clear();\n  }\n  isSkipped() {\n    return this.skipAnimations;\n  }\n  destroy() {\n    this.stop();\n    this.controllers.clear();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/interactionManager.ts\nvar InteractionState = /* @__PURE__ */ ((InteractionState2) => {\n  InteractionState2[InteractionState2[\"Default\"] = 32] = \"Default\";\n  InteractionState2[InteractionState2[\"ZoomDrag\"] = 16] = \"ZoomDrag\";\n  InteractionState2[InteractionState2[\"Annotations\"] = 8] = \"Annotations\";\n  InteractionState2[InteractionState2[\"ContextMenu\"] = 4] = \"ContextMenu\";\n  InteractionState2[InteractionState2[\"Animation\"] = 2] = \"Animation\";\n  InteractionState2[InteractionState2[\"AnnotationsSelected\"] = 1] = \"AnnotationsSelected\";\n  InteractionState2[InteractionState2[\"Clickable\"] = 41] = \"Clickable\";\n  InteractionState2[InteractionState2[\"Focusable\"] = 34] = \"Focusable\";\n  InteractionState2[InteractionState2[\"Keyable\"] = 43] = \"Keyable\";\n  InteractionState2[InteractionState2[\"ContextMenuable\"] = 36] = \"ContextMenuable\";\n  InteractionState2[InteractionState2[\"AnnotationsMoveable\"] = 9] = \"AnnotationsMoveable\";\n  InteractionState2[InteractionState2[\"AnnotationsDraggable\"] = 57] = \"AnnotationsDraggable\";\n  InteractionState2[InteractionState2[\"ZoomDraggable\"] = 50] = \"ZoomDraggable\";\n  InteractionState2[InteractionState2[\"ZoomClickable\"] = 34] = \"ZoomClickable\";\n  InteractionState2[InteractionState2[\"ZoomWheelable\"] = 59] = \"ZoomWheelable\";\n  InteractionState2[InteractionState2[\"All\"] = 63] = \"All\";\n  return InteractionState2;\n})(InteractionState || {});\nvar InteractionManager = class {\n  constructor() {\n    this.stateQueue = 32 /* Default */ | 2 /* Animation */;\n  }\n  pushState(state) {\n    this.stateQueue |= state;\n  }\n  popState(state) {\n    this.stateQueue &= ~state;\n  }\n  isState(allowedStates) {\n    return !!(this.stateQueue & -this.stateQueue & allowedStates);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/animationManager.ts\nfunction validAnimationDuration(testee) {\n  if (testee == null)\n    return true;\n  return !isNaN(testee) && testee >= 0 && testee <= 2;\n}\nvar AnimationManager = class {\n  constructor(interactionManager, chartUpdateMutex) {\n    this.interactionManager = interactionManager;\n    this.chartUpdateMutex = chartUpdateMutex;\n    this.defaultDuration = 1e3;\n    this.batch = new AnimationBatch(this.defaultDuration * 1.5);\n    this.debug = Debug.create(true, \"animation\");\n    this.events = new EventEmitter();\n    this.rafAvailable = typeof requestAnimationFrame !== \"undefined\";\n    this.isPlaying = true;\n    this.requestId = null;\n    this.skipAnimations = true;\n    this.currentAnonymousAnimationId = 0;\n  }\n  addListener(eventName, listener) {\n    return this.events.on(eventName, listener);\n  }\n  /**\n   * Create an animation to tween a value between the `from` and `to` properties. If an animation already exists\n   * with the same `id`, immediately stop it.\n   */\n  animate(opts) {\n    const batch = this.batch;\n    try {\n      batch.checkOverlappingId(opts.id);\n    } catch (error2) {\n      this.failsafeOnError(error2);\n      return;\n    }\n    let { id } = opts;\n    if (id == null) {\n      id = `__${this.currentAnonymousAnimationId}`;\n      this.currentAnonymousAnimationId += 1;\n    }\n    const skip = this.isSkipped() || opts.phase === \"none\";\n    if (skip) {\n      this.debug(\"AnimationManager - skipping animation\");\n    }\n    const { delay, duration } = opts;\n    if (!validAnimationDuration(delay)) {\n      throw new Error(`Animation delay of ${delay} is unsupported (${id})`);\n    }\n    if (!validAnimationDuration(duration)) {\n      throw new Error(`Animation duration of ${duration} is unsupported (${id})`);\n    }\n    const animation = new Animation({\n      ...opts,\n      id,\n      skip,\n      autoplay: this.isPlaying ? opts.autoplay : false,\n      phase: opts.phase,\n      defaultDuration: this.defaultDuration\n    });\n    if (this.forceTimeJump(animation, this.defaultDuration)) {\n      return;\n    }\n    this.batch.addAnimation(animation);\n    return animation;\n  }\n  play() {\n    if (this.isPlaying) {\n      return;\n    }\n    this.isPlaying = true;\n    this.debug(\"AnimationManager.play()\");\n    try {\n      this.batch.play();\n    } catch (error2) {\n      this.failsafeOnError(error2);\n    }\n    this.requestAnimation();\n  }\n  stop() {\n    this.isPlaying = false;\n    this.cancelAnimation();\n    this.debug(\"AnimationManager.stop()\");\n    this.batch.stop();\n  }\n  stopByAnimationId(id) {\n    try {\n      this.batch.stopByAnimationId(id);\n    } catch (error2) {\n      this.failsafeOnError(error2);\n    }\n  }\n  stopByAnimationGroupId(id) {\n    try {\n      this.batch.stopByAnimationGroupId(id);\n    } catch (error2) {\n      this.failsafeOnError(error2);\n    }\n  }\n  reset() {\n    if (this.isPlaying) {\n      this.stop();\n      this.play();\n    } else {\n      this.stop();\n    }\n  }\n  skip(skip = true) {\n    this.skipAnimations = skip;\n  }\n  isSkipped() {\n    return !this.rafAvailable || this.skipAnimations || this.batch.isSkipped();\n  }\n  isActive() {\n    return this.isPlaying && this.batch.isActive();\n  }\n  skipCurrentBatch() {\n    if (this.debug.check()) {\n      this.debug(`AnimationManager - skipCurrentBatch()`, { stack: new Error().stack });\n    }\n    this.batch.skip();\n  }\n  /** Mocking point for tests to guarantee that animation updates happen. */\n  isSkippingFrames() {\n    return true;\n  }\n  /** Mocking point for tests to capture requestAnimationFrame callbacks. */\n  scheduleAnimationFrame(cb) {\n    this.requestId = getWindow().requestAnimationFrame((t) => {\n      cb(t).catch((e) => logger_exports.error(e));\n    });\n  }\n  /** Mocking point for tests to skip animations to a specific point in time. */\n  forceTimeJump(_animation, _defaultDuration) {\n    return false;\n  }\n  requestAnimation() {\n    if (!this.rafAvailable)\n      return;\n    if (!this.batch.isActive() || this.requestId !== null)\n      return;\n    let prevTime;\n    const onAnimationFrame = async (time2) => {\n      const executeAnimationFrame = () => {\n        const deltaTime = time2 - (prevTime ?? time2);\n        prevTime = time2;\n        this.debug(\"AnimationManager - onAnimationFrame()\", {\n          controllersCount: this.batch.size,\n          deltaTime\n        });\n        this.interactionManager.pushState(2 /* Animation */);\n        try {\n          this.batch.progress(deltaTime);\n        } catch (error2) {\n          this.failsafeOnError(error2);\n        }\n        this.events.emit(\"animation-frame\", {\n          type: \"animation-frame\",\n          deltaMs: deltaTime\n        });\n      };\n      if (this.isSkippingFrames()) {\n        await this.chartUpdateMutex.acquireImmediately(executeAnimationFrame);\n      } else {\n        await this.chartUpdateMutex.acquire(executeAnimationFrame);\n      }\n      if (this.batch.isActive()) {\n        this.scheduleAnimationFrame(onAnimationFrame);\n      } else {\n        this.batch.stop();\n        this.events.emit(\"animation-stop\", {\n          type: \"animation-stop\",\n          deltaMs: this.batch.consumedTimeMs\n        });\n      }\n    };\n    this.events.emit(\"animation-start\", {\n      type: \"animation-start\",\n      deltaMs: 0\n    });\n    this.scheduleAnimationFrame(onAnimationFrame);\n  }\n  cancelAnimation() {\n    if (this.requestId === null)\n      return;\n    cancelAnimationFrame(this.requestId);\n    this.requestId = null;\n    this.startBatch();\n  }\n  failsafeOnError(error2, cancelAnimation = true) {\n    logger_exports.error(\"Error during animation, skipping animations\", error2);\n    if (cancelAnimation) {\n      this.cancelAnimation();\n    }\n  }\n  startBatch(skipAnimations) {\n    this.debug(`AnimationManager - startBatch() with skipAnimations=${skipAnimations}.`);\n    this.reset();\n    this.batch.destroy();\n    this.batch = new AnimationBatch(this.defaultDuration * 1.5);\n    if (skipAnimations === true) {\n      this.batch.skip();\n    }\n  }\n  endBatch() {\n    if (this.batch.isActive()) {\n      this.batch.ready();\n      this.requestAnimation();\n    } else {\n      this.interactionManager.popState(2 /* Animation */);\n      if (this.batch.isSkipped()) {\n        this.batch.skip(false);\n      }\n    }\n  }\n  onBatchStop(cb) {\n    this.batch.stoppedCbs.add(cb);\n  }\n  destroy() {\n    this.stop();\n    this.events.clear();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/chartEventManager.ts\nvar ChartEventManager = class extends BaseManager {\n  seriesEvent(type) {\n    this.listeners.dispatch(type, { type });\n  }\n  seriesKeyNavZoom(delta3, widgetEvent) {\n    const event = { type: \"series-keynav-zoom\", delta: delta3, widgetEvent };\n    this.listeners.dispatch(\"series-keynav-zoom\", event);\n  }\n  legendItemClick(legendType, series, itemId, enabled, legendItemName) {\n    const event = {\n      type: \"legend-item-click\",\n      legendType,\n      series,\n      itemId,\n      enabled,\n      legendItemName\n    };\n    this.listeners.dispatch(\"legend-item-click\", event);\n  }\n  legendItemDoubleClick(legendType, series, itemId, enabled, numVisibleItems, legendItemName) {\n    const event = {\n      type: \"legend-item-double-click\",\n      legendType,\n      series,\n      itemId,\n      enabled,\n      legendItemName,\n      numVisibleItems\n    };\n    this.listeners.dispatch(\"legend-item-double-click\", event);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/contextMenuRegistry.ts\nvar ContextMenuRegistry = class {\n  constructor() {\n    this.defaultActions = [];\n    this.disabledActions = /* @__PURE__ */ new Set();\n    this.hiddenActions = /* @__PURE__ */ new Set();\n    this.listeners = new Listeners();\n  }\n  static check(type, event) {\n    return event.type === type;\n  }\n  static checkCallback(desiredType, type, _callback) {\n    return desiredType === type;\n  }\n  dispatchContext(type, pointerEvent, context, position) {\n    const { sourceEvent } = pointerEvent;\n    const x = position?.x ?? pointerEvent.canvasX;\n    const y = position?.y ?? pointerEvent.canvasY;\n    sourceEvent.stopPropagation();\n    const event = { type, x, y, context, sourceEvent };\n    this.listeners.dispatch(\"\", event);\n  }\n  addListener(handler) {\n    return this.listeners.addListener(\"\", handler);\n  }\n  filterActions(type) {\n    return this.defaultActions.filter((action) => {\n      return action.id != null && !this.hiddenActions.has(action.id) && [\"all\", type].includes(action.type);\n    });\n  }\n  registerDefaultAction(action) {\n    const didAdd = action.id != null && !this.defaultActions.some(({ id }) => id === action.id);\n    if (didAdd) {\n      this.defaultActions.push(action);\n    }\n    return () => {\n      const index = didAdd ? this.defaultActions.findIndex(({ id }) => id === action.id) : -1;\n      if (index !== -1) {\n        this.defaultActions.splice(index, 1);\n      }\n    };\n  }\n  enableAction(actionId) {\n    this.disabledActions.delete(actionId);\n  }\n  disableAction(actionId) {\n    this.disabledActions.add(actionId);\n  }\n  showAction(actionId) {\n    this.hiddenActions.add(actionId);\n  }\n  hideAction(actionId) {\n    this.hiddenActions.delete(actionId);\n  }\n  isDisabled(actionId) {\n    return this.disabledActions.has(actionId);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/highlightManager.ts\nvar HighlightManager = class extends BaseManager {\n  constructor() {\n    super(...arguments);\n    this.highlightStates = new StateTracker();\n  }\n  updateHighlight(callerId, highlightedDatum) {\n    const { activeHighlight: previousHighlight } = this;\n    this.highlightStates.set(callerId, highlightedDatum);\n    this.activeHighlight = this.highlightStates.stateValue();\n    if (!this.isEqual(this.activeHighlight, previousHighlight)) {\n      this.listeners.dispatch(\"highlight-change\", {\n        type: \"highlight-change\",\n        currentHighlight: this.activeHighlight,\n        previousHighlight,\n        callerId\n      });\n    }\n  }\n  getActiveHighlight() {\n    return this.activeHighlight;\n  }\n  isEqual(a, b) {\n    return a === b || a != null && b != null && a?.series === b?.series && a?.itemId === b?.itemId && a?.datum === b?.datum;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/util.ts\nfunction datumBoundaryPoints(datum, domain) {\n  if (datum == null || domain.length === 0) {\n    return [false, false];\n  }\n  const datumValue = datum.valueOf();\n  const d0 = domain[0];\n  const d1 = domain[domain.length - 1];\n  if (typeof d0 === \"string\") {\n    return [datumValue === d0, datumValue === d1];\n  }\n  let min = d0.valueOf();\n  let max = d1.valueOf();\n  if (min > max) {\n    [min, max] = [max, min];\n  }\n  return [datumValue === min, datumValue === max];\n}\nfunction datumStylerProperties(datum, xKey, yKey, xDomain, yDomain) {\n  const { xValue, yValue } = datum;\n  const [min, max] = datumBoundaryPoints(yValue, yDomain);\n  const [first2, last] = datumBoundaryPoints(xValue, xDomain);\n  return {\n    datum,\n    xKey,\n    yKey,\n    xValue,\n    yValue,\n    first: first2,\n    last,\n    min,\n    max\n  };\n}\nfunction visibleRangeIndices(length2, [range0, range1], xRange) {\n  const xMinIndex = findMinIndex(0, length2 - 1, (index) => {\n    const x1 = xRange(index)?.[1] ?? NaN;\n    return !Number.isFinite(x1) || x1 > range0;\n  }) ?? 0;\n  let xMaxIndex = findMaxIndex(0, length2 - 1, (index) => {\n    const x0 = xRange(index)?.[0] ?? NaN;\n    return !Number.isFinite(x0) || x0 < range1;\n  }) ?? length2 - 1;\n  xMaxIndex = Math.min(xMaxIndex + 1, length2);\n  return [xMinIndex, xMaxIndex];\n}\nfunction getDatumRefPoint(series, datum) {\n  const refPoint = datum.yBar?.upperPoint ?? datum.midPoint ?? series.datumMidPoint?.(datum);\n  if (refPoint) {\n    const { x, y } = Transformable.toCanvasPoint(series.contentGroup, refPoint.x, refPoint.y);\n    return { canvasX: Math.round(x), canvasY: Math.round(y) };\n  }\n}\nfunction countExpandingSearch(min, max, start2, countUntil, iteratee) {\n  let i = -1;\n  let count = 0;\n  let shift = 0;\n  let reachedAnEnd = false;\n  while (count < countUntil && i <= max - min) {\n    i += 1;\n    const index = start2 + shift;\n    if (!reachedAnEnd)\n      shift *= -1;\n    if (shift >= 0)\n      shift += 1;\n    if (reachedAnEnd && shift < 0)\n      shift -= 1;\n    if (index < min || index > max) {\n      reachedAnEnd = true;\n      continue;\n    }\n    if (iteratee(index))\n      count += 1;\n  }\n  return count;\n}\n\n// packages/ag-charts-community/src/chart/interaction/tooltipManager.ts\nvar TooltipManager = class {\n  constructor(domManager, tooltip) {\n    this.domManager = domManager;\n    this.tooltip = tooltip;\n    this.stateTracker = new StateTracker();\n    this.suppressState = new StateTracker(false);\n    this.appliedState = null;\n    tooltip.setup(domManager);\n    domManager.addListener(\"hidden\", () => this.tooltip.hide());\n  }\n  updateTooltip(callerId, meta, content) {\n    if (!this.tooltip.enabled)\n      return;\n    content ?? (content = this.stateTracker.get(callerId)?.content);\n    this.stateTracker.set(callerId, { content, meta });\n    this.applyStates();\n  }\n  removeTooltip(callerId) {\n    if (!this.tooltip.enabled)\n      return;\n    this.stateTracker.delete(callerId);\n    this.applyStates();\n  }\n  suppressTooltip(callerId) {\n    this.suppressState.set(callerId, true);\n  }\n  unsuppressTooltip(callerId) {\n    this.suppressState.delete(callerId);\n  }\n  destroy() {\n    this.domManager.removeStyles(\"tooltip\");\n  }\n  applyStates() {\n    const id = this.stateTracker.stateId();\n    const state = id ? this.stateTracker.get(id) : null;\n    if (this.suppressState.stateValue() || state?.meta == null || state?.content == null) {\n      this.appliedState = null;\n      this.tooltip.hide();\n      return;\n    }\n    const canvasRect = this.domManager.getBoundingClientRect();\n    const boundingRect = this.tooltip.bounds === \"extended\" ? this.domManager.getOverlayClientRect() : canvasRect;\n    if (this.appliedState?.content === state?.content) {\n      const renderInstantly = this.tooltip.isVisible();\n      this.tooltip.show(boundingRect, canvasRect, state?.meta, null, renderInstantly);\n    } else {\n      this.tooltip.show(boundingRect, canvasRect, state?.meta, state?.content);\n    }\n    this.appliedState = state;\n  }\n  static makeTooltipMeta(event, series, datum) {\n    const { canvasX, canvasY } = event;\n    const tooltip = series.properties.tooltip;\n    const meta = {\n      canvasX,\n      canvasY,\n      enableInteraction: tooltip.interaction?.enabled ?? false,\n      lastPointerEvent: { type: event.type, canvasX, canvasY },\n      showArrow: tooltip.showArrow,\n      position: {\n        type: tooltip.position.type,\n        xOffset: tooltip.position.xOffset,\n        yOffset: tooltip.position.yOffset\n      }\n    };\n    const refPoint = getDatumRefPoint(series, datum);\n    if ((tooltip.position.type === \"node\" || tooltip.position.type === \"sparkline\") && refPoint) {\n      return { ...meta, canvasX: refPoint.canvasX, canvasY: refPoint.canvasY };\n    }\n    return meta;\n  }\n  isEnteringInteractiveTooltip(event) {\n    const { tooltip } = this;\n    const relatedTarget = event.sourceEvent.relatedTarget;\n    return tooltip.interactive && tooltip.enabled && tooltip.isVisible() && tooltip.contains(relatedTarget);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/dragInterpreter.ts\nvar DRAG_THRESHOLD_PX = 3;\nvar DOUBLE_TAP_TIMER_MS = 505;\nfunction makeSynthetic(device, type, event) {\n  const { offsetX, offsetY, clientX, clientY, currentX, currentY, sourceEvent } = event;\n  return { type, device, offsetX, offsetY, clientX, clientY, currentX, currentY, sourceEvent };\n}\nfunction checkDistanceSquared(dx, dy) {\n  const distanceSquared2 = dx * dx + dy * dy;\n  const thresholdSquared = DRAG_THRESHOLD_PX * DRAG_THRESHOLD_PX;\n  return distanceSquared2 >= thresholdSquared;\n}\nvar DragInterpreter = class {\n  constructor(widget) {\n    this.destroyFns = [];\n    this.listeners = new Listeners();\n    this.isDragging = false;\n    this.touch = { distanceTravelledX: 0, distanceTravelledY: 0, clientX: 0, clientY: 0 };\n    this.destroyFns.push(\n      widget.addListener(\"touchstart\", this.onTouchStart.bind(this)),\n      widget.addListener(\"touchmove\", this.onTouchMove.bind(this)),\n      widget.addListener(\"touchend\", this.onTouchEnd.bind(this)),\n      widget.addListener(\"mousemove\", this.onMouseMove.bind(this)),\n      widget.addListener(\"dblclick\", this.onDblClick.bind(this)),\n      widget.addListener(\"drag-start\", this.onDragStart.bind(this)),\n      widget.addListener(\"drag-move\", this.onDragMove.bind(this)),\n      widget.addListener(\"drag-end\", this.onDragEnd.bind(this))\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n    this.listeners.destroy();\n  }\n  addListener(type, handler) {\n    return this.listeners.addListener(type, handler);\n  }\n  dispatch(event) {\n    this.listeners.dispatch(event.type, event);\n  }\n  onTouchStart(e) {\n    const { clientX, clientY } = e.sourceEvent.targetTouches.item(0) ?? { clientX: Infinity, clientY: Infinity };\n    this.touch.distanceTravelledX = 0;\n    this.touch.distanceTravelledY = 0;\n    this.touch.clientX = clientX;\n    this.touch.clientY = clientY;\n  }\n  onTouchMove(e) {\n    const { clientX, clientY } = e.sourceEvent.targetTouches.item(0) ?? { clientX: Infinity, clientY: Infinity };\n    this.touch.distanceTravelledX += Math.abs(this.touch.clientX - clientX);\n    this.touch.distanceTravelledY += Math.abs(this.touch.clientY - clientY);\n    this.touch.clientX = clientX;\n    this.touch.clientY = clientY;\n  }\n  onTouchEnd(event) {\n    event.sourceEvent.preventDefault();\n  }\n  onMouseMove(event) {\n    this.dispatch(event);\n  }\n  onDblClick(event) {\n    this.dispatch({ device: \"mouse\", ...event });\n  }\n  onDragStart(event) {\n    this.dragStartEvent = event;\n  }\n  onDragMove(event) {\n    if (this.dragStartEvent != null) {\n      if (checkDistanceSquared(event.originDeltaX, event.originDeltaY)) {\n        this.dispatch(this.dragStartEvent);\n        this.dispatch({ ...this.dragStartEvent, type: \"drag-move\" });\n        this.dragStartEvent = void 0;\n        this.isDragging = true;\n      }\n    }\n    if (this.isDragging) {\n      this.dispatch(event);\n    }\n  }\n  onDragEnd(event) {\n    if (this.isDragging) {\n      this.dispatch(event);\n      this.isDragging = false;\n      return;\n    }\n    if (event.device === \"mouse\") {\n      const click = makeSynthetic(\"mouse\", \"click\", event);\n      this.dispatch(click);\n    } else if (event.sourceEvent.type === \"touchend\") {\n      if (checkDistanceSquared(this.touch.distanceTravelledX, this.touch.distanceTravelledY)) {\n        return;\n      }\n      const click = makeSynthetic(\"touch\", \"click\", event);\n      this.dispatch(click);\n      const now = Date.now();\n      if (this.lastClickTime !== void 0 && now - this.lastClickTime <= DOUBLE_TAP_TIMER_MS) {\n        const dblClick = makeSynthetic(event.device, \"dblclick\", event);\n        this.dispatch(dblClick);\n        this.lastClickTime = void 0;\n      } else {\n        this.lastClickTime = now;\n      }\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/widgetSet.ts\nvar DOMManagerWidget = class extends NativeWidget {\n  constructor(elem) {\n    super(elem);\n  }\n  addChildToDOM() {\n  }\n  removeChildFromDOM() {\n  }\n};\nvar WidgetSet = class {\n  constructor(domManager) {\n    this.seriesWidget = new DOMManagerWidget(domManager.getParent(\"series-area\"));\n    this.chartWidget = new DOMManagerWidget(domManager.getParent(\"canvas-proxy\"));\n    this.containerWidget = new DOMManagerWidget(domManager.getParent(\"canvas-container\"));\n    this.containerWidget.addChild(this.chartWidget);\n    this.chartWidget.addChild(this.seriesWidget);\n    this.seriesDragInterpreter = new DragInterpreter(this.seriesWidget);\n  }\n  destroy() {\n    this.seriesDragInterpreter.destroy();\n    this.seriesWidget.destroy();\n    this.chartWidget.destroy();\n    this.containerWidget.destroy();\n  }\n};\n\n// packages/ag-charts-community/src/util/vector4.ts\nvar Vec4 = {\n  bottomCenter,\n  center,\n  clone,\n  collides,\n  end,\n  from,\n  height,\n  round: round2,\n  start,\n  topCenter,\n  origin,\n  width\n};\nfunction start(a) {\n  return { x: a.x1, y: a.y1 };\n}\nfunction end(a) {\n  return { x: a.x2, y: a.y2 };\n}\nfunction topCenter(a) {\n  return { x: (a.x1 + a.x2) / 2, y: Math.min(a.y1, a.y2) };\n}\nfunction center(a) {\n  return { x: (a.x1 + a.x2) / 2, y: (a.y1 + a.y2) / 2 };\n}\nfunction bottomCenter(a) {\n  return { x: (a.x1 + a.x2) / 2, y: Math.max(a.y1, a.y2) };\n}\nfunction width(a) {\n  return Math.abs(a.x2 - a.x1);\n}\nfunction height(a) {\n  return Math.abs(a.y2 - a.y1);\n}\nfunction round2(a) {\n  return { x1: Math.round(a.x1), y1: Math.round(a.y1), x2: Math.round(a.x2), y2: Math.round(a.y2) };\n}\nfunction clone(a) {\n  return { x1: a.x1, y1: a.y1, x2: a.x2, y2: a.y2 };\n}\nfunction collides(a, b) {\n  const an = normalise(a);\n  const bn = normalise(b);\n  return an.x1 <= bn.x2 && an.x2 >= bn.x1 && an.y1 <= bn.y2 && an.y2 >= bn.y1;\n}\nfunction normalise(a) {\n  return { x1: Math.min(a.x1, a.x2), x2: Math.max(a.x1, a.x2), y1: Math.min(a.y1, a.y2), y2: Math.max(a.y1, a.y2) };\n}\nfunction from(a, b, c, d) {\n  if (typeof a === \"number\") {\n    return { x1: a, y1: b, x2: c, y2: d };\n  }\n  if (\"width\" in a) {\n    return {\n      x1: a.x,\n      y1: a.y,\n      x2: a.x + a.width,\n      y2: a.y + a.height\n    };\n  }\n  throw new Error(`Values can not be converted into a vector4: [${JSON.stringify(a)}] [${b}] [${c}] [${d}]`);\n}\nfunction origin() {\n  return { x1: 0, y1: 0, x2: 0, y2: 0 };\n}\n\n// packages/ag-charts-community/src/util/panToBBox.ts\nfunction normalize2(screenMin, min, screenMax, max, target) {\n  return min + (max - min) * ((target - screenMin) / (screenMax - screenMin));\n}\nfunction unnormalize(screenMin, min, screenMax, max, ratio2) {\n  return screenMin + (ratio2 - min) * ((screenMax - screenMin) / (max - min));\n}\nfunction calcWorldAxis(viewportMin, viewportMax, ratio2) {\n  return [\n    unnormalize(viewportMin, ratio2.min, viewportMax, ratio2.max, 0),\n    unnormalize(viewportMin, ratio2.min, viewportMax, ratio2.max, 1)\n  ];\n}\nfunction calcWorldVec4(viewport, ratioX, ratioY) {\n  const [x1, x2] = calcWorldAxis(viewport.x1, viewport.x2, ratioX);\n  const [y1, y2] = calcWorldAxis(viewport.y1, viewport.y2, ratioY);\n  return { x1, x2, y1, y2 };\n}\nfunction panAxesUnnormalized(worldMin, worldMax, viewportMin, viewportMax, targetMin, targetMax) {\n  if (viewportMin <= targetMin && targetMax <= viewportMax)\n    return viewportMin;\n  const minDiff = targetMin - viewportMin;\n  const maxDiff = targetMax - viewportMax;\n  const diff2 = Math.abs(minDiff) < Math.abs(maxDiff) ? minDiff : maxDiff;\n  return clamp(worldMin, viewportMin + diff2, worldMax);\n}\nfunction calcPanToBBoxRatios(viewportBBox, ratios, targetBBox) {\n  const { x: ratioX = { min: 0, max: 1 }, y: ratioY = { min: 0, max: 1 } } = ratios;\n  const target = Vec4.from(targetBBox);\n  const viewport = Vec4.from(viewportBBox);\n  const world = calcWorldVec4(viewport, ratioX, ratioY);\n  const x = panAxesUnnormalized(world.x1, world.x2, viewport.x1, viewport.x2, target.x1, target.x2);\n  const y = panAxesUnnormalized(world.y1, world.y2, viewport.y1, viewport.y2, target.y1, target.y2);\n  return {\n    x: {\n      min: normalize2(viewport.x1, ratioX.min, viewport.x2, ratioX.max, x),\n      max: normalize2(viewport.x1, ratioX.min, viewport.x2, ratioX.max, x + viewportBBox.width)\n    },\n    y: {\n      min: normalize2(viewport.y1, ratioY.min, viewport.y2, ratioY.max, y),\n      max: normalize2(viewport.y1, ratioY.min, viewport.y2, ratioY.max, y + viewportBBox.height)\n    }\n  };\n}\n\n// packages/ag-charts-community/src/chart/interaction/zoomManager.ts\nvar expectedMementoKeys = [\"rangeX\", \"rangeY\", \"ratioX\", \"ratioY\", \"autoScaledAxes\"];\nvar ZoomManagerAutoScaleAxis = class {\n  constructor() {\n    this.enabled = false;\n    this.padding = 0;\n    this.manuallyAdjusted = false;\n  }\n};\nvar rangeValidator = (axis) => attachDescription((value, context) => {\n  if (!ContinuousScale.is(axis?.scale) && !OrdinalTimeScale.is(axis?.scale))\n    return true;\n  if (value == null || context.end == null)\n    return true;\n  return value <= context.end;\n}, `to be less than end`);\nvar ZoomManager = class extends BaseManager {\n  constructor(fireChartEvent, layoutManager) {\n    super();\n    this.fireChartEvent = fireChartEvent;\n    this.mementoOriginatorKey = \"zoom\";\n    this.axisZoomManagers = /* @__PURE__ */ new Map();\n    this.state = new StateTracker(void 0, \"initial\");\n    this.axes = [];\n    this.didLayoutAxes = false;\n    this.autoScaleYAxis = new ZoomManagerAutoScaleAxis();\n    this.lastRestoredState = void 0;\n    this.independentAxes = false;\n    this.navigatorModule = false;\n    this.zoomModule = false;\n    // The initial state memento can not be restored until the chart has performed its first layout. Instead save it as\n    // pending and restore then delete it on the first layout.\n    this.pendingMemento = void 0;\n    this.destroyFns.push(\n      layoutManager.addListener(\"layout:complete\", () => {\n        const { pendingMemento } = this;\n        const shouldPerformInitialLayout = !this.didLayoutAxes;\n        this.didLayoutAxes = true;\n        if (pendingMemento) {\n          this.restoreMemento(pendingMemento.version, pendingMemento.mementoVersion, pendingMemento.memento);\n        } else if (shouldPerformInitialLayout) {\n          this.autoScaleYZoom(\"zoom-manager\");\n        }\n      })\n    );\n  }\n  createMemento() {\n    return this.getMementoRanges();\n  }\n  guardMemento(blob, messages) {\n    if (blob == null)\n      return true;\n    if (!isObject(blob))\n      return false;\n    for (const key of Object.keys(blob)) {\n      if (!expectedMementoKeys.includes(key)) {\n        return false;\n      }\n    }\n    const primaryX = this.getPrimaryAxis(\"x\" /* X */);\n    const primaryY = this.getPrimaryAxis(\"y\" /* Y */);\n    const zoomMementoDefs = {\n      rangeX: { start: and(or(number, date), rangeValidator(primaryX)), end: or(number, date) },\n      rangeY: { start: and(or(number, date), rangeValidator(primaryY)), end: or(number, date) },\n      ratioX: { start: and(ratio, lessThan(\"end\")), end: ratio },\n      ratioY: { start: and(ratio, lessThan(\"end\")), end: ratio },\n      autoScaledAxes: arrayOf(union(\"y\"))\n    };\n    const result = validate(blob, zoomMementoDefs);\n    if (result.errors.length > 0) {\n      messages.push(...result.errors.map((e) => e.message));\n      return false;\n    }\n    return true;\n  }\n  restoreMemento(version, mementoVersion, memento) {\n    const { independentAxes } = this;\n    if (!this.axes || !this.didLayoutAxes) {\n      this.pendingMemento = { version, mementoVersion, memento };\n      return;\n    }\n    this.pendingMemento = void 0;\n    const zoom = this.getDefinedZoom();\n    if (memento?.rangeX) {\n      zoom.x = this.rangeToRatio(memento.rangeX, \"x\" /* X */) ?? { min: 0, max: 1 };\n    } else if (memento?.ratioX) {\n      zoom.x = {\n        min: memento.ratioX.start ?? 0,\n        max: memento.ratioX.end ?? 1\n      };\n    } else {\n      zoom.x = { min: 0, max: 1 };\n    }\n    if (!this.navigatorModule || this.zoomModule) {\n      let yAutoScale = memento?.autoScaledAxes?.includes(\"y\");\n      if (memento?.rangeY) {\n        zoom.y = this.rangeToRatio(memento.rangeY, \"y\" /* Y */) ?? { min: 0, max: 1 };\n        yAutoScale ?? (yAutoScale = false);\n      } else if (memento?.ratioY) {\n        zoom.y = {\n          min: memento.ratioY.start ?? 0,\n          max: memento.ratioY.end ?? 1\n        };\n        yAutoScale ?? (yAutoScale = false);\n      } else {\n        zoom.y = { min: 0, max: 1 };\n        yAutoScale ?? (yAutoScale = true);\n      }\n      zoom.autoScaleYAxis = yAutoScale;\n    }\n    this.lastRestoredState = zoom;\n    if (independentAxes !== true) {\n      this.updateZoom(\"zoom-manager\", zoom);\n      return;\n    }\n    const primaryX = this.getPrimaryAxis(\"x\" /* X */);\n    const primaryY = this.getPrimaryAxis(\"y\" /* Y */);\n    for (const axis of [primaryX, primaryY]) {\n      if (!axis)\n        continue;\n      this.updateAxisZoom(\"zoom-manager\", axis.id, zoom[axis.direction]);\n    }\n  }\n  updateAxes(axes) {\n    this.axes = axes;\n    const zoomManagers = new Map(axes.map((axis) => [axis.id, this.axisZoomManagers.get(axis.id)]));\n    this.axisZoomManagers.clear();\n    for (const axis of axes) {\n      this.axisZoomManagers.set(axis.id, zoomManagers.get(axis.id) ?? new AxisZoomManager(axis));\n    }\n    if (this.state.size > 0 && axes.length > 0) {\n      this.updateZoom(this.state.stateId(), this.state.stateValue());\n    }\n  }\n  setIndependentAxes(independent = true) {\n    this.independentAxes = independent;\n  }\n  setAutoScaleYAxis(enabled, padding) {\n    this.autoScaleYAxis.enabled = enabled;\n    this.autoScaleYAxis.padding = padding;\n  }\n  setNavigatorEnabled(enabled = true) {\n    this.navigatorModule = enabled;\n  }\n  setZoomModuleEnabled(enabled = true) {\n    this.zoomModule = enabled;\n  }\n  isZoomEnabled() {\n    return this.zoomModule;\n  }\n  updateZoom(callerId, newZoom) {\n    if (newZoom?.x && (newZoom.x.min < 0 || newZoom.x.max > 1)) {\n      logger_exports.warnOnce(\n        `Attempted to update x-axis zoom to an invalid ratio of [{ min: ${newZoom.x.min}, max: ${newZoom.x.max} }], expecting a ratio of 0 to 1, ignoring.`\n      );\n      newZoom.x = void 0;\n    }\n    if (newZoom?.y && (newZoom.y.min < 0 || newZoom.y.max > 1)) {\n      logger_exports.warnOnce(\n        `Attempted to update y-axis zoom to an invalid ratio of [{ min: ${newZoom.y.min}, max: ${newZoom.y.max} }], expecting a ratio of 0 to 1, ignoring.`\n      );\n      newZoom.y = void 0;\n    }\n    if (this.axisZoomManagers.size === 0) {\n      const stateId = this.state.stateId();\n      if (stateId === \"initial\" || stateId === callerId) {\n        this.state.set(callerId, newZoom);\n      }\n      return;\n    }\n    this.state.set(callerId, newZoom);\n    const autoScaleYAxis = newZoom?.autoScaleYAxis;\n    if (autoScaleYAxis != null) {\n      this.autoScaleYAxis.manuallyAdjusted = !autoScaleYAxis;\n    }\n    this.axisZoomManagers.forEach((axis) => {\n      axis.updateZoom(callerId, newZoom?.[axis.getDirection()]);\n    });\n    this.applyChanges(callerId);\n  }\n  updateAxisZoom(callerId, axisId, newZoom) {\n    this.axisZoomManagers.get(axisId)?.updateZoom(callerId, newZoom);\n    this.applyChanges(callerId);\n  }\n  resetZoom(callerId) {\n    this.autoScaleYAxis.manuallyAdjusted = false;\n    const zoom = this.getRestoredZoom();\n    this.updateZoom(callerId, {\n      x: { min: zoom?.x?.min ?? 0, max: zoom?.x?.max ?? 1 },\n      y: { min: zoom?.y?.min ?? 0, max: zoom?.y?.max ?? 1 },\n      autoScaleYAxis: zoom?.autoScaleYAxis ?? true\n    });\n  }\n  resetAxisZoom(callerId, axisId) {\n    const axisZoomManager = this.axisZoomManagers.get(axisId);\n    const direction = axisZoomManager?.getDirection();\n    if (direction == null)\n      return;\n    const restoredZoom = this.getRestoredZoom();\n    if (direction === \"y\" /* Y */) {\n      const autoScaleYAxis = restoredZoom?.autoScaleYAxis ?? true;\n      this.autoScaleYAxis.manuallyAdjusted = !autoScaleYAxis;\n    }\n    this.updateAxisZoom(callerId, axisId, restoredZoom?.[direction] ?? { min: 0, max: 1 });\n  }\n  setAxisManuallyAdjusted(_callerId, axisId) {\n    const direction = this.axisZoomManagers.get(axisId)?.getDirection();\n    if (direction !== \"y\" /* Y */)\n      return;\n    this.autoScaleYAxis.manuallyAdjusted = true;\n  }\n  updatePrimaryAxisZoom(callerId, direction, newZoom) {\n    const primaryAxis = this.getPrimaryAxis(direction);\n    if (!primaryAxis)\n      return;\n    this.updateAxisZoom(callerId, primaryAxis.id, newZoom);\n  }\n  panToBBox(callerId, seriesRect, target) {\n    if (!this.isZoomEnabled())\n      return false;\n    const zoom = this.getZoom();\n    if (zoom === void 0 || !zoom.x && !zoom.y)\n      return false;\n    const panIsPossible = seriesRect.width > 0 && seriesRect.height > 0 && Math.abs(target.width) <= Math.abs(seriesRect.width) && Math.abs(target.height) <= Math.abs(seriesRect.height);\n    if (!panIsPossible) {\n      logger_exports.warnOnce(`cannot pan to target BBox - chart too small?`);\n      return false;\n    }\n    const newZoom = calcPanToBBoxRatios(seriesRect, zoom, target);\n    if (this.independentAxes) {\n      this.updatePrimaryAxisZoom(callerId, \"x\" /* X */, newZoom.x);\n      this.updatePrimaryAxisZoom(callerId, \"y\" /* Y */, newZoom.y);\n    } else {\n      this.updateZoom(callerId, newZoom);\n    }\n    return true;\n  }\n  // Fire this event to signal to listeners that the view is changing through a zoom and/or pan change.\n  fireZoomPanStartEvent(callerId) {\n    this.listeners.dispatch(\"zoom-pan-start\", { type: \"zoom-pan-start\", callerId });\n  }\n  extendToEnd(callerId, direction, extent2) {\n    return this.extendWith(callerId, direction, (end2) => Number(end2) - extent2);\n  }\n  extendWith(callerId, direction, fn) {\n    const axis = this.getPrimaryAxis(direction);\n    if (!axis)\n      return;\n    const extents = this.getDomainExtents(axis);\n    if (!extents)\n      return;\n    const [, end2] = extents;\n    const start2 = fn(end2);\n    const ratio2 = this.rangeToRatio({ start: start2, end: end2 }, direction);\n    if (!ratio2)\n      return;\n    this.updateZoom(callerId, { [direction]: ratio2 });\n  }\n  updateWith(callerId, direction, fn) {\n    const axis = this.getPrimaryAxis(direction);\n    if (!axis)\n      return;\n    const extents = this.getDomainExtents(axis);\n    if (!extents)\n      return;\n    let [start2, end2] = extents;\n    [start2, end2] = fn(start2, end2);\n    const ratio2 = this.rangeToRatio({ start: start2, end: end2 }, direction);\n    if (!ratio2)\n      return;\n    this.updateZoom(callerId, { [direction]: ratio2 });\n  }\n  getZoom() {\n    let x;\n    let y;\n    this.axisZoomManagers.forEach((axis) => {\n      if (axis.getDirection() === \"x\" /* X */) {\n        x ?? (x = axis.getZoom());\n      } else if (axis.getDirection() === \"y\" /* Y */) {\n        y ?? (y = axis.getZoom());\n      }\n    });\n    if (x || y) {\n      return { x, y };\n    }\n  }\n  getAxisZoom(axisId) {\n    return this.axisZoomManagers.get(axisId)?.getZoom() ?? { min: 0, max: 1 };\n  }\n  getAxisZooms() {\n    const axes = {};\n    for (const [axisId, axis] of this.axisZoomManagers.entries()) {\n      axes[axisId] = {\n        direction: axis.getDirection(),\n        zoom: axis.getZoom()\n      };\n    }\n    return axes;\n  }\n  getRestoredZoom() {\n    return this.lastRestoredState;\n  }\n  getPrimaryAxisId(direction) {\n    return this.getPrimaryAxis(direction)?.id;\n  }\n  isVisibleItemsCountAtLeast(zoom, minVisibleItems) {\n    const xAxis = this.getPrimaryAxis(\"x\" /* X */);\n    const yAxis = this.getPrimaryAxis(\"y\" /* Y */);\n    const processedSeriesIds = /* @__PURE__ */ new Set();\n    let visibleItemsCount = 0;\n    const xVisibleRange = [zoom.x.min, zoom.x.max];\n    const yVisibleRange = [zoom.y.min, zoom.y.max];\n    for (const series of xAxis?.boundSeries ?? []) {\n      processedSeriesIds.add(series.id);\n      const remainingItems = minVisibleItems - (visibleItemsCount ?? 0);\n      const seriesVisibleItems = series.getVisibleItems(xVisibleRange, yVisibleRange, remainingItems);\n      visibleItemsCount += seriesVisibleItems;\n      if (visibleItemsCount >= minVisibleItems)\n        return true;\n    }\n    for (const series of yAxis?.boundSeries ?? []) {\n      if (processedSeriesIds.has(series.id))\n        continue;\n      const remainingItems = minVisibleItems - (visibleItemsCount ?? 0);\n      const seriesVisibleItems = series.getVisibleItems(xVisibleRange, yVisibleRange, remainingItems);\n      visibleItemsCount += seriesVisibleItems;\n      if (visibleItemsCount >= minVisibleItems)\n        return true;\n    }\n    return processedSeriesIds.size === 0;\n  }\n  getMementoRanges() {\n    const zoom = this.getDefinedZoom();\n    let autoScaledAxes;\n    if (this.autoScaleYAxis.enabled) {\n      autoScaledAxes = this.autoScaleYAxis.manuallyAdjusted ? [] : [\"y\"];\n    }\n    const memento = {\n      rangeX: this.getRangeDirection(zoom.x, \"x\" /* X */),\n      rangeY: this.getRangeDirection(zoom.y, \"y\" /* Y */),\n      ratioX: { start: zoom.x.min, end: zoom.x.max },\n      ratioY: { start: zoom.y.min, end: zoom.y.max },\n      autoScaledAxes\n    };\n    return memento;\n  }\n  autoScaleYZoom(callerId, applyChanges = true) {\n    if (!this.isZoomEnabled())\n      return;\n    const { independentAxes, autoScaleYAxis } = this;\n    const zoom = this.getZoom();\n    if (zoom?.x == null || !autoScaleYAxis.enabled || autoScaleYAxis.manuallyAdjusted)\n      return;\n    const { padding } = autoScaleYAxis;\n    let zoomY;\n    if (zoom.x?.min === 0 && zoom.x?.max === 1) {\n      zoomY = { min: 0, max: 1 };\n    } else if (independentAxes) {\n      zoomY = this.primaryAxisZoom(\"y\" /* Y */, zoom.x, { padding });\n    } else {\n      zoomY = this.combinedAxisZoom(\"y\" /* Y */, zoom.x, { padding });\n    }\n    if (zoomY == null)\n      return;\n    if (independentAxes) {\n      const primaryAxis = this.getPrimaryAxis(\"y\" /* Y */);\n      const primaryAxisManager = primaryAxis == null ? void 0 : this.axisZoomManagers.get(primaryAxis.id);\n      primaryAxisManager?.updateZoom(\"zoom-manager\", zoomY);\n    } else {\n      for (const axisZoomManager of this.axisZoomManagers.values()) {\n        if (axisZoomManager.getDirection() === \"y\" /* Y */) {\n          axisZoomManager.updateZoom(\"zoom-manager\", zoomY);\n        }\n      }\n    }\n    if (applyChanges) {\n      this.applyChanges(callerId);\n    }\n  }\n  applyChanges(callerId) {\n    this.autoScaleYZoom(callerId, false);\n    const changed = Array.from(this.axisZoomManagers.values(), (axis) => axis.applyChanges()).includes(true);\n    if (!changed) {\n      return;\n    }\n    const axes = {};\n    for (const [axisId, axis] of this.axisZoomManagers.entries()) {\n      axes[axisId] = axis.getZoom();\n    }\n    this.listeners.dispatch(\"zoom-change\", { type: \"zoom-change\", ...this.getZoom(), axes, callerId });\n    this.fireChartEvent({ type: \"zoom\", ...this.getMementoRanges() });\n  }\n  getRangeDirection(ratio2, direction) {\n    const axis = this.getPrimaryAxis(direction);\n    if (!axis || !ContinuousScale.is(axis.scale) && !OrdinalTimeScale.is(axis.scale))\n      return;\n    const extents = this.getDomainPixelExtents(axis);\n    if (!extents)\n      return;\n    const [d0, d1] = extents;\n    let start2;\n    let end2;\n    if (d0 <= d1) {\n      start2 = axis.scale.invert(0);\n      end2 = axis.scale.invert(d0 + (d1 - d0) * ratio2.max);\n    } else {\n      start2 = axis.scale.invert(d0 - (d0 - d1) * ratio2.min);\n      end2 = axis.scale.invert(0);\n    }\n    return { start: start2, end: end2 };\n  }\n  rangeToRatio(range3, direction) {\n    const axis = this.getPrimaryAxis(direction);\n    if (!axis)\n      return;\n    const extents = this.getDomainPixelExtents(axis);\n    if (!extents)\n      return;\n    const [d0, d1] = extents;\n    let r0 = range3.start == null ? d0 : axis.scale.convert?.(range3.start);\n    let r1 = range3.end == null ? d1 : axis.scale.convert?.(range3.end);\n    if (!isFiniteNumber(r0) || !isFiniteNumber(r1))\n      return;\n    const [dMin, dMax] = [Math.min(d0, d1), Math.max(d0, d1)];\n    if (r0 < dMin || r0 > dMax) {\n      logger_exports.warnOnce(\n        `Invalid range start [${range3.start}], expecting a value between [${axis.scale.invert?.(d0)}] and [${axis.scale.invert?.(d1)}], ignoring.`\n      );\n      return;\n    }\n    if (r1 < dMin || r1 > dMax) {\n      logger_exports.warnOnce(\n        `Invalid range end [${range3.end}], expecting a value between [${axis.scale.invert?.(d0)}] and [${axis.scale.invert?.(d1)}], ignoring.`\n      );\n      return;\n    }\n    r0 = Math.min(dMax, Math.max(dMin, r0));\n    r1 = Math.min(dMax, Math.max(dMin, r1));\n    const diff2 = d1 - d0;\n    const min = Math.abs((r0 - d0) / diff2);\n    const max = Math.abs((r1 - d0) / diff2);\n    return { min, max };\n  }\n  getPrimaryAxis(direction) {\n    return this.axes?.find((a) => a.direction === direction);\n  }\n  getDomainExtents(axis) {\n    const { domain } = axis.scale;\n    const d0 = domain.at(0);\n    const d1 = domain.at(-1);\n    if (d0 == null || d1 == null)\n      return;\n    return [d0, d1];\n  }\n  getDomainPixelExtents(axis) {\n    const { domain } = axis.scale;\n    const d0 = axis.scale.convert?.(domain.at(0));\n    const d1 = axis.scale.convert?.(domain.at(-1));\n    if (!isFiniteNumber(d0) || !isFiniteNumber(d1))\n      return;\n    return [d0, d1];\n  }\n  getDefinedZoom() {\n    const zoom = this.getZoom();\n    return {\n      x: { min: zoom?.x?.min ?? 0, max: zoom?.x?.max ?? 1 },\n      y: { min: zoom?.y?.min ?? 0, max: zoom?.y?.max ?? 1 }\n    };\n  }\n  zoomBounds(xAxis, yAxis, zoom, padding) {\n    const xScale = xAxis.scale;\n    const xScaleRange = xScale.range;\n    xScale.range = [0, 1];\n    const yScale = yAxis.scale;\n    const yScaleRange = yScale.range;\n    yScale.range = [0, 1];\n    let min = 1;\n    let minPadding = false;\n    let max = 0;\n    let maxPadding = false;\n    for (const series of yAxis.boundSeries) {\n      const { connectsToYAxis } = series;\n      const yValues = series.getRange(\"y\" /* Y */, [zoom.min, zoom.max]);\n      for (const yValue of yValues) {\n        const y = yScale.convert(yValue);\n        if (!Number.isFinite(y))\n          continue;\n        if (y < min) {\n          min = y;\n          minPadding = !connectsToYAxis || yValue < 0;\n        }\n        if (y > max) {\n          max = y;\n          maxPadding = !connectsToYAxis || yValue > 0;\n        }\n      }\n    }\n    if (isFiniteNumber(yAxis.min)) {\n      min = 0;\n    }\n    if (isFiniteNumber(yAxis.max)) {\n      max = 1;\n    }\n    xScale.range = xScaleRange;\n    yScale.range = yScaleRange;\n    if (min >= max)\n      return;\n    const totalPadding = (minPadding ? padding : 0) + (maxPadding ? padding : 0);\n    const paddedDelta = Math.min((max - min) * (1 + totalPadding), 1);\n    if (paddedDelta <= 0)\n      return;\n    if (minPadding && maxPadding) {\n      const mid = (max + min) / 2;\n      min = mid - paddedDelta / 2;\n      max = mid + paddedDelta / 2;\n    } else if (!minPadding && maxPadding) {\n      max = min + paddedDelta;\n    } else if (minPadding && !maxPadding) {\n      min = max - paddedDelta;\n    }\n    if (min < 0) {\n      max += -min;\n      min = 0;\n    } else if (max > 1) {\n      min -= max - 1;\n      max = 1;\n    }\n    return { min, max };\n  }\n  primaryAxisZoom(direction, zoom, { padding = 0 } = {}) {\n    const crossDirection = direction === \"x\" /* X */ ? \"y\" /* Y */ : \"x\" /* X */;\n    const xAxis = this.getPrimaryAxis(crossDirection);\n    const yAxis = this.getPrimaryAxis(direction);\n    if (xAxis == null || yAxis == null)\n      return;\n    return this.zoomBounds(xAxis, yAxis, zoom, padding);\n  }\n  combinedAxisZoom(direction, zoom, { padding = 0 } = {}) {\n    const crossDirection = direction === \"x\" /* X */ ? \"y\" /* Y */ : \"x\" /* X */;\n    const seriesXAxes = /* @__PURE__ */ new Map();\n    for (const xAxis of this.axes) {\n      if (xAxis.direction !== crossDirection)\n        continue;\n      for (const series of xAxis.boundSeries) {\n        seriesXAxes.set(series, xAxis);\n      }\n    }\n    let min = 1;\n    let max = 0;\n    for (const yAxis of this.axes) {\n      if (yAxis.direction !== direction)\n        continue;\n      for (const series of yAxis.boundSeries) {\n        const xAxis = seriesXAxes.get(series);\n        if (xAxis == null)\n          continue;\n        const bounds = this.zoomBounds(xAxis, yAxis, zoom, padding);\n        if (bounds == null)\n          return;\n        min = Math.min(min, bounds.min);\n        max = Math.max(max, bounds.max);\n      }\n    }\n    const delta3 = 1e-6;\n    if (min < delta3)\n      min = 0;\n    if (max > 1 - delta3)\n      max = 1;\n    if (min > max)\n      return;\n    return { min, max };\n  }\n};\nvar AxisZoomManager = class {\n  constructor(axis) {\n    this.axis = axis;\n    const [min = 0, max = 1] = axis.visibleRange;\n    this.state = new StateTracker({ min, max });\n    this.currentZoom = this.state.stateValue();\n  }\n  getDirection() {\n    return this.axis.direction;\n  }\n  updateZoom(callerId, newZoom) {\n    this.state.set(callerId, newZoom);\n  }\n  getZoom() {\n    return deepClone(this.state.stateValue());\n  }\n  hasChanges() {\n    const currentZoom = this.currentZoom;\n    const pendingZoom = this.state.stateValue();\n    return currentZoom.min !== pendingZoom.min || currentZoom.max !== pendingZoom.max;\n  }\n  applyChanges() {\n    const hasChanges = this.hasChanges();\n    this.currentZoom = this.state.stateValue();\n    return hasChanges;\n  }\n};\n\n// packages/ag-charts-community/src/chart/layout/seriesLabelLayoutManager.ts\nvar SeriesLabelLayoutManager = class {\n  constructor() {\n    this.labelData = /* @__PURE__ */ new Map();\n  }\n  updateLabels(placedLabelSeries, padding, seriesRect = BBox.zero) {\n    const bounds = {\n      x: -padding.left,\n      y: -padding.top,\n      width: seriesRect.width + padding.left + padding.right,\n      height: seriesRect.height + padding.top + padding.bottom\n    };\n    const expectedSeriesId = new Set(placedLabelSeries.map((s) => s.id));\n    for (const seriesId of this.labelData.keys()) {\n      if (!expectedSeriesId.has(seriesId)) {\n        this.labelData.delete(seriesId);\n      }\n    }\n    for (const series of placedLabelSeries) {\n      const labelData = series.getLabelData();\n      if (labelData.every(isPointLabelDatum)) {\n        this.labelData.set(series.id, labelData);\n      }\n    }\n    const placedLabels = placeLabels(this.labelData, bounds, 5);\n    for (const series of placedLabelSeries) {\n      series.updatePlacedLabelData?.(placedLabels.get(series.id) ?? []);\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/legend/legendManager.ts\nvar LegendManager = class extends BaseManager {\n  constructor() {\n    super(...arguments);\n    this.mementoOriginatorKey = \"legend\";\n    this.legendDataMap = /* @__PURE__ */ new Map();\n  }\n  createMemento() {\n    return this.getData().filter(({ hideInLegend, isFixed }) => !hideInLegend && !isFixed).map(({ enabled, seriesId, itemId, legendItemName }) => ({\n      visible: enabled,\n      seriesId,\n      itemId,\n      legendItemName\n    }));\n  }\n  guardMemento(blob) {\n    return blob == null || isArray(blob);\n  }\n  restoreMemento(_version, _mementoVersion, memento) {\n    memento?.forEach((datum) => {\n      const { seriesId, data } = this.getRestoredData(datum) ?? {};\n      if (!seriesId || !data) {\n        return;\n      }\n      this.updateData(seriesId, data);\n    });\n    this.update();\n  }\n  getRestoredData(datum) {\n    const { seriesId, itemId, legendItemName, visible } = datum;\n    if (seriesId) {\n      const legendData = this.legendDataMap.get(seriesId) ?? [];\n      const data = legendData.map((d) => {\n        const match = d.seriesId === seriesId && (!itemId || d.itemId === itemId);\n        if (match && d.isFixed) {\n          this.warnFixed(d.seriesId, d.itemId);\n        }\n        return !d.isFixed && match ? { ...d, enabled: visible } : d;\n      });\n      return { seriesId, data };\n    }\n    if (itemId == null && legendItemName == null) {\n      return;\n    }\n    for (const legendDatum of this.getData()) {\n      if (itemId != null && legendDatum.itemId !== itemId || legendItemName != null && legendDatum.legendItemName !== legendItemName) {\n        continue;\n      }\n      if (legendDatum.isFixed) {\n        this.warnFixed(legendDatum.seriesId, itemId);\n        return;\n      }\n      const seriesLegendData = (this.legendDataMap.get(legendDatum.seriesId) ?? []).map(\n        (d) => d.itemId === itemId || d.legendItemName === legendItemName ? { ...d, enabled: visible } : d\n      );\n      return {\n        seriesId: legendDatum.seriesId,\n        data: seriesLegendData\n      };\n    }\n  }\n  warnFixed(seriesId, itemId) {\n    logger_exports.warnOnce(\n      `The legend item with seriesId [${seriesId}] and itemId [${itemId}] is not configurable, this series item cannot be toggled through the legend.`\n    );\n  }\n  update(data) {\n    this.listeners.dispatch(\"legend-change\", {\n      type: \"legend-change\",\n      legendData: data ?? this.getData()\n    });\n  }\n  updateData(seriesId, data = []) {\n    this.legendDataMap.set(seriesId, data);\n  }\n  clearData() {\n    this.legendDataMap.clear();\n  }\n  toggleItem({\n    enabled,\n    seriesId,\n    itemId,\n    legendItemName\n  }) {\n    if (legendItemName) {\n      this.getData().forEach((datum) => {\n        const newData = (this.legendDataMap.get(datum.seriesId) ?? []).map(\n          (d) => d.legendItemName === legendItemName ? { ...d, enabled } : d\n        );\n        this.updateData(datum.seriesId, newData);\n      });\n      return;\n    }\n    const seriesLegendData = this.getData(seriesId);\n    const singleLegendItem = seriesLegendData.length === 1;\n    const data = seriesLegendData.map(\n      (datum) => itemId == null && singleLegendItem || datum.itemId === itemId ? { ...datum, enabled } : datum\n    );\n    this.updateData(seriesId, data);\n  }\n  getData(seriesId) {\n    if (seriesId) {\n      return this.legendDataMap.get(seriesId) ?? [];\n    }\n    return [...this.legendDataMap].reduce(\n      (data, [_, legendData]) => data.concat(legendData),\n      []\n    );\n  }\n  getDatum({ seriesId, itemId } = {}) {\n    return this.getData(seriesId).find((datum) => datum.itemId === itemId);\n  }\n  getSeriesEnabled(seriesId) {\n    const data = this.getData(seriesId);\n    if (data.length > 0) {\n      return data.some((d) => d.enabled);\n    }\n  }\n  getItemEnabled({ seriesId, itemId } = {}) {\n    return this.getDatum({ seriesId, itemId })?.enabled ?? true;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesStateManager.ts\nvar SeriesStateManager = class {\n  constructor() {\n    this.groups = {};\n  }\n  registerSeries({ internalId, seriesGrouping, visible, type }) {\n    var _a;\n    if (!seriesGrouping)\n      return;\n    (_a = this.groups)[type] ?? (_a[type] = {});\n    this.groups[type][internalId] = { grouping: seriesGrouping, visible };\n  }\n  updateSeries({ internalId, seriesGrouping, visible, type }) {\n    if (!seriesGrouping)\n      return;\n    const entry = this.groups[type]?.[internalId];\n    if (entry) {\n      entry.grouping = seriesGrouping;\n      entry.visible = visible;\n    }\n  }\n  deregisterSeries({ internalId, type }) {\n    if (this.groups[type]) {\n      delete this.groups[type][internalId];\n    }\n    if (this.groups[type] && Object.keys(this.groups[type]).length === 0) {\n      delete this.groups[type];\n    }\n  }\n  getVisiblePeerGroupIndex({ type, seriesGrouping, visible }) {\n    if (!seriesGrouping) {\n      return { visibleGroupCount: visible ? 1 : 0, visibleSameStackCount: visible ? 1 : 0, index: 0 };\n    }\n    const visibleGroupsSet = /* @__PURE__ */ new Set();\n    const visibleSameStackSet = /* @__PURE__ */ new Set();\n    for (const entry of Object.values(this.groups[type] ?? {})) {\n      if (!entry.visible)\n        continue;\n      visibleGroupsSet.add(entry.grouping.groupIndex);\n      if (entry.grouping.groupIndex === seriesGrouping.groupIndex) {\n        visibleSameStackSet.add(entry.grouping.stackIndex);\n      }\n    }\n    const visibleGroups = Array.from(visibleGroupsSet);\n    visibleGroups.sort((a, b) => a - b);\n    return {\n      visibleGroupCount: visibleGroups.length,\n      visibleSameStackCount: visibleSameStackSet.size,\n      index: visibleGroups.indexOf(seriesGrouping.groupIndex)\n    };\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartUpdateType.ts\nvar ChartUpdateType = /* @__PURE__ */ ((ChartUpdateType2) => {\n  ChartUpdateType2[ChartUpdateType2[\"FULL\"] = 0] = \"FULL\";\n  ChartUpdateType2[ChartUpdateType2[\"UPDATE_DATA\"] = 1] = \"UPDATE_DATA\";\n  ChartUpdateType2[ChartUpdateType2[\"PROCESS_DATA\"] = 2] = \"PROCESS_DATA\";\n  ChartUpdateType2[ChartUpdateType2[\"PERFORM_LAYOUT\"] = 3] = \"PERFORM_LAYOUT\";\n  ChartUpdateType2[ChartUpdateType2[\"SERIES_UPDATE\"] = 4] = \"SERIES_UPDATE\";\n  ChartUpdateType2[ChartUpdateType2[\"PRE_SCENE_RENDER\"] = 5] = \"PRE_SCENE_RENDER\";\n  ChartUpdateType2[ChartUpdateType2[\"SCENE_RENDER\"] = 6] = \"SCENE_RENDER\";\n  ChartUpdateType2[ChartUpdateType2[\"NONE\"] = 7] = \"NONE\";\n  return ChartUpdateType2;\n})(ChartUpdateType || {});\n\n// packages/ag-charts-community/src/chart/updateService.ts\nvar UpdateService = class {\n  constructor(updateCallback) {\n    this.updateCallback = updateCallback;\n    this.events = new EventEmitter();\n  }\n  addListener(eventName, listener) {\n    return this.events.on(eventName, listener);\n  }\n  removeListener(eventName, listener) {\n    return this.events.on(eventName, listener);\n  }\n  destroy() {\n    this.events.clear();\n  }\n  update(type = 0 /* FULL */, options) {\n    this.updateCallback(type, options);\n  }\n  dispatchUpdateComplete() {\n    this.events.emit(\"update-complete\", { type: \"update-complete\" });\n  }\n  dispatchPreDomUpdate() {\n    this.events.emit(\"pre-dom-update\", { type: \"pre-dom-update\" });\n  }\n  dispatchPreSceneRender() {\n    this.events.emit(\"pre-scene-render\", { type: \"pre-scene-render\" });\n  }\n  dispatchProcessData({ series }) {\n    this.events.emit(\"process-data\", { type: \"process-data\", series });\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartContext.ts\nvar ChartContext = class {\n  constructor(chart, vars) {\n    this.callbackCache = new CallbackCache();\n    this.chartEventManager = new ChartEventManager();\n    this.highlightManager = new HighlightManager();\n    this.layoutManager = new LayoutManager();\n    this.localeManager = new LocaleManager();\n    this.seriesStateManager = new SeriesStateManager();\n    this.stateManager = new StateManager();\n    this.seriesLabelLayoutManager = new SeriesLabelLayoutManager();\n    this.contextModules = [];\n    const {\n      scene,\n      root,\n      syncManager,\n      container,\n      fireEvent,\n      updateCallback,\n      updateMutex,\n      styleContainer,\n      chartType\n    } = vars;\n    this.chartService = chart;\n    this.syncManager = syncManager;\n    this.domManager = new DOMManager(container, styleContainer);\n    this.widgets = new WidgetSet(this.domManager);\n    const canvasElement = this.domManager.addChild(\n      \"canvas\",\n      \"scene-canvas\",\n      scene?.canvas.element\n    );\n    this.scene = scene ?? new Scene({ canvasElement });\n    this.scene.setRoot(root);\n    this.axisManager = new AxisManager(root);\n    this.legendManager = new LegendManager();\n    this.annotationManager = new AnnotationManager(chart.annotationRoot);\n    this.chartTypeOriginator = new ChartTypeOriginator(chart);\n    this.interactionManager = new InteractionManager();\n    this.contextMenuRegistry = new ContextMenuRegistry();\n    this.updateService = new UpdateService(updateCallback);\n    this.proxyInteractionService = new ProxyInteractionService(this.localeManager, this.domManager);\n    this.historyManager = new HistoryManager(this.chartEventManager);\n    this.animationManager = new AnimationManager(this.interactionManager, updateMutex);\n    this.dataService = new DataService(this.animationManager);\n    this.tooltipManager = new TooltipManager(this.domManager, chart.tooltip);\n    this.zoomManager = new ZoomManager(fireEvent, this.layoutManager);\n    for (const module of moduleRegistry.byType(\"context\")) {\n      if (!module.chartTypes.includes(chartType))\n        continue;\n      const moduleInstance = module.moduleFactory(this);\n      this.contextModules.push(moduleInstance);\n      this[module.contextKey] = moduleInstance;\n    }\n  }\n  destroy() {\n    this.animationManager.destroy();\n    this.highlightManager.destroy();\n    this.axisManager.destroy();\n    this.callbackCache.invalidateCache();\n    this.chartEventManager.destroy();\n    this.domManager.destroy();\n    this.highlightManager.destroy();\n    this.proxyInteractionService.destroy();\n    this.syncManager.destroy();\n    this.tooltipManager.destroy();\n    this.zoomManager.destroy();\n    this.widgets.destroy();\n    this.contextModules.forEach((m) => m.destroy());\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartHighlight.ts\nvar ChartHighlight = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.range = \"tooltip\";\n  }\n};\n__decorateClass([\n  Validate(UNION([\"tooltip\", \"node\"], \"a range\"))\n], ChartHighlight.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/chart/data/caching.ts\nfunction setsEqual(a, b) {\n  if (a.size !== b.size)\n    return false;\n  for (const value of a) {\n    if (!b.has(value))\n      return false;\n  }\n  return true;\n}\nfunction idsMapEqual(a, b) {\n  if (a == null || b == null)\n    return a === b;\n  if (a.size !== b.size)\n    return false;\n  for (const [key, aValue] of a) {\n    const bValue = b.get(key);\n    if (bValue == null)\n      return false;\n    if (!setsEqual(aValue, bValue))\n      return false;\n  }\n  return true;\n}\nfunction propsEqual(a, b) {\n  if (a.length !== b.length)\n    return false;\n  for (let i = 0; i < a.length; i += 1) {\n    const { type: typeA, idsMap: idsMapA, scopes: scopesA, data: dataA, ...propA } = a[i];\n    const { type: typeB, idsMap: idsMapB, scopes: scopesB, data: dataB, ...propB } = b[i];\n    if (typeA !== typeB)\n      return false;\n    if (scopesA && scopesB && !arraysEqual(scopesA, scopesB))\n      return false;\n    if (dataA && dataB && dataA !== dataB)\n      return false;\n    if (!objectsEqual(propA, propB) || !idsMapEqual(idsMapA, idsMapB))\n      return false;\n  }\n  return true;\n}\nfunction optsEqual(a, b) {\n  const { props: propsA, ...restA } = a;\n  const { props: propsB, ...restB } = b;\n  return objectsEqual(restA, restB) && propsEqual(propsA, propsB);\n}\nfunction canReuseCachedData(cachedDataItem, data, ids, opts) {\n  return data === cachedDataItem.data && arraysEqual(ids, cachedDataItem.ids) && optsEqual(opts, cachedDataItem.opts);\n}\n\n// packages/ag-charts-community/src/chart/data/dataDomain.ts\nvar DiscreteDomain = class _DiscreteDomain {\n  constructor() {\n    this.domain = /* @__PURE__ */ new Set();\n  }\n  static is(value) {\n    return value instanceof _DiscreteDomain;\n  }\n  extend(val) {\n    this.domain.add(val);\n  }\n  getDomain() {\n    return Array.from(this.domain);\n  }\n};\nvar ContinuousDomain = class _ContinuousDomain {\n  constructor() {\n    this.domain = [Infinity, -Infinity];\n  }\n  static is(value) {\n    return value instanceof _ContinuousDomain;\n  }\n  static extendDomain(values, domain = [Infinity, -Infinity]) {\n    for (const value of values) {\n      if (typeof value !== \"number\") {\n        continue;\n      }\n      if (domain[0] > value) {\n        domain[0] = value;\n      }\n      if (domain[1] < value) {\n        domain[1] = value;\n      }\n    }\n    return domain;\n  }\n  extend(value) {\n    if (this.domain[0] > value) {\n      this.domain[0] = value;\n    }\n    if (this.domain[1] < value) {\n      this.domain[1] = value;\n    }\n  }\n  getDomain() {\n    return [...this.domain];\n  }\n};\n\n// packages/ag-charts-community/src/chart/data/rangeLookup.ts\nvar MIN = 0;\nvar MAX = 1;\nvar SPAN = 2;\nvar RangeLookup = class {\n  constructor(allValues) {\n    const dataLength = allValues.reduce((acc, v) => Math.max(acc, v.length), 0);\n    const sizePower = 32 - Math.clz32(dataLength);\n    let maxLevelSize = 1 << sizePower;\n    if (dataLength === maxLevelSize / 2) {\n      maxLevelSize = maxLevelSize >>> 1;\n    }\n    this.maxLevelSize = maxLevelSize;\n    const buffer = new Float64Array((maxLevelSize * 2 - 1) * 2).fill(NaN);\n    for (const values of allValues) {\n      for (let i = 0; i < values.length; i += 1) {\n        const value = Number(values[i]);\n        const bufferIndex = maxLevelSize + i - 1;\n        const bufferMinIndex = (bufferIndex * SPAN | 0) + MIN;\n        const bufferMaxIndex = (bufferIndex * SPAN | 0) + MAX;\n        const prevMinValue = buffer[bufferMinIndex];\n        const prevMaxValue = buffer[bufferMaxIndex];\n        if (!Number.isFinite(prevMinValue) || value < prevMinValue) {\n          buffer[bufferMinIndex] = value;\n        }\n        if (!Number.isFinite(prevMaxValue) || value > prevMaxValue) {\n          buffer[bufferMaxIndex] = value;\n        }\n      }\n    }\n    for (let size = maxLevelSize / 2 | 0; size >= 1; size = size / 2 | 0) {\n      const start2 = size - 1 | 0;\n      const end2 = start2 + size | 0;\n      for (let i = 0; i < size; i += 1) {\n        const nodeIndex = start2 + i;\n        const leftIndex = end2 + i * 2;\n        const rightIndex = leftIndex + 1;\n        const aMin = buffer[(leftIndex * SPAN | 0) + MIN];\n        const bMin = buffer[(rightIndex * SPAN | 0) + MIN];\n        buffer[(nodeIndex * SPAN | 0) + MIN] = !Number.isFinite(bMin) || aMin < bMin ? aMin : bMin;\n        const aMax = buffer[(leftIndex * SPAN | 0) + MAX];\n        const bMax = buffer[(rightIndex * SPAN | 0) + MAX];\n        buffer[(nodeIndex * SPAN | 0) + MAX] = !Number.isFinite(bMax) || aMax > bMax ? aMax : bMax;\n      }\n    }\n    this.buffer = buffer;\n  }\n  computeRangeInto(buffer, start2, end2, bufferIndex, currentStart, step, into) {\n    const currentEnd = currentStart + step - 1;\n    if (currentEnd < start2 || currentStart >= end2)\n      return into;\n    if (currentStart >= start2 && currentEnd < end2) {\n      const min = buffer[(bufferIndex * SPAN | 0) + MIN];\n      const max = buffer[(bufferIndex * SPAN | 0) + MAX];\n      if (Number.isFinite(min))\n        into[0] = Math.min(into[0], min);\n      if (Number.isFinite(max))\n        into[1] = Math.max(into[1], max);\n    } else if (step > 1) {\n      bufferIndex = bufferIndex * 2 | 0;\n      step = step / 2 | 0;\n      this.computeRangeInto(buffer, start2, end2, bufferIndex + 1 | 0, currentStart, step, into);\n      this.computeRangeInto(buffer, start2, end2, bufferIndex + 2 | 0, currentStart + step, step, into);\n    }\n    return into;\n  }\n  rangeBetween(start2, end2) {\n    if (start2 > end2)\n      return [NaN, NaN];\n    const { maxLevelSize, buffer } = this;\n    const range3 = [Infinity, -Infinity];\n    this.computeRangeInto(buffer, start2, end2, 0, 0, maxLevelSize, range3);\n    return range3;\n  }\n  get range() {\n    const { buffer } = this;\n    return [buffer[MIN], buffer[MAX]];\n  }\n};\n\n// packages/ag-charts-community/src/chart/data/dataModel.ts\nvar DOMAIN_RANGES = Symbol(\"domain-ranges\");\nfunction toKeyString(keys) {\n  return keys.map((key) => isObject(key) ? JSON.stringify(key) : key).join(\"-\");\n}\nfunction round3(val) {\n  const accuracy = 1e4;\n  if (Number.isInteger(val)) {\n    return val;\n  } else if (Math.abs(val) > accuracy) {\n    return Math.trunc(val);\n  }\n  return Math.round(val * accuracy) / accuracy;\n}\nfunction fixNumericExtent(extent2) {\n  const numberExtent = extent2?.map(Number);\n  return numberExtent?.every(Number.isFinite) ? numberExtent : [];\n}\nfunction getMissCount(scopeProvider, missMap) {\n  return missMap?.get(scopeProvider.id) ?? 0;\n}\nfunction isScoped(obj) {\n  return \"scopes\" in obj && Array.isArray(obj.scopes);\n}\nvar INVALID_VALUE = Symbol(\"invalid\");\nfunction createArray(length2, value) {\n  const out = [];\n  for (let i = 0; i < length2; i += 1) {\n    out[i] = value;\n  }\n  return out;\n}\nfunction datumKeys(keys, columnScope, datumIndex) {\n  const out = [];\n  for (const k of keys) {\n    const key = k.get(columnScope)?.[datumIndex];\n    if (key == null)\n      return;\n    out.push(key);\n  }\n  return out;\n}\nfunction getPathComponents(path) {\n  const components = [];\n  let matchIndex = 0;\n  let matchGroup;\n  const regExp = /((?:(?:^|\\.)\\s*\\w+|\\[\\s*(?:'(?:[^']|(?<!\\\\)\\\\')*'|\"(?:[^\"]|(?<!\\\\)\\\\\")*\"|-?\\d+)\\s*\\])\\s*)/g;\n  while (matchGroup = regExp.exec(path)) {\n    if (matchGroup.index !== matchIndex) {\n      return;\n    }\n    matchIndex = matchGroup.index + matchGroup[0].length;\n    const match = matchGroup[1].trim();\n    if (match.startsWith(\".\")) {\n      components.push(match.slice(1).trim());\n    } else if (match.startsWith(\"[\")) {\n      const accessor = match.slice(1, -1).trim();\n      if (accessor.startsWith(`'`)) {\n        components.push(accessor.slice(1, -1).replace(/(?<!\\\\)\\\\'/g, `'`));\n      } else if (accessor.startsWith(`\"`)) {\n        components.push(accessor.slice(1, -1).replace(/(?<!\\\\)\\\\\"/g, `\"`));\n      } else {\n        components.push(accessor);\n      }\n    } else {\n      components.push(match);\n    }\n  }\n  if (matchIndex !== path.length)\n    return;\n  return components;\n}\nfunction createPathAccessor(components) {\n  return (datum) => {\n    let current = datum;\n    for (const component of components) {\n      current = current[component];\n    }\n    return current;\n  };\n}\nvar DataModel = class {\n  constructor(opts, mode = \"standalone\", suppressFieldDotNotation = false) {\n    this.opts = opts;\n    this.mode = mode;\n    this.suppressFieldDotNotation = suppressFieldDotNotation;\n    this.debug = Debug.create(true, \"data-model\");\n    this.scopeCache = /* @__PURE__ */ new Map();\n    this.keys = [];\n    this.values = [];\n    this.aggregates = [];\n    this.groupProcessors = [];\n    this.propertyProcessors = [];\n    this.reducers = [];\n    this.processors = [];\n    this.markScopeDatumInvalid = function(scopes, data, datumIndex, invalidData) {\n      for (const scope of scopes) {\n        if (!invalidData.has(scope)) {\n          invalidData.set(scope, createArray(data.length, false));\n        }\n        invalidData.get(scope)[datumIndex] = true;\n      }\n    };\n    let keys = true;\n    for (const next of opts.props) {\n      if (next.type === \"key\" && !keys) {\n        throw new Error(\"AG Charts - internal config error: keys must come before values.\");\n      }\n      if (next.type === \"value\" && keys) {\n        keys = false;\n      }\n    }\n    const verifyMatchGroupId = ({ matchGroupIds = [] }) => {\n      for (const matchGroupId of matchGroupIds) {\n        if (this.values.every((def) => def.groupId !== matchGroupId)) {\n          throw new Error(\n            `AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchGroupId}).`\n          );\n        }\n      }\n    };\n    const keyScopes = /* @__PURE__ */ new Set();\n    const valueScopes = /* @__PURE__ */ new Set();\n    for (const def of opts.props) {\n      const scopes = def.type === \"key\" ? keyScopes : valueScopes;\n      if (isScoped(def)) {\n        def.scopes?.forEach((s) => scopes.add(s));\n      }\n      switch (def.type) {\n        case \"key\":\n          this.keys.push({ ...def, index: this.keys.length, missing: /* @__PURE__ */ new Map() });\n          break;\n        case \"value\":\n          if (def.property == null) {\n            throw new Error(\n              `AG Charts - internal config error: no properties specified for value definitions: ${JSON.stringify(\n                def\n              )}`\n            );\n          }\n          this.values.push({ ...def, index: this.values.length, missing: /* @__PURE__ */ new Map() });\n          break;\n        case \"aggregate\":\n          verifyMatchGroupId(def);\n          this.aggregates.push({ ...def, index: this.aggregates.length });\n          break;\n        case \"group-value-processor\":\n          verifyMatchGroupId(def);\n          this.groupProcessors.push({ ...def, index: this.groupProcessors.length });\n          break;\n        case \"property-value-processor\":\n          this.propertyProcessors.push({ ...def, index: this.propertyProcessors.length });\n          break;\n        case \"reducer\":\n          this.reducers.push({ ...def, index: this.reducers.length });\n          break;\n        case \"processor\":\n          this.processors.push({ ...def, index: this.processors.length });\n          break;\n      }\n    }\n    if (!!this.opts.groupByKeys || this.opts.groupByFn != null) {\n      const ungroupedScopes = new Set(valueScopes.values());\n      keyScopes.forEach((s) => ungroupedScopes.delete(s));\n      if (ungroupedScopes.size > 0) {\n        throw new Error(\n          `AG Charts - scopes missing key for grouping, illegal configuration: ${[...ungroupedScopes.values()]}`\n        );\n      }\n    }\n  }\n  resolveProcessedDataDefById(scope, searchId) {\n    const def = this.scopeCache.get(scope.id)?.get(searchId);\n    if (!def) {\n      throw new Error(`AG Charts - didn't find property definition for [${searchId}, ${scope.id}]`);\n    }\n    return { index: def.index, def };\n  }\n  resolveProcessedDataIndexById(scope, searchId) {\n    return this.resolveProcessedDataDefById(scope, searchId).index;\n  }\n  resolveKeysById(scope, searchId, processedData) {\n    const index = this.resolveProcessedDataIndexById(scope, searchId);\n    const keys = processedData.keys[index];\n    if (keys == null) {\n      throw new Error(`AG Charts - didn't find keys for [${searchId}, ${scope.id}]`);\n    }\n    return keys.get(scope.id);\n  }\n  hasColumnById(scope, searchId) {\n    return this.scopeCache.get(scope.id)?.get(searchId) != null;\n  }\n  resolveColumnById(scope, searchId, processedData) {\n    const index = this.resolveProcessedDataIndexById(scope, searchId);\n    const column = processedData.columns?.[index];\n    if (column == null) {\n      throw new Error(`AG Charts - didn't find column for [${searchId}, ${scope.id}]`);\n    }\n    return column;\n  }\n  /**\n   * Provides a convenience iterator to iterate over all of the extract datum values in a\n   * specific DataGroup.\n   *\n   * @param scope to which datums should belong\n   * @param group containing the datums\n   * @param processedData containing the group\n   */\n  *forEachDatum(scope, processedData, group) {\n    const columnIndex = processedData.columnScopes.findIndex((s) => s.has(scope.id));\n    for (const datumIndex of group.datumIndices[columnIndex] ?? []) {\n      yield processedData.columns[columnIndex][datumIndex];\n    }\n  }\n  /**\n   * Provides a convenience iterator to iterate over all of the extracted datum values in a\n   * GroupedData.\n   *\n   * @param scope to which datums should belong\n   * @param processedData to iterate through\n   */\n  *forEachGroupDatum(scope, processedData) {\n    const columnIndex = processedData.columnScopes.findIndex((s) => s.has(scope.id));\n    const output = {\n      groupIndex: 0,\n      columnIndex\n    };\n    const empty = [];\n    for (const group of processedData.groups) {\n      output.group = group;\n      let valueIndex = 0;\n      for (const datumIndex of group.datumIndices[columnIndex] ?? empty) {\n        output.datumIndex = datumIndex;\n        output.valueIndex = valueIndex++;\n        yield output;\n      }\n      output.groupIndex++;\n    }\n  }\n  /**\n   * Provides a window-based convenience iterator to iterate over all of the extracted datum\n   * values in a GroupedData, including the previous and next entries relative to each datum.\n   *\n   * @param scope to which datums should belong\n   * @param processedData to iterate through\n   */\n  *forEachGroupDatumTuple(scope, processedData) {\n    const columnIndex = processedData.columnScopes.findIndex((s) => s.has(scope.id));\n    const output = { columnIndex, datumIndexes: [void 0, void 0, void 0] };\n    for (const next of this.forEachGroupDatum(scope, processedData)) {\n      output.group = output.nextGroup;\n      output.groupIndex = output.nextGroupIndex;\n      output.nextGroup = next.group;\n      output.nextGroupIndex = next.groupIndex;\n      output.datumIndexes[0] = output.datumIndexes[1];\n      output.datumIndexes[1] = output.datumIndexes[2];\n      output.datumIndexes[2] = next.datumIndex;\n      if (output.group != null && output.datumIndexes[1] != null) {\n        yield output;\n      }\n    }\n    output.group = output.nextGroup;\n    output.groupIndex = output.nextGroupIndex;\n    output.nextGroup = void 0;\n    output.nextGroupIndex = void 0;\n    output.datumIndexes[0] = output.datumIndexes[1];\n    output.datumIndexes[1] = output.datumIndexes[2];\n    output.datumIndexes[2] = void 0;\n    if (output.group != null && output.datumIndexes[1] != null) {\n      yield output;\n    }\n  }\n  getDomain(scope, searchId, type, processedData) {\n    const domains = this.getDomainsByType(type ?? \"value\", processedData);\n    return domains?.[this.resolveProcessedDataIndexById(scope, searchId)] ?? [];\n  }\n  getDomainBetweenRange(scope, searchIds, [i0, i1], processedData) {\n    const columnIndices = searchIds.map((searchId) => this.resolveProcessedDataIndexById(scope, searchId));\n    const cacheKey = columnIndices.join(\":\");\n    const domainRanges = processedData[DOMAIN_RANGES];\n    let rangeLookup = domainRanges.get(cacheKey);\n    if (rangeLookup == null) {\n      const values = columnIndices.map((columnIndex) => processedData.columns[columnIndex]);\n      rangeLookup = new RangeLookup(values);\n      domainRanges.set(cacheKey, rangeLookup);\n    }\n    return rangeLookup.rangeBetween(i0, i1);\n  }\n  getDomainsByType(type, processedData) {\n    switch (type) {\n      case \"key\":\n        return processedData.domain.keys;\n      case \"value\":\n        return processedData.domain.values;\n      case \"aggregate\":\n        return processedData.domain.aggValues;\n      case \"group-value-processor\":\n        return processedData.domain.groups;\n      default:\n        return null;\n    }\n  }\n  processData(sources) {\n    const {\n      opts: { groupByKeys, groupByFn },\n      aggregates,\n      groupProcessors,\n      reducers,\n      processors,\n      propertyProcessors\n    } = this;\n    const start2 = performance.now();\n    if (groupByKeys && this.keys.length === 0) {\n      return;\n    }\n    let processedData = this.extractData(sources);\n    if (groupByKeys) {\n      processedData = this.groupData(processedData);\n    } else if (groupByFn) {\n      processedData = this.groupData(processedData, groupByFn(processedData));\n    }\n    if (groupProcessors.length > 0 && processedData.type === \"grouped\") {\n      this.postProcessGroups(processedData);\n    }\n    if (aggregates.length > 0 && processedData.type === \"ungrouped\") {\n      this.aggregateUngroupedData(processedData);\n    } else if (aggregates.length > 0 && processedData.type === \"grouped\") {\n      this.aggregateGroupedData(processedData);\n    }\n    if (propertyProcessors.length > 0) {\n      this.postProcessProperties(processedData);\n    }\n    if (reducers.length > 0) {\n      this.reduceData(processedData);\n    }\n    if (processors.length > 0) {\n      this.postProcessData(processedData);\n    }\n    this.warnDataMissingProperties(sources);\n    const end2 = performance.now();\n    processedData.time = end2 - start2;\n    if (this.debug.check()) {\n      logProcessedData(processedData);\n    }\n    this.processScopeCache();\n    return processedData;\n  }\n  warnDataMissingProperties(sources) {\n    if (sources.size === 0)\n      return;\n    for (const def of iterate(this.keys, this.values)) {\n      for (const [scope, missCount] of def.missing) {\n        if (missCount < (sources.get(scope)?.length ?? Infinity))\n          continue;\n        const scopeHint = scope == null ? \"\" : ` for ${scope}`;\n        logger_exports.warnOnce(`the key '${def.property}' was not found in any data element${scopeHint}.`);\n      }\n    }\n  }\n  processScopeCache() {\n    this.scopeCache.clear();\n    for (const def of iterate(this.keys, this.values, this.aggregates)) {\n      if (!def.idsMap)\n        continue;\n      for (const [scope, ids] of def.idsMap) {\n        for (const id of ids) {\n          if (!this.scopeCache.has(scope)) {\n            this.scopeCache.set(scope, /* @__PURE__ */ new Map([[id, def]]));\n          } else if (this.scopeCache.get(scope)?.has(id)) {\n            throw new Error(\"duplicate definition ids on the same scope are not allowed.\");\n          } else {\n            this.scopeCache.get(scope).set(id, def);\n          }\n        }\n      }\n    }\n  }\n  valueGroupIdxLookup({ matchGroupIds }) {\n    const result = [];\n    for (const [index, def] of this.values.entries()) {\n      if (!matchGroupIds || def.groupId && matchGroupIds.includes(def.groupId)) {\n        result.push(index);\n      }\n    }\n    return result;\n  }\n  valueIdxLookup(scopes, prop) {\n    const noScopesToMatch = scopes == null || scopes.length === 0;\n    const propId = typeof prop === \"string\" ? prop : prop.id;\n    const hasMatchingScopeId = (def) => {\n      if (def.idsMap) {\n        for (const [scope, ids] of def.idsMap) {\n          if (scopes?.includes(scope) && ids.has(propId)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const result = this.values.reduce((res, def, index) => {\n      const validDefScopes = def.scopes == null || noScopesToMatch && !def.scopes.length || def.scopes.some((s) => scopes?.includes(s));\n      if (validDefScopes && (def.property === propId || def.id === propId || hasMatchingScopeId(def))) {\n        res.push(index);\n      }\n      return res;\n    }, []);\n    if (result.length === 0) {\n      throw new Error(\n        `AG Charts - configuration error, unknown property ${JSON.stringify(prop)} in scope(s) ${JSON.stringify(\n          scopes\n        )}`\n      );\n    }\n    return result;\n  }\n  extractData(sources) {\n    const { dataDomain, processValue, allScopesHaveSameDefs } = this.initDataDomainProcessor();\n    const { keys: keyDefs, values: valueDefs } = this;\n    const { invalidData, invalidKeys, allKeyMappings } = this.extractKeys(keyDefs, sources, processValue);\n    const { columns, columnScopes, partialValidDataCount, maxDataLength } = this.extractValues(\n      invalidData,\n      valueDefs,\n      sources,\n      invalidKeys,\n      processValue\n    );\n    const propertyDomain = (def) => {\n      const defDomain = dataDomain.get(def);\n      const result = defDomain.getDomain();\n      if (ContinuousDomain.is(defDomain) && result[0] > result[1]) {\n        return [];\n      }\n      return result;\n    };\n    return {\n      type: \"ungrouped\",\n      input: { count: maxDataLength },\n      scopes: new Set(sources.keys()),\n      dataSources: sources,\n      aggregation: void 0,\n      keys: [...allKeyMappings.values()],\n      columns,\n      columnScopes,\n      invalidKeys,\n      invalidData,\n      domain: {\n        keys: keyDefs.map(propertyDomain),\n        values: valueDefs.map(propertyDomain)\n      },\n      defs: {\n        allScopesHaveSameDefs,\n        keys: keyDefs,\n        values: valueDefs\n      },\n      partialValidDataCount,\n      time: 0,\n      [DOMAIN_RANGES]: /* @__PURE__ */ new Map()\n    };\n  }\n  extractKeys(keyDefs, sources, processValue) {\n    const invalidKeys = /* @__PURE__ */ new Map();\n    const invalidData = /* @__PURE__ */ new Map();\n    const allKeys = /* @__PURE__ */ new Map();\n    let keyDefKeys;\n    let scopeDataProcessed;\n    const cloneScope = (source, target) => {\n      const sourceScope = scopeDataProcessed.get(source);\n      keyDefKeys.set(target, keyDefKeys.get(sourceScope));\n      if (invalidKeys.has(sourceScope)) {\n        invalidKeys.set(target, invalidKeys.get(sourceScope));\n        invalidData.set(target, invalidData.get(sourceScope));\n      }\n    };\n    for (const keyDef of keyDefs) {\n      const { invalidValue, scopes: keyScopes } = keyDef;\n      keyDefKeys = /* @__PURE__ */ new Map();\n      scopeDataProcessed = /* @__PURE__ */ new Map();\n      allKeys.set(keyDef, keyDefKeys);\n      for (const scope of keyScopes ?? []) {\n        const data = sources.get(scope) ?? [];\n        if (scopeDataProcessed.has(data)) {\n          cloneScope(data, scope);\n          continue;\n        }\n        const keys = [];\n        keyDefKeys.set(scope, keys);\n        scopeDataProcessed.set(data, scope);\n        let invalidScopeKeys;\n        let invalidScopeData;\n        for (let datumIndex = 0; datumIndex < data.length; datumIndex++) {\n          const key = processValue(keyDef, data[datumIndex], datumIndex, scope);\n          if (key !== INVALID_VALUE) {\n            keys.push(key);\n            continue;\n          }\n          keys.push(invalidValue);\n          invalidScopeKeys ?? (invalidScopeKeys = createArray(data.length, false));\n          invalidScopeData ?? (invalidScopeData = createArray(data.length, false));\n          invalidScopeKeys[datumIndex] = true;\n          invalidScopeData[datumIndex] = true;\n        }\n        if (invalidScopeKeys && invalidScopeData) {\n          invalidKeys.set(scope, invalidScopeKeys);\n          invalidData.set(scope, invalidScopeData);\n        }\n      }\n    }\n    return { invalidData, invalidKeys, allKeyMappings: allKeys };\n  }\n  extractValues(invalidData, valueDefs, sources, invalidKeys, processValue) {\n    let partialValidDataCount = 0;\n    const columns = [];\n    const allColumnScopes = [];\n    let maxDataLength = 0;\n    for (const def of valueDefs) {\n      const { invalidValue } = def;\n      const valueSources = new Set(def.scopes.map((s) => sources.get(s)));\n      if (valueSources.size > 1) {\n        throw new Error(`AG Charts - more than one data source for: ${JSON.stringify(def)}`);\n      }\n      const columnScopes = new Set(def.scopes);\n      const columnScope = first(def.scopes);\n      const columnSource = sources.get(columnScope);\n      const column = columnSource.map((valueDatum, datumIndex) => {\n        const invalidKey = invalidKeys.get(columnScope)?.[datumIndex];\n        let value = processValue(def, valueDatum, datumIndex, def.scopes);\n        if (invalidKey || value === INVALID_VALUE) {\n          this.markScopeDatumInvalid(def.scopes, columnSource, datumIndex, invalidData);\n        }\n        if (invalidKey) {\n          value = invalidValue;\n        } else if (value === INVALID_VALUE) {\n          partialValidDataCount += 1;\n          value = invalidValue;\n        }\n        return value;\n      });\n      columns.push(column);\n      allColumnScopes.push(columnScopes);\n      maxDataLength = Math.max(maxDataLength, column.length);\n    }\n    return { columns, columnScopes: allColumnScopes, partialValidDataCount, maxDataLength };\n  }\n  groupData(data, groupingFn) {\n    var _a;\n    const groups = /* @__PURE__ */ new Map();\n    const { keys: dataKeys, columns: allColumns, columnScopes, invalidKeys, invalidData } = data;\n    const allScopes = data.scopes;\n    const processedColumnIndexes = /* @__PURE__ */ new Set();\n    for (const scope of allScopes) {\n      const scopeColumnIndexes = allColumns.map((_, idx) => idx).filter((idx) => !processedColumnIndexes.has(idx) && columnScopes[idx].has(scope));\n      if (scopeColumnIndexes.length === 0)\n        continue;\n      for (const idx of scopeColumnIndexes) {\n        processedColumnIndexes.add(idx);\n      }\n      const siblingScopes = /* @__PURE__ */ new Set();\n      for (const columnIdx of scopeColumnIndexes) {\n        for (const columnScope of columnScopes[columnIdx]) {\n          siblingScopes.add(columnScope);\n        }\n      }\n      const scopeKeys = dataKeys.map((k) => k.get(scope)).filter((k) => k != null);\n      const firstColumn = allColumns[first(scopeColumnIndexes)];\n      const scopeInvalidData = invalidData?.get(scope);\n      const scopeInvalidKeys = invalidKeys?.get(scope);\n      for (let datumIndex = 0; datumIndex < firstColumn.length; datumIndex++) {\n        if (scopeInvalidKeys?.[datumIndex] === true)\n          continue;\n        const keys = scopeKeys.map((k) => k[datumIndex]);\n        if (keys == null || keys.length === 0) {\n          throw new Error(\"AG Charts - no keys found for scope: \" + scope);\n        }\n        const group = groupingFn?.(keys) ?? keys;\n        const groupStr = toKeyString(group);\n        const outputGroup = groups.get(groupStr) ?? {\n          keys: group,\n          datumIndices: [],\n          validScopes: allScopes\n        };\n        if (!groups.has(groupStr)) {\n          groups.set(groupStr, outputGroup);\n        }\n        if (scopeInvalidData?.[datumIndex] === true) {\n          if (outputGroup.validScopes === allScopes) {\n            outputGroup.validScopes = new Set(allScopes.values());\n          }\n          for (const invalidScope of siblingScopes) {\n            outputGroup.validScopes.delete(invalidScope);\n          }\n        }\n        if (outputGroup.validScopes.size === 0)\n          continue;\n        for (const columnIdx of scopeColumnIndexes) {\n          (_a = outputGroup.datumIndices)[columnIdx] ?? (_a[columnIdx] = []);\n          outputGroup.datumIndices[columnIdx].push(datumIndex);\n        }\n      }\n    }\n    const resultGroups = [];\n    const resultData = [];\n    for (const { keys, datumIndices, validScopes } of groups.values()) {\n      if (validScopes?.size === 0)\n        continue;\n      resultGroups.push(keys);\n      resultData.push({\n        datumIndices,\n        keys,\n        aggregation: [],\n        validScopes\n      });\n    }\n    return {\n      ...data,\n      type: \"grouped\",\n      domain: {\n        ...data.domain,\n        groups: resultGroups\n      },\n      groups: resultData\n    };\n  }\n  aggregateUngroupedData(processedData) {\n    const domainAggValues = this.aggregates.map(() => [Infinity, -Infinity]);\n    processedData.domain.aggValues = domainAggValues;\n    const { keys, columns, dataSources } = processedData;\n    const onlyScope = first(dataSources.keys());\n    const rawData = dataSources.get(onlyScope);\n    processedData.aggregation = rawData?.map((_, datumIndex) => {\n      const aggregation = [];\n      for (const [index, def] of this.aggregates.entries()) {\n        const indices = this.valueGroupIdxLookup(def);\n        let groupAggValues = def.groupAggregateFunction?.() ?? [Infinity, -Infinity];\n        const valuesToAgg = indices.map((columnIndex) => columns[columnIndex][datumIndex]);\n        const k = datumKeys(keys, onlyScope, datumIndex);\n        const valuesAgg = k != null ? def.aggregateFunction(valuesToAgg, k) : void 0;\n        if (valuesAgg) {\n          groupAggValues = def.groupAggregateFunction?.(valuesAgg, groupAggValues) ?? ContinuousDomain.extendDomain(valuesAgg, groupAggValues);\n        }\n        const finalValues = def.finalFunction?.(groupAggValues) ?? groupAggValues;\n        if (def.round === true) {\n          for (const idx in finalValues) {\n            finalValues[idx] = round3(finalValues[idx]);\n          }\n        }\n        aggregation[index] = finalValues;\n        ContinuousDomain.extendDomain(finalValues, domainAggValues[index]);\n      }\n      return aggregation;\n    });\n  }\n  aggregateGroupedData(processedData) {\n    const domainAggValues = this.aggregates.map(() => [Infinity, -Infinity]);\n    processedData.domain.aggValues = domainAggValues;\n    const { columns } = processedData;\n    for (const [index, def] of this.aggregates.entries()) {\n      const indices = this.valueGroupIdxLookup(def);\n      for (const group of processedData.groups) {\n        group.aggregation ?? (group.aggregation = []);\n        if (group.validScopes?.size === 0)\n          continue;\n        const groupKeys = group.keys;\n        let groupAggValues = def.groupAggregateFunction?.() ?? [Infinity, -Infinity];\n        const maxDatumIndex = Math.max(\n          ...indices.map((columnIndex) => group.datumIndices[columnIndex]?.length ?? 0)\n        );\n        for (let datumIndex = 0; datumIndex < maxDatumIndex; datumIndex++) {\n          const valuesToAgg = indices.map(\n            (columnIndex) => columns[columnIndex][group.datumIndices[columnIndex]?.[datumIndex]]\n          );\n          const valuesAgg = def.aggregateFunction(valuesToAgg, groupKeys);\n          if (valuesAgg) {\n            groupAggValues = def.groupAggregateFunction?.(valuesAgg, groupAggValues) ?? ContinuousDomain.extendDomain(valuesAgg, groupAggValues);\n          }\n        }\n        const finalValues = def.finalFunction?.(groupAggValues) ?? groupAggValues;\n        if (def.round === true) {\n          for (const idx in finalValues) {\n            finalValues[idx] = round3(finalValues[idx]);\n          }\n        }\n        group.aggregation[index] = finalValues;\n        ContinuousDomain.extendDomain(finalValues, domainAggValues[index]);\n      }\n    }\n  }\n  postProcessGroups(processedData) {\n    const { groupProcessors } = this;\n    const { columnScopes, columns, invalidData, scopes } = processedData;\n    for (const processor of groupProcessors) {\n      const valueIndexes = this.valueGroupIdxLookup(processor);\n      const adjustFn = processor.adjust()();\n      for (const dataGroup of processedData.groups) {\n        if (dataGroup.validScopes !== scopes)\n          continue;\n        adjustFn(columns, valueIndexes, dataGroup);\n      }\n      for (const valueIndex of valueIndexes) {\n        const valueDef = this.values[valueIndex];\n        const isDiscrete = valueDef.valueType === \"category\";\n        const column = columns[valueIndex];\n        const columnScope = first(columnScopes[valueIndex]);\n        const invalidDatums = invalidData?.get(columnScope);\n        const domain = isDiscrete ? new DiscreteDomain() : new ContinuousDomain();\n        for (let datumIndex = 0; datumIndex < column.length; datumIndex += 1) {\n          if (invalidDatums?.[datumIndex] === true)\n            continue;\n          domain.extend(column[datumIndex]);\n        }\n        processedData.domain.values[valueIndex] = domain.getDomain();\n      }\n    }\n  }\n  postProcessProperties(processedData) {\n    for (const { adjust, property, scopes } of this.propertyProcessors) {\n      for (const idx of this.valueIdxLookup(scopes, property)) {\n        adjust()(processedData, idx);\n      }\n    }\n  }\n  reduceData(processedData) {\n    processedData.reduced ?? (processedData.reduced = {});\n    const { dataSources, keys } = processedData;\n    for (const def of this.reducers) {\n      const reducer = def.reducer();\n      let accValue = def.initialValue;\n      if (processedData.type === \"grouped\") {\n        for (const group of processedData.groups) {\n          accValue = reducer(accValue, group.keys);\n        }\n      } else {\n        const onlyScope = first(dataSources.keys());\n        const keyColumns = keys.map((k) => k.get(onlyScope)).filter((k) => k != null);\n        const keysParam = keyColumns.map(() => void 0);\n        const rawData = dataSources.get(onlyScope);\n        for (let datumIndex = 0; datumIndex < rawData.length; datumIndex += 1) {\n          for (let keyIdx = 0; keyIdx < keysParam.length; keyIdx++) {\n            keysParam[keyIdx] = keyColumns[keyIdx]?.[datumIndex];\n          }\n          accValue = reducer(accValue, keysParam);\n        }\n      }\n      processedData.reduced[def.property] = accValue;\n    }\n  }\n  postProcessData(processedData) {\n    processedData.reduced ?? (processedData.reduced = {});\n    for (const def of this.processors) {\n      processedData.reduced[def.property] = def.calculate(\n        processedData,\n        processedData.reduced[def.property]\n      );\n    }\n  }\n  initDataDomainProcessor() {\n    const { keys: keyDefs, values: valueDefs } = this;\n    const scopes = /* @__PURE__ */ new Set();\n    for (const valueDef of valueDefs) {\n      if (!valueDef.scopes)\n        continue;\n      for (const scope of valueDef.scopes) {\n        scopes.add(scope);\n      }\n    }\n    const dataDomain = /* @__PURE__ */ new Map();\n    const processorFns = /* @__PURE__ */ new Map();\n    let allScopesHaveSameDefs = true;\n    const initDataDomain = () => {\n      for (const def of iterate(keyDefs, valueDefs)) {\n        if (def.valueType === \"category\") {\n          dataDomain.set(def, new DiscreteDomain());\n        } else {\n          dataDomain.set(def, new ContinuousDomain());\n          allScopesHaveSameDefs && (allScopesHaveSameDefs = (def.scopes ?? []).length === scopes.size);\n        }\n      }\n    };\n    initDataDomain();\n    const accessors = this.buildAccessors(iterate(keyDefs, valueDefs));\n    const processValue = (def, datum, idx, valueScopes) => {\n      let valueInDatum;\n      let value;\n      if (accessors.has(def.property)) {\n        try {\n          value = accessors.get(def.property)(datum);\n        } catch {\n        }\n        valueInDatum = value != null;\n      } else {\n        valueInDatum = def.property in datum;\n        value = valueInDatum ? datum[def.property] : def.missingValue;\n      }\n      if (def.forceValue != null) {\n        const valueNegative = valueInDatum && isNegative(value);\n        value = valueNegative ? -1 * def.forceValue : def.forceValue;\n        valueInDatum = true;\n      }\n      const missingValueDef = \"missingValue\" in def;\n      if (!valueInDatum && !missingValueDef) {\n        if (typeof valueScopes === \"string\") {\n          const missCount = def.missing.get(valueScopes) ?? 0;\n          def.missing.set(valueScopes, missCount + 1);\n        } else {\n          for (const scope of valueScopes) {\n            const missCount = def.missing.get(scope) ?? 0;\n            def.missing.set(scope, missCount + 1);\n          }\n        }\n      }\n      if (!dataDomain.has(def)) {\n        initDataDomain();\n      }\n      if (valueInDatum && def.validation?.(value, datum, idx) === false) {\n        if (\"invalidValue\" in def) {\n          value = def.invalidValue;\n        } else {\n          if (this.mode !== \"integrated\") {\n            logger_exports.warnOnce(\n              `invalid value of type [${typeof value}] for [${def.scopes} / ${def.id}] ignored:`,\n              `[${value}]`\n            );\n          }\n          return INVALID_VALUE;\n        }\n      }\n      if (def.processor) {\n        if (!processorFns.has(def)) {\n          processorFns.set(def, def.processor());\n        }\n        value = processorFns.get(def)?.(value);\n      }\n      dataDomain.get(def)?.extend(value);\n      return value;\n    };\n    return { dataDomain, processValue, initDataDomain, scopes, allScopesHaveSameDefs };\n  }\n  buildAccessors(defs) {\n    const result = /* @__PURE__ */ new Map();\n    if (this.suppressFieldDotNotation) {\n      return result;\n    }\n    for (const def of defs) {\n      const isPath = def.property.includes(\".\") || def.property.includes(\"[\");\n      if (!isPath)\n        continue;\n      const components = getPathComponents(def.property);\n      if (components == null) {\n        logger_exports.warnOnce(\"Invalid property path [%s]\", def.property);\n        continue;\n      }\n      const accessor = createPathAccessor(components);\n      result.set(def.property, accessor);\n    }\n    return result;\n  }\n};\nfunction logProcessedData(processedData) {\n  const logValues = (name, data) => {\n    if (data.length > 0) {\n      logger_exports.log(`DataModel.processData() - ${name}`);\n      logger_exports.table(data);\n    }\n  };\n  logger_exports.log(\"DataModel.processData() - processedData\", processedData);\n  logValues(\"Key Domains\", processedData.domain.keys);\n  logValues(\"Group Domains\", processedData.domain.groups ?? []);\n  logValues(\"Value Domains\", processedData.domain.values);\n  logValues(\"Aggregate Domains\", processedData.domain.aggValues ?? []);\n}\n\n// packages/ag-charts-community/src/chart/data/dataController.ts\nvar _DataController = class _DataController {\n  constructor(mode, suppressFieldDotNotation) {\n    this.mode = mode;\n    this.suppressFieldDotNotation = suppressFieldDotNotation;\n    this.debug = Debug.create(true, \"data-model\");\n    this.requested = [];\n    this.status = \"setup\";\n  }\n  async request(id, data, opts) {\n    if (this.status !== \"setup\") {\n      throw new Error(`AG Charts - data request after data setup phase.`);\n    }\n    return new Promise((resolve, reject) => {\n      this.requested.push({ id, opts, data, resolve, reject });\n    });\n  }\n  execute(cachedData) {\n    if (this.status !== \"setup\") {\n      throw new Error(`AG Charts - data request after data setup phase.`);\n    }\n    this.status = \"executed\";\n    this.debug(\"DataController.execute() - requested\", this.requested);\n    const valid = this.validateRequests(this.requested);\n    this.debug(\"DataController.execute() - validated\", valid);\n    const merged = this.mergeRequested(valid);\n    this.debug(\"DataController.execute() - merged\", merged);\n    if (this.debug.check()) {\n      getWindow().processedData = [];\n    }\n    const nextCachedData = [];\n    for (const { data, ids, opts, resolves, rejects } of merged) {\n      const reusableCache = cachedData?.find((cacheItem) => canReuseCachedData(cacheItem, data, ids, opts));\n      let dataModel;\n      let processedData;\n      if (reusableCache == null) {\n        try {\n          dataModel = new DataModel(opts, this.mode, this.suppressFieldDotNotation);\n          const sources = new Map(valid.map((v) => [v.id, v.data]));\n          processedData = dataModel.processData(sources);\n        } catch (error2) {\n          rejects.forEach((cb) => cb(error2));\n          continue;\n        }\n      } else {\n        ({ dataModel, processedData } = reusableCache);\n      }\n      nextCachedData.push({ opts, data, ids, dataModel, processedData });\n      if (this.debug.check()) {\n        getWindow(\"processedData\").push(processedData);\n      }\n      if (processedData?.partialValidDataCount === 0) {\n        resolves.forEach(\n          (resolve) => resolve({\n            dataModel,\n            processedData\n          })\n        );\n      } else if (processedData) {\n        this.splitResult(dataModel, processedData, ids, resolves);\n      } else {\n        rejects.forEach((cb) => cb(new Error(`AG Charts - no processed data generated`)));\n      }\n    }\n    return nextCachedData;\n  }\n  validateRequests(requested) {\n    const valid = [];\n    for (const [index, request] of requested.entries()) {\n      if (index > 0 && request.data.length !== requested[0].data.length && request.opts.groupByData === false && request.opts.groupByKeys === false) {\n        request.reject(\n          new Error(\"all series[].data arrays must be of the same length and have matching keys.\")\n        );\n      } else {\n        valid.push(request);\n      }\n    }\n    return valid;\n  }\n  mergeRequested(requested) {\n    const grouped = [];\n    for (const request of requested) {\n      const match = grouped.find(_DataController.groupMatch(request));\n      if (match) {\n        match.push(request);\n      } else {\n        grouped.push([request]);\n      }\n    }\n    return grouped.map(_DataController.mergeRequests);\n  }\n  splitResult(dataModel, processedData, scopes, resolves) {\n    for (let i = 0; i < scopes.length; i++) {\n      const resolve = resolves[i];\n      resolve({\n        dataModel,\n        processedData\n      });\n    }\n  }\n  static groupMatch({ data, opts }) {\n    function keys(props2) {\n      return props2.filter((p) => p.type === \"key\").map((p) => p.property).join(\";\");\n    }\n    const { groupByData, groupByKeys = false, groupByFn, props } = opts;\n    const propsKeys = keys(props);\n    return ([group]) => (groupByData === false || group.data === data) && (group.opts.groupByKeys ?? false) === groupByKeys && group.opts.groupByFn === groupByFn && keys(group.opts.props) === propsKeys;\n  }\n  static mergeRequests(requests) {\n    const crossScopeMergableTypes = /* @__PURE__ */ new Set([\"key\", \"group-value-processor\"]);\n    return requests.reduce(\n      (result, { id, data, resolve, reject, opts: { props, ...opts } }) => {\n        result.ids.push(id);\n        result.rejects.push(reject);\n        result.resolves.push(resolve);\n        result.data ?? (result.data = data);\n        result.opts ?? (result.opts = { ...opts, props: [] });\n        for (const prop of props) {\n          const clone2 = { ...prop, scopes: [id], data };\n          _DataController.createIdsMap(id, clone2);\n          const match = result.opts.props.find(\n            (existing) => existing.type === clone2.type && (crossScopeMergableTypes.has(existing.type) || existing.data === clone2.data) && _DataController.deepEqual(existing, clone2)\n          );\n          if (!match) {\n            result.opts.props.push(clone2);\n            continue;\n          }\n          match.scopes ?? (match.scopes = []);\n          match.scopes.push(...clone2.scopes ?? []);\n          if ((match.type === \"key\" || match.type === \"value\") && clone2.idsMap?.size) {\n            _DataController.mergeIdsMap(clone2.idsMap, match.idsMap);\n          }\n        }\n        return result;\n      },\n      { ids: [], rejects: [], resolves: [], data: null, opts: null }\n    );\n  }\n  static mergeIdsMap(fromMap, toMap) {\n    for (const [scope, ids] of fromMap) {\n      const toMapValue = toMap.get(scope);\n      if (toMapValue == null) {\n        toMap.set(scope, new Set(ids));\n      } else {\n        for (const id of ids) {\n          toMapValue.add(id);\n        }\n      }\n    }\n  }\n  static createIdsMap(scope, prop) {\n    if (prop.id == null)\n      return;\n    prop.idsMap ?? (prop.idsMap = /* @__PURE__ */ new Map());\n    if (prop.idsMap.has(scope)) {\n      prop.idsMap.get(scope).add(prop.id);\n    } else {\n      prop.idsMap.set(scope, /* @__PURE__ */ new Set([prop.id]));\n    }\n  }\n  static deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n      if (a.constructor !== b.constructor) {\n        return false;\n      }\n      let i, length2;\n      if (Array.isArray(a)) {\n        length2 = a.length;\n        if (length2 !== b.length) {\n          return false;\n        }\n        for (i = length2 - 1; i >= 0; i--) {\n          if (!_DataController.deepEqual(a[i], b[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      const keys = Object.keys(a);\n      length2 = keys.length;\n      if (length2 !== Object.keys(b).length) {\n        return false;\n      }\n      for (i = length2 - 1; i >= 0; i--) {\n        const key = keys[i];\n        if (!_DataController.skipKeys.has(key) && (!Object.hasOwn(b, key) || !_DataController.deepEqual(a[key], b[key]))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n};\n// optimized version of deep equality for `mergeRequests` which can potentially loop over 1M times\n_DataController.skipKeys = /* @__PURE__ */ new Set([\"id\", \"idsMap\", \"type\", \"scopes\", \"data\"]);\nvar DataController = _DataController;\n\n// packages/ag-charts-community/src/chart/factory/axisRegistry.ts\nvar AxisRegistry = class {\n  constructor() {\n    this.axesMap = /* @__PURE__ */ new Map();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(axisType, module) {\n    this.axesMap.set(axisType, module.moduleFactory);\n    if (module.themeTemplate) {\n      this.setThemeTemplate(axisType, module.themeTemplate);\n    }\n  }\n  create(axisType, moduleContext) {\n    const axisFactory = this.axesMap.get(axisType);\n    if (axisFactory) {\n      return axisFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown axis type: ${axisType}`);\n  }\n  has(axisType) {\n    return this.axesMap.has(axisType);\n  }\n  keys() {\n    return this.axesMap.keys();\n  }\n  setThemeTemplate(axisType, themeTemplate) {\n    this.themeTemplates.set(axisType, themeTemplate);\n    return this;\n  }\n  getThemeTemplate(axisType) {\n    return this.themeTemplates.get(axisType);\n  }\n};\nvar axisRegistry = new AxisRegistry();\n\n// packages/ag-charts-community/src/chart/factory/expectedEnterpriseModules.ts\nvar EXPECTED_ENTERPRISE_MODULES = [\n  {\n    type: \"root\",\n    optionsKey: \"animation\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"]\n  },\n  { type: \"root\", optionsKey: \"annotations\", chartTypes: [\"cartesian\"] },\n  {\n    type: \"root\",\n    optionsKey: \"background\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n    optionsInnerKey: \"image\"\n  },\n  {\n    type: \"root\",\n    optionsKey: \"foreground\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n    optionsInnerKey: \"image\"\n  },\n  {\n    type: \"root\",\n    optionsKey: \"chartToolbar\",\n    chartTypes: [\"cartesian\"]\n  },\n  {\n    type: \"root\",\n    optionsKey: \"contextMenu\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"]\n  },\n  { type: \"root\", optionsKey: \"statusBar\", chartTypes: [\"cartesian\"], identifier: \"status-bar\" },\n  {\n    type: \"root\",\n    optionsKey: \"dataSource\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"]\n  },\n  { type: \"root\", optionsKey: \"sync\", chartTypes: [\"cartesian\"] },\n  { type: \"root\", optionsKey: \"zoom\", chartTypes: [\"cartesian\", \"topology\"] },\n  { type: \"root\", optionsKey: \"ranges\", chartTypes: [\"cartesian\"] },\n  {\n    type: \"legend\",\n    optionsKey: \"gradientLegend\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n    identifier: \"gradient\"\n  },\n  { type: \"root\", optionsKey: \"navigator\", chartTypes: [\"cartesian\"] },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"angle-category\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"angle-number\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"radius-category\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"radius-number\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"bar\", community: true },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"line\", community: true },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"cartesian\"], identifier: \"ordinal-time\" },\n  { type: \"axis-option\", optionsKey: \"crosshair\", chartTypes: [\"cartesian\"] },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"box-plot\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"candlestick\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"cone-funnel\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"funnel\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"ohlc\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"heatmap\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"range-area\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"range-bar\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"waterfall\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"nightingale\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radar-area\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radar-line\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radial-bar\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radial-column\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"hierarchy\"], identifier: \"sunburst\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"hierarchy\"], identifier: \"treemap\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-shape\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-line\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-marker\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-shape-background\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-line-background\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"flow-proportion\"], identifier: \"chord\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"flow-proportion\"], identifier: \"sankey\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"standalone\"], identifier: \"pyramid\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"gauge\"], identifier: \"linear-gauge\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"gauge\"], identifier: \"radial-gauge\" },\n  { type: \"series-option\", optionsKey: \"errorBar\", chartTypes: [\"cartesian\"], identifier: \"error-bars\" },\n  { type: \"context\", contextKey: \"sharedToolbar\", chartTypes: [\"cartesian\"] }\n];\nfunction isEnterpriseSeriesType(type) {\n  return EXPECTED_ENTERPRISE_MODULES.some((s) => s.type === \"series\" && s.identifier === type);\n}\nfunction getEnterpriseSeriesChartTypes(type) {\n  return EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === \"series\" && s.identifier === type)?.chartTypes;\n}\nfunction isEnterpriseCartesian(seriesType) {\n  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === \"cartesian\");\n  return type === \"cartesian\";\n}\nfunction isEnterprisePolar(seriesType) {\n  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === \"polar\");\n  return type === \"polar\";\n}\nfunction isEnterpriseHierarchy(seriesType) {\n  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === \"hierarchy\");\n  return type === \"hierarchy\";\n}\nfunction isEnterpriseTopology(seriesType) {\n  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === \"topology\");\n  return type === \"topology\";\n}\nfunction isEnterpriseFlowProportion(seriesType) {\n  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === \"flow-proportion\");\n  return type === \"flow-proportion\";\n}\nfunction isEnterpriseStandalone(seriesType) {\n  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === \"standalone\");\n  return type === \"standalone\";\n}\nfunction isEnterpriseGauge(seriesType) {\n  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === \"gauge\");\n  return type === \"gauge\";\n}\nfunction isEnterpriseModule(module) {\n  return module.packageType === \"enterprise\";\n}\nfunction verifyIfModuleExpected(module) {\n  if (!isEnterpriseModule(module)) {\n    throw new Error(\"AG Charts - internal configuration error, only enterprise modules need verification.\");\n  }\n  const stub = EXPECTED_ENTERPRISE_MODULES.find((s) => {\n    return s.type === module.type && (\"optionsKey\" in s && \"optionsKey\" in module ? s.optionsKey === module.optionsKey : true) && (\"contextKey\" in s && \"contextKey\" in module ? s.contextKey === module.contextKey : true) && s.identifier === module.identifier && module.chartTypes.every((t) => s.chartTypes.includes(t));\n  });\n  if (stub) {\n    stub.useCount ?? (stub.useCount = 0);\n    stub.useCount++;\n  }\n  return stub != null;\n}\nfunction getUnusedExpectedModules() {\n  return EXPECTED_ENTERPRISE_MODULES.filter(({ useCount }) => useCount == null || useCount === 0);\n}\n\n// packages/ag-charts-community/src/chart/factory/legendRegistry.ts\nvar LegendRegistry = class {\n  constructor() {\n    this.legendMap = /* @__PURE__ */ new Map();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(legendType, { optionsKey, moduleFactory, themeTemplate }) {\n    this.legendMap.set(legendType, { optionsKey, moduleFactory });\n    this.themeTemplates.set(optionsKey, themeTemplate);\n  }\n  create(legendType, moduleContext) {\n    const legendFactory = this.legendMap.get(legendType)?.moduleFactory;\n    if (legendFactory) {\n      return legendFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown legend type: ${legendType}`);\n  }\n  getThemeTemplates() {\n    return Object.fromEntries(this.themeTemplates);\n  }\n  getKeys() {\n    return Array.from(this.legendMap.entries()).reduce(\n      (result, [legendType, record]) => {\n        result[legendType] = record.optionsKey;\n        return result;\n      },\n      {}\n    );\n  }\n};\nvar legendRegistry = new LegendRegistry();\n\n// packages/ag-charts-community/src/chart/factory/chartTypes.ts\nvar ChartTypes = class extends Map {\n  get(seriesType) {\n    return super.get(seriesType) ?? \"unknown\";\n  }\n  isCartesian(seriesType) {\n    return this.get(seriesType) === \"cartesian\";\n  }\n  isPolar(seriesType) {\n    return this.get(seriesType) === \"polar\";\n  }\n  isHierarchy(seriesType) {\n    return this.get(seriesType) === \"hierarchy\";\n  }\n  isTopology(seriesType) {\n    return this.get(seriesType) === \"topology\";\n  }\n  isFlowProportion(seriesType) {\n    return this.get(seriesType) === \"flow-proportion\";\n  }\n  isStandalone(seriesType) {\n    return this.get(seriesType) === \"standalone\";\n  }\n  isGauge(seriesType) {\n    return this.get(seriesType) === \"gauge\";\n  }\n  get seriesTypes() {\n    return Array.from(this.keys());\n  }\n  get cartesianTypes() {\n    return this.seriesTypes.filter((t) => this.isCartesian(t));\n  }\n  get polarTypes() {\n    return this.seriesTypes.filter((t) => this.isPolar(t));\n  }\n  get hierarchyTypes() {\n    return this.seriesTypes.filter((t) => this.isHierarchy(t));\n  }\n  get topologyTypes() {\n    return this.seriesTypes.filter((t) => this.isTopology(t));\n  }\n  get flowProportionTypes() {\n    return this.seriesTypes.filter((t) => this.isFlowProportion(t));\n  }\n  get standaloneTypes() {\n    return this.seriesTypes.filter((t) => this.isStandalone(t));\n  }\n  get gaugeTypes() {\n    return this.seriesTypes.filter((t) => this.isGauge(t));\n  }\n};\nvar ChartDefaults = class extends Map {\n  set(chartType, defaults) {\n    return super.set(chartType, mergeDefaults(defaults, this.get(chartType)));\n  }\n};\nvar chartTypes2 = new ChartTypes();\nvar publicChartTypes = new ChartTypes();\nvar chartDefaults = new ChartDefaults();\n\n// packages/ag-charts-community/src/chart/factory/seriesRegistry.ts\nvar SeriesRegistry = class {\n  constructor() {\n    this.seriesMap = /* @__PURE__ */ new Map();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(seriesType, {\n    chartTypes: [chartType],\n    moduleFactory,\n    tooltipDefaults: tooltipDefaults2,\n    defaultAxes,\n    themeTemplate,\n    paletteFactory,\n    solo,\n    stackable,\n    groupable,\n    stackedByDefault,\n    hidden\n  }) {\n    this.setThemeTemplate(seriesType, themeTemplate);\n    this.seriesMap.set(seriesType, {\n      moduleFactory,\n      tooltipDefaults: tooltipDefaults2,\n      defaultAxes,\n      paletteFactory,\n      solo,\n      stackable,\n      groupable,\n      stackedByDefault\n    });\n    chartTypes2.set(seriesType, chartType);\n    if (!hidden) {\n      publicChartTypes.set(seriesType, chartType);\n    }\n  }\n  create(seriesType, moduleContext) {\n    const seriesFactory = this.seriesMap.get(seriesType)?.moduleFactory;\n    if (seriesFactory) {\n      return seriesFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown series type: ${seriesType}`);\n  }\n  cloneDefaultAxes(seriesType, options) {\n    const defaultAxes = this.seriesMap.get(seriesType)?.defaultAxes;\n    if (defaultAxes == null)\n      return null;\n    const axes = typeof defaultAxes === \"function\" ? defaultAxes(options) : defaultAxes;\n    return { axes: deepClone(axes) };\n  }\n  isDerivedDefaultAxes(seriesType) {\n    return typeof this.seriesMap.get(seriesType)?.defaultAxes === \"function\";\n  }\n  setThemeTemplate(seriesType, themeTemplate) {\n    const currentTemplate = this.themeTemplates.get(seriesType);\n    this.themeTemplates.set(seriesType, mergeDefaults(themeTemplate, currentTemplate));\n  }\n  getThemeTemplate(seriesType) {\n    return this.themeTemplates.get(seriesType);\n  }\n  getPaletteFactory(seriesType) {\n    return this.seriesMap.get(seriesType)?.paletteFactory;\n  }\n  getTooltipDefauls(seriesType) {\n    return this.seriesMap.get(seriesType)?.tooltipDefaults;\n  }\n  isSolo(seriesType) {\n    return this.seriesMap.get(seriesType)?.solo ?? false;\n  }\n  isGroupable(seriesType) {\n    return this.seriesMap.get(seriesType)?.groupable ?? false;\n  }\n  isStackable(seriesType) {\n    return this.seriesMap.get(seriesType)?.stackable ?? false;\n  }\n  isStackedByDefault(seriesType) {\n    return this.seriesMap.get(seriesType)?.stackedByDefault ?? false;\n  }\n};\nvar seriesRegistry = new SeriesRegistry();\n\n// packages/ag-charts-community/src/chart/interaction/syncManager.ts\nvar _SyncManager = class _SyncManager extends BaseManager {\n  constructor(chart) {\n    super();\n    this.chart = chart;\n  }\n  subscribe(groupId = _SyncManager.DEFAULT_GROUP) {\n    let syncGroup = this.get(groupId);\n    if (!syncGroup) {\n      syncGroup = /* @__PURE__ */ new Set();\n      _SyncManager.chartsGroups.set(groupId, syncGroup);\n    }\n    syncGroup.add(this.chart);\n    return this;\n  }\n  unsubscribe(groupId = _SyncManager.DEFAULT_GROUP) {\n    this.get(groupId)?.delete(this.chart);\n    return this;\n  }\n  getChart() {\n    return this.chart;\n  }\n  getGroup(groupId = _SyncManager.DEFAULT_GROUP) {\n    const syncGroup = this.get(groupId);\n    return syncGroup ? Array.from(syncGroup) : [];\n  }\n  getGroupSiblings(groupId = _SyncManager.DEFAULT_GROUP) {\n    return this.getGroup(groupId).filter((chart) => chart !== this.chart);\n  }\n  get(groupId) {\n    return _SyncManager.chartsGroups.get(groupId);\n  }\n};\n_SyncManager.chartsGroups = /* @__PURE__ */ new Map();\n_SyncManager.DEFAULT_GROUP = Symbol(\"sync-group-default\");\nvar SyncManager = _SyncManager;\n\n// packages/ag-charts-community/src/chart/keyboard.ts\nvar Keyboard = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Keyboard.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], Keyboard.prototype, \"tabIndex\", 2);\n\n// packages/ag-charts-community/src/chart/mapping/prepareAxis.ts\nvar CartesianAxisPositions = [\"top\", \"right\", \"bottom\", \"left\"];\nfunction isAxisPosition(position) {\n  return typeof position === \"string\" && CartesianAxisPositions.includes(position);\n}\nfunction guessInvalidPositions(axes) {\n  const invalidAxes = [];\n  const usedPositions = [];\n  const guesses = [...CartesianAxisPositions];\n  for (const axis of axes) {\n    if (axis instanceof CartesianAxis) {\n      if (isAxisPosition(axis.position)) {\n        usedPositions.push(axis.position);\n      } else {\n        invalidAxes.push(axis);\n      }\n    }\n  }\n  for (const axis of invalidAxes) {\n    let nextGuess;\n    do {\n      nextGuess = guesses.pop();\n    } while (nextGuess && usedPositions.includes(nextGuess));\n    if (nextGuess == null)\n      break;\n    axis.position = nextGuess;\n  }\n}\n\n// packages/ag-charts-community/src/chart/mapping/prepareSeries.ts\nvar MATCHING_KEYS = [\"direction\", \"xKey\", \"yKey\", \"sizeKey\", \"angleKey\", \"radiusKey\", \"normalizedTo\"];\nfunction matchSeriesOptions(series, optSeries, oldOptsSeries) {\n  const generateKey = (type, i, opts) => {\n    const result = [type];\n    for (const key of MATCHING_KEYS) {\n      if (key in i && i[key] != null)\n        result.push(`${key}=${i[key]}`);\n    }\n    if (opts?.seriesGrouping) {\n      result.push(`seriesGrouping.groupId=${opts?.seriesGrouping.groupId}`);\n    }\n    return result.join(\";\");\n  };\n  const seriesMap = /* @__PURE__ */ new Map();\n  let idx = 0;\n  for (const s of series) {\n    const key = generateKey(s.type, s.properties, oldOptsSeries?.[idx]);\n    if (!seriesMap.has(key)) {\n      seriesMap.set(key, []);\n    }\n    seriesMap.get(key)?.push([s, idx++]);\n  }\n  const optsMap = /* @__PURE__ */ new Map();\n  idx = 0;\n  for (const o of optSeries) {\n    const key = generateKey(o.type, o, o);\n    if (!optsMap.has(key)) {\n      optsMap.set(key, []);\n    }\n    optsMap.get(key)?.push([o, idx++]);\n  }\n  const overlap = [...seriesMap.keys()].some((k) => optsMap.has(k));\n  if (!overlap) {\n    return { status: \"no-overlap\", oldKeys: seriesMap.keys(), newKeys: optsMap.keys() };\n  }\n  const changes = [];\n  for (const [key, optsTuples] of optsMap.entries()) {\n    for (const [opts, targetIdx] of optsTuples) {\n      const seriesArray = seriesMap.get(key);\n      if (seriesArray == null || seriesArray.length < 1) {\n        changes.push({ opts, targetIdx, idx: targetIdx, status: \"add\" });\n        seriesMap.delete(key);\n        continue;\n      }\n      const [outputSeries, currentIdx] = seriesArray.shift();\n      const previousOpts = oldOptsSeries?.[currentIdx] ?? {};\n      const diff2 = jsonDiff(previousOpts, opts ?? {});\n      const { groupIndex, stackIndex } = diff2?.seriesGrouping ?? {};\n      if (groupIndex != null || stackIndex != null) {\n        changes.push({\n          opts,\n          series: outputSeries,\n          diff: diff2,\n          targetIdx,\n          idx: currentIdx,\n          status: \"series-grouping\"\n        });\n      } else if (diff2) {\n        changes.push({\n          opts,\n          series: outputSeries,\n          diff: diff2,\n          targetIdx,\n          idx: currentIdx,\n          status: \"update\"\n        });\n      } else {\n        changes.push({ opts, series: outputSeries, targetIdx, idx: currentIdx, status: \"no-op\" });\n      }\n      if (seriesArray.length === 0) {\n        seriesMap.delete(key);\n      }\n    }\n  }\n  for (const seriesArray of seriesMap.values()) {\n    for (const [outputSeries, currentIdx] of seriesArray) {\n      changes.push({ series: outputSeries, idx: currentIdx, targetIdx: -1, status: \"remove\" });\n    }\n  }\n  return { status: \"overlap\", changes };\n}\n\n// packages/ag-charts-community/src/chart/mapping/types.ts\nfunction optionsType(input) {\n  const { series } = input;\n  if (!series)\n    return;\n  return series[0]?.type ?? \"line\";\n}\nfunction isAgCartesianChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  return chartTypes2.isCartesian(specifiedType) || isEnterpriseCartesian(specifiedType);\n}\nfunction isAgPolarChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  return chartTypes2.isPolar(specifiedType) || isEnterprisePolar(specifiedType);\n}\nfunction isAgHierarchyChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  return chartTypes2.isHierarchy(specifiedType) || isEnterpriseHierarchy(specifiedType);\n}\nfunction isAgTopologyChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  return chartTypes2.isTopology(specifiedType) || isEnterpriseTopology(specifiedType);\n}\nfunction isAgFlowProportionChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  return chartTypes2.isFlowProportion(specifiedType) || isEnterpriseFlowProportion(specifiedType);\n}\nfunction isAgStandaloneChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  return chartTypes2.isStandalone(specifiedType) || isEnterpriseStandalone(specifiedType);\n}\nfunction isAgGaugeChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  return chartTypes2.isGauge(specifiedType) || isEnterpriseGauge(specifiedType);\n}\nfunction isAgPolarChartOptionsWithSeriesBasedLegend(input) {\n  const specifiedType = optionsType(input);\n  return isAgPolarChartOptions(input) && specifiedType !== \"pie\" && specifiedType !== \"donut\";\n}\nfunction isSeriesOptionType(input) {\n  if (input == null) {\n    return false;\n  }\n  return chartTypes2.has(input);\n}\nfunction isAxisOptionType(input) {\n  if (input == null) {\n    return false;\n  }\n  return axisRegistry.has(input);\n}\n\n// packages/ag-charts-community/src/chart/modulesManager.ts\nvar ModulesManager = class extends ModuleMap {\n  applyOptions(options) {\n    for (const m of this.moduleMap.values()) {\n      if (m.module.optionsKey in options && isProperties(m.moduleInstance)) {\n        m.moduleInstance.set(options[m.module.optionsKey]);\n      }\n    }\n  }\n  *legends() {\n    for (const { module, moduleInstance } of this.moduleMap.values()) {\n      if (module.type !== \"legend\")\n        continue;\n      yield {\n        legendType: module.identifier,\n        legend: moduleInstance\n      };\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/overlay/overlay.ts\nvar DEFAULT_OVERLAY_CLASS = \"ag-charts-overlay\";\nvar DEFAULT_OVERLAY_DARK_CLASS = \"ag-charts-dark-overlay\";\nvar Overlay = class extends BaseProperties {\n  constructor(className, defaultMessageId) {\n    super();\n    this.className = className;\n    this.defaultMessageId = defaultMessageId;\n    this.enabled = true;\n  }\n  getText(localeManager) {\n    return localeManager.t(this.text ?? this.defaultMessageId);\n  }\n  getElement(animationManager, localeManager, rect) {\n    this.content?.remove();\n    this.focusBox = rect;\n    if (this.renderer) {\n      const htmlContent = this.renderer();\n      if (htmlContent instanceof HTMLElement) {\n        this.content = htmlContent;\n      } else {\n        const tempDiv = createElement(\"div\");\n        tempDiv.innerHTML = htmlContent;\n        this.content = tempDiv.firstElementChild;\n      }\n    } else {\n      const content = createElement(\"div\", {\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        boxSizing: \"border-box\",\n        height: \"100%\",\n        margin: \"8px\",\n        fontFamily: \"var(--ag-charts-font-family)\",\n        fontSize: \"var(--ag-charts-font-size)\",\n        fontWeight: \"var(--ag-charts-font-weight)\"\n      });\n      content.innerText = this.getText(localeManager);\n      this.content = content;\n      animationManager?.animate({\n        from: 0,\n        to: 1,\n        id: \"overlay\",\n        phase: \"add\",\n        groupId: \"opacity\",\n        onUpdate(value) {\n          content.style.opacity = String(value);\n        },\n        onStop() {\n          content.style.opacity = \"1\";\n        }\n      });\n    }\n    return this.content;\n  }\n  removeElement(cleanup = () => this.content?.remove(), animationManager) {\n    if (!this.content)\n      return;\n    if (animationManager) {\n      const { content } = this;\n      animationManager.animate({\n        from: 1,\n        to: 0,\n        phase: \"remove\",\n        id: \"overlay\",\n        groupId: \"opacity\",\n        onUpdate(value) {\n          content.style.opacity = String(value);\n        },\n        onStop() {\n          cleanup?.();\n        }\n      });\n    } else {\n      cleanup?.();\n    }\n    this.content = void 0;\n    this.focusBox = void 0;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Overlay.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], Overlay.prototype, \"text\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], Overlay.prototype, \"renderer\", 2);\n\n// packages/ag-charts-community/src/chart/overlay/chartOverlays.ts\nvar ChartOverlays = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.darkTheme = false;\n    this.loading = new Overlay(\"ag-charts-loading-overlay\", \"overlayLoadingData\");\n    this.noData = new Overlay(\"ag-charts-no-data-overlay\", \"overlayNoData\");\n    this.noVisibleSeries = new Overlay(\"ag-charts-no-visible-series\", \"overlayNoVisibleSeries\");\n    this.unsupportedBrowser = new Overlay(\"ag-charts-unsupported-browser\", \"overlayUnsupportedBrowser\");\n  }\n  getFocusInfo(localeManager) {\n    for (const overlay of [this.loading, this.noData, this.noVisibleSeries, this.unsupportedBrowser]) {\n      if (overlay.focusBox !== void 0) {\n        return { text: overlay.getText(localeManager), rect: overlay.focusBox };\n      }\n    }\n    return void 0;\n  }\n  destroy() {\n    this.loading.removeElement();\n    this.noData.removeElement();\n    this.noVisibleSeries.removeElement();\n    this.unsupportedBrowser.removeElement();\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], ChartOverlays.prototype, \"darkTheme\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"loading\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"noData\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"noVisibleSeries\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"unsupportedBrowser\", 2);\n\n// packages/ag-charts-community/src/chart/overlay/loadingSpinner.ts\nfunction getLoadingSpinner(text2, defaultDuration) {\n  const { animationDuration } = PHASE_METADATA[\"add\"];\n  const duration = animationDuration * defaultDuration;\n  const container = createElement(\"div\", `${DEFAULT_OVERLAY_CLASS}--loading`, {\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    flexDirection: \"column\",\n    height: \"100%\",\n    boxSizing: \"border-box\",\n    font: \"13px Verdana, sans-serif\",\n    // FONT_SIZE.MEDIUM\n    userSelect: \"none\",\n    animation: `ag-charts-loading ${duration}ms linear 50ms both`\n  });\n  const matrix = createElement(\"span\", {\n    width: \"45px\",\n    height: \"40px\",\n    backgroundImage: [\n      \"linear-gradient(#0000 calc(1 * 100% / 6), #ccc 0 calc(3 * 100% / 6), #0000 0), \",\n      \"linear-gradient(#0000 calc(2 * 100% / 6), #ccc 0 calc(4 * 100% / 6), #0000 0), \",\n      \"linear-gradient(#0000 calc(3 * 100% / 6), #ccc 0 calc(5 * 100% / 6), #0000 0)\"\n    ].join(\"\"),\n    backgroundSize: \"10px 400%\",\n    backgroundRepeat: \"no-repeat\",\n    animation: \"ag-charts-loading-matrix 1s infinite linear\"\n  });\n  const label = createElement(\"p\", { marginTop: \"1em\" });\n  label.innerText = text2;\n  const background = createElement(\"div\", `${DEFAULT_OVERLAY_CLASS}__loading-background`, {\n    position: \"absolute\",\n    inset: \"0\",\n    opacity: \"0.5\",\n    zIndex: \"-1\"\n  });\n  const animationStyles = createElement(\"style\");\n  animationStyles.innerText = [\n    \"@keyframes ag-charts-loading { from { opacity: 0 } to { opacity: 1 } }\",\n    \"@keyframes ag-charts-loading-matrix {\",\n    \"0% { background-position: 0% 0%, 50% 0%, 100% 0%; }\",\n    \"100% { background-position: 0% 100%, 50% 100%, 100% 100%; }\",\n    \"}\"\n  ].join(\" \");\n  container.replaceChildren(animationStyles, matrix, label, background);\n  return container;\n}\n\n// packages/ag-charts-community/src/chart/series/seriesZIndexMap.ts\nvar SeriesZIndexMap = /* @__PURE__ */ ((SeriesZIndexMap2) => {\n  SeriesZIndexMap2[SeriesZIndexMap2[\"BACKGROUND\"] = 0] = \"BACKGROUND\";\n  SeriesZIndexMap2[SeriesZIndexMap2[\"ANY_CONTENT\"] = 1] = \"ANY_CONTENT\";\n  return SeriesZIndexMap2;\n})(SeriesZIndexMap || {});\nvar SeriesContentZIndexMap = /* @__PURE__ */ ((SeriesContentZIndexMap2) => {\n  SeriesContentZIndexMap2[SeriesContentZIndexMap2[\"FOREGROUND\"] = 0] = \"FOREGROUND\";\n  SeriesContentZIndexMap2[SeriesContentZIndexMap2[\"HIGHLIGHT\"] = 1] = \"HIGHLIGHT\";\n  SeriesContentZIndexMap2[SeriesContentZIndexMap2[\"LABEL\"] = 2] = \"LABEL\";\n  return SeriesContentZIndexMap2;\n})(SeriesContentZIndexMap || {});\n\n// packages/ag-charts-community/src/chart/series/series.ts\nvar SeriesNodePickMode = /* @__PURE__ */ ((SeriesNodePickMode2) => {\n  SeriesNodePickMode2[SeriesNodePickMode2[\"EXACT_SHAPE_MATCH\"] = 0] = \"EXACT_SHAPE_MATCH\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"NEAREST_NODE\"] = 1] = \"NEAREST_NODE\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"AXIS_ALIGNED\"] = 2] = \"AXIS_ALIGNED\";\n  return SeriesNodePickMode2;\n})(SeriesNodePickMode || {});\nvar CROSS_FILTER_MARKER_FILL_OPACITY_FACTOR = 0.25;\nvar CROSS_FILTER_MARKER_STROKE_OPACITY_FACTOR = 0.125;\nvar SeriesNodeEvent = class {\n  constructor(type, event, { datum }, series) {\n    this.type = type;\n    this.event = event;\n    this.datum = datum;\n    this.seriesId = series.id;\n  }\n};\nvar SeriesGroupingChangedEvent = class {\n  constructor(series, seriesGrouping, oldGrouping) {\n    this.series = series;\n    this.seriesGrouping = seriesGrouping;\n    this.oldGrouping = oldGrouping;\n    this.type = \"groupingChanged\";\n  }\n};\nvar Series = class extends Observable {\n  constructor(seriesOpts) {\n    super();\n    this.destroyFns = [];\n    this.usesPlacedLabels = false;\n    this.seriesGrouping = void 0;\n    this.NodeEvent = SeriesNodeEvent;\n    this.internalId = createId(this);\n    // The group node that contains the series rendering in its default (non-highlighted) state.\n    this.contentGroup = new TranslatableGroup({\n      name: `${this.internalId}-content`,\n      zIndex: 1 /* ANY_CONTENT */\n    });\n    // The group node that contains all highlighted series items. This is a performance optimisation\n    // for large-scale data-sets, where the only thing that routinely varies is the currently\n    // highlighted node.\n    this.highlightGroup = new TranslatableGroup({\n      name: `${this.internalId}-highlight`,\n      zIndex: 1 /* ANY_CONTENT */\n    });\n    // Error bars etc.\n    this.annotationGroup = new TranslatableGroup({\n      name: `${this.internalId}-annotation`\n    });\n    // Lazily initialised labelGroup for label presentation.\n    this.labelGroup = new TranslatableGroup({\n      name: `${this.internalId}-series-labels`\n    });\n    this.axes = {\n      [\"x\" /* X */]: void 0,\n      [\"y\" /* Y */]: void 0\n    };\n    this.directions = [\"x\" /* X */, \"y\" /* Y */];\n    // Flag to determine if we should recalculate node data.\n    this.nodeDataRefresh = true;\n    this.moduleMap = new ModuleMap();\n    this.datumCallbackCache = /* @__PURE__ */ new Map();\n    this.connectsToYAxis = false;\n    this._declarationOrder = -1;\n    this.seriesListeners = new Listeners();\n    this._pickNodeCache = new LRUCache();\n    const {\n      moduleCtx,\n      pickModes,\n      directionKeys = {},\n      directionNames = {},\n      canHaveAxes = false,\n      usesPlacedLabels = false\n    } = seriesOpts;\n    this.ctx = moduleCtx;\n    this.directionKeys = directionKeys;\n    this.directionNames = directionNames;\n    this.canHaveAxes = canHaveAxes;\n    this.usesPlacedLabels = usesPlacedLabels;\n    this.highlightGroup = new TranslatableGroup({\n      name: `${this.internalId}-highlight`\n    });\n    this.highlightNode = this.highlightGroup.appendChild(new Group({ name: \"highlightNode\", zIndex: 0 }));\n    this.highlightLabel = this.highlightGroup.appendChild(new Group({ name: \"highlightLabel\", zIndex: 10 }));\n    this.pickModes = pickModes;\n  }\n  get pickModeAxis() {\n    return \"main\";\n  }\n  get id() {\n    return this.properties?.id ?? this.internalId;\n  }\n  get type() {\n    return this.constructor.type ?? \"\";\n  }\n  get focusable() {\n    return true;\n  }\n  get data() {\n    return this._data ?? this._chartData;\n  }\n  set visible(newVisibility) {\n    this.properties.visible = newVisibility;\n    this.ctx.legendManager.toggleItem({ enabled: newVisibility, seriesId: this.id });\n    this.ctx.legendManager.update();\n    this.visibleMaybeChanged();\n  }\n  get visible() {\n    return this.ctx.legendManager.getSeriesEnabled(this.id) ?? this.properties.visible;\n  }\n  get hasData() {\n    return this.data != null && this.data.length > 0;\n  }\n  get tooltipEnabled() {\n    return this.properties.tooltip?.enabled ?? false;\n  }\n  onDataChange() {\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n  }\n  setOptionsData(input) {\n    this._data = input;\n    this.onDataChange();\n  }\n  setChartData(input) {\n    this._chartData = input;\n    if (this.data === input) {\n      this.onDataChange();\n    }\n  }\n  onSeriesGroupingChange(prev, next) {\n    const { internalId, type, visible } = this;\n    if (prev) {\n      this.ctx.seriesStateManager.deregisterSeries(this);\n    }\n    if (next) {\n      this.ctx.seriesStateManager.registerSeries({ internalId, type, visible, seriesGrouping: next });\n    }\n    this.fireEvent(new SeriesGroupingChangedEvent(this, next, prev));\n  }\n  getBandScalePadding() {\n    return { inner: 1, outer: 0 };\n  }\n  attachSeries(seriesContentNode, seriesNode, annotationNode) {\n    seriesContentNode.appendChild(this.contentGroup);\n    seriesNode.appendChild(this.highlightGroup);\n    seriesNode.appendChild(this.labelGroup);\n    annotationNode?.appendChild(this.annotationGroup);\n  }\n  detachSeries(seriesContentNode, seriesNode, annotationNode) {\n    seriesContentNode?.removeChild(this.contentGroup);\n    seriesNode.removeChild(this.highlightGroup);\n    seriesNode.removeChild(this.labelGroup);\n    annotationNode?.removeChild(this.annotationGroup);\n  }\n  setSeriesIndex(index) {\n    if (index === this._declarationOrder)\n      return false;\n    this._declarationOrder = index;\n    this.contentGroup.zIndex = [1 /* ANY_CONTENT */, index, 0 /* FOREGROUND */];\n    this.highlightGroup.zIndex = [1 /* ANY_CONTENT */, index, 1 /* HIGHLIGHT */];\n    this.labelGroup.zIndex = [1 /* ANY_CONTENT */, index, 2 /* LABEL */];\n    this.annotationGroup.zIndex = index;\n    return true;\n  }\n  renderToOffscreenCanvas() {\n    return false;\n  }\n  addEventListener(type, listener) {\n    return super.addEventListener(type, listener);\n  }\n  addListener(type, listener) {\n    return this.seriesListeners.addListener(type, listener);\n  }\n  dispatch(type, event) {\n    this.seriesListeners.dispatch(type, event);\n  }\n  addChartEventListeners() {\n    return;\n  }\n  destroy() {\n    this.destroyFns.forEach((f) => f());\n    this.destroyFns = [];\n    this.resetDatumCallbackCache();\n    this.ctx.seriesStateManager.deregisterSeries(this);\n  }\n  getDirectionValues(direction, properties) {\n    const resolvedDirection = this.resolveKeyDirection(direction);\n    const keys = properties?.[resolvedDirection];\n    const values = [];\n    if (!keys) {\n      return values;\n    }\n    const addValues = (...items) => {\n      for (const value of items) {\n        if (Array.isArray(value)) {\n          addValues(...value);\n        } else if (typeof value === \"object\") {\n          addValues(...Object.values(value));\n        } else {\n          values.push(value);\n        }\n      }\n    };\n    addValues(...keys.map((key) => this.properties[key]));\n    return values;\n  }\n  getKeys(direction) {\n    return this.getDirectionValues(direction, this.directionKeys);\n  }\n  getKeyProperties(direction) {\n    return this.directionKeys[this.resolveKeyDirection(direction)] ?? [];\n  }\n  getNames(direction) {\n    return this.getDirectionValues(direction, this.directionNames);\n  }\n  resolveKeyDirection(direction) {\n    return direction;\n  }\n  // The union of the series domain ('community') and series-option domains ('enterprise').\n  getDomain(direction) {\n    const seriesDomain = this.getSeriesDomain(direction);\n    const moduleDomains = this.moduleMap.mapModules((module) => module.getDomain(direction)).flat();\n    return moduleDomains.length !== 0 ? seriesDomain.concat(moduleDomains) : seriesDomain;\n  }\n  getRange(direction, visibleRange) {\n    return this.getSeriesRange(direction, visibleRange);\n  }\n  getVisibleItems(_xVisibleRange, _yVisibleRange, _minVisibleItems) {\n    return Infinity;\n  }\n  getGradientFillOptions({ bounds }, defaultColorRange) {\n    const { axes } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const xRange = xAxis?.range ?? [0, 1];\n    const yRange = yAxis?.range ?? [0, 1];\n    const [x1, x2] = findMinMax(xRange);\n    const [y1, y2] = findMinMax(yRange);\n    const width2 = x2 - x1;\n    const height2 = y2 - y1;\n    let domain = [0, 1];\n    if (bounds === \"series\") {\n      domain = this.getSeriesDomain(\"y\" /* Y */);\n    } else if (bounds === \"axes\") {\n      domain = yAxis?.scale.domain ?? [0, 1];\n    }\n    return {\n      bbox: new BBox(x1, y1, width2, height2),\n      domain,\n      defaultColorRange\n    };\n  }\n  // Indicate that something external changed and we should recalculate nodeData.\n  markNodeDataDirty() {\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n    this.visibleMaybeChanged();\n  }\n  visibleMaybeChanged() {\n    this.ctx.seriesStateManager.updateSeries(this);\n  }\n  getOpacity() {\n    const defaultOpacity = 1;\n    const { dimOpacity = 1, enabled = true } = this.properties.highlightStyle.series;\n    if (!enabled || dimOpacity === defaultOpacity) {\n      return defaultOpacity;\n    }\n    switch (this.isItemIdHighlighted()) {\n      case 0 /* None */:\n      case 1 /* This */:\n        return defaultOpacity;\n      case 2 /* Other */:\n      default:\n        return dimOpacity;\n    }\n  }\n  getStrokeWidth(defaultStrokeWidth) {\n    const { strokeWidth, enabled = true } = this.properties.highlightStyle.series;\n    if (!enabled || strokeWidth === void 0) {\n      return defaultStrokeWidth;\n    }\n    switch (this.isItemIdHighlighted()) {\n      case 1 /* This */:\n        return strokeWidth;\n      case 0 /* None */:\n      case 2 /* Other */:\n        return defaultStrokeWidth;\n    }\n  }\n  isItemIdHighlighted() {\n    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;\n    if (series == null) {\n      return 0 /* None */;\n    }\n    if (series !== this) {\n      return 2 /* Other */;\n    }\n    return 1 /* This */;\n  }\n  getModuleTooltipParams() {\n    return this.moduleMap.mapModules((module) => module.getTooltipParams()).reduce((total, current) => Object.assign(total, current), {});\n  }\n  pickNode(point, intent, exactMatchOnly = false) {\n    const { pickModes, pickModeAxis, visible, contentGroup } = this;\n    if (!visible || !contentGroup.visible)\n      return;\n    if (intent === \"highlight\" && !this.properties.highlight.enabled)\n      return;\n    if (intent === \"highlight-tooltip\" && !this.properties.highlight.enabled)\n      return;\n    let maxDistance = Infinity;\n    if (intent === \"tooltip\" || intent === \"highlight-tooltip\") {\n      const { tooltip } = this.properties;\n      maxDistance = typeof tooltip.range === \"number\" ? tooltip.range : Infinity;\n      exactMatchOnly || (exactMatchOnly = tooltip.range === \"exact\");\n    } else if (intent === \"event\" || intent === \"context-menu\") {\n      const { nodeClickRange } = this.properties;\n      maxDistance = typeof nodeClickRange === \"number\" ? nodeClickRange : Infinity;\n      exactMatchOnly || (exactMatchOnly = nodeClickRange === \"exact\");\n    }\n    const selectedPickModes = pickModes.filter(\n      (m) => !exactMatchOnly || m === 0 /* EXACT_SHAPE_MATCH */\n    );\n    const { x, y } = point;\n    const key = JSON.stringify({ x, y, maxDistance, selectedPickModes });\n    if (this._pickNodeCache.has(key)) {\n      return this._pickNodeCache.get(key);\n    }\n    for (const pickMode of selectedPickModes) {\n      let match;\n      switch (pickMode) {\n        case 0 /* EXACT_SHAPE_MATCH */:\n          match = this.pickNodeExactShape(point);\n          break;\n        case 1 /* NEAREST_NODE */:\n          match = this.pickNodeClosestDatum(point);\n          break;\n        case 2 /* AXIS_ALIGNED */:\n          match = pickModeAxis != null ? this.pickNodeMainAxisFirst(point, pickModeAxis === \"main-category\") : void 0;\n          break;\n      }\n      if (match && match.distance <= maxDistance) {\n        return this._pickNodeCache.set(key, { pickMode, match: match.datum, distance: match.distance });\n      }\n    }\n    return this._pickNodeCache.set(key, void 0);\n  }\n  pickNodeExactShape(point) {\n    const match = this.contentGroup.pickNode(point.x, point.y);\n    if (match && match.datum.missing !== true) {\n      return { datum: match.datum, distance: 0 };\n    }\n    return void 0;\n  }\n  pickNodeClosestDatum(_point) {\n    throw new Error(\"AG Charts - Series.pickNodeClosestDatum() not implemented\");\n  }\n  pickNodeNearestDistantObject(point, items) {\n    const match = nearestSquared(point.x, point.y, items);\n    if (match.nearest !== void 0 && match.nearest.datum.missing !== true) {\n      return { datum: match.nearest.datum, distance: Math.sqrt(match.distanceSquared) };\n    }\n    return void 0;\n  }\n  pickNodeMainAxisFirst(_point, _requireCategoryAxis) {\n    throw new Error(\"AG Charts - Series.pickNodeMainAxisFirst() not implemented\");\n  }\n  getLabelData() {\n    return [];\n  }\n  updatePlacedLabelData(_labels) {\n    return;\n  }\n  fireNodeClickEvent(event, datum) {\n    this.fireEvent(new this.NodeEvent(\"nodeClick\", event, datum, this));\n  }\n  fireNodeDoubleClickEvent(event, datum) {\n    this.fireEvent(new this.NodeEvent(\"nodeDoubleClick\", event, datum, this));\n  }\n  createNodeContextMenuActionEvent(event, datum) {\n    return new this.NodeEvent(\"nodeContextMenuAction\", event, datum, this);\n  }\n  onLegendInitialState(legendType, initialState) {\n    const { visible = true, itemId, legendItemName } = initialState ?? {};\n    this.toggleSeriesItem(visible, legendType, itemId, legendItemName);\n  }\n  onLegendItemClick(event) {\n    const { enabled, itemId, series, legendType } = event;\n    const legendItemName = \"legendItemName\" in this.properties ? this.properties.legendItemName : void 0;\n    const legendItemKey = \"legendItemKey\" in this.properties ? this.properties.legendItemKey : void 0;\n    const matchedLegendItemName = legendItemName != void 0 && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName || legendItemKey != void 0) {\n      this.toggleSeriesItem(enabled, legendType, itemId, legendItemName, event);\n    }\n  }\n  onLegendItemDoubleClick(event) {\n    const { enabled, itemId, series, numVisibleItems, legendType } = event;\n    const legendItemName = \"legendItemName\" in this.properties ? this.properties.legendItemName : void 0;\n    const legendItemKey = \"legendItemKey\" in this.properties ? this.properties.legendItemKey : void 0;\n    const matchedLegendItemName = legendItemName != void 0 && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName || legendItemKey != void 0) {\n      this.toggleSeriesItem(true, legendType, itemId, legendItemName, event);\n    } else if (enabled && numVisibleItems === 1) {\n      this.toggleSeriesItem(true, legendType, void 0, legendItemName);\n    } else {\n      this.toggleSeriesItem(false, legendType, void 0, legendItemName);\n    }\n  }\n  toggleSeriesItem(enabled, legendType, itemId, legendItemName, legendEvent) {\n    const seriesId = this.id;\n    if (enabled || legendType !== \"category\") {\n      this.visible = enabled;\n    }\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n    const event = {\n      type: \"seriesVisibilityChange\",\n      seriesId,\n      itemId,\n      legendItemName: legendEvent?.legendItemName ?? legendItemName,\n      visible: enabled\n    };\n    this.fireEvent(event);\n    this.ctx.legendManager.toggleItem({ enabled, seriesId, itemId, legendItemName });\n  }\n  isEnabled() {\n    return this.visible;\n  }\n  getModuleMap() {\n    return this.moduleMap;\n  }\n  createModuleContext() {\n    return { ...this.ctx, series: this };\n  }\n  getLabelText(label, params, defaultFormatter = formatValue) {\n    if (label.formatter) {\n      return this.ctx.callbackCache.call(label.formatter, { seriesId: this.id, ...params }) ?? defaultFormatter(params.value);\n    }\n    return defaultFormatter(params.value);\n  }\n  getMarkerStyle(marker, params, defaultStyle = marker.getStyle()) {\n    const defaultSize = { size: params.datum.point?.size ?? 0 };\n    const markerStyle = mergeDefaults(defaultSize, defaultStyle);\n    if (marker.itemStyler) {\n      const style = this.ctx.callbackCache.call(marker.itemStyler, {\n        seriesId: this.id,\n        ...markerStyle,\n        ...params,\n        datum: params.datum.datum\n      });\n      return mergeDefaults(style, markerStyle);\n    }\n    return markerStyle;\n  }\n  updateMarkerStyle(markerNode, marker, params, defaultStyle = marker.getStyle(), { applyTranslation = true, selected = true } = {}) {\n    const { point } = params.datum;\n    const activeStyle = this.getMarkerStyle(marker, params, defaultStyle);\n    const visible = this.visible && activeStyle.size > 0 && point && !isNaN(point.x) && !isNaN(point.y);\n    if (applyTranslation) {\n      markerNode.setProperties({ visible, ...activeStyle, translationX: point?.x, translationY: point?.y });\n    } else {\n      markerNode.setProperties({ visible, ...activeStyle });\n    }\n    if (!selected) {\n      markerNode.fillOpacity *= CROSS_FILTER_MARKER_FILL_OPACITY_FACTOR;\n      markerNode.strokeOpacity *= CROSS_FILTER_MARKER_STROKE_OPACITY_FACTOR;\n    }\n    if (typeof marker.shape === \"function\" && !markerNode.dirtyPath) {\n      markerNode.path.clear(true);\n      markerNode.updatePath();\n      markerNode.checkPathDirty();\n      const bb = markerNode.getBBox();\n      if (point !== void 0 && bb.isFinite()) {\n        const center2 = bb.computeCenter();\n        const [dx, dy] = [\"x\", \"y\"].map(\n          (key) => (activeStyle.strokeWidth ?? 0) + Math.abs(center2[key] - point[key])\n        );\n        point.focusSize = Math.max(bb.width + dx, bb.height + dy);\n      }\n    }\n  }\n  get nodeDataDependencies() {\n    return this._nodeDataDependencies ?? { seriesRectWidth: NaN, seriesRectHeight: NaN };\n  }\n  checkResize(newSeriesRect) {\n    const { width: seriesRectWidth, height: seriesRectHeight } = newSeriesRect ?? { width: NaN, height: NaN };\n    const newNodeDataDependencies = newSeriesRect ? { seriesRectWidth, seriesRectHeight } : void 0;\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n      this.markNodeDataDirty();\n    }\n    return resize;\n  }\n  pickFocus(_opts) {\n    return void 0;\n  }\n  resetDatumCallbackCache() {\n    this.datumCallbackCache.clear();\n  }\n  cachedDatumCallback(id, fn) {\n    const { datumCallbackCache } = this;\n    const existing = datumCallbackCache.get(id);\n    if (existing != null)\n      return existing;\n    const value = fn();\n    datumCallbackCache.set(id, value);\n    return value;\n  }\n};\n__decorateClass([\n  ActionOnSet({\n    changeValue: function(newVal, oldVal) {\n      this.onSeriesGroupingChange(oldVal, newVal);\n    }\n  })\n], Series.prototype, \"seriesGrouping\", 2);\n\n// packages/ag-charts-community/src/scene/polyRoots.ts\nfunction linearRoot(a, b) {\n  const t = -b / a;\n  return a !== 0 && t >= 0 && t <= 1 ? [t] : [];\n}\nfunction quadraticRoots(a, b, c) {\n  if (a === 0) {\n    return linearRoot(b, c);\n  }\n  const D = b * b - 4 * a * c;\n  const roots = [];\n  if (D === 0) {\n    const t = -b / (2 * a);\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n  } else if (D > 0) {\n    const rD = Math.sqrt(D);\n    const t1 = (-b - rD) / (2 * a);\n    const t2 = (-b + rD) / (2 * a);\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n  }\n  return roots;\n}\nfunction cubicRoots(a, b, c, d) {\n  if (a === 0) {\n    return quadraticRoots(b, c, d);\n  }\n  const A = b / a;\n  const B = c / a;\n  const C2 = d / a;\n  const Q = (3 * B - A * A) / 9;\n  const R = (9 * A * B - 27 * C2 - 2 * A * A * A) / 54;\n  const D = Q * Q * Q + R * R;\n  const third = 1 / 3;\n  const roots = [];\n  if (D >= 0) {\n    const rD = Math.sqrt(D);\n    const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);\n    const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);\n    const Im = Math.abs(Math.sqrt(3) * (S - T) / 2);\n    const t = -third * A + (S + T);\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n    if (Im === 0) {\n      const t2 = -third * A - (S + T) / 2;\n      if (t2 >= 0 && t2 <= 1) {\n        roots.push(t2);\n      }\n    }\n  } else {\n    const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));\n    const thirdA = third * A;\n    const twoSqrtQ = 2 * Math.sqrt(-Q);\n    const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;\n    const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;\n    const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n    if (t3 >= 0 && t3 <= 1) {\n      roots.push(t3);\n    }\n  }\n  return roots;\n}\n\n// packages/ag-charts-community/src/scene/intersection.ts\nfunction segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n  const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);\n  if (d === 0) {\n    return 0;\n  }\n  const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;\n  const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;\n  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n    return 1;\n  }\n  return 0;\n}\nfunction cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {\n  let intersections = 0;\n  const A = y1 - y2;\n  const B = x2 - x1;\n  const C2 = x1 * (y2 - y1) - y1 * (x2 - x1);\n  const bx = bezierCoefficients(px1, px2, px3, px4);\n  const by = bezierCoefficients(py1, py2, py3, py4);\n  const a = A * bx[0] + B * by[0];\n  const b = A * bx[1] + B * by[1];\n  const c = A * bx[2] + B * by[2];\n  const d = A * bx[3] + B * by[3] + C2;\n  const roots = cubicRoots(a, b, c, d);\n  for (const t of roots) {\n    const tt = t * t;\n    const ttt = t * tt;\n    const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];\n    const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];\n    let s;\n    if (x1 === x2) {\n      s = (y - y1) / (y2 - y1);\n    } else {\n      s = (x - x1) / (x2 - x1);\n    }\n    if (s >= 0 && s <= 1) {\n      intersections++;\n    }\n  }\n  return intersections;\n}\nfunction bezierCoefficients(P1, P2, P3, P4) {\n  return [\n    // Bzier expressed as matrix operations:\n    -P1 + 3 * P2 - 3 * P3 + P4,\n    //                 |-1  3 -3  1| |P1|\n    3 * P1 - 6 * P2 + 3 * P3,\n    //   [t^3 t^2 t 1] | 3 -6  3  0| |P2|\n    -3 * P1 + 3 * P2,\n    //                 |-3  3  0  0| |P3|\n    P1\n    //                 | 1  0  0  0| |P4|\n  ];\n}\nfunction arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {\n  if (isNaN(cx) || isNaN(cy)) {\n    return 0;\n  }\n  if (counterClockwise) {\n    [endAngle, startAngle] = [startAngle, endAngle];\n  }\n  const k = (y2 - y1) / (x2 - x1);\n  const y0 = y1 - k * x1;\n  const a = Math.pow(k, 2) + 1;\n  const b = 2 * (k * (y0 - cy) - cx);\n  const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);\n  const d = Math.pow(b, 2) - 4 * a * c;\n  if (d < 0) {\n    return 0;\n  }\n  const i1x = (-b + Math.sqrt(d)) / 2 / a;\n  const i2x = (-b - Math.sqrt(d)) / 2 / a;\n  let intersections = 0;\n  [i1x, i2x].forEach((x) => {\n    const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);\n    if (!isXInsideLine) {\n      return;\n    }\n    const y = k * x + y0;\n    const adjacent = x - cx;\n    const opposite = y - cy;\n    const angle2 = Math.atan2(opposite, adjacent);\n    if (isBetweenAngles(angle2, startAngle, endAngle)) {\n      intersections++;\n    }\n  });\n  return intersections;\n}\n\n// packages/ag-charts-community/src/scene/util/bezier.ts\nfunction evaluateBezier(p0, p1, p2, p3, t) {\n  return (1 - t) ** 3 * p0 + 3 * (1 - t) ** 2 * t * p1 + 3 * (1 - t) * t ** 2 * p2 + t ** 3 * p3;\n}\nfunction solveBezier(p0, p1, p2, p3, value) {\n  if (value <= Math.min(p0, p3)) {\n    return p0 < p3 ? 0 : 1;\n  } else if (value >= Math.max(p0, p3)) {\n    return p0 < p3 ? 1 : 0;\n  }\n  let t0 = 0;\n  let t1 = 1;\n  let t = NaN;\n  for (let i = 0; i < 12; i += 1) {\n    t = (t0 + t1) / 2;\n    const curveValue = evaluateBezier(p0, p1, p2, p3, t);\n    if (curveValue < value) {\n      t0 = t;\n    } else {\n      t1 = t;\n    }\n  }\n  return t;\n}\nfunction splitBezier(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, t) {\n  const x01 = (1 - t) * p0x + t * p1x;\n  const y01 = (1 - t) * p0y + t * p1y;\n  const x12 = (1 - t) * p1x + t * p2x;\n  const y12 = (1 - t) * p1y + t * p2y;\n  const x23 = (1 - t) * p2x + t * p3x;\n  const y23 = (1 - t) * p2y + t * p3y;\n  const x012 = (1 - t) * x01 + t * x12;\n  const y012 = (1 - t) * y01 + t * y12;\n  const x123 = (1 - t) * x12 + t * x23;\n  const y123 = (1 - t) * y12 + t * y23;\n  const x0123 = (1 - t) * x012 + t * x123;\n  const y0123 = (1 - t) * y012 + t * y123;\n  return [\n    [\n      { x: p0x, y: p0y },\n      { x: x01, y: y01 },\n      { x: x012, y: y012 },\n      { x: x0123, y: y0123 }\n    ],\n    [\n      { x: x0123, y: y0123 },\n      { x: x123, y: y123 },\n      { x: x23, y: y23 },\n      { x: p3x, y: p3y }\n    ]\n  ];\n}\nfunction calculateDerivativeExtrema(p0, p1, p2, p3) {\n  const a = -p0 + 3 * p1 - 3 * p2 + p3;\n  const b = 3 * p0 - 6 * p1 + 3 * p2;\n  const c = -3 * p0 + 3 * p1;\n  if (a === 0) {\n    if (b !== 0) {\n      const t = -c / b;\n      if (t > 0 && t < 1) {\n        return [t];\n      }\n    }\n    return [];\n  }\n  const discriminant = b * b - 4 * a * c;\n  if (discriminant >= 0) {\n    const sqrtDiscriminant = Math.sqrt(discriminant);\n    const t1 = (-b + sqrtDiscriminant) / (2 * a);\n    const t2 = (-b - sqrtDiscriminant) / (2 * a);\n    return [t1, t2].filter((t) => t > 0 && t < 1);\n  }\n  return [];\n}\nfunction calculateDerivativeExtremaXY(sx, sy, cp1x, cp1y, cp2x, cp2y, x, y) {\n  const tx = calculateDerivativeExtrema(sx, cp1x, cp2x, x);\n  const ty = calculateDerivativeExtrema(sy, cp1y, cp2y, y);\n  return [...tx, ...ty];\n}\n\n// packages/ag-charts-community/src/scene/extendedPath2D.ts\nvar ExtendedPath2D = class {\n  constructor() {\n    // The methods of this class will likely be called many times per animation frame,\n    // and any allocation can trigger a GC cycle during animation, so we attempt\n    // to minimize the number of allocations.\n    this.path2d = new Path2D();\n    this.previousCommands = [];\n    this.previousParams = [];\n    this.previousClosedPath = false;\n    this.commands = [];\n    this.params = [];\n    this.openedPath = false;\n    this.closedPath = false;\n  }\n  isEmpty() {\n    return this.commands.length === 0;\n  }\n  isDirty() {\n    return this.closedPath !== this.previousClosedPath || this.previousCommands.length !== this.commands.length || this.previousParams.length !== this.params.length || this.previousCommands.toString() !== this.commands.toString() || this.previousParams.toString() !== this.params.toString();\n  }\n  getPath2D() {\n    return this.path2d;\n  }\n  moveTo(x, y) {\n    this.openedPath = true;\n    this.path2d.moveTo(x, y);\n    this.commands.push(0 /* Move */);\n    this.params.push(x, y);\n  }\n  lineTo(x, y) {\n    if (this.openedPath) {\n      this.path2d.lineTo(x, y);\n      this.commands.push(1 /* Line */);\n      this.params.push(x, y);\n    } else {\n      this.moveTo(x, y);\n    }\n  }\n  rect(x, y, width2, height2) {\n    this.moveTo(x, y);\n    this.lineTo(x + width2, y);\n    this.lineTo(x + width2, y + height2);\n    this.lineTo(x, y + height2);\n    this.closePath();\n  }\n  roundRect(x, y, width2, height2, radii) {\n    radii = Math.min(radii, width2 / 2, height2 / 2);\n    this.moveTo(x, y + radii);\n    this.arc(x + radii, y + radii, radii, Math.PI, 1.5 * Math.PI);\n    this.lineTo(x + radii, y);\n    this.lineTo(x + width2 - radii, y);\n    this.arc(x + width2 - radii, y + radii, radii, 1.5 * Math.PI, 2 * Math.PI);\n    this.lineTo(x + width2, y + radii);\n    this.lineTo(x + width2, y + height2 - radii);\n    this.arc(x + width2 - radii, y + height2 - radii, radii, 0, Math.PI / 2);\n    this.lineTo(x + width2 - radii, y + height2);\n    this.lineTo(x + radii, y + height2);\n    this.arc(x + +radii, y + height2 - radii, radii, Math.PI / 2, Math.PI);\n    this.lineTo(x, y + height2 - radii);\n    this.closePath();\n  }\n  arc(x, y, r, sAngle, eAngle, counterClockwise) {\n    this.openedPath = true;\n    this.path2d.arc(x, y, r, sAngle, eAngle, counterClockwise);\n    this.commands.push(2 /* Arc */);\n    this.params.push(x, y, r, sAngle, eAngle, counterClockwise ? 1 : 0);\n  }\n  cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {\n    if (!this.openedPath) {\n      this.moveTo(cx1, cy1);\n    }\n    this.path2d.bezierCurveTo(cx1, cy1, cx2, cy2, x, y);\n    this.commands.push(3 /* Curve */);\n    this.params.push(cx1, cy1, cx2, cy2, x, y);\n  }\n  closePath() {\n    if (this.openedPath) {\n      this.path2d.closePath();\n      this.commands.push(4 /* ClosePath */);\n      this.openedPath = false;\n      this.closedPath = true;\n    }\n  }\n  clear(trackChanges) {\n    if (trackChanges) {\n      this.previousCommands = this.commands;\n      this.previousParams = this.params;\n      this.previousClosedPath = this.closedPath;\n    }\n    this.path2d = new Path2D();\n    this.openedPath = false;\n    this.closedPath = false;\n    this.commands = [];\n    this.params = [];\n  }\n  isPointInPath(x, y) {\n    const commands = this.commands;\n    const params = this.params;\n    const cn = commands.length;\n    const ox = -1e4;\n    const oy = -1e4;\n    let sx = NaN;\n    let sy = NaN;\n    let px = 0;\n    let py = 0;\n    let intersectionCount = 0;\n    for (let ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);\n          px = params[pi++];\n          sx = px;\n          py = params[pi++];\n          sy = py;\n          break;\n        case 1 /* Line */:\n          intersectionCount += segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y);\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case 3 /* Curve */:\n          intersectionCount += cubicSegmentIntersections(\n            px,\n            py,\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            ox,\n            oy,\n            x,\n            y\n          );\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case 2 /* Arc */: {\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const startAngle = params[pi++];\n          const endAngle = params[pi++];\n          const counterClockwise = Boolean(params[pi++]);\n          intersectionCount += arcIntersections(\n            cx,\n            cy,\n            r,\n            startAngle,\n            endAngle,\n            counterClockwise,\n            ox,\n            oy,\n            x,\n            y\n          );\n          if (!isNaN(sx)) {\n            const startX = cx + Math.cos(startAngle) * r;\n            const startY = cy + Math.sin(startAngle) * r;\n            intersectionCount += segmentIntersection(px, py, startX, startY, ox, oy, x, y);\n          }\n          px = cx + Math.cos(endAngle) * r;\n          py = cy + Math.sin(endAngle) * r;\n          break;\n        }\n        case 4 /* ClosePath */:\n          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);\n          break;\n      }\n    }\n    return intersectionCount % 2 === 1;\n  }\n  distanceSquared(x, y) {\n    let best = Infinity;\n    const commands = this.commands;\n    const params = this.params;\n    const cn = commands.length;\n    let sx = NaN;\n    let sy = NaN;\n    let px = 0;\n    let py = 0;\n    for (let ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          px = sx = params[pi++];\n          py = sy = params[pi++];\n          break;\n        case 1 /* Line */: {\n          const nx = params[pi++];\n          const ny = params[pi++];\n          best = lineDistanceSquared(x, y, px, py, nx, ny, best);\n          break;\n        }\n        case 3 /* Curve */:\n          logger_exports.error(\"Command.Curve distanceSquare not implemented\");\n          break;\n        case 2 /* Arc */: {\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const startAngle = params[pi++];\n          const endAngle = params[pi++];\n          const startX = cx + Math.cos(startAngle) * r;\n          const startY = cy + Math.sin(startAngle) * r;\n          const counterClockwise = Boolean(params[pi++]);\n          best = lineDistanceSquared(x, y, px, py, startX, startY, best);\n          best = arcDistanceSquared(x, y, cx, cy, r, startAngle, endAngle, counterClockwise, best);\n          px = cx + Math.cos(endAngle) * r;\n          py = cy + Math.sin(endAngle) * r;\n          break;\n        }\n        case 4 /* ClosePath */:\n          best = lineDistanceSquared(x, y, px, py, sx, sy, best);\n          break;\n      }\n    }\n    return best;\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\n  toSVG(transform = (x, y) => ({ x, y })) {\n    const buffer = [];\n    const { commands, params } = this;\n    const addCommand = (command, ...points) => {\n      buffer.push(command);\n      for (let i = 0; i < points.length; i += 2) {\n        const { x, y } = transform(points[i], points[i + 1]);\n        buffer.push(x, y);\n      }\n    };\n    let pi = 0;\n    for (const command of commands) {\n      switch (command) {\n        case 0 /* Move */:\n          addCommand(\"M\", params[pi++], params[pi++]);\n          break;\n        case 1 /* Line */:\n          addCommand(\"L\", params[pi++], params[pi++]);\n          break;\n        case 3 /* Curve */:\n          addCommand(\"C\", params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], params[pi++]);\n          break;\n        case 2 /* Arc */: {\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const A0 = params[pi++];\n          const A1 = params[pi++];\n          const ccw = params[pi++];\n          let sweep = ccw ? A0 - A1 : A1 - A0;\n          if (sweep < 0) {\n            sweep += Math.ceil(-sweep / (2 * Math.PI)) * 2 * Math.PI;\n          }\n          if (ccw) {\n            sweep = -sweep;\n          }\n          const arcSections = Math.max(Math.ceil(Math.abs(sweep) / (Math.PI / 2)), 1);\n          const step = sweep / arcSections;\n          const h = 4 / 3 * Math.tan(step / 4);\n          const move = buffer.length === 0 ? \"M\" : \"L\";\n          addCommand(move, cx + Math.cos(A0) * r, cy + Math.sin(A0) * r);\n          for (let i = 0; i < arcSections; i += 1) {\n            const a0 = A0 + step * (i + 0);\n            const a1 = A0 + step * (i + 1);\n            const rSinStart = r * Math.sin(a0);\n            const rCosStart = r * Math.cos(a0);\n            const rSinEnd = r * Math.sin(a1);\n            const rCosEnd = r * Math.cos(a1);\n            addCommand(\n              \"C\",\n              cx + rCosStart - h * rSinStart,\n              cy + rSinStart + h * rCosStart,\n              cx + rCosEnd + h * rSinEnd,\n              cy + rSinEnd - h * rCosEnd,\n              cx + rCosEnd,\n              cy + rSinEnd\n            );\n          }\n          break;\n        }\n        case 4 /* ClosePath */:\n          buffer.push(\"Z\");\n          break;\n      }\n    }\n    return buffer.join(\" \");\n  }\n  computeBBox() {\n    const { commands, params } = this;\n    let [top, left, right, bot] = [Infinity, Infinity, -Infinity, -Infinity];\n    let [sx, sy] = [NaN, NaN];\n    let [mx, my] = [NaN, NaN];\n    const joinPoint = (x, y, updatestart) => {\n      top = Math.min(y, top);\n      left = Math.min(x, left);\n      right = Math.max(x, right);\n      bot = Math.max(y, bot);\n      if (updatestart) {\n        [sx, sy] = [x, y];\n      }\n    };\n    let pi = 0;\n    for (const command of commands) {\n      switch (command) {\n        case 0 /* Move */:\n          joinPoint(params[pi++], params[pi++], true);\n          [mx, my] = [sx, sy];\n          break;\n        case 1 /* Line */:\n          joinPoint(params[pi++], params[pi++], true);\n          break;\n        case 3 /* Curve */: {\n          const cp1x = params[pi++];\n          const cp1y = params[pi++];\n          const cp2x = params[pi++];\n          const cp2y = params[pi++];\n          const x = params[pi++];\n          const y = params[pi++];\n          joinPoint(x, y, true);\n          const Ts = calculateDerivativeExtremaXY(sx, sy, cp1x, cp1y, cp2x, cp2y, x, y);\n          Ts.forEach((t) => {\n            const px = evaluateBezier(sx, cp1x, cp2x, x, t);\n            const py = evaluateBezier(sy, cp1y, cp2y, y, t);\n            joinPoint(px, py);\n          });\n          break;\n        }\n        case 2 /* Arc */: {\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          let A0 = normalizeAngle360(params[pi++]);\n          let A1 = normalizeAngle360(params[pi++]);\n          const ccw = params[pi++];\n          if (ccw) {\n            [A0, A1] = [A1, A0];\n          }\n          const joinAngle = (angle2, updatestart) => {\n            const px = cx + r * Math.cos(angle2);\n            const py = cy + r * Math.sin(angle2);\n            joinPoint(px, py, updatestart);\n          };\n          joinAngle(A0);\n          joinAngle(A1, true);\n          const criticalAngles = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2];\n          for (const crit of criticalAngles) {\n            if (A0 < A1 && A0 <= crit && crit <= A1 || A0 > A1 && (A0 <= crit || crit <= A1)) {\n              joinAngle(crit);\n            }\n          }\n          break;\n        }\n        case 4 /* ClosePath */:\n          [sx, sy] = [mx, my];\n          break;\n      }\n    }\n    return new BBox(left, top, right - left, bot - top);\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/path.ts\nfunction ScenePathChangeDetection(opts) {\n  const { changeCb, convertor } = opts ?? {};\n  return SceneChangeDetection({ type: \"path\", convertor, changeCb });\n}\nvar Path = class extends Shape {\n  constructor() {\n    super(...arguments);\n    /**\n     * Declare a path to retain for later rendering and hit testing\n     * using custom Path2D class. Think of it as a TypeScript version\n     * of the native Path2D (with some differences) that works in all browsers.\n     */\n    this.path = new ExtendedPath2D();\n    this._clipX = NaN;\n    this._clipY = NaN;\n    this.clip = false;\n    /**\n     * The path only has to be updated when certain attributes change.\n     * For example, if transform attributes (such as `translationX`)\n     * are changed, we don't have to update the path. The `dirtyPath` flag\n     * is how we keep track if the path has to be updated or not.\n     */\n    this._dirtyPath = true;\n    this.lastPixelRatio = NaN;\n  }\n  set clipX(value) {\n    this._clipX = value;\n    this.dirtyPath = true;\n  }\n  set clipY(value) {\n    this._clipY = value;\n    this.dirtyPath = true;\n  }\n  set dirtyPath(value) {\n    if (this._dirtyPath !== value) {\n      this._dirtyPath = value;\n      if (value) {\n        this.markDirty();\n      }\n    }\n  }\n  get dirtyPath() {\n    return this._dirtyPath;\n  }\n  checkPathDirty() {\n    if (this._dirtyPath) {\n      return;\n    }\n    this.dirtyPath = this.path.isDirty() || (this.fillShadow?.isDirty() ?? false) || (this._clipPath?.isDirty() ?? false);\n  }\n  isPointInPath(x, y) {\n    this.updatePathIfDirty();\n    return this.path.closedPath && this.path.isPointInPath(x, y);\n  }\n  distanceSquared(x, y) {\n    return this.distanceSquaredTransformedPoint(x, y);\n  }\n  svgPathData(transform) {\n    this.updatePathIfDirty();\n    return this.path.toSVG(transform);\n  }\n  distanceSquaredTransformedPoint(x, y) {\n    this.updatePathIfDirty();\n    if (this.path.closedPath && this.path.isPointInPath(x, y)) {\n      return 0;\n    }\n    return this.path.distanceSquared(x, y);\n  }\n  isDirtyPath() {\n    return false;\n  }\n  updatePath() {\n  }\n  updatePathIfDirty() {\n    if (this.dirtyPath || this.isDirtyPath()) {\n      this.updatePath();\n      this.dirtyPath = false;\n    }\n  }\n  preRender(renderCtx) {\n    if (renderCtx.devicePixelRatio !== this.lastPixelRatio) {\n      this.dirtyPath = true;\n    }\n    this.lastPixelRatio = renderCtx.devicePixelRatio;\n    this.updatePathIfDirty();\n    return super.preRender(renderCtx, this.path.commands.length);\n  }\n  render(renderCtx) {\n    const { ctx } = renderCtx;\n    if (this.clip && !isNaN(this._clipX) && !isNaN(this._clipY)) {\n      ctx.save();\n      const margin = this.strokeWidth / 2;\n      this._clipPath ?? (this._clipPath = new ExtendedPath2D());\n      this._clipPath.clear();\n      this._clipPath.rect(-margin, -margin, this._clipX + margin, this._clipY + margin + margin);\n      ctx.clip(this._clipPath?.getPath2D());\n      if (this._clipX > 0 && this._clipY > 0) {\n        this.drawPath(ctx);\n      }\n      ctx.restore();\n    } else {\n      this._clipPath = void 0;\n      this.drawPath(ctx);\n    }\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n  drawPath(ctx) {\n    this.fillStroke(ctx, this.path.getPath2D());\n  }\n  toSVG() {\n    if (!this.visible)\n      return;\n    const element2 = createSvgElement(\"path\");\n    element2.setAttribute(\"d\", this.svgPathData());\n    this.applySvgFillAttributes(element2);\n    this.applySvgStrokeAttributes(element2);\n    return {\n      elements: [element2]\n    };\n  }\n};\nPath.className = \"Path\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clip\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipX\", 1);\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipY\", 1);\n\n// packages/ag-charts-community/src/dom/focusIndicator.ts\nvar FocusIndicator = class {\n  constructor(swapChain) {\n    this.swapChain = swapChain;\n    this.div = createElement(\"div\");\n    this.svg = createSvgElement(\"svg\");\n    this.outerPath = createSvgElement(\"path\");\n    this.innerPath = createSvgElement(\"path\");\n    this.svg.append(this.outerPath);\n    this.svg.append(this.innerPath);\n    this.outerPath.classList.add(\"ag-charts-focus-svg-outer-path\");\n    this.innerPath.classList.add(\"ag-charts-focus-svg-inner-path\");\n    this.element = createElement(\"div\", \"ag-charts-focus-indicator\");\n    this.element.ariaHidden = \"true\";\n    this.element.append(this.svg);\n    this.swapChain.addListener(\"swap\", (parent) => this.onSwap(parent));\n  }\n  clear() {\n  }\n  update(focus, rect, clip) {\n    if (rect == null)\n      return;\n    if (focus instanceof Path) {\n      const transform = (localX, localY) => {\n        let { x, y } = Transformable.toCanvasPoint(focus, localX, localY);\n        x -= rect.x ?? 0;\n        y -= rect.y ?? 0;\n        return { x, y };\n      };\n      const d = focus.svgPathData(transform);\n      this.outerPath.setAttribute(\"d\", d);\n      this.innerPath.setAttribute(\"d\", d);\n      this.show(this.svg);\n    } else {\n      let bbox;\n      if (clip) {\n        const x0 = Math.max(focus.x - rect.x, 0);\n        const y0 = Math.max(focus.y - rect.y, 0);\n        const x1 = Math.min(focus.x + focus.width - rect.x, rect.width);\n        const y1 = Math.min(focus.y + focus.height - rect.y, rect.height);\n        bbox = new BBox(x0, y0, x1 - x0, y1 - y0);\n      } else {\n        bbox = new BBox(focus.x - rect.x, focus.y - rect.y, focus.width, focus.height);\n      }\n      setElementBBox(this.div, bbox);\n      this.show(this.div);\n    }\n  }\n  onSwap(newParent) {\n    if (newParent === this.element.parentElement)\n      return;\n    this.element.remove();\n    newParent.appendChild(this.element);\n    this.overrideFocusVisible(this.focusVisible);\n  }\n  show(child) {\n    this.element.innerHTML = \"\";\n    this.element.append(child);\n  }\n  overrideFocusVisible(focusVisible) {\n    this.focusVisible = focusVisible;\n    const opacity = { true: \"1\", false: \"0\", undefined: \"\" };\n    const parent = this.element.parentElement;\n    parent?.style.setProperty(\"opacity\", opacity[`${focusVisible}`]);\n  }\n  // Get the `:focus-visible` CSS state.\n  isFocusVisible() {\n    const parent = this.element.parentElement;\n    return parent != null && getWindow().getComputedStyle(parent).opacity === \"1\";\n  }\n};\n\n// packages/ag-charts-community/src/dom/focusSwapChain.ts\nvar FocusSwapChain = class {\n  constructor(label1, label2, id, announcerRole) {\n    this.label1 = label1;\n    this.label2 = label2;\n    this.hasFocus = false;\n    this.skipDispatch = false;\n    this.listeners = {\n      blur: [],\n      focus: [],\n      swap: []\n    };\n    this.onBlur = (e) => {\n      setElementStyle(e.target, \"pointer-events\", void 0);\n      return !this.skipDispatch && this.dispatch(\"blur\", e);\n    };\n    this.onFocus = (e) => {\n      setElementStyle(e.target, \"pointer-events\", \"auto\");\n      return !this.skipDispatch && this.dispatch(\"focus\", e);\n    };\n    setAttribute(this.label1, \"id\", `${id}-label1`);\n    setAttribute(this.label2, \"id\", `${id}-label2`);\n    setElementStyle(this.label1, \"display\", \"none\");\n    setElementStyle(this.label2, \"display\", \"none\");\n    this.activeAnnouncer = this.createAnnouncer(announcerRole);\n    this.inactiveAnnouncer = this.createAnnouncer(announcerRole);\n    setAttribute(this.activeAnnouncer, \"tabindex\", 0);\n    this.label2.insertAdjacentElement(\"afterend\", this.activeAnnouncer);\n    this.label2.insertAdjacentElement(\"afterend\", this.inactiveAnnouncer);\n    this.swap(\"\");\n  }\n  createAnnouncer(role) {\n    const announcer = createElement(\"div\");\n    announcer.role = role;\n    announcer.className = \"ag-charts-swapchain\";\n    announcer.addEventListener(\"blur\", this.onBlur);\n    announcer.addEventListener(\"focus\", this.onFocus);\n    return announcer;\n  }\n  destroy() {\n    for (const announcer of [this.activeAnnouncer, this.inactiveAnnouncer]) {\n      announcer.removeEventListener(\"blur\", this.onBlur);\n      announcer.removeEventListener(\"focus\", this.onFocus);\n      announcer.remove();\n    }\n  }\n  focus(opts) {\n    this.focusOptions = opts;\n    this.activeAnnouncer.focus(opts);\n    this.focusOptions = void 0;\n  }\n  update(newLabel) {\n    this.skipDispatch = true;\n    this.swap(newLabel);\n    if (this.hasFocus) {\n      this.activeAnnouncer.focus(this.focusOptions);\n    }\n    this.skipDispatch = false;\n  }\n  addListener(type, handler) {\n    this.listeners[type].push(handler);\n    if (type === \"swap\") {\n      const swapHandler = handler;\n      swapHandler(this.activeAnnouncer);\n    }\n  }\n  dispatch(type, param) {\n    if (type === \"focus\")\n      this.hasFocus = true;\n    else if (type === \"blur\")\n      this.hasFocus = false;\n    this.listeners[type].forEach((fn) => fn(param));\n  }\n  swap(newLabel) {\n    const userTabIndex = this.activeAnnouncer.tabIndex;\n    this.label2.textContent = newLabel;\n    [this.inactiveAnnouncer, this.activeAnnouncer] = [this.activeAnnouncer, this.inactiveAnnouncer];\n    [this.label1, this.label2] = [this.label2, this.label1];\n    setAttributes(this.inactiveAnnouncer, {\n      \"aria-labelledby\": this.label1.id,\n      \"aria-hidden\": true,\n      tabindex: void 0\n    });\n    setAttributes(this.activeAnnouncer, {\n      \"aria-labelledby\": this.label1.id,\n      \"aria-hidden\": false,\n      tabindex: userTabIndex\n    });\n    this.dispatch(\"swap\", this.activeAnnouncer);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/keyBindings.ts\nvar KEY_BINDINGS = {\n  arrowdown: { bindings: [{ code: \"ArrowDown\" }] },\n  arrowleft: { bindings: [{ code: \"ArrowLeft\" }] },\n  arrowright: { bindings: [{ code: \"ArrowRight\" }] },\n  arrowup: { bindings: [{ code: \"ArrowUp\" }] },\n  delete: { bindings: [{ key: \"Backspace\" }, { key: \"Delete\" }], activatesFocusIndicator: false },\n  redo: {\n    bindings: [\n      { key: \"y\", ctrlOrMeta: true },\n      { key: \"z\", ctrlOrMeta: true, shift: true }\n    ],\n    activatesFocusIndicator: false\n  },\n  undo: { bindings: [{ key: \"z\", ctrlOrMeta: true }], activatesFocusIndicator: false },\n  submit: { bindings: [{ key: \"Enter\" }, { code: \"Enter\" }, { code: \"Space\" }] },\n  zoomin: { bindings: [{ key: \"+\" }, { code: \"ZoomIn\" }, { code: \"Add\" }], activatesFocusIndicator: false },\n  zoomout: { bindings: [{ key: \"-\" }, { code: \"ZoomOut\" }, { code: \"Substract\" }], activatesFocusIndicator: false }\n};\nfunction matchesKeyBinding(e, bindings) {\n  for (const kb of bindings) {\n    if (\"code\" in kb) {\n      if (kb.code === e.code)\n        return true;\n    } else {\n      const matches = kb.key === e.key && (kb.shift === void 0 || kb.shift === e.shiftKey) && (kb.ctrlOrMeta === void 0 || kb.ctrlOrMeta === e.ctrlKey || kb.ctrlOrMeta === e.metaKey);\n      if (matches)\n        return true;\n    }\n  }\n  return false;\n}\nfunction mapKeyboardEventToAction(event) {\n  for (const [actionName, { activatesFocusIndicator = true, bindings }] of Object.entries(KEY_BINDINGS)) {\n    if (matchesKeyBinding(event, bindings)) {\n      const name = actionName;\n      return { name, activatesFocusIndicator };\n    }\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/keyboardUtil.ts\nfunction computeCenter(series, hoverRect, pick) {\n  const refPoint = getDatumRefPoint(series, pick.datum);\n  if (refPoint != null)\n    return { x: refPoint.canvasX, y: refPoint.canvasY };\n  const bboxOrPath = pick.bounds;\n  if (bboxOrPath == null)\n    return;\n  if (bboxOrPath instanceof BBox) {\n    const { x: centerX, y: centerY } = bboxOrPath.computeCenter();\n    return {\n      x: hoverRect.x + centerX,\n      y: hoverRect.y + centerY\n    };\n  }\n  return Transformable.toCanvas(bboxOrPath).computeCenter();\n}\nfunction getPickedFocusBBox({ bounds }) {\n  if (bounds instanceof BBox)\n    return bounds;\n  if (bounds != null)\n    return Transformable.toCanvas(bounds);\n  return BBox.NaN;\n}\nfunction makeKeyboardPointerEvent(series, hoverRect, pick) {\n  const { x: canvasX, y: canvasY } = computeCenter(series, hoverRect, pick) ?? {};\n  if (canvasX !== void 0 && canvasY !== void 0) {\n    return { type: \"keyboard\", canvasX, canvasY };\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/util/placement.ts\nfunction calculatePlacement(naturalWidth, naturalHeight, container, bounds) {\n  let { top, right, bottom, left, width: width2, height: height2 } = bounds;\n  if (left != null) {\n    if (width2 != null) {\n      right = container.width - left + width2;\n    } else if (right != null) {\n      width2 = container.width - left - right;\n    }\n  } else if (right != null && width2 != null) {\n    left = container.width - right - width2;\n  }\n  if (top != null) {\n    if (height2 != null) {\n      bottom = container.height - top - height2;\n    } else if (bottom != null) {\n      height2 = container.height - bottom - top;\n    }\n  } else if (bottom != null && height2 != null) {\n    top = container.height - bottom - height2;\n  }\n  if (width2 == null) {\n    if (height2 == null) {\n      width2 = naturalWidth;\n      height2 = naturalHeight;\n    } else {\n      width2 = Math.ceil(naturalWidth * height2 / naturalHeight);\n    }\n  } else if (height2 == null) {\n    height2 = Math.ceil(naturalHeight * width2 / naturalWidth);\n  }\n  if (left == null) {\n    if (right == null) {\n      left = Math.floor((container.width - width2) / 2);\n    } else {\n      left = container.width - right - width2;\n    }\n  }\n  if (top == null) {\n    if (bottom == null) {\n      top = Math.floor((container.height - height2) / 2);\n    } else {\n      top = container.height - height2 - bottom;\n    }\n  }\n  return { x: left, y: top, width: width2, height: height2 };\n}\n\n// packages/ag-charts-community/src/util/sanitize.ts\nvar element = null;\nfunction sanitizeHtml(text2) {\n  if (text2 == null) {\n    return;\n  } else if (text2 === \"\") {\n    return \"\";\n  }\n  element ?? (element = createElement(\"div\"));\n  element.textContent = String(text2);\n  return element.innerHTML;\n}\n\n// packages/ag-charts-community/src/chart/marker/shapes.ts\nfunction drawMarkerUnitPolygon(params, moves) {\n  const { path, size } = params;\n  const { x: x0, y: y0 } = params;\n  path.clear();\n  let didMove = false;\n  for (const [dx, dy] of moves) {\n    const x = x0 + (dx - 0.5) * size;\n    const y = y0 + (dy - 0.5) * size;\n    if (didMove) {\n      path.lineTo(x, y);\n    } else {\n      path.moveTo(x, y);\n    }\n    didMove = true;\n  }\n  path.closePath();\n}\nvar MARKER_SHAPES = {\n  circle({ path, x, y, size }) {\n    const r = size / 2;\n    path.clear();\n    path.arc(x, y, r, 0, Math.PI * 2);\n    path.closePath();\n  },\n  cross(params) {\n    drawMarkerUnitPolygon(params, [\n      [0.25, 0],\n      [0.5, 0.25],\n      [0.75, 0],\n      [1, 0.25],\n      [0.75, 0.5],\n      [1, 0.75],\n      [0.75, 1],\n      [0.5, 0.75],\n      [0.25, 1],\n      [0, 0.75],\n      [0.25, 0.5],\n      [0, 0.25]\n    ]);\n  },\n  diamond(params) {\n    drawMarkerUnitPolygon(params, [\n      [0.5, 0],\n      [1, 0.5],\n      [0.5, 1],\n      [0, 0.5]\n    ]);\n  },\n  heart({ path, x, y, size }) {\n    const r = size / 4;\n    y = y + r / 2;\n    path.clear();\n    path.arc(x - r, y - r, r, toRadians(130), toRadians(330));\n    path.arc(x + r, y - r, r, toRadians(220), toRadians(50));\n    path.lineTo(x, y + r);\n    path.closePath();\n  },\n  pin({ path, x, y, size: s }) {\n    const cx = 0.5;\n    const cy = 0.5;\n    path.moveTo(x + (0.15625 - cx) * s, y + (0.34375 - cy) * s);\n    path.cubicCurveTo(\n      x + (0.15625 - cx) * s,\n      y + (0.151491 - cy) * s,\n      x + (0.307741 - cx) * s,\n      y + (0 - cy) * s,\n      x + (0.5 - cx) * s,\n      y + (0 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.692259 - cx) * s,\n      y + (0 - cy) * s,\n      x + (0.84375 - cx) * s,\n      y + (0.151491 - cy) * s,\n      x + (0.84375 - cx) * s,\n      y + (0.34375 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.84375 - cx) * s,\n      y + (0.493824 - cy) * s,\n      x + (0.784625 - cx) * s,\n      y + (0.600181 - cy) * s,\n      x + (0.716461 - cx) * s,\n      y + (0.695393 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.699009 - cx) * s,\n      y + (0.719769 - cy) * s,\n      x + (0.681271 - cx) * s,\n      y + (0.743104 - cy) * s,\n      x + (0.663785 - cx) * s,\n      y + (0.766105 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.611893 - cx) * s,\n      y + (0.834367 - cy) * s,\n      x + (0.562228 - cx) * s,\n      y + (0.899699 - cy) * s,\n      x + (0.528896 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.524075 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.512663 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.5 - cx) * s,\n      y + (1 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.487337 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.475925 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.471104 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.487337 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.475925 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.471104 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.437772 - cx) * s,\n      y + (0.899699 - cy) * s,\n      x + (0.388107 - cx) * s,\n      y + (0.834367 - cy) * s,\n      x + (0.336215 - cx) * s,\n      y + (0.766105 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.318729 - cx) * s,\n      y + (0.743104 - cy) * s,\n      x + (0.300991 - cx) * s,\n      y + (0.719769 - cy) * s,\n      x + (0.283539 - cx) * s,\n      y + (0.695393 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.215375 - cx) * s,\n      y + (0.600181 - cy) * s,\n      x + (0.15625 - cx) * s,\n      y + (0.493824 - cy) * s,\n      x + (0.15625 - cx) * s,\n      y + (0.34375 - cy) * s\n    );\n    path.closePath();\n  },\n  plus(params) {\n    drawMarkerUnitPolygon(params, [\n      [1 / 3, 0],\n      [2 / 3, 0],\n      [2 / 3, 1 / 3],\n      [1, 1 / 3],\n      [1, 2 / 3],\n      [2 / 3, 2 / 3],\n      [2 / 3, 1],\n      [1 / 3, 1],\n      [1 / 3, 2 / 3],\n      [0, 2 / 3],\n      [0, 1 / 3],\n      [1 / 3, 1 / 3]\n    ]);\n  },\n  square({ path, x, y, size, pixelRatio }) {\n    const hs = size / 2;\n    path.clear();\n    path.moveTo(align(pixelRatio, x - hs), align(pixelRatio, y - hs));\n    path.lineTo(align(pixelRatio, x + hs), align(pixelRatio, y - hs));\n    path.lineTo(align(pixelRatio, x + hs), align(pixelRatio, y + hs));\n    path.lineTo(align(pixelRatio, x - hs), align(pixelRatio, y + hs));\n    path.closePath();\n  },\n  star({ path, x, y, size }) {\n    const spikes = 5;\n    const outerRadius = size / 2;\n    const innerRadius = outerRadius / 2;\n    const rotation = Math.PI / 2;\n    for (let i = 0; i < spikes * 2; i++) {\n      const radius = i % 2 === 0 ? outerRadius : innerRadius;\n      const angle2 = i * Math.PI / spikes - rotation;\n      const xCoordinate = x + Math.cos(angle2) * radius;\n      const yCoordinate = y + Math.sin(angle2) * radius;\n      path.lineTo(xCoordinate, yCoordinate);\n    }\n    path.closePath();\n  },\n  triangle(params) {\n    drawMarkerUnitPolygon(params, [\n      [0.5, 0],\n      [1, 0.87],\n      [0, 0.87]\n    ]);\n  }\n};\n\n// packages/ag-charts-community/src/chart/marker/marker.ts\nvar InternalMarker = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.shape = \"square\";\n    this.x = 0;\n    this.y = 0;\n    this.size = 12;\n  }\n  updatePath() {\n    const { path, shape, x, y, size } = this;\n    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;\n    const anchor = Marker.anchor(shape);\n    const drawParams = {\n      path,\n      x: x - (anchor.x - 0.5) * size,\n      y: y - (anchor.y - 0.5) * size,\n      size,\n      pixelRatio\n    };\n    path.clear();\n    if (typeof shape === \"string\") {\n      MARKER_SHAPES[shape](drawParams);\n    } else if (typeof shape === \"function\") {\n      shape(drawParams);\n    }\n  }\n  computeBBox() {\n    const { x, y, size } = this;\n    const anchor = Marker.anchor(this.shape);\n    return new BBox(x - size * anchor.x, y - size * anchor.y, size, size);\n  }\n  executeFill(ctx, path) {\n    if (!path)\n      return;\n    return super.executeFill(ctx, path);\n  }\n  executeStroke(ctx, path) {\n    if (!path)\n      return;\n    return super.executeStroke(ctx, path);\n  }\n};\n__decorateClass([\n  ScenePathChangeDetection()\n], InternalMarker.prototype, \"shape\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], InternalMarker.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], InternalMarker.prototype, \"y\", 2);\n__decorateClass([\n  ScenePathChangeDetection({ convertor: Math.abs })\n], InternalMarker.prototype, \"size\", 2);\nvar Marker = class extends Rotatable(Scalable(Translatable(InternalMarker))) {\n  static anchor(shape) {\n    if (shape === \"pin\") {\n      return { x: 0.5, y: 1 };\n    } else if (typeof shape === \"function\" && \"anchor\" in shape) {\n      return shape.anchor;\n    }\n    return { x: 0.5, y: 0.5 };\n  }\n  constructor(options) {\n    super(options);\n    if (options?.shape != null) {\n      this.shape = options.shape;\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/legend/legendSymbol.ts\nfunction legendSymbolSvg(symbol, size, lineSize = size * (5 / 3)) {\n  const group = new Group();\n  const markerStrokeWidth = Math.min(symbol.marker.strokeWidth, 2);\n  const lineStrokeWidth = Math.min(symbol.line?.strokeWidth ?? 0, 2);\n  const width2 = Math.max(symbol.marker.enabled === false ? 0 : size, symbol.line == null ? 0 : lineSize);\n  const height2 = Math.max(symbol.marker.enabled === false ? 0 : size, lineStrokeWidth);\n  if (symbol.line != null) {\n    const { stroke: stroke2, strokeOpacity, lineDash } = symbol.line;\n    const line = new Line();\n    line.x1 = 0;\n    line.y1 = height2 / 2;\n    line.x2 = width2;\n    line.y2 = height2 / 2;\n    line.stroke = stroke2;\n    line.strokeOpacity = strokeOpacity;\n    line.strokeWidth = lineStrokeWidth;\n    line.lineDash = lineDash;\n    group.append(line);\n  }\n  if (symbol.marker.enabled !== false) {\n    const { shape, fill, fillOpacity, stroke: stroke2, strokeOpacity, lineDash, lineDashOffset } = symbol.marker;\n    const marker = new Marker();\n    marker.shape = shape ?? \"square\";\n    marker.size = size;\n    marker.fill = fill;\n    marker.fillOpacity = fillOpacity;\n    marker.stroke = stroke2;\n    marker.strokeOpacity = strokeOpacity;\n    marker.strokeWidth = markerStrokeWidth;\n    marker.lineDash = lineDash;\n    marker.lineDashOffset = lineDashOffset;\n    const anchor = Marker.anchor(shape);\n    const x = width2 / 2 + (anchor.x - 0.5) * size;\n    const y = height2 / 2 + (anchor.y - 0.5) * size;\n    const scale2 = size / (size + markerStrokeWidth);\n    marker.x = 0;\n    marker.y = 0;\n    marker.translationX = x;\n    marker.translationY = y;\n    marker.scalingX = scale2;\n    marker.scalingY = scale2;\n    group.append(marker);\n  }\n  return Group.toSVG(group, width2, height2);\n}\n\n// packages/ag-charts-community/src/chart/tooltip/springAnimation.ts\nvar M = 0.1;\nvar K = 200;\nvar C = 12;\nvar DELTA = 0.5;\nvar SpringAnimation = class extends Listeners {\n  constructor() {\n    super(...arguments);\n    this.x1 = NaN;\n    this.y1 = NaN;\n    this.x = NaN;\n    this.y = NaN;\n    this.vx = 0;\n    this.vy = 0;\n    this.t0 = NaN;\n    this.animationFrameHandle = void 0;\n  }\n  reset() {\n    this.x = NaN;\n    this.y = NaN;\n    if (this.animationFrameHandle != null) {\n      cancelAnimationFrame(this.animationFrameHandle);\n      this.animationFrameHandle = void 0;\n    }\n  }\n  update(x, y) {\n    if (Number.isNaN(this.x) || Number.isNaN(this.y)) {\n      this.x = x;\n      this.y = y;\n      this.vx = 0;\n      this.vy = 0;\n      this.emitUpdate();\n      if (this.animationFrameHandle != null) {\n        cancelAnimationFrame(this.animationFrameHandle);\n        this.animationFrameHandle = void 0;\n      }\n      return;\n    }\n    this.x1 = x;\n    this.y1 = y;\n    this.t0 = Date.now();\n    if (this.animationFrameHandle == null) {\n      this.animationFrameHandle = requestAnimationFrame(this.onFrame.bind(this));\n    }\n  }\n  onFrame() {\n    this.animationFrameHandle = void 0;\n    const { x1, y1, t0 } = this;\n    const t1 = Date.now();\n    const dt = t1 - t0;\n    this.t0 = t1;\n    const stepT = 1e-3;\n    const iterations = Math.ceil(dt / (stepT * 1e3)) | 0;\n    let { x, y, vx, vy } = this;\n    for (let i = 0; i < iterations; i += 1) {\n      const dx = x - x1;\n      const dy = y - y1;\n      const ax = -(K * dx + C * vx) / M;\n      const ay = -(K * dy + C * vy) / M;\n      vx += ax * stepT;\n      vy += ay * stepT;\n      x += vx * stepT;\n      y += vy * stepT;\n    }\n    if (Math.hypot(x - x1, y - y1) < DELTA) {\n      this.x = this.x1;\n      this.y = this.y1;\n      this.vx = 0;\n      this.vy = 0;\n    } else {\n      this.x = x;\n      this.y = y;\n      this.vx = vx;\n      this.vy = vy;\n      this.animationFrameHandle = requestAnimationFrame(this.onFrame.bind(this));\n    }\n    this.emitUpdate();\n  }\n  emitUpdate() {\n    this.dispatch(\"update\", { type: \"update\", x: this.x, y: this.y });\n  }\n};\n\n// packages/ag-charts-community/src/chart/tooltip/tooltip.ts\nvar DEFAULT_TOOLTIP_CLASS = \"ag-charts-tooltip\";\nvar DEFAULT_TOOLTIP_DARK_CLASS = \"ag-charts-tooltip--dark\";\nfunction tooltipContentAriaLabel(content) {\n  const ariaLabel = [];\n  if (content.type === \"raw\")\n    return \"\";\n  if (content.heading != null)\n    ariaLabel.push(content.heading);\n  if (content.title != null)\n    ariaLabel.push(content.title);\n  content.data?.forEach((datum) => {\n    ariaLabel.push(datum.label ?? datum.fallbackLabel, datum.value);\n  });\n  return ariaLabel.join(\"; \");\n}\nfunction dataHtml(label, value, inline) {\n  let rowHtml = \"\";\n  if (label == null) {\n    rowHtml += `<span class=\"${DEFAULT_TOOLTIP_CLASS}-label\">${sanitizeHtml(value)}</span>`;\n  } else {\n    rowHtml += `<span class=\"${DEFAULT_TOOLTIP_CLASS}-label\">${sanitizeHtml(label)}</span>`;\n    rowHtml += \" \";\n    rowHtml += `<span class=\"${DEFAULT_TOOLTIP_CLASS}-value\">${sanitizeHtml(value)}</span>`;\n  }\n  const rowClassNames = [`${DEFAULT_TOOLTIP_CLASS}-row`];\n  if (inline)\n    rowClassNames.push(`${DEFAULT_TOOLTIP_CLASS}-row--inline`);\n  rowHtml = `<div class=\"${rowClassNames.join(\" \")}\">${rowHtml}</div>`;\n  return rowHtml;\n}\nfunction tooltipContentHtml(content) {\n  if (content.type === \"raw\")\n    return content.rawHtmlString;\n  let html = \"\";\n  if ((content.heading == null || content.title == null) && content.data?.length === 1 && content.data[0].label == null && content.data[0].value != null) {\n    const datum = content.data[0];\n    html += dataHtml(content.heading ?? content.title, datum.value, false);\n  } else {\n    const dataInline = content.title == null && content.data?.length === 1;\n    if (content.heading != null) {\n      html += `<span class=\"${DEFAULT_TOOLTIP_CLASS}-heading\">${sanitizeHtml(content.heading)}</span>`;\n      html += \" \";\n    }\n    const symbol = content.symbol == null ? void 0 : legendSymbolSvg(content.symbol, 12);\n    if (symbol != null && (content.title != null || content.data?.length)) {\n      html += `<span class=\"${DEFAULT_TOOLTIP_CLASS}-symbol\">${symbol}</span>`;\n    }\n    if (content.title != null) {\n      html += `<span class=\"${DEFAULT_TOOLTIP_CLASS}-title\">${sanitizeHtml(content.title)}</span>`;\n      html += \" \";\n    }\n    content.data?.forEach((datum) => {\n      html += dataHtml(datum.label ?? datum.fallbackLabel, datum.value, dataInline);\n      html += \" \";\n    });\n  }\n  html = `<div class=\"${DEFAULT_TOOLTIP_CLASS}-content\">${html.trimEnd()}</div>`;\n  return html;\n}\nvar TooltipPosition = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    /** The type of positioning for the tooltip. By default, the tooltip follows the pointer. */\n    this.type = \"pointer\";\n    /** The horizontal offset in pixels for the position of the tooltip. */\n    this.xOffset = 0;\n    /** The vertical offset in pixels for the position of the tooltip. */\n    this.yOffset = 0;\n  }\n};\n__decorateClass([\n  Validate(\n    UNION(\n      [\n        \"pointer\",\n        \"node\",\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\",\n        \"top-left\",\n        \"top-right\",\n        \"bottom-right\",\n        \"bottom-left\",\n        { value: \"sparkline\", undocumented: true },\n        { value: \"sparkline-\", undocumented: true }\n      ],\n      \"a position type\"\n    )\n  )\n], TooltipPosition.prototype, \"type\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], TooltipPosition.prototype, \"xOffset\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], TooltipPosition.prototype, \"yOffset\", 2);\nvar Tooltip = class extends BaseProperties {\n  constructor() {\n    super();\n    this.enabled = true;\n    this.delay = 0;\n    this.range = void 0;\n    this.wrapping = \"hyphenate\";\n    this.position = new TooltipPosition();\n    this.darkTheme = false;\n    this.bounds = \"extended\";\n    this.destroyFns = [];\n    this.springAnimation = new SpringAnimation();\n    this.enableInteraction = false;\n    this.wrapTypes = [\"always\", \"hyphenate\", \"on-space\", \"never\"];\n    this.showTimeout = 0;\n    this._showArrow = true;\n    this._compact = false;\n    this._visible = false;\n    this.positionParams = void 0;\n    this.destroyFns.push(this.springAnimation.addListener(\"update\", this.updateTooltipPosition.bind(this)));\n  }\n  get interactive() {\n    return this.enableInteraction;\n  }\n  setup(domManager) {\n    if (\"togglePopover\" in getWindow().HTMLElement.prototype) {\n      this.element = domManager.addChild(\"canvas-overlay\", DEFAULT_TOOLTIP_CLASS);\n      this.element.setAttribute(\"popover\", \"manual\");\n      this.element.className = DEFAULT_TOOLTIP_CLASS;\n    }\n  }\n  destroy(domManager) {\n    domManager.removeChild(\"canvas-overlay\", DEFAULT_TOOLTIP_CLASS);\n    this.destroyFns.forEach((f) => f());\n  }\n  isVisible() {\n    return this._visible;\n  }\n  contains(node) {\n    return this.element?.contains(node) ?? false;\n  }\n  updateTooltipPosition() {\n    const { element: element2, positionParams } = this;\n    if (element2 == null || positionParams == null)\n      return;\n    const { canvasRect, relativeRect, meta } = positionParams;\n    const { x: canvasX, y: canvasY } = this.springAnimation;\n    const positionType = meta.position?.type ?? this.position.type;\n    const xOffset = meta.position?.xOffset ?? 0;\n    const yOffset = meta.position?.yOffset ?? 0;\n    const minX = relativeRect.x;\n    const minY = relativeRect.y;\n    const maxX = relativeRect.width - element2.clientWidth - 1 + minX;\n    const maxY = relativeRect.height - element2.clientHeight + minY;\n    let tooltipBounds = this.getTooltipBounds({ positionType, canvasX, canvasY, yOffset, xOffset, canvasRect });\n    let position = calculatePlacement(element2.clientWidth, element2.clientHeight, relativeRect, tooltipBounds);\n    if (positionType === \"sparkline\" && (position.x <= minX || position.x >= maxX)) {\n      tooltipBounds = this.getTooltipBounds({\n        positionType: \"sparkline-constrained\",\n        canvasX,\n        canvasY,\n        yOffset,\n        xOffset,\n        canvasRect\n      });\n      position = calculatePlacement(element2.clientWidth, element2.clientHeight, relativeRect, tooltipBounds);\n    }\n    const left = clamp(minX, position.x, maxX);\n    const top = clamp(minY, position.y, maxY);\n    const constrained = left !== position.x || top !== position.y;\n    const defaultShowArrow = (positionType === \"node\" || positionType === \"pointer\") && !constrained && !xOffset && !yOffset;\n    const showArrow = meta.showArrow ?? this.showArrow ?? defaultShowArrow;\n    this.updateShowArrow(showArrow);\n    this.updateCompact(positionType === \"sparkline\" || positionType === \"sparkline-constrained\");\n    element2.style.transform = `translate(${left}px, ${top}px)`;\n  }\n  /**\n   * Shows tooltip at the given event's coordinates.\n   * If the `html` parameter is missing, moves the existing tooltip to the new position.\n   */\n  show(boundingRect, canvasRect, meta, content, instantly = false) {\n    const { element: element2 } = this;\n    if (element2 != null && content != null) {\n      element2.innerHTML = tooltipContentHtml(content);\n    } else if (element2 == null || element2.innerHTML === \"\") {\n      this.toggle(false);\n      return;\n    }\n    const relativeRect = {\n      x: boundingRect.x - canvasRect.x,\n      y: boundingRect.y - canvasRect.y,\n      width: boundingRect.width,\n      height: boundingRect.height\n    };\n    this.positionParams = {\n      canvasRect,\n      relativeRect,\n      meta\n    };\n    this.springAnimation.update(meta.canvasX, meta.canvasY);\n    element2.style.top = `${canvasRect.top}px`;\n    element2.style.left = `${canvasRect.left}px`;\n    if (meta.enableInteraction) {\n      this.enableInteraction = true;\n      element2.style.pointerEvents = \"auto\";\n      element2.removeAttribute(\"aria-hidden\");\n    } else {\n      this.enableInteraction = false;\n      element2.style.pointerEvents = \"none\";\n      element2.setAttribute(\"aria-hidden\", \"true\");\n    }\n    if (this.delay > 0 && !instantly) {\n      this.toggle(false);\n      this.showTimeout = setTimeout(() => {\n        this.toggle(true);\n      }, this.delay);\n    } else {\n      this.toggle(true);\n    }\n  }\n  hide() {\n    this.springAnimation.reset();\n    this.toggle(false);\n  }\n  toggle(visible) {\n    if (!this.element?.isConnected)\n      return;\n    this._visible = visible;\n    const { classList } = this.element;\n    const toggleClass = (name, include) => classList.toggle(`${DEFAULT_TOOLTIP_CLASS}--${name}`, include);\n    if (!visible) {\n      clearTimeout(this.showTimeout);\n    }\n    toggleClass(\"no-interaction\", !this.enableInteraction);\n    toggleClass(\"arrow\", this._showArrow);\n    toggleClass(\"compact\", this._compact);\n    classList.toggle(DEFAULT_TOOLTIP_DARK_CLASS, this.darkTheme);\n    this.element.togglePopover(visible);\n    if (visible) {\n      this.updateTooltipPosition();\n    }\n    for (const wrapType of this.wrapTypes) {\n      classList.toggle(`${DEFAULT_TOOLTIP_CLASS}--wrap-${wrapType}`, wrapType === this.wrapping);\n    }\n  }\n  updateShowArrow(show) {\n    this._showArrow = show;\n  }\n  updateCompact(compact) {\n    this._compact = compact;\n  }\n  getTooltipBounds(opts) {\n    if (!this.element)\n      return {};\n    const { positionType, canvasX, canvasY, yOffset, xOffset, canvasRect } = opts;\n    const { clientWidth: tooltipWidth, clientHeight: tooltipHeight } = this.element;\n    const bounds = { width: tooltipWidth, height: tooltipHeight };\n    switch (positionType) {\n      case \"node\":\n      case \"pointer\": {\n        bounds.top = canvasY + yOffset - tooltipHeight - 8;\n        bounds.left = canvasX + xOffset - tooltipWidth / 2;\n        return bounds;\n      }\n      case \"top\": {\n        bounds.top = yOffset;\n        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"right\": {\n        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;\n        bounds.left = canvasRect.width - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"left\": {\n        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n      case \"bottom\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"top-left\": {\n        bounds.top = yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n      case \"top-right\": {\n        bounds.top = yOffset;\n        bounds.left = canvasRect.width - tooltipWidth + xOffset;\n        return bounds;\n      }\n      case \"bottom-right\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = canvasRect.width - tooltipWidth + xOffset;\n        return bounds;\n      }\n      case \"bottom-left\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n      case \"sparkline\": {\n        bounds.top = canvasY + yOffset - tooltipHeight / 2;\n        bounds.left = canvasX + xOffset + 8;\n        return bounds;\n      }\n      case \"sparkline-constrained\": {\n        bounds.top = canvasY + yOffset - tooltipHeight / 2;\n        bounds.left = canvasX + xOffset - 8 - tooltipWidth;\n        return bounds;\n      }\n    }\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Tooltip.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Tooltip.prototype, \"showArrow\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Tooltip.prototype, \"delay\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE, { optional: true })\n], Tooltip.prototype, \"range\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], Tooltip.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Tooltip.prototype, \"position\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], Tooltip.prototype, \"darkTheme\", 2);\n__decorateClass([\n  Validate(UNION([\"extended\", \"canvas\"]))\n], Tooltip.prototype, \"bounds\", 2);\n\n// packages/ag-charts-community/src/chart/series/seriesAreaManager.ts\nvar SeriesAreaManager = class extends BaseManager {\n  constructor(chart) {\n    super();\n    this.chart = chart;\n    this.id = createId(this);\n    this.series = [];\n    this.highlight = {\n      /** Last received event that still needs to be applied. */\n      pendingHoverEvent: void 0,\n      /** Last applied event. */\n      appliedHoverEvent: void 0,\n      /** Last applied event, which has been temporarily stashed during the main chart update cycle. */\n      stashedHoverEvent: void 0\n    };\n    this.tooltip = {\n      lastHover: void 0\n    };\n    /**\n     * A11y Requirements for Tooltip/Highlight (see AG-13051 for details):\n     *\n     *   -   When the series-area is blurred, always the mouse to update the tooltip/highlight.\n     *\n     *   -   When the series-area receives a `focus` event, use `:focus-visible` to guess the input device.\n     *       (this is decided by the browser).\n     *\n     *   -   For keyboard users, `focus` and `keydown` events always updates & shows the tooltip/highlight on\n     *       the currently (or newly) focused datum.\n     *\n     *   -   For keyboard users, `mousemove` events update the tooltip/highlight iff `pickNode` finds a match\n     *       for the mouse event offsets.\n     */\n    this.hoverDevice = \"pointer\";\n    /**\n     * This is the \"second last\" input event. It can be useful for keydown\n     * events that for which don't to set the isFocusVisible state\n     * (e.g. Backspace/Delete key on FC annotations, see AG-13041).\n     *\n     * Use with caution! The focus indicator must ALWAYS be visible for\n     * keyboard-only users.\n     */\n    this.previousInputDevice = \"keyboard\";\n    this.focus = {\n      sortedSeries: [],\n      series: void 0,\n      seriesIndex: 0,\n      datumIndex: 0,\n      datum: void 0\n    };\n    this.hoverScheduler = debouncedAnimationFrame(() => {\n      if (!this.tooltip.lastHover && !this.highlight.pendingHoverEvent)\n        return;\n      if (this.chart.getUpdateType() <= 4 /* SERIES_UPDATE */) {\n        this.hoverScheduler.schedule();\n        return;\n      }\n      if (this.highlight.pendingHoverEvent) {\n        this.handleHoverHighlight(false);\n      }\n      if (this.tooltip.lastHover) {\n        this.handleHoverTooltip(this.tooltip.lastHover, false);\n      }\n    });\n    const label1 = chart.ctx.domManager.addChild(\"series-area\", \"series-area-aria-label1\");\n    const label2 = chart.ctx.domManager.addChild(\"series-area\", \"series-area-aria-label2\");\n    this.swapChain = new FocusSwapChain(label1, label2, this.id, \"img\");\n    this.swapChain.addListener(\"blur\", () => this.onBlur());\n    this.swapChain.addListener(\"focus\", () => this.onFocus());\n    this.focusIndicator = new FocusIndicator(this.swapChain);\n    this.focusIndicator.overrideFocusVisible(chart.mode === \"integrated\" ? false : void 0);\n    const { seriesDragInterpreter, seriesWidget, containerWidget } = chart.ctx.widgets;\n    seriesWidget.setTabIndex(-1);\n    this.destroyFns.push(\n      () => chart.ctx.domManager.removeChild(\"series-area\", \"series-area-aria-label1\"),\n      () => chart.ctx.domManager.removeChild(\"series-area\", \"series-area-aria-label2\"),\n      seriesWidget.addListener(\"focus\", () => this.swapChain.focus()),\n      seriesWidget.addListener(\"mousemove\", (event) => this.onHover(event)),\n      seriesWidget.addListener(\"wheel\", (event) => this.onWheel(event)),\n      seriesWidget.addListener(\"mouseleave\", (event) => this.onLeave(event)),\n      seriesWidget.addListener(\"keydown\", (event) => this.onKeyDown(event)),\n      seriesWidget.addListener(\"contextmenu\", (event, current) => this.onContextMenu(event, current)),\n      seriesDragInterpreter.addListener(\"drag-move\", (event) => this.onDragMove(event)),\n      seriesDragInterpreter.addListener(\"click\", (event) => this.onClick(event, seriesWidget)),\n      seriesDragInterpreter.addListener(\"dblclick\", (event) => this.onClick(event, seriesWidget)),\n      containerWidget.addListener(\"contextmenu\", (event, current) => this.onContextMenu(event, current)),\n      containerWidget.addListener(\"click\", (event, current) => this.onClick(event, current)),\n      containerWidget.addListener(\"dblclick\", (event, current) => this.onClick(event, current)),\n      chart.ctx.animationManager.addListener(\"animation-start\", () => this.clearAll()),\n      chart.ctx.domManager.addListener(\"resize\", () => this.clearAll()),\n      chart.ctx.highlightManager.addListener(\"highlight-change\", (event) => this.changeHighlightDatum(event)),\n      chart.ctx.layoutManager.addListener(\"layout:complete\", (event) => this.layoutComplete(event)),\n      chart.ctx.updateService.addListener(\"pre-scene-render\", () => this.preSceneRender()),\n      chart.ctx.updateService.addListener(\"update-complete\", () => this.updateComplete()),\n      chart.ctx.zoomManager.addListener(\"zoom-change\", () => this.clearAll()),\n      chart.ctx.zoomManager.addListener(\"zoom-pan-start\", () => this.clearAll())\n    );\n  }\n  isState(allowedStates) {\n    return this.chart.ctx.interactionManager.isState(allowedStates);\n  }\n  isIgnoredTouch(event) {\n    if (event.device !== \"touch\" || event.type === \"click\")\n      return false;\n    if (this.chart.ctx.chartService.touch.dragAction === \"hover\")\n      return false;\n    if (this.chart.ctx.chartService.touch.dragAction === \"drag\") {\n      if (this.isState(9 /* AnnotationsMoveable */)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  dataChanged() {\n    var _a;\n    (_a = this.highlight).stashedHoverEvent ?? (_a.stashedHoverEvent = this.highlight.appliedHoverEvent);\n    this.chart.ctx.tooltipManager.removeTooltip(this.id);\n    this.focusIndicator.clear();\n    this.clearHighlight();\n  }\n  preSceneRender() {\n    if (this.highlight.stashedHoverEvent != null) {\n      this.highlight.pendingHoverEvent = this.highlight.stashedHoverEvent;\n      this.highlight.stashedHoverEvent = void 0;\n      this.handleHoverHighlight(true);\n    }\n    if (this.tooltip.lastHover != null) {\n      this.handleHoverTooltip(this.tooltip.lastHover, true);\n    }\n  }\n  updateComplete() {\n    if (this.focusIndicator.isFocusVisible() && this.isState(34 /* Focusable */)) {\n      this.handleSeriesFocus(0, 0, true);\n    }\n  }\n  update(type, opts) {\n    this.chart.ctx.updateService.update(type, opts);\n  }\n  seriesChanged(series) {\n    this.focus.sortedSeries = [...series].sort((a, b) => {\n      let fpA = a.properties.focusPriority ?? Infinity;\n      let fpB = b.properties.focusPriority ?? Infinity;\n      if (fpA === fpB) {\n        [fpA, fpB] = [a._declarationOrder, b._declarationOrder];\n      }\n      if (fpA < fpB) {\n        return -1;\n      } else if (fpA > fpB) {\n        return 1;\n      }\n      return 0;\n    });\n    this.series = series;\n  }\n  layoutComplete(event) {\n    this.seriesRect = event.series.rect;\n    this.hoverRect = event.series.paddedRect;\n    this.chart.ctx.widgets.seriesWidget.setBounds(event.series.paddedRect);\n    this.chart.ctx.widgets.chartWidget.setBounds(event.chart);\n  }\n  onContextMenu(event, current) {\n    const { sourceEvent } = event;\n    if (sourceEvent.currentTarget != current.getElement())\n      return;\n    if (sourceEvent.target == this.chart.ctx.widgets.containerWidget.getElement()) {\n      if (this.isState(36 /* ContextMenuable */)) {\n        const { currentX: canvasX2, currentY: canvasY2 } = event;\n        this.chart.ctx.contextMenuRegistry.dispatchContext(\"all\", { sourceEvent, canvasX: canvasX2, canvasY: canvasY2 }, {});\n      }\n      return;\n    }\n    let pickedNode;\n    let position;\n    if (this.focusIndicator.isFocusVisible()) {\n      pickedNode = this.chart.ctx.highlightManager.getActiveHighlight();\n      if (pickedNode && this.seriesRect && pickedNode.midPoint) {\n        position = Transformable.toCanvasPoint(\n          pickedNode.series.contentGroup,\n          pickedNode.midPoint.x,\n          pickedNode.midPoint.y\n        );\n      }\n    } else if (this.isState(36 /* ContextMenuable */)) {\n      const match = this.pickNode({ x: event.currentX, y: event.currentY }, \"context-menu\");\n      if (match) {\n        this.chart.ctx.highlightManager.updateHighlight(this.id);\n        pickedNode = match.datum;\n      }\n    }\n    const pickedSeries = pickedNode?.series;\n    this.clearAll();\n    const canvasX = event.currentX + current.cssLeft();\n    const canvasY = event.currentY + current.cssTop();\n    this.chart.ctx.contextMenuRegistry.dispatchContext(\n      \"series-area\",\n      { sourceEvent, canvasX, canvasY },\n      { pickedSeries, pickedNode },\n      position\n    );\n  }\n  onLeave(event) {\n    if (!this.isState(41 /* Clickable */))\n      return;\n    const relatedTarget = event.sourceEvent.relatedTarget;\n    if (relatedTarget?.className === \"ag-charts-text-input__textarea\") {\n      return;\n    }\n    if (this.chart.ctx.tooltipManager.isEnteringInteractiveTooltip(event)) {\n      return;\n    }\n    this.chart.ctx.domManager.updateCursor(this.id);\n    if (!this.focusIndicator.isFocusVisible())\n      this.clearAll();\n  }\n  onWheel(_event) {\n    if (!this.isState(41 /* Clickable */))\n      return;\n    this.focusIndicator?.overrideFocusVisible(false);\n    this.previousInputDevice = \"pointer\";\n  }\n  onDragMove(event) {\n    if (!this.isState(41 /* Clickable */))\n      return;\n    this.focusIndicator?.overrideFocusVisible(false);\n    this.onHoverLikeEvent(event);\n  }\n  onHover(event) {\n    if (!this.isState(41 /* Clickable */))\n      return;\n    this.onHoverLikeEvent(event);\n  }\n  onHoverLikeEvent(event) {\n    if (this.isIgnoredTouch(event))\n      return;\n    if (event.device === \"touch\" || excludesType(event, \"drag-move\")) {\n      this.tooltip.lastHover = event;\n    }\n    if (event.device === \"touch\" && this.chart.ctx.chartService.touch.dragAction === \"hover\") {\n      event.sourceEvent.preventDefault();\n    }\n    this.hoverDevice = \"pointer\";\n    this.previousInputDevice = \"pointer\";\n    this.highlight.pendingHoverEvent = event;\n    this.hoverScheduler.schedule();\n    if (this.isState(32 /* Default */)) {\n      const { currentX: x, currentY: y } = event;\n      const found = this.pickNode({ x, y }, \"event\");\n      if (found?.series.hasEventListener(\"nodeClick\") || found?.series.hasEventListener(\"nodeDoubleClick\")) {\n        this.chart.ctx.domManager.updateCursor(this.id, \"pointer\");\n      } else {\n        this.chart.ctx.domManager.updateCursor(this.id);\n      }\n    }\n  }\n  onClick(event, current) {\n    if (event.device === \"touch\" && current === this.chart.ctx.widgets.seriesWidget) {\n      this.swapChain.focus({ preventScroll: true });\n    }\n    if (!this.isState(41 /* Clickable */))\n      return;\n    if (current === this.chart.ctx.widgets.seriesWidget) {\n      if (!current.getElement().contains(event.sourceEvent.target)) {\n        return;\n      }\n    } else if (event.sourceEvent.target != current.getElement()) {\n      return;\n    }\n    this.focusIndicator.overrideFocusVisible(false);\n    this.onHoverLikeEvent(event);\n    if (!this.isState(32 /* Default */))\n      return;\n    if (current == this.chart.ctx.widgets.seriesWidget && this.checkSeriesNodeClick(event)) {\n      this.update(4 /* SERIES_UPDATE */);\n      event.sourceEvent.preventDefault();\n      return;\n    }\n    const newEvent = { type: event.type === \"click\" ? \"click\" : \"doubleClick\", event: event.sourceEvent };\n    this.chart.fireEvent(newEvent);\n  }\n  onFocus() {\n    if (!this.isState(34 /* Focusable */))\n      return;\n    this.hoverDevice = this.focusIndicator.isFocusVisible() ? \"keyboard\" : \"pointer\";\n    this.handleFocus(0, 0);\n  }\n  onBlur() {\n    if (!this.isState(34 /* Focusable */))\n      return;\n    this.hoverDevice = \"pointer\";\n    this.clearAll();\n    this.focusIndicator.overrideFocusVisible(void 0);\n  }\n  onKeyDown(widgetEvent) {\n    if (!this.isState(43 /* Keyable */))\n      return;\n    const action = mapKeyboardEventToAction(widgetEvent.sourceEvent);\n    if (action?.activatesFocusIndicator === false) {\n      this.focusIndicator.overrideFocusVisible(this.previousInputDevice === \"keyboard\");\n    }\n    switch (action?.name) {\n      case \"redo\":\n        return this.chart.ctx.chartEventManager.seriesEvent(\"series-redo\");\n      case \"undo\":\n        return this.chart.ctx.chartEventManager.seriesEvent(\"series-undo\");\n      case \"zoomin\":\n        return this.chart.ctx.chartEventManager.seriesKeyNavZoom(1, widgetEvent);\n      case \"zoomout\":\n        return this.chart.ctx.chartEventManager.seriesKeyNavZoom(-1, widgetEvent);\n      case \"arrowup\":\n        return this.onArrow(-1, 0, widgetEvent);\n      case \"arrowdown\":\n        return this.onArrow(1, 0, widgetEvent);\n      case \"arrowleft\":\n        return this.onArrow(0, -1, widgetEvent);\n      case \"arrowright\":\n        return this.onArrow(0, 1, widgetEvent);\n      case \"submit\":\n        return this.onSubmit(widgetEvent);\n    }\n  }\n  onArrow(seriesIndexDelta, datumIndexDelta, event) {\n    if (!this.isState(34 /* Focusable */))\n      return;\n    this.hoverDevice = \"keyboard\";\n    this.previousInputDevice = \"keyboard\";\n    this.focusIndicator.overrideFocusVisible(true);\n    this.focus.seriesIndex += seriesIndexDelta;\n    this.focus.datumIndex += datumIndexDelta;\n    this.handleFocus(seriesIndexDelta, datumIndexDelta);\n    event.sourceEvent.preventDefault();\n    this.chart.ctx.chartEventManager.seriesEvent(\"series-focus-change\");\n  }\n  onSubmit(event) {\n    if (!this.isState(34 /* Focusable */))\n      return;\n    const { series, datum } = this.focus;\n    const sourceEvent = event.sourceEvent;\n    if (series !== void 0 && datum !== void 0) {\n      series.fireNodeClickEvent(sourceEvent, datum);\n    } else {\n      this.chart.fireEvent({\n        type: \"click\",\n        event: sourceEvent\n      });\n    }\n    sourceEvent.preventDefault();\n  }\n  checkSeriesNodeClick(event) {\n    const result = this.pickNode({ x: event.currentX, y: event.currentY }, \"event\");\n    if (result == null)\n      return false;\n    if (event.type === \"click\") {\n      result.series.fireNodeClickEvent(event.sourceEvent, result.datum);\n      return true;\n    }\n    if (event.type === \"dblclick\") {\n      event.preventZoomDblClick = result.distance === 0;\n      result.series.fireNodeDoubleClickEvent(event.sourceEvent, result.datum);\n      return true;\n    }\n    return false;\n  }\n  handleFocus(seriesIndexDelta, datumIndexDelta) {\n    const overlayFocus = this.chart.overlays.getFocusInfo(this.chart.ctx.localeManager);\n    if (overlayFocus == null) {\n      this.handleSeriesFocus(seriesIndexDelta, datumIndexDelta);\n    } else {\n      this.focusIndicator.update(overlayFocus.rect, this.seriesRect, false);\n    }\n  }\n  handleSeriesFocus(otherIndexDelta, datumIndexDelta, refresh = false) {\n    if (this.chart.chartType === \"hierarchy\" || this.chart.chartType === \"gauge\") {\n      this.handleSoloSeriesFocus(otherIndexDelta, datumIndexDelta, refresh);\n      return;\n    }\n    const { focus, seriesRect } = this;\n    const visibleSeries = focus.sortedSeries.filter((s) => s.visible && s.focusable);\n    if (visibleSeries.length === 0)\n      return;\n    const oldPick = {\n      datumIndex: focus.datumIndex - datumIndexDelta,\n      otherIndex: focus.seriesIndex - otherIndexDelta\n    };\n    focus.seriesIndex = clamp(0, focus.seriesIndex, visibleSeries.length - 1);\n    focus.series = visibleSeries[focus.seriesIndex];\n    const { datumIndex, seriesIndex: otherIndex } = focus;\n    const pick = focus.series.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });\n    this.updatePickedFocus(otherIndexDelta, datumIndexDelta, oldPick, pick, refresh);\n  }\n  handleSoloSeriesFocus(otherIndexDelta, datumIndexDelta, refresh) {\n    this.focus.series = this.focus.sortedSeries[0];\n    const {\n      focus: { series, seriesIndex: otherIndex, datumIndex },\n      seriesRect\n    } = this;\n    if (series == null)\n      return;\n    const oldPick = {\n      datumIndex: this.focus.datumIndex - datumIndexDelta,\n      otherIndex: this.focus.seriesIndex - otherIndexDelta\n    };\n    const pick = series.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });\n    this.updatePickedFocus(otherIndexDelta, datumIndexDelta, oldPick, pick, refresh);\n  }\n  updatePickedFocus(otherIndexDelta, datumIndexDelta, oldPick, pick, refresh) {\n    const { focus, hoverRect } = this;\n    if (pick === void 0 || focus.series === void 0 || hoverRect === void 0)\n      return;\n    const { datum, datumIndex, otherIndex } = pick;\n    if (otherIndex !== void 0) {\n      focus.seriesIndex = otherIndex;\n    }\n    focus.datumIndex = datumIndex;\n    focus.datum = datum;\n    if (this.focusIndicator.isFocusVisible()) {\n      this.chart.ctx.animationManager.reset();\n    }\n    if (this.focusIndicator.isFocusVisible()) {\n      const focusBBox = getPickedFocusBBox(pick);\n      const { x, y } = focusBBox.computeCenter();\n      if (!hoverRect.containsPoint(x, y)) {\n        const panSuccess = this.chart.ctx.zoomManager.panToBBox(this.id, hoverRect, focusBBox);\n        if (panSuccess) {\n          return;\n        }\n      }\n    }\n    this.focusIndicator.update(pick.bounds, this.seriesRect, pick.clipFocusBox);\n    const keyboardEvent = makeKeyboardPointerEvent(focus.series, hoverRect, pick);\n    if (keyboardEvent !== void 0 && this.hoverDevice === \"keyboard\") {\n      this.tooltip.lastHover = void 0;\n      this.highlight.appliedHoverEvent = void 0;\n      this.highlight.pendingHoverEvent = void 0;\n      this.highlight.stashedHoverEvent = void 0;\n      const tooltipContent = focus.series.getTooltipContent(datum);\n      const meta = TooltipManager.makeTooltipMeta(keyboardEvent, focus.series, datum);\n      this.chart.ctx.highlightManager.updateHighlight(this.id, datum);\n      const tooltipEnabled = this.chart.tooltip.enabled && focus.series.tooltipEnabled;\n      if (tooltipEnabled) {\n        this.chart.ctx.tooltipManager.updateTooltip(this.id, meta, tooltipContent);\n      } else {\n        this.chart.ctx.tooltipManager.removeTooltip(this.id);\n      }\n      if (!refresh) {\n        const shouldAnnouncePick = datumIndexDelta === 0 && otherIndexDelta === 0 || oldPick.datumIndex !== pick.datumIndex || oldPick.otherIndex !== (pick.otherIndex ?? focus.seriesIndex);\n        if (shouldAnnouncePick) {\n          this.swapChain.update(this.getDatumAriaText(datum, tooltipContent));\n        }\n      }\n    }\n  }\n  getDatumAriaText(datum, tooltipContent) {\n    const description = tooltipContent == null ? \"\" : tooltipContentAriaLabel(tooltipContent);\n    return this.chart.ctx.localeManager.t(\"ariaAnnounceHoverDatum\", {\n      datum: datum.series.getDatumAriaText?.(datum, description) ?? description\n    });\n  }\n  clearHighlight() {\n    this.highlight.pendingHoverEvent = void 0;\n    this.highlight.appliedHoverEvent = void 0;\n    this.chart.ctx.highlightManager.updateHighlight(this.id);\n  }\n  clearTooltip() {\n    this.chart.ctx.tooltipManager.removeTooltip(this.id);\n    this.tooltip.lastHover = void 0;\n  }\n  clearAll() {\n    this.clearHighlight();\n    this.clearTooltip();\n    this.focusIndicator.clear();\n  }\n  handleHoverHighlight(redisplay) {\n    this.highlight.appliedHoverEvent = this.highlight.pendingHoverEvent;\n    this.highlight.pendingHoverEvent = void 0;\n    const event = this.highlight.appliedHoverEvent;\n    if (!event || !this.isState(41 /* Clickable */))\n      return;\n    const { currentX, currentY } = event;\n    const canvasX = event.currentX + (this.hoverRect?.x ?? 0);\n    const canvasY = event.currentY + (this.hoverRect?.y ?? 0);\n    if (redisplay ? this.chart.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(canvasX, canvasY)) {\n      this.clearHighlight();\n      return;\n    }\n    const { range: range3 } = this.chart.highlight;\n    const intent = range3 === \"tooltip\" ? \"highlight-tooltip\" : \"highlight\";\n    const found = this.pickNode({ x: currentX, y: currentY }, intent);\n    if (found) {\n      this.chart.ctx.highlightManager.updateHighlight(this.id, found.datum);\n      this.hoverDevice = \"pointer\";\n      return;\n    }\n    this.chart.ctx.highlightManager.updateHighlight(this.id);\n  }\n  handleHoverTooltip(event, redisplay) {\n    if (!this.isState(41 /* Clickable */))\n      return;\n    const { currentX, currentY } = event;\n    const canvasX = currentX + (this.hoverRect?.x ?? 0);\n    const canvasY = currentY + (this.hoverRect?.y ?? 0);\n    const targetElement = event.sourceEvent.target;\n    if (redisplay ? this.chart.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(canvasX, canvasY)) {\n      if (this.hoverDevice == \"pointer\")\n        this.clearTooltip();\n      return;\n    }\n    if (targetElement && this.chart.tooltip.interactive && this.chart.ctx.domManager.isManagedChildDOMElement(targetElement, \"canvas-overlay\", DEFAULT_TOOLTIP_CLASS)) {\n      return;\n    }\n    const pick = this.pickNode({ x: event.currentX, y: event.currentY }, \"tooltip\");\n    if (!pick) {\n      if (this.hoverDevice == \"pointer\")\n        this.clearTooltip();\n      return;\n    }\n    this.hoverDevice = \"pointer\";\n    const content = pick.series.getTooltipContent(pick.datum);\n    const tooltipEnabled = this.chart.tooltip.enabled && pick.series.tooltipEnabled;\n    const shouldUpdateTooltip = tooltipEnabled && content != null;\n    if (shouldUpdateTooltip) {\n      const meta = TooltipManager.makeTooltipMeta(\n        { type: \"pointermove\", canvasX, canvasY },\n        pick.series,\n        pick.datum\n      );\n      this.chart.ctx.tooltipManager.updateTooltip(this.id, meta, content);\n    } else {\n      this.chart.ctx.tooltipManager.removeTooltip(this.id);\n    }\n  }\n  changeHighlightDatum(event) {\n    const seriesToUpdate = /* @__PURE__ */ new Set();\n    const { series: newSeries = void 0, datum: newDatum } = event.currentHighlight ?? {};\n    const { series: lastSeries = void 0, datum: lastDatum } = event.previousHighlight ?? {};\n    if (lastSeries) {\n      seriesToUpdate.add(lastSeries);\n    }\n    if (newSeries) {\n      seriesToUpdate.add(newSeries);\n    }\n    if (lastSeries?.properties.cursor && lastDatum) {\n      this.chart.ctx.domManager.updateCursor(lastSeries.id);\n    }\n    if (newSeries?.properties.cursor && newSeries?.properties.cursor !== \"default\" && newDatum) {\n      this.chart.ctx.domManager.updateCursor(newSeries.id, newSeries.properties.cursor);\n    }\n    const updateAll = newSeries == null || lastSeries == null;\n    if (updateAll) {\n      this.update(4 /* SERIES_UPDATE */);\n    } else {\n      this.update(4 /* SERIES_UPDATE */, { seriesToUpdate });\n    }\n  }\n  pickNode(point, intent, exactMatchOnly) {\n    const reverseSeries = [...this.series].reverse();\n    let result;\n    for (const series of reverseSeries) {\n      if (!series.visible || !series.contentGroup.visible) {\n        continue;\n      }\n      const { match, distance: distance2 } = series.pickNode(point, intent, exactMatchOnly) ?? {};\n      if (!match || distance2 == null) {\n        continue;\n      }\n      if (!result || result.distance > distance2) {\n        result = { series, distance: distance2, datum: match };\n      }\n      if (distance2 === 0) {\n        break;\n      }\n    }\n    return result;\n  }\n};\nfunction excludesType(obj, excluded) {\n  return obj.type !== excluded;\n}\n\n// packages/ag-charts-community/src/chart/series/seriesLayerManager.ts\nvar SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION = 30;\nvar SeriesLayerManager = class {\n  constructor(seriesRoot) {\n    this.seriesRoot = seriesRoot;\n    this.groups = /* @__PURE__ */ new Map();\n    this.series = /* @__PURE__ */ new Map();\n    this.expectedSeriesCount = 1;\n    this.mode = \"normal\";\n  }\n  setSeriesCount(count) {\n    this.expectedSeriesCount = count;\n  }\n  requestGroup(seriesConfig) {\n    const { internalId, type, contentGroup: seriesContentGroup, seriesGrouping } = seriesConfig;\n    const { groupIndex = internalId } = seriesGrouping ?? {};\n    const seriesInfo = this.series.get(internalId);\n    if (seriesInfo != null) {\n      throw new Error(`AG Charts - series already has an allocated layer: ${JSON.stringify(seriesInfo)}`);\n    }\n    if (this.series.size === 0) {\n      this.mode = this.expectedSeriesCount >= SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION ? \"aggressive-grouping\" : \"normal\";\n    }\n    let group = this.groups.get(type);\n    if (group == null) {\n      group = /* @__PURE__ */ new Map();\n      this.groups.set(type, group);\n    }\n    const lookupIndex = this.lookupIdx(groupIndex);\n    let groupInfo = group.get(lookupIndex);\n    if (groupInfo == null) {\n      groupInfo = {\n        type,\n        id: lookupIndex,\n        seriesIds: [],\n        group: this.seriesRoot.appendChild(\n          new Group({\n            name: `${seriesConfig.contentGroup.name ?? type}-managed-layer`,\n            zIndex: seriesConfig.contentGroup.zIndex,\n            // Set in updateLayerCompositing\n            renderToOffscreenCanvas: false\n          })\n        )\n      };\n      group.set(lookupIndex, groupInfo);\n    }\n    this.series.set(internalId, { layerState: groupInfo, seriesConfig });\n    groupInfo.seriesIds.push(internalId);\n    groupInfo.group.appendChild(seriesContentGroup);\n    return groupInfo.group;\n  }\n  changeGroup(seriesConfig) {\n    const { internalId, seriesGrouping, type, contentGroup, oldGrouping } = seriesConfig;\n    const { groupIndex = internalId } = seriesGrouping ?? {};\n    if (this.groups.get(type)?.get(groupIndex)?.seriesIds.includes(internalId)) {\n      return;\n    }\n    if (this.series.has(internalId)) {\n      this.releaseGroup({\n        internalId,\n        seriesGrouping: oldGrouping,\n        type,\n        contentGroup\n      });\n    }\n    this.requestGroup(seriesConfig);\n  }\n  releaseGroup(seriesConfig) {\n    const { internalId, contentGroup, type } = seriesConfig;\n    if (!this.series.has(internalId)) {\n      throw new Error(`AG Charts - series doesn't have an allocated layer: ${internalId}`);\n    }\n    const groupInfo = this.series.get(internalId)?.layerState;\n    if (groupInfo) {\n      groupInfo.seriesIds = groupInfo.seriesIds.filter((v) => v !== internalId);\n      groupInfo.group.removeChild(contentGroup);\n    }\n    if (groupInfo?.seriesIds.length === 0) {\n      this.seriesRoot.removeChild(groupInfo.group);\n      this.groups.get(groupInfo.type)?.delete(groupInfo.id);\n      this.groups.get(type)?.delete(internalId);\n    } else if (groupInfo != null && groupInfo.seriesIds.length > 0) {\n      groupInfo.group.zIndex = this.getLowestSeriesZIndex(groupInfo.seriesIds);\n    }\n    this.series.delete(internalId);\n  }\n  updateLayerCompositing() {\n    this.groups.forEach((groups) => {\n      groups.forEach((groupInfo) => {\n        const { group, seriesIds } = groupInfo;\n        let renderToOffscreenCanvas;\n        if (seriesIds.length === 0) {\n          renderToOffscreenCanvas = false;\n        } else if (seriesIds.length > 1) {\n          renderToOffscreenCanvas = true;\n        } else {\n          const series = this.series.get(seriesIds[0]);\n          renderToOffscreenCanvas = series?.seriesConfig.renderToOffscreenCanvas() === true;\n        }\n        group.renderToOffscreenCanvas = renderToOffscreenCanvas;\n        group.zIndex = this.getLowestSeriesZIndex(seriesIds);\n      });\n    });\n  }\n  lookupIdx(groupIndex) {\n    if (this.mode === \"normal\") {\n      return groupIndex;\n    }\n    if (typeof groupIndex === \"string\") {\n      groupIndex = Number(groupIndex.split(\"-\").at(-1));\n      if (!groupIndex) {\n        return 0;\n      }\n    }\n    return Math.floor(\n      clamp(0, groupIndex / this.expectedSeriesCount, 1) * SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION\n    );\n  }\n  destroy() {\n    this.groups.forEach((groups) => {\n      groups.forEach((groupInfo) => {\n        this.seriesRoot.removeChild(groupInfo.group);\n      });\n    });\n    this.groups.clear();\n    this.series.clear();\n  }\n  getLowestSeriesZIndex(seriesIds) {\n    const lowestSeriesZIndex = seriesIds.reduce((currentLowest, seriesId) => {\n      const series = this.series.get(seriesId);\n      const zIndex = series?.seriesConfig.contentGroup.zIndex;\n      if (currentLowest == null || zIndex == null)\n        return zIndex;\n      return compareZIndex(currentLowest, zIndex) <= 0 ? currentLowest : zIndex;\n    }, void 0);\n    return lowestSeriesZIndex ?? 1 /* ANY_CONTENT */;\n  }\n};\n\n// packages/ag-charts-community/src/chart/touch.ts\nvar Touch = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.dragAction = \"drag\";\n  }\n};\n__decorateClass([\n  Validate(UNION([\"none\", \"drag\", \"hover\"]))\n], Touch.prototype, \"dragAction\", 2);\n\n// packages/ag-charts-community/src/chart/update/dataWindowProcessor.ts\nvar DataWindowProcessor = class {\n  constructor(chart, dataService, updateService, zoomManager, animationManager) {\n    this.chart = chart;\n    this.dataService = dataService;\n    this.updateService = updateService;\n    this.zoomManager = zoomManager;\n    this.animationManager = animationManager;\n    this.dirtyZoom = false;\n    this.dirtyDataSource = false;\n    this.lastAxisZooms = /* @__PURE__ */ new Map();\n    this.destroyFns = [];\n    this.destroyFns.push(\n      this.dataService.addListener(\"data-source-change\", () => this.onDataSourceChange()),\n      this.dataService.addListener(\"data-load\", () => this.onDataLoad()),\n      this.dataService.addListener(\"data-error\", () => this.onDataError()),\n      this.updateService.addListener(\"update-complete\", () => this.onUpdateComplete()),\n      this.zoomManager.addListener(\"zoom-change\", () => this.onZoomChange())\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n  }\n  onDataLoad() {\n    this.animationManager.skip();\n    this.updateService.update(1 /* UPDATE_DATA */);\n  }\n  onDataError() {\n    this.updateService.update(3 /* PERFORM_LAYOUT */);\n  }\n  onDataSourceChange() {\n    this.dirtyDataSource = true;\n  }\n  onUpdateComplete() {\n    if (!this.dirtyZoom && !this.dirtyDataSource)\n      return;\n    this.updateWindow();\n  }\n  onZoomChange() {\n    this.dirtyZoom = true;\n  }\n  updateWindow() {\n    if (!this.dataService.isLazy())\n      return;\n    const axis = this.getValidAxis();\n    let window2;\n    let shouldRefresh = true;\n    if (axis) {\n      const zoom = this.zoomManager.getAxisZoom(axis.id);\n      window2 = this.getAxisWindow(axis, zoom);\n      shouldRefresh = this.shouldRefresh(axis, zoom);\n    }\n    this.dirtyZoom = false;\n    this.dirtyDataSource = false;\n    if (!shouldRefresh)\n      return;\n    this.dataService.load({ windowStart: window2?.min, windowEnd: window2?.max });\n  }\n  getValidAxis() {\n    return this.chart.axes.find((axis) => axis.type === \"time\");\n  }\n  shouldRefresh(axis, zoom) {\n    if (this.dirtyDataSource)\n      return true;\n    if (!this.dirtyZoom)\n      return false;\n    const lastZoom = this.lastAxisZooms.get(axis.id);\n    if (lastZoom && zoom.min === lastZoom.min && zoom.max === lastZoom.max) {\n      return false;\n    }\n    this.lastAxisZooms.set(axis.id, zoom);\n    return true;\n  }\n  getAxisWindow(axis, zoom) {\n    const { domain } = axis.scale;\n    if (!zoom || domain.length === 0 || isNaN(Number(domain[0])))\n      return;\n    const diff2 = Number(domain[1]) - Number(domain[0]);\n    const min = new Date(Number(domain[0]) + diff2 * zoom.min);\n    const max = new Date(Number(domain[0]) + diff2 * zoom.max);\n    return { min, max };\n  }\n};\n\n// packages/ag-charts-community/src/util/browser.ts\nvar isSafariRegexp = /^((?!chrome|android).)*safari/i;\nvar safariVersionRegexp = /Version\\/(\\d+(\\.\\d+)?)/;\nvar isChromeRegexp = /Chrome/;\nvar chromeVersionRegexp = /Chrome\\/(\\d+)/;\nvar isEdge = /Edg/;\nvar isOpera = /OPR/;\nfunction isUnsupportedBrowser() {\n  const { userAgent } = getWindow(\"navigator\");\n  if (isSafariRegexp.test(userAgent)) {\n    const version = parseFloat(safariVersionRegexp.exec(userAgent)?.[1] ?? \"0\");\n    const supported = Math.floor(version) > 16;\n    if (!supported) {\n      logger_exports.warnOnce(`Unsupported Safari version: ${version}; ${userAgent}`);\n    }\n    return !supported;\n  } else if (isChromeRegexp.test(userAgent) && !isEdge.test(userAgent) && !isOpera.test(userAgent)) {\n    const version = parseInt(chromeVersionRegexp.exec(userAgent)?.[1] ?? \"0\", 10);\n    const supported = version > 126;\n    if (!supported) {\n      logger_exports.warnOnce(`Unsupported Chrome version: ${version}; ${userAgent}`);\n    }\n    return !supported;\n  }\n  return false;\n}\n\n// packages/ag-charts-community/src/chart/update/overlaysProcessor.ts\nvar visibleIgnoredSeries = /* @__PURE__ */ new Set([\"map-shape-background\", \"map-line-background\"]);\nvar OverlaysProcessor = class {\n  constructor(chartLike, overlays, dataService, layoutManager, localeManager, animationManager, domManager) {\n    this.chartLike = chartLike;\n    this.overlays = overlays;\n    this.dataService = dataService;\n    this.layoutManager = layoutManager;\n    this.localeManager = localeManager;\n    this.animationManager = animationManager;\n    this.domManager = domManager;\n    this.destroyFns = [];\n    this.overlayElem = this.domManager.addChild(\"canvas-overlay\", \"overlay\");\n    this.overlayElem.role = \"status\";\n    this.overlayElem.ariaAtomic = \"false\";\n    this.overlayElem.ariaLive = \"polite\";\n    this.overlayElem.classList.toggle(DEFAULT_OVERLAY_CLASS);\n    this.destroyFns.push(this.layoutManager.addListener(\"layout:complete\", (e) => this.onLayoutComplete(e)));\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n    this.domManager.removeStyles(\"overlays\");\n    this.domManager.removeChild(\"canvas-overlay\", \"overlay\");\n  }\n  onLayoutComplete({ series: { rect } }) {\n    const isLoading = this.dataService.isLoading();\n    const hasData = this.chartLike.series.some((s) => s.hasData);\n    const anySeriesVisible = this.chartLike.series.some((s) => s.visible && !visibleIgnoredSeries.has(s.type));\n    if (this.overlays.darkTheme) {\n      this.overlayElem.classList.add(DEFAULT_OVERLAY_DARK_CLASS);\n    } else {\n      this.overlayElem.classList.remove(DEFAULT_OVERLAY_DARK_CLASS);\n    }\n    this.overlayElem.style.left = `${rect.x}px`;\n    this.overlayElem.style.top = `${rect.y}px`;\n    this.overlayElem.style.width = `${rect.width}px`;\n    this.overlayElem.style.height = `${rect.height}px`;\n    const loadingShown = isLoading;\n    const noDataShown = !isLoading && !hasData;\n    const noVisibleSeriesShown = hasData && !anySeriesVisible;\n    const unsupportedBrowser = this.overlays.unsupportedBrowser.enabled && isUnsupportedBrowser();\n    if (loadingShown) {\n      this.showOverlay(this.overlays.loading, rect);\n    } else {\n      this.hideOverlay(this.overlays.loading);\n    }\n    if (noDataShown) {\n      this.showOverlay(this.overlays.noData, rect);\n    } else {\n      this.hideOverlay(this.overlays.noData);\n    }\n    if (noVisibleSeriesShown) {\n      this.showOverlay(this.overlays.noVisibleSeries, rect);\n    } else {\n      this.hideOverlay(this.overlays.noVisibleSeries);\n    }\n    if (unsupportedBrowser) {\n      this.showOverlay(this.overlays.unsupportedBrowser, rect);\n    } else {\n      this.hideOverlay(this.overlays.unsupportedBrowser);\n    }\n    const shown = loadingShown || noDataShown || noVisibleSeriesShown || unsupportedBrowser;\n    setAttribute(this.overlayElem, \"aria-hidden\", !shown);\n  }\n  showOverlay(overlay, seriesRect) {\n    if (!overlay.enabled)\n      return;\n    const element2 = overlay.getElement(this.animationManager, this.localeManager, seriesRect);\n    this.overlayElem.appendChild(element2);\n  }\n  hideOverlay(overlay) {\n    overlay.removeElement(() => {\n      this.overlayElem.innerText = \"\\xA0\";\n    }, this.animationManager);\n  }\n};\n\n// packages/ag-charts-community/src/chart/chart.ts\nvar debug = Debug.create(true, \"opts\");\nvar SeriesArea = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.padding = new Padding(0);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesArea.prototype, \"clip\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesArea.prototype, \"padding\", 2);\nvar _Chart = class _Chart extends Observable {\n  constructor(options, resources) {\n    var _a;\n    super();\n    this.id = createId(this);\n    this.seriesRoot = new TranslatableGroup({\n      name: `${this.id}-series-root`,\n      zIndex: 5 /* SERIES_LAYER */\n    });\n    this.annotationRoot = new TranslatableGroup({\n      name: `${this.id}-annotation-root`,\n      zIndex: 9 /* SERIES_ANNOTATION */\n    });\n    this.titleGroup = new Group({\n      name: \"titles\",\n      zIndex: 13 /* SERIES_LABEL */\n    });\n    this.debug = Debug.create();\n    this.extraDebugStats = {};\n    this.data = [];\n    this._firstAutoSize = true;\n    this._autoSizeNotify = new AsyncAwaitQueue();\n    this.padding = new Padding(20);\n    this.seriesArea = new SeriesArea();\n    this.keyboard = new Keyboard();\n    this.touch = new Touch();\n    this.mode = \"standalone\";\n    this.chartCaptions = new ChartCaptions();\n    this.suppressFieldDotNotation = false;\n    this.destroyed = false;\n    this._destroyFns = [];\n    // Used to prevent infinite update loops when syncing charts.\n    this.skipSync = false;\n    this.chartAnimationPhase = \"initial\";\n    this.modulesManager = new ModulesManager();\n    this.processors = [];\n    this.queuedUserOptions = [];\n    this.queuedChartOptions = [];\n    this.firstApply = true;\n    this._pendingFactoryUpdatesCount = 0;\n    this._performUpdateSkipAnimations = false;\n    this._performUpdateNotify = new AsyncAwaitQueue();\n    this.performUpdateType = 7 /* NONE */;\n    this.runningUpdateType = 7 /* NONE */;\n    this.updateShortcutCount = 0;\n    this.seriesToUpdate = /* @__PURE__ */ new Set();\n    this.updateMutex = new Mutex();\n    this.updateRequestors = {};\n    this.performUpdateTrigger = debouncedCallback(({ count }) => {\n      if (this.destroyed)\n        return;\n      this.updateMutex.acquire(async () => {\n        try {\n          await this.performUpdate(count);\n        } catch (error2) {\n          logger_exports.error(\"update error\", error2);\n        }\n      }).catch((e) => logger_exports.errorOnce(e));\n    });\n    this._performUpdateSplits = {};\n    this.axes = [];\n    this.series = [];\n    this._cachedData = void 0;\n    this.onSeriesNodeClick = (event) => {\n      this.fireEvent({ ...event, type: \"seriesNodeClick\" });\n    };\n    this.onSeriesNodeDoubleClick = (event) => {\n      this.fireEvent({ ...event, type: \"seriesNodeDoubleClick\" });\n    };\n    this.onSeriesVisibilityChange = (event) => {\n      this.fireEvent(event);\n    };\n    this.seriesGroupingChanged = (event) => {\n      if (!(event instanceof SeriesGroupingChangedEvent))\n        return;\n      const { series, seriesGrouping, oldGrouping } = event;\n      if (series.contentGroup.isRoot())\n        return;\n      this.seriesLayerManager.changeGroup({\n        internalId: series.internalId,\n        type: series.type,\n        contentGroup: series.contentGroup,\n        renderToOffscreenCanvas: () => series.renderToOffscreenCanvas(),\n        seriesGrouping,\n        oldGrouping\n      });\n    };\n    this.chartOptions = options;\n    const scene = resources?.scene;\n    const container = resources?.container ?? options.processedOptions.container ?? void 0;\n    const styleContainer = resources?.styleContainer ?? options.specialOverrides.styleContainer;\n    if (scene) {\n      this._firstAutoSize = false;\n      this._lastAutoSize = [scene.width, scene.height, scene.pixelRatio];\n    }\n    const root = new Group({ name: \"root\" });\n    root.visible = false;\n    root.append(this.seriesRoot);\n    root.append(this.annotationRoot);\n    root.append(this.titleGroup);\n    this.titleGroup.append(this.title.node);\n    this.titleGroup.append(this.subtitle.node);\n    this.titleGroup.append(this.footnote.node);\n    this.tooltip = new Tooltip();\n    this.seriesLayerManager = new SeriesLayerManager(this.seriesRoot);\n    this.mode = options.userOptions.mode ?? this.mode;\n    const ctx = this.ctx = new ChartContext(this, {\n      chartType: this.getChartType(),\n      scene,\n      root,\n      container,\n      styleContainer,\n      syncManager: new SyncManager(this),\n      fireEvent: (event) => this.fireEvent(event),\n      updateCallback: (type, opts) => this.update(type, opts),\n      updateMutex: this.updateMutex\n    });\n    this._destroyFns.push(\n      ctx.domManager.addListener(\"resize\", () => this.parentResize(ctx.domManager.containerSize))\n    );\n    this.overlays = new ChartOverlays();\n    (_a = this.overlays.loading).renderer ?? (_a.renderer = () => getLoadingSpinner(this.overlays.loading.getText(ctx.localeManager), ctx.animationManager.defaultDuration));\n    this.processors = [\n      new DataWindowProcessor(this, ctx.dataService, ctx.updateService, ctx.zoomManager, ctx.animationManager),\n      new OverlaysProcessor(\n        this,\n        this.overlays,\n        ctx.dataService,\n        ctx.layoutManager,\n        ctx.localeManager,\n        ctx.animationManager,\n        ctx.domManager\n      )\n    ];\n    this.highlight = new ChartHighlight();\n    this.container = container;\n    const moduleContext = this.getModuleContext();\n    ctx.domManager.setDataBoolean(\"animating\", false);\n    this.seriesAreaManager = new SeriesAreaManager(this.initSeriesAreaDependencies());\n    this._destroyFns.push(\n      ctx.layoutManager.registerElement(0 /* Caption */, (e) => {\n        e.layoutBox.shrink(this.padding.toJson());\n        this.chartCaptions.positionCaptions(e);\n      }),\n      ctx.layoutManager.addListener(\"layout:complete\", (e) => this.chartCaptions.positionAbsoluteCaptions(e)),\n      ctx.dataService.addListener(\"data-load\", (event) => {\n        this.data = event.data;\n      }),\n      this.title.registerInteraction(moduleContext, \"beforebegin\"),\n      this.subtitle.registerInteraction(moduleContext, \"beforebegin\"),\n      this.footnote.registerInteraction(moduleContext, \"afterend\"),\n      Widget.addWindowEvent(\"page-left\", () => this.destroy()),\n      ctx.animationManager.addListener(\"animation-frame\", () => {\n        this.update(6 /* SCENE_RENDER */);\n      }),\n      ctx.animationManager.addListener(\"animation-start\", () => ctx.domManager.setDataBoolean(\"animating\", true)),\n      ctx.animationManager.addListener(\"animation-stop\", () => ctx.domManager.setDataBoolean(\"animating\", false)),\n      ctx.zoomManager.addListener(\"zoom-change\", () => {\n        this.series.forEach((s) => s.animationState?.transition(\"updateData\"));\n        const skipAnimations = this.chartAnimationPhase !== \"initial\";\n        this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });\n      })\n    );\n    this.parentResize(ctx.domManager.containerSize);\n  }\n  static getInstance(element2) {\n    return _Chart.chartsInstances.get(element2);\n  }\n  /** NOTE: This is exposed for use by Integrated charts only. */\n  get canvasElement() {\n    return this.ctx.scene.canvas.element;\n  }\n  download(fileName, fileFormat) {\n    this.ctx.scene.download(fileName, fileFormat);\n  }\n  getCanvasDataURL(fileFormat) {\n    return this.ctx.scene.getDataURL(fileFormat);\n  }\n  toSVG() {\n    return this.ctx.scene.toSVG();\n  }\n  getOptions() {\n    return this.queuedUserOptions.at(-1) ?? this.chartOptions.userOptions;\n  }\n  getChartOptions() {\n    return this.queuedChartOptions.at(-1) ?? this.chartOptions;\n  }\n  overrideFocusVisible(visible) {\n    this.seriesAreaManager.focusIndicator.overrideFocusVisible(visible);\n  }\n  initSeriesAreaDependencies() {\n    const { ctx, tooltip, highlight, overlays, seriesRoot, mode } = this;\n    const chartType = this.getChartType();\n    const fireEvent = this.fireEvent.bind(this);\n    const getUpdateType = () => this.performUpdateType;\n    return { fireEvent, getUpdateType, chartType, ctx, tooltip, highlight, overlays, seriesRoot, mode };\n  }\n  getModuleContext() {\n    return this.ctx;\n  }\n  getCaptionText() {\n    return [this.title, this.subtitle, this.footnote].filter((caption) => caption.enabled && caption.text).map((caption) => caption.text).join(\". \");\n  }\n  getAriaLabel() {\n    return this.ctx.localeManager.t(\"ariaAnnounceChart\", { seriesCount: this.series.length });\n  }\n  resetAnimations() {\n    this.chartAnimationPhase = \"initial\";\n    for (const series of this.series) {\n      series.resetAnimation(this.chartAnimationPhase);\n    }\n    for (const axis of this.axes) {\n      axis.resetAnimation(this.chartAnimationPhase);\n    }\n    this.animationRect = void 0;\n    this.ctx.animationManager.reset();\n  }\n  skipAnimations() {\n    this.ctx.animationManager.skipCurrentBatch();\n    this._performUpdateSkipAnimations = true;\n  }\n  detachAndClear() {\n    this.container = void 0;\n    this.ctx.scene.clear();\n  }\n  destroy(opts) {\n    if (this.destroyed) {\n      return;\n    }\n    const keepTransferableResources = opts?.keepTransferableResources;\n    let result;\n    this.performUpdateType = 7 /* NONE */;\n    this._destroyFns.forEach((fn) => fn());\n    this.processors.forEach((p) => p.destroy());\n    this.tooltip.destroy(this.ctx.domManager);\n    this.overlays.destroy();\n    this.modulesManager.destroy();\n    if (keepTransferableResources) {\n      this.ctx.scene.strip();\n      result = {\n        container: this.container,\n        scene: this.ctx.scene\n      };\n    } else {\n      this.ctx.scene.destroy();\n      this.container = void 0;\n    }\n    this.destroySeries(this.series);\n    this.seriesLayerManager.destroy();\n    this.axes.forEach((a) => a.destroy());\n    this.axes = [];\n    this.animationRect = void 0;\n    this.ctx.destroy();\n    this.destroyed = true;\n    Object.freeze(this);\n    return result;\n  }\n  requestFactoryUpdate(cb) {\n    if (this.destroyed)\n      return;\n    this._pendingFactoryUpdatesCount++;\n    this.updateMutex.acquire(async () => {\n      if (this.destroyed)\n        return;\n      try {\n        await cb(this);\n      } finally {\n        if (!this.destroyed) {\n          this._pendingFactoryUpdatesCount--;\n        }\n      }\n    }).catch((e) => logger_exports.errorOnce(e));\n  }\n  update(type = 0 /* FULL */, opts) {\n    if (this.destroyed)\n      return;\n    const {\n      forceNodeDataRefresh = false,\n      skipAnimations,\n      seriesToUpdate = this.series,\n      newAnimationBatch\n    } = opts ?? {};\n    this.ctx.widgets.seriesWidget.setDragTouchEnabled(this.touch.dragAction !== \"none\");\n    if (forceNodeDataRefresh) {\n      this.series.forEach((series) => series.markNodeDataDirty());\n    }\n    for (const series of seriesToUpdate) {\n      this.seriesToUpdate.add(series);\n    }\n    if (skipAnimations) {\n      this.ctx.animationManager.skipCurrentBatch();\n      this._performUpdateSkipAnimations = true;\n    }\n    if (newAnimationBatch && this.ctx.animationManager.isActive()) {\n      this._performUpdateSkipAnimations = true;\n    }\n    this.skipSync = opts?.skipSync ?? false;\n    if (this.debug.check()) {\n      let stack = new Error().stack ?? \"<unknown>\";\n      stack = stack.replace(/\\([^)]*/g, \"\");\n      this.updateRequestors[stack] = type;\n    }\n    if (type < this.performUpdateType) {\n      this.performUpdateType = type;\n      this.ctx.domManager.setDataBoolean(\"updatePending\", true);\n      this.performUpdateTrigger.schedule(opts?.backOffMs);\n    }\n  }\n  async performUpdate(count) {\n    const { performUpdateType, extraDebugStats, _performUpdateSplits: splits, ctx } = this;\n    const seriesToUpdate = [...this.seriesToUpdate];\n    this.performUpdateType = 7 /* NONE */;\n    this.seriesToUpdate.clear();\n    this.runningUpdateType = performUpdateType;\n    if (this.updateShortcutCount === 0 && performUpdateType < 6 /* SCENE_RENDER */) {\n      ctx.animationManager.startBatch(this._performUpdateSkipAnimations);\n      ctx.animationManager.onBatchStop(() => this.chartAnimationPhase = \"ready\");\n    }\n    this.debug(\"Chart.performUpdate() - start\", ChartUpdateType[performUpdateType]);\n    let previousSplit = performance.now();\n    splits.start ?? (splits.start = previousSplit);\n    const updateSplits = (splitName) => {\n      splits[splitName] ?? (splits[splitName] = 0);\n      splits[splitName] += performance.now() - previousSplit;\n      previousSplit = performance.now();\n    };\n    switch (performUpdateType) {\n      case 0 /* FULL */:\n        if (this.checkUpdateShortcut(0 /* FULL */))\n          break;\n        this.ctx.updateService.dispatchPreDomUpdate();\n        this.updateDOM();\n      case 1 /* UPDATE_DATA */:\n        if (this.checkUpdateShortcut(1 /* UPDATE_DATA */))\n          break;\n        await this.updateData();\n        updateSplits(\"\\u2B07\\uFE0F\");\n      case 2 /* PROCESS_DATA */:\n        if (this.checkUpdateShortcut(2 /* PROCESS_DATA */))\n          break;\n        await this.processData();\n        this.seriesAreaManager.dataChanged();\n        updateSplits(\"\\u{1F3ED}\");\n      case 3 /* PERFORM_LAYOUT */:\n        await this.checkFirstAutoSize();\n        if (this.checkUpdateShortcut(3 /* PERFORM_LAYOUT */))\n          break;\n        await this.processLayout();\n        updateSplits(\"\\u2316\");\n      case 4 /* SERIES_UPDATE */: {\n        if (this.checkUpdateShortcut(4 /* SERIES_UPDATE */))\n          break;\n        await this.updateSeries(seriesToUpdate);\n        updateSplits(\"\\u{1F914}\");\n        this.updateAriaLabels();\n        this.seriesLayerManager.updateLayerCompositing();\n      }\n      case 5 /* PRE_SCENE_RENDER */:\n        if (this.checkUpdateShortcut(5 /* PRE_SCENE_RENDER */))\n          break;\n        ctx.updateService.dispatchPreSceneRender();\n        updateSplits(\"\\u2196\");\n      case 6 /* SCENE_RENDER */:\n        if (this.checkUpdateShortcut(6 /* SCENE_RENDER */))\n          break;\n        ctx.animationManager.endBatch();\n        extraDebugStats[\"updateShortcutCount\"] = this.updateShortcutCount;\n        ctx.scene.render({ debugSplitTimes: splits, extraDebugStats, seriesRect: this.seriesRect });\n        this.extraDebugStats = {};\n        for (const key of Object.keys(splits)) {\n          delete splits[key];\n        }\n        this.ctx.domManager.incrementDataCounter(\"sceneRenders\");\n      case 7 /* NONE */:\n        this.updateShortcutCount = 0;\n        this.updateRequestors = {};\n        this._performUpdateSkipAnimations = false;\n        ctx.animationManager.endBatch();\n    }\n    if (!this.destroyed) {\n      ctx.updateService.dispatchUpdateComplete();\n      this.ctx.domManager.setDataBoolean(\"updatePending\", false);\n      this.runningUpdateType = 7 /* NONE */;\n    }\n    this._performUpdateNotify.notify();\n    const end2 = performance.now();\n    this.debug(\"Chart.performUpdate() - end\", {\n      chart: this,\n      durationMs: Math.round((end2 - splits[\"start\"]) * 100) / 100,\n      count,\n      performUpdateType: ChartUpdateType[performUpdateType]\n    });\n  }\n  updateThemeClassName() {\n    const themeClassNamePrefix = \"ag-charts-theme-\";\n    const validThemeClassNames = [`${themeClassNamePrefix}default`, `${themeClassNamePrefix}default-dark`];\n    let themeClassName = validThemeClassNames[0];\n    let isDark = false;\n    let { theme } = this.chartOptions.processedOptions;\n    while (typeof theme !== \"string\" && theme != null) {\n      theme = theme.baseTheme;\n    }\n    if (typeof theme === \"string\") {\n      themeClassName = theme.replace(\"ag-\", themeClassNamePrefix);\n      isDark = theme.includes(\"-dark\");\n    }\n    if (!validThemeClassNames.includes(themeClassName)) {\n      themeClassName = isDark ? validThemeClassNames[1] : validThemeClassNames[0];\n    }\n    this.ctx.domManager.setThemeClass(themeClassName);\n  }\n  updateDOM() {\n    this.updateThemeClassName();\n    const { enabled, tabIndex } = this.keyboard;\n    this.ctx.domManager.setTabGuardIndex(enabled ? tabIndex ?? 0 : -1);\n    this.ctx.domManager.setThemeParameters(this.chartOptions.themeParameters);\n  }\n  updateAriaLabels() {\n    this.ctx.domManager.updateCanvasLabel(this.getAriaLabel());\n  }\n  checkUpdateShortcut(checkUpdateType) {\n    const maxShortcuts = 3;\n    if (this.destroyed)\n      return true;\n    if (this.updateShortcutCount > maxShortcuts) {\n      logger_exports.warn(\n        `exceeded the maximum number of simultaneous updates (${maxShortcuts + 1}), discarding changes and rendering`,\n        this.updateRequestors\n      );\n      return false;\n    }\n    if (this.performUpdateType <= checkUpdateType) {\n      this.updateShortcutCount++;\n      return true;\n    }\n    return false;\n  }\n  async checkFirstAutoSize() {\n    if (this.width != null && this.height != null) {\n    } else if (!this._lastAutoSize) {\n      const success = await this._autoSizeNotify.await(500);\n      if (!success) {\n        this.debug(\"Chart.checkFirstAutoSize() - timeout for first size update.\");\n      }\n    }\n  }\n  onAxisChange(newValue, oldValue) {\n    if (oldValue == null && newValue.length === 0)\n      return;\n    this.ctx.axisManager.updateAxes(oldValue ?? [], newValue);\n  }\n  onSeriesChange(newValue, oldValue) {\n    const seriesToDestroy = oldValue?.filter((series) => !newValue.includes(series)) ?? [];\n    this.destroySeries(seriesToDestroy);\n    this.seriesLayerManager?.setSeriesCount(newValue.length);\n    for (const series of newValue) {\n      if (oldValue?.includes(series))\n        continue;\n      const seriesContentNode = this.seriesLayerManager.requestGroup(series);\n      series.attachSeries(seriesContentNode, this.seriesRoot, this.annotationRoot);\n      const chart = this;\n      series.chart = {\n        get mode() {\n          return chart.mode;\n        },\n        get isMiniChart() {\n          return false;\n        },\n        get seriesRect() {\n          return chart.seriesRect;\n        }\n      };\n      series.resetAnimation(this.chartAnimationPhase);\n      this.addSeriesListeners(series);\n      series.addChartEventListeners();\n    }\n    this.seriesAreaManager?.seriesChanged(newValue);\n  }\n  destroySeries(allSeries) {\n    allSeries?.forEach((series) => {\n      series.removeEventListener(\"nodeClick\", this.onSeriesNodeClick);\n      series.removeEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n      series.removeEventListener(\"groupingChanged\", this.seriesGroupingChanged);\n      series.destroy();\n      this.seriesLayerManager.releaseGroup(series);\n      series.detachSeries(void 0, this.seriesRoot, this.annotationRoot);\n      series.chart = void 0;\n    });\n  }\n  addSeriesListeners(series) {\n    if (this.hasEventListener(\"seriesNodeClick\")) {\n      series.addEventListener(\"nodeClick\", this.onSeriesNodeClick);\n    }\n    if (this.hasEventListener(\"seriesNodeDoubleClick\")) {\n      series.addEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n    }\n    if (this.hasEventListener(\"seriesVisibilityChange\")) {\n      series.addEventListener(\"seriesVisibilityChange\", this.onSeriesVisibilityChange);\n    }\n    series.addEventListener(\"groupingChanged\", this.seriesGroupingChanged);\n  }\n  assignSeriesToAxes() {\n    for (const axis of this.axes) {\n      axis.boundSeries = this.series.filter((s) => s.axes[axis.direction] === axis);\n    }\n  }\n  assignAxesToSeries() {\n    const directionToAxesMap = groupBy(this.axes, (axis) => axis.direction);\n    for (const series of this.series) {\n      for (const direction of series.directions) {\n        const directionAxes = directionToAxesMap[direction];\n        if (!directionAxes) {\n          logger_exports.warnOnce(\n            `no available axis for direction [${direction}]; check series and axes configuration.`\n          );\n          return;\n        }\n        const seriesKeys = series.getKeys(direction);\n        const newAxis = directionAxes.find(\n          (axis) => !axis.keys.length || seriesKeys.some((key) => axis.keys.includes(key))\n        );\n        if (!newAxis) {\n          logger_exports.warnOnce(\n            `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`\n          );\n          return;\n        }\n        series.axes[direction] = newAxis;\n      }\n    }\n  }\n  parentResize(size) {\n    if (size == null || this.width != null && this.height != null)\n      return;\n    let { width: width2, height: height2 } = size;\n    const { pixelRatio } = size;\n    width2 = Math.floor(width2);\n    height2 = Math.floor(height2);\n    if (width2 === 0 && height2 === 0)\n      return;\n    const [autoWidth = 0, autoHeight = 0, autoPixelRatio = 1] = this._lastAutoSize ?? [];\n    if (autoWidth === width2 && autoHeight === height2 && autoPixelRatio === pixelRatio)\n      return;\n    this._lastAutoSize = [width2, height2, pixelRatio];\n    this.resize(\"SizeMonitor\", {});\n  }\n  resize(source, opts) {\n    const { scene, animationManager } = this.ctx;\n    const { inWidth, inHeight, inMinWidth, inMinHeight, inOverrideDevicePixelRatio } = opts;\n    this.ctx.domManager.setSizeOptions(\n      inMinWidth ?? this.minWidth,\n      inMinHeight ?? this.minHeight,\n      inWidth ?? this.width,\n      inHeight ?? this.height\n    );\n    const width2 = inWidth ?? this.width ?? this._lastAutoSize?.[0];\n    const height2 = inHeight ?? this.height ?? this._lastAutoSize?.[1];\n    const pixelRatio = inOverrideDevicePixelRatio ?? this.overrideDevicePixelRatio ?? this._lastAutoSize?.[2];\n    this.debug(`Chart.resize() from ${source}`, { width: width2, height: height2, pixelRatio, stack: new Error().stack });\n    if (width2 == null || height2 == null || !isFiniteNumber(width2) || !isFiniteNumber(height2))\n      return;\n    if (scene.resize(width2, height2, pixelRatio)) {\n      animationManager.reset();\n      let skipAnimations = true;\n      if ((this.width == null || this.height == null) && this._firstAutoSize) {\n        skipAnimations = false;\n        this._firstAutoSize = false;\n      }\n      this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });\n      this._autoSizeNotify.notify();\n    }\n  }\n  async updateData() {\n    this.series.forEach((s) => s.setChartData(this.data));\n    const modulePromises = this.modulesManager.mapModules((m) => m.updateData?.(this.data));\n    await Promise.all(modulePromises);\n  }\n  async processData() {\n    if (this.series.some((s) => s.canHaveAxes)) {\n      this.assignAxesToSeries();\n      this.assignSeriesToAxes();\n    }\n    const dataController = new DataController(this.mode, this.suppressFieldDotNotation);\n    const seriesPromises = this.series.map((s) => {\n      s.resetDatumCallbackCache();\n      return s.processData(dataController);\n    });\n    const modulePromises = this.modulesManager.mapModules((m) => m.processData?.(dataController));\n    this._cachedData = dataController.execute(this._cachedData);\n    await Promise.all([...seriesPromises, ...modulePromises]);\n    for (const axis of this.axes) {\n      axis.processData();\n    }\n    this.updateLegends();\n  }\n  updateLegends(initialStateLegend) {\n    for (const { legend, legendType } of this.modulesManager.legends()) {\n      if (legendType === \"category\") {\n        this.setCategoryLegendData(initialStateLegend);\n      } else {\n        this.setLegendData(legendType, legend);\n      }\n    }\n  }\n  setCategoryLegendData(initialState) {\n    var _a;\n    const {\n      ctx: { legendManager, stateManager }\n    } = this;\n    if (initialState) {\n      this.series.forEach((s) => {\n        const seriesState = initialState.find((init) => init.seriesId === s.id);\n        s.onLegendInitialState(\"category\", seriesState);\n      });\n    }\n    const legendData = this.series.flatMap((s) => {\n      const seriesLegendData = s.getLegendData(\"category\");\n      legendManager.updateData(s.id, seriesLegendData);\n      return seriesLegendData;\n    });\n    if (initialState) {\n      stateManager.setStateAndRestore(legendManager, initialState);\n      return;\n    }\n    if (this.mode !== \"integrated\") {\n      const seriesMarkerFills = {};\n      const seriesTypeMap = new Map(this.series.map((s) => [s.id, s.type]));\n      for (const {\n        seriesId,\n        symbol: { marker },\n        label\n      } of legendData.filter((d) => !d.hideInLegend)) {\n        if (marker.fill == null)\n          continue;\n        const seriesType = seriesTypeMap.get(seriesId);\n        const markerFill = seriesMarkerFills[seriesType] ?? (seriesMarkerFills[seriesType] = {});\n        markerFill[_a = label.text] ?? (markerFill[_a] = marker.fill);\n        if (markerFill[label.text] !== marker.fill) {\n          logger_exports.warnOnce(\n            `legend item '${label.text}' has multiple fill colors, this may cause unexpected behaviour.`\n          );\n        }\n      }\n    }\n    legendManager.update();\n  }\n  setLegendData(legendType, legend) {\n    legend.data = this.series.filter((s) => s.properties.showInLegend).flatMap((s) => s.getLegendData(legendType));\n  }\n  async processLayout() {\n    const oldRect = this.animationRect;\n    const { width: width2, height: height2 } = this.ctx.scene;\n    const ctx = this.ctx.layoutManager.createContext(width2, height2);\n    await this.performLayout(ctx);\n    if (oldRect && !this.animationRect?.equals(oldRect)) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    this.debug(\"Chart.performUpdate() - seriesRect\", this.seriesRect);\n  }\n  async updateSeries(seriesToUpdate) {\n    const { seriesRect } = this;\n    await Promise.all(seriesToUpdate.map((series) => series.update({ seriesRect })));\n    this.ctx.seriesLabelLayoutManager.updateLabels(\n      this.series.filter((s) => s.visible && s.usesPlacedLabels),\n      this.padding,\n      this.seriesRect\n    );\n  }\n  async waitForUpdate(timeoutMs = 1e4, failOnTimeout = false) {\n    const start2 = performance.now();\n    while (this._pendingFactoryUpdatesCount > 0 || this.performUpdateType !== 7 /* NONE */ || this.runningUpdateType !== 7 /* NONE */) {\n      if (this.destroyed)\n        break;\n      if (this._pendingFactoryUpdatesCount > 0) {\n        await this.updateMutex.waitForClearAcquireQueue();\n      }\n      if (this.performUpdateType !== 7 /* NONE */ || this.runningUpdateType !== 7 /* NONE */) {\n        await this._performUpdateNotify.await();\n      }\n      if (performance.now() - start2 > timeoutMs) {\n        const message = `Chart.waitForUpdate() timeout of ${timeoutMs} reached - first chart update taking too long.`;\n        if (failOnTimeout) {\n          throw new Error(message);\n        } else {\n          logger_exports.warnOnce(message);\n        }\n      }\n      if (isInputPending()) {\n        await pause();\n      }\n    }\n  }\n  filterMiniChartSeries(series) {\n    return series?.filter((s) => s.showInMiniChart !== false);\n  }\n  applyOptions(newChartOptions) {\n    const deltaOptions = this.firstApply ? newChartOptions.processedOptions : newChartOptions.diffOptions(this.chartOptions);\n    if (deltaOptions == null || Object.keys(deltaOptions).length === 0)\n      return;\n    const oldOpts = this.firstApply ? {} : this.chartOptions.processedOptions;\n    const newOpts = newChartOptions.processedOptions;\n    debug(\"Chart.applyOptions() - applying delta\", deltaOptions);\n    const modulesChanged = this.applyModules(newOpts);\n    const skip = [\n      \"type\",\n      \"data\",\n      \"series\",\n      \"listeners\",\n      \"preset\",\n      \"theme\",\n      \"legend.listeners\",\n      \"navigator.miniChart.series\",\n      \"navigator.miniChart.label\",\n      \"locale.localeText\",\n      \"axes\",\n      \"topology\",\n      \"nodes\",\n      \"initialState\",\n      \"styleContainer\"\n    ];\n    if (deltaOptions.listeners) {\n      this.registerListeners(this, deltaOptions.listeners);\n    }\n    jsonApply(this, deltaOptions, { skip });\n    let forceNodeDataRefresh = false;\n    let seriesStatus = \"no-op\";\n    if (deltaOptions.series != null) {\n      seriesStatus = this.applySeries(this, deltaOptions.series, oldOpts?.series);\n      forceNodeDataRefresh = true;\n    }\n    if (seriesStatus === \"replaced\") {\n      this.resetAnimations();\n    }\n    if (this.applyAxes(this, newOpts, oldOpts, seriesStatus, [])) {\n      forceNodeDataRefresh = true;\n    }\n    if (deltaOptions.data) {\n      this.data = deltaOptions.data;\n    }\n    if (deltaOptions.legend?.listeners && this.modulesManager.isEnabled(\"legend\")) {\n      Object.assign(this.legend.listeners, deltaOptions.legend.listeners);\n    }\n    if (deltaOptions.locale?.localeText) {\n      this.modulesManager.getModule(\"locale\").localeText = deltaOptions.locale?.localeText;\n    }\n    this.chartOptions = newChartOptions;\n    const navigatorModule = this.modulesManager.getModule(\"navigator\");\n    const zoomModule = this.modulesManager.getModule(\"zoom\");\n    if (!navigatorModule?.enabled && !zoomModule?.enabled) {\n      this.ctx.zoomManager.updateZoom(\"chart\");\n    }\n    const miniChart = navigatorModule?.miniChart;\n    const miniChartSeries = newOpts.navigator?.miniChart?.series ?? newOpts.series;\n    if (miniChart?.enabled === true && miniChartSeries != null) {\n      this.applyMiniChartOptions(miniChart, miniChartSeries, newOpts, oldOpts);\n    } else if (miniChart?.enabled === false) {\n      miniChart.series = [];\n      miniChart.axes = [];\n    }\n    this.ctx.annotationManager.setAnnotationStyles(newChartOptions.annotationThemes);\n    forceNodeDataRefresh || (forceNodeDataRefresh = this.shouldForceNodeDataRefresh(deltaOptions, seriesStatus));\n    const majorChange = forceNodeDataRefresh || modulesChanged;\n    const updateType = majorChange ? 0 /* FULL */ : 3 /* PERFORM_LAYOUT */;\n    this.maybeResetAnimations(seriesStatus);\n    if (this.shouldClearLegendData(newOpts, oldOpts, seriesStatus)) {\n      this.ctx.legendManager.clearData();\n    }\n    this.applyInitialState(newOpts);\n    debug(\"Chart.applyOptions() - update type\", ChartUpdateType[updateType], {\n      seriesStatus,\n      forceNodeDataRefresh\n    });\n    this.update(updateType, { forceNodeDataRefresh, newAnimationBatch: true });\n    this.firstApply = false;\n  }\n  applyInitialState(options) {\n    const { annotationManager, chartTypeOriginator, historyManager, stateManager, zoomManager } = this.ctx;\n    const { initialState } = options;\n    if (\"annotations\" in options && options.annotations?.enabled && initialState?.annotations != null) {\n      const annotations = initialState.annotations.map((annotation) => {\n        const annotationTheme = annotationManager.getAnnotationTypeStyles(annotation.type);\n        return mergeDefaults(annotation, annotationTheme);\n      });\n      stateManager.setState(annotationManager, annotations);\n    }\n    if (initialState?.chartType != null) {\n      stateManager.setState(chartTypeOriginator, initialState.chartType);\n    }\n    if ((options.navigator?.enabled || options.zoom?.enabled) && initialState?.zoom != null) {\n      stateManager.setState(zoomManager, initialState.zoom);\n    }\n    if (initialState?.legend != null) {\n      this.updateLegends(initialState.legend);\n    }\n    if (initialState != null) {\n      historyManager.clear();\n    }\n  }\n  maybeResetAnimations(seriesStatus) {\n    if (this.mode !== \"standalone\")\n      return;\n    switch (seriesStatus) {\n      case \"series-grouping-change\":\n      case \"replaced\":\n        this.resetAnimations();\n        break;\n      default:\n    }\n  }\n  shouldForceNodeDataRefresh(deltaOptions, seriesStatus) {\n    const seriesDataUpdate = !!deltaOptions.data || seriesStatus === \"data-change\" || seriesStatus === \"replaced\";\n    const legendKeys = legendRegistry.getKeys();\n    const optionsHaveLegend = Object.values(legendKeys).some(\n      (legendKey) => deltaOptions[legendKey] != null\n    );\n    const otherRefreshUpdate = deltaOptions.title != null && deltaOptions.subtitle != null;\n    return seriesDataUpdate || optionsHaveLegend || otherRefreshUpdate;\n  }\n  shouldClearLegendData(options, oldOpts, seriesStatus) {\n    const seriesChanged = seriesStatus === \"replaced\" || seriesStatus === \"series-grouping-change\" || seriesStatus === \"updated\";\n    const legendRemoved = oldOpts.legend != null && options.legend == null;\n    return seriesChanged || legendRemoved;\n  }\n  applyMiniChartOptions(miniChart, miniChartSeries, completeOptions, oldOpts) {\n    const oldSeries = oldOpts?.navigator?.miniChart?.series ?? oldOpts?.series;\n    const miniChartSeriesStatus = this.applySeries(\n      miniChart,\n      this.filterMiniChartSeries(miniChartSeries),\n      this.filterMiniChartSeries(oldSeries)\n    );\n    this.applyAxes(miniChart, completeOptions, oldOpts, miniChartSeriesStatus, [\n      \"axes[].tick\",\n      \"axes[].thickness\",\n      \"axes[].title\",\n      \"axes[].crosshair\",\n      \"axes[].gridLine\",\n      \"axes[].label\"\n    ]);\n    const series = miniChart.series;\n    for (const s of series) {\n      s.properties.id = void 0;\n    }\n    const axes = miniChart.axes;\n    const horizontalAxis = axes.find((axis) => axis.direction === \"x\" /* X */);\n    for (const axis of axes) {\n      axis.nice = false;\n      axis.gridLine.enabled = false;\n      axis.label.enabled = axis === horizontalAxis;\n      axis.tick.enabled = false;\n      axis.interactionEnabled = false;\n    }\n    if (horizontalAxis != null) {\n      const miniChartOpts = completeOptions.navigator?.miniChart;\n      const labelOptions = miniChartOpts?.label;\n      const intervalOptions = miniChartOpts?.label?.interval;\n      horizontalAxis.line.enabled = false;\n      horizontalAxis.label.set(\n        without(labelOptions, [\"interval\", \"rotation\", \"minSpacing\", \"autoRotate\", \"autoRotateAngle\"])\n      );\n      horizontalAxis.tick.set(\n        without(intervalOptions, [\"enabled\", \"width\", \"size\", \"color\", \"interval\", \"step\"])\n      );\n      if (horizontalAxis.type === \"grouped-category\") {\n        horizontalAxis.label.enabled = false;\n        horizontalAxis.label.rotation = 0;\n        const { depthOptions } = horizontalAxis;\n        if (depthOptions.length === 0) {\n          depthOptions.set([{ label: { enabled: true } }]);\n        } else {\n          for (let i = 1; i < depthOptions.length; i++) {\n            depthOptions[i].label.enabled = false;\n          }\n        }\n      }\n      const step = intervalOptions?.step;\n      if (step != null) {\n        horizontalAxis.interval.step = step;\n      }\n    }\n  }\n  applyModules(options) {\n    const { type: chartType } = this.constructor;\n    let modulesChanged = false;\n    for (const module of moduleRegistry.byType(\"root\", \"legend\")) {\n      const isConfigured = options[module.optionsKey] != null;\n      const shouldBeEnabled = isConfigured && module.chartTypes.includes(chartType);\n      if (shouldBeEnabled === this.modulesManager.isEnabled(module))\n        continue;\n      if (shouldBeEnabled) {\n        this.modulesManager.addModule(module, (m) => m.moduleFactory(this.getModuleContext()));\n        if (module.type === \"legend\") {\n          this.modulesManager.getModule(module)?.attachLegend(this.ctx.scene);\n        }\n        this[module.optionsKey] = this.modulesManager.getModule(module);\n      } else {\n        this.modulesManager.removeModule(module);\n        delete this[module.optionsKey];\n      }\n      modulesChanged = true;\n    }\n    return modulesChanged;\n  }\n  initSeriesDeclarationOrder(series) {\n    for (let idx = 0; idx < series.length; idx++) {\n      series[idx].setSeriesIndex(idx);\n    }\n  }\n  applySeries(chart, optSeries, oldOptSeries) {\n    if (!optSeries) {\n      return \"no-change\";\n    }\n    const matchResult = matchSeriesOptions(chart.series, optSeries, oldOptSeries);\n    if (matchResult.status === \"no-overlap\") {\n      debug(`Chart.applySeries() - creating new series instances, status: ${matchResult.status}`, matchResult);\n      const chartSeries = optSeries.map((opts) => this.createSeries(opts));\n      this.initSeriesDeclarationOrder(chartSeries);\n      chart.series = chartSeries;\n      return \"replaced\";\n    }\n    debug(`Chart.applySeries() - matchResult`, matchResult);\n    const seriesInstances = [];\n    let dataChanged = false;\n    let groupingChanged = false;\n    let isUpdated = false;\n    const changes = matchResult.changes.toSorted((a, b) => a.targetIdx - b.targetIdx);\n    for (const change of changes) {\n      groupingChanged || (groupingChanged = change.status === \"series-grouping\");\n      dataChanged || (dataChanged = change.diff?.data != null);\n      isUpdated || (isUpdated = change.status !== \"no-op\");\n      switch (change.status) {\n        case \"add\": {\n          const newSeries = this.createSeries(change.opts);\n          seriesInstances.push(newSeries);\n          debug(`Chart.applySeries() - created new series`, newSeries);\n          break;\n        }\n        case \"remove\":\n          debug(`Chart.applySeries() - removing series at previous idx ${change.idx}`, change.series);\n          break;\n        case \"no-op\":\n          seriesInstances.push(change.series);\n          debug(`Chart.applySeries() - no change to series at previous idx ${change.idx}`, change.series);\n          break;\n        case \"series-grouping\":\n        case \"update\":\n        default: {\n          const { series, diff: diff2, idx } = change;\n          debug(`Chart.applySeries() - applying series diff previous idx ${idx}`, diff2, series);\n          this.applySeriesValues(series, diff2);\n          series.markNodeDataDirty();\n          seriesInstances.push(series);\n        }\n      }\n    }\n    this.initSeriesDeclarationOrder(seriesInstances);\n    debug(`Chart.applySeries() - final series instances`, seriesInstances);\n    chart.series = seriesInstances;\n    if (groupingChanged) {\n      return \"series-grouping-change\";\n    }\n    if (dataChanged) {\n      return \"data-change\";\n    }\n    return isUpdated ? \"updated\" : \"no-op\";\n  }\n  applyAxes(chart, options, oldOpts, seriesStatus, skip = []) {\n    if (!(\"axes\" in options) || !options.axes) {\n      return false;\n    }\n    skip = [\"axes[].type\", ...skip];\n    const { axes } = options;\n    const forceRecreate = seriesStatus === \"replaced\";\n    const matchingTypes = !forceRecreate && chart.axes.length === axes.length && chart.axes.every((a, i) => a.type === axes[i].type);\n    if (matchingTypes && isAgCartesianChartOptions(oldOpts)) {\n      chart.axes.forEach((axis, index) => {\n        const previousOpts = oldOpts.axes?.[index] ?? {};\n        const axisDiff = jsonDiff(previousOpts, axes[index]);\n        debug(`Chart.applyAxes() - applying axis diff idx ${index}`, axisDiff);\n        const path = `axes[${index}]`;\n        jsonApply(axis, axisDiff, { path, skip });\n      });\n      return true;\n    }\n    debug(`Chart.applyAxes() - creating new axes instances; seriesStatus: ${seriesStatus}`);\n    chart.axes = this.createAxis(axes, skip);\n    return true;\n  }\n  createSeries(seriesOptions) {\n    const seriesInstance = seriesRegistry.create(seriesOptions.type, this.getModuleContext());\n    this.applySeriesOptionModules(seriesInstance, seriesOptions);\n    this.applySeriesValues(seriesInstance, seriesOptions);\n    return seriesInstance;\n  }\n  applySeriesOptionModules(series, options) {\n    const moduleContext = series.createModuleContext();\n    const moduleMap = series.getModuleMap();\n    for (const module of moduleRegistry.byType(\"series-option\")) {\n      if (module.optionsKey in options && module.seriesTypes.includes(series.type)) {\n        moduleMap.addModule(module, (m) => m.moduleFactory(moduleContext));\n      }\n    }\n  }\n  applySeriesValues(target, options) {\n    const moduleMap = target.getModuleMap();\n    const { type: _, data, listeners, seriesGrouping, showInMiniChart: __, ...seriesOptions } = options;\n    for (const moduleDef of EXPECTED_ENTERPRISE_MODULES) {\n      if (moduleDef.type !== \"series-option\")\n        continue;\n      if (moduleDef.optionsKey in seriesOptions) {\n        const module = moduleMap.getModule(moduleDef.optionsKey);\n        if (module) {\n          const moduleOptions = seriesOptions[moduleDef.optionsKey];\n          delete seriesOptions[moduleDef.optionsKey];\n          module.properties.set(moduleOptions);\n        }\n      }\n    }\n    target.properties.set(seriesOptions);\n    if (\"data\" in options) {\n      target.setOptionsData(data);\n    }\n    if (listeners) {\n      this.registerListeners(target, listeners);\n    }\n    if (\"seriesGrouping\" in options) {\n      if (seriesGrouping == null) {\n        target.seriesGrouping = void 0;\n      } else {\n        target.seriesGrouping = { ...target.seriesGrouping, ...seriesGrouping };\n      }\n    }\n  }\n  createAxis(options, skip) {\n    const newAxes = [];\n    const moduleContext = this.getModuleContext();\n    for (let index = 0; index < options.length; index++) {\n      const axisOptions = options[index];\n      const axis = axisRegistry.create(axisOptions.type, moduleContext);\n      this.applyAxisModules(axis, axisOptions);\n      jsonApply(axis, axisOptions, { path: `axes[${index}]`, skip });\n      newAxes.push(axis);\n    }\n    guessInvalidPositions(newAxes);\n    return newAxes;\n  }\n  applyAxisModules(axis, options) {\n    const moduleContext = axis.createModuleContext();\n    const moduleMap = axis.getModuleMap();\n    for (const module of moduleRegistry.byType(\"axis-option\")) {\n      const shouldBeEnabled = options[module.optionsKey] != null;\n      if (shouldBeEnabled === moduleMap.isEnabled(module))\n        continue;\n      if (shouldBeEnabled) {\n        moduleMap.addModule(module, (m) => m.moduleFactory(moduleContext));\n        axis[module.optionsKey] = moduleMap.getModule(module);\n      } else {\n        moduleMap.removeModule(module);\n        delete axis[module.optionsKey];\n      }\n    }\n  }\n  registerListeners(source, listeners) {\n    source.clearEventListeners();\n    for (const [property, listener] of Object.entries(listeners)) {\n      if (isFunction(listener)) {\n        source.addEventListener(property, listener);\n      }\n    }\n  }\n};\n_Chart.chartsInstances = /* @__PURE__ */ new WeakMap();\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      if (this.destroyed)\n        return;\n      this.ctx.domManager.setContainer(value);\n      _Chart.chartsInstances.set(value, this);\n    },\n    oldValue(value) {\n      _Chart.chartsInstances.delete(value);\n    }\n  })\n], _Chart.prototype, \"container\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"width option\", { inWidth: value });\n    }\n  })\n], _Chart.prototype, \"width\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"height option\", { inHeight: value });\n    }\n  })\n], _Chart.prototype, \"height\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"minWidth option\", { inMinWidth: value });\n    }\n  })\n], _Chart.prototype, \"minWidth\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"minHeight option\", { inMinHeight: value });\n    }\n  })\n], _Chart.prototype, \"minHeight\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"overrideDevicePixelRatio option\", { inOverrideDevicePixelRatio: value });\n    }\n  })\n], _Chart.prototype, \"overrideDevicePixelRatio\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"seriesArea\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"keyboard\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"touch\", 2);\n__decorateClass([\n  Validate(UNION([\"standalone\", \"integrated\"], \"a chart mode\"))\n], _Chart.prototype, \"mode\", 2);\n__decorateClass([\n  ProxyProperty(\"chartCaptions.title\")\n], _Chart.prototype, \"title\", 2);\n__decorateClass([\n  ProxyProperty(\"chartCaptions.subtitle\")\n], _Chart.prototype, \"subtitle\", 2);\n__decorateClass([\n  ProxyProperty(\"chartCaptions.footnote\")\n], _Chart.prototype, \"footnote\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], _Chart.prototype, \"suppressFieldDotNotation\", 2);\n__decorateClass([\n  ActionOnSet({\n    changeValue(newValue, oldValue) {\n      this.onAxisChange(newValue, oldValue);\n    }\n  })\n], _Chart.prototype, \"axes\", 2);\n__decorateClass([\n  ActionOnSet({\n    changeValue(newValue, oldValue) {\n      this.onSeriesChange(newValue, oldValue);\n    }\n  })\n], _Chart.prototype, \"series\", 2);\nvar Chart = _Chart;\n\n// packages/ag-charts-community/src/scale/logScale.ts\nvar logFunctions = {\n  2: (_base, x) => Math.log2(x),\n  [Math.E]: (_base, x) => Math.log(x),\n  10: (_base, x) => Math.log10(x)\n};\nvar DEFAULT_LOG = (base, x) => Math.log(x) / Math.log(base);\nfunction log2(base, domain, x) {\n  const start2 = Math.min(...domain);\n  const fn = logFunctions[base] ?? DEFAULT_LOG;\n  return start2 >= 0 ? fn(base, x) : -fn(base, -x);\n}\nvar powFunctions = {\n  [Math.E]: (_base, x) => Math.exp(x),\n  10: (_base, x) => x >= 0 ? 10 ** x : 1 / 10 ** -x\n};\nvar DEFAULT_POW = (base, x) => base ** x;\nfunction pow(base, domain, x) {\n  const start2 = Math.min(...domain);\n  const fn = powFunctions[base] ?? DEFAULT_POW;\n  return start2 >= 0 ? fn(base, x) : -fn(base, -x);\n}\nvar LogScale = class extends ContinuousScale {\n  constructor(d = [1, 10], r = [0, 1]) {\n    super(d, r);\n    this.type = \"log\";\n    // Handling <1 and crossing 0 cases is tricky, easiest solution is to default to clamping.\n    this.defaultClamp = true;\n    this.base = 10;\n    this.log = (x) => log2(this.base, this.domain, x);\n    this.pow = (x) => pow(this.base, this.domain, x);\n  }\n  toDomain(d) {\n    return d;\n  }\n  transform(x) {\n    const [min, max] = findMinMax(this.domain);\n    if (min >= 0 !== max >= 0)\n      return NaN;\n    return min >= 0 ? Math.log(x) : -Math.log(-x);\n  }\n  transformInvert(x) {\n    const [min, max] = findMinMax(this.domain);\n    if (min >= 0 !== max >= 0)\n      return NaN;\n    return min >= 0 ? Math.exp(x) : -Math.exp(-x);\n  }\n  niceDomain(_ticks, domain = this.domain) {\n    if (domain.length < 2)\n      return [];\n    const { base } = this;\n    const [d0, d1] = domain;\n    const roundStart = d0 > d1 ? Math.ceil : Math.floor;\n    const roundStop = d0 > d1 ? Math.floor : Math.ceil;\n    const n0 = pow(base, domain, roundStart(log2(base, domain, d0)));\n    const n1 = pow(base, domain, roundStop(log2(base, domain, d1)));\n    return [n0, n1];\n  }\n  ticks({ interval, tickCount = ContinuousScale.defaultTickCount }, domain = this.domain, visibleRange) {\n    if (!domain || domain.length < 2 || tickCount < 1) {\n      return [];\n    }\n    const base = this.base;\n    const [d0, d1] = domain;\n    const start2 = Math.min(d0, d1);\n    const stop = Math.max(d0, d1);\n    let p0 = this.log(start2);\n    let p1 = this.log(stop);\n    if (interval) {\n      const inBounds = (tick) => tick >= start2 && tick <= stop;\n      const step = Math.min(Math.abs(interval), Math.abs(p1 - p0));\n      const ticks2 = range(p0, p1, step).map(this.pow).filter(inBounds);\n      if (!isDenseInterval(ticks2.length, this.getPixelRange())) {\n        return ticks2;\n      }\n    }\n    if (!isInteger(base) || p1 - p0 >= tickCount) {\n      return createTicks(p0, p1, Math.min(p1 - p0, tickCount)).map(this.pow);\n    }\n    let ticks = [];\n    const isPositive = start2 > 0;\n    p0 = Math.floor(p0) - 1;\n    p1 = Math.round(p1) + 1;\n    const availableSpacing = findRangeExtent(this.range) / tickCount;\n    let lastTickPosition = Infinity;\n    for (let p = p0; p <= p1; p++) {\n      const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));\n      for (let k = 1; k < base; k++) {\n        const q = isPositive ? k : base - k + 1;\n        const t = this.pow(p) * q;\n        const tickPosition = this.convert(t);\n        const prevSpacing = Math.abs(lastTickPosition - tickPosition);\n        const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);\n        const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;\n        if (t >= start2 && t <= stop && (k === 1 || fits || ticks.length === 0)) {\n          ticks.push(t);\n          lastTickPosition = tickPosition;\n        }\n      }\n    }\n    ticks = filterVisibleTicks(ticks, isPositive, visibleRange);\n    return ticks;\n  }\n  tickFormatter({ specifier }) {\n    return specifier != null ? numberFormat(specifier) : String;\n  }\n  datumFormatter(params) {\n    return this.tickFormatter(params);\n  }\n};\n\n// packages/ag-charts-community/src/scene/util/quadtree.ts\nvar QuadtreeNearest = class {\n  constructor(capacity, maxdepth, boundary) {\n    this.root = new QuadtreeNodeNearest(capacity, maxdepth, boundary);\n  }\n  clear(boundary) {\n    this.root.clear(boundary);\n  }\n  addValue(hitTester, value) {\n    const elem = {\n      hitTester,\n      value,\n      distanceSquared: (x, y) => {\n        return hitTester.distanceSquared(x, y);\n      }\n    };\n    this.root.addElem(elem);\n  }\n  find(x, y) {\n    const arg = { best: { nearest: void 0, distanceSquared: Infinity } };\n    this.root.find(x, y, arg);\n    return arg.best;\n  }\n};\nvar QuadtreeSubdivisions = class {\n  constructor(nw, ne, sw, se) {\n    this.nw = nw;\n    this.ne = ne;\n    this.sw = sw;\n    this.se = se;\n  }\n  addElem(elem) {\n    this.nw.addElem(elem);\n    this.ne.addElem(elem);\n    this.sw.addElem(elem);\n    this.se.addElem(elem);\n  }\n  find(x, y, arg) {\n    this.nw.find(x, y, arg);\n    this.ne.find(x, y, arg);\n    this.sw.find(x, y, arg);\n    this.se.find(x, y, arg);\n  }\n};\nvar QuadtreeNode = class {\n  constructor(capacity, maxdepth, boundary) {\n    this.capacity = capacity;\n    this.maxdepth = maxdepth;\n    this.boundary = boundary ?? BBox.NaN;\n    this.elems = [];\n    this.subdivisions = void 0;\n  }\n  clear(boundary) {\n    this.elems.length = 0;\n    this.boundary = boundary;\n    this.subdivisions = void 0;\n  }\n  addElem(e) {\n    if (this.addCondition(e)) {\n      if (this.subdivisions === void 0) {\n        if (this.maxdepth === 0 || this.elems.length < this.capacity) {\n          this.elems.push(e);\n        } else {\n          this.subdivide(e);\n        }\n      } else {\n        this.subdivisions.addElem(e);\n      }\n    }\n  }\n  find(x, y, arg) {\n    if (this.findCondition(x, y, arg)) {\n      if (this.subdivisions === void 0) {\n        this.findAction(x, y, arg);\n      } else {\n        this.subdivisions.find(x, y, arg);\n      }\n    }\n  }\n  subdivide(newElem) {\n    this.subdivisions = this.makeSubdivisions();\n    for (const e of this.elems) {\n      this.subdivisions.addElem(e);\n    }\n    this.subdivisions.addElem(newElem);\n    this.elems.length = 0;\n  }\n  makeSubdivisions() {\n    const { x, y, width: width2, height: height2 } = this.boundary;\n    const { capacity } = this;\n    const depth = this.maxdepth - 1;\n    const halfWidth = width2 / 2;\n    const halfHeight = height2 / 2;\n    const nwBoundary = new BBox(x, y, halfWidth, halfHeight);\n    const neBoundary = new BBox(x + halfWidth, y, halfWidth, halfHeight);\n    const swBoundary = new BBox(x, y + halfHeight, halfWidth, halfHeight);\n    const seBoundary = new BBox(x + halfWidth, y + halfHeight, halfWidth, halfHeight);\n    return new QuadtreeSubdivisions(\n      this.child(capacity, depth, nwBoundary),\n      this.child(capacity, depth, neBoundary),\n      this.child(capacity, depth, swBoundary),\n      this.child(capacity, depth, seBoundary)\n    );\n  }\n};\nvar QuadtreeNodeNearest = class _QuadtreeNodeNearest extends QuadtreeNode {\n  addCondition(e) {\n    const { x, y } = e.hitTester.midPoint;\n    return this.boundary.containsPoint(x, y);\n  }\n  findCondition(x, y, arg) {\n    const { best } = arg;\n    return best.distanceSquared !== 0 && this.boundary.distanceSquared(x, y) < best.distanceSquared;\n  }\n  findAction(x, y, arg) {\n    const other = nearestSquared(x, y, this.elems, arg.best.distanceSquared);\n    if (other.nearest !== void 0 && other.distanceSquared < arg.best.distanceSquared) {\n      arg.best = other;\n    }\n  }\n  child(capacity, depth, boundary) {\n    return new _QuadtreeNodeNearest(capacity, depth, boundary);\n  }\n};\n\n// packages/ag-charts-community/src/scale/linearScale.ts\nvar LinearScale = class _LinearScale extends ContinuousScale {\n  constructor() {\n    super([0, 1], [0, 1]);\n    this.type = \"number\";\n  }\n  static getTickStep(start2, stop, ticks) {\n    const { interval, tickCount = ContinuousScale.defaultTickCount, minTickCount, maxTickCount } = ticks;\n    return interval ?? tickStep(start2, stop, tickCount, minTickCount, maxTickCount);\n  }\n  toDomain(d) {\n    return d;\n  }\n  ticks({ interval, tickCount = ContinuousScale.defaultTickCount, minTickCount, maxTickCount }, domain = this.domain, visibleRange) {\n    if (!domain || domain.length < 2 || tickCount < 1 || !domain.every(isFinite)) {\n      return [];\n    }\n    const [d0, d1] = domain;\n    if (interval) {\n      const step = Math.abs(interval);\n      if (!isDenseInterval((d1 - d0) / step, this.getPixelRange())) {\n        return range(d0, d1, step);\n      }\n    }\n    return createTicks(d0, d1, tickCount, minTickCount, maxTickCount, visibleRange);\n  }\n  niceDomain(ticks, domain = this.domain) {\n    if (domain.length < 2)\n      return [];\n    const { tickCount = ContinuousScale.defaultTickCount } = ticks;\n    let [start2, stop] = domain;\n    if (tickCount === 1) {\n      [start2, stop] = niceTicksDomain(start2, stop);\n    } else if (tickCount > 1) {\n      const roundStart = start2 > stop ? Math.ceil : Math.floor;\n      const roundStop = start2 > stop ? Math.floor : Math.ceil;\n      const maxAttempts = 4;\n      for (let i = 0; i < maxAttempts; i++) {\n        const prev0 = start2;\n        const prev1 = stop;\n        const step = _LinearScale.getTickStep(start2, stop, ticks);\n        const [d0, d1] = domain;\n        start2 = roundStart(d0 / step) * step;\n        stop = roundStop(d1 / step) * step;\n        if (start2 === prev0 && stop === prev1)\n          break;\n      }\n    }\n    return [start2, stop];\n  }\n  tickFormatter({ ticks: specifiedTicks, fractionDigits, specifier }) {\n    return specifier != null ? tickFormat(specifiedTicks, specifier) : (x) => formatValue(x, fractionDigits);\n  }\n  datumFormatter({ ticks: specifiedTicks, fractionDigits, specifier }) {\n    return specifier != null ? tickFormat(specifiedTicks, specifier) : (x) => formatValue(x, fractionDigits + 1);\n  }\n};\n\n// packages/ag-charts-community/src/util/extent.ts\nfunction extent(values) {\n  if (values.length === 0) {\n    return null;\n  }\n  let min = Infinity;\n  let max = -Infinity;\n  for (const n of values) {\n    const v = n instanceof Date ? n.getTime() : n;\n    if (typeof v !== \"number\")\n      continue;\n    if (v < min) {\n      min = v;\n    }\n    if (v > max) {\n      max = v;\n    }\n  }\n  const result = [min, max];\n  return result.every(isFinite) ? result : null;\n}\nfunction normalisedExtentWithMetadata(d, min, max) {\n  let clipped = false;\n  if (d.length > 2) {\n    d = extent(d) ?? [NaN, NaN];\n  }\n  if (!isNaN(min)) {\n    clipped || (clipped = min > d[0]);\n    d = [min, d[1]];\n  }\n  if (!isNaN(max)) {\n    clipped || (clipped = max < d[1]);\n    d = [d[0], max];\n  }\n  if (d[0] > d[1]) {\n    d = [];\n  }\n  return { extent: d, clipped };\n}\n\n// packages/ag-charts-community/src/chart/axis/numberAxis.ts\nvar NumberAxis = class extends CartesianAxis {\n  constructor(moduleCtx, scale2 = new LinearScale()) {\n    super(moduleCtx, scale2);\n    this.min = NaN;\n    this.max = NaN;\n  }\n  normaliseDataDomain(d) {\n    const { min, max } = this;\n    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);\n    return { domain: extent2, clipped };\n  }\n};\nNumberAxis.className = \"NumberAxis\";\nNumberAxis.type = \"number\";\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, LESS_THAN(\"max\"))),\n  Default(NaN)\n], NumberAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, GREATER_THAN(\"min\"))),\n  Default(NaN)\n], NumberAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/axis/timeAxis.ts\nvar TimeAxis = class extends CartesianAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new TimeScale());\n    this.min = void 0;\n    this.max = void 0;\n  }\n  normaliseDataDomain(d) {\n    let { min, max } = this;\n    let clipped = false;\n    if (typeof min === \"number\") {\n      min = new Date(min);\n    }\n    if (typeof max === \"number\") {\n      max = new Date(max);\n    }\n    if (d.length > 2) {\n      d = extent(d)?.map((x) => new Date(x)) ?? [];\n    }\n    if (min instanceof Date) {\n      clipped || (clipped = min > d[0]);\n      d = [min, d[1]];\n    }\n    if (max instanceof Date) {\n      clipped || (clipped = max < d[1]);\n      d = [d[0], max];\n    }\n    if (d[0] > d[1]) {\n      d = [];\n    }\n    return { domain: d, clipped };\n  }\n};\nTimeAxis.className = \"TimeAxis\";\nTimeAxis.type = \"time\";\n__decorateClass([\n  Validate(AND(DATE_OR_DATETIME_MS, LESS_THAN(\"max\")), { optional: true })\n], TimeAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(DATE_OR_DATETIME_MS, GREATER_THAN(\"min\")), { optional: true })\n], TimeAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/series/dataModelSeries.ts\nvar DataModelSeries = class extends Series {\n  constructor() {\n    super(...arguments);\n    this.clipFocusBox = true;\n  }\n  getScaleInformation({\n    xScale,\n    yScale\n  }) {\n    const isContinuousX = ContinuousScale.is(xScale);\n    const isContinuousY = ContinuousScale.is(yScale);\n    return { isContinuousX, isContinuousY, xScaleType: xScale?.type, yScaleType: yScale?.type };\n  }\n  getModulePropertyDefinitions() {\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    return this.moduleMap.mapModules((mod2) => mod2.getPropertyDefinitions(this.getScaleInformation({ xScale, yScale }))).flat();\n  }\n  // Request data, but with message dispatching to series-options (modules).\n  async requestDataModel(dataController, data, opts) {\n    opts.props.push(...this.getModulePropertyDefinitions());\n    const { dataModel, processedData } = await dataController.request(this.id, data ?? [], opts);\n    this.dataModel = dataModel;\n    this.processedData = processedData;\n    this.dispatch(\"data-processed\", { dataModel, processedData });\n    return { dataModel, processedData };\n  }\n  isProcessedDataAnimatable() {\n    const validationResults = this.processedData?.reduced?.animationValidation;\n    if (!validationResults) {\n      return true;\n    }\n    const { orderedKeys, uniqueKeys } = validationResults;\n    return orderedKeys && uniqueKeys;\n  }\n  checkProcessedDataAnimatable() {\n    if (!this.isProcessedDataAnimatable()) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  pickFocus(opts) {\n    const nodeData = this.getNodeData();\n    if (nodeData === void 0 || nodeData.length === 0) {\n      return;\n    }\n    const datumIndex = this.computeFocusDatumIndex(opts, nodeData);\n    if (datumIndex === void 0) {\n      return;\n    }\n    const { clipFocusBox } = this;\n    const datum = nodeData[datumIndex];\n    const derivedOpts = { ...opts, datumIndex };\n    const bounds = this.computeFocusBounds(derivedOpts);\n    if (bounds !== void 0) {\n      return { bounds, clipFocusBox, datum, datumIndex };\n    }\n  }\n  computeFocusDatumIndex(opts, nodeData) {\n    const isDatumEnabled = (datumIndex2) => {\n      const { missing = false, enabled = true, focusable = true } = nodeData[datumIndex2];\n      return !missing && enabled && focusable;\n    };\n    const searchBackward = (datumIndex2, delta3) => {\n      while (datumIndex2 >= 0 && !isDatumEnabled(datumIndex2)) {\n        datumIndex2 += delta3;\n      }\n      return datumIndex2 === -1 ? void 0 : datumIndex2;\n    };\n    const searchForward = (datumIndex2, delta3) => {\n      while (datumIndex2 < nodeData.length && !isDatumEnabled(datumIndex2)) {\n        datumIndex2 += delta3;\n      }\n      return datumIndex2 === nodeData.length ? void 0 : datumIndex2;\n    };\n    let datumIndex;\n    const clampedIndex = clamp(0, opts.datumIndex, nodeData.length - 1);\n    if (opts.datumIndexDelta < 0) {\n      datumIndex = searchBackward(clampedIndex, opts.datumIndexDelta);\n    } else if (opts.datumIndexDelta > 0) {\n      datumIndex = searchForward(clampedIndex, opts.datumIndexDelta);\n    } else {\n      datumIndex = searchForward(clampedIndex, 1) ?? searchBackward(clampedIndex, -1);\n    }\n    if (datumIndex === void 0) {\n      if (opts.datumIndexDelta === 0) {\n        return;\n      } else {\n        return opts.datumIndex - opts.datumIndexDelta;\n      }\n    } else {\n      return datumIndex;\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesProperties.ts\nvar SeriesItemHighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"rgba(255,255,255, 0.33)\";\n    this.stroke = `rgba(0, 0, 0, 0.4)`;\n    this.strokeWidth = 2;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"lineDashOffset\", 2);\nvar SeriesHighlightStyle = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesHighlightStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesHighlightStyle.prototype, \"dimOpacity\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesHighlightStyle.prototype, \"enabled\", 2);\nvar TextHighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.color = \"black\";\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], TextHighlightStyle.prototype, \"color\", 2);\nvar HighlightProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], HighlightProperties.prototype, \"enabled\", 2);\nvar HighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.item = new SeriesItemHighlightStyle();\n    this.series = new SeriesHighlightStyle();\n    this.text = new TextHighlightStyle();\n  }\n};\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"item\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"series\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"text\", 2);\nvar SeriesProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.visible = true;\n    this.focusPriority = Infinity;\n    this.showInLegend = true;\n    this.cursor = \"default\";\n    this.nodeClickRange = \"exact\";\n    this.highlight = new HighlightProperties();\n    this.highlightStyle = new HighlightStyle();\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], SeriesProperties.prototype, \"id\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesProperties.prototype, \"visible\", 2);\n__decorateClass([\n  Validate(REAL_NUMBER, { optional: true })\n], SeriesProperties.prototype, \"focusPriority\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesProperties.prototype, \"showInLegend\", 2);\n__decorateClass([\n  Validate(STRING)\n], SeriesProperties.prototype, \"cursor\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE)\n], SeriesProperties.prototype, \"nodeClickRange\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesProperties.prototype, \"highlight\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesProperties.prototype, \"highlightStyle\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/cartesianSeries.ts\nvar DEFAULT_CARTESIAN_DIRECTION_KEYS = {\n  [\"x\" /* X */]: [\"xKey\"],\n  [\"y\" /* Y */]: [\"yKey\"]\n};\nvar DEFAULT_CARTESIAN_DIRECTION_NAMES = {\n  [\"x\" /* X */]: [\"xName\"],\n  [\"y\" /* Y */]: [\"yName\"]\n};\nvar CartesianSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.xKey = series.properties.xKey;\n    this.yKey = series.properties.yKey;\n  }\n};\nvar CartesianSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.pickOutsideVisibleMinorAxis = false;\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], CartesianSeriesProperties.prototype, \"legendItemName\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianSeriesProperties.prototype, \"pickOutsideVisibleMinorAxis\", 2);\nvar RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD = 100;\nvar CartesianSeries = class extends DataModelSeries {\n  constructor({\n    pathsPerSeries = [\"path\"],\n    hasMarkers = false,\n    hasHighlightedLabels = false,\n    pathsZIndexSubOrderOffset = [],\n    datumSelectionGarbageCollection = true,\n    markerSelectionGarbageCollection = true,\n    animationAlwaysUpdateSelections = false,\n    animationResetFns,\n    directionKeys,\n    directionNames,\n    ...otherOpts\n  }) {\n    super({\n      directionKeys,\n      directionNames,\n      canHaveAxes: true,\n      ...otherOpts\n    });\n    this.NodeEvent = CartesianSeriesNodeEvent;\n    this.dataNodeGroup = this.contentGroup.appendChild(\n      new Group({ name: `${this.id}-series-dataNodes`, zIndex: 0 })\n    );\n    this.markerGroup = this.contentGroup.appendChild(\n      new Group({ name: `${this.id}-series-markers`, zIndex: 1 })\n    );\n    this.labelGroup = this.contentGroup.appendChild(\n      new TranslatableGroup({ name: `${this.id}-series-labels` })\n    );\n    this.labelSelection = Selection.select(this.labelGroup, Text);\n    this.highlightSelection = Selection.select(\n      this.highlightNode,\n      () => this.opts.hasMarkers ? new Marker() : this.nodeFactory()\n    );\n    this.highlightLabelSelection = Selection.select(this.highlightLabel, Text);\n    this.annotationSelections = /* @__PURE__ */ new Set();\n    this.debug = Debug.create();\n    if (!directionKeys || !directionNames)\n      throw new Error(`Unable to initialise series type ${this.type}`);\n    this.opts = {\n      pathsPerSeries,\n      hasMarkers,\n      hasHighlightedLabels,\n      pathsZIndexSubOrderOffset,\n      directionKeys,\n      directionNames,\n      animationResetFns,\n      animationAlwaysUpdateSelections,\n      datumSelectionGarbageCollection,\n      markerSelectionGarbageCollection\n    };\n    this.paths = pathsPerSeries.map((path) => {\n      return new Path({ name: `${this.id}-${path}` });\n    });\n    this.datumSelection = Selection.select(\n      this.dataNodeGroup,\n      () => this.nodeFactory(),\n      datumSelectionGarbageCollection\n    );\n    this.markerSelection = Selection.select(this.markerGroup, Marker, markerSelectionGarbageCollection);\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => {\n              if (this.ctx.animationManager.isSkipped()) {\n                this.resetAllAnimation(data);\n              } else {\n                this.animateWaitingUpdateReady(data);\n              }\n            }\n          },\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        disabled: {\n          update: (data) => this.resetAllAnimation(data),\n          reset: \"empty\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  get contextNodeData() {\n    return this._contextNodeData;\n  }\n  getNodeData() {\n    return this.contextNodeData?.nodeData;\n  }\n  attachSeries(seriesContentNode, seriesNode, annotationNode) {\n    super.attachSeries(seriesContentNode, seriesNode, annotationNode);\n    this.attachPaths(this.paths, seriesNode, annotationNode);\n  }\n  detachSeries(seriesContentNode, seriesNode, annotationNode) {\n    super.detachSeries(seriesContentNode, seriesNode, annotationNode);\n    this.detachPaths(this.paths, seriesNode, annotationNode);\n  }\n  attachPaths(paths, _seriesNode, _annotationNode) {\n    for (const path of paths) {\n      this.contentGroup.appendChild(path);\n    }\n  }\n  detachPaths(paths, _seriesNode, _annotationNode) {\n    for (const path of paths) {\n      this.contentGroup.removeChild(path);\n    }\n  }\n  renderToOffscreenCanvas() {\n    const nodeData = this.getNodeData();\n    return nodeData != null && nodeData.length > RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    } else if (phase === \"disabled\") {\n      this.animationState.transition(\"disable\");\n    }\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event)),\n      this.ctx.chartEventManager.addListener(\n        \"legend-item-double-click\",\n        (event) => this.onLegendItemDoubleClick(event)\n      )\n    );\n  }\n  destroy() {\n    super.destroy();\n    this._contextNodeData = void 0;\n  }\n  update({ seriesRect }) {\n    const { visible, _contextNodeData: previousContextData } = this;\n    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;\n    const seriesHighlighted = series === this;\n    const resize = this.checkResize(seriesRect);\n    const highlightItems = this.updateHighlightSelection(seriesHighlighted);\n    this.updateSelections(visible);\n    this.updateNodes(highlightItems, seriesHighlighted, visible);\n    const animationData = this.getAnimationData(seriesRect, previousContextData);\n    if (!animationData)\n      return;\n    if (resize) {\n      this.animationState.transition(\"resize\", animationData);\n    }\n    this.animationState.transition(\"update\", animationData);\n  }\n  updateSelections(anySeriesItemEnabled) {\n    var _a;\n    const animationSkipUpdate = !this.opts.animationAlwaysUpdateSelections && this.ctx.animationManager.isSkipped();\n    if (!anySeriesItemEnabled && animationSkipUpdate) {\n      return;\n    }\n    if (!this.nodeDataRefresh && !this.isPathOrSelectionDirty()) {\n      return;\n    }\n    if (this.nodeDataRefresh) {\n      this.nodeDataRefresh = false;\n      this.debug(`CartesianSeries.updateSelections() - calling createNodeData() for`, this.id);\n      this.markQuadtreeDirty();\n      this._contextNodeData = this.createNodeData();\n      const animationValid = this.isProcessedDataAnimatable();\n      if (this._contextNodeData) {\n        (_a = this._contextNodeData).animationValid ?? (_a.animationValid = animationValid);\n      }\n      const { dataModel, processedData } = this;\n      if (dataModel !== void 0 && processedData !== void 0) {\n        this.dispatch(\"data-update\", { dataModel, processedData });\n      }\n    }\n    this.updateSeriesSelections();\n  }\n  updateSeriesSelections(seriesHighlighted) {\n    const { datumSelection, labelSelection, markerSelection, paths } = this;\n    const contextData = this._contextNodeData;\n    if (!contextData)\n      return;\n    const { nodeData, labelData, itemId } = contextData;\n    this.updatePaths({ seriesHighlighted, itemId, contextData, paths });\n    this.datumSelection = this.updateDatumSelection({ nodeData, datumSelection });\n    this.labelSelection = this.updateLabelSelection({ labelData, labelSelection }) ?? labelSelection;\n    if (this.opts.hasMarkers) {\n      this.markerSelection = this.updateMarkerSelection({ nodeData, markerSelection });\n    }\n  }\n  updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {\n    const {\n      highlightSelection,\n      highlightLabelSelection,\n      opts: { hasMarkers, hasHighlightedLabels }\n    } = this;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const visible = this.visible && this._contextNodeData != null && anySeriesItemEnabled;\n    this.contentGroup.visible = animationEnabled || visible;\n    this.highlightGroup.visible = (animationEnabled || visible) && seriesHighlighted;\n    const opacity = this.getOpacity();\n    if (hasMarkers) {\n      this.updateMarkerNodes({\n        markerSelection: highlightSelection,\n        isHighlight: true\n      });\n      this.animationState.transition(\"highlightMarkers\", highlightSelection);\n    } else {\n      this.updateDatumNodes({\n        datumSelection: highlightSelection,\n        isHighlight: true\n      });\n      this.animationState.transition(\"highlight\", highlightSelection);\n    }\n    if (hasHighlightedLabels) {\n      this.updateLabelNodes({ labelSelection: highlightLabelSelection });\n    }\n    const { dataNodeGroup, markerGroup, datumSelection, labelSelection, markerSelection, paths, labelGroup } = this;\n    const { itemId } = this.contextNodeData ?? {};\n    dataNodeGroup.opacity = opacity;\n    dataNodeGroup.visible = animationEnabled || visible;\n    labelGroup.visible = visible;\n    if (hasMarkers) {\n      markerGroup.opacity = opacity;\n      markerGroup.visible = visible;\n    }\n    if (labelGroup) {\n      labelGroup.opacity = opacity;\n    }\n    this.updatePathNodes({\n      seriesHighlighted,\n      itemId,\n      paths,\n      opacity,\n      visible,\n      animationEnabled\n    });\n    if (!dataNodeGroup.visible) {\n      return;\n    }\n    this.updateDatumNodes({ datumSelection, highlightedItems, isHighlight: false });\n    if (!this.usesPlacedLabels) {\n      this.updateLabelNodes({ labelSelection });\n    }\n    if (hasMarkers) {\n      this.updateMarkerNodes({ markerSelection, isHighlight: false });\n    }\n  }\n  getHighlightLabelData(labelData, highlightedItem) {\n    const labelItems = labelData.filter(\n      (ld) => ld.datum === highlightedItem.datum && ld.itemId === highlightedItem.itemId\n    );\n    return labelItems.length === 0 ? void 0 : labelItems;\n  }\n  getHighlightData(_nodeData, highlightedItem) {\n    return highlightedItem ? [highlightedItem] : void 0;\n  }\n  updateHighlightSelection(seriesHighlighted) {\n    const { highlightSelection, highlightLabelSelection, _contextNodeData: contextNodeData } = this;\n    if (!contextNodeData)\n      return;\n    const highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();\n    const item = seriesHighlighted && highlightedDatum?.datum ? highlightedDatum : void 0;\n    let labelItems;\n    let highlightItems;\n    if (item != null) {\n      const labelsEnabled = this.isLabelEnabled();\n      const { labelData, nodeData } = contextNodeData;\n      highlightItems = this.getHighlightData(nodeData, item);\n      labelItems = labelsEnabled ? this.getHighlightLabelData(labelData, item) : void 0;\n    }\n    this.highlightSelection = this.updateHighlightSelectionItem({\n      items: highlightItems,\n      highlightSelection\n    });\n    this.highlightLabelSelection = this.updateHighlightSelectionLabel({\n      items: labelItems,\n      highlightLabelSelection\n    });\n    return highlightItems;\n  }\n  markQuadtreeDirty() {\n    this.quadtree = void 0;\n  }\n  *datumNodesIter() {\n    for (const { node } of this.datumSelection) {\n      if (node.datum.missing === true)\n        continue;\n      yield node;\n    }\n  }\n  getQuadTree() {\n    if (this.quadtree === void 0) {\n      const { width: width2, height: height2 } = this.ctx.scene.canvas;\n      const canvasRect = new BBox(0, 0, width2, height2);\n      this.quadtree = new QuadtreeNearest(100, 10, canvasRect);\n      this.initQuadTree(this.quadtree);\n    }\n    return this.quadtree;\n  }\n  initQuadTree(_quadtree) {\n  }\n  pickNodeExactShape(point) {\n    const result = super.pickNodeExactShape(point);\n    if (result) {\n      return result;\n    }\n    const { x, y } = point;\n    const {\n      opts: { hasMarkers }\n    } = this;\n    let match;\n    const { dataNodeGroup, markerGroup } = this;\n    match = dataNodeGroup.pickNode(x, y);\n    if (!match && hasMarkers) {\n      match = markerGroup?.pickNode(x, y);\n    }\n    if (match && match.datum.missing !== true) {\n      return { datum: match.datum, distance: 0 };\n    }\n    for (const mod2 of this.moduleMap.modules()) {\n      const { datum } = mod2.pickNodeExact(point) ?? {};\n      if (datum == null)\n        continue;\n      if (datum?.missing === true)\n        continue;\n      return { datum, distance: 0 };\n    }\n  }\n  pickNodeClosestDatum(point) {\n    const { x, y } = point;\n    const { axes, _contextNodeData: contextNodeData } = this;\n    if (!contextNodeData)\n      return;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const hitPoint = { x, y };\n    let minDistance = Infinity;\n    let closestDatum;\n    for (const datum of contextNodeData.nodeData) {\n      const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;\n      if (isNaN(datumX) || isNaN(datumY)) {\n        continue;\n      }\n      const isInRange = xAxis?.inRange(datumX) && yAxis?.inRange(datumY);\n      if (!isInRange) {\n        continue;\n      }\n      const distance2 = Math.max((hitPoint.x - datumX) ** 2 + (hitPoint.y - datumY) ** 2, 0);\n      if (distance2 < minDistance) {\n        minDistance = distance2;\n        closestDatum = datum;\n      }\n    }\n    for (const mod2 of this.moduleMap.modules()) {\n      const modPick = mod2.pickNodeNearest(point);\n      if (modPick !== void 0 && modPick.distanceSquared < minDistance) {\n        minDistance = modPick.distanceSquared;\n        closestDatum = modPick.datum;\n        break;\n      }\n    }\n    if (closestDatum) {\n      const distance2 = Math.max(Math.sqrt(minDistance) - (closestDatum.point?.size ?? 0), 0);\n      return { datum: closestDatum, distance: distance2 };\n    }\n  }\n  pickNodeMainAxisFirst(point, requireCategoryAxis) {\n    const { x, y } = point;\n    const { axes, _contextNodeData: contextNodeData } = this;\n    const { pickOutsideVisibleMinorAxis } = this.properties;\n    if (!contextNodeData)\n      return;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const directions2 = [xAxis, yAxis].filter(CategoryAxis.is).map((a) => a.direction);\n    if (requireCategoryAxis && directions2.length === 0)\n      return;\n    const [majorDirection = \"x\" /* X */] = directions2;\n    const hitPointCoords = [x, y];\n    if (majorDirection !== \"x\" /* X */)\n      hitPointCoords.reverse();\n    const minDistance = [Infinity, Infinity];\n    let closestDatum;\n    for (const datum of contextNodeData.nodeData) {\n      const { x: datumX = NaN, y: datumY = NaN } = datum.point ?? datum.midPoint ?? {};\n      if (isNaN(datumX) || isNaN(datumY) || datum.missing === true)\n        continue;\n      const visible = [xAxis?.inRange(datumX), yAxis?.inRange(datumY)];\n      if (majorDirection !== \"x\" /* X */) {\n        visible.reverse();\n      }\n      if (!visible[0] || !pickOutsideVisibleMinorAxis && !visible[1])\n        continue;\n      const datumPoint = [datumX, datumY];\n      if (majorDirection !== \"x\" /* X */) {\n        datumPoint.reverse();\n      }\n      let newMinDistance = true;\n      for (let i = 0; i < datumPoint.length; i++) {\n        const dist = Math.abs(datumPoint[i] - hitPointCoords[i]);\n        if (dist > minDistance[i]) {\n          newMinDistance = false;\n          break;\n        } else if (dist < minDistance[i]) {\n          minDistance[i] = dist;\n          minDistance.fill(Infinity, i + 1, minDistance.length);\n        }\n      }\n      if (newMinDistance) {\n        closestDatum = datum;\n      }\n    }\n    if (closestDatum) {\n      let closestDistanceSquared = Math.max(\n        minDistance[0] ** 2 + minDistance[1] ** 2 - (closestDatum.point?.size ?? 0),\n        0\n      );\n      for (const mod2 of this.moduleMap.modules()) {\n        const modPick = mod2.pickNodeMainAxisFirst(point);\n        if (modPick !== void 0 && modPick.distanceSquared < closestDistanceSquared) {\n          closestDatum = modPick.datum;\n          closestDistanceSquared = modPick.distanceSquared;\n          break;\n        }\n      }\n      return { datum: closestDatum, distance: Math.sqrt(closestDistanceSquared) };\n    }\n  }\n  isPathOrSelectionDirty() {\n    return false;\n  }\n  shouldFlipXY() {\n    return false;\n  }\n  // Workaround - it would be nice if this difference didn't exist\n  keysOrValues(xKey) {\n    const key = this.dataModel.resolveProcessedDataIndexById(this, xKey);\n    return this.processedData?.keys[key]?.get(this.id) ?? this.processedData?.columns[key] ?? [];\n  }\n  visibleRange(axisKey, visibleRange, indices) {\n    const xValues = this.keysOrValues(axisKey);\n    const pixelSize = 0;\n    return visibleRangeIndices(indices?.length ?? xValues.length, visibleRange, (topIndex) => {\n      const datumIndex = indices?.[topIndex] ?? topIndex;\n      return this.xCoordinateRange(xValues[datumIndex], pixelSize, datumIndex);\n    });\n  }\n  domainForVisibleRange(_direction, axisKeys, crossAxisKey, visibleRange, sorted, indices) {\n    const { processedData, dataModel } = this;\n    const [r0, r1] = visibleRange;\n    const crossAxisValues = this.keysOrValues(crossAxisKey);\n    if (sorted) {\n      const crossAxisRange = this.visibleRange(crossAxisKey, visibleRange, indices);\n      return dataModel.getDomainBetweenRange(this, axisKeys, crossAxisRange, processedData);\n    }\n    const allAxisValues = axisKeys.map((axisKey) => this.keysOrValues(axisKey));\n    let axisMin = Infinity;\n    let axisMax = -Infinity;\n    crossAxisValues.forEach((crossAxisValue, i) => {\n      const [x0, x1] = this.xCoordinateRange(crossAxisValue, 0, i);\n      if (x1 < r0 || x0 > r1)\n        return;\n      for (let j = 0; j < axisKeys.length; j++) {\n        const axisValue = allAxisValues[j][i];\n        axisMin = Math.min(axisMin, axisValue);\n        axisMax = Math.max(axisMax, axisValue);\n      }\n    });\n    if (axisMin > axisMax)\n      return [NaN, NaN];\n    return [axisMin, axisMax];\n  }\n  domainForClippedRange(direction, axisKeys, crossAxisKey, sorted) {\n    const { processedData, dataModel, axes } = this;\n    const crossDirection = direction === \"x\" /* X */ ? \"y\" /* Y */ : \"x\" /* X */;\n    const crossAxisRange = axisExtent(axes[crossDirection]);\n    if (!crossAxisRange) {\n      return axisKeys.flatMap((axisKey) => dataModel.getDomain(this, axisKey, \"value\", processedData));\n    }\n    const crossAxisValues = this.keysOrValues(crossAxisKey);\n    if (sorted) {\n      const crossRange = clippedRangeIndices(\n        crossAxisValues.length,\n        crossAxisRange,\n        (index) => crossAxisValues[index]\n      );\n      return dataModel.getDomainBetweenRange(this, axisKeys, crossRange, processedData);\n    }\n    const allAxisValues = axisKeys.map((axisKey) => this.keysOrValues(axisKey));\n    const range0 = crossAxisRange[0].valueOf();\n    const range1 = crossAxisRange[1].valueOf();\n    const axisValues = [];\n    crossAxisValues.forEach((crossAxisValue, i) => {\n      const c = crossAxisValue.valueOf();\n      if (c < range0 || c > range1)\n        return;\n      const values = allAxisValues.map((v) => v[i]);\n      if (c >= range0) {\n        axisValues.push(...values);\n      }\n      if (c <= range1) {\n        axisValues.push(...values);\n      }\n    });\n    return axisValues;\n  }\n  countVisibleItems(crossAxisKey, axisKeys, xVisibleRange, yVisibleRange, minVisibleItems) {\n    const { dataModel, processedData } = this;\n    if (!dataModel || !processedData)\n      return Infinity;\n    const crossValues = this.keysOrValues(crossAxisKey);\n    const allAxisValues = axisKeys.map((axisKey) => dataModel.resolveColumnById(this, axisKey, processedData));\n    const crossAxis = this.axes[\"x\" /* X */];\n    const axis = this.axes[\"y\" /* Y */];\n    const shouldFlipXY = this.shouldFlipXY();\n    const crossRange = crossAxis.range;\n    const range3 = axis.range;\n    const convert = (d, r, v) => {\n      return d[0] + (v - r[0]) / (r[1] - r[0]) * (d[1] - d[0]);\n    };\n    const crossMin = convert(crossRange, crossAxis.visibleRange, xVisibleRange[0]);\n    const crossMax = convert(crossRange, crossAxis.visibleRange, xVisibleRange[1]);\n    const axisMin = convert(range3, axis.visibleRange, shouldFlipXY ? yVisibleRange[0] : yVisibleRange[1]);\n    const axisMax = convert(range3, axis.visibleRange, shouldFlipXY ? yVisibleRange[1] : yVisibleRange[0]);\n    const startIndex = Math.round(\n      (xVisibleRange[0] + (xVisibleRange[1] - xVisibleRange[0]) / 2) * crossValues.length\n    );\n    const pixelSize = 0;\n    return countExpandingSearch(0, crossValues.length - 1, startIndex, minVisibleItems, (index) => {\n      let [x0, x1] = this.xCoordinateRange(crossValues[index], pixelSize, index);\n      let [y0, y1] = this.yCoordinateRange(\n        allAxisValues.map((axisValues) => axisValues[index]),\n        pixelSize,\n        index\n      );\n      if (!isFiniteNumber(x0) || !isFiniteNumber(x1) || !isFiniteNumber(y0) || !isFiniteNumber(y1)) {\n        return false;\n      }\n      if (shouldFlipXY)\n        [x0, x1, y0, y1] = [y0, y1, x0, x1];\n      return x0 >= crossMin && x1 <= crossMax && y0 >= axisMin && y1 <= axisMax;\n    });\n  }\n  updateHighlightSelectionItem(opts) {\n    const {\n      opts: { hasMarkers }\n    } = this;\n    const { items, highlightSelection } = opts;\n    const nodeData = items ?? [];\n    if (hasMarkers) {\n      const markerSelection = highlightSelection;\n      return this.updateMarkerSelection({ nodeData, markerSelection });\n    } else {\n      return this.updateDatumSelection({\n        nodeData,\n        datumSelection: highlightSelection\n      });\n    }\n  }\n  updateHighlightSelectionLabel(opts) {\n    return this.updateLabelSelection({\n      labelData: opts.items ?? [],\n      labelSelection: opts.highlightLabelSelection\n    });\n  }\n  updateDatumSelection(opts) {\n    return opts.datumSelection;\n  }\n  updateDatumNodes(_opts) {\n  }\n  updateMarkerSelection(opts) {\n    return opts.markerSelection;\n  }\n  updateMarkerNodes(_opts) {\n  }\n  updatePaths(opts) {\n    opts.paths.forEach((p) => p.visible = false);\n  }\n  updatePathNodes(opts) {\n    const { paths, opacity, visible } = opts;\n    for (const path of paths) {\n      path.opacity = opacity;\n      path.visible = visible;\n    }\n  }\n  resetPathAnimation(data) {\n    const { path } = this.opts?.animationResetFns ?? {};\n    if (path) {\n      data.paths.forEach((paths) => {\n        resetMotion([paths], path);\n      });\n    }\n  }\n  resetDatumAnimation(data) {\n    const { datum } = this.opts?.animationResetFns ?? {};\n    if (datum) {\n      resetMotion([data.datumSelection], datum);\n    }\n  }\n  resetLabelAnimation(data) {\n    const { label } = this.opts?.animationResetFns ?? {};\n    if (label) {\n      resetMotion([data.labelSelection], label);\n    }\n  }\n  resetMarkerAnimation(data) {\n    const { marker } = this.opts?.animationResetFns ?? {};\n    if (marker && this.opts.hasMarkers) {\n      resetMotion([data.markerSelection], marker);\n    }\n  }\n  resetAllAnimation(data) {\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    this.resetPathAnimation(data);\n    this.resetDatumAnimation(data);\n    this.resetLabelAnimation(data);\n    this.resetMarkerAnimation(data);\n    if (data.contextData?.animationValid === false) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  animateEmptyUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateWaitingUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateReadyHighlight(data) {\n    const { datum } = this.opts?.animationResetFns ?? {};\n    if (datum) {\n      resetMotion([data], datum);\n    }\n  }\n  animateReadyHighlightMarkers(data) {\n    const { marker } = this.opts?.animationResetFns ?? {};\n    if (marker) {\n      resetMotion([data], marker);\n    }\n  }\n  animateReadyResize(data) {\n    this.resetAllAnimation(data);\n  }\n  animateClearingUpdateEmpty(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  getAnimationData(seriesRect, previousContextData) {\n    const { _contextNodeData: contextData } = this;\n    if (!contextData)\n      return;\n    const animationData = {\n      datumSelection: this.datumSelection,\n      markerSelection: this.markerSelection,\n      labelSelection: this.labelSelection,\n      annotationSelections: [...this.annotationSelections],\n      contextData,\n      previousContextData,\n      paths: this.paths,\n      seriesRect\n    };\n    return animationData;\n  }\n  updateLabelSelection(opts) {\n    return opts.labelSelection;\n  }\n  getScaling(scale2) {\n    if (scale2 instanceof LogScale) {\n      const { range: range3, domain } = scale2;\n      return {\n        type: \"log\",\n        convert: (d) => scale2.convert(d),\n        domain: [domain[0], domain[1]],\n        range: [range3[0], range3[1]]\n      };\n    } else if (scale2 instanceof ContinuousScale) {\n      const { range: range3, domain } = scale2;\n      return {\n        type: \"continuous\",\n        domain: [domain[0], domain[1]],\n        range: [range3[0], range3[1]]\n      };\n    } else if (scale2 instanceof BandScale) {\n      const { domain } = scale2;\n      return {\n        type: \"category\",\n        domain,\n        inset: scale2.inset,\n        step: scale2.step\n      };\n    }\n  }\n  calculateScaling() {\n    const result = {};\n    for (const direction of Object.values(ChartAxisDirection)) {\n      const axis = this.axes[direction];\n      if (!axis)\n        continue;\n      const scalingResult = this.getScaling(axis.scale);\n      if (scalingResult != null) {\n        result[direction] = scalingResult;\n      }\n    }\n    return result;\n  }\n};\nfunction axisExtent(axis) {\n  let min;\n  let max;\n  if (axis instanceof NumberAxis && (Number.isFinite(axis.min) || Number.isFinite(axis.max))) {\n    min = Number.isFinite(axis.min) ? axis.min : void 0;\n    max = Number.isFinite(axis.max) ? axis.max : void 0;\n  } else if (axis instanceof TimeAxis && (axis.min != null || axis.max != null)) {\n    ({ min, max } = axis);\n  }\n  if (min == null && max == null)\n    return;\n  min ?? (min = -Infinity);\n  max ?? (max = Infinity);\n  return [min, max];\n}\nfunction clippedRangeIndices(length2, range3, xValue) {\n  const range0 = range3[0].valueOf();\n  const range1 = range3[1].valueOf();\n  const xMinIndex = findMinIndex(0, length2 - 1, (index) => {\n    const x = xValue(index)?.valueOf();\n    return !Number.isFinite(x) || x >= range0;\n  });\n  let xMaxIndex = findMaxIndex(0, length2 - 1, (index) => {\n    const x = xValue(index)?.valueOf();\n    return !Number.isFinite(x) || x <= range1;\n  });\n  if (xMinIndex == null || xMaxIndex == null)\n    return [0, 0];\n  xMaxIndex = Math.min(xMaxIndex + 1, length2);\n  return [xMinIndex, xMaxIndex];\n}\n\n// packages/ag-charts-community/src/chart/cartesianChart.ts\nvar directions = [\"top\", \"right\", \"bottom\", \"left\"];\nvar _CartesianChart = class _CartesianChart extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    // TODO should come from theme\n    /** Integrated Charts feature state - not used in Standalone Charts. */\n    this.paired = true;\n    this.lastUpdateClipRect = void 0;\n    this.lastLayoutWidth = NaN;\n    this.lastLayoutHeight = NaN;\n  }\n  onAxisChange(newValue, oldValue) {\n    super.onAxisChange(newValue, oldValue);\n    if (this.ctx != null) {\n      this.ctx.zoomManager.updateAxes(newValue);\n    }\n  }\n  destroySeries(series) {\n    super.destroySeries(series);\n    this.lastLayoutWidth = NaN;\n    this.lastLayoutHeight = NaN;\n  }\n  getChartType() {\n    return \"cartesian\";\n  }\n  setRootClipRects(clipRect) {\n    const { seriesRoot, annotationRoot } = this;\n    seriesRoot.setClipRect(clipRect);\n    annotationRoot.setClipRect(clipRect);\n  }\n  async processData() {\n    await super.processData();\n    for (const axis of this.axes) {\n      const syncedDomain = this.getSyncedDomain(axis);\n      if (syncedDomain != null) {\n        axis.setDomains(syncedDomain);\n      }\n    }\n    this.ctx.updateService.dispatchProcessData({ series: { shouldFlipXY: this.shouldFlipXY() } });\n  }\n  performLayout(ctx) {\n    const { seriesRoot, annotationRoot } = this;\n    const { clipSeries, seriesRect, visible } = this.updateAxes(ctx.layoutBox);\n    this.seriesRoot.visible = visible;\n    this.seriesRect = seriesRect;\n    this.animationRect = ctx.layoutBox;\n    const { x, y } = seriesRect;\n    if (ctx.width !== this.lastLayoutWidth || ctx.height !== this.lastLayoutHeight) {\n      for (const group of [seriesRoot, annotationRoot]) {\n        group.translationX = Math.floor(x);\n        group.translationY = Math.floor(y);\n      }\n    } else {\n      const { translationX, translationY } = seriesRoot;\n      staticFromToMotion(\n        this.id,\n        \"seriesRect\",\n        this.ctx.animationManager,\n        [seriesRoot, annotationRoot],\n        { translationX, translationY },\n        { translationX: Math.floor(x), translationY: Math.floor(y) },\n        { phase: \"update\" }\n      );\n    }\n    this.lastLayoutWidth = ctx.width;\n    this.lastLayoutHeight = ctx.height;\n    const seriesPaddedRect = seriesRect.clone().grow(this.seriesArea.padding);\n    const clipRect = this.seriesArea.clip || clipSeries ? seriesPaddedRect : void 0;\n    const { lastUpdateClipRect } = this;\n    this.lastUpdateClipRect = clipRect;\n    if (this.ctx.animationManager.isActive() && lastUpdateClipRect != null) {\n      this.ctx.animationManager.animate({\n        id: this.id,\n        groupId: \"clip-rect\",\n        phase: \"update\",\n        from: lastUpdateClipRect,\n        to: seriesPaddedRect,\n        onUpdate: (interpolatedClipRect) => this.setRootClipRects(interpolatedClipRect),\n        onComplete: () => this.setRootClipRects(clipRect)\n      });\n    } else {\n      this.setRootClipRects(clipRect);\n    }\n    this.ctx.layoutManager.emitLayoutComplete(ctx, {\n      axes: this.axes.map((axis) => axis.getLayoutState()),\n      series: {\n        visible,\n        rect: seriesRect,\n        paddedRect: seriesPaddedRect\n      },\n      clipSeries\n    });\n  }\n  updateAxes(layoutBox) {\n    const { clipSeries, seriesRect, overflows } = this.resolveAxesLayout(layoutBox);\n    for (const axis of this.axes) {\n      axis.update();\n      axis.setCrossLinesVisible(!overflows);\n      this.clipAxis(axis, seriesRect, layoutBox);\n    }\n    return { clipSeries, seriesRect, visible: !overflows };\n  }\n  // Iteratively try to resolve axis widths - since X axis width affects Y axis range,\n  // and vice-versa, we need to iteratively try and find a fit for the axes and their\n  // ticks/labels.\n  resolveAxesLayout(layoutBox) {\n    let newState;\n    let prevState;\n    let iterations = 0;\n    const maxIterations = 10;\n    do {\n      prevState = newState ?? this.getDefaultState();\n      newState = this.updateAxesPass(new Map(prevState.axisAreaWidths), layoutBox.clone());\n      if (iterations++ > maxIterations) {\n        logger_exports.warn(\"Max iterations reached. Unable to stabilize axes layout.\");\n        break;\n      }\n    } while (!this.isLayoutStable(newState, prevState));\n    this.lastAreaWidths = newState.axisAreaWidths;\n    return newState;\n  }\n  updateAxesPass(axisAreaWidths, axisAreaBound) {\n    const axisWidths = /* @__PURE__ */ new Map();\n    const primaryTickCounts = {};\n    let overflows = false;\n    let clipSeries = false;\n    for (const dir of directions) {\n      const padding = this.seriesArea.padding[dir];\n      const axis = this.axes.findLast((a) => a.position === dir);\n      if (axis) {\n        axis.seriesAreaPadding = padding;\n      } else {\n        axisAreaBound.shrink(padding, dir);\n      }\n    }\n    const totalWidth = (axisAreaWidths.get(\"left\") ?? 0) + (axisAreaWidths.get(\"right\") ?? 0);\n    const totalHeight = (axisAreaWidths.get(\"top\") ?? 0) + (axisAreaWidths.get(\"bottom\") ?? 0);\n    const crossLinePadding = this.buildCrossLinePadding(axisAreaWidths);\n    if (axisAreaBound.width <= totalWidth + crossLinePadding.hPadding || axisAreaBound.height <= totalHeight + crossLinePadding.vPadding) {\n      overflows = true;\n    } else {\n      axisAreaBound.shrink(crossLinePadding);\n    }\n    const seriesRect = axisAreaBound.clone().shrink(Object.fromEntries(axisAreaWidths));\n    for (const axis of this.axes) {\n      const { position = \"left\", direction } = axis;\n      this.sizeAxis(axis, seriesRect, position);\n      const isVertical = direction === \"y\" /* Y */;\n      const { primaryTickCount, bbox } = axis.calculateLayout(\n        axis.nice ? primaryTickCounts[direction] : void 0\n      );\n      primaryTickCounts[direction] ?? (primaryTickCounts[direction] = primaryTickCount);\n      clipSeries || (clipSeries = axis.dataDomain.clipped || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1);\n      axisWidths.set(axis.id, Math.ceil(axis.thickness ?? (isVertical ? bbox?.width : bbox?.height) ?? 0));\n    }\n    const axisGroups = Object.entries(groupBy(this.axes, (axis) => axis.position ?? \"left\"));\n    const { width: width2, height: height2, pixelRatio } = this.ctx.scene;\n    const newAxisAreaWidths = /* @__PURE__ */ new Map();\n    const axisOffsets = /* @__PURE__ */ new Map();\n    for (const [position, axes] of axisGroups) {\n      const isVertical = position === \"left\" || position === \"right\";\n      let currentOffset = isVertical ? height2 % pixelRatio : width2 % pixelRatio;\n      let totalAxisWidth = 0;\n      for (const axis of axes) {\n        axisOffsets.set(axis.id, currentOffset);\n        const axisThickness = axisWidths.get(axis.id) ?? 0;\n        totalAxisWidth = Math.max(totalAxisWidth, currentOffset + axisThickness);\n        if (axis.layoutConstraints.stacked) {\n          currentOffset += axisThickness + _CartesianChart.AxesPadding;\n        }\n      }\n      newAxisAreaWidths.set(position, Math.ceil(totalAxisWidth));\n    }\n    for (const [position, axes] of axisGroups) {\n      this.positionAxes({\n        axes,\n        position,\n        axisWidths,\n        axisOffsets,\n        axisAreaWidths: newAxisAreaWidths,\n        axisBound: axisAreaBound,\n        seriesRect\n      });\n    }\n    return { clipSeries, seriesRect, axisAreaWidths: newAxisAreaWidths, overflows };\n  }\n  buildCrossLinePadding(axisAreaSize) {\n    const crossLinePadding = { top: 0, right: 0, bottom: 0, left: 0, hPadding: 0, vPadding: 0 };\n    this.axes.forEach((axis) => {\n      axis.crossLines?.forEach((crossLine) => {\n        crossLine.calculatePadding?.(crossLinePadding);\n      });\n    });\n    for (const [side, padding = 0] of Object.entries(crossLinePadding)) {\n      crossLinePadding[side] = Math.max(padding - (axisAreaSize.get(side) ?? 0), 0);\n    }\n    crossLinePadding.hPadding = crossLinePadding.left + crossLinePadding.right;\n    crossLinePadding.vPadding = crossLinePadding.top + crossLinePadding.bottom;\n    return crossLinePadding;\n  }\n  clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {\n    const bound = dimension === \"x\" ? seriesRect.x : seriesRect.y;\n    const size = dimension === \"x\" ? seriesRect.width : seriesRect.height;\n    return direction === 1 ? Math.min(value, bound + size) : Math.max(value, bound);\n  }\n  getSyncedDomain(axis) {\n    const syncModule = this.modulesManager.getModule(\"sync\");\n    if (!syncModule?.enabled)\n      return;\n    const syncedDomain = syncModule.getSyncedDomain(axis);\n    if (syncedDomain && axis.dataDomain.domain.length) {\n      let shouldUpdate;\n      const { domain } = axis.scale;\n      if (ContinuousScale.is(axis.scale)) {\n        const [min, max] = findMinMax(syncedDomain);\n        shouldUpdate = min !== domain[0] || max !== domain[1];\n      } else {\n        shouldUpdate = !arraysEqual(syncedDomain, domain);\n      }\n      if (shouldUpdate && !this.skipSync) {\n        syncModule.updateSiblings();\n      }\n    }\n    return syncedDomain;\n  }\n  sizeAxis(axis, seriesRect, position) {\n    const isCategory = axis instanceof CategoryAxis;\n    const isLeftRight = position === \"left\" || position === \"right\";\n    const { width: width2, height: height2 } = seriesRect;\n    const maxEnd = isLeftRight ? height2 : width2;\n    let start2 = 0;\n    let end2 = maxEnd;\n    let { min, max } = this.ctx.zoomManager.getAxisZoom(axis.id);\n    const { width: axisWidth, unit, align: align2 } = axis.layoutConstraints;\n    if (unit === \"px\") {\n      end2 = start2 + axisWidth;\n    } else {\n      end2 = end2 * axisWidth / 100;\n    }\n    if (align2 === \"end\") {\n      start2 = maxEnd - (end2 - start2);\n      end2 = maxEnd;\n    }\n    if (isLeftRight) {\n      if (isCategory) {\n        [min, max] = [1 - max, 1 - min];\n      } else {\n        [start2, end2] = [end2, start2];\n      }\n    }\n    axis.range = [start2, end2];\n    axis.visibleRange = [min, max];\n    axis.gridLength = isLeftRight ? width2 : height2;\n  }\n  positionAxes(opts) {\n    const { axes, axisBound, axisWidths, axisOffsets, axisAreaWidths, seriesRect, position } = opts;\n    const axisAreaWidth = axisAreaWidths.get(position) ?? 0;\n    let mainDimension = \"x\";\n    let minorDimension = \"y\";\n    let direction = 1;\n    if (position === \"top\" || position === \"bottom\") {\n      mainDimension = \"y\";\n      minorDimension = \"x\";\n    }\n    let axisBoundMainOffset = axisBound[mainDimension];\n    if (position === \"right\" || position === \"bottom\") {\n      direction = -1;\n      axisBoundMainOffset += mainDimension === \"x\" ? axisBound.width : axisBound.height;\n    }\n    for (const axis of axes) {\n      const minorOffset = axisAreaWidths.get(minorDimension === \"x\" ? \"left\" : \"top\") ?? 0;\n      const axisThickness = axisWidths.get(axis.id) ?? 0;\n      const axisOffset = axisOffsets.get(axis.id) ?? 0;\n      axis.gridPadding = axisAreaWidth - axisOffset - axisThickness;\n      axis.translation[minorDimension] = axisBound[minorDimension] + minorOffset;\n      axis.translation[mainDimension] = this.clampToOutsideSeriesRect(\n        seriesRect,\n        axisBoundMainOffset + direction * (axisOffset + axisThickness),\n        mainDimension,\n        direction\n      );\n    }\n  }\n  shouldFlipXY() {\n    return this.series.every((series) => series instanceof CartesianSeries && series.shouldFlipXY());\n  }\n  getDefaultState() {\n    const axisAreaWidths = /* @__PURE__ */ new Map();\n    if (this.lastAreaWidths) {\n      for (const { position = \"left\" } of this.axes) {\n        const areaWidth = this.lastAreaWidths.get(position);\n        if (areaWidth != null) {\n          axisAreaWidths.set(position, areaWidth);\n        }\n      }\n    }\n    return { axisAreaWidths, clipSeries: false, overflows: false };\n  }\n  isLayoutStable(newState, prevState) {\n    if (prevState.overflows !== newState.overflows || prevState.clipSeries !== newState.clipSeries) {\n      return false;\n    }\n    for (const key of newState.axisAreaWidths.keys()) {\n      if (!prevState.axisAreaWidths.has(key)) {\n        return false;\n      }\n    }\n    for (const [p, w] of prevState.axisAreaWidths.entries()) {\n      const otherW = newState.axisAreaWidths.get(p);\n      if ((w != null || otherW != null) && w !== otherW) {\n        return false;\n      }\n    }\n    return true;\n  }\n  clipAxis(axis, seriesRect, layoutBBox) {\n    const gridLinePadding = Math.ceil(axis.gridLine?.width ?? 0);\n    const axisLinePadding = Math.ceil(axis.line?.width ?? 0);\n    let { width: width2, height: height2 } = seriesRect;\n    width2 += axis.direction === \"x\" /* X */ ? gridLinePadding : axisLinePadding;\n    height2 += axis.direction === \"y\" /* Y */ ? gridLinePadding : axisLinePadding;\n    axis.clipGrid(seriesRect.x, seriesRect.y, width2, height2);\n    switch (axis.position) {\n      case \"left\":\n      case \"right\":\n        axis.clipTickLines(\n          layoutBBox.x,\n          seriesRect.y - gridLinePadding,\n          layoutBBox.width + gridLinePadding,\n          seriesRect.height + gridLinePadding * 2\n        );\n        break;\n      case \"top\":\n      case \"bottom\":\n        axis.clipTickLines(\n          seriesRect.x - gridLinePadding,\n          layoutBBox.y,\n          seriesRect.width + gridLinePadding * 2,\n          layoutBBox.height + gridLinePadding\n        );\n        const { label, labelNodes, scale: scale2 } = axis;\n        if (ContinuousScale.is(scale2) && label.enabled && label.avoidCollisions && labelNodes.length > 1) {\n          const sortedLabels = labelNodes.toSorted((a, b) => a.translationY - b.translationY);\n          const lastLabel = sortedLabels.at(-1);\n          const lastLabelBBox = lastLabel.getBBox();\n          const lastLabelInBounds = seriesRect.x + lastLabelBBox.y + lastLabelBBox.height <= layoutBBox.x + layoutBBox.width + this.padding.right;\n          lastLabel.visible = lastLabelInBounds;\n          if (lastLabelInBounds || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1) {\n            sortedLabels[0].visible = true;\n          } else {\n            const firstLabelBBox = sortedLabels[0].getBBox();\n            sortedLabels[0].visible = firstLabelBBox.y >= 0;\n          }\n        }\n        break;\n    }\n  }\n};\n_CartesianChart.className = \"CartesianChart\";\n_CartesianChart.type = \"cartesian\";\n_CartesianChart.AxesPadding = 15;\nvar CartesianChart = _CartesianChart;\n\n// packages/ag-charts-community/src/chart/cartesianChartModule.ts\nvar CartesianChartModule = {\n  type: \"chart\",\n  name: \"cartesian\",\n  detect: isAgCartesianChartOptions,\n  create(options, resources) {\n    return new CartesianChart(options, resources);\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartProxy.ts\nvar debug2 = Debug.create(true, \"opts\");\nvar _AgChartInstanceProxy = class _AgChartInstanceProxy {\n  constructor(chart, factoryApi, licenseManager) {\n    this.factoryApi = factoryApi;\n    this.licenseManager = licenseManager;\n    this.chart = chart;\n  }\n  async update(options) {\n    return debug2.group(\"AgChartInstance.update()\", async () => {\n      this.factoryApi.update(options, this);\n      await this.chart.waitForUpdate();\n    });\n  }\n  async updateDelta(deltaOptions) {\n    return debug2.group(\"AgChartInstance.updateDelta()\", async () => {\n      this.factoryApi.updateUserDelta(this, deltaOptions);\n      await this.chart.waitForUpdate();\n    });\n  }\n  getOptions() {\n    const options = deepClone(this.chart.getOptions());\n    for (const key of Object.keys(options)) {\n      if (key.startsWith(\"_\")) {\n        delete options[key];\n      }\n    }\n    return options;\n  }\n  waitForUpdate() {\n    return this.chart.waitForUpdate();\n  }\n  async download(opts) {\n    const clone2 = await this.prepareResizedChart(this, opts);\n    try {\n      clone2.chart.download(opts?.fileName, opts?.fileFormat);\n    } finally {\n      clone2.destroy();\n    }\n  }\n  async __toSVG(opts) {\n    const clone2 = await this.prepareResizedChart(this, { width: 600, height: 300, ...opts });\n    try {\n      return clone2.chart.toSVG();\n    } finally {\n      clone2.destroy();\n    }\n  }\n  async getImageDataURL(opts) {\n    const clone2 = await this.prepareResizedChart(this, opts);\n    try {\n      return clone2.chart.getCanvasDataURL(opts?.fileFormat);\n    } finally {\n      clone2.destroy();\n    }\n  }\n  getState() {\n    return this.factoryApi.caretaker.save(...this.getEnabledOriginators());\n  }\n  async setState(state) {\n    const originators = this.getEnabledOriginators();\n    if (!originators.includes(this.chart.ctx.legendManager)) {\n      await this.setStateOriginators(state, originators);\n      return;\n    }\n    await this.setStateOriginators(\n      state,\n      originators.filter((originator) => originator !== this.chart.ctx.zoomManager)\n    );\n    await this.setStateOriginators(state, [this.chart.ctx.zoomManager]);\n  }\n  resetAnimations() {\n    this.chart.resetAnimations();\n  }\n  skipAnimations() {\n    this.chart.skipAnimations();\n  }\n  destroy() {\n    if (this.releaseChart) {\n      this.releaseChart();\n      this.releaseChart = void 0;\n    } else if (this.chart) {\n      this.chart.publicApi = void 0;\n      this.chart.destroy();\n    }\n    this.chart = null;\n  }\n  async prepareResizedChart(proxy, opts = {}) {\n    const { chart } = proxy;\n    const width2 = opts.width ?? chart.width ?? chart.ctx.scene.canvas.width;\n    const height2 = opts.height ?? chart.height ?? chart.ctx.scene.canvas.height;\n    const state = proxy.getState();\n    const isEnterprise = moduleRegistry.hasEnterpriseModules();\n    const processedOverrides = {\n      ...chart.chartOptions.processedOverrides,\n      container: document.createElement(\"div\"),\n      width: width2,\n      height: height2\n    };\n    if (opts.width != null && opts.height != null) {\n      processedOverrides.overrideDevicePixelRatio = 1;\n    }\n    const userOptions = chart.getOptions();\n    if (isEnterprise) {\n      processedOverrides.animation = { enabled: false };\n      if (this.licenseManager?.isDisplayWatermark()) {\n        processedOverrides.foreground = {\n          text: this.licenseManager.getWatermarkMessage(),\n          image: {\n            url: `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU4IiBoZWlnaHQ9IjQwIiB2aWV3Qm94PSIwIDAgMjU4IDQwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMjUuNzc5IDI4LjY1N0gxMy4zNTlMMTEuMTczIDM0LjAxMkg1LjY3Mjk3TDE3LjE4MiA3LjA1OTk5SDIxLjk1M0wzMy40NjIgMzQuMDEySDI3Ljk2MkwyNS43NzYgMjguNjU3SDI1Ljc3OVpNMjQuMDY4IDI0LjM5N0wxOS41ODggMTMuNDM0TDE1LjEwNyAyNC4zOTdIMjQuMDY4Wk02Mi4wOTIgMTguODIzSDQ5LjgxN1YyMy4wODZINTYuNzc1QzU2LjU1NSAyNS4yMjIgNTUuNzU1IDI2LjkyNyA1NC4zNzIgMjguMjAyQzUyLjk4OSAyOS40NzYgNTEuMTY2IDMwLjExNSA0OC45MDkgMzAuMTE1QzQ3LjYyMiAzMC4xMTUgNDYuNDUgMjkuODg1IDQ1LjM5MyAyOS40MjNDNDQuMzU4MyAyOC45NzgxIDQzLjQzMjYgMjguMzEzOCA0Mi42OCAyNy40NzZDNDEuOTI3IDI2LjYzOSA0MS4zNDQgMjUuNjMxIDQwLjkzMSAyNC40NTNDNDAuNTE5IDIzLjI3NSA0MC4zMTEgMjEuOTcgNDAuMzExIDIwLjUzN0M0MC4zMTEgMTkuMTA1IDQwLjUxNiAxNy44IDQwLjkzMSAxNi42MjFDNDEuMzQ0IDE1LjQ0MyA0MS45MjcgMTQuNDM2IDQyLjY4IDEzLjU5OEM0My40Mzc2IDEyLjc1NzcgNDQuMzY5NiAxMi4wOTMyIDQ1LjQxMSAxMS42NTFDNDYuNDc4IDExLjE4OSA0Ny42NTYgMTAuOTYgNDguOTQ2IDEwLjk2QzUxLjYxMiAxMC45NiA1My42MzcgMTEuNjAyIDU1LjAyIDEyLjg4NUw1OC4zIDkuNjA0OTlDNTUuODE3IDcuNjY5OTkgNTIuNjc2IDYuNjk5OTkgNDguODcyIDYuNjk5OTlDNDYuNzYgNi42OTk5OSA0NC44NTMgNy4wMzQ5OSA0My4xNTQgNy43MDA5OUM0MS40NTUgOC4zNjc5OSAzOS45OTggOS4zMDM5OSAzOC43ODMgMTAuNTA0QzM3LjU2NyAxMS43MDcgMzYuNjM0IDEzLjE1OCAzNS45NzcgMTQuODU3QzM1LjMxOSAxNi41NTYgMzQuOTk0IDE4LjQ1MSAzNC45OTQgMjAuNTRDMzQuOTk0IDIyLjYzIDM1LjMyOSAyNC40OTQgMzUuOTk1IDI2LjIwNUMzNi42NjIgMjcuOTE2IDM3LjYwNSAyOS4zNzQgMzguODE3IDMwLjU3N0M0MC4wMzIgMzEuNzggNDEuNDg2IDMyLjcxMyA0My4xODggMzMuMzgzQzQ0Ljg4OCAzNC4wNDkgNDYuNzgyIDM0LjM4NCA0OC44NzIgMzQuMzg0QzUwLjk2MSAzNC4zODQgNTIuNzUgMzQuMDQ5IDU0LjM5IDMzLjM4M0M1Ni4wMzEgMzIuNzE2IDU3LjQyNiAzMS43OCA1OC41NzkgMzAuNTc3QzU5LjczMyAyOS4zNzQgNjAuNjE5IDI3LjkxNiA2MS4yMzkgMjYuMjA1QzYxLjg2IDI0LjQ5NCA2Mi4xNyAyMi42MDUgNjIuMTcgMjAuNTRDNjIuMTY5NiAxOS45Njg4IDYyLjE0NDUgMTkuMzk4IDYyLjA5NSAxOC44MjlMNjIuMDkyIDE4LjgyM1pNMTUxLjgxIDE2Ljk4MUMxNTMuNDEgMTQuNjA5IDE1Ny40MTkgMTQuMzU4IDE1OS4wMjIgMTQuMzU4VjE4LjkxQzE1Ni45NTcgMTguOTEgMTU0Ljk4NSAxOC45OTYgMTUzLjc1NyAxOS44OTJDMTUyLjUyOSAyMC43OTIgMTUxLjkxOSAyMS45ODIgMTUxLjkxOSAyMy40NjRWMzMuOTlIMTQ2Ljk2NFYxNC4zNThIMTUxLjczNkwxNTEuODEgMTYuOTgxWk0xNDMuMDExIDE0LjM2MVYzNC4wMzFIMTM4LjI0TDEzOC4xMzEgMzEuMDQ1QzEzNy40NjYgMzIuMDc2IDEzNi41NTEgMzIuOTIxOSAxMzUuNDcxIDMzLjUwNEMxMzQuMzc2IDM0LjA5OSAxMzMuMDY4IDM0LjM5NiAxMzEuNTM2IDM0LjM5NkMxMzAuMiAzNC4zOTYgMTI4Ljk2MyAzNC4xNTIgMTI3LjgyMiAzMy42NjhDMTI2LjcgMzMuMTk2NCAxMjUuNjg5IDMyLjQ5NSAxMjQuODU1IDMxLjYwOUMxMjQuMDE4IDMwLjcyMiAxMjMuMzU0IDI5LjY2MiAxMjIuODcxIDI4LjQyMkMxMjIuMzg0IDI3LjE4NSAxMjIuMTQyIDI1LjgxMSAxMjIuMTQyIDI0LjMwNEMxMjIuMTQyIDIyLjc5OCAxMjIuMzg0IDIxLjM3OCAxMjIuODcxIDIwLjExNkMxMjMuMzU3IDE4Ljg1NCAxMjQuMDE4IDE3Ljc3MiAxMjQuODU1IDE2Ljg3M0MxMjUuNjg4IDE1Ljk3NjQgMTI2LjY5OCAxNS4yNjM2IDEyNy44MjIgMTQuNzhDMTI4Ljk2MyAxNC4yODEgMTMwLjIwMyAxNC4wMzMgMTMxLjUzNiAxNC4wMzNDMTMzLjA0MyAxNC4wMzMgMTM0LjMzIDE0LjMxOCAxMzUuMzk3IDE0Ljg4OEMxMzYuNDYyIDE1LjQ1ODkgMTM3LjM3NSAxNi4yNzggMTM4LjA1NyAxNy4yNzZWMTQuMzYxSDE0My4wMTFaTTEzMi42MzEgMzAuMTMzQzEzNC4yNTYgMzAuMTMzIDEzNS41NjcgMjkuNTk0IDEzNi41NjUgMjguNTEyQzEzNy41NjEgMjcuNDMgMTM4LjA2IDI1Ljk5MSAxMzguMDYgMjQuMTk2QzEzOC4wNiAyMi40MDEgMTM3LjU2MSAyMC45OSAxMzYuNTY1IDE5Ljg5OUMxMzUuNTcgMTguODA3IDEzNC4yNTkgMTguMjU4IDEzMi42MzEgMTguMjU4QzEzMS4wMDMgMTguMjU4IDEyOS43MjkgMTguODA0IDEyOC43MzQgMTkuODk5QzEyNy43MzggMjAuOTkzIDEyNy4yMzkgMjIuNDM4IDEyNy4yMzkgMjQuMjMzQzEyNy4yMzkgMjYuMDI4IDEyNy43MzUgMjcuNDMzIDEyOC43MzQgMjguNTE1QzEyOS43MjkgMjkuNTk0IDEzMS4wMjggMzAuMTM2IDEzMi42MzEgMzAuMTM2VjMwLjEzM1pNOTMuNjk4IDI3Ljg3NkM5My41Nzk1IDI4LjAwMjUgOTMuNDU2NCAyOC4xMjQ2IDkzLjMyOSAyOC4yNDJDOTEuOTQ3IDI5LjUxNiA5MC4xMjMgMzAuMTU1IDg3Ljg2NiAzMC4xNTVDODYuNTggMzAuMTU1IDg1LjQwOCAyOS45MjYgODQuMzUgMjkuNDY0QzgzLjMxNTUgMjkuMDE4OSA4Mi4zODk4IDI4LjM1NDYgODEuNjM3IDI3LjUxN0M4MC44ODQgMjYuNjc5IDgwLjMwMSAyNS42NzIgNzkuODg5IDI0LjQ5NEM3OS40NzYgMjMuMzE1IDc5LjI2OSAyMi4wMSA3OS4yNjkgMjAuNTc4Qzc5LjI2OSAxOS4xNDUgNzkuNDczIDE3Ljg0IDc5Ljg4OSAxNi42NjJDODAuMzAxIDE1LjQ4NCA4MC44ODQgMTQuNDc2IDgxLjYzNyAxMy42MzlDODIuMzk0OSAxMi43OTg3IDgzLjMyNzMgMTIuMTM0MiA4NC4zNjkgMTEuNjkyQzg1LjQzNiAxMS4yMyA4Ni42MTQgMTEgODcuOTAzIDExQzkwLjU3IDExIDkyLjU5NSAxMS42NDIgOTMuOTc3IDEyLjkyNkw5Ny4yNTggOS42NDQ5OUM5NC43NzQgNy43MTA5OSA5MS42MzMgNi43Mzk5OSA4Ny44MjkgNi43Mzk5OUM4NS43MTggNi43Mzk5OSA4My44MTEgNy4wNzQ5OSA4Mi4xMTIgNy43NDE5OUM4MC40MTMgOC40MDc5OSA3OC45NTYgOS4zNDQ5OSA3Ny43NCAxMC41NDVDNzYuNTI1IDExLjc0NyA3NS41OTIgMTMuMTk5IDc0LjkzNCAxNC44OThDNzQuMjc3IDE2LjU5NyA3My45NTEgMTguNDkxIDczLjk1MSAyMC41ODFDNzMuOTUxIDIyLjY3IDc0LjI4NiAyNC41MzQgNzQuOTUzIDI2LjI0NUM3NS42MTkgMjcuOTU3IDc2LjU2MiAyOS40MTQgNzcuNzc0IDMwLjYxN0M3OC45OSAzMS44MiA4MC40NDQgMzIuNzUzIDgyLjE0NiAzMy40MjNDODMuODQ1IDM0LjA5IDg1LjczOSAzNC40MjQgODcuODI5IDM0LjQyNEM4OS45MTkgMzQuNDI0IDkxLjcwOCAzNC4wOSA5My4zNDggMzMuNDIzQzk0LjcxOCAzMi44NjUgOTUuOTE4IDMyLjEyMSA5Ni45NDggMzEuMTkxQzk3LjE0OSAzMS4wMDggOTcuMzQ4IDMwLjgxNSA5Ny41MzcgMzAuNjJMOTMuNzAxIDI3Ljg4NUw5My42OTggMjcuODc2Wk0xMTAuODAyIDE0LjAxNUMxMDkuMTk5IDE0LjAxNSAxMDYuODM2IDE0LjQ3MSAxMDUuNjExIDE2LjE1OEwxMDUuNTM3IDYuMDE1OTlIMTAwLjc2NVYzMy45MzlIMTA1LjcyVjIyLjY0MUMxMDUuNzcxIDIxLjQ2MDcgMTA2LjI4OCAyMC4zNDg4IDEwNy4xNTcgMTkuNTQ4OUMxMDguMDI3IDE4Ljc0OTEgMTA5LjE3OCAxOC4zMjY2IDExMC4zNTggMTguMzc0QzExMy4zOTcgMTguMzc0IDExNC4yNjggMjEuMTU5IDExNC4yNjggMjIuNjQxVjMzLjkzOUgxMTkuMjIzVjIxLjA1OUMxMTkuMjIzIDIxLjA1OSAxMTkuMTQyIDE0LjAxNSAxMTAuODAyIDE0LjAxNVpNMTczLjc2MyAxNC4zNThIMTY5Ljk5OVY4LjcxNDk5SDE2NS4wNDhWMTQuMzU4SDE2MS4yODRWMTguOTE2SDE2NS4wNDhWMzQuMDAzSDE2OS45OTlWMTguOTE2SDE3My43NjNWMTQuMzU4Wk0xOTAuNzg3IDI1LjI2MkMxOTAuMTI5IDI0LjUwMTQgMTg5LjMwNyAyMy44OTk0IDE4OC4zODQgMjMuNTAxQzE4Ny40ODggMjMuMTE3IDE4Ni4zMzEgMjIuNzMyIDE4NC45NDggMjIuMzY0QzE4NC4xNjUgMjIuMTQzOSAxODMuMzkgMjEuODk3OCAxODIuNjIzIDIxLjYyNkMxODIuMTYzIDIxLjQ2MjEgMTgxLjc0MSAyMS4yMDY2IDE4MS4zODMgMjAuODc1QzE4MS4yMzUgMjAuNzQyMSAxODEuMTE4IDIwLjU3ODkgMTgxLjAzOSAyMC4zOTY0QzE4MC45NjEgMjAuMjE0IDE4MC45MjIgMjAuMDE2NiAxODAuOTI3IDE5LjgxOEMxODAuOTI3IDE5LjI3MiAxODEuMTU2IDE4Ljg0NCAxODEuNjI1IDE4LjUxQzE4Mi4xMjEgMTguMTU2IDE4Mi44NjIgMTcuOTc2IDE4My44MjYgMTcuOTc2QzE4NC43OSAxNy45NzYgMTg1LjU4NyAxOC4yMDkgMTg2LjE0OCAxOC42NjhDMTg2LjcwNiAxOS4xMjQgMTg3LjAwNyAxOS43MjUgMTg3LjA3MiAyMC41TDE4Ny4wOTQgMjAuNzgySDE5MS42MzNMMTkxLjYxNyAyMC40NkMxOTEuNTIxIDE4LjQ4NSAxOTAuNzcxIDE2LjkgMTg5LjM4NSAxNS43NUMxODguMDEyIDE0LjYxMiAxODYuMTg1IDE0LjAzMyAxODMuOTYyIDE0LjAzM0MxODIuNDc3IDE0LjAzMyAxODEuMTQxIDE0LjI4NyAxNzkuOTk0IDE0Ljc4NkMxNzguODMxIDE1LjI5MSAxNzcuOTI2IDE1Ljk5NSAxNzcuMjk2IDE2Ljg4MkMxNzYuNjczIDE3Ljc0NTUgMTc2LjMzOCAxOC43ODQgMTc2LjM0MSAxOS44NDlDMTc2LjM0MSAyMS4xNjcgMTc2LjY5OCAyMi4yNDkgMTc3LjM5OSAyMy4wNjRDMTc4LjA2IDIzLjg0MzIgMTc4Ljg5OCAyNC40NTM0IDE3OS44NDIgMjQuODQ0QzE4MC43NDQgMjUuMjE2IDE4MS45MjggMjUuNjA3IDE4My4zNjEgMjZDMTg0LjgwNiAyNi40MSAxODUuODcyIDI2Ljc4NSAxODYuNTMgMjcuMTIzQzE4Ny4xIDI3LjQxNCAxODcuMzc5IDI3Ljg0NSAxODcuMzc5IDI4LjQ0NEMxODcuMzc5IDI5LjA0MiAxODcuMTIyIDI5LjQ2NyAxODYuNTk1IDI5LjgzOUMxODYuMDQzIDMwLjIyNiAxODUuMjM3IDMwLjQyNSAxODQuMjAxIDMwLjQyNUMxODMuMTY2IDMwLjQyNSAxODIuMzk0IDMwLjE3NCAxODEuNzQ5IDI5LjY3NEMxODEuMTEzIDI5LjE4MSAxODAuNzcyIDI4LjU4OSAxODAuNzEgMjcuODY0TDE4MC42ODUgMjcuNTgySDE3Ni4wMTNMMTc2LjAyNSAyNy45MDFDMTc2LjA2NyAyOS4wOTU1IDE3Ni40NzIgMzAuMjQ4NyAxNzcuMTg4IDMxLjIwNkMxNzcuOTA3IDMyLjE4IDE3OC44OTMgMzIuOTU4IDE4MC4xMTggMzMuNTE5QzE4MS4zMzYgMzQuMDc3IDE4Mi43MzIgMzQuMzYyIDE4NC4yNjYgMzQuMzYyQzE4NS44MDEgMzQuMzYyIDE4Ny4xMDkgMzQuMTA4IDE4OC4yMzggMzMuNjA5QzE4OS4zNzYgMzMuMTA0IDE5MC4yNzIgMzIuMzk0IDE5MC45MDEgMzEuNDk0QzE5MS41MzQgMzAuNTkyIDE5MS44NTMgMjkuNTU0IDE5MS44NTMgMjguNDAzQzE5MS44MjggMjcuMTEgMTkxLjQ2NiAyNi4wNTMgMTkwLjc3NyAyNS4yNjJIMTkwLjc4N1oiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTI0MS45ODIgMjUuNjU4MlYxNy43MTE3SDIyOC40NDFMMjIwLjQ5NCAyNS42NTgySDI0MS45ODJaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNTcuMjM5IDUuOTUwODFIMjQwLjI2NUwyMzIuMjU1IDEzLjg5NzNIMjU3LjIzOVY1Ljk1MDgxWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjEyLjYxMSAzMy42MDQ4TDIxNi42OCAyOS41MzYxSDIzMC40MTJWMzcuNDgyN0gyMTIuNjExVjMzLjYwNDhaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yMTUuNTk5IDIxLjc4MDNIMjI0LjM3MkwyMzIuMzgyIDEzLjgzMzdIMjE1LjU5OVYyMS43ODAzWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjA2IDMzLjYwNDdIMjEyLjYxMUwyMjAuNDk0IDI1LjY1ODJIMjA2VjMzLjYwNDdaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNDAuMjY1IDUuOTUwODFMMjM2LjE5NyAxMC4wMTk0SDIxMC4yNTlWMi4wNzI4OEgyNDAuMjY1VjUuOTUwODFaIiBmaWxsPSIjOUI5QjlCIi8+Cjwvc3ZnPgo=`,\n            width: 170,\n            height: 25,\n            right: 25,\n            bottom: 50,\n            opacity: 0.7\n          }\n        };\n      }\n    }\n    const specialOverrides = { ...chart.chartOptions.specialOverrides };\n    const optionsMetadata = { ...chart.chartOptions.optionMetadata };\n    const cloneProxy = this.factoryApi.create(userOptions, processedOverrides, specialOverrides, optionsMetadata);\n    await cloneProxy.setState(state);\n    cloneProxy.chart.ctx.zoomManager.updateZoom(\"chartProxy\", chart.ctx.zoomManager.getZoom());\n    cloneProxy.chart.ctx.legendManager.clearData();\n    cloneProxy.chart.ctx.legendManager.update(chart.ctx.legendManager.getData());\n    chart.series.forEach((series, index) => {\n      if (!series.visible) {\n        cloneProxy.chart.series[index].visible = false;\n      }\n    });\n    const legendPages = [];\n    for (const legend of chart.modulesManager.legends()) {\n      legendPages.push(legend.legend.pagination?.currentPage ?? 0);\n    }\n    for (const legend of cloneProxy.chart.modulesManager.legends()) {\n      const page = legendPages.shift() ?? 0;\n      if (!legend.legend.pagination)\n        continue;\n      legend.legend.pagination.setPage(page);\n    }\n    cloneProxy.chart.update(0 /* FULL */, { forceNodeDataRefresh: true });\n    await cloneProxy.waitForUpdate();\n    return cloneProxy;\n  }\n  getEnabledOriginators() {\n    const {\n      chartOptions: { processedOptions, optionMetadata },\n      ctx: { annotationManager, chartTypeOriginator, zoomManager, legendManager }\n    } = this.chart;\n    const originators = [];\n    if (\"annotations\" in processedOptions && processedOptions.annotations?.enabled) {\n      originators.push(annotationManager);\n    }\n    const isFinancialChart = optionMetadata.presetType === \"price-volume\";\n    if (isFinancialChart) {\n      originators.push(chartTypeOriginator);\n    }\n    if (processedOptions.navigator?.enabled || processedOptions.zoom?.enabled) {\n      originators.push(zoomManager);\n    }\n    if (\"legend\" in this.chart) {\n      originators.push(legendManager);\n    }\n    return originators;\n  }\n  async setStateOriginators(state, originators) {\n    this.factoryApi.caretaker.restore(state, ...originators);\n    this.chart.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });\n    await this.chart.waitForUpdate();\n  }\n};\n_AgChartInstanceProxy.chartInstances = /* @__PURE__ */ new WeakMap();\n__decorateClass([\n  ActionOnSet({\n    oldValue(chart) {\n      if (!chart.destroyed) {\n        chart.publicApi = void 0;\n      }\n      _AgChartInstanceProxy.chartInstances.delete(chart);\n    },\n    newValue(chart) {\n      if (!chart)\n        return;\n      chart.publicApi = this;\n      _AgChartInstanceProxy.chartInstances.set(chart, this);\n    }\n  })\n], _AgChartInstanceProxy.prototype, \"chart\", 2);\nvar AgChartInstanceProxy = _AgChartInstanceProxy;\n\n// packages/ag-charts-community/src/locale/locale.ts\nvar Locale = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.localeText = void 0;\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.ctx.localeManager.setLocaleText(target.localeText);\n  }),\n  Validate(PLAIN_OBJECT, { optional: true })\n], Locale.prototype, \"localeText\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.ctx.localeManager.setLocaleTextFormatter(target.getLocaleText);\n  }),\n  Validate(FUNCTION, { optional: true })\n], Locale.prototype, \"getLocaleText\", 2);\n\n// packages/ag-charts-community/src/locale/localeModule.ts\nvar LocaleModule = {\n  type: \"root\",\n  optionsKey: \"locale\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n  moduleFactory: (ctx) => new Locale(ctx)\n};\n\n// packages/ag-charts-community/src/scale/groupedCategoryScale.ts\nvar GroupedCategoryScale = class extends CategoryScale {\n  getIndex(value) {\n    return super.getIndex(value) ?? this.getMatchIndex(value);\n  }\n  getMatchIndex(value) {\n    const key = JSON.stringify(value);\n    const match = this._domain.find((d) => JSON.stringify(d) === key);\n    if (match != null) {\n      return super.getIndex(match);\n    }\n  }\n};\n\n// packages/ag-charts-community/src/util/memo.ts\nvar memorizedFns = /* @__PURE__ */ new WeakMap();\nfunction memo(params, fnGenerator) {\n  const serialisedParams = JSON.stringify(params, null, 0);\n  if (!memorizedFns.has(fnGenerator)) {\n    memorizedFns.set(fnGenerator, /* @__PURE__ */ new Map());\n  }\n  if (!memorizedFns.get(fnGenerator)?.has(serialisedParams)) {\n    memorizedFns.get(fnGenerator)?.set(serialisedParams, fnGenerator(params));\n  }\n  return memorizedFns.get(fnGenerator)?.get(serialisedParams);\n}\nfunction simpleMemorize(fn) {\n  const primitveCache = /* @__PURE__ */ new Map();\n  const paramsToKeys = (...params) => {\n    return params.map((v) => {\n      if (typeof v === \"object\")\n        return v;\n      if (typeof v === \"symbol\")\n        return v;\n      if (!primitveCache.has(v)) {\n        primitveCache.set(v, { v });\n      }\n      return primitveCache.get(v);\n    });\n  };\n  const empty = {};\n  const cache = /* @__PURE__ */ new WeakMap();\n  return (...p) => {\n    const keys = p.length === 0 ? [empty] : paramsToKeys(...p);\n    let currentCache = cache;\n    for (const key of keys.slice(0, -1)) {\n      if (!currentCache.has(key)) {\n        currentCache.set(key, /* @__PURE__ */ new WeakMap());\n      }\n      currentCache = currentCache.get(key);\n    }\n    const finalKey = keys.at(-1);\n    let cachedValue = currentCache.get(finalKey);\n    if (!cachedValue) {\n      cachedValue = fn(...p);\n      currentCache.set(finalKey, cachedValue);\n    }\n    return cachedValue;\n  };\n}\n\n// packages/ag-charts-community/src/chart/data/aggregateFunctions.ts\nfunction sumValues(values, accumulator = [0, 0]) {\n  for (const value of values) {\n    if (typeof value !== \"number\") {\n      continue;\n    }\n    if (value < 0) {\n      accumulator[0] += value;\n    }\n    if (value > 0) {\n      accumulator[1] += value;\n    }\n  }\n  return accumulator;\n}\nfunction sum(id, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: [matchGroupId],\n    type: \"aggregate\",\n    aggregateFunction: (values) => sumValues(values)\n  };\n  return result;\n}\nfunction groupSum(id, matchGroupId) {\n  return {\n    id,\n    type: \"aggregate\",\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    aggregateFunction: (values) => sumValues(values),\n    groupAggregateFunction: (next, acc = [0, 0]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      return acc;\n    },\n    round: true\n  };\n}\nfunction range2(id, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: [matchGroupId],\n    type: \"aggregate\",\n    aggregateFunction: (values) => ContinuousDomain.extendDomain(values)\n  };\n  return result;\n}\nfunction groupCount(id) {\n  return {\n    id,\n    type: \"aggregate\",\n    aggregateFunction: () => [0, 1],\n    groupAggregateFunction: (next, acc = [0, 0]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      return acc;\n    }\n  };\n}\nfunction groupAverage(id, matchGroupId) {\n  const def = {\n    id,\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    type: \"aggregate\",\n    aggregateFunction: (values) => sumValues(values),\n    groupAggregateFunction: (next, acc = [0, 0, -1]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      acc[2]++;\n      return acc;\n    },\n    finalFunction: (acc = [0, 0, 0]) => {\n      const result = acc[0] + acc[1];\n      if (result >= 0) {\n        return [0, result / acc[2]];\n      }\n      return [result / acc[2], 0];\n    },\n    round: true\n  };\n  return def;\n}\nfunction area(id, aggFn, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    type: \"aggregate\",\n    aggregateFunction: (values, keyRange = []) => {\n      const keyWidth = keyRange[1] - keyRange[0];\n      return aggFn.aggregateFunction(values).map((v) => v / keyWidth);\n    },\n    round: true\n  };\n  if (aggFn.groupAggregateFunction) {\n    result.groupAggregateFunction = aggFn.groupAggregateFunction;\n  }\n  return result;\n}\nfunction accumulatedValue(onlyPositive) {\n  return () => {\n    let value = 0;\n    return (datum) => {\n      if (!isFiniteNumber(datum)) {\n        return datum;\n      }\n      value += onlyPositive ? Math.max(0, datum) : datum;\n      return value;\n    };\n  };\n}\nfunction trailingAccumulatedValue() {\n  return () => {\n    let value = 0;\n    return (datum) => {\n      if (!isFiniteNumber(datum)) {\n        return datum;\n      }\n      const trailingValue = value;\n      value += datum;\n      return trailingValue;\n    };\n  };\n}\n\n// packages/ag-charts-community/src/chart/data/processors.ts\nfunction basicContinuousCheckDatumValidation(value) {\n  return value != null && isContinuous(value);\n}\nfunction basicDiscreteCheckDatumValidation(value) {\n  return value != null;\n}\nfunction getValidationFn(scaleType) {\n  switch (scaleType) {\n    case \"number\":\n    case \"log\":\n    case \"ordinal-time\":\n    case \"time\":\n    case \"color\":\n      return basicContinuousCheckDatumValidation;\n    default:\n      return basicDiscreteCheckDatumValidation;\n  }\n}\nfunction getValueType(scaleType) {\n  switch (scaleType) {\n    case \"number\":\n    case \"log\":\n    case \"time\":\n    case \"color\":\n      return \"range\";\n    default:\n      return \"category\";\n  }\n}\nfunction keyProperty(propName, scaleType, opts = {}) {\n  const result = {\n    property: propName,\n    type: \"key\",\n    valueType: getValueType(scaleType),\n    validation: getValidationFn(scaleType),\n    ...opts\n  };\n  return result;\n}\nfunction valueProperty(propName, scaleType, opts = {}) {\n  const result = {\n    property: propName,\n    type: \"value\",\n    valueType: getValueType(scaleType),\n    validation: getValidationFn(scaleType),\n    ...opts\n  };\n  return result;\n}\nfunction rowCountProperty(propName, opts = {}) {\n  const result = {\n    property: propName,\n    type: \"value\",\n    valueType: \"range\",\n    missingValue: 1,\n    processor: () => () => 1,\n    ...opts\n  };\n  return result;\n}\nfunction rangedValueProperty(propName, opts = {}) {\n  const { min = -Infinity, max = Infinity, ...defOpts } = opts;\n  return {\n    type: \"value\",\n    property: propName,\n    valueType: \"range\",\n    validation: basicContinuousCheckDatumValidation,\n    processor: () => (datum) => isFiniteNumber(datum) ? clamp(min, datum, max) : datum,\n    ...defOpts\n  };\n}\nfunction accumulativeValueProperty(propName, scaleType, opts = {}) {\n  const { onlyPositive, ...defOpts } = opts;\n  const result = {\n    ...valueProperty(propName, scaleType, defOpts),\n    processor: accumulatedValue(onlyPositive)\n  };\n  return result;\n}\nfunction trailingAccumulatedValueProperty(propName, scaleType, opts = {}) {\n  const result = {\n    ...valueProperty(propName, scaleType, opts),\n    processor: trailingAccumulatedValue()\n  };\n  return result;\n}\nfunction groupAccumulativeValueProperty(propName, mode, sum2, opts, scaleType) {\n  return [\n    valueProperty(propName, scaleType, opts),\n    accumulateGroup(opts.groupId, mode, sum2, opts.separateNegative),\n    ...opts.rangeId != null ? [range2(opts.rangeId, opts.groupId)] : []\n  ];\n}\nfunction groupStackValueProperty(propName, scaleType, opts) {\n  return [valueProperty(propName, scaleType, opts), accumulateStack(opts.groupId)];\n}\nvar SMALLEST_KEY_INTERVAL = {\n  type: \"reducer\",\n  property: \"smallestKeyInterval\",\n  initialValue: Infinity,\n  reducer: () => {\n    let prevX = NaN;\n    return (smallestSoFar = Infinity, keys) => {\n      const nextX = typeof keys[0] === \"number\" ? keys[0] : Number(keys[0]);\n      const interval = Math.abs(nextX - prevX);\n      prevX = nextX;\n      if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {\n        return interval;\n      }\n      return smallestSoFar;\n    };\n  }\n};\nvar LARGEST_KEY_INTERVAL = {\n  type: \"reducer\",\n  property: \"largestKeyInterval\",\n  initialValue: -Infinity,\n  reducer: () => {\n    let prevX = NaN;\n    return (largestSoFar = -Infinity, keys) => {\n      const nextX = typeof keys[0] === \"number\" ? keys[0] : Number(keys[0]);\n      const interval = Math.abs(nextX - prevX);\n      prevX = nextX;\n      if (!isNaN(interval) && interval > 0 && interval > largestSoFar) {\n        return interval;\n      }\n      return largestSoFar;\n    };\n  }\n};\nvar SORT_DOMAIN_GROUPS = {\n  type: \"processor\",\n  property: \"sortedGroupDomain\",\n  calculate: ({ domain: { groups } }) => groups?.slice().sort((a, b) => {\n    for (let i = 0; i < a.length; i++) {\n      const result = a[i] - b[i];\n      if (result !== 0) {\n        return result;\n      }\n    }\n    return 0;\n  })\n};\nfunction normaliseFnBuilder({ normaliseTo }) {\n  const normalise2 = (val, extent2) => {\n    if (extent2 === 0)\n      return null;\n    const result = (val ?? 0) * normaliseTo / extent2;\n    if (result >= 0) {\n      return Math.min(normaliseTo, result);\n    }\n    return Math.max(-normaliseTo, result);\n  };\n  return () => () => (columns, valueIndexes, dataGroup) => {\n    const extent2 = normaliseFindExtent(columns, valueIndexes, dataGroup);\n    for (const valueIdx of valueIndexes) {\n      for (const datumIndex of dataGroup.datumIndices[valueIdx]) {\n        const column = columns[valueIdx];\n        const value = column[datumIndex];\n        if (value == null) {\n          column[datumIndex] = void 0;\n          continue;\n        }\n        column[datumIndex] = // eslint-disable-next-line sonarjs/no-nested-functions\n        typeof value === \"number\" ? normalise2(value, extent2) : value.map((v) => normalise2(v, extent2));\n      }\n    }\n  };\n}\nfunction normaliseFindExtent(columns, valueIndexes, dataGroup) {\n  const valuesExtent = [0, 0];\n  for (const valueIdx of valueIndexes) {\n    const column = columns[valueIdx];\n    for (const datumIndex of dataGroup.datumIndices[valueIdx]) {\n      const value = column[datumIndex];\n      if (value == null)\n        continue;\n      const valueExtent = typeof value === \"number\" ? value : Math.max(...value.map((v) => v ?? 0));\n      const valIdx = valueExtent < 0 ? 0 : 1;\n      if (valIdx === 0) {\n        valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], valueExtent);\n      } else {\n        valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], valueExtent);\n      }\n    }\n  }\n  return Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);\n}\nfunction normaliseGroupTo(matchGroupIds, normaliseTo) {\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds,\n    adjust: memo({ normaliseTo }, normaliseFnBuilder)\n  };\n}\nfunction normalisePropertyFnBuilder({\n  normaliseTo,\n  zeroDomain,\n  rangeMin,\n  rangeMax\n}) {\n  const normaliseSpan = normaliseTo[1] - normaliseTo[0];\n  const normalise2 = (val, start2, span) => {\n    const result = normaliseTo[0] + (val - start2) / span * normaliseSpan;\n    if (span === 0) {\n      return zeroDomain;\n    } else if (result >= normaliseTo[1]) {\n      return normaliseTo[1];\n    } else if (result < normaliseTo[0]) {\n      return normaliseTo[0];\n    }\n    return result;\n  };\n  return () => (pData, pIdx) => {\n    let [start2, end2] = pData.domain.values[pIdx];\n    if (rangeMin != null)\n      start2 = rangeMin;\n    if (rangeMax != null)\n      end2 = rangeMax;\n    const span = end2 - start2;\n    pData.domain.values[pIdx] = [normaliseTo[0], normaliseTo[1]];\n    const column = pData.columns[pIdx];\n    for (let datumIndex = 0; datumIndex < column.length; datumIndex += 1) {\n      column[datumIndex] = normalise2(column[datumIndex], start2, span);\n    }\n  };\n}\nfunction normalisePropertyTo(property, normaliseTo, zeroDomain, rangeMin, rangeMax) {\n  return {\n    type: \"property-value-processor\",\n    property,\n    adjust: memo({ normaliseTo, rangeMin, rangeMax, zeroDomain }, normalisePropertyFnBuilder)\n  };\n}\nvar ANIMATION_VALIDATION_UNIQUE_KEYS = 1;\nvar ANIMATION_VALIDATION_ORDERED_KEYS = 2;\nvar animationValidationProcessKey = (count, def, keyValues, column) => {\n  let validation = ANIMATION_VALIDATION_UNIQUE_KEYS | ANIMATION_VALIDATION_ORDERED_KEYS;\n  if (def.valueType === \"category\") {\n    if (keyValues.length !== count)\n      validation &= ~ANIMATION_VALIDATION_UNIQUE_KEYS;\n    return validation;\n  }\n  let lastValue = column[0]?.valueOf();\n  for (let d = 1; validation !== 0 && d < column.length; d++) {\n    const keyValue = column[d]?.valueOf();\n    if (!Number.isFinite(keyValue) || lastValue > keyValue)\n      validation &= ~ANIMATION_VALIDATION_ORDERED_KEYS;\n    if (Number.isFinite(keyValue) && lastValue === keyValue)\n      validation &= ~ANIMATION_VALIDATION_UNIQUE_KEYS;\n    lastValue = keyValue;\n  }\n  return validation;\n};\nfunction animationValidation(valueKeyIds) {\n  return {\n    type: \"processor\",\n    property: \"animationValidation\",\n    calculate(result) {\n      const { keys: keysDefs, values: valuesDef } = result.defs;\n      const {\n        input: { count },\n        domain: { keys: domainKeys, values: domainValues },\n        keys,\n        columns\n      } = result;\n      let validation = ANIMATION_VALIDATION_UNIQUE_KEYS | ANIMATION_VALIDATION_ORDERED_KEYS;\n      if (count !== 0) {\n        for (let i = 0; validation !== 0 && i < keysDefs.length; i++) {\n          for (const scope of keysDefs[i].scopes) {\n            validation &= animationValidationProcessKey(\n              count,\n              keysDefs[i],\n              domainKeys[i],\n              keys[i].get(scope)\n            );\n          }\n        }\n        for (let i = 0; validation !== 0 && i < valuesDef.length; i++) {\n          const value = valuesDef[i];\n          if (!valueKeyIds?.includes(value.id))\n            continue;\n          validation &= animationValidationProcessKey(count, value, domainValues[i], columns[i]);\n        }\n      }\n      return {\n        uniqueKeys: (validation & ANIMATION_VALIDATION_UNIQUE_KEYS) !== 0,\n        orderedKeys: (validation & ANIMATION_VALIDATION_ORDERED_KEYS) !== 0\n      };\n    }\n  };\n}\nfunction buildGroupAccFn({ mode, separateNegative }) {\n  return () => () => (columns, valueIndexes, dataGroup) => {\n    const acc = [0, 0];\n    for (const valueIdx of valueIndexes) {\n      for (const datumIndex of dataGroup.datumIndices[valueIdx] ?? []) {\n        const column = columns[valueIdx];\n        const currentVal = column[datumIndex];\n        const accIndex = isNegative(currentVal) && separateNegative ? 0 : 1;\n        if (!isFiniteNumber(currentVal))\n          continue;\n        if (mode === \"normal\")\n          acc[accIndex] += currentVal;\n        column[datumIndex] = acc[accIndex];\n        if (mode === \"trailing\")\n          acc[accIndex] += currentVal;\n      }\n    }\n  };\n}\nfunction buildGroupWindowAccFn({ mode, sum: sum2 }) {\n  return () => {\n    const lastValues = [];\n    let firstRow = true;\n    return () => {\n      return (columns, valueIndexes, dataGroup) => {\n        let acc = 0;\n        for (const valueIdx of valueIndexes) {\n          const column = columns[valueIdx];\n          for (const datumIndex of dataGroup.datumIndices[valueIdx] ?? []) {\n            const currentVal = column[datumIndex];\n            const lastValue = firstRow && sum2 === \"current\" ? 0 : lastValues[valueIdx];\n            lastValues[valueIdx] = currentVal;\n            const sumValue = sum2 === \"current\" ? currentVal : lastValue;\n            if (!isFiniteNumber(currentVal) || !isFiniteNumber(lastValue)) {\n              column[datumIndex] = acc;\n              continue;\n            }\n            if (mode === \"normal\") {\n              acc += sumValue;\n            }\n            column[datumIndex] = acc;\n            if (mode === \"trailing\") {\n              acc += sumValue;\n            }\n          }\n        }\n        firstRow = false;\n      };\n    };\n  };\n}\nfunction accumulateGroup(matchGroupId, mode, sum2, separateNegative = false) {\n  let adjust;\n  if (mode.startsWith(\"window\")) {\n    const modeParam = mode.endsWith(\"-trailing\") ? \"trailing\" : \"normal\";\n    adjust = memo({ mode: modeParam, sum: sum2 }, buildGroupWindowAccFn);\n  } else {\n    adjust = memo({ mode, separateNegative }, buildGroupAccFn);\n  }\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds: [matchGroupId],\n    adjust\n  };\n}\nfunction groupStackAccFn() {\n  return () => (columns, valueIndexes, dataGroup) => {\n    const acc = new Float64Array(valueIndexes.length);\n    let stackCount = 0;\n    for (const valueIdx of valueIndexes) {\n      const column = columns[valueIdx];\n      for (const datumIndex of dataGroup.datumIndices[valueIdx] ?? []) {\n        const currentValue = column[datumIndex];\n        acc[stackCount] = Number.isFinite(currentValue) ? currentValue : NaN;\n        stackCount += 1;\n        column[datumIndex] = acc.subarray(0, stackCount);\n      }\n    }\n  };\n}\nfunction accumulateStack(matchGroupId) {\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds: [matchGroupId],\n    adjust: groupStackAccFn\n  };\n}\nfunction valueIdentifier(value) {\n  return value.id ?? value.property;\n}\nfunction valueIndices(id, previousData, processedData) {\n  const properties = /* @__PURE__ */ new Map();\n  const previousValues = previousData.defs.values;\n  for (let previousIndex = 0; previousIndex < previousValues.length; previousIndex += 1) {\n    const previousValue = previousValues[previousIndex];\n    if (previousValue.scopes?.includes(id) === false)\n      continue;\n    const valueId = valueIdentifier(previousValue);\n    if (properties.has(valueId))\n      return;\n    properties.set(valueId, previousIndex);\n  }\n  const indices = [];\n  const nextValues = processedData.defs.values;\n  for (let nextIndex = 0; nextIndex < nextValues.length; nextIndex += 1) {\n    const nextValue = nextValues[nextIndex];\n    if (nextValue.scopes?.includes(id) === false)\n      continue;\n    const valueId = valueIdentifier(nextValue);\n    const previousIndex = properties.get(valueId);\n    if (previousIndex == null)\n      return;\n    properties.delete(valueId);\n    indices.push({ previousIndex, nextIndex });\n  }\n  if (properties.size !== 0)\n    return;\n  return indices;\n}\nfunction columnsEqual(previousColumns, nextColumns, indices, previousDatumIndex, nextDatumIndex) {\n  for (const { previousIndex, nextIndex } of indices) {\n    const previousColumn = previousColumns[previousIndex];\n    const nextColumn = nextColumns[nextIndex];\n    const previousValue = previousColumn[previousDatumIndex];\n    const nextValue = nextColumn[nextDatumIndex];\n    if (previousValue !== nextValue) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction diff(id, previousData, updateMovedData = true) {\n  return {\n    type: \"processor\",\n    property: \"diff\",\n    calculate(processedData, previousValue) {\n      const moved = /* @__PURE__ */ new Map();\n      const added = /* @__PURE__ */ new Map();\n      const updated = /* @__PURE__ */ new Map();\n      const removed = /* @__PURE__ */ new Map();\n      const previousKeys = previousData.keys;\n      const keys = processedData.keys;\n      const previousColumns = previousData.columns;\n      const columns = processedData.columns;\n      const indices = valueIndices(id, previousData, processedData);\n      if (indices == null)\n        return previousValue;\n      const length2 = Math.max(previousData.input.count, processedData.input.count);\n      for (let i = 0; i < length2; i++) {\n        const hasPreviousDatum = i < previousData.input.count;\n        const hasDatum = i < processedData.input.count;\n        const prevKeys = hasPreviousDatum ? datumKeys(previousKeys, id, i) : void 0;\n        const prevId = prevKeys != null ? createDatumId(prevKeys) : \"\";\n        const dKeys = hasDatum ? datumKeys(keys, id, i) : void 0;\n        const datumId = dKeys != null ? createDatumId(dKeys) : \"\";\n        if (hasDatum && hasPreviousDatum && prevId === datumId) {\n          if (!columnsEqual(previousColumns, columns, indices, i, i)) {\n            updated.set(datumId, i);\n          }\n          continue;\n        }\n        const removedIndex = removed.get(datumId);\n        if (removedIndex != null) {\n          if (updateMovedData || !columnsEqual(previousColumns, columns, indices, removedIndex, i)) {\n            updated.set(datumId, i);\n            moved.set(datumId, i);\n          }\n          removed.delete(datumId);\n        } else if (hasDatum) {\n          added.set(datumId, i);\n        }\n        const addedIndex = added.get(prevId);\n        if (addedIndex != null) {\n          if (updateMovedData || !columnsEqual(previousColumns, columns, indices, addedIndex, i)) {\n            updated.set(prevId, i);\n            moved.set(prevId, i);\n          }\n          added.delete(prevId);\n        } else if (hasPreviousDatum) {\n          updated.delete(prevId);\n          removed.set(prevId, i);\n        }\n      }\n      const changed = added.size > 0 || updated.size > 0 || removed.size > 0;\n      const value = {\n        changed,\n        added: new Set(added.keys()),\n        updated: new Set(updated.keys()),\n        removed: new Set(removed.keys()),\n        moved: new Set(moved.keys())\n      };\n      return {\n        ...previousValue,\n        [id]: value\n      };\n    }\n  };\n}\nfunction createDatumId(keys, ...extraKeys) {\n  let result;\n  if (isArray(keys)) {\n    result = keys.map((key) => transformIntegratedCategoryValue(key)).join(\"___\");\n  } else {\n    result = transformIntegratedCategoryValue(keys);\n  }\n  const primitiveType = typeof result === \"string\" || typeof result === \"number\" || typeof result === \"boolean\" || result instanceof Date;\n  if (primitiveType && extraKeys.length > 0) {\n    result += `___${extraKeys.join(\"___\")}`;\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/chart/axis/tree.ts\nvar Dimensions = class {\n  constructor() {\n    this.top = Infinity;\n    this.right = -Infinity;\n    this.bottom = -Infinity;\n    this.left = Infinity;\n  }\n  update(x, y) {\n    if (x > this.right) {\n      this.right = x;\n    }\n    if (x < this.left) {\n      this.left = x;\n    }\n    if (y > this.bottom) {\n      this.bottom = y;\n    }\n    if (y < this.top) {\n      this.top = y;\n    }\n  }\n};\nvar TreeNode = class _TreeNode {\n  constructor(label = \"\", parent, refId) {\n    this.label = label;\n    this.parent = parent;\n    this.refId = refId;\n    this.x = 0;\n    this.y = 0;\n    this.subtreeLeft = NaN;\n    this.subtreeRight = NaN;\n    this.children = [];\n    this.leafCount = 0;\n    this.prelim = 0;\n    this.mod = 0;\n    this.ancestor = this;\n    this.change = 0;\n    this.shift = 0;\n    this.index = 0;\n    // screenX is meant to be recomputed from (layout) x when the tree is resized (without performing another layout)\n    this.screenX = 0;\n    this.depth = parent ? parent.depth + 1 : 0;\n  }\n  insertTick(tick, index) {\n    let root = this;\n    for (let i = 0; i < tick.length; i++) {\n      const pathPart = tick[i];\n      const isNotLeaf = i !== tick.length - 1;\n      const { children } = root;\n      const existingNode = children.find((child) => child.label === pathPart);\n      if (existingNode && isNotLeaf) {\n        root = existingNode;\n      } else {\n        const node = new _TreeNode(pathPart, root, index);\n        node.index = children.length;\n        children.push(node);\n        if (isNotLeaf) {\n          root = node;\n        }\n      }\n    }\n  }\n  getLeftSibling() {\n    return this.index > 0 ? this.parent?.children[this.index - 1] : void 0;\n  }\n  getLeftmostSibling() {\n    return this.index > 0 ? this.parent?.children[0] : void 0;\n  }\n  // traverse the left contour of a subtree, return the successor of v on this contour\n  nextLeft() {\n    return this.children[0];\n  }\n  // traverse the right contour of a subtree, return the successor of v on this contour\n  nextRight() {\n    return this.children.at(-1);\n  }\n  getSiblings() {\n    return this.parent?.children.filter((_, i) => i !== this.index) ?? [];\n  }\n};\nfunction ticksToTree(ticks) {\n  const maxDepth = ticks.reduce((depth, tick) => depth < tick.length ? tick.length : depth, 0);\n  const root = new TreeNode();\n  for (let i = 0; i < ticks.length; i++) {\n    const tick = ticks[i];\n    while (tick.length < maxDepth) {\n      tick.push(\"\");\n    }\n    root.insertTick(tick, i);\n  }\n  return root;\n}\nfunction moveSubtree(wm, wp, shift) {\n  const subtrees = wp.index - wm.index;\n  const ratio2 = shift / subtrees;\n  wp.change -= ratio2;\n  wp.shift += shift;\n  wm.change += ratio2;\n  wp.prelim += shift;\n  wp.mod += shift;\n}\nfunction ancestor(vim, v, defaultAncestor) {\n  return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;\n}\nfunction executeShifts({ children }) {\n  let shift = 0;\n  let change = 0;\n  for (let i = children.length - 1; i >= 0; i--) {\n    const w = children[i];\n    w.prelim += shift;\n    w.mod += shift;\n    change += w.change;\n    shift += w.shift + change;\n  }\n}\nfunction apportion(v, defaultAncestor) {\n  const w = v.getLeftSibling();\n  if (w) {\n    let vop = v;\n    let vip = v;\n    let vim = w;\n    let vom = vip.getLeftmostSibling();\n    let sip = vip.mod;\n    let sop = vop.mod;\n    let sim = vim.mod;\n    let som = vom.mod;\n    while (vim.nextRight() && vip.nextLeft()) {\n      vim = vim.nextRight();\n      vip = vip.nextLeft();\n      vom = vom.nextLeft();\n      vop = vop.nextRight();\n      vop.ancestor = v;\n      const shift = vim.prelim + sim - (vip.prelim + sip) + 1;\n      if (shift > 0) {\n        moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);\n        sip += shift;\n        sop += shift;\n      }\n      sim += vim.mod;\n      sip += vip.mod;\n      som += vom.mod;\n      sop += vop.mod;\n    }\n    if (vim.nextRight() && !vop.nextRight()) {\n      vop.mod += sim - sop;\n    } else {\n      if (vip.nextLeft() && !vom.nextLeft()) {\n        vom.mod += sip - som;\n      }\n      defaultAncestor = v;\n    }\n  }\n  return defaultAncestor;\n}\nfunction firstWalk(node) {\n  const { children } = node;\n  if (children.length) {\n    let [defaultAncestor] = children;\n    for (const child of children) {\n      firstWalk(child);\n      defaultAncestor = apportion(child, defaultAncestor);\n    }\n    executeShifts(node);\n    const midpoint = (children[0].prelim + children.at(-1).prelim) / 2;\n    const leftSibling = node.getLeftSibling();\n    if (leftSibling) {\n      node.prelim = leftSibling.prelim + 1;\n      node.mod = node.prelim - midpoint;\n    } else {\n      node.prelim = midpoint;\n    }\n  } else {\n    const leftSibling = node.getLeftSibling();\n    node.prelim = leftSibling ? leftSibling.prelim + 1 : 0;\n  }\n}\nfunction secondWalk(v, m, layout) {\n  v.x = v.prelim + m;\n  v.y = v.depth;\n  layout.insertNode(v);\n  for (const w of v.children) {\n    secondWalk(w, m + v.mod, layout);\n  }\n}\nfunction thirdWalk(v) {\n  const { children } = v;\n  let leafCount = 0;\n  for (const w of children) {\n    thirdWalk(w);\n    if (w.children.length) {\n      leafCount += w.leafCount;\n    } else {\n      leafCount++;\n    }\n  }\n  v.leafCount = leafCount;\n  if (children.length) {\n    v.subtreeLeft = children[0].subtreeLeft;\n    v.subtreeRight = children[children.length - 1].subtreeRight;\n    v.x = (v.subtreeLeft + v.subtreeRight) / 2;\n  } else {\n    v.subtreeLeft = v.x;\n    v.subtreeRight = v.x;\n  }\n}\nfunction treeLayout(ticks) {\n  const layout = new TreeLayout();\n  const root = ticksToTree(ticks);\n  firstWalk(root);\n  secondWalk(root, -root.prelim, layout);\n  thirdWalk(root);\n  return layout;\n}\nvar TreeLayout = class {\n  constructor() {\n    this.dimensions = new Dimensions();\n    this.nodes = [];\n    this.depth = 0;\n  }\n  insertNode(node) {\n    if (this.depth < node.depth) {\n      this.depth = node.depth;\n    }\n    this.dimensions.update(node.x, node.y);\n    this.nodes.push(node);\n  }\n  scalingX(width2, flip) {\n    let scalingX = 1;\n    if (width2 > 0) {\n      const { left, right } = this.dimensions;\n      scalingX = width2 / (right - left);\n    }\n    if (flip) {\n      scalingX *= -1;\n    }\n    return scalingX;\n  }\n};\n\n// packages/ag-charts-community/src/chart/axis/groupedCategoryAxis.ts\nvar DepthLabelProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], DepthLabelProperties.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], DepthLabelProperties.prototype, \"avoidCollisions\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], DepthLabelProperties.prototype, \"color\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], DepthLabelProperties.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], DepthLabelProperties.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], DepthLabelProperties.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(NUMBER.restrict({ min: 1 }), { optional: true })\n], DepthLabelProperties.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DepthLabelProperties.prototype, \"fontFamily\", 2);\nvar DepthTickProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], DepthTickProperties.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], DepthTickProperties.prototype, \"width\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], DepthTickProperties.prototype, \"stroke\", 2);\nvar DepthProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.label = new DepthLabelProperties();\n    this.tick = new DepthTickProperties();\n  }\n};\n__decorateClass([\n  Validate(OBJECT)\n], DepthProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DepthProperties.prototype, \"tick\", 2);\nvar GroupedCategoryAxis = class extends CategoryAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new GroupedCategoryScale());\n    // Label scale (labels are positioned between ticks, tick count = label count + 1).\n    // We don't call is `labelScale` for consistency with other axes.\n    this.tickScale = new GroupedCategoryScale();\n    this.depthOptions = new PropertiesArray(DepthProperties);\n    this.includeInvisibleDomains = true;\n    this.tickScale.paddingInner = 1;\n    this.tickScale.paddingOuter = 0;\n  }\n  resizeTickTree() {\n    if (!this.tickTreeLayout)\n      return;\n    const { nodes } = this.tickTreeLayout;\n    const { range: range3, step, inset, bandwidth } = this.scale;\n    const width2 = Math.abs(range3[1] - range3[0]) - step;\n    const scalingX = this.tickTreeLayout.scalingX(width2, range3[0] > range3[1]);\n    const shiftX = inset + bandwidth / 2;\n    let offsetX = 0;\n    for (const node of nodes) {\n      const screenX = node.x * scalingX;\n      if (offsetX > screenX) {\n        offsetX = screenX;\n      }\n      node.screenX = screenX + shiftX;\n    }\n    for (const node of nodes) {\n      node.screenX -= offsetX;\n    }\n  }\n  getDepthOptionsMap(maxDepth) {\n    const optionsMap = [];\n    const { depthOptions, label } = this;\n    for (let i = 0; i < maxDepth; i++) {\n      optionsMap.push(\n        depthOptions[i]?.label.enabled ?? label.enabled ? {\n          enabled: true,\n          spacing: depthOptions[i]?.label.spacing ?? label.spacing,\n          lineHeight: TextUtils.getLineHeight(depthOptions[i]?.label.fontSize ?? label.fontSize ?? 10),\n          avoidCollisions: depthOptions[i]?.label.avoidCollisions ?? label.avoidCollisions\n        } : { enabled: false, spacing: 0, lineHeight: 0, avoidCollisions: false }\n      );\n    }\n    return optionsMap;\n  }\n  updateCategoryLabels() {\n    if (!this.computedLayout)\n      return;\n    this.tickLabelGroupSelection.update(this.computedLayout.tickLabelLayout).each((node, datum) => node.setProperties(datum));\n  }\n  updateAxisLine() {\n    if (!this.computedLayout)\n      return;\n    this.lineNode.visible = this.line.enabled;\n    this.lineNode.stroke = this.line.stroke;\n    this.lineNode.strokeWidth = this.line.width;\n  }\n  computeLayout() {\n    this.updateDirection();\n    this.updateScale();\n    this.resizeTickTree();\n    if (!this.tickTreeLayout?.depth) {\n      return { bbox: BBox.zero, separatorLayout: [], tickLabelLayout: [] };\n    }\n    const { step } = this.scale;\n    const { title, label, range: range3, depthOptions } = this;\n    const { depth: maxDepth, nodes: treeLabels } = this.tickTreeLayout;\n    const keepEvery = Math.ceil(label.fontSize / step);\n    const rotation = toRadians(this.rotation);\n    const isHorizontal = this.position === \"top\" || this.position === \"bottom\";\n    const sideFlag = label.getSideFlag();\n    const tickLabelLayout = [];\n    const labelBBoxes = /* @__PURE__ */ new Map();\n    const tempText = new TransformableText();\n    const { defaultRotation, configuredRotation } = calculateLabelRotation({\n      rotation: label.rotation,\n      parallel: label.parallel,\n      regularFlipRotation: normalizeAngle360(rotation - Math.PI / 2),\n      parallelFlipRotation: normalizeAngle360(rotation)\n    });\n    const labelRotation = defaultRotation + configuredRotation;\n    const optionsMap = this.getDepthOptionsMap(maxDepth);\n    const setLabelProps = (datum, index) => {\n      const depth = maxDepth - datum.depth;\n      if (!optionsMap[depth]?.enabled || index % keepEvery !== 0 || !inRange(datum.screenX, range3)) {\n        return false;\n      }\n      const text2 = this.formatTick(datum.label, index - 1);\n      const labelStyles = this.getLabelStyles({ value: text2, depth }, depthOptions[depth]?.label);\n      tempText.setProperties({\n        ...labelStyles,\n        text: text2,\n        textAlign: \"center\",\n        textBaseline: label.parallel ? \"hanging\" : \"bottom\",\n        rotation: 0,\n        translationX: 0,\n        translationY: datum.screenX\n      });\n      return true;\n    };\n    let maxLeafLabelWidth = 0;\n    const depthLines = {};\n    treeLabels.forEach((datum, index) => {\n      const depth = maxDepth - datum.depth;\n      const nodeLines = countLines(datum.label);\n      depthLines[depth] ?? (depthLines[depth] = 1);\n      if (depthLines[depth] < nodeLines) {\n        depthLines[depth] = nodeLines;\n      }\n      const isVisible = setLabelProps(datum, index);\n      if (!isVisible || !tempText.getBBox())\n        return;\n      labelBBoxes.set(index, tempText.getBBox());\n      if (!datum.leafCount) {\n        tempText.rotation = labelRotation;\n        const { width: width3 } = tempText.getBBox();\n        if (maxLeafLabelWidth < width3) {\n          maxLeafLabelWidth = width3;\n        }\n      }\n    });\n    const idGenerator = createIdsGenerator();\n    const labelX = sideFlag * optionsMap[0].spacing;\n    const separatorData = /* @__PURE__ */ new Map();\n    const nestedPadding = (d) => {\n      let v = maxLeafLabelWidth;\n      for (let i = 1; i <= d; i++) {\n        v += optionsMap[i].spacing;\n        if (label.mirrored || i !== d) {\n          v += depthLines[i] * optionsMap[i].lineHeight;\n        }\n      }\n      return v;\n    };\n    treeLabels.forEach((datum, index) => {\n      if (index === 0)\n        return;\n      const visible = setLabelProps(datum, index);\n      const isLeaf = !datum.children.length;\n      const depth = maxDepth - datum.depth;\n      if (datum.parent) {\n        const separatorX = isLeaf ? datum.x : datum.x - (datum.leafCount - 1) / 2;\n        if (!separatorData.has(separatorX)) {\n          const tickOptions = this.depthOptions[depth]?.tick;\n          let v = maxLeafLabelWidth;\n          for (let i = 0; i <= depth; i++) {\n            v += optionsMap[i].spacing;\n            if (i !== 0) {\n              v += depthLines[i] * optionsMap[i].lineHeight;\n            }\n          }\n          separatorData.set(separatorX, {\n            tickSize: v,\n            tickStroke: tickOptions?.stroke,\n            tickWidth: tickOptions?.enabled !== false ? tickOptions?.width : 0\n          });\n        }\n      }\n      if (!visible)\n        return;\n      tempText.x = labelX;\n      tempText.y = 0;\n      if (isLeaf) {\n        const { width: width3 } = labelBBoxes.get(index);\n        const angleRatio = getAngleRatioRadians(labelRotation);\n        tempText.rotation = labelRotation;\n        tempText.textAlign = \"end\";\n        tempText.textBaseline = \"middle\";\n        tempText.rotationCenterX = labelX - width3 / 2;\n        tempText.translationX = (optionsMap[depth].spacing - width3) / 2 * angleRatio * sideFlag;\n        if (label.mirrored) {\n          tempText.translationX += width3;\n        }\n      } else {\n        tempText.rotation = isHorizontal ? defaultRotation : -Math.PI / 2;\n        tempText.rotationCenterX = labelX;\n        tempText.translationX = sideFlag * nestedPadding(depth);\n      }\n      if (optionsMap[depth].avoidCollisions) {\n        const availableRange = isLeaf ? step : datum.leafCount * step;\n        if (tempText.getBBox().height > availableRange) {\n          labelBBoxes.delete(index);\n          return;\n        }\n      }\n      const { text: text2 = \"\" } = tempText;\n      tickLabelLayout.push({\n        text: text2,\n        visible: true,\n        range: this.scale.range,\n        tickId: idGenerator(text2),\n        fill: tempText.fill,\n        fontFamily: tempText.fontFamily,\n        fontSize: tempText.fontSize,\n        fontStyle: tempText.fontStyle,\n        fontWeight: tempText.fontWeight,\n        rotation: tempText.rotation,\n        rotationCenterX: tempText.rotationCenterX,\n        textAlign: tempText.textAlign,\n        textBaseline: tempText.textBaseline,\n        translationX: tempText.translationX,\n        translationY: tempText.translationY,\n        x: tempText.x,\n        y: tempText.y\n      });\n      labelBBoxes.set(index, Transformable.toCanvas(tempText));\n    });\n    const { enabled, stroke: stroke2, width: width2 } = this.line;\n    this.lineNode.datum = { x: 0, y1: range3[0], y2: range3[1] };\n    this.lineNode.setProperties({ stroke: stroke2, strokeWidth: enabled ? width2 : 0 });\n    const separatorLayout = [...separatorData.values()];\n    separatorLayout.push(separatorLayout[0]);\n    const axisBoxes = [this.lineNode.getBBox(), new BBox(0, 0, separatorLayout[0].tickSize * sideFlag, 0)];\n    if (title.enabled) {\n      this.updateTitle(false, separatorLayout[0].tickSize);\n      axisBoxes.push(title.caption.node.getBBox());\n    }\n    const mergedBBox = BBox.merge(iterate(labelBBoxes.values(), axisBoxes));\n    return {\n      bbox: this.getTransformBox(mergedBBox),\n      separatorLayout,\n      tickLabelLayout\n    };\n  }\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   * Supposed to be called _manually_ after changing _any_ of the axis properties.\n   * This allows to bulk set axis properties before updating the nodes.\n   * The node changes made by this method are rendered on the next animation frame.\n   * We could schedule this method call automatically on the next animation frame\n   * when any of the axis properties change (the way we do when properties of scene graph's\n   * nodes change), but this will mean that we first wait for the next animation\n   * frame to make changes to the nodes of the axis, then wait for another animation\n   * frame to render those changes. It's nice to have everything update automatically,\n   * but this extra level of async indirection will not just introduce an unwanted delay,\n   * it will also make it harder to reason about the program.\n   */\n  update() {\n    if (!this.computedLayout)\n      return;\n    const { tickScale, gridLine, gridLength } = this;\n    const { separatorLayout } = this.computedLayout;\n    const ticksData = tickScale.ticks({\n      nice: false,\n      interval: void 0,\n      tickCount: void 0,\n      minTickCount: 0,\n      maxTickCount: Infinity\n    }).map((tick, index) => ({\n      ...separatorLayout[index],\n      tick,\n      tickId: createDatumId(tick, index),\n      tickLabel: tick.filter(Boolean).join(\" - \"),\n      translationY: Math.round(tickScale.convert(tick))\n    }));\n    this.gridLineGroupSelection.update(gridLine.enabled && gridLength ? ticksData : []);\n    this.tickLineGroupSelection.update(this.tick.enabled ? ticksData : []);\n    this.updatePosition();\n    this.updateCategoryLabels();\n    this.updateAxisLine();\n    this.updateGridLines();\n    this.updateTickLines();\n    this.updateTitle();\n    this.resetSelectionNodes();\n  }\n  calculateLayout() {\n    const { separatorLayout, tickLabelLayout, bbox } = this.computeLayout();\n    this.computedLayout = { separatorLayout, tickLabelLayout };\n    return { bbox, primaryTickCount: void 0, niceDomain: this.scale.domain };\n  }\n  /**\n   * The length of the grid. The grid is only visible in case of a non-zero value.\n   */\n  onGridVisibilityChange() {\n    this.gridLineGroupSelection.clear();\n    this.tickLabelGroupSelection.clear();\n  }\n  updateScale() {\n    super.updateScale();\n    this.tickScale.range = this.scale.range;\n    this.scale.paddingOuter = this.scale.paddingInner / 2;\n  }\n  processData() {\n    const { direction } = this;\n    const flatDomains = this.boundSeries.filter((s) => s.visible).flatMap((series) => series.getDomain(direction));\n    this.dataDomain = { domain: extent(flatDomains) ?? this.filterDuplicateArrays(flatDomains), clipped: false };\n    if (this.isReversed()) {\n      this.dataDomain.domain.reverse();\n    }\n    const domain = this.dataDomain.domain.map(\n      (datum) => (\n        // Handle integrated charts data when provided as an object\n        toArray(isObject(datum) && \"value\" in datum ? datum.value : datum)\n      )\n    );\n    this.tickTreeLayout = treeLayout(domain);\n    const orderedDomain = [];\n    for (const node of this.tickTreeLayout.nodes) {\n      if (node.leafCount || node.refId == null)\n        continue;\n      orderedDomain.push(this.dataDomain.domain[node.refId]);\n    }\n    this.scale.domain = sortBasedOnArray(this.dataDomain.domain, orderedDomain);\n    this.tickScale.domain = domain.concat([[\"\"]]);\n    return { animatable: true };\n  }\n  updateGridLines() {\n    if (!this.gridLength)\n      return;\n    const { width: width2, style } = this.gridLine;\n    const lineSize = this.gridLength * -this.label.getSideFlag();\n    this.gridLineGroupSelection.each((line, datum, index) => {\n      const { stroke: stroke2, lineDash } = style[index % style.length];\n      const y = datum.translationY;\n      line.visible = this.inRange(y);\n      line.x1 = 0;\n      line.x2 = lineSize;\n      line.y = y;\n      line.stroke = stroke2;\n      line.strokeWidth = width2;\n      line.lineDash = lineDash;\n    });\n  }\n  filterDuplicateArrays(array2) {\n    const seen = /* @__PURE__ */ new Set();\n    return array2.filter((item) => {\n      const key = isArray(item) ? JSON.stringify(item) : item;\n      if (seen.has(key))\n        return false;\n      seen.add(key);\n      return true;\n    });\n  }\n};\nGroupedCategoryAxis.className = \"GroupedCategoryAxis\";\nGroupedCategoryAxis.type = \"grouped-category\";\n__decorateClass([\n  Validate(OBJECT_ARRAY)\n], GroupedCategoryAxis.prototype, \"depthOptions\", 2);\n\n// packages/ag-charts-community/src/chart/axis/logAxis.ts\nvar NON_ZERO_NUMBER = predicateWithMessage((value) => isNumber(value) && value !== 0, \"a non-zero number\");\nvar LogAxis = class extends NumberAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new LogScale());\n    this.min = NaN;\n    this.max = NaN;\n  }\n  normaliseDataDomain(d) {\n    const { min, max } = this;\n    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);\n    if (extent2[0] < 0 && extent2[1] > 0 || d[0] < 0 && d[1] > 0) {\n      logger_exports.warn(\n        `The log axis domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.`\n      );\n      return { domain: [], clipped };\n    } else if (extent2[0] === 0 || extent2[1] === 0 || d[0] === 0 || d[1] === 0) {\n      logger_exports.warn(\n        `The log axis domain contains a value of 0, the chart data cannot be rendered. See log axis documentation for more information.`\n      );\n      return { domain: [], clipped };\n    }\n    return { domain: extent2, clipped };\n  }\n  set base(value) {\n    this.scale.base = value;\n  }\n  get base() {\n    return this.scale.base;\n  }\n  defaultDatumFormatter(datum, _fractionDigits) {\n    return String(datum);\n  }\n  defaultLabelFormatter(datum, _fractionDigits) {\n    return String(datum);\n  }\n};\nLogAxis.className = \"LogAxis\";\nLogAxis.type = \"log\";\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, LESS_THAN(\"max\"))),\n  Default(NaN)\n], LogAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, GREATER_THAN(\"min\"))),\n  Default(NaN)\n], LogAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/scene/util/corner.ts\nvar drawCorner = (path, { x0, y0, x1, y1, cx, cy }, cornerRadius, move) => {\n  if (move) {\n    path.moveTo(x0, y0);\n  }\n  if (x0 !== x1 || y0 !== y1) {\n    const r0 = Math.atan2(y0 - cy, x0 - cx);\n    const r1 = Math.atan2(y1 - cy, x1 - cx);\n    path.arc(cx, cy, cornerRadius, r0, r1);\n  } else {\n    path.lineTo(x0, y0);\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/rect.ts\nvar epsilon = 1e-6;\nvar cornerEdges = (leadingEdge, trailingEdge, leadingInset, trailingInset, cornerRadius) => {\n  let leadingClipped = false;\n  let trailingClipped = false;\n  let leading0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - leadingInset ** 2, 0));\n  let leading1 = 0;\n  let trailing0 = 0;\n  let trailing1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - trailingInset ** 2, 0));\n  if (leading0 > leadingEdge) {\n    leadingClipped = true;\n    leading0 = leadingEdge;\n    leading1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (trailingInset - leadingEdge) ** 2));\n  } else if (leading0 < epsilon) {\n    leading0 = 0;\n  }\n  if (trailing1 > trailingEdge) {\n    trailingClipped = true;\n    trailing0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (leadingInset - trailingEdge) ** 2));\n    trailing1 = trailingEdge;\n  } else if (trailing1 < epsilon) {\n    trailing1 = 0;\n  }\n  return { leading0, leading1, trailing0, trailing1, leadingClipped, trailingClipped };\n};\nvar clippedRoundRect = (path, x, y, width2, height2, cornerRadii, clipBBox) => {\n  let {\n    topLeft: topLeftCornerRadius,\n    topRight: topRightCornerRadius,\n    bottomRight: bottomRightCornerRadius,\n    bottomLeft: bottomLeftCornerRadius\n  } = cornerRadii;\n  const maxVerticalCornerRadius = Math.max(\n    topLeftCornerRadius + bottomLeftCornerRadius,\n    topRightCornerRadius + bottomRightCornerRadius\n  );\n  const maxHorizontalCornerRadius = Math.max(\n    topLeftCornerRadius + topRightCornerRadius,\n    bottomLeftCornerRadius + bottomRightCornerRadius\n  );\n  if (maxVerticalCornerRadius <= 0 && maxHorizontalCornerRadius <= 0) {\n    if (clipBBox == null) {\n      path.rect(x, y, width2, height2);\n    } else {\n      path.rect(clipBBox.x, clipBBox.y, clipBBox.width, clipBBox.height);\n    }\n    return;\n  } else if (clipBBox == null && topLeftCornerRadius === topRightCornerRadius && topLeftCornerRadius === bottomRightCornerRadius && topLeftCornerRadius === bottomLeftCornerRadius) {\n    path.roundRect(x, y, width2, height2, topLeftCornerRadius);\n    return;\n  }\n  if (width2 < 0) {\n    x += width2;\n    width2 = Math.abs(width2);\n  }\n  if (height2 < 0) {\n    y += height2;\n    height2 = Math.abs(height2);\n  }\n  if (width2 <= 0 || height2 <= 0)\n    return;\n  if (clipBBox == null) {\n    clipBBox = new BBox(x, y, width2, height2);\n  } else {\n    const x0 = Math.max(x, clipBBox.x);\n    const x1 = Math.min(x + width2, clipBBox.x + clipBBox.width);\n    const y0 = Math.max(y, clipBBox.y);\n    const y1 = Math.min(y + height2, clipBBox.y + clipBBox.height);\n    clipBBox = new BBox(x0, y0, x1 - x0, y1 - y0);\n  }\n  const borderScale = Math.max(maxVerticalCornerRadius / height2, maxHorizontalCornerRadius / width2, 1);\n  if (borderScale > 1) {\n    topLeftCornerRadius /= borderScale;\n    topRightCornerRadius /= borderScale;\n    bottomRightCornerRadius /= borderScale;\n    bottomLeftCornerRadius /= borderScale;\n  }\n  let drawTopLeftCorner = true;\n  let drawTopRightCorner = true;\n  let drawBottomRightCorner = true;\n  let drawBottomLeftCorner = true;\n  let topLeftCorner;\n  let topRightCorner;\n  let bottomRightCorner;\n  let bottomLeftCorner;\n  if (drawTopLeftCorner) {\n    const nodes = cornerEdges(\n      clipBBox.height,\n      clipBBox.width,\n      Math.max(x + topLeftCornerRadius - clipBBox.x, 0),\n      Math.max(y + topLeftCornerRadius - clipBBox.y, 0),\n      topLeftCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawBottomLeftCorner = false;\n    if (nodes.trailingClipped)\n      drawTopRightCorner = false;\n    const x0 = Math.max(clipBBox.x + nodes.leading1, clipBBox.x);\n    const y0 = Math.max(clipBBox.y + nodes.leading0, clipBBox.y);\n    const x1 = Math.max(clipBBox.x + nodes.trailing1, clipBBox.x);\n    const y1 = Math.max(clipBBox.y + nodes.trailing0, clipBBox.y);\n    const cx = x + topLeftCornerRadius;\n    const cy = y + topLeftCornerRadius;\n    topLeftCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawTopRightCorner) {\n    const nodes = cornerEdges(\n      clipBBox.width,\n      clipBBox.height,\n      Math.max(y + topRightCornerRadius - clipBBox.y, 0),\n      Math.max(clipBBox.x + clipBBox.width - (x + width2 - topRightCornerRadius), 0),\n      topRightCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawTopLeftCorner = false;\n    if (nodes.trailingClipped)\n      drawBottomRightCorner = false;\n    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading0, clipBBox.x + clipBBox.width);\n    const y0 = Math.max(clipBBox.y + nodes.leading1, clipBBox.y);\n    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing0, clipBBox.x + clipBBox.width);\n    const y1 = Math.max(clipBBox.y + nodes.trailing1, clipBBox.y);\n    const cx = x + width2 - topRightCornerRadius;\n    const cy = y + topRightCornerRadius;\n    topRightCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawBottomRightCorner) {\n    const nodes = cornerEdges(\n      clipBBox.height,\n      clipBBox.width,\n      Math.max(clipBBox.x + clipBBox.width - (x + width2 - bottomRightCornerRadius), 0),\n      Math.max(clipBBox.y + clipBBox.height - (y + height2 - bottomRightCornerRadius), 0),\n      bottomRightCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawTopRightCorner = false;\n    if (nodes.trailingClipped)\n      drawBottomLeftCorner = false;\n    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading1, clipBBox.x + clipBBox.width);\n    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading0, clipBBox.y + clipBBox.height);\n    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing1, clipBBox.x + clipBBox.width);\n    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing0, clipBBox.y + clipBBox.height);\n    const cx = x + width2 - bottomRightCornerRadius;\n    const cy = y + height2 - bottomRightCornerRadius;\n    bottomRightCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawBottomLeftCorner) {\n    const nodes = cornerEdges(\n      clipBBox.width,\n      clipBBox.height,\n      Math.max(clipBBox.y + clipBBox.height - (y + height2 - bottomLeftCornerRadius), 0),\n      Math.max(x + bottomLeftCornerRadius - clipBBox.x, 0),\n      bottomLeftCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawBottomRightCorner = false;\n    if (nodes.trailingClipped)\n      drawTopLeftCorner = false;\n    const x0 = Math.max(clipBBox.x + nodes.leading0, clipBBox.x);\n    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading1, clipBBox.y + clipBBox.height);\n    const x1 = Math.max(clipBBox.x + nodes.trailing0, clipBBox.x);\n    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing1, clipBBox.y + clipBBox.height);\n    const cx = x + bottomLeftCornerRadius;\n    const cy = y + height2 - bottomLeftCornerRadius;\n    bottomLeftCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  let didMove = false;\n  if (drawTopLeftCorner && topLeftCorner != null) {\n    drawCorner(path, topLeftCorner, topLeftCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawTopRightCorner && topRightCorner != null) {\n    drawCorner(path, topRightCorner, topRightCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawBottomRightCorner && bottomRightCorner != null) {\n    drawCorner(path, bottomRightCorner, bottomRightCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawBottomLeftCorner && bottomLeftCorner != null) {\n    drawCorner(path, bottomLeftCorner, bottomLeftCornerRadius, !didMove);\n  }\n  path.closePath();\n};\nvar Rect = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.borderPath = new ExtendedPath2D();\n    this.x = 0;\n    this.y = 0;\n    this.width = 10;\n    this.height = 10;\n    this.topLeftCornerRadius = 0;\n    this.topRightCornerRadius = 0;\n    this.bottomRightCornerRadius = 0;\n    this.bottomLeftCornerRadius = 0;\n    this.clipBBox = void 0;\n    this.crisp = false;\n    this.lastUpdatePathStrokeWidth = Shape.defaultStyles.strokeWidth;\n    this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;\n    this.hittester = super.isPointInPath.bind(this);\n    this.distanceCalculator = super.distanceSquaredTransformedPoint.bind(this);\n    /**\n     * When the rectangle's width or height is less than a pixel\n     * and crisp mode is on, the rectangle will still fit into the pixel,\n     * but will be less opaque to make an effect of holding less space.\n     */\n    this.microPixelEffectOpacity = 1;\n  }\n  set cornerRadius(cornerRadius) {\n    this.topLeftCornerRadius = cornerRadius;\n    this.topRightCornerRadius = cornerRadius;\n    this.bottomRightCornerRadius = cornerRadius;\n    this.bottomLeftCornerRadius = cornerRadius;\n  }\n  isDirtyPath() {\n    return this.lastUpdatePathStrokeWidth !== this.strokeWidth || Boolean(this.path.isDirty() || this.borderPath.isDirty());\n  }\n  updatePath() {\n    const {\n      path,\n      borderPath,\n      crisp,\n      topLeftCornerRadius: topLeft,\n      topRightCornerRadius: topRight,\n      bottomRightCornerRadius: bottomRight,\n      bottomLeftCornerRadius: bottomLeft\n    } = this;\n    let { x, y, width: w, height: h, strokeWidth, clipBBox } = this;\n    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;\n    const pixelSize = 1 / pixelRatio;\n    let microPixelEffectOpacity = 1;\n    path.clear(true);\n    borderPath.clear(true);\n    if (crisp) {\n      if (w <= pixelSize) {\n        microPixelEffectOpacity *= w / pixelSize;\n      }\n      if (h <= pixelSize) {\n        microPixelEffectOpacity *= h / pixelSize;\n      }\n      w = this.align(x, w);\n      h = this.align(y, h);\n      x = this.align(x);\n      y = this.align(y);\n      clipBBox = clipBBox != null ? new BBox(\n        this.align(clipBBox.x),\n        this.align(clipBBox.y),\n        this.align(clipBBox.x, clipBBox.width),\n        this.align(clipBBox.y, clipBBox.height)\n      ) : void 0;\n    }\n    if (strokeWidth) {\n      if (w < pixelSize) {\n        const lx = x + pixelSize / 2;\n        borderPath.moveTo(lx, y);\n        borderPath.lineTo(lx, y + h);\n        strokeWidth = pixelSize;\n        this.borderClipPath = void 0;\n      } else if (h < pixelSize) {\n        const ly = y + pixelSize / 2;\n        borderPath.moveTo(x, ly);\n        borderPath.lineTo(x + w, ly);\n        strokeWidth = pixelSize;\n        this.borderClipPath = void 0;\n      } else if (strokeWidth < w && strokeWidth < h) {\n        const halfStrokeWidth = strokeWidth / 2;\n        x += halfStrokeWidth;\n        y += halfStrokeWidth;\n        w -= strokeWidth;\n        h -= strokeWidth;\n        const adjustedClipBBox = clipBBox?.clone().shrink(halfStrokeWidth);\n        const cornerRadii = {\n          topLeft: topLeft > 0 ? topLeft - strokeWidth : 0,\n          topRight: topRight > 0 ? topRight - strokeWidth : 0,\n          bottomRight: bottomRight > 0 ? bottomRight - strokeWidth : 0,\n          bottomLeft: bottomLeft > 0 ? bottomLeft - strokeWidth : 0\n        };\n        this.borderClipPath = void 0;\n        if (w > 0 && h > 0 && (adjustedClipBBox == null || adjustedClipBBox?.width > 0 && adjustedClipBBox?.height > 0)) {\n          clippedRoundRect(path, x, y, w, h, cornerRadii, adjustedClipBBox);\n          clippedRoundRect(borderPath, x, y, w, h, cornerRadii, adjustedClipBBox);\n        }\n      } else {\n        this.borderClipPath = this.borderClipPath ?? new ExtendedPath2D();\n        this.borderClipPath.clear(true);\n        this.borderClipPath.rect(x, y, w, h);\n        borderPath.rect(x, y, w, h);\n      }\n    } else {\n      const cornerRadii = { topLeft, topRight, bottomRight, bottomLeft };\n      this.borderClipPath = void 0;\n      clippedRoundRect(path, x, y, w, h, cornerRadii, clipBBox);\n    }\n    if ([topLeft, topRight, bottomRight, bottomLeft].every((r) => r === 0)) {\n      const bbox = this.getBBox();\n      this.hittester = bbox.containsPoint.bind(bbox);\n      this.distanceSquared = (hitX, hitY) => this.getBBox().distanceSquared(hitX, hitY);\n    } else {\n      this.hittester = super.isPointInPath;\n      this.distanceCalculator = super.distanceSquaredTransformedPoint;\n    }\n    this.effectiveStrokeWidth = strokeWidth;\n    this.lastUpdatePathStrokeWidth = strokeWidth;\n    this.microPixelEffectOpacity = microPixelEffectOpacity;\n  }\n  computeBBox() {\n    const { x, y, width: width2, height: height2, clipBBox } = this;\n    return clipBBox?.clone() ?? new BBox(x, y, width2, height2);\n  }\n  isPointInPath(x, y) {\n    return this.hittester(x, y);\n  }\n  get midPoint() {\n    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };\n  }\n  distanceSquared(x, y) {\n    return this.distanceCalculator(x, y);\n  }\n  applyFillAlpha(ctx) {\n    const { fillOpacity, microPixelEffectOpacity, opacity } = this;\n    ctx.globalAlpha *= opacity * fillOpacity * microPixelEffectOpacity;\n  }\n  renderStroke(ctx) {\n    const { stroke: stroke2, effectiveStrokeWidth } = this;\n    if (stroke2 && effectiveStrokeWidth) {\n      const { globalAlpha } = ctx;\n      const {\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        lineCap,\n        lineJoin,\n        borderPath,\n        borderClipPath,\n        opacity,\n        microPixelEffectOpacity\n      } = this;\n      if (borderClipPath) {\n        ctx.clip(borderClipPath.getPath2D());\n      }\n      this.applyStroke(ctx);\n      ctx.globalAlpha *= opacity * strokeOpacity * microPixelEffectOpacity;\n      ctx.lineWidth = effectiveStrokeWidth;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      ctx.stroke(borderPath.getPath2D());\n      ctx.globalAlpha = globalAlpha;\n    }\n  }\n};\nRect.className = \"Rect\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"y\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"width\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"height\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"topLeftCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"topRightCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"bottomRightCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"bottomLeftCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"clipBBox\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"crisp\", 2);\n\n// packages/ag-charts-community/src/chart/background/background.ts\nvar Background = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.rectNode = new Rect();\n    this.textNode = new Text();\n    this.fill = \"white\";\n    this.node = this.createNode();\n    this.node.append([this.rectNode, this.textNode]);\n    this.visible = true;\n    this.destroyFns.push(\n      ctx.scene.attachNode(this.node),\n      ctx.layoutManager.addListener(\"layout:complete\", (e) => this.onLayoutComplete(e))\n    );\n  }\n  createNode() {\n    return new Group({ name: \"background\", zIndex: 0 /* CHART_BACKGROUND */ });\n  }\n  onLayoutComplete(e) {\n    const { width: width2, height: height2 } = e.chart;\n    this.rectNode.width = width2;\n    this.rectNode.height = height2;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  ProxyPropertyOnWrite(\"node\", \"visible\")\n], Background.prototype, \"visible\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"rectNode\", \"fill\")\n], Background.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], Background.prototype, \"image\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"textNode\")\n], Background.prototype, \"text\", 2);\n\n// packages/ag-charts-community/src/chart/background/backgroundModule.ts\nvar BackgroundModule = {\n  type: \"root\",\n  optionsKey: \"background\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n  moduleFactory: (ctx) => new Background(ctx)\n};\n\n// packages/ag-charts-community/src/chart/gridLayout.ts\nfunction gridLayout({\n  orientation,\n  bboxes,\n  maxHeight,\n  maxWidth,\n  itemPaddingY = 0,\n  itemPaddingX = 0,\n  forceResult = false\n}) {\n  const horizontal = orientation === \"horizontal\";\n  const primary = {\n    max: horizontal ? maxWidth : maxHeight,\n    fn: horizontal ? (b) => b.width : (b) => b.height,\n    padding: horizontal ? itemPaddingX : itemPaddingY\n  };\n  const secondary = {\n    max: horizontal ? maxHeight : maxWidth,\n    fn: horizontal ? (b) => b.height : (b) => b.width,\n    padding: horizontal ? itemPaddingY : itemPaddingX\n  };\n  let processedBBoxCount = 0;\n  const rawPages = [];\n  while (processedBBoxCount < bboxes.length) {\n    const unprocessedBBoxes = bboxes.slice(processedBBoxCount);\n    const result = processBBoxes(unprocessedBBoxes, processedBBoxCount, primary, secondary, forceResult);\n    if (!result) {\n      return;\n    }\n    processedBBoxCount += result.processedBBoxCount;\n    rawPages.push(result.pageIndices);\n  }\n  return buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX);\n}\nfunction processBBoxes(bboxes, indexOffset, primary, secondary, forceResult) {\n  const minGuess = 1;\n  let startingGuess = estimateStartingGuess(bboxes, primary);\n  if (startingGuess < minGuess) {\n    if (!forceResult) {\n      return;\n    }\n    startingGuess = minGuess;\n  }\n  let guess = startingGuess;\n  while (guess >= minGuess) {\n    const pageIndices = calculatePage(bboxes, indexOffset, guess, primary, secondary, forceResult);\n    if (pageIndices == null && guess <= minGuess) {\n      return;\n    }\n    if (pageIndices == null) {\n      guess--;\n      continue;\n    }\n    if (typeof pageIndices === \"number\") {\n      if (pageIndices <= minGuess) {\n        return;\n      }\n      guess = pageIndices < guess && pageIndices > minGuess ? pageIndices : guess;\n      guess--;\n      continue;\n    }\n    const processedBBoxCount = pageIndices.length * pageIndices[0].length;\n    return { processedBBoxCount, pageIndices };\n  }\n}\nfunction calculatePage(bboxes, indexOffset, primaryCount, primary, secondary, forceResult) {\n  const result = [];\n  let sumSecondary = 0;\n  let currentMaxSecondary = 0;\n  let currentPrimaryIndices = [];\n  const maxPrimaryValues = [];\n  for (let bboxIndex = 0; bboxIndex < bboxes.length; bboxIndex++) {\n    const primaryValueIdx = (bboxIndex + primaryCount) % primaryCount;\n    if (primaryValueIdx === 0) {\n      sumSecondary += currentMaxSecondary;\n      currentMaxSecondary = 0;\n      if (currentPrimaryIndices.length > 0) {\n        result.push(currentPrimaryIndices);\n      }\n      currentPrimaryIndices = [];\n    }\n    const primaryValue = primary.fn(bboxes[bboxIndex]) + primary.padding;\n    maxPrimaryValues[primaryValueIdx] = Math.max(maxPrimaryValues[primaryValueIdx] ?? 0, primaryValue);\n    currentMaxSecondary = Math.max(currentMaxSecondary, secondary.fn(bboxes[bboxIndex]) + secondary.padding);\n    const currentSecondaryDimension = sumSecondary + currentMaxSecondary;\n    const returnResult = !forceResult || result.length > 0;\n    if (currentSecondaryDimension > secondary.max && returnResult) {\n      currentPrimaryIndices = [];\n      break;\n    }\n    const sumPrimary = maxPrimaryValues.reduce((sum2, next) => sum2 + next, 0);\n    if (sumPrimary > primary.max && !forceResult) {\n      if (maxPrimaryValues.length < primaryCount) {\n        return maxPrimaryValues.length;\n      }\n      return;\n    }\n    currentPrimaryIndices.push(bboxIndex + indexOffset);\n  }\n  if (currentPrimaryIndices.length > 0) {\n    result.push(currentPrimaryIndices);\n  }\n  return result.length > 0 ? result : void 0;\n}\nfunction buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX) {\n  let maxPageWidth = 0;\n  let maxPageHeight = 0;\n  const pages = rawPages.map((indices) => {\n    if (orientation === \"horizontal\") {\n      indices = transpose(indices);\n    }\n    let endIndex = 0;\n    const columns = indices.map((colIndices) => {\n      const colBBoxes = colIndices.map((bboxIndex) => {\n        endIndex = Math.max(bboxIndex, endIndex);\n        return bboxes[bboxIndex];\n      });\n      let columnHeight = 0;\n      let columnWidth = 0;\n      colBBoxes.forEach((bbox) => {\n        columnHeight += bbox.height + itemPaddingY;\n        columnWidth = Math.max(columnWidth, bbox.width + itemPaddingX);\n      });\n      return {\n        indices: colIndices,\n        bboxes: colBBoxes,\n        columnHeight: Math.ceil(columnHeight),\n        columnWidth: Math.ceil(columnWidth)\n      };\n    });\n    let pageWidth = 0;\n    let pageHeight = 0;\n    columns.forEach((column) => {\n      pageWidth += column.columnWidth;\n      pageHeight = Math.max(pageHeight, column.columnHeight);\n    });\n    maxPageWidth = Math.max(pageWidth, maxPageWidth);\n    maxPageHeight = Math.max(pageHeight, maxPageHeight);\n    return {\n      columns,\n      startIndex: indices[0][0],\n      endIndex,\n      pageWidth,\n      pageHeight\n    };\n  });\n  return { pages, maxPageWidth, maxPageHeight };\n}\nfunction transpose(data) {\n  const result = [];\n  for (const _ of data[0]) {\n    result.push([]);\n  }\n  data.forEach((innerData, dataIdx) => {\n    innerData.forEach((item, itemIdx) => {\n      result[itemIdx][dataIdx] = item;\n    });\n  });\n  return result;\n}\nfunction estimateStartingGuess(bboxes, primary) {\n  const n = bboxes.length;\n  let primarySum = 0;\n  for (let bboxIndex = 0; bboxIndex < n; bboxIndex++) {\n    primarySum += primary.fn(bboxes[bboxIndex]) + primary.padding;\n    if (primarySum > primary.max) {\n      const ratio2 = n / bboxIndex;\n      if (ratio2 < 2) {\n        return Math.ceil(n / 2);\n      }\n      return bboxIndex;\n    }\n  }\n  return n;\n}\n\n// packages/ag-charts-community/src/chart/pagination/pagination.ts\nvar PaginationLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.color = \"black\";\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING)\n], PaginationLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], PaginationLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], PaginationLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], PaginationLabel.prototype, \"fontFamily\", 2);\nvar PaginationMarkerStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.size = 15;\n    this.fill = void 0;\n    this.fillOpacity = void 0;\n    this.stroke = void 0;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarkerStyle.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], PaginationMarkerStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], PaginationMarkerStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], PaginationMarkerStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarkerStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PaginationMarkerStyle.prototype, \"strokeOpacity\", 2);\nvar PaginationMarker = class extends BaseProperties {\n  constructor(parent) {\n    super();\n    this.parent = parent;\n    this.shape = \"triangle\";\n    this.size = 15;\n    this.padding = 8;\n  }\n};\n__decorateClass([\n  ActionOnSet({\n    changeValue() {\n      if (this.parent.marker === this) {\n        this.parent.onMarkerShapeChange();\n      }\n    }\n  })\n], PaginationMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarker.prototype, \"padding\", 2);\nvar Pagination = class extends BaseProperties {\n  constructor(chartUpdateCallback, pageUpdateCallback) {\n    super();\n    this.chartUpdateCallback = chartUpdateCallback;\n    this.pageUpdateCallback = pageUpdateCallback;\n    this.id = createId(this);\n    this.marker = new PaginationMarker(this);\n    this.activeStyle = new PaginationMarkerStyle();\n    this.inactiveStyle = new PaginationMarkerStyle();\n    this.highlightStyle = new PaginationMarkerStyle();\n    this.label = new PaginationLabel();\n    this.group = new TranslatableGroup({ name: \"pagination\" });\n    this.labelNode = new Text();\n    this.totalPages = 0;\n    this.currentPage = 0;\n    this.translationX = 0;\n    this.translationY = 0;\n    this.nextButtonDisabled = false;\n    this.previousButtonDisabled = false;\n    this._visible = true;\n    this._enabled = true;\n    this._orientation = \"vertical\";\n    this.nextButton = new Marker();\n    this.previousButton = new Marker();\n    this.labelNode.setProperties({\n      textBaseline: \"middle\",\n      fontSize: 12,\n      fontFamily: \"Verdana, sans-serif\",\n      fill: \"black\",\n      y: 1\n    });\n    this.group.append([this.nextButton, this.previousButton, this.labelNode]);\n    this.update();\n    this.updateMarkers();\n  }\n  set visible(value) {\n    this._visible = value;\n    this.updateGroupVisibility();\n  }\n  get visible() {\n    return this._visible;\n  }\n  set enabled(value) {\n    this._enabled = value;\n    this.updateGroupVisibility();\n  }\n  get enabled() {\n    return this._enabled;\n  }\n  updateGroupVisibility() {\n    this.group.visible = this.enabled && this.visible;\n  }\n  set orientation(value) {\n    this._orientation = value;\n    switch (value) {\n      case \"horizontal\": {\n        this.previousButton.rotation = -Math.PI / 2;\n        this.nextButton.rotation = Math.PI / 2;\n        break;\n      }\n      case \"vertical\":\n      default: {\n        this.previousButton.rotation = 0;\n        this.nextButton.rotation = Math.PI;\n      }\n    }\n  }\n  get orientation() {\n    return this._orientation;\n  }\n  update() {\n    this.updateLabel();\n    this.updatePositions();\n    this.enableOrDisableButtons();\n  }\n  updatePositions() {\n    this.group.translationX = this.translationX;\n    this.group.translationY = this.translationY;\n    this.updateLabelPosition();\n    this.updateNextButtonPosition();\n  }\n  updateLabelPosition() {\n    const { size: markerSize, padding: markerPadding } = this.marker;\n    this.nextButton.size = markerSize;\n    this.previousButton.size = markerSize;\n    this.labelNode.x = markerSize / 2 + markerPadding;\n  }\n  updateNextButtonPosition() {\n    const labelBBox = this.labelNode.getBBox();\n    this.nextButton.translationX = labelBBox.width + (this.marker.size / 2 + this.marker.padding) * 2;\n  }\n  updateLabel() {\n    const {\n      currentPage,\n      totalPages: pages,\n      labelNode,\n      label: { color, fontStyle, fontWeight, fontSize, fontFamily }\n    } = this;\n    labelNode.text = `${currentPage + 1} / ${pages}`;\n    labelNode.fill = color;\n    labelNode.fontStyle = fontStyle;\n    labelNode.fontWeight = fontWeight;\n    labelNode.fontSize = fontSize;\n    labelNode.fontFamily = fontFamily;\n  }\n  updateMarkers() {\n    const {\n      nextButton,\n      previousButton,\n      nextButtonDisabled,\n      previousButtonDisabled,\n      activeStyle,\n      inactiveStyle,\n      highlightStyle,\n      highlightActive\n    } = this;\n    const buttonStyle = (button, disabled) => {\n      if (disabled) {\n        return inactiveStyle;\n      } else if (button === highlightActive) {\n        return highlightStyle;\n      }\n      return activeStyle;\n    };\n    this.updateMarker(nextButton, buttonStyle(\"next\", nextButtonDisabled));\n    this.updateMarker(previousButton, buttonStyle(\"previous\", previousButtonDisabled));\n  }\n  updateMarker(marker, style) {\n    const { shape, size } = this.marker;\n    marker.shape = shape;\n    marker.size = size;\n    marker.fill = style.fill;\n    marker.fillOpacity = style.fillOpacity ?? 1;\n    marker.stroke = style.stroke;\n    marker.strokeWidth = style.strokeWidth;\n    marker.strokeOpacity = style.strokeOpacity;\n  }\n  enableOrDisableButtons() {\n    const { currentPage, totalPages } = this;\n    const zeroPagesToDisplay = totalPages === 0;\n    const onLastPage = currentPage === totalPages - 1;\n    const onFirstPage = currentPage === 0;\n    this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;\n    this.previousButtonDisabled = onFirstPage || zeroPagesToDisplay;\n  }\n  setPage(pageNumber) {\n    pageNumber = clamp(0, pageNumber, Math.max(0, this.totalPages - 1));\n    if (this.currentPage !== pageNumber) {\n      this.currentPage = pageNumber;\n      this.onPaginationChanged();\n    }\n  }\n  getCursor(node) {\n    return { previous: this.previousButtonDisabled, next: this.nextButtonDisabled }[node] ? void 0 : \"pointer\";\n  }\n  onClick(event, node) {\n    event.preventDefault();\n    if (node === \"next\" && !this.nextButtonDisabled) {\n      this.incrementPage();\n      this.onPaginationChanged();\n    } else if (node === \"previous\" && !this.previousButtonDisabled) {\n      this.decrementPage();\n      this.onPaginationChanged();\n    }\n  }\n  onMouseHover(node) {\n    this.highlightActive = node;\n    this.updateMarkers();\n    this.chartUpdateCallback(6 /* SCENE_RENDER */);\n  }\n  onPaginationChanged() {\n    this.pageUpdateCallback(this.currentPage);\n  }\n  incrementPage() {\n    this.currentPage = Math.min(this.currentPage + 1, this.totalPages - 1);\n  }\n  decrementPage() {\n    this.currentPage = Math.max(this.currentPage - 1, 0);\n  }\n  onMarkerShapeChange() {\n    this.updatePositions();\n    this.updateMarkers();\n    this.chartUpdateCallback(6 /* SCENE_RENDER */);\n  }\n  attachPagination(node) {\n    node.append(this.group);\n  }\n  getBBox() {\n    return this.group.getBBox();\n  }\n  computeCSSBounds() {\n    const prev = Transformable.toCanvas(this.previousButton);\n    const next = Transformable.toCanvas(this.nextButton);\n    return { prev, next };\n  }\n};\nPagination.className = \"Pagination\";\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"activeStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"inactiveStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"highlightStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"label\", 2);\n\n// packages/ag-charts-community/src/scene/util/changeDetectableProperties.ts\nvar ChangeDetectableProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this._dirty = true;\n  }\n  markDirty() {\n    this._dirty = true;\n  }\n  markClean(_opts) {\n    this._dirty = false;\n  }\n  isDirty() {\n    return this._dirty;\n  }\n};\n\n// packages/ag-charts-community/src/chart/marker/util.ts\nvar MARKER_SUPPORTED_SHAPES = /* @__PURE__ */ new Set([\n  \"circle\",\n  \"cross\",\n  \"diamond\",\n  \"heart\",\n  \"pin\",\n  \"plus\",\n  \"square\",\n  \"star\",\n  \"triangle\"\n]);\nfunction isSupportedMarkerShape(shape) {\n  return typeof shape === \"string\" && MARKER_SUPPORTED_SHAPES.has(shape);\n}\n\n// packages/ag-charts-community/src/chart/series/seriesMarker.ts\nvar MARKER_SHAPE = predicateWithMessage(\n  (value) => isSupportedMarkerShape(value) || typeof value === \"function\",\n  `a marker shape keyword such as 'circle', 'diamond' or 'square' or an object extending the Marker class`\n);\nvar SeriesMarker = class extends ChangeDetectableProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.shape = \"circle\";\n    this.size = 6;\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n  }\n  getStyle() {\n    const { size, shape, fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this;\n    return { size, shape, fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset };\n  }\n  getDiameter() {\n    return this.size + this.strokeWidth;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  SceneChangeDetection()\n], SeriesMarker.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(MARKER_SHAPE),\n  SceneChangeDetection()\n], SeriesMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection()\n], SeriesMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  SceneChangeDetection()\n], SeriesMarker.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO),\n  SceneChangeDetection()\n], SeriesMarker.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  SceneChangeDetection()\n], SeriesMarker.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection()\n], SeriesMarker.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO),\n  SceneChangeDetection()\n], SeriesMarker.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], SeriesMarker.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], SeriesMarker.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true }),\n  SceneChangeDetection()\n], SeriesMarker.prototype, \"itemStyler\", 2);\n\n// packages/ag-charts-community/src/chart/series/shapeUtil.ts\nfunction applyShapeStyle(shape, style, overrides) {\n  shape.fill = overrides?.fill ?? style.fill;\n  shape.fillOpacity = overrides?.fillOpacity ?? style.fillOpacity ?? 1;\n  shape.stroke = overrides?.stroke ?? style.stroke;\n  shape.strokeOpacity = overrides?.strokeOpacity ?? style.strokeOpacity ?? 1;\n  shape.strokeWidth = overrides?.strokeWidth ?? style.strokeWidth ?? 0;\n  shape.lineDash = overrides?.lineDash ?? style.lineDash;\n  shape.lineDashOffset = overrides?.lineDashOffset ?? style.lineDashOffset ?? 0;\n}\n\n// packages/ag-charts-community/src/chart/legend/legendDOMProxy.ts\nvar LegendDOMProxy = class {\n  constructor(ctx, idPrefix) {\n    this.idPrefix = idPrefix;\n    this.dirty = true;\n    this.destroyFns = new DestroyFns();\n    this.itemList = ctx.proxyInteractionService.createProxyContainer({\n      type: \"list\",\n      domManagerId: `${idPrefix}-toolbar`,\n      classList: [\"ag-charts-proxy-legend-toolbar\"],\n      ariaLabel: { id: \"ariaLabelLegend\" }\n    });\n    this.paginationGroup = ctx.proxyInteractionService.createProxyContainer({\n      type: \"group\",\n      domManagerId: `${idPrefix}-pagination`,\n      classList: [\"ag-charts-proxy-legend-pagination\"],\n      ariaLabel: { id: \"ariaLabelLegendPagination\" },\n      ariaOrientation: \"horizontal\"\n    });\n    this.itemDescription = createElement(\"p\");\n    this.itemDescription.style.display = \"none\";\n    this.itemDescription.id = `${idPrefix}-ariaDescription`;\n    this.itemDescription.textContent = this.getItemAriaDescription(ctx.localeManager);\n    this.itemList.getElement().append(this.itemDescription);\n  }\n  destroy() {\n    this.destroyFns.destroy();\n  }\n  initLegendList(params) {\n    if (!this.dirty)\n      return;\n    const { ctx, itemSelection, datumReader, itemListener } = params;\n    const lm = ctx.localeManager;\n    const count = itemSelection.length;\n    itemSelection.each((markerLabel, datum, index) => {\n      markerLabel.proxyButton?.destroy();\n      markerLabel.proxyButton = ctx.proxyInteractionService.createProxyElement({\n        type: \"listswitch\",\n        textContent: this.getItemAriaText(lm, datumReader.getItemLabel(datum), index, count),\n        ariaChecked: !!markerLabel.datum.enabled,\n        ariaDescribedBy: this.itemDescription.id,\n        parent: this.itemList\n      });\n      const button = markerLabel.proxyButton;\n      button.addListener(\"click\", (ev) => itemListener.onClick(ev.sourceEvent, markerLabel.datum, button));\n      button.addListener(\"dblclick\", (ev) => itemListener.onDoubleClick(ev.sourceEvent, markerLabel.datum));\n      button.addListener(\"mouseenter\", (ev) => itemListener.onHover(ev.sourceEvent, markerLabel));\n      button.addListener(\"mouseleave\", () => itemListener.onLeave());\n      button.addListener(\"contextmenu\", (ev) => itemListener.onContextClick(ev.sourceEvent, markerLabel));\n      button.addListener(\"blur\", () => itemListener.onLeave());\n      button.addListener(\"focus\", (ev) => itemListener.onHover(ev.sourceEvent, markerLabel));\n      button.addListener(\"drag-start\", () => {\n      });\n    });\n    this.dirty = false;\n  }\n  update(params) {\n    if (params.visible) {\n      this.initLegendList(params);\n      this.updateItemProxyButtons(params);\n      this.updatePaginationProxyButtons(params, true);\n    }\n    this.updateVisibility(params.visible);\n  }\n  updateVisibility(visible) {\n    this.itemList.setHidden(!visible);\n    this.paginationGroup.setHidden(!visible);\n  }\n  updateItemProxyButtons({ itemSelection, group, pagination, interactive }) {\n    const groupBBox = Transformable.toCanvas(group);\n    this.itemList.setBounds(groupBBox);\n    const maxHeight = Math.max(...itemSelection.nodes().map((l) => l.getBBox().height));\n    itemSelection.each((l, _datum) => {\n      if (l.proxyButton) {\n        const visible = l.pageIndex === pagination.currentPage;\n        const { x, y, height: height2, width: width2 } = Transformable.toCanvas(l);\n        const margin = (maxHeight - height2) / 2;\n        const bbox = { x: x - groupBBox.x, y: y - margin - groupBBox.y, height: maxHeight, width: width2 };\n        l.proxyButton.setCursor(\"pointer\");\n        l.proxyButton.setEnabled(interactive && visible);\n        l.proxyButton.setBounds(bbox);\n      }\n    });\n  }\n  updatePaginationProxyButtons(params, init) {\n    const { pagination } = params;\n    this.paginationGroup.setHidden(!pagination.visible);\n    if (init && \"ctx\" in params) {\n      const { ctx, oldPages, newPages } = params;\n      const oldNeedsButtons = (oldPages?.length ?? newPages.length) > 1;\n      const newNeedsButtons = newPages.length > 1;\n      if (oldNeedsButtons !== newNeedsButtons) {\n        if (newNeedsButtons) {\n          this.prevButton = ctx.proxyInteractionService.createProxyElement({\n            type: \"button\",\n            id: `${this.idPrefix}-prev-page`,\n            textContent: { id: \"ariaLabelLegendPagePrevious\" },\n            tabIndex: 0,\n            parent: this.paginationGroup\n          });\n          this.prevButton.addListener(\"click\", (ev) => this.onPageButton(params, ev, \"previous\"));\n          this.prevButton.addListener(\"mouseenter\", () => pagination.onMouseHover(\"previous\"));\n          this.prevButton.addListener(\"mouseleave\", () => pagination.onMouseHover(void 0));\n          this.nextButton ?? (this.nextButton = ctx.proxyInteractionService.createProxyElement({\n            type: \"button\",\n            id: `${this.idPrefix}-next-page`,\n            textContent: { id: \"ariaLabelLegendPageNext\" },\n            tabIndex: 0,\n            parent: this.paginationGroup\n          }));\n          this.nextButton.addListener(\"click\", (ev) => this.onPageButton(params, ev, \"next\"));\n          this.nextButton.addListener(\"mouseenter\", () => pagination.onMouseHover(\"next\"));\n          this.nextButton.addListener(\"mouseleave\", () => pagination.onMouseHover(void 0));\n        } else {\n          this.nextButton?.destroy();\n          this.prevButton?.destroy();\n          this.nextButton = void 0;\n          this.prevButton = void 0;\n        }\n      }\n    }\n    const { prev, next } = pagination.computeCSSBounds();\n    this.prevButton?.setBounds(prev);\n    this.nextButton?.setBounds(next);\n    this.prevButton?.setEnabled(pagination.currentPage !== 0);\n    this.nextButton?.setEnabled(pagination.currentPage !== pagination.totalPages - 1);\n    this.nextButton?.setCursor(pagination.getCursor(\"next\"));\n    this.prevButton?.setCursor(pagination.getCursor(\"previous\"));\n  }\n  onPageButton(params, ev, node) {\n    params.pagination.onClick(ev.sourceEvent, node);\n    this.updatePaginationProxyButtons(params, false);\n  }\n  onDataUpdate(oldData, newData) {\n    this.dirty = oldData.length !== newData.length || oldData.some((_v, index, _a) => {\n      const [newValue, oldValue] = [newData[index], oldData[index]];\n      return newValue.id !== oldValue.id;\n    });\n  }\n  onLocaleChanged(localeManager, itemSelection, datumReader) {\n    const count = itemSelection.length;\n    itemSelection.each(({ proxyButton }, datum, index) => {\n      const button = proxyButton?.getElement();\n      if (button != null) {\n        const label = datumReader.getItemLabel(datum);\n        button.textContent = this.getItemAriaText(localeManager, label, index, count);\n      }\n    });\n    this.itemDescription.textContent = this.getItemAriaDescription(localeManager);\n  }\n  onPageChange(params) {\n    this.updateItemProxyButtons(params);\n    this.updatePaginationProxyButtons(params, false);\n  }\n  getItemAriaText(localeManager, label, index, count) {\n    if (index >= 0 && label) {\n      index++;\n      return localeManager.t(\"ariaLabelLegendItem\", { label, index, count });\n    }\n    return localeManager.t(\"ariaLabelLegendItemUnknown\");\n  }\n  getItemAriaDescription(localeManager) {\n    return localeManager.t(\"ariaDescriptionLegendItem\");\n  }\n};\n\n// packages/ag-charts-community/src/chart/legend/legendEvent.ts\nfunction makeLegendItemEvent(type, itemId, seriesId, event) {\n  const result = {\n    defaultPrevented: false,\n    apiEvent: {\n      type,\n      itemId,\n      seriesId,\n      event,\n      preventDefault: () => result.defaultPrevented = true\n    }\n  };\n  return result;\n}\n\n// packages/ag-charts-community/src/chart/legend/legendMarkerLabel.ts\nvar LegendMarkerLabel = class extends Translatable(Group) {\n  constructor() {\n    super({ name: \"markerLabelGroup\" });\n    this.symbolsGroup = this.appendChild(\n      new Group({\n        name: \"legend-markerLabel-symbols\"\n      })\n    );\n    this.label = this.appendChild(new Text());\n    this.enabled = true;\n    this.pageIndex = NaN;\n    this.spacing = 0;\n    this.length = 0;\n    this.isCustomMarker = false;\n    this.marker = this.symbolsGroup.appendChild(new Marker({ zIndex: 1 }));\n    this.line = this.symbolsGroup.appendChild(new Line({ zIndex: 0 }));\n    const { label, line, symbolsGroup } = this;\n    line.visible = false;\n    symbolsGroup.renderToOffscreenCanvas = true;\n    symbolsGroup.optimizeForInfrequentRedraws = true;\n    label.textBaseline = \"middle\";\n    label.fontSize = 12;\n    label.fontFamily = \"Verdana, sans-serif\";\n    label.fill = \"black\";\n    label.y = 1;\n  }\n  destroy() {\n    super.destroy();\n    this.proxyButton?.destroy();\n  }\n  setEnabled(enabled) {\n    this.enabled = enabled;\n    this.refreshVisibilities();\n  }\n  refreshVisibilities() {\n    const opacity = this.enabled ? 1 : 0.5;\n    this.label.opacity = opacity;\n    this.opacity = opacity;\n  }\n  layout() {\n    const { marker, line, length: length2, isCustomMarker } = this;\n    let centerTranslateX = 0;\n    let centerTranslateY = 0;\n    if (marker.visible) {\n      const { size } = marker;\n      const anchor = Marker.anchor(marker.shape);\n      centerTranslateX = (anchor.x - 0.5) * size + length2 / 2;\n      centerTranslateY = (anchor.y - 0.5) * size;\n      if (isCustomMarker) {\n        marker.x = 0;\n        marker.y = 0;\n        marker.translationX = centerTranslateX;\n        marker.translationY = centerTranslateY;\n      } else {\n        marker.x = centerTranslateX;\n        marker.y = centerTranslateY;\n        marker.translationX = 0;\n        marker.translationY = 0;\n      }\n    }\n    if (line.visible) {\n      line.x1 = 0;\n      line.x2 = length2;\n      line.y1 = 0;\n      line.y2 = 0;\n    }\n  }\n  preRender(renderCtx) {\n    const out = super.preRender(renderCtx);\n    this.layout();\n    return out;\n  }\n  layoutLabel() {\n    const { length: length2, spacing } = this;\n    this.label.x = length2 + spacing;\n  }\n  computeBBox() {\n    this.layout();\n    return super.computeBBox();\n  }\n};\nLegendMarkerLabel.className = \"MarkerLabel\";\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"text\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\", \"fill\")\n], LegendMarkerLabel.prototype, \"color\", 2);\n__decorateClass([\n  ObserveChanges((target) => target.layoutLabel())\n], LegendMarkerLabel.prototype, \"spacing\", 2);\n__decorateClass([\n  ObserveChanges((target) => target.layoutLabel())\n], LegendMarkerLabel.prototype, \"length\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], LegendMarkerLabel.prototype, \"isCustomMarker\", 2);\n\n// packages/ag-charts-community/src/chart/legend/legend.ts\nvar LegendLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.maxLength = void 0;\n    this.color = \"black\";\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLabel.prototype, \"maxLength\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], LegendLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], LegendLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], LegendLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], LegendLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendLabel.prototype, \"formatter\", 2);\nvar LegendMarker = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.shape = void 0;\n    this.size = 15;\n    this.padding = 8;\n  }\n};\n__decorateClass([\n  Validate(MARKER_SHAPE, { optional: true })\n], LegendMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendMarker.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendMarker.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LegendMarker.prototype, \"enabled\", 2);\nvar LegendLine = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLine.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLine.prototype, \"length\", 2);\nvar LegendItem = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.paddingX = 16;\n    this.paddingY = 8;\n    this.showSeriesStroke = false;\n    this.marker = new LegendMarker();\n    this.label = new LegendLabel();\n    this.line = new LegendLine();\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendItem.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendItem.prototype, \"paddingX\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendItem.prototype, \"paddingY\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LegendItem.prototype, \"showSeriesStroke\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"line\", 2);\nvar LegendListeners = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendListeners.prototype, \"legendItemClick\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendListeners.prototype, \"legendItemDoubleClick\", 2);\nvar ID_LEGEND_VISIBILITY = \"legend-visibility\";\nvar ID_LEGEND_OTHER_SERIES = \"legend-other-series\";\nvar Legend = class extends BaseProperties {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.id = createId(this);\n    this.group = new TranslatableGroup({ name: \"legend\", zIndex: 14 /* LEGEND */ });\n    this.itemSelection = Selection.select(\n      this.group,\n      LegendMarkerLabel\n    );\n    this.oldSize = [0, 0];\n    this.pages = [];\n    this.maxPageSize = [0, 0];\n    /** Item index to track on re-pagination, so current page updates appropriately. */\n    this.paginationTrackingIndex = 0;\n    this.truncatedItems = /* @__PURE__ */ new Set();\n    this._data = [];\n    this.toggleSeries = true;\n    this.item = new LegendItem();\n    this.listeners = new LegendListeners();\n    this.enabled = true;\n    this.position = \"bottom\";\n    this.spacing = 20;\n    this.destroyFns = [];\n    this.size = [0, 0];\n    this._visible = true;\n    this.pagination = new Pagination(\n      (type) => ctx.updateService.update(type),\n      (page) => this.updatePageNumber(page)\n    );\n    this.pagination.attachPagination(this.group);\n    this.destroyFns.push(\n      ctx.contextMenuRegistry.registerDefaultAction({\n        id: ID_LEGEND_VISIBILITY,\n        type: \"legend\",\n        label: \"contextMenuToggleSeriesVisibility\",\n        action: (params) => this.contextToggleVisibility(params)\n      }),\n      ctx.contextMenuRegistry.registerDefaultAction({\n        id: ID_LEGEND_OTHER_SERIES,\n        type: \"legend\",\n        label: \"contextMenuToggleOtherSeries\",\n        action: (params) => this.contextToggleOtherSeries(params)\n      }),\n      ctx.legendManager.addListener(\"legend-change\", this.onLegendDataChange.bind(this))\n    );\n    this.destroyFns.push(\n      ctx.layoutManager.registerElement(1 /* Legend */, (e) => this.positionLegend(e)),\n      ctx.localeManager.addListener(\"locale-changed\", () => this.onLocaleChanged()),\n      () => this.group.remove()\n    );\n    this.domProxy = new LegendDOMProxy(this.ctx, this.id);\n    this.ctx.historyManager.addMementoOriginator(ctx.legendManager);\n  }\n  set data(value) {\n    if (objectsEqual(value, this._data))\n      return;\n    this.domProxy.onDataUpdate(this._data, value);\n    this._data = value;\n    this.updateGroupVisibility();\n  }\n  get data() {\n    return this._data;\n  }\n  onLegendDataChange({ legendData = [] }) {\n    if (!this.enabled)\n      return;\n    this.data = legendData.filter((datum) => !datum.hideInLegend);\n  }\n  destroy() {\n    this.ctx.domManager.removeChild(\"canvas-overlay\", `${this.id}-toolbar`);\n    this.ctx.domManager.removeChild(\"canvas-overlay\", `${this.id}-pagination`);\n    this.destroyFns.forEach((f) => f());\n    this.itemSelection.clear();\n    this.domProxy.destroy();\n  }\n  getOrientation() {\n    if (this.orientation !== void 0) {\n      return this.orientation;\n    }\n    switch (this.position) {\n      case \"right\":\n      case \"left\":\n        return \"vertical\";\n      case \"bottom\":\n      case \"top\":\n        return \"horizontal\";\n    }\n  }\n  set visible(value) {\n    this._visible = value;\n    this.updateGroupVisibility();\n  }\n  get visible() {\n    return this._visible;\n  }\n  updateGroupVisibility() {\n    this.group.visible = this.enabled && this.visible && this.data.length > 0;\n  }\n  attachLegend(scene) {\n    scene.appendChild(this.group);\n  }\n  getItemLabel(datum) {\n    const {\n      ctx: { callbackCache }\n    } = this;\n    const { formatter } = this.item.label;\n    if (formatter) {\n      const seriesDatum = datum.datum;\n      return callbackCache.call(formatter, {\n        itemId: datum.itemId,\n        value: datum.label.text,\n        seriesId: datum.seriesId,\n        ...seriesDatum && { datum: seriesDatum }\n      });\n    }\n    return datum.label.text;\n  }\n  /**\n   * The method is given the desired size of the legend, which only serves as a hint.\n   * The vertically oriented legend will take as much horizontal space as needed, but will\n   * respect the height constraints, and the horizontal legend will take as much vertical\n   * space as needed in an attempt not to exceed the given width.\n   * After the layout is done, the {@link size} will contain the actual size of the legend.\n   * If the actual size is not the same as the previous actual size, the legend will fire\n   * the 'layoutChange' event to communicate that another layout is needed, and the above\n   * process should be repeated.\n   * @param width\n   * @param height\n   */\n  calcLayout(width2, height2) {\n    const {\n      paddingX,\n      paddingY,\n      label,\n      maxWidth,\n      label: { maxLength = Infinity, fontStyle, fontWeight, fontSize, fontFamily }\n    } = this.item;\n    const data = [...this.data];\n    if (this.reverseOrder) {\n      data.reverse();\n    }\n    this.itemSelection.update(data);\n    const bboxes = [];\n    const font2 = TextUtils.toFontString(label);\n    const itemMaxWidthPercentage = 0.8;\n    const maxItemWidth = maxWidth ?? width2 * itemMaxWidthPercentage;\n    const markerWidth = this.calculateMarkerWidth();\n    this.itemSelection.each((markerLabel, datum) => {\n      markerLabel.fontStyle = fontStyle;\n      markerLabel.fontWeight = fontWeight;\n      markerLabel.fontSize = fontSize;\n      markerLabel.fontFamily = fontFamily;\n      const paddedSymbolWidth = this.updateMarkerLabel(markerLabel, datum, markerWidth);\n      const id = datum.itemId ?? datum.id;\n      const labelText = this.getItemLabel(datum);\n      const text2 = (labelText ?? \"<unknown>\").replace(/\\r?\\n/g, \" \");\n      markerLabel.text = this.truncate(text2, maxLength, maxItemWidth, paddedSymbolWidth, font2, id);\n      bboxes.push(markerLabel.getBBox());\n    });\n    width2 = Math.max(1, width2);\n    height2 = Math.max(1, height2);\n    if (!isFinite(width2)) {\n      return {};\n    }\n    const size = this.size;\n    const oldSize = this.oldSize;\n    size[0] = width2;\n    size[1] = height2;\n    if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {\n      oldSize[0] = size[0];\n      oldSize[1] = size[1];\n    }\n    const { pages, maxPageHeight, maxPageWidth } = this.updatePagination(bboxes, width2, height2);\n    const oldPages = this.pages;\n    this.pages = pages;\n    this.maxPageSize = [maxPageWidth - paddingX, maxPageHeight - paddingY];\n    const pageNumber = this.pagination.currentPage;\n    const page = this.pages[pageNumber];\n    if (this.pages.length < 1 || !page) {\n      this.visible = false;\n      return { oldPages };\n    }\n    this.visible = true;\n    this.updatePositions(pageNumber);\n    this.update();\n    return { oldPages };\n  }\n  isCustomMarker(markerEnabled, shape) {\n    return markerEnabled && shape !== void 0 && typeof shape !== \"string\";\n  }\n  calcSymbolsEnabled(symbol) {\n    const { showSeriesStroke, marker } = this.item;\n    const markerEnabled = !!marker.enabled || !showSeriesStroke || (symbol.marker.enabled ?? true);\n    const lineEnabled = !!(symbol.line && showSeriesStroke);\n    const isCustomMarker = this.isCustomMarker(markerEnabled, symbol.marker.shape);\n    return { markerEnabled, lineEnabled, isCustomMarker };\n  }\n  calcSymbolsLengths(symbol) {\n    const { marker, line } = this.item;\n    const { markerEnabled, lineEnabled } = this.calcSymbolsEnabled(symbol);\n    const { strokeWidth: markerStrokeWidth } = this.getMarkerStyles(symbol);\n    const { strokeWidth: lineStrokeWidth } = lineEnabled ? this.getLineStyles(symbol) : { strokeWidth: 0 };\n    let customMarkerSize;\n    const { shape } = symbol.marker;\n    if (this.isCustomMarker(markerEnabled, shape)) {\n      const tmpShape = new Marker();\n      tmpShape.shape = shape;\n      tmpShape.updatePath();\n      const bbox = tmpShape.getBBox();\n      customMarkerSize = Math.max(bbox.width, bbox.height);\n    }\n    const markerLength = markerEnabled ? marker.size : 0;\n    const lineLength = lineEnabled ? line.length ?? 25 : 0;\n    return { markerLength, markerStrokeWidth, lineLength, lineStrokeWidth, customMarkerSize };\n  }\n  calculateMarkerWidth() {\n    let markerWidth = 0;\n    this.itemSelection.each((_, datum) => {\n      const { symbol } = datum;\n      const { markerLength, lineLength, customMarkerSize = -Infinity } = this.calcSymbolsLengths(symbol);\n      markerWidth = Math.max(markerWidth, lineLength, customMarkerSize, markerLength);\n    });\n    return markerWidth;\n  }\n  updateMarkerLabel(markerLabel, datum, markerWidth) {\n    const { marker: itemMarker, paddingX } = this.item;\n    const { symbol } = datum;\n    let paddedSymbolWidth = paddingX;\n    const { markerEnabled, lineEnabled, isCustomMarker } = this.calcSymbolsEnabled(symbol);\n    const spacing = itemMarker.padding;\n    if (markerEnabled || lineEnabled) {\n      paddedSymbolWidth += spacing + markerWidth;\n    }\n    const { marker, line } = markerLabel;\n    marker.visible = markerEnabled;\n    if (marker.visible) {\n      marker.shape = itemMarker.shape ?? symbol.marker.shape ?? \"square\";\n      marker.size = itemMarker.size;\n      applyShapeStyle(marker, this.getMarkerStyles(symbol));\n    }\n    line.visible = lineEnabled;\n    if (line.visible) {\n      applyShapeStyle(line, this.getLineStyles(symbol));\n    }\n    markerLabel.length = markerWidth;\n    markerLabel.spacing = spacing;\n    markerLabel.isCustomMarker = isCustomMarker;\n    return paddedSymbolWidth;\n  }\n  truncate(text2, maxCharLength, maxItemWidth, paddedMarkerWidth, font2, id) {\n    let addEllipsis = false;\n    if (text2.length > maxCharLength) {\n      text2 = text2.substring(0, maxCharLength);\n      addEllipsis = true;\n    }\n    const measurer2 = CachedTextMeasurerPool.getMeasurer({ font: font2 });\n    const result = TextWrapper.truncateLine(text2, measurer2, maxItemWidth - paddedMarkerWidth, addEllipsis);\n    if (result.endsWith(TextUtils.EllipsisChar)) {\n      this.truncatedItems.add(id);\n    } else {\n      this.truncatedItems.delete(id);\n    }\n    return result;\n  }\n  updatePagination(bboxes, width2, height2) {\n    const orientation = this.getOrientation();\n    const trackingIndex = Math.min(this.paginationTrackingIndex, bboxes.length);\n    this.pagination.orientation = orientation;\n    this.pagination.translationX = 0;\n    this.pagination.translationY = 0;\n    const { pages, maxPageHeight, maxPageWidth, paginationBBox, paginationVertical } = this.calculatePagination(\n      bboxes,\n      width2,\n      height2\n    );\n    const newCurrentPage = pages.findIndex((p) => p.endIndex >= trackingIndex);\n    this.pagination.currentPage = clamp(0, newCurrentPage, pages.length - 1);\n    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\n    const paginationComponentPadding = 8;\n    const legendItemsWidth = maxPageWidth - itemPaddingX;\n    const legendItemsHeight = maxPageHeight - itemPaddingY;\n    let paginationX = 0;\n    let paginationY = -paginationBBox.y - this.item.marker.size / 2;\n    if (paginationVertical) {\n      paginationY += legendItemsHeight + paginationComponentPadding;\n    } else {\n      paginationX += -paginationBBox.x + legendItemsWidth + paginationComponentPadding;\n      paginationY += (legendItemsHeight - paginationBBox.height) / 2;\n    }\n    this.pagination.translationX = paginationX;\n    this.pagination.translationY = paginationY;\n    this.pagination.update();\n    this.pagination.updateMarkers();\n    let pageIndex = 0;\n    this.itemSelection.each((markerLabel, _, nodeIndex) => {\n      if (nodeIndex > (pages[pageIndex]?.endIndex ?? Infinity)) {\n        pageIndex++;\n      }\n      markerLabel.pageIndex = pageIndex;\n    });\n    return {\n      maxPageHeight,\n      maxPageWidth,\n      pages\n    };\n  }\n  calculatePagination(bboxes, width2, height2) {\n    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\n    const orientation = this.getOrientation();\n    const paginationVertical = [\"left\", \"right\"].includes(this.position);\n    let paginationBBox = this.pagination.getBBox();\n    let lastPassPaginationBBox = new BBox(0, 0, 0, 0);\n    let pages = [];\n    let maxPageWidth = 0;\n    let maxPageHeight = 0;\n    let count = 0;\n    const stableOutput = (bbox) => {\n      return bbox.width === paginationBBox.width && bbox.height === paginationBBox.height;\n    };\n    const forceResult = this.maxWidth !== void 0 && this.maxHeight !== void 0;\n    do {\n      if (count++ > 10) {\n        logger_exports.warn(\"unable to find stable legend layout.\");\n        break;\n      }\n      paginationBBox = lastPassPaginationBBox;\n      const maxWidth = width2 - (paginationVertical ? 0 : paginationBBox.width);\n      const maxHeight = height2 - (paginationVertical ? paginationBBox.height : 0);\n      const layout = gridLayout({\n        orientation,\n        bboxes,\n        maxHeight,\n        maxWidth,\n        itemPaddingY,\n        itemPaddingX,\n        forceResult\n      });\n      pages = layout?.pages ?? [];\n      maxPageWidth = layout?.maxPageWidth ?? 0;\n      maxPageHeight = layout?.maxPageHeight ?? 0;\n      const totalPages = pages.length;\n      this.pagination.visible = totalPages > 1;\n      this.pagination.totalPages = totalPages;\n      this.pagination.update();\n      this.pagination.updateMarkers();\n      lastPassPaginationBBox = this.pagination.getBBox();\n      if (!this.pagination.visible) {\n        break;\n      }\n    } while (!stableOutput(lastPassPaginationBBox));\n    return { maxPageWidth, maxPageHeight, pages, paginationBBox: lastPassPaginationBBox, paginationVertical };\n  }\n  updatePositions(pageNumber = 0) {\n    const {\n      item: { paddingY },\n      itemSelection,\n      pages\n    } = this;\n    if (pages.length < 1 || !pages[pageNumber]) {\n      return;\n    }\n    const { columns, startIndex: visibleStart, endIndex: visibleEnd } = pages[pageNumber];\n    let x = 0;\n    let y = 0;\n    const columnCount = columns.length;\n    const rowCount = columns[0].indices.length;\n    const horizontal = this.getOrientation() === \"horizontal\";\n    const itemHeight = columns[0].bboxes[0].height + paddingY;\n    const rowSumColumnWidths = [];\n    itemSelection.each((markerLabel, _, i) => {\n      if (i < visibleStart || i > visibleEnd) {\n        markerLabel.visible = false;\n        return;\n      }\n      const pageIndex = i - visibleStart;\n      let columnIndex;\n      let rowIndex;\n      if (horizontal) {\n        columnIndex = pageIndex % columnCount;\n        rowIndex = Math.floor(pageIndex / columnCount);\n      } else {\n        columnIndex = Math.floor(pageIndex / rowCount);\n        rowIndex = pageIndex % rowCount;\n      }\n      markerLabel.visible = true;\n      const column = columns[columnIndex];\n      if (!column) {\n        return;\n      }\n      y = Math.floor(itemHeight * rowIndex);\n      x = Math.floor(rowSumColumnWidths[rowIndex] ?? 0);\n      rowSumColumnWidths[rowIndex] = (rowSumColumnWidths[rowIndex] ?? 0) + column.columnWidth;\n      markerLabel.translationX = x;\n      markerLabel.translationY = y;\n    });\n  }\n  updatePageNumber(pageNumber) {\n    const { itemSelection, group, pagination, pages, toggleSeries: interactive } = this;\n    const { startIndex, endIndex } = pages[pageNumber];\n    if (startIndex === 0) {\n      this.paginationTrackingIndex = 0;\n    } else if (pageNumber === pages.length - 1) {\n      this.paginationTrackingIndex = endIndex;\n    } else {\n      this.paginationTrackingIndex = Math.floor((startIndex + endIndex) / 2);\n    }\n    this.pagination.update();\n    this.pagination.updateMarkers();\n    this.updatePositions(pageNumber);\n    this.domProxy.onPageChange({ itemSelection, group, pagination, interactive });\n    this.ctx.updateService.update(6 /* SCENE_RENDER */);\n  }\n  update() {\n    const {\n      label: { color }\n    } = this.item;\n    this.itemSelection.each((markerLabel, datum) => {\n      markerLabel.setEnabled(datum.enabled);\n      markerLabel.color = color;\n    });\n    this.updateContextMenu();\n  }\n  updateContextMenu() {\n    const {\n      toggleSeries,\n      ctx: { contextMenuRegistry }\n    } = this;\n    if (toggleSeries) {\n      contextMenuRegistry.hideAction(ID_LEGEND_VISIBILITY);\n      contextMenuRegistry.hideAction(ID_LEGEND_OTHER_SERIES);\n    } else {\n      contextMenuRegistry.showAction(ID_LEGEND_VISIBILITY);\n      contextMenuRegistry.showAction(ID_LEGEND_OTHER_SERIES);\n    }\n  }\n  getLineStyles(datum) {\n    const { stroke: stroke2, strokeOpacity = 1, strokeWidth, lineDash } = datum.line ?? {};\n    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);\n    return {\n      stroke: stroke2,\n      strokeOpacity,\n      strokeWidth: this.item.line.strokeWidth ?? defaultLineStrokeWidth,\n      lineDash\n    };\n  }\n  getMarkerStyles(datum) {\n    const {\n      fill,\n      stroke: stroke2,\n      strokeOpacity = 1,\n      fillOpacity = 1,\n      strokeWidth,\n      lineDash,\n      lineDashOffset\n    } = datum.marker;\n    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);\n    return {\n      fill,\n      stroke: stroke2,\n      strokeOpacity,\n      fillOpacity,\n      strokeWidth: this.item.marker.strokeWidth ?? defaultLineStrokeWidth,\n      lineDash,\n      lineDashOffset\n    };\n  }\n  computePagedBBox() {\n    const actualBBox = Group.computeChildrenBBox(this.group.children());\n    if (this.pages.length > 1) {\n      const [maxPageWidth, maxPageHeight] = this.maxPageSize;\n      actualBBox.height = Math.max(maxPageHeight, actualBBox.height);\n      actualBBox.width = Math.max(maxPageWidth, actualBBox.width);\n    }\n    return actualBBox;\n  }\n  findNode(params) {\n    const { datum, proxyButton } = this.itemSelection.select((ml) => ml.datum?.itemId === params.itemId)[0] ?? {};\n    if (datum === void 0 || proxyButton === void 0) {\n      throw new Error(\n        `AG Charts - Missing required properties { datum: ${datum}, proxyButton: ${JSON.stringify(proxyButton)} }`\n      );\n    }\n    return { datum, proxyButton };\n  }\n  contextToggleVisibility(params) {\n    const { datum, proxyButton } = this.findNode(params);\n    this.doClick(params.event, datum, proxyButton);\n  }\n  contextToggleOtherSeries(params) {\n    this.doDoubleClick(params.event, this.findNode(params).datum);\n  }\n  onContextClick(sourceEvent, node) {\n    const legendItem = node.datum;\n    if (this.preventHidingAll && this.contextMenuDatum?.enabled && this.getVisibleItemCount() <= 1) {\n      this.ctx.contextMenuRegistry.disableAction(ID_LEGEND_VISIBILITY);\n    } else {\n      this.ctx.contextMenuRegistry.enableAction(ID_LEGEND_VISIBILITY);\n    }\n    const { offsetX, offsetY } = sourceEvent;\n    const { x: canvasX, y: canvasY } = Transformable.toCanvasPoint(node, offsetX, offsetY);\n    this.ctx.contextMenuRegistry.dispatchContext(\"legend\", { sourceEvent, canvasX, canvasY }, { legendItem });\n  }\n  onClick(event, datum, proxyButton) {\n    if (this.doClick(event, datum, proxyButton)) {\n      event.preventDefault();\n    }\n  }\n  getVisibleItemCount() {\n    return this.ctx.chartService.series.flatMap((s) => s.getLegendData(\"category\")).filter((d) => d.enabled).length;\n  }\n  doClick(event, datum, proxyButton) {\n    const {\n      listeners: { legendItemClick },\n      ctx: { chartService, highlightManager },\n      preventHidingAll,\n      toggleSeries\n    } = this;\n    if (!datum) {\n      return false;\n    }\n    const { legendType, seriesId, itemId, enabled } = datum;\n    const series = chartService.series.find((s) => s.id === seriesId);\n    if (!series) {\n      return false;\n    }\n    let newEnabled = enabled;\n    const clickEvent = makeLegendItemEvent(\"click\", itemId, series.id, event);\n    legendItemClick?.(clickEvent.apiEvent);\n    if (clickEvent.defaultPrevented)\n      return true;\n    if (toggleSeries) {\n      newEnabled = !enabled;\n      if (preventHidingAll && !newEnabled) {\n        const numVisibleItems = this.getVisibleItemCount();\n        if (numVisibleItems < 2) {\n          newEnabled = true;\n        }\n      }\n      proxyButton.setChecked(newEnabled);\n      this.ctx.chartEventManager.legendItemClick(legendType, series, itemId, newEnabled, datum.legendItemName);\n    }\n    if (newEnabled) {\n      highlightManager.updateHighlight(this.id, {\n        series,\n        itemId,\n        datum: void 0,\n        datumIndex: void 0\n      });\n    } else {\n      highlightManager.updateHighlight(this.id);\n    }\n    this.ctx.legendManager.update();\n    this.ctx.updateService.update(2 /* PROCESS_DATA */, {\n      forceNodeDataRefresh: true,\n      skipAnimations: datum.skipAnimations ?? false\n    });\n    return true;\n  }\n  onDoubleClick(event, datum) {\n    if (this.doDoubleClick(event, datum)) {\n      event.preventDefault();\n    }\n  }\n  doDoubleClick(event, datum) {\n    const {\n      listeners: { legendItemDoubleClick },\n      ctx: { chartService },\n      toggleSeries\n    } = this;\n    if (chartService.mode === \"integrated\") {\n      return false;\n    }\n    if (!datum) {\n      return false;\n    }\n    const { legendType, id, itemId, seriesId } = datum;\n    const series = chartService.series.find((s) => s.id === id);\n    if (!series) {\n      return false;\n    }\n    const doubleClickEvent = makeLegendItemEvent(\"dblclick\", itemId, series.id, event);\n    legendItemDoubleClick?.(doubleClickEvent.apiEvent);\n    if (doubleClickEvent.defaultPrevented)\n      return true;\n    if (toggleSeries) {\n      const legendData = chartService.series.flatMap((s) => s.getLegendData(\"category\"));\n      const numVisibleItems = legendData.filter((d) => d.enabled).length;\n      const clickedItem = legendData.find((d) => d.itemId === itemId && d.seriesId === seriesId);\n      this.ctx.chartEventManager.legendItemDoubleClick(\n        legendType,\n        series,\n        itemId,\n        clickedItem?.enabled ?? false,\n        numVisibleItems,\n        clickedItem?.legendItemName\n      );\n    }\n    this.ctx.legendManager.update();\n    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });\n    return true;\n  }\n  toTooltipMeta(event, node) {\n    let lastPointerEvent;\n    if (event instanceof FocusEvent) {\n      const { x, y } = Transformable.toCanvas(node).computeCenter();\n      lastPointerEvent = { type: \"keyboard\", canvasX: x, canvasY: y };\n    } else {\n      event.preventDefault();\n      const { x, y } = Transformable.toCanvasPoint(node, event.offsetX, event.offsetY);\n      lastPointerEvent = { type: \"pointermove\", canvasX: x, canvasY: y };\n    }\n    const { canvasX, canvasY } = lastPointerEvent;\n    return { canvasX, canvasY, lastPointerEvent, showArrow: false };\n  }\n  onHover(event, node) {\n    if (!this.enabled)\n      throw new Error(\"AG Charts - onHover handler called on disabled legend\");\n    this.pagination.setPage(node.pageIndex);\n    const datum = node.datum;\n    const series = datum ? this.ctx.chartService.series.find((s) => s.id === datum?.id) : void 0;\n    if (datum && this.truncatedItems.has(datum.itemId ?? datum.id)) {\n      const meta = this.toTooltipMeta(event, node);\n      this.ctx.tooltipManager.updateTooltip(this.id, meta, {\n        type: \"structured\",\n        title: this.getItemLabel(datum)\n      });\n    } else {\n      this.ctx.tooltipManager.removeTooltip(this.id);\n    }\n    if (datum?.enabled && series) {\n      this.updateHighlight({ series, itemId: datum?.itemId, datum: void 0, datumIndex: void 0 });\n    } else {\n      this.updateHighlight();\n    }\n  }\n  onLeave() {\n    this.ctx.tooltipManager.removeTooltip(this.id);\n    this.updateHighlight();\n  }\n  updateHighlight(datum) {\n    if (this.ctx.interactionManager.isState(32 /* Default */)) {\n      this.ctx.highlightManager.updateHighlight(this.id, datum);\n    } else if (this.ctx.interactionManager.isState(2 /* Animation */)) {\n      this.pendingHighlightDatum = datum;\n      this.ctx.animationManager.onBatchStop(() => {\n        this.ctx.highlightManager.updateHighlight(this.id, this.pendingHighlightDatum);\n      });\n    }\n  }\n  onLocaleChanged() {\n    this.domProxy.onLocaleChanged(this.ctx.localeManager, this.itemSelection, this);\n  }\n  positionLegend(ctx) {\n    const oldPages = this.positionLegendScene(ctx);\n    this.positionLegendDOM(oldPages);\n  }\n  positionLegendScene(ctx) {\n    if (!this.enabled || !this.data.length)\n      return;\n    const { layoutBox } = ctx;\n    const { x, y, width: width2, height: height2 } = layoutBox;\n    const [legendWidth, legendHeight] = this.calculateLegendDimensions(layoutBox);\n    const { oldPages } = this.calcLayout(legendWidth, legendHeight);\n    const legendBBox = this.computePagedBBox();\n    const calculateTranslationPerpendicularDimension = () => {\n      switch (this.position) {\n        case \"top\":\n        case \"left\":\n          return 0;\n        case \"bottom\":\n          return height2 - legendBBox.height;\n        case \"right\":\n        default:\n          return width2 - legendBBox.width;\n      }\n    };\n    if (this.visible) {\n      const legendPadding = this.spacing;\n      let translationX;\n      let translationY;\n      switch (this.position) {\n        case \"top\":\n        case \"bottom\":\n          translationX = (width2 - legendBBox.width) / 2;\n          translationY = calculateTranslationPerpendicularDimension();\n          layoutBox.shrink(legendBBox.height + legendPadding, this.position);\n          break;\n        case \"left\":\n        case \"right\":\n        default:\n          translationX = calculateTranslationPerpendicularDimension();\n          translationY = (height2 - legendBBox.height) / 2;\n          layoutBox.shrink(legendBBox.width + legendPadding, this.position);\n      }\n      this.group.translationX = Math.floor(x + translationX - legendBBox.x);\n      this.group.translationY = Math.floor(y + translationY - legendBBox.y);\n    }\n    return oldPages;\n  }\n  positionLegendDOM(oldPages) {\n    const {\n      ctx,\n      itemSelection,\n      pagination,\n      pages: newPages,\n      toggleSeries,\n      group,\n      listeners: { legendItemClick, legendItemDoubleClick }\n    } = this;\n    const visible = this.visible && this.enabled;\n    const interactive = toggleSeries || legendItemDoubleClick != null || legendItemClick != null;\n    this.domProxy.update({\n      visible,\n      interactive,\n      ctx,\n      itemSelection,\n      group,\n      pagination,\n      oldPages,\n      newPages,\n      datumReader: this,\n      itemListener: this\n    });\n  }\n  calculateLegendDimensions(shrinkRect) {\n    const { width: width2, height: height2 } = shrinkRect;\n    const aspectRatio = width2 / height2;\n    const maxCoefficient = 0.5;\n    const minHeightCoefficient = 0.2;\n    const minWidthCoefficient = 0.25;\n    let legendWidth, legendHeight;\n    switch (this.position) {\n      case \"top\":\n      case \"bottom\": {\n        const heightCoefficient = aspectRatio < 1 ? Math.min(maxCoefficient, minHeightCoefficient * (1 / aspectRatio)) : minHeightCoefficient;\n        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width2) : width2;\n        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height2) : Math.round(height2 * heightCoefficient);\n        break;\n      }\n      case \"left\":\n      case \"right\":\n      default: {\n        const widthCoefficient = aspectRatio > 1 ? Math.min(maxCoefficient, minWidthCoefficient * aspectRatio) : minWidthCoefficient;\n        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width2) : Math.round(width2 * widthCoefficient);\n        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height2) : height2;\n      }\n    }\n    return [legendWidth, legendHeight];\n  }\n};\nLegend.className = \"Legend\";\n__decorateClass([\n  Validate(BOOLEAN)\n], Legend.prototype, \"toggleSeries\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"pagination\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"item\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"listeners\", 2);\n__decorateClass([\n  ObserveChanges((target, newValue, oldValue) => {\n    target.updateGroupVisibility();\n    if (newValue === oldValue) {\n      return;\n    }\n    const {\n      ctx: { legendManager, stateManager }\n    } = target;\n    if (oldValue === false && newValue === true) {\n      stateManager.restoreState(legendManager);\n    }\n  }),\n  Validate(BOOLEAN)\n], Legend.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITION)\n], Legend.prototype, \"position\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Legend.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Legend.prototype, \"maxHeight\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Legend.prototype, \"reverseOrder\", 2);\n__decorateClass([\n  Validate(UNION([\"horizontal\", \"vertical\"], \"an orientation\"), { optional: true })\n], Legend.prototype, \"orientation\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Legend.prototype, \"preventHidingAll\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Legend.prototype, \"spacing\", 2);\n\n// packages/ag-charts-community/src/chart/legend/legendModule.ts\nvar CommunityLegendModule = {\n  type: \"legend\",\n  optionsKey: \"legend\",\n  identifier: \"category\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\", \"standalone\", \"gauge\"],\n  moduleFactory: (ctx) => new Legend(ctx),\n  packageType: \"community\",\n  removable: \"standalone-only\"\n};\n\n// packages/ag-charts-community/src/chart/themes/constants.ts\nvar constants_exports = {};\n__export(constants_exports, {\n  CARTESIAN_AXIS_TYPE: () => CARTESIAN_AXIS_TYPE,\n  CARTESIAN_POSITION: () => CARTESIAN_POSITION,\n  FONT_SIZE: () => FONT_SIZE,\n  FONT_SIZE_RATIO: () => FONT_SIZE_RATIO,\n  POLAR_AXIS_SHAPE: () => POLAR_AXIS_SHAPE,\n  POLAR_AXIS_TYPE: () => POLAR_AXIS_TYPE\n});\nvar FONT_SIZE = /* @__PURE__ */ ((FONT_SIZE2) => {\n  FONT_SIZE2[FONT_SIZE2[\"SMALLEST\"] = 8] = \"SMALLEST\";\n  FONT_SIZE2[FONT_SIZE2[\"SMALLER\"] = 10] = \"SMALLER\";\n  FONT_SIZE2[FONT_SIZE2[\"SMALL\"] = 12] = \"SMALL\";\n  FONT_SIZE2[FONT_SIZE2[\"MEDIUM\"] = 13] = \"MEDIUM\";\n  FONT_SIZE2[FONT_SIZE2[\"LARGE\"] = 14] = \"LARGE\";\n  FONT_SIZE2[FONT_SIZE2[\"LARGEST\"] = 17] = \"LARGEST\";\n  return FONT_SIZE2;\n})(FONT_SIZE || {});\nvar FONT_SIZE_RATIO = /* @__PURE__ */ ((FONT_SIZE_RATIO2) => {\n  FONT_SIZE_RATIO2[FONT_SIZE_RATIO2[\"SMALLEST\"] = 0.6666666666666666] = \"SMALLEST\";\n  FONT_SIZE_RATIO2[FONT_SIZE_RATIO2[\"SMALLER\"] = 0.8333333333333334] = \"SMALLER\";\n  FONT_SIZE_RATIO2[FONT_SIZE_RATIO2[\"SMALL\"] = 1] = \"SMALL\";\n  FONT_SIZE_RATIO2[FONT_SIZE_RATIO2[\"MEDIUM\"] = 1.0833333333333333] = \"MEDIUM\";\n  FONT_SIZE_RATIO2[FONT_SIZE_RATIO2[\"LARGE\"] = 1.1666666666666667] = \"LARGE\";\n  FONT_SIZE_RATIO2[FONT_SIZE_RATIO2[\"LARGEST\"] = 1.4166666666666667] = \"LARGEST\";\n  return FONT_SIZE_RATIO2;\n})(FONT_SIZE_RATIO || {});\nvar CARTESIAN_POSITION = /* @__PURE__ */ ((CARTESIAN_POSITION2) => {\n  CARTESIAN_POSITION2[\"TOP\"] = \"top\";\n  CARTESIAN_POSITION2[\"RIGHT\"] = \"right\";\n  CARTESIAN_POSITION2[\"BOTTOM\"] = \"bottom\";\n  CARTESIAN_POSITION2[\"LEFT\"] = \"left\";\n  return CARTESIAN_POSITION2;\n})(CARTESIAN_POSITION || {});\nvar CARTESIAN_AXIS_TYPE = /* @__PURE__ */ ((CARTESIAN_AXIS_TYPE2) => {\n  CARTESIAN_AXIS_TYPE2[\"CATEGORY\"] = \"category\";\n  CARTESIAN_AXIS_TYPE2[\"GROUPED_CATEGORY\"] = \"grouped-category\";\n  CARTESIAN_AXIS_TYPE2[\"ORDINAL_TIME\"] = \"ordinal-time\";\n  CARTESIAN_AXIS_TYPE2[\"NUMBER\"] = \"number\";\n  CARTESIAN_AXIS_TYPE2[\"TIME\"] = \"time\";\n  CARTESIAN_AXIS_TYPE2[\"LOG\"] = \"log\";\n  return CARTESIAN_AXIS_TYPE2;\n})(CARTESIAN_AXIS_TYPE || {});\nvar POLAR_AXIS_TYPE = /* @__PURE__ */ ((POLAR_AXIS_TYPE2) => {\n  POLAR_AXIS_TYPE2[\"ANGLE_CATEGORY\"] = \"angle-category\";\n  POLAR_AXIS_TYPE2[\"ANGLE_NUMBER\"] = \"angle-number\";\n  POLAR_AXIS_TYPE2[\"RADIUS_CATEGORY\"] = \"radius-category\";\n  POLAR_AXIS_TYPE2[\"RADIUS_NUMBER\"] = \"radius-number\";\n  return POLAR_AXIS_TYPE2;\n})(POLAR_AXIS_TYPE || {});\nvar POLAR_AXIS_SHAPE = /* @__PURE__ */ ((POLAR_AXIS_SHAPE2) => {\n  POLAR_AXIS_SHAPE2[\"CIRCLE\"] = \"circle\";\n  POLAR_AXIS_SHAPE2[\"POLYGON\"] = \"polygon\";\n  return POLAR_AXIS_SHAPE2;\n})(POLAR_AXIS_SHAPE || {});\n\n// packages/ag-charts-community/src/chart/themes/symbols.ts\nvar symbols_exports = {};\n__export(symbols_exports, {\n  DEFAULT_ANNOTATION_HANDLE_FILL: () => DEFAULT_ANNOTATION_HANDLE_FILL,\n  DEFAULT_ANNOTATION_STATISTICS_COLOR: () => DEFAULT_ANNOTATION_STATISTICS_COLOR,\n  DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE,\n  DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL: () => DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,\n  DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE,\n  DEFAULT_ANNOTATION_STATISTICS_FILL: () => DEFAULT_ANNOTATION_STATISTICS_FILL,\n  DEFAULT_ANNOTATION_STATISTICS_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_STROKE,\n  DEFAULT_BACKGROUND_COLOUR: () => DEFAULT_BACKGROUND_COLOUR,\n  DEFAULT_CAPTION_ALIGNMENT: () => DEFAULT_CAPTION_ALIGNMENT,\n  DEFAULT_CAPTION_LAYOUT_STYLE: () => DEFAULT_CAPTION_LAYOUT_STYLE,\n  DEFAULT_COLOR_RANGE: () => DEFAULT_COLOR_RANGE,\n  DEFAULT_DIVERGING_SERIES_COLOR_RANGE: () => DEFAULT_DIVERGING_SERIES_COLOR_RANGE,\n  DEFAULT_FIBONACCI_STROKES: () => DEFAULT_FIBONACCI_STROKES,\n  DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL: () => DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,\n  DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR: () => DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,\n  DEFAULT_FUNNEL_SERIES_COLOR_RANGE: () => DEFAULT_FUNNEL_SERIES_COLOR_RANGE,\n  DEFAULT_GAUGE_SERIES_COLOR_RANGE: () => DEFAULT_GAUGE_SERIES_COLOR_RANGE,\n  DEFAULT_GRIDLINE_ENABLED: () => DEFAULT_GRIDLINE_ENABLED,\n  DEFAULT_HIERARCHY_FILLS: () => DEFAULT_HIERARCHY_FILLS,\n  DEFAULT_HIERARCHY_STROKES: () => DEFAULT_HIERARCHY_STROKES,\n  DEFAULT_POLAR_SERIES_STROKE: () => DEFAULT_POLAR_SERIES_STROKE,\n  DEFAULT_SEPARATION_LINES_COLOUR: () => DEFAULT_SEPARATION_LINES_COLOUR,\n  DEFAULT_SHADOW_COLOUR: () => DEFAULT_SHADOW_COLOUR,\n  DEFAULT_SPARKLINE_CROSSHAIR_STROKE: () => DEFAULT_SPARKLINE_CROSSHAIR_STROKE,\n  DEFAULT_TEXTBOX_COLOR: () => DEFAULT_TEXTBOX_COLOR,\n  DEFAULT_TEXTBOX_FILL: () => DEFAULT_TEXTBOX_FILL,\n  DEFAULT_TEXTBOX_STROKE: () => DEFAULT_TEXTBOX_STROKE,\n  DEFAULT_TEXT_ANNOTATION_COLOR: () => DEFAULT_TEXT_ANNOTATION_COLOR,\n  DEFAULT_TOOLBAR_POSITION: () => DEFAULT_TOOLBAR_POSITION,\n  IS_COMMUNITY: () => IS_COMMUNITY,\n  IS_DARK_THEME: () => IS_DARK_THEME,\n  IS_ENTERPRISE: () => IS_ENTERPRISE,\n  PALETTE_ALT_DOWN_FILL: () => PALETTE_ALT_DOWN_FILL,\n  PALETTE_ALT_DOWN_STROKE: () => PALETTE_ALT_DOWN_STROKE,\n  PALETTE_ALT_NEUTRAL_FILL: () => PALETTE_ALT_NEUTRAL_FILL,\n  PALETTE_ALT_NEUTRAL_STROKE: () => PALETTE_ALT_NEUTRAL_STROKE,\n  PALETTE_ALT_UP_FILL: () => PALETTE_ALT_UP_FILL,\n  PALETTE_ALT_UP_STROKE: () => PALETTE_ALT_UP_STROKE,\n  PALETTE_DOWN_FILL: () => PALETTE_DOWN_FILL,\n  PALETTE_DOWN_STROKE: () => PALETTE_DOWN_STROKE,\n  PALETTE_NEUTRAL_FILL: () => PALETTE_NEUTRAL_FILL,\n  PALETTE_NEUTRAL_STROKE: () => PALETTE_NEUTRAL_STROKE,\n  PALETTE_UP_FILL: () => PALETTE_UP_FILL,\n  PALETTE_UP_STROKE: () => PALETTE_UP_STROKE\n});\nvar IS_DARK_THEME = Symbol(\"is-dark-theme\");\nvar IS_COMMUNITY = Symbol(\"is-community\");\nvar IS_ENTERPRISE = Symbol(\"is-enterprise\");\nvar DEFAULT_SEPARATION_LINES_COLOUR = Symbol(\"default-separation-lines-colour\");\nvar DEFAULT_BACKGROUND_COLOUR = Symbol(\"default-background-colour\");\nvar DEFAULT_SHADOW_COLOUR = Symbol(\"default-shadow-colour\");\nvar DEFAULT_CAPTION_LAYOUT_STYLE = Symbol(\"default-caption-layout-style\");\nvar DEFAULT_CAPTION_ALIGNMENT = Symbol(\"default-caption-alignment\");\nvar PALETTE_UP_STROKE = Symbol(\"palette-up-stroke\");\nvar PALETTE_DOWN_STROKE = Symbol(\"palette-down-stroke\");\nvar PALETTE_UP_FILL = Symbol(\"palette-up-fill\");\nvar PALETTE_DOWN_FILL = Symbol(\"palette-down-fill\");\nvar PALETTE_NEUTRAL_STROKE = Symbol(\"palette-neutral-stroke\");\nvar PALETTE_NEUTRAL_FILL = Symbol(\"palette-neutral-fill\");\nvar PALETTE_ALT_UP_STROKE = Symbol(\"palette-alt-up-stroke\");\nvar PALETTE_ALT_DOWN_STROKE = Symbol(\"palette-alt-down-stroke\");\nvar PALETTE_ALT_UP_FILL = Symbol(\"palette-alt-up-fill\");\nvar PALETTE_ALT_DOWN_FILL = Symbol(\"palette-alt-down-fill\");\nvar PALETTE_ALT_NEUTRAL_FILL = Symbol(\"palette-gray-fill\");\nvar PALETTE_ALT_NEUTRAL_STROKE = Symbol(\"palette-gray-stroke\");\nvar DEFAULT_POLAR_SERIES_STROKE = Symbol(\"default-polar-series-stroke\");\nvar DEFAULT_DIVERGING_SERIES_COLOR_RANGE = Symbol(\n  \"default-diverging-series-colour-range\"\n);\nvar DEFAULT_COLOR_RANGE = Symbol(\"default-colour-range\");\nvar DEFAULT_SPARKLINE_CROSSHAIR_STROKE = Symbol(\"default-sparkline-crosshair-stroke\");\nvar DEFAULT_GAUGE_SERIES_COLOR_RANGE = Symbol(\"default-gauge-series-colour-range\");\nvar DEFAULT_FUNNEL_SERIES_COLOR_RANGE = Symbol(\"default-funnel-series-colour-range\");\nvar DEFAULT_HIERARCHY_FILLS = Symbol(\"default-hierarchy-fills\");\nvar DEFAULT_HIERARCHY_STROKES = Symbol(\"default-hierarchy-strokes\");\nvar DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR = Symbol(\n  \"default-financial-charts-annotation-stroke\"\n);\nvar DEFAULT_FIBONACCI_STROKES = Symbol(\"default-hierarchy-strokes\");\nvar DEFAULT_TEXT_ANNOTATION_COLOR = Symbol(\"default-text-annotation-color\");\nvar DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL = Symbol(\n  \"default-financial-charts-annotation-background-fill\"\n);\nvar DEFAULT_ANNOTATION_HANDLE_FILL = Symbol(\"default-annotation-handle-fill\");\nvar DEFAULT_ANNOTATION_STATISTICS_FILL = Symbol(\"default-annotation-statistics-fill\");\nvar DEFAULT_ANNOTATION_STATISTICS_STROKE = Symbol(\"default-annotation-statistics-stroke\");\nvar DEFAULT_ANNOTATION_STATISTICS_COLOR = Symbol(\"default-annotation-statistics-color\");\nvar DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE = Symbol(\n  \"default-annotation-statistics-divider-stroke\"\n);\nvar DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL = Symbol(\n  \"default-annotation-statistics-fill\"\n);\nvar DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE = Symbol(\n  \"default-annotation-statistics-stroke\"\n);\nvar DEFAULT_TEXTBOX_FILL = Symbol(\"default-textbox-fill\");\nvar DEFAULT_TEXTBOX_STROKE = Symbol(\"default-textbox-stroke\");\nvar DEFAULT_TEXTBOX_COLOR = Symbol(\"default-textbox-color\");\nvar DEFAULT_TOOLBAR_POSITION = Symbol(\"default-toolbar-position\");\nvar DEFAULT_GRIDLINE_ENABLED = Symbol(\"default-gridline-enabled\");\n\n// packages/ag-charts-community/src/chart/themes/util.ts\nfunction swapAxisCondition(axes, swap) {\n  return (series) => {\n    if (!swap(series))\n      return axes;\n    return [\n      { ...axes[0], position: axes[1].position },\n      { ...axes[1], position: axes[0].position }\n    ];\n  };\n}\nfunction singleSeriesPaletteFactory({ takeColors }) {\n  const {\n    fills: [fill],\n    strokes: [stroke2]\n  } = takeColors(1);\n  return { fill, stroke: stroke2 };\n}\nfunction markerPaletteFactory(params) {\n  return { marker: singleSeriesPaletteFactory(params) };\n}\n\n// packages/ag-charts-community/src/motion/pathMotion.ts\nfunction pathMotion(groupId, subId, animationManager, paths, fns) {\n  const { addPhaseFn, updatePhaseFn, removePhaseFn } = fns;\n  const animate = (phase, path, updateFn) => {\n    animationManager.animate({\n      id: `${groupId}_${subId}_${path.id}_${phase}`,\n      groupId,\n      from: 0,\n      to: 1,\n      ease: easeOut,\n      collapsable: false,\n      onUpdate(ratio2, preInit) {\n        if (preInit && phase !== \"removed\")\n          return;\n        path.path.clear(true);\n        updateFn(ratio2, path);\n        path.checkPathDirty();\n      },\n      onStop() {\n        if (phase !== \"added\")\n          return;\n        path.path.clear(true);\n        updateFn(1, path);\n        path.checkPathDirty();\n      },\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase]\n    });\n  };\n  for (const path of paths) {\n    if (!animationManager.isSkipped()) {\n      animate(\"removed\", path, removePhaseFn);\n      animate(\"updated\", path, updatePhaseFn);\n    }\n    animate(\"added\", path, addPhaseFn);\n  }\n}\n\n// packages/ag-charts-community/src/chart/series/seriesLabelUtil.ts\nfunction seriesLabelFadeInAnimation({ id }, subId, animationManager, ...labelSelections) {\n  staticFromToMotion(\n    id,\n    subId,\n    animationManager,\n    labelSelections,\n    { opacity: 0 },\n    { opacity: 1 },\n    { phase: \"trailing\" }\n  );\n}\nfunction seriesLabelFadeOutAnimation({ id }, subId, animationManager, ...labelSelections) {\n  staticFromToMotion(\n    id,\n    subId,\n    animationManager,\n    labelSelections,\n    { opacity: 1 },\n    { opacity: 0 },\n    { phase: \"remove\" }\n  );\n}\nfunction resetLabelFn(_node) {\n  return { opacity: 1 };\n}\n\n// packages/ag-charts-community/src/scene/dropShadow.ts\nvar DropShadow = class extends ChangeDetectableProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.color = \"rgba(0, 0, 0, 0.5)\";\n    this.xOffset = 0;\n    this.yOffset = 0;\n    this.blur = 5;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  SceneChangeDetection()\n], DropShadow.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(COLOR_STRING),\n  SceneChangeDetection()\n], DropShadow.prototype, \"color\", 2);\n__decorateClass([\n  Validate(NUMBER),\n  SceneChangeDetection()\n], DropShadow.prototype, \"xOffset\", 2);\n__decorateClass([\n  Validate(NUMBER),\n  SceneChangeDetection()\n], DropShadow.prototype, \"yOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection()\n], DropShadow.prototype, \"blur\", 2);\n\n// packages/ag-charts-community/src/chart/series/seriesTooltip.ts\nvar SeriesTooltipInteraction = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesTooltipInteraction.prototype, \"enabled\", 2);\nvar SeriesTooltip = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.interaction = new SeriesTooltipInteraction();\n    this.position = new TooltipPosition();\n    this.range = void 0;\n    this.class = void 0;\n  }\n  formatTooltip(content, params) {\n    const overrides = this.renderer?.(params);\n    if (typeof overrides === \"string\")\n      return { type: \"raw\", rawHtmlString: overrides };\n    if (overrides != null)\n      return { type: \"structured\", ...content, ...overrides };\n    return { type: \"structured\", ...content };\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesTooltip.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesTooltip.prototype, \"showArrow\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], SeriesTooltip.prototype, \"renderer\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesTooltip.prototype, \"interaction\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesTooltip.prototype, \"position\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE, { optional: true })\n], SeriesTooltip.prototype, \"range\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], SeriesTooltip.prototype, \"class\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/interpolationProperties.ts\nvar INTERPOLATION_TYPE = UNION([\"linear\", \"smooth\", \"step\"], \"a line style\");\nvar INTERPOLATION_STEP_POSITION = UNION([\"start\", \"middle\", \"end\"]);\nvar InterpolationProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.type = \"linear\";\n    this.tension = 1;\n    this.position = \"end\";\n  }\n};\n__decorateClass([\n  Validate(INTERPOLATION_TYPE)\n], InterpolationProperties.prototype, \"type\", 2);\n__decorateClass([\n  Validate(RATIO)\n], InterpolationProperties.prototype, \"tension\", 2);\n__decorateClass([\n  Validate(INTERPOLATION_STEP_POSITION)\n], InterpolationProperties.prototype, \"position\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesProperties.ts\nvar AreaSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.xName = void 0;\n    this.defaultColorRange = [];\n    this.fill = \"#c16068\";\n    this.fillOpacity = 1;\n    this.stroke = \"#874349\";\n    this.strokeWidth = 2;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.interpolation = new InterpolationProperties();\n    this.shadow = new DropShadow();\n    this.marker = new SeriesMarker();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n    this.connectMissingData = false;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], AreaSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AreaSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING)\n], AreaSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AreaSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AreaSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], AreaSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], AreaSeriesProperties.prototype, \"defaultColorRange\", 2);\n__decorateClass([\n  Validate(OR(COLOR_GRADIENT, COLOR_STRING))\n], AreaSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], AreaSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], AreaSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AreaSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], AreaSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], AreaSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AreaSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"interpolation\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AreaSeriesProperties.prototype, \"connectMissingData\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolation.ts\nfunction spanRange(span) {\n  switch (span.type) {\n    case \"linear\":\n    case \"step\":\n      return [\n        { x: span.x0, y: span.y0 },\n        { x: span.x1, y: span.y1 }\n      ];\n    case \"cubic\":\n      return [\n        { x: span.cp0x, y: span.cp0y },\n        { x: span.cp3x, y: span.cp3y }\n      ];\n  }\n}\nfunction spanRangeNormalized(span) {\n  const range3 = spanRange(span);\n  if (range3[0].x > range3[1].x) {\n    range3.reverse();\n  }\n  return range3;\n}\nfunction collapseSpanToPoint(span, point) {\n  const { x, y } = point;\n  switch (span.type) {\n    case \"linear\":\n      return {\n        type: \"linear\",\n        moveTo: span.moveTo,\n        x0: x,\n        y0: y,\n        x1: x,\n        y1: y\n      };\n    case \"step\":\n      return {\n        type: \"step\",\n        moveTo: span.moveTo,\n        x0: x,\n        y0: y,\n        x1: x,\n        y1: y,\n        stepX: x\n      };\n    case \"cubic\":\n      return {\n        type: \"cubic\",\n        moveTo: span.moveTo,\n        cp0x: x,\n        cp0y: y,\n        cp1x: x,\n        cp1y: y,\n        cp2x: x,\n        cp2y: y,\n        cp3x: x,\n        cp3y: y\n      };\n  }\n}\nfunction rescaleSpan(span, nextStart, nextEnd) {\n  const [prevStart, prevEnd] = spanRange(span);\n  const widthScale = prevEnd.x !== prevStart.x ? (nextEnd.x - nextStart.x) / (prevEnd.x - prevStart.x) : 0;\n  const heightScale = prevEnd.y !== prevStart.y ? (nextEnd.y - nextStart.y) / (prevEnd.y - prevStart.y) : 0;\n  switch (span.type) {\n    case \"linear\":\n      return {\n        type: \"linear\",\n        moveTo: span.moveTo,\n        x0: nextStart.x,\n        y0: nextStart.y,\n        x1: nextEnd.x,\n        y1: nextEnd.y\n      };\n    case \"cubic\":\n      return {\n        type: \"cubic\",\n        moveTo: span.moveTo,\n        cp0x: nextStart.x,\n        cp0y: nextStart.y,\n        cp1x: nextEnd.x - (span.cp2x - prevStart.x) * widthScale,\n        cp1y: nextEnd.y - (span.cp2y - prevStart.y) * heightScale,\n        cp2x: nextEnd.x - (span.cp1x - prevStart.x) * widthScale,\n        cp2y: nextEnd.y - (span.cp1y - prevStart.y) * heightScale,\n        cp3x: nextEnd.x,\n        cp3y: nextEnd.y\n      };\n    case \"step\":\n      return {\n        type: \"step\",\n        moveTo: span.moveTo,\n        x0: nextStart.x,\n        y0: nextStart.y,\n        x1: nextEnd.x,\n        y1: nextEnd.y,\n        stepX: nextEnd.x - (span.stepX - prevStart.x) * widthScale\n      };\n  }\n}\nfunction clipSpanX(span, x0, x1) {\n  const { moveTo } = span;\n  const [start2, end2] = spanRangeNormalized(span);\n  const { x: spanX0, y: spanY0 } = start2;\n  const { x: spanX1, y: spanY1 } = end2;\n  if (x1 < spanX0) {\n    return rescaleSpan(span, start2, start2);\n  } else if (x0 > spanX1) {\n    return rescaleSpan(span, end2, end2);\n  }\n  switch (span.type) {\n    case \"linear\": {\n      const m = spanY0 === spanY1 ? void 0 : (spanY1 - spanY0) / (spanX1 - spanX0);\n      const y0 = m == null ? spanY0 : m * (x0 - spanX0) + spanY0;\n      const y1 = m == null ? spanY0 : m * (x1 - spanX0) + spanY0;\n      return { type: \"linear\", moveTo, x0, y0, x1, y1 };\n    }\n    case \"step\":\n      if (x1 <= span.stepX) {\n        const y = span.y0;\n        return { type: \"step\", moveTo, x0, y0: y, x1, y1: y, stepX: x1 };\n      } else if (x0 >= span.stepX) {\n        const y = span.y1;\n        return { type: \"step\", moveTo, x0, y0: y, x1, y1: y, stepX: x0 };\n      } else {\n        const { y0, y1, stepX } = span;\n        return { type: \"step\", moveTo, x0, y0, x1, y1, stepX };\n      }\n    case \"cubic\": {\n      const t0 = solveBezier(span.cp0x, span.cp1x, span.cp2x, span.cp3x, x0);\n      let [_unused, bezier] = splitBezier(\n        span.cp0x,\n        span.cp0y,\n        span.cp1x,\n        span.cp1y,\n        span.cp2x,\n        span.cp2y,\n        span.cp3x,\n        span.cp3y,\n        t0\n      );\n      const t1 = solveBezier(bezier[0].x, bezier[1].x, bezier[2].x, bezier[3].x, x1);\n      [bezier, _unused] = splitBezier(\n        bezier[0].x,\n        bezier[0].y,\n        bezier[1].x,\n        bezier[1].y,\n        bezier[2].x,\n        bezier[2].y,\n        bezier[3].x,\n        bezier[3].y,\n        t1\n      );\n      return {\n        type: \"cubic\",\n        moveTo,\n        cp0x: bezier[0].x,\n        cp0y: bezier[0].y,\n        cp1x: bezier[1].x,\n        cp1y: bezier[1].y,\n        cp2x: bezier[2].x,\n        cp2y: bezier[2].y,\n        cp3x: bezier[3].x,\n        cp3y: bezier[3].y\n      };\n    }\n  }\n}\nfunction linearPoints(points) {\n  const spans = [];\n  let i = 0;\n  let x0 = NaN;\n  let y0 = NaN;\n  for (const { x: x1, y: y1 } of points) {\n    if (i > 0) {\n      const moveTo = i === 1;\n      spans.push({ type: \"linear\", moveTo, x0, y0, x1, y1 });\n    }\n    i += 1;\n    x0 = x1;\n    y0 = y1;\n  }\n  return spans;\n}\nvar lineSteps = {\n  start: 0,\n  middle: 0.5,\n  end: 1\n};\nfunction stepPoints(points, position) {\n  const spans = [];\n  let i = 0;\n  let x0 = NaN;\n  let y0 = NaN;\n  const p0 = typeof position === \"number\" ? position : lineSteps[position];\n  for (const { x: x1, y: y1 } of points) {\n    if (i > 0) {\n      const moveTo = i === 1;\n      const stepX = x0 + (x1 - x0) * p0;\n      spans.push({ type: \"step\", moveTo, x0, y0, x1, y1, stepX });\n    }\n    i += 1;\n    x0 = x1;\n    y0 = y1;\n  }\n  return spans;\n}\nvar flatnessRatio = 0.05;\nfunction smoothPoints(iPoints, tension) {\n  const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);\n  if (points.length <= 1)\n    return [];\n  const gradients = points.map((c, i) => {\n    const p = i === 0 ? c : points[i - 1];\n    const n = i === points.length - 1 ? c : points[i + 1];\n    const isTerminalPoint = i === 0 || i === points.length - 1;\n    if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {\n      return 0;\n    }\n    if (!isTerminalPoint) {\n      const range3 = Math.abs(p.y - n.y);\n      const prevRatio = Math.abs(c.y - p.y) / range3;\n      const nextRatio = Math.abs(c.y - n.y) / range3;\n      if (prevRatio <= flatnessRatio || 1 - prevRatio <= flatnessRatio || nextRatio <= flatnessRatio || 1 - nextRatio <= flatnessRatio) {\n        return 0;\n      }\n    }\n    return (n.y - p.y) / (n.x - p.x);\n  });\n  if (gradients[1] === 0) {\n    gradients[0] *= 2;\n  }\n  if (gradients[gradients.length - 2] === 0) {\n    gradients[gradients.length - 1] *= 2;\n  }\n  const spans = [];\n  for (let i = 1; i < points.length; i += 1) {\n    const prev = points[i - 1];\n    const prevM = gradients[i - 1];\n    const cur = points[i];\n    const curM = gradients[i];\n    const dx = cur.x - prev.x;\n    const dy = cur.y - prev.y;\n    let dcp1x = dx * tension / 3;\n    let dcp1y = dx * prevM * tension / 3;\n    let dcp2x = dx * tension / 3;\n    let dcp2y = dx * curM * tension / 3;\n    if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy)) {\n      dcp1x *= Math.abs(dy / dcp1y);\n      dcp1y = Math.sign(dcp1y) * Math.abs(dy);\n    }\n    if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy)) {\n      dcp2x *= Math.abs(dy / dcp2y);\n      dcp2y = Math.sign(dcp2y) * Math.abs(dy);\n    }\n    spans.push({\n      type: \"cubic\",\n      moveTo: i === 1,\n      cp0x: prev.x,\n      cp0y: prev.y,\n      cp1x: prev.x + dcp1x,\n      cp1y: prev.y + dcp1y,\n      cp2x: cur.x - dcp2x,\n      cp2y: cur.y - dcp2y,\n      cp3x: cur.x,\n      cp3y: cur.y\n    });\n  }\n  return spans;\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationPlotting.ts\nfunction lerp2(a, b, ratio2) {\n  return (b - a) * ratio2 + a;\n}\nfunction linearSupertype(span, stepX) {\n  const { x0, y0, x1, y1 } = span;\n  const m = (y1 - y0) / (x1 - x0);\n  const stepY = m * (stepX - x0) + y0;\n  return {\n    leftCp1x: x0,\n    leftCp1y: y0,\n    leftCp2x: stepX,\n    leftCp2y: stepY,\n    stepX,\n    stepY0: stepY,\n    stepY1: stepY,\n    rightCp1x: stepX,\n    rightCp1y: stepY,\n    rightCp2x: x1,\n    rightCp2y: y1\n  };\n}\nfunction bezierSupertype(span, stepX) {\n  const { cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y } = span;\n  const t = solveBezier(cp0x, cp1x, cp2x, cp3x, stepX);\n  const [left, right] = splitBezier(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, t);\n  const stepY = left[3].y;\n  return {\n    leftCp1x: left[1].x,\n    leftCp1y: left[1].y,\n    leftCp2x: left[2].x,\n    leftCp2y: left[2].y,\n    stepX,\n    stepY0: stepY,\n    stepY1: stepY,\n    rightCp1x: right[1].x,\n    rightCp1y: right[1].y,\n    rightCp2x: right[2].x,\n    rightCp2y: right[2].y\n  };\n}\nfunction stepSupertype(span) {\n  const { x0, y0, x1, y1, stepX } = span;\n  return {\n    leftCp1x: (x0 + stepX) / 2,\n    leftCp1y: y0,\n    leftCp2x: (x0 + stepX) / 2,\n    leftCp2y: y0,\n    stepX,\n    stepY0: y0,\n    stepY1: y1,\n    rightCp1x: (stepX + x1) / 2,\n    rightCp1y: y1,\n    rightCp2x: (stepX + x1) / 2,\n    rightCp2y: y1\n  };\n}\nfunction spanSupertype(span, stepX) {\n  if (span.type === \"linear\") {\n    return linearSupertype(span, stepX);\n  } else if (span.type === \"cubic\") {\n    return bezierSupertype(span, stepX);\n  } else {\n    return stepSupertype(span);\n  }\n}\nfunction plotStart(path, moveTo, x0, y0, x1, y1, reversed) {\n  switch (moveTo) {\n    case 0 /* MoveTo */:\n      if (reversed) {\n        path.moveTo(x1, y1);\n      } else {\n        path.moveTo(x0, y0);\n      }\n      break;\n    case 1 /* LineTo */:\n      if (reversed) {\n        path.lineTo(x1, y1);\n      } else {\n        path.lineTo(x0, y0);\n      }\n      break;\n  }\n}\nfunction plotLinear(path, x0, y0, x1, y1, reversed) {\n  if (reversed) {\n    path.lineTo(x0, y0);\n  } else {\n    path.lineTo(x1, y1);\n  }\n}\nfunction plotCubic(path, cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, reversed) {\n  if (reversed) {\n    path.cubicCurveTo(cp2x, cp2y, cp1x, cp1y, cp0x, cp0y);\n  } else {\n    path.cubicCurveTo(cp1x, cp1y, cp2x, cp2y, cp3x, cp3y);\n  }\n}\nfunction plotStep(path, x0, y0, x1, y1, stepX, reversed) {\n  if (reversed) {\n    path.lineTo(stepX, y1);\n    path.lineTo(stepX, y0);\n    path.lineTo(x0, y0);\n  } else {\n    path.lineTo(stepX, y0);\n    path.lineTo(stepX, y1);\n    path.lineTo(x1, y1);\n  }\n}\nfunction plotSpan(path, span, moveTo, reversed) {\n  const [start2, end2] = spanRange(span);\n  plotStart(path, moveTo, start2.x, start2.y, end2.x, end2.y, reversed);\n  switch (span.type) {\n    case \"linear\":\n      plotLinear(path, span.x0, span.y0, span.x1, span.y1, reversed);\n      break;\n    case \"cubic\":\n      plotCubic(\n        path,\n        span.cp0x,\n        span.cp0y,\n        span.cp1x,\n        span.cp1y,\n        span.cp2x,\n        span.cp2y,\n        span.cp3x,\n        span.cp3y,\n        reversed\n      );\n      break;\n    case \"step\":\n      plotStep(path, span.x0, span.y0, span.x1, span.y1, span.stepX, reversed);\n      break;\n  }\n}\nfunction interpolatedSpanRange(a, b, ratio2) {\n  const [aStart, aEnd] = spanRange(a);\n  const [bStart, bEnd] = spanRange(b);\n  const x0 = lerp2(aStart.x, bStart.x, ratio2);\n  const y0 = lerp2(aStart.y, bStart.y, ratio2);\n  const x1 = lerp2(aEnd.x, bEnd.x, ratio2);\n  const y1 = lerp2(aEnd.y, bEnd.y, ratio2);\n  return [\n    { x: x0, y: y0 },\n    { x: x1, y: y1 }\n  ];\n}\nfunction plotInterpolatedSpans(path, a, b, ratio2, moveTo, reversed) {\n  const [{ x: x0, y: y0 }, { x: x1, y: y1 }] = interpolatedSpanRange(a, b, ratio2);\n  plotStart(path, moveTo, x0, y0, x1, y1, reversed);\n  if (a.type === \"cubic\" && b.type === \"cubic\") {\n    const cp1x = lerp2(a.cp1x, b.cp1x, ratio2);\n    const cp1y = lerp2(a.cp1y, b.cp1y, ratio2);\n    const cp2x = lerp2(a.cp2x, b.cp2x, ratio2);\n    const cp2y = lerp2(a.cp2y, b.cp2y, ratio2);\n    plotCubic(path, x0, y0, cp1x, cp1y, cp2x, cp2y, x1, y1, reversed);\n  } else if (a.type === \"step\" && b.type === \"step\") {\n    const stepX = lerp2(a.stepX, b.stepX, ratio2);\n    plotStep(path, x0, y0, x1, y1, stepX, reversed);\n  } else if (a.type === \"linear\" && b.type === \"linear\") {\n    plotLinear(path, x0, y0, x1, y1, reversed);\n  } else {\n    let defaultStepX;\n    if (a.type === \"step\") {\n      defaultStepX = a.stepX;\n    } else if (b.type === \"step\") {\n      defaultStepX = b.stepX;\n    } else {\n      defaultStepX = (x0 + x1) / 2;\n    }\n    const as = spanSupertype(a, defaultStepX);\n    const bs = spanSupertype(b, defaultStepX);\n    const leftCp1x = lerp2(as.leftCp1x, bs.leftCp1x, ratio2);\n    const leftCp1y = lerp2(as.leftCp1y, bs.leftCp1y, ratio2);\n    const leftCp2x = lerp2(as.leftCp2x, bs.leftCp2x, ratio2);\n    const leftCp2y = lerp2(as.leftCp2y, bs.leftCp2y, ratio2);\n    const stepX = lerp2(as.stepX, bs.stepX, ratio2);\n    const stepY0 = lerp2(as.stepY0, bs.stepY0, ratio2);\n    const stepY1 = lerp2(as.stepY1, bs.stepY1, ratio2);\n    const rightCp1x = lerp2(as.rightCp1x, bs.rightCp1x, ratio2);\n    const rightCp1y = lerp2(as.rightCp1y, bs.rightCp1y, ratio2);\n    const rightCp2x = lerp2(as.rightCp2x, bs.rightCp2x, ratio2);\n    const rightCp2y = lerp2(as.rightCp2y, bs.rightCp2y, ratio2);\n    if (reversed) {\n      path.cubicCurveTo(rightCp2x, rightCp2y, rightCp1x, rightCp1y, stepX, stepY1);\n      path.lineTo(stepX, stepY0);\n      path.cubicCurveTo(leftCp2x, leftCp2y, leftCp1x, leftCp1y, x0, y0);\n    } else {\n      path.cubicCurveTo(leftCp1x, leftCp1y, leftCp2x, leftCp2y, stepX, stepY0);\n      path.lineTo(stepX, stepY1);\n      path.cubicCurveTo(rightCp1x, rightCp1y, rightCp2x, rightCp2y, x1, y1);\n    }\n  }\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationUtil.ts\nvar CollapseMode = /* @__PURE__ */ ((CollapseMode2) => {\n  CollapseMode2[CollapseMode2[\"Zero\"] = 0] = \"Zero\";\n  CollapseMode2[CollapseMode2[\"Split\"] = 1] = \"Split\";\n  return CollapseMode2;\n})(CollapseMode || {});\nfunction integratedCategoryMatch(a, b) {\n  if (a == null || b == null)\n    return false;\n  if (typeof a !== \"object\" || typeof b !== \"object\")\n    return false;\n  if (\"id\" in a && \"id\" in b) {\n    return a.id === b.id;\n  }\n  return a.toString() === b.toString();\n}\nfunction scale(val, scaling) {\n  if (!scaling)\n    return NaN;\n  if (val instanceof Date) {\n    val = val.getTime();\n  }\n  if (scaling.type === \"continuous\" && typeof val === \"number\") {\n    const domainRatio = (val - scaling.domain[0]) / (scaling.domain[1] - scaling.domain[0]);\n    return domainRatio * (scaling.range[1] - scaling.range[0]) + scaling.range[0];\n  }\n  if (scaling.type === \"log\" && typeof val === \"number\") {\n    return scaling.convert(val);\n  }\n  if (scaling.type !== \"category\")\n    return NaN;\n  const matchingIndex = scaling.domain.findIndex((d) => d === val);\n  if (matchingIndex >= 0) {\n    return scaling.inset + scaling.step * matchingIndex;\n  }\n  const matchingIntegratedIndex = scaling.domain.findIndex((d) => integratedCategoryMatch(val, d));\n  if (matchingIntegratedIndex >= 0) {\n    return scaling.inset + scaling.step * matchingIndex;\n  }\n  return NaN;\n}\nfunction toAxisValue(value) {\n  return transformIntegratedCategoryValue(value).valueOf();\n}\nfunction getAxisIndices({ data }, values) {\n  return data.map((datum, datumIndex) => ({\n    xValue0Index: values.indexOf(toAxisValue(datum.xValue0)),\n    xValue1Index: values.indexOf(toAxisValue(datum.xValue1)),\n    datumIndex\n  }));\n}\nfunction validateCategorySorting(newData, oldData) {\n  const oldScale = oldData.scales.x;\n  const newScale = newData.scales.x;\n  if (oldScale?.type !== \"category\" || newScale?.type !== \"category\")\n    return true;\n  let x0 = -Infinity;\n  for (const oldValue of oldScale.domain) {\n    const x = scale(oldValue, newScale);\n    if (!Number.isFinite(x))\n      continue;\n    if (x < x0) {\n      return false;\n    } else {\n      x0 = x;\n    }\n  }\n  return true;\n}\nfunction validateAxisEntriesOrder(axisValues, data) {\n  let x0 = -Infinity;\n  for (const axisValue of axisValues) {\n    const x = scale(axisValue.value, data.scales.x);\n    if (!Number.isFinite(x))\n      continue;\n    if (x < x0) {\n      return false;\n    } else {\n      x0 = x;\n    }\n  }\n  return true;\n}\nfunction spanAxisContext(newData, oldData) {\n  const allAxisEntries = /* @__PURE__ */ new Map();\n  for (const { xValue0, xValue1 } of newData.data) {\n    const xValue0Value = toAxisValue(xValue0);\n    const xValue1Value = toAxisValue(xValue1);\n    allAxisEntries.set(xValue0Value, xValue0).set(xValue1Value, xValue1);\n  }\n  const newAxisEntries = Array.from(allAxisEntries, ([axisValue, value]) => ({ axisValue, value }));\n  newAxisEntries.sort((a, b) => {\n    return scale(a.value, newData.scales.x) - scale(b.value, newData.scales.x);\n  });\n  const exclusivelyOldAxisEntries = [];\n  for (const { xValue0, xValue1 } of oldData.data) {\n    const xValue0Value = toAxisValue(xValue0);\n    const xValue1Value = toAxisValue(xValue1);\n    if (!allAxisEntries.has(xValue0Value)) {\n      allAxisEntries.set(xValue0Value, xValue0);\n      exclusivelyOldAxisEntries.push({ axisValue: xValue0Value, value: xValue0 });\n    }\n    if (!allAxisEntries.has(xValue1Value)) {\n      allAxisEntries.set(xValue1Value, xValue1);\n      exclusivelyOldAxisEntries.push({ axisValue: xValue1Value, value: xValue1 });\n    }\n  }\n  exclusivelyOldAxisEntries.sort((a, b) => {\n    return scale(a.value, oldData.scales.x) - scale(b.value, oldData.scales.x);\n  });\n  const axisEntries = newAxisEntries;\n  let insertionIndex = 0;\n  for (const oldAxisEntries of exclusivelyOldAxisEntries) {\n    for (let i = axisEntries.length - 1; i > insertionIndex; i -= 1) {\n      const oldValueX = scale(oldAxisEntries.value, oldData.scales.x);\n      const newValueX = scale(axisEntries[i].value, oldData.scales.x);\n      if (oldValueX > newValueX) {\n        insertionIndex = i + 1;\n        break;\n      }\n    }\n    axisEntries.splice(insertionIndex, 0, oldAxisEntries);\n    insertionIndex += 1;\n  }\n  if (!validateAxisEntriesOrder(axisEntries, oldData))\n    return;\n  const axisValues = axisEntries.map((axisEntry) => axisEntry.axisValue);\n  const oldDataAxisIndices = getAxisIndices(oldData, axisValues);\n  const newDataAxisIndices = getAxisIndices(newData, axisValues);\n  return { axisValues, oldDataAxisIndices, newDataAxisIndices };\n}\nfunction clipSpan(span, xValue0Index, xIndices) {\n  if (xIndices.xValue1Index === xIndices.xValue0Index + 1)\n    return span;\n  const range3 = spanRange(span);\n  const step = (range3[1].x - range3[0].x) / (xIndices.xValue1Index - xIndices.xValue0Index);\n  const start2 = range3[0].x + (xValue0Index - xIndices.xValue0Index) * step;\n  const end2 = start2 + step;\n  return clipSpanX(span, start2, end2);\n}\nfunction axisZeroSpan(span, data) {\n  const [r0, r1] = spanRange(span);\n  const y0 = scale(0, data.scales.y);\n  return rescaleSpan(span, { x: r0.x, y: y0 }, { x: r1.x, y: y0 });\n}\nfunction collapseSpanToMidpoint(span) {\n  const [r0, r1] = spanRange(span);\n  return collapseSpanToPoint(span, {\n    x: (r0.x + r1.x) / 2,\n    y: (r0.y + r1.y) / 2\n  });\n}\nfunction collapseSpan(span, collapseMode, data, axisIndices, indices, range3) {\n  let xValue;\n  let yValue;\n  if (indices.xValue0Index >= range3.xValue1Index) {\n    const datumIndex = axisIndices.findLast((i) => i.xValue1Index <= range3.xValue1Index)?.datumIndex;\n    const datum = datumIndex != null ? data.data[datumIndex] : void 0;\n    xValue = datum?.xValue1;\n    yValue = datum?.yValue1;\n  } else if (indices.xValue0Index <= range3.xValue0Index) {\n    const datumIndex = axisIndices.find((i) => i.xValue0Index >= range3.xValue0Index)?.datumIndex;\n    const datum = datumIndex != null ? data.data[datumIndex] : void 0;\n    xValue = datum?.xValue0;\n    yValue = datum?.yValue0;\n  }\n  if (xValue == null || yValue == null) {\n    switch (collapseMode) {\n      case 0 /* Zero */:\n        return axisZeroSpan(span, data);\n      case 1 /* Split */:\n        return collapseSpanToMidpoint(span);\n    }\n  }\n  const x = scale(xValue, data.scales.x);\n  const y = scale(yValue, data.scales.y);\n  const point = { x, y };\n  return rescaleSpan(span, point, point);\n}\nfunction zeroDataSpan(spanDatum, zeroData) {\n  if (zeroData == null)\n    return;\n  const newSpanXValue0 = toAxisValue(spanDatum.xValue0);\n  const newSpanXValue1 = toAxisValue(spanDatum.xValue1);\n  return zeroData.find(\n    (zeroSpanDatum) => toAxisValue(zeroSpanDatum.xValue0) === newSpanXValue0 && toAxisValue(zeroSpanDatum.xValue1) === newSpanXValue1\n  )?.span;\n}\nfunction addSpan(newData, collapseMode, newAxisIndices, newIndices, oldZeroData, range3, out) {\n  const newSpanDatum = newData.data[newIndices.datumIndex];\n  const newSpan = newSpanDatum.span;\n  const zeroSpan = zeroDataSpan(newSpanDatum, oldZeroData);\n  if (zeroSpan != null) {\n    out.removed.push({ from: zeroSpan, to: zeroSpan });\n    out.moved.push({ from: zeroSpan, to: newSpan });\n    out.added.push({ from: newSpan, to: newSpan });\n  } else {\n    const oldSpan = collapseSpan(newSpan, collapseMode, newData, newAxisIndices, newIndices, range3);\n    out.added.push({ from: oldSpan, to: newSpan });\n  }\n}\nfunction removeSpan(oldData, collapseMode, oldAxisIndices, oldIndices, newZeroData, range3, out) {\n  const oldSpanDatum = oldData.data[oldIndices.datumIndex];\n  const oldSpan = oldSpanDatum.span;\n  const zeroSpan = zeroDataSpan(oldSpanDatum, newZeroData);\n  if (zeroSpan != null) {\n    out.removed.push({ from: oldSpan, to: oldSpan });\n    out.moved.push({ from: oldSpan, to: zeroSpan });\n    out.added.push({ from: zeroSpan, to: zeroSpan });\n  } else {\n    const newSpan = collapseSpan(oldSpan, collapseMode, oldData, oldAxisIndices, oldIndices, range3);\n    out.removed.push({ from: oldSpan, to: newSpan });\n  }\n}\nfunction alignSpanToContainingSpan(span, axisValues, preData, postData, postSpanIndices) {\n  const startXValue0 = axisValues[postSpanIndices.xValue0Index];\n  const startDatum = preData.data.find((spanDatum) => toAxisValue(spanDatum.xValue0) === startXValue0);\n  const endXValue1 = axisValues[postSpanIndices.xValue1Index];\n  const endDatum = preData.data.find((spanDatum) => toAxisValue(spanDatum.xValue1) === endXValue1);\n  if (startDatum == null || endDatum == null)\n    return;\n  const [{ x: x0 }, { x: x1 }] = spanRange(span);\n  const startX = scale(startDatum.xValue0, preData.scales.x);\n  const startY = scale(startDatum.yValue0, preData.scales.y);\n  const endX = scale(endDatum.xValue1, preData.scales.x);\n  const endY = scale(endDatum.yValue1, preData.scales.y);\n  let altSpan = postData.data[postSpanIndices.datumIndex].span;\n  altSpan = rescaleSpan(altSpan, { x: startX, y: startY }, { x: endX, y: endY });\n  altSpan = clipSpanX(altSpan, x0, x1);\n  return altSpan;\n}\nfunction appendSpanPhases(newData, oldData, collapseMode, axisValues, xValue0Index, newAxisIndices, oldAxisIndices, range3, out) {\n  const xValue1Index = xValue0Index + 1;\n  const oldIndices = oldAxisIndices.find((i) => i.xValue0Index <= xValue0Index && i.xValue1Index >= xValue1Index);\n  const newIndices = newAxisIndices.find((i) => i.xValue0Index <= xValue0Index && i.xValue1Index >= xValue1Index);\n  const oldZeroData = oldData.zeroData;\n  const newZeroData = newData.zeroData;\n  if (oldIndices == null && newIndices != null) {\n    addSpan(newData, collapseMode, newAxisIndices, newIndices, oldZeroData, range3, out);\n    return;\n  } else if (oldIndices != null && newIndices == null) {\n    removeSpan(oldData, collapseMode, oldAxisIndices, oldIndices, newZeroData, range3, out);\n    return;\n  } else if (oldIndices == null || newIndices == null) {\n    return;\n  }\n  let ordering;\n  if (oldIndices.xValue0Index === newIndices.xValue0Index && oldIndices.xValue1Index === newIndices.xValue1Index) {\n    ordering = 0;\n  } else if (oldIndices.xValue0Index <= newIndices.xValue0Index && oldIndices.xValue1Index >= newIndices.xValue1Index) {\n    ordering = -1;\n  } else if (oldIndices.xValue0Index >= newIndices.xValue0Index && oldIndices.xValue1Index <= newIndices.xValue1Index) {\n    ordering = 1;\n  } else {\n    ordering = 0;\n  }\n  const oldSpanDatum = oldData.data[oldIndices.datumIndex];\n  const clippedOldSpanOldScale = clipSpan(oldSpanDatum.span, xValue0Index, oldIndices);\n  const newSpanDatum = newData.data[newIndices.datumIndex];\n  const clippedNewSpanNewScale = clipSpan(newSpanDatum.span, xValue0Index, newIndices);\n  if (ordering === 1) {\n    const clippedPostRemoveOldSpanOldScale = alignSpanToContainingSpan(\n      clippedOldSpanOldScale,\n      axisValues,\n      oldData,\n      newData,\n      newIndices\n    );\n    if (clippedPostRemoveOldSpanOldScale != null) {\n      out.removed.push({ from: clippedOldSpanOldScale, to: clippedPostRemoveOldSpanOldScale });\n      out.moved.push({ from: clippedPostRemoveOldSpanOldScale, to: clippedNewSpanNewScale });\n      out.added.push({ from: clippedNewSpanNewScale, to: clippedNewSpanNewScale });\n    } else {\n      removeSpan(oldData, collapseMode, oldAxisIndices, oldIndices, newZeroData, range3, out);\n    }\n  } else if (ordering === -1) {\n    const clippedPreAddedNewSpanNewScale = alignSpanToContainingSpan(\n      clippedNewSpanNewScale,\n      axisValues,\n      newData,\n      oldData,\n      oldIndices\n    );\n    if (clippedPreAddedNewSpanNewScale != null) {\n      out.removed.push({ from: clippedOldSpanOldScale, to: clippedOldSpanOldScale });\n      out.moved.push({ from: clippedOldSpanOldScale, to: clippedPreAddedNewSpanNewScale });\n      out.added.push({ from: clippedPreAddedNewSpanNewScale, to: clippedNewSpanNewScale });\n    } else {\n      addSpan(newData, collapseMode, newAxisIndices, newIndices, oldZeroData, range3, out);\n    }\n  } else {\n    out.removed.push({ from: clippedOldSpanOldScale, to: clippedOldSpanOldScale });\n    out.moved.push({ from: clippedOldSpanOldScale, to: clippedNewSpanNewScale });\n    out.added.push({ from: clippedNewSpanNewScale, to: clippedNewSpanNewScale });\n  }\n}\nfunction phaseAnimation(axisContext, newData, oldData, collapseMode) {\n  const out = {\n    removed: [],\n    moved: [],\n    added: []\n  };\n  const { axisValues, oldDataAxisIndices, newDataAxisIndices } = axisContext;\n  const range3 = {\n    xValue0Index: Math.max(\n      oldDataAxisIndices.at(0)?.xValue0Index ?? -Infinity,\n      newDataAxisIndices.at(0)?.xValue0Index ?? -Infinity\n    ),\n    xValue1Index: Math.min(\n      oldDataAxisIndices.at(-1)?.xValue1Index ?? Infinity,\n      newDataAxisIndices.at(-1)?.xValue1Index ?? Infinity\n    )\n  };\n  for (let xValue0Index = 0; xValue0Index < axisValues.length - 1; xValue0Index += 1) {\n    appendSpanPhases(\n      newData,\n      oldData,\n      collapseMode,\n      axisValues,\n      xValue0Index,\n      newDataAxisIndices,\n      oldDataAxisIndices,\n      range3,\n      out\n    );\n  }\n  return out;\n}\nfunction resetSpan(data, spanDatum, collapseMode) {\n  const { span } = spanDatum;\n  switch (collapseMode) {\n    case 0 /* Zero */:\n      return zeroDataSpan(spanDatum, data.zeroData) ?? axisZeroSpan(span, data);\n    case 1 /* Split */:\n      return collapseSpanToMidpoint(span);\n  }\n}\nfunction resetAnimation(newData, oldData, collapseMode) {\n  const added = [];\n  const removed = [];\n  for (const oldSpanDatum of oldData.data) {\n    const oldSpan = oldSpanDatum.span;\n    const collapsedSpan = resetSpan(oldData, oldSpanDatum, collapseMode);\n    removed.push({ from: oldSpan, to: collapsedSpan });\n  }\n  for (const newSpanDatum of newData.data) {\n    const newSpan = newSpanDatum.span;\n    const collapsedSpan = resetSpan(newData, newSpanDatum, collapseMode);\n    added.push({ from: collapsedSpan, to: newSpan });\n  }\n  return {\n    removed,\n    moved: [],\n    added\n  };\n}\nfunction pairUpSpans(newData, oldData, collapseMode) {\n  if (!validateCategorySorting(newData, oldData))\n    return;\n  const axisContext = spanAxisContext(newData, oldData);\n  return axisContext == null ? resetAnimation(newData, oldData, collapseMode) : phaseAnimation(axisContext, newData, oldData, collapseMode);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/scaling.ts\nfunction isContinuousScaling(scaling) {\n  return scaling.type === \"continuous\" || scaling.type === \"log\";\n}\nfunction isCategoryScaling(scaling) {\n  return scaling.type === \"category\";\n}\nfunction areScalingEqual(a, b) {\n  if (a === void 0 || b === void 0) {\n    return a !== void 0 || b !== void 0;\n  }\n  if (isContinuousScaling(a) && isContinuousScaling(b)) {\n    return a.type === b.type && arraysEqual(a.domain, b.domain) && arraysEqual(a.range, b.range);\n  }\n  if (isCategoryScaling(a) && isCategoryScaling(b)) {\n    return a.inset === b.inset && a.step === b.step && arraysEqual(a.domain, b.domain);\n  }\n  return false;\n}\nfunction isScaleValid(scale2) {\n  if (scale2 == null)\n    return false;\n  if (scale2.type === \"category\")\n    return scale2.domain.every((v) => v != null);\n  return scale2.domain.every((v) => Number.isFinite(v) || v instanceof Date) && scale2.range.every((v) => Number.isFinite(v));\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineUtil.ts\nfunction interpolatePoints(points, interpolation) {\n  let spans;\n  const pointsIter = points.map((point) => point.point);\n  switch (interpolation.type) {\n    case \"linear\":\n      spans = linearPoints(pointsIter);\n      break;\n    case \"smooth\":\n      spans = smoothPoints(pointsIter, interpolation.tension);\n      break;\n    case \"step\":\n      spans = stepPoints(pointsIter, interpolation.position);\n      break;\n  }\n  return spans.map((span, i) => ({\n    span,\n    xValue0: points[i].xDatum,\n    yValue0: points[i].yDatum,\n    xValue1: points[i + 1].xDatum,\n    yValue1: points[i + 1].yDatum\n  }));\n}\nfunction pointsEq(a, b, delta3 = 1e-3) {\n  return Math.abs(a.x - b.x) < delta3 && Math.abs(a.y - b.y) < delta3;\n}\nfunction plotLinePathStroke({ path }, spans) {\n  let lastPoint;\n  for (const { span } of spans) {\n    const [start2, end2] = spanRange(span);\n    const join = lastPoint != null && pointsEq(lastPoint, start2) ? 1 /* LineTo */ : 0 /* MoveTo */;\n    plotSpan(path, span, join, false);\n    lastPoint = end2;\n  }\n}\nfunction plotInterpolatedLinePathStroke(ratio2, path, spans) {\n  let lastPoint;\n  for (const span of spans) {\n    const [start2, end2] = interpolatedSpanRange(span.from, span.to, ratio2);\n    const join = lastPoint != null && pointsEq(lastPoint, start2) ? 1 /* LineTo */ : 0 /* MoveTo */;\n    plotInterpolatedSpans(path.path, span.from, span.to, ratio2, join, false);\n    lastPoint = end2;\n  }\n}\nfunction prepareLinePathStrokeAnimationFns(status, spans, visibleToggleMode) {\n  const removePhaseFn = (ratio2, path) => plotInterpolatedLinePathStroke(ratio2, path, spans.removed);\n  const updatePhaseFn = (ratio2, path) => plotInterpolatedLinePathStroke(ratio2, path, spans.moved);\n  const addPhaseFn = (ratio2, path) => plotInterpolatedLinePathStroke(ratio2, path, spans.added);\n  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\n  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\n}\nfunction prepareLinePathPropertyAnimation(status, visibleToggleMode) {\n  const phase = visibleToggleMode === \"none\" ? \"updated\" : status;\n  const result = {\n    fromFn: (_path) => {\n      let mixin;\n      if (status === \"removed\") {\n        mixin = { finish: { visible: false } };\n      } else if (status === \"added\") {\n        mixin = { start: { visible: true } };\n      } else {\n        mixin = {};\n      }\n      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase], ...mixin };\n    },\n    toFn: (_path) => {\n      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase] };\n    }\n  };\n  if (visibleToggleMode === \"fade\") {\n    return {\n      fromFn: (path) => {\n        const opacity = status === \"added\" ? 0 : path.opacity;\n        return { opacity, ...result.fromFn(path) };\n      },\n      toFn: (path) => {\n        const opacity = status === \"removed\" ? 0 : 1;\n        return { opacity, ...result.toFn(path) };\n      }\n    };\n  }\n  return result;\n}\nfunction prepareLinePathAnimation(newData, oldData, diff2) {\n  const isCategoryBased = newData.scales.x?.type === \"category\";\n  const wasCategoryBased = oldData.scales.x?.type === \"category\";\n  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {\n    return;\n  }\n  if (newData.strokeData == null || oldData.strokeData == null) {\n    return;\n  }\n  let status = \"updated\";\n  if (oldData.visible && !newData.visible) {\n    status = \"removed\";\n  } else if (!oldData.visible && newData.visible) {\n    status = \"added\";\n  }\n  const strokeSpans = pairUpSpans(\n    { scales: newData.scales, data: newData.strokeData.spans },\n    { scales: oldData.scales, data: oldData.strokeData.spans },\n    1 /* Split */\n  );\n  if (strokeSpans == null)\n    return;\n  const stroke2 = prepareLinePathStrokeAnimationFns(status, strokeSpans, \"fade\");\n  const hasMotion = (diff2?.changed ?? true) || !areScalingEqual(newData.scales.x, oldData.scales.x) || !areScalingEqual(newData.scales.y, oldData.scales.y) || status !== \"updated\";\n  return { status, stroke: stroke2, hasMotion };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaUtil.ts\nfunction plotAreaPathFill({ path }, { spans, phantomSpans }) {\n  for (let i = 0; i < spans.length; i += 1) {\n    const { span } = spans[i];\n    const phantomSpan = phantomSpans[i].span;\n    plotSpan(path, span, 0 /* MoveTo */, false);\n    plotSpan(path, phantomSpan, 1 /* LineTo */, true);\n    path.closePath();\n  }\n}\nfunction plotInterpolatedAreaSeriesFillSpans(ratio2, { path }, spans, fillPhantomSpans) {\n  for (let i = 0; i < spans.length; i += 1) {\n    const span = spans[i];\n    const reversedPhantomSpan = fillPhantomSpans[i];\n    plotInterpolatedSpans(path, span.from, span.to, ratio2, 0 /* MoveTo */, false);\n    plotInterpolatedSpans(path, reversedPhantomSpan.from, reversedPhantomSpan.to, ratio2, 1 /* LineTo */, true);\n    path.closePath();\n  }\n}\nfunction prepareAreaFillAnimationFns(status, spans, fillPhantomSpans, visibleToggleMode) {\n  const removePhaseFn = (ratio2, path) => plotInterpolatedAreaSeriesFillSpans(ratio2, path, spans.removed, fillPhantomSpans.removed);\n  const updatePhaseFn = (ratio2, path) => plotInterpolatedAreaSeriesFillSpans(ratio2, path, spans.moved, fillPhantomSpans.moved);\n  const addPhaseFn = (ratio2, path) => plotInterpolatedAreaSeriesFillSpans(ratio2, path, spans.added, fillPhantomSpans.added);\n  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\n  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\n}\nfunction prepareAreaPathAnimation(newData, oldData) {\n  const isCategoryBased = newData.scales.x?.type === \"category\";\n  const wasCategoryBased = oldData.scales.x?.type === \"category\";\n  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {\n    return;\n  }\n  let status = \"updated\";\n  if (oldData.visible && !newData.visible) {\n    status = \"removed\";\n  } else if (!oldData.visible && newData.visible) {\n    status = \"added\";\n  }\n  const fillSpans = pairUpSpans(\n    { scales: newData.scales, data: newData.fillData.spans },\n    { scales: oldData.scales, data: oldData.fillData.spans },\n    0 /* Zero */\n  );\n  if (fillSpans == null)\n    return;\n  const fillPhantomSpans = pairUpSpans(\n    { scales: newData.scales, data: newData.fillData.phantomSpans },\n    { scales: oldData.scales, data: oldData.fillData.phantomSpans },\n    0 /* Zero */\n  );\n  if (fillPhantomSpans == null)\n    return;\n  const strokeSpans = pairUpSpans(\n    {\n      scales: newData.scales,\n      data: newData.strokeData.spans,\n      zeroData: newData.fillData.phantomSpans\n    },\n    {\n      scales: oldData.scales,\n      data: oldData.strokeData.spans,\n      zeroData: oldData.fillData.phantomSpans\n    },\n    0 /* Zero */\n  );\n  if (strokeSpans == null)\n    return;\n  const fadeMode = \"none\";\n  const fill = prepareAreaFillAnimationFns(status, fillSpans, fillPhantomSpans, fadeMode);\n  const stroke2 = prepareLinePathStrokeAnimationFns(status, strokeSpans, fadeMode);\n  return { status, fill, stroke: stroke2 };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/markerUtil.ts\nfunction markerFadeInAnimation({ id }, animationManager, status, ...markerSelections) {\n  const params = { phase: status ? NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] : \"trailing\" };\n  staticFromToMotion(id, \"markers\", animationManager, markerSelections, { opacity: 0 }, { opacity: 1 }, params);\n  markerSelections.forEach((s) => s.cleanup());\n}\nfunction markerScaleInAnimation({ id }, animationManager, ...markerSelections) {\n  staticFromToMotion(\n    id,\n    \"markers\",\n    animationManager,\n    markerSelections,\n    { scalingX: 0, scalingY: 0 },\n    { scalingX: 1, scalingY: 1 },\n    { phase: \"initial\" }\n  );\n  markerSelections.forEach((s) => s.cleanup());\n}\nfunction markerSwipeScaleInAnimation({ id, nodeDataDependencies }, animationManager, ...markerSelections) {\n  const seriesWidth = nodeDataDependencies.seriesRectWidth;\n  const fromFn = (_, datum) => {\n    const x = datum.midPoint?.x ?? seriesWidth;\n    let delay = clamp(0, inverseEaseOut(x / seriesWidth), 1);\n    if (isNaN(delay)) {\n      delay = 0;\n    }\n    return { scalingX: 0, scalingY: 0, delay, duration: QUICK_TRANSITION, phase: \"initial\" };\n  };\n  const toFn = () => {\n    return { scalingX: 1, scalingY: 1 };\n  };\n  fromToMotion(id, \"markers\", animationManager, markerSelections, { fromFn, toFn });\n}\nfunction resetMarkerFn(_node) {\n  return { opacity: 1, scalingX: 1, scalingY: 1 };\n}\nfunction resetMarkerPositionFn(_node, datum) {\n  return {\n    translationX: datum.point?.x ?? NaN,\n    translationY: datum.point?.y ?? NaN\n  };\n}\nfunction computeMarkerFocusBounds(series, { datumIndex }) {\n  const nodeData = series.getNodeData();\n  if (nodeData === void 0)\n    return void 0;\n  const datum = nodeData[datumIndex];\n  const { point } = datum;\n  if (datum == null || point == null)\n    return void 0;\n  const size = 4 + (point.focusSize ?? series.getFormattedMarkerStyle(datum).size);\n  const radius = size / 2;\n  const x = datum.point.x - radius;\n  const y = datum.point.y - radius;\n  return Transformable.toCanvas(series.contentGroup, new BBox(x, y, size, size));\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/pathUtil.ts\nfunction pathSwipeInAnimation({ id, visible, nodeDataDependencies }, animationManager, ...paths) {\n  const { seriesRectWidth: width2, seriesRectHeight: height2 } = nodeDataDependencies;\n  staticFromToMotion(\n    id,\n    \"path_properties\",\n    animationManager,\n    paths,\n    { clipX: 0 },\n    { clipX: width2 },\n    {\n      phase: \"initial\",\n      start: { clip: true, clipY: height2, visible },\n      finish: { clip: false, visible }\n    }\n  );\n}\nfunction pathFadeInAnimation({ id }, subId, animationManager, phase = \"add\", ...selection) {\n  staticFromToMotion(id, subId, animationManager, selection, { opacity: 0 }, { opacity: 1 }, { phase });\n}\nfunction buildResetPathFn(opts) {\n  return (_node) => ({\n    visible: opts.getVisible(),\n    opacity: opts.getOpacity(),\n    clipScalingX: 1,\n    clip: false\n  });\n}\nfunction updateClipPath({ nodeDataDependencies }, path) {\n  const toFinite = (value) => isFinite(value) ? value : 0;\n  path.clipX = toFinite(nodeDataDependencies.seriesRectWidth);\n  path.clipY = toFinite(nodeDataDependencies.seriesRectHeight);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeries.ts\nvar CROSS_FILTER_AREA_FILL_OPACITY_FACTOR = 0.125;\nvar CROSS_FILTER_AREA_STROKE_OPACITY_FACTOR = 0.25;\nvar AreaSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pathsPerSeries: [\"fill\", \"stroke\"],\n      pathsZIndexSubOrderOffset: [0, 1e3],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      pickModes: [2 /* AXIS_ALIGNED */, 0 /* EXACT_SHAPE_MATCH */],\n      animationResetFns: {\n        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),\n        label: resetLabelFn,\n        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })\n      }\n    });\n    this.properties = new AreaSeriesProperties();\n    this.connectsToYAxis = true;\n    this.backgroundGroup = new Group({\n      name: `${this.id}-background`,\n      zIndex: 0 /* BACKGROUND */\n    });\n    this._isStacked = void 0;\n  }\n  get pickModeAxis() {\n    return \"main\";\n  }\n  renderToOffscreenCanvas() {\n    return super.renderToOffscreenCanvas() || this.contextNodeData != null && (this.contextNodeData.fillData.spans.length > RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD || this.contextNodeData.strokeData.spans.length > RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD);\n  }\n  attachSeries(seriesContentNode, seriesNode, annotationNode) {\n    super.attachSeries(seriesContentNode, seriesNode, annotationNode);\n    seriesContentNode.appendChild(this.backgroundGroup);\n  }\n  detachSeries(seriesContentNode, seriesNode, annotationNode) {\n    super.detachSeries(seriesContentNode, seriesNode, annotationNode);\n    seriesContentNode?.removeChild(this.backgroundGroup);\n  }\n  attachPaths([fill, stroke2]) {\n    this.backgroundGroup.appendChild(fill);\n    this.contentGroup.appendChild(stroke2);\n    stroke2.zIndex = -1;\n  }\n  detachPaths([fill, stroke2]) {\n    this.backgroundGroup.removeChild(fill);\n    this.contentGroup.removeChild(stroke2);\n  }\n  isStacked() {\n    const stackCount = this.seriesGrouping?.stackCount ?? 1;\n    return stackCount > 1;\n  }\n  setSeriesIndex(index) {\n    const isStacked = this.isStacked();\n    if (!super.setSeriesIndex(index) && this._isStacked === isStacked)\n      return false;\n    this._isStacked = isStacked;\n    if (isStacked) {\n      this.backgroundGroup.zIndex = [0 /* BACKGROUND */, index];\n      this.contentGroup.zIndex = [1 /* ANY_CONTENT */, index, 0 /* FOREGROUND */];\n    } else {\n      this.backgroundGroup.zIndex = [1 /* ANY_CONTENT */, index, 0 /* FOREGROUND */, 0];\n      this.contentGroup.zIndex = [1 /* ANY_CONTENT */, index, 0 /* FOREGROUND */, 1];\n    }\n    return true;\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;\n    const { xKey, yKey, yFilterKey, connectMissingData, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const idMap = {\n      value: `area-stack-${groupIndex}-yValue`,\n      values: `area-stack-${groupIndex}-yValues`,\n      stack: `area-stack-${groupIndex}-yValue-stack`,\n      marker: `area-stack-${groupIndex}-yValues-marker`\n    };\n    const extraProps = [];\n    if (isDefined(normalizedTo)) {\n      extraProps.push(normaliseGroupTo(Object.values(idMap), normalizedTo));\n    }\n    if (animationEnabled) {\n      extraProps.push(animationValidation());\n    }\n    const common = { invalidValue: null };\n    if ((isDefined(normalizedTo) || connectMissingData) && stackCount > 1) {\n      common.invalidValue = 0;\n    }\n    if (!visible) {\n      common.forceValue = 0;\n    }\n    await this.requestDataModel(dataController, data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xValue\" }),\n        valueProperty(yKey, yScaleType, { id: `yValueRaw`, ...common }),\n        ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: \"yFilterRaw\" })] : [],\n        ...groupStackValueProperty(yKey, yScaleType, { id: `yValueStack`, ...common, groupId: idMap.stack }),\n        valueProperty(yKey, yScaleType, { id: `yValue`, ...common, groupId: idMap.value }),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window\",\n          \"current\",\n          { id: `yValueEnd`, ...common, groupId: idMap.values },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          { id: `yValueCumulative`, ...common, groupId: idMap.marker },\n          yScaleType\n        ),\n        ...extraProps\n      ],\n      groupByKeys: true,\n      groupByData: false\n    });\n    this.animationState.transition(\"updateData\");\n  }\n  xCoordinateRange(xValue, pixelSize) {\n    const { marker } = this.properties;\n    const x = this.axes[\"x\" /* X */].scale.convert(xValue);\n    const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;\n    return [x - r, x + r];\n  }\n  yCoordinateRange(yValues, pixelSize) {\n    const { marker } = this.properties;\n    const y = this.axes[\"y\" /* Y */].scale.convert(yValues[0]);\n    const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;\n    return [y - r, y + r];\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, axes } = this;\n    if (!processedData || !dataModel)\n      return [];\n    const yAxis = axes[\"y\" /* Y */];\n    if (direction === \"x\" /* X */) {\n      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n      const keys = dataModel.getDomain(this, `xValue`, \"key\", processedData);\n      if (keyDef?.def.type === \"key\" && keyDef.def.valueType === \"category\") {\n        return keys;\n      }\n      return fixNumericExtent(extent(keys));\n    }\n    const yExtent = this.domainForClippedRange(\"y\" /* Y */, [\"yValueEnd\"], \"xValue\", true);\n    if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {\n      return fixNumericExtent(yExtent);\n    } else {\n      const fixedYExtent = Number.isFinite(yExtent[1] - yExtent[0]) ? [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]] : [];\n      return fixNumericExtent(fixedYExtent);\n    }\n  }\n  getSeriesRange(_direction, visibleRange) {\n    const [y0, y1] = this.domainForVisibleRange(\"y\" /* Y */, [\"yValueEnd\"], \"xValue\", visibleRange, true);\n    return [Math.min(y0, 0), Math.max(y1, 0)];\n  }\n  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {\n    return this.countVisibleItems(\"xValue\", [\"yValueEnd\"], xVisibleRange, yVisibleRange, minVisibleItems);\n  }\n  createNodeData() {\n    const { axes, data, processedData, dataModel } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!xAxis || !yAxis || !data || !dataModel || processedData?.type !== \"grouped\" || !this.properties.isValid()) {\n      return;\n    }\n    const {\n      yKey,\n      xKey,\n      yFilterKey,\n      marker,\n      label,\n      fill: seriesFill,\n      stroke: seriesStroke,\n      connectMissingData,\n      interpolation\n    } = this.properties;\n    const { scale: xScale } = xAxis;\n    const { scale: yScale } = yAxis;\n    const { isContinuousY } = this.getScaleInformation({ xScale, yScale });\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const xValues = dataModel.resolveKeysById(this, \"xValue\", processedData);\n    const yEndValues = dataModel.resolveColumnById(this, `yValueEnd`, processedData);\n    const yRawValues = dataModel.resolveColumnById(this, `yValueRaw`, processedData);\n    const yCumulativeValues = dataModel.resolveColumnById(this, `yValueCumulative`, processedData);\n    const yFilterValues = yFilterKey != null ? dataModel.resolveColumnById(this, \"yFilterRaw\", processedData) : void 0;\n    const yStackValues = dataModel.resolveColumnById(this, \"yValueStack\", processedData);\n    const createMarkerCoordinate = (xDatum, yEnd, rawYDatum) => {\n      let currY;\n      if (isDefined(this.properties.normalizedTo) ? isContinuousY && isContinuous(rawYDatum) : !isNaN(rawYDatum)) {\n        currY = yEnd;\n      }\n      return {\n        x: xScale.convert(xDatum) + xOffset,\n        y: yScale.convert(currY),\n        size: marker.size\n      };\n    };\n    const labelData = [];\n    const markerData = [];\n    const { visibleSameStackCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);\n    let crossFiltering = false;\n    const { dataSources } = processedData;\n    const rawData = dataSources.get(this.id) ?? [];\n    for (const { datumIndex } of dataModel.forEachGroupDatum(this, processedData)) {\n      const xDatum = xValues[datumIndex];\n      if (xDatum == null)\n        return;\n      const seriesDatum = rawData[datumIndex];\n      const yDatum = yRawValues[datumIndex];\n      const yValueCumulative = yCumulativeValues[datumIndex];\n      const yValueEnd = yEndValues[datumIndex];\n      const validPoint = Number.isFinite(yDatum);\n      const point = createMarkerCoordinate(xDatum, +yValueCumulative, yDatum);\n      const selected = yFilterValues != null ? yFilterValues[datumIndex] === yDatum : void 0;\n      if (selected === false) {\n        crossFiltering = true;\n      }\n      if (validPoint && marker) {\n        markerData.push({\n          series: this,\n          itemId: yKey,\n          datum: seriesDatum,\n          datumIndex,\n          midPoint: { x: point.x, y: point.y },\n          cumulativeValue: yValueEnd,\n          yValue: yDatum,\n          xValue: xDatum,\n          yKey,\n          xKey,\n          point,\n          fill: marker.fill ?? seriesFill,\n          stroke: marker.stroke ?? seriesStroke,\n          strokeWidth: marker.strokeWidth ?? this.getStrokeWidth(this.properties.strokeWidth),\n          selected\n        });\n      }\n      if (validPoint && label) {\n        const labelText = this.getLabelText(label, {\n          value: yDatum,\n          datum: seriesDatum,\n          xKey,\n          yKey,\n          xName: this.properties.xName,\n          yName: this.properties.yName\n        });\n        labelData.push({\n          series: this,\n          itemId: yKey,\n          datum: seriesDatum,\n          datumIndex,\n          x: point.x,\n          y: point.y,\n          labelText\n        });\n      }\n    }\n    const spansForPoints = (points) => {\n      return points.flatMap((p) => {\n        return Array.isArray(p) ? interpolatePoints(p, interpolation) : new Array(p.skip).fill(null);\n      });\n    };\n    const createPoint = (xDatum, yDatum) => ({\n      point: {\n        x: xScale.convert(xDatum) + xOffset,\n        y: yScale.convert(yDatum)\n      },\n      xDatum,\n      yDatum\n    });\n    const getSeriesSpans = (index) => {\n      const points = [];\n      for (const {\n        datumIndexes: [pIdx, datumIndex, nIndx]\n      } of dataModel.forEachGroupDatumTuple(this, processedData)) {\n        const xDatum = xValues[datumIndex];\n        const yValueStack = yStackValues[datumIndex];\n        const yDatum = yValueStack[index];\n        const yDatumIsFinite = Number.isFinite(yDatum);\n        if (connectMissingData && !yDatumIsFinite)\n          continue;\n        const lastYValueStack = pIdx != null ? yStackValues[pIdx] : void 0;\n        const nextYValueStack = nIndx != null ? yStackValues[nIndx] : void 0;\n        let yValueEndBackwards = 0;\n        let yValueEndForwards = 0;\n        for (let j = 0; j <= index; j += 1) {\n          const value = yValueStack[j];\n          if (Number.isFinite(value)) {\n            const lastWasFinite = lastYValueStack == null || Number.isFinite(lastYValueStack[j]);\n            const nextWasFinite = nextYValueStack == null || Number.isFinite(nextYValueStack[j]);\n            if (lastWasFinite) {\n              yValueEndBackwards += value;\n            }\n            if (nextWasFinite) {\n              yValueEndForwards += value;\n            }\n          }\n        }\n        const currentPoints = points[points.length - 1];\n        if (!connectMissingData && (yValueEndBackwards !== yValueEndForwards || !yDatumIsFinite)) {\n          if (!yDatumIsFinite && Array.isArray(currentPoints) && currentPoints.length === 1) {\n            points[points.length - 1] = { skip: 1 };\n          } else {\n            const pointBackwards = createPoint(xDatum, yValueEndBackwards);\n            const pointForwards = createPoint(xDatum, yValueEndForwards);\n            if (Array.isArray(currentPoints)) {\n              currentPoints.push(pointBackwards);\n            } else if (currentPoints != null) {\n              currentPoints.skip += 1;\n            }\n            points.push(yDatumIsFinite ? [pointForwards] : { skip: 0 });\n          }\n        } else {\n          const yValueEnd = Math.max(yValueEndBackwards, yValueEndForwards);\n          const point = createPoint(xDatum, yValueEnd);\n          if (Array.isArray(currentPoints)) {\n            currentPoints.push(point);\n          } else if (currentPoints != null) {\n            currentPoints.skip += 1;\n            points.push([point]);\n          } else {\n            points.push([point]);\n          }\n        }\n      }\n      return spansForPoints(points);\n    };\n    const stackIndex = this.seriesGrouping?.stackIndex ?? 0;\n    const getAxisSpans = () => {\n      const yValueZeroPoints = Array.from(dataModel.forEachGroupDatum(this, processedData), ({ datumIndex }) => {\n        const xDatum = xValues[datumIndex];\n        const yValueStack = yStackValues[datumIndex];\n        const yDatum = yValueStack[stackIndex];\n        if (connectMissingData && !Number.isFinite(yDatum))\n          return;\n        return createPoint(xDatum, 0);\n      }).filter((x) => x != null);\n      return interpolatePoints(yValueZeroPoints, interpolation);\n    };\n    const currentSeriesSpans = getSeriesSpans(stackIndex);\n    const phantomSpans = currentSeriesSpans.map(() => null);\n    for (let j = stackIndex - 1; j >= -1; j -= 1) {\n      let spans;\n      for (let i = 0; i < phantomSpans.length; i += 1) {\n        if (phantomSpans[i] != null)\n          continue;\n        spans ?? (spans = j !== -1 ? getSeriesSpans(j) : getAxisSpans());\n        phantomSpans[i] = spans[i];\n      }\n    }\n    const fillSpans = currentSeriesSpans.map((span, index) => span ?? phantomSpans[index]);\n    const strokeSpans = currentSeriesSpans.filter((span) => span != null);\n    const context = {\n      itemId: yKey,\n      fillData: { itemId: yKey, spans: fillSpans, phantomSpans },\n      strokeData: { itemId: yKey, spans: strokeSpans },\n      labelData,\n      nodeData: markerData,\n      scales: this.calculateScaling(),\n      visible: this.visible,\n      stackVisible: visibleSameStackCount > 0,\n      crossFiltering\n    };\n    return context;\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  updatePathNodes(opts) {\n    const { opacity, visible, animationEnabled } = opts;\n    const [fill, stroke2] = opts.paths;\n    const crossFiltering = this.contextNodeData?.crossFiltering === true;\n    const strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);\n    stroke2.setProperties({\n      fill: void 0,\n      lineCap: \"round\",\n      lineJoin: \"round\",\n      pointerEvents: 1 /* None */,\n      stroke: this.properties.stroke,\n      strokeWidth,\n      strokeOpacity: this.properties.strokeOpacity * (crossFiltering ? CROSS_FILTER_AREA_STROKE_OPACITY_FACTOR : 1),\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset,\n      opacity,\n      visible: visible || animationEnabled\n    });\n    const { fill: seriesFill } = this.properties;\n    if (isGradientFill(seriesFill)) {\n      const gradientFillOptions = this.getGradientFillOptions(seriesFill, this.properties.defaultColorRange);\n      fill.gradientFillOptions = gradientFillOptions;\n    }\n    fill.setProperties({\n      stroke: void 0,\n      lineJoin: \"round\",\n      pointerEvents: 1 /* None */,\n      fill: this.properties.fill,\n      fillOpacity: this.properties.fillOpacity * (crossFiltering ? CROSS_FILTER_AREA_FILL_OPACITY_FACTOR : 1),\n      fillShadow: this.properties.shadow,\n      opacity,\n      visible: visible || animationEnabled\n    });\n    updateClipPath(this, stroke2);\n    updateClipPath(this, fill);\n  }\n  updatePaths(opts) {\n    this.updateAreaPaths(opts.paths, opts.contextData);\n  }\n  updateAreaPaths(paths, contextData) {\n    for (const path of paths) {\n      path.visible = contextData.visible;\n    }\n    if (contextData.visible) {\n      this.updateFillPath(paths, contextData);\n      this.updateStrokePath(paths, contextData);\n    } else {\n      for (const path of paths) {\n        path.path.clear();\n        path.markDirty();\n      }\n    }\n  }\n  updateFillPath(paths, contextData) {\n    const [fill] = paths;\n    fill.path.clear();\n    plotAreaPathFill(fill, contextData.fillData);\n    fill.markDirty();\n  }\n  updateStrokePath(paths, contextData) {\n    const { spans } = contextData.strokeData;\n    const [, stroke2] = paths;\n    stroke2.path.clear();\n    plotLinePathStroke(stroke2, spans);\n    stroke2.markDirty();\n  }\n  updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    const markersEnabled = this.properties.marker.enabled || this.contextNodeData?.crossFiltering === true;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(markersEnabled ? nodeData : []);\n  }\n  getMarkerItemBaseStyle(highlighted) {\n    const { marker } = this.properties;\n    const highlightStyle = highlighted ? this.properties.highlightStyle.item : void 0;\n    return {\n      fill: highlightStyle?.fill ?? marker.fill,\n      fillOpacity: highlightStyle?.fillOpacity ?? marker.fillOpacity,\n      stroke: highlightStyle?.stroke ?? marker.stroke,\n      strokeWidth: highlightStyle?.strokeWidth ?? marker.strokeWidth,\n      strokeOpacity: highlightStyle?.strokeOpacity ?? marker.strokeOpacity\n    };\n  }\n  getMarkerItemStyleOverrides(datumId, datum, xValue, yValue, format, highlighted) {\n    const { marker } = this.properties;\n    const { itemStyler } = marker;\n    if (itemStyler == null)\n      return;\n    const { id: seriesId, properties } = this;\n    const { xKey, yKey } = properties;\n    const { xDomain, yDomain } = this.cachedDatumCallback(\"domain\", () => ({\n      xDomain: this.getSeriesDomain(\"x\" /* X */),\n      yDomain: this.getSeriesDomain(\"y\" /* Y */)\n    }));\n    return this.cachedDatumCallback(createDatumId(datumId, highlighted ? \"highlight\" : \"node\"), () => {\n      return itemStyler({\n        seriesId,\n        ...datumStylerProperties(datum, xKey, yKey, xDomain, yDomain),\n        xValue,\n        yValue,\n        highlighted,\n        ...format\n      });\n    });\n  }\n  updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, marker, fill, stroke: stroke2, strokeWidth, fillOpacity, strokeOpacity, highlightStyle } = this.properties;\n    const xDomain = this.getSeriesDomain(\"x\" /* X */);\n    const yDomain = this.getSeriesDomain(\"y\" /* Y */);\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {\n      fill,\n      stroke: stroke2,\n      strokeWidth,\n      fillOpacity,\n      strokeOpacity\n    });\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(\n        node,\n        marker,\n        { ...datumStylerProperties(datum, xKey, yKey, xDomain, yDomain), highlighted },\n        baseStyle,\n        { selected: datum.selected }\n      );\n    });\n    if (!highlighted) {\n      this.properties.marker.markClean();\n    }\n  }\n  updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    return labelSelection.update(labelData);\n  }\n  updateLabelNodes(opts) {\n    const { labelSelection } = opts;\n    const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;\n    labelSelection.each((text2, datum) => {\n      const { x, y, labelText } = datum;\n      if (labelText && labelEnabled && this.visible) {\n        text2.fontStyle = fontStyle;\n        text2.fontWeight = fontWeight;\n        text2.fontSize = fontSize;\n        text2.fontFamily = fontFamily;\n        text2.textAlign = \"center\";\n        text2.textBaseline = \"bottom\";\n        text2.text = labelText;\n        text2.x = x;\n        text2.y = y - 10;\n        text2.fill = color;\n        text2.visible = true;\n      } else {\n        text2.visible = false;\n      }\n    });\n  }\n  getTooltipContent(nodeDatum) {\n    const { id: seriesId, dataModel, processedData, axes, properties } = this;\n    const { xKey, xName, yKey, yName, tooltip } = properties;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!dataModel || !processedData || !xAxis || !yAxis)\n      return;\n    const { datumIndex } = nodeDatum;\n    const datum = processedData.dataSources.get(this.id)?.[datumIndex];\n    const xValue = dataModel.resolveKeysById(this, `xValue`, processedData)[datumIndex];\n    const yValue = dataModel.resolveColumnById(this, `yValueRaw`, processedData)[datumIndex];\n    if (xValue == null)\n      return;\n    const format = this.getMarkerItemBaseStyle(false);\n    Object.assign(\n      format,\n      this.getMarkerItemStyleOverrides(String(datumIndex), datum, xValue, yValue, format, false)\n    );\n    return tooltip.formatTooltip(\n      {\n        heading: xAxis.formatDatum(xValue),\n        symbol: this.legendItemSymbol(),\n        data: [{ label: yName, fallbackLabel: yKey, value: yAxis.formatDatum(yValue) }]\n      },\n      {\n        seriesId,\n        datum,\n        title: yName,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        ...format,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  legendItemSymbol() {\n    const { fill, stroke: stroke2, fillOpacity, strokeOpacity, strokeWidth, lineDash, marker } = this.properties;\n    const useAreaFill = !marker.enabled || marker.fill === void 0;\n    return {\n      marker: {\n        shape: marker.shape,\n        fill: useAreaFill ? fill : marker.fill,\n        fillOpacity: useAreaFill ? fillOpacity : marker.fillOpacity,\n        stroke: marker.stroke ?? stroke2,\n        strokeOpacity: marker.strokeOpacity,\n        strokeWidth: marker.strokeWidth,\n        lineDash: marker.lineDash,\n        lineDashOffset: marker.lineDashOffset,\n        enabled: marker.enabled || strokeWidth <= 0\n      },\n      line: {\n        stroke: stroke2,\n        strokeOpacity,\n        strokeWidth,\n        lineDash\n      }\n    };\n  }\n  getLegendData(legendType) {\n    if (!this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    const {\n      id: seriesId,\n      ctx: { legendManager },\n      visible\n    } = this;\n    const { yKey: itemId, yName, legendItemName, showInLegend } = this.properties;\n    return [\n      {\n        legendType,\n        id: seriesId,\n        itemId,\n        seriesId,\n        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),\n        label: {\n          text: legendItemName ?? yName ?? itemId\n        },\n        symbol: this.legendItemSymbol(),\n        legendItemName,\n        hideInLegend: !showInLegend\n      }\n    ];\n  }\n  animateEmptyUpdateReady(animationData) {\n    const { markerSelection, labelSelection, contextData, paths } = animationData;\n    const { animationManager } = this.ctx;\n    this.updateAreaPaths(paths, contextData);\n    pathSwipeInAnimation(this, animationManager, ...paths);\n    resetMotion([markerSelection], resetMarkerPositionFn);\n    markerSwipeScaleInAnimation(this, animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n  }\n  animateReadyResize(animationData) {\n    const { contextData, paths } = animationData;\n    this.updateAreaPaths(paths, contextData);\n    super.animateReadyResize(animationData);\n  }\n  animateWaitingUpdateReady(animationData) {\n    const { animationManager } = this.ctx;\n    const { markerSelection, labelSelection, contextData, paths, previousContextData } = animationData;\n    const [fill, stroke2] = paths;\n    if (fill == null && stroke2 == null)\n      return;\n    this.resetMarkerAnimation(animationData);\n    this.resetLabelAnimation(animationData);\n    const update = () => {\n      this.resetPathAnimation(animationData);\n      this.updateAreaPaths(paths, contextData);\n    };\n    const skip = () => {\n      animationManager.skipCurrentBatch();\n      update();\n    };\n    if (contextData == null || previousContextData == null) {\n      update();\n      markerFadeInAnimation(this, animationManager, \"added\", markerSelection);\n      pathFadeInAnimation(this, \"fill_path_properties\", animationManager, \"add\", fill);\n      pathFadeInAnimation(this, \"stroke_path_properties\", animationManager, \"add\", stroke2);\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n      return;\n    }\n    if (contextData.crossFiltering !== previousContextData.crossFiltering) {\n      skip();\n      return;\n    }\n    const fns = prepareAreaPathAnimation(contextData, previousContextData);\n    if (fns === void 0) {\n      skip();\n      return;\n    } else if (fns.status === \"no-op\") {\n      return;\n    }\n    markerFadeInAnimation(this, animationManager, void 0, markerSelection);\n    fromToMotion(this.id, \"fill_path_properties\", animationManager, [fill], fns.fill.pathProperties);\n    pathMotion(this.id, \"fill_path_update\", animationManager, [fill], fns.fill.path);\n    fromToMotion(this.id, \"stroke_path_properties\", animationManager, [stroke2], fns.stroke.pathProperties);\n    pathMotion(this.id, \"stroke_path_update\", animationManager, [stroke2], fns.stroke.path);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n    this.ctx.animationManager.animate({\n      id: this.id,\n      groupId: \"reset_after_animation\",\n      phase: \"trailing\",\n      from: {},\n      to: {},\n      onComplete: () => this.updateAreaPaths(paths, contextData)\n    });\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey } = datum;\n    const xDomain = this.getSeriesDomain(\"x\" /* X */);\n    const yDomain = this.getSeriesDomain(\"y\" /* Y */);\n    return this.getMarkerStyle(this.properties.marker, {\n      ...datumStylerProperties(datum, xKey, yKey, xDomain, yDomain),\n      highlighted: true\n    });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nAreaSeries.className = \"AreaSeries\";\nAreaSeries.type = \"area\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesModule.ts\nvar AreaSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"area\",\n  moduleFactory: (ctx) => new AreaSeries(ctx),\n  stackable: true,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      nodeClickRange: \"nearest\",\n      tooltip: { position: { type: \"node\" } },\n      fillOpacity: 0.8,\n      strokeOpacity: 1,\n      strokeWidth: 0,\n      lineDash: [0],\n      lineDashOffset: 0,\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      },\n      interpolation: {\n        type: \"linear\",\n        tension: 1,\n        position: \"end\"\n      },\n      marker: {\n        enabled: false,\n        shape: \"circle\",\n        size: 7,\n        strokeWidth: 0\n      },\n      label: {\n        enabled: false,\n        fontSize: { $ref: \"fontSize\" },\n        fontFamily: { $ref: \"fontFamily\" },\n        fontWeight: { $ref: \"fontWeight\" },\n        color: { $ref: \"textColor\" }\n      }\n    }\n  },\n  paletteFactory: (params) => {\n    const { marker } = markerPaletteFactory(params);\n    const defaultColorRange = params.themeTemplateParameters.get(DEFAULT_COLOR_RANGE);\n    return { fill: marker.fill, stroke: marker.stroke, marker, defaultColorRange };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/quadtreeUtil.ts\nfunction addHitTestersToQuadtree(quadtree, hitTesters) {\n  for (const node of hitTesters) {\n    const datum = node.datum;\n    if (datum === void 0) {\n      logger_exports.error(\"undefined datum\");\n    } else {\n      quadtree.addValue(node, datum);\n    }\n  }\n}\nfunction findQuadtreeMatch(series, point) {\n  const { x, y } = point;\n  const { nearest, distanceSquared: distanceSquared2 } = series.getQuadTree().find(x, y);\n  if (nearest !== void 0) {\n    return { datum: nearest.value, distance: Math.sqrt(distanceSquared2) };\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/abstractBarSeries.ts\nvar AbstractBarSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.direction = \"vertical\";\n  }\n};\n__decorateClass([\n  Validate(DIRECTION)\n], AbstractBarSeriesProperties.prototype, \"direction\", 2);\nvar AbstractBarSeries = class extends CartesianSeries {\n  constructor() {\n    super(...arguments);\n    /**\n     * Used to get the position of bars within each group.\n     */\n    this.groupScale = new CategoryScale();\n    this.smallestDataInterval = void 0;\n    this.largestDataInterval = void 0;\n  }\n  padBandExtent(keys, alignStart) {\n    const ratio2 = typeof alignStart === \"boolean\" ? 1 : 0.5;\n    const scalePadding = isFiniteNumber(this.smallestDataInterval) ? this.smallestDataInterval * ratio2 : 0;\n    const keysExtent = extent(keys) ?? [NaN, NaN];\n    if (typeof alignStart === \"boolean\") {\n      keysExtent[alignStart ? 0 : 1] -= (alignStart ? 1 : -1) * scalePadding;\n    } else {\n      keysExtent[0] -= scalePadding;\n      keysExtent[1] += scalePadding;\n    }\n    return fixNumericExtent(keysExtent);\n  }\n  getBandScalePadding() {\n    return { inner: 0.3, outer: 0.15 };\n  }\n  shouldFlipXY() {\n    return !this.isVertical();\n  }\n  isVertical() {\n    return this.properties.direction === \"vertical\";\n  }\n  getBarDirection() {\n    return this.shouldFlipXY() ? \"x\" /* X */ : \"y\" /* Y */;\n  }\n  getCategoryDirection() {\n    return this.shouldFlipXY() ? \"y\" /* Y */ : \"x\" /* X */;\n  }\n  getValueAxis() {\n    const direction = this.getBarDirection();\n    return this.axes[direction];\n  }\n  getCategoryAxis() {\n    const direction = this.getCategoryDirection();\n    return this.axes[direction];\n  }\n  getBandwidth(xAxis) {\n    return ContinuousScale.is(xAxis.scale) ? xAxis.scale.calcBandwidth(this.smallestDataInterval) : xAxis.scale.bandwidth;\n  }\n  xCoordinateRange(xValue) {\n    const xAxis = this.axes[this.getCategoryDirection()];\n    const xScale = xAxis.scale;\n    const bandWidth = this.getBandwidth(xAxis) ?? 0;\n    const barOffset = ContinuousScale.is(xScale) ? bandWidth * -0.5 : 0;\n    const x = xScale.convert(xValue) + barOffset;\n    return [x, x + bandWidth];\n  }\n  yCoordinateRange(yValues) {\n    const yAxis = this.axes[this.getBarDirection()];\n    const yScale = yAxis.scale;\n    const ys = yValues.map((yValue) => yScale.convert(yValue));\n    if (ys.length === 1) {\n      const y0 = yScale.convert(0);\n      return [Math.min(ys[0], y0), Math.max(ys[0], y0)];\n    }\n    return [Math.min(...ys), Math.max(...ys)];\n  }\n  updateGroupScale(xAxis) {\n    const domain = [];\n    const { groupScale } = this;\n    const xBandWidth = this.getBandwidth(xAxis);\n    const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);\n    for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {\n      domain.push(String(groupIdx));\n    }\n    groupScale.domain = domain;\n    groupScale.range = [0, xBandWidth ?? 0];\n    if (xAxis instanceof GroupedCategoryAxis) {\n      groupScale.paddingInner = xAxis.groupPaddingInner;\n    } else if (xAxis instanceof CategoryAxis) {\n      groupScale.paddingInner = xAxis.groupPaddingInner;\n      groupScale.round = groupScale.padding !== 0;\n    } else {\n      groupScale.padding = 0;\n    }\n    const barWidth = groupScale.bandwidth >= 1 ? (\n      // Pixel-rounded value for low-volume bar charts.\n      groupScale.bandwidth\n    ) : (\n      // Handle high-volume bar charts gracefully.\n      groupScale.rawBandwidth\n    );\n    return { barWidth, groupIndex };\n  }\n  resolveKeyDirection(direction) {\n    if (this.getBarDirection() === \"x\" /* X */) {\n      if (direction === \"x\" /* X */) {\n        return \"y\" /* Y */;\n      }\n      return \"x\" /* X */;\n    }\n    return direction;\n  }\n  initQuadTree(quadtree) {\n    addHitTestersToQuadtree(quadtree, this.datumNodesIter());\n  }\n  pickNodeClosestDatum(point) {\n    return findQuadtreeMatch(this, point);\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeriesProperties.ts\nvar BarSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"inside-center\";\n    this.padding = 0;\n  }\n};\n__decorateClass([\n  Validate(UNION([\"inside-center\", \"inside-start\", \"inside-end\", \"outside-start\", \"outside-end\"], \"a placement\"))\n], BarSeriesLabel.prototype, \"placement\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], BarSeriesLabel.prototype, \"padding\", 2);\nvar BarSeriesProperties = class extends AbstractBarSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"#c16068\";\n    this.fillOpacity = 1;\n    this.stroke = \"#874349\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.crisp = void 0;\n    this.shadow = new DropShadow();\n    this.label = new BarSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    this.sparklineMode = false;\n    this.fastDataProcessing = false;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], BarSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING)\n], BarSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"stackGroup\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], BarSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], BarSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], BarSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], BarSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], BarSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], BarSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], BarSeriesProperties.prototype, \"crisp\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], BarSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], BarSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BarSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BarSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], BarSeriesProperties.prototype, \"sparklineMode\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], BarSeriesProperties.prototype, \"fastDataProcessing\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/barUtil.ts\nfunction checkCrisp(scale2, visibleRange, smallestDataInterval, largestDataInterval) {\n  if (visibleRange != null) {\n    const [visibleMin, visibleMax] = visibleRange;\n    const isZoomed = visibleMin !== 0 || visibleMax !== 1;\n    if (isZoomed)\n      return false;\n  }\n  if (ContinuousScale.is(scale2)) {\n    const spacing = scale2.calcBandwidth(largestDataInterval) - scale2.calcBandwidth(smallestDataInterval);\n    if (spacing > 0 && spacing < 1)\n      return false;\n  }\n  return true;\n}\nvar isDatumNegative = (datum) => {\n  return isNegative(datum.yValue ?? 0);\n};\nfunction collapsedStartingBarPosition(isVertical, axes, mode) {\n  const { startingX, startingY } = getStartingValues(isVertical, axes);\n  const calculate = (datum, prevDatum) => {\n    let x = isVertical ? datum.x : startingX;\n    let y = isVertical ? startingY : datum.y;\n    let width2 = isVertical ? datum.width : 0;\n    let height2 = isVertical ? 0 : datum.height;\n    const { opacity = 1 } = datum;\n    if (prevDatum && (isNaN(x) || isNaN(y))) {\n      ({ x, y } = prevDatum);\n      width2 = isVertical ? prevDatum.width : 0;\n      height2 = isVertical ? 0 : prevDatum.height;\n      if (isVertical && !isDatumNegative(prevDatum)) {\n        y += prevDatum.height;\n      } else if (!isVertical && isDatumNegative(prevDatum)) {\n        x += prevDatum.width;\n      }\n    }\n    let clipBBox;\n    if (datum.clipBBox == null) {\n      clipBBox = void 0;\n    } else if (isDatumNegative(datum)) {\n      clipBBox = isVertical ? new BBox(x, y - height2, width2, height2) : new BBox(x - width2, y, width2, height2);\n    } else {\n      clipBBox = new BBox(x, y, width2, height2);\n    }\n    return { x, y, width: width2, height: height2, clipBBox, opacity };\n  };\n  return { isVertical, calculate, mode };\n}\nfunction midpointStartingBarPosition(isVertical, mode) {\n  return {\n    isVertical,\n    calculate: (datum) => {\n      return {\n        x: isVertical ? datum.x : datum.x + datum.width / 2,\n        y: isVertical ? datum.y + datum.height / 2 : datum.y,\n        width: isVertical ? datum.width : 0,\n        height: isVertical ? 0 : datum.height,\n        clipBBox: datum.clipBBox,\n        opacity: datum.opacity ?? 1\n      };\n    },\n    mode\n  };\n}\nfunction prepareBarAnimationFunctions(initPos) {\n  const isRemoved = (datum) => datum == null || isNaN(datum.x) || isNaN(datum.y);\n  const fromFn = (rect, datum, status) => {\n    if (status === \"updated\" && isRemoved(datum)) {\n      status = \"removed\";\n    } else if (status === \"updated\" && isRemoved(rect.previousDatum)) {\n      status = \"added\";\n    }\n    let source;\n    if (status === \"added\" && rect.previousDatum == null && initPos.mode === \"fade\") {\n      source = {\n        ...resetBarSelectionsFn(rect, datum),\n        opacity: 0\n      };\n    } else if (status === \"unknown\" || status === \"added\") {\n      source = initPos.calculate(datum, rect.previousDatum);\n    } else {\n      source = {\n        x: rect.x,\n        y: rect.y,\n        width: rect.width,\n        height: rect.height,\n        clipBBox: rect.clipBBox,\n        opacity: rect.opacity ?? 1\n      };\n    }\n    const phase = NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];\n    return { ...source, phase };\n  };\n  const toFn = (rect, datum, status) => {\n    if (status === \"removed\" && rect.datum == null && initPos.mode === \"fade\") {\n      return { ...resetBarSelectionsFn(rect, datum), opacity: 0 };\n    } else if (status === \"removed\" || isRemoved(datum)) {\n      return initPos.calculate(datum, rect.previousDatum);\n    } else {\n      return {\n        x: datum.x,\n        y: datum.y,\n        width: datum.width,\n        height: datum.height,\n        clipBBox: datum.clipBBox,\n        opacity: datum.opacity ?? 1\n      };\n    }\n  };\n  const applyFn = (rect, datum, status) => {\n    rect.setProperties(datum);\n    rect.crisp = status === \"end\" && (rect.datum?.crisp ?? false);\n  };\n  return { toFn, fromFn, applyFn };\n}\nfunction getStartingValues(isVertical, axes) {\n  const axis = axes[isVertical ? \"y\" /* Y */ : \"x\" /* X */];\n  let startingX = Infinity;\n  let startingY = 0;\n  if (!axis) {\n    return { startingX, startingY };\n  }\n  if (isVertical) {\n    startingY = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.max(...axis.range));\n  } else {\n    startingX = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.min(...axis.range));\n  }\n  return { startingX, startingY };\n}\nfunction resetBarSelectionsFn(rect, { x, y, width: width2, height: height2, clipBBox, opacity = 1 }) {\n  return { x, y, width: width2, height: height2, clipBBox, opacity, crisp: rect.datum?.crisp ?? false };\n}\nfunction computeBarFocusBounds(series, datum) {\n  if (datum === void 0)\n    return void 0;\n  const { x, y, width: width2, height: height2 } = datum;\n  return Transformable.toCanvas(series.contentGroup, new BBox(x, y, width2, height2));\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/labelUtil.ts\nfunction updateLabelNode(textNode, label, labelDatum) {\n  if (label.enabled && labelDatum) {\n    const { x, y, text: text2, textAlign, textBaseline } = labelDatum;\n    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = label;\n    textNode.setProperties({\n      visible: true,\n      x,\n      y,\n      text: text2,\n      fill,\n      fontStyle,\n      fontWeight,\n      fontSize,\n      fontFamily,\n      textAlign,\n      textBaseline\n    });\n  } else {\n    textNode.visible = false;\n  }\n}\nvar placements = {\n  \"inside-start\": { inside: true, direction: -1, textAlignment: 1 },\n  \"inside-end\": { inside: true, direction: 1, textAlignment: -1 },\n  \"outside-start\": { inside: false, direction: -1, textAlignment: -1 },\n  \"outside-end\": { inside: false, direction: 1, textAlignment: 1 }\n};\nfunction adjustLabelPlacement({\n  isUpward,\n  isVertical,\n  placement,\n  padding = 0,\n  rect\n}) {\n  let x = rect.x + rect.width / 2;\n  let y = rect.y + rect.height / 2;\n  let textAlign = \"center\";\n  let textBaseline = \"middle\";\n  if (placement !== \"inside-center\") {\n    const barDirection = (isUpward ? 1 : -1) * (isVertical ? -1 : 1);\n    const { direction, textAlignment } = placements[placement];\n    const displacementRatio = (direction + 1) * 0.5;\n    if (isVertical) {\n      const y0 = isUpward ? rect.y + rect.height : rect.y;\n      const height2 = rect.height * barDirection;\n      y = y0 + height2 * displacementRatio + padding * textAlignment * barDirection;\n      textBaseline = textAlignment === barDirection ? \"top\" : \"bottom\";\n    } else {\n      const x0 = isUpward ? rect.x : rect.x + rect.width;\n      const width2 = rect.width * barDirection;\n      x = x0 + width2 * displacementRatio + padding * textAlignment * barDirection;\n      textAlign = textAlignment === barDirection ? \"left\" : \"right\";\n    }\n  }\n  return { x, y, textAlign, textBaseline };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeries.ts\nvar X_MIN = 0;\nvar X_MAX = 1;\nvar Y_MIN = 2;\nvar Y_MAX = 3;\nvar SPAN2 = 4;\nvar BarSeries = class extends AbstractBarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [\n        2 /* AXIS_ALIGNED */,\n        // Only used in sparklineMode\n        1 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      pathsPerSeries: [],\n      hasHighlightedLabels: true,\n      datumSelectionGarbageCollection: false,\n      animationAlwaysUpdateSelections: true,\n      animationResetFns: {\n        datum: resetBarSelectionsFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new BarSeriesProperties();\n    this.connectsToYAxis = true;\n    this.dataAggregationFilters = void 0;\n  }\n  get pickModeAxis() {\n    return this.properties.sparklineMode ? \"main\" : void 0;\n  }\n  crossFilteringEnabled() {\n    return this.properties.yFilterKey != null && (this.seriesGrouping == null || this.seriesGrouping.stackIndex === 0);\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || !this.data) {\n      return;\n    }\n    const { xKey, yKey, yFilterKey, normalizedTo, fastDataProcessing } = this.properties;\n    const { seriesGrouping: { groupIndex = this.id } = {}, data } = this;\n    const groupCount2 = this.seriesGrouping?.groupCount ?? 0;\n    const stackCount = this.seriesGrouping?.stackCount ?? 0;\n    const stacked = stackCount >= 1 || normalizedTo != null;\n    const grouped = !fastDataProcessing || groupCount2 > 1 || stacked;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.getCategoryAxis()?.scale;\n    const yScale = this.getValueAxis()?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const stackGroupName = `bar-stack-${groupIndex}-yValues`;\n    const stackGroupTrailingName = `${stackGroupName}-trailing`;\n    const visibleProps = this.visible ? {} : { forceValue: 0 };\n    const props = [\n      keyProperty(xKey, xScaleType, { id: \"xValue\" }),\n      valueProperty(yKey, yScaleType, { id: `yValue-raw`, invalidValue: null, ...visibleProps })\n    ];\n    if (this.crossFilteringEnabled()) {\n      props.push(\n        valueProperty(yFilterKey, yScaleType, {\n          id: `yFilterValue`,\n          invalidValue: null,\n          ...visibleProps\n        })\n      );\n    }\n    if (stacked) {\n      props.push(\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          {\n            id: `yValue-end`,\n            rangeId: `yValue-range`,\n            invalidValue: null,\n            missingValue: 0,\n            groupId: stackGroupName,\n            separateNegative: true,\n            ...visibleProps\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"trailing\",\n          \"current\",\n          {\n            id: `yValue-start`,\n            invalidValue: null,\n            missingValue: 0,\n            groupId: stackGroupTrailingName,\n            separateNegative: true,\n            ...visibleProps\n          },\n          yScaleType\n        )\n      );\n    }\n    if (isContinuousX) {\n      props.push(SMALLEST_KEY_INTERVAL, LARGEST_KEY_INTERVAL);\n    }\n    if (isFiniteNumber(normalizedTo)) {\n      props.push(normaliseGroupTo([stackGroupName, stackGroupTrailingName], Math.abs(normalizedTo)));\n    }\n    if (animationEnabled && this.processedData) {\n      props.push(diff(this.id, this.processedData));\n    }\n    if (animationEnabled || !grouped) {\n      props.push(animationValidation());\n    }\n    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {\n      props,\n      groupByKeys: grouped,\n      groupByData: !grouped\n    });\n    this.dataAggregationFilters = this.aggregateData(dataModel, processedData);\n    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;\n    this.largestDataInterval = processedData.reduced?.largestKeyInterval;\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel } = this;\n    if (dataModel == null || processedData == null)\n      return [];\n    if (direction === this.getCategoryDirection()) {\n      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n      const keys = dataModel.getDomain(this, `xValue`, \"key\", processedData);\n      if (keyDef?.def.type === \"key\" && keyDef.def.valueType === \"category\") {\n        return keys;\n      }\n      return this.padBandExtent(keys);\n    }\n    const yKey = this.dataModel?.hasColumnById(this, `yValue-end`) ? \"yValue-end\" : \"yValue-raw\";\n    let yExtent = this.domainForClippedRange(\"y\" /* Y */, [yKey], \"xValue\", true);\n    const yFilterExtent = this.crossFilteringEnabled() ? dataModel.getDomain(this, `yFilterValue`, \"value\", processedData) : void 0;\n    if (yFilterExtent != null) {\n      yExtent = [Math.min(yExtent[0], yFilterExtent[0]), Math.max(yExtent[1], yFilterExtent[1])];\n    }\n    if (this.getValueAxis() instanceof LogAxis) {\n      return fixNumericExtent(yExtent);\n    } else {\n      const fixedYExtent = Number.isFinite(yExtent[1] - yExtent[0]) ? [Math.min(0, yExtent[0]), Math.max(0, yExtent[1])] : [];\n      return fixNumericExtent(fixedYExtent);\n    }\n  }\n  getSeriesRange(_direction, visibleRange) {\n    const yKey = this.dataModel?.hasColumnById(this, `yValue-end`) ? \"yValue-end\" : \"yValue-raw\";\n    const [y0, y1] = this.domainForVisibleRange(\"y\" /* Y */, [yKey], \"xValue\", visibleRange, true);\n    return [Math.min(y0, 0), Math.max(y1, 0)];\n  }\n  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {\n    const yKey = this.dataModel?.hasColumnById(this, `yValue-end`) ? \"yValue-end\" : \"yValue-raw\";\n    return this.countVisibleItems(\"xValue\", [yKey], xVisibleRange, yVisibleRange, minVisibleItems);\n  }\n  aggregateData(_dataModel, _processedData) {\n    return;\n  }\n  createNodeData() {\n    const { dataModel, processedData, groupScale, dataAggregationFilters } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!dataModel || !processedData || !xAxis || !yAxis || !this.properties.isValid()) {\n      return;\n    }\n    const rawData = processedData.dataSources?.get(this.id);\n    if (rawData == null)\n      return;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const { xKey, yKey, xName, yName, legendItemName, label } = this.properties;\n    const yReversed = yAxis.isReversed();\n    const { barWidth, groupIndex: groupScaleIndex } = this.updateGroupScale(xAxis);\n    const groupOffset = groupScale.convert(String(groupScaleIndex));\n    const barOffset = ContinuousScale.is(xScale) ? barWidth * -0.5 : 0;\n    const xValues = dataModel.resolveKeysById(this, `xValue`, processedData);\n    const yRawValues = dataModel.resolveColumnById(this, `yValue-raw`, processedData);\n    const yFilterValues = this.crossFilteringEnabled() ? dataModel.resolveColumnById(this, `yFilterValue`, processedData) : void 0;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xPosition = (index) => xScale.convert(xValues[index]) + groupOffset + barOffset;\n    const crisp = this.properties.crisp ?? checkCrisp(xAxis?.scale, xAxis?.visibleRange, this.smallestDataInterval, this.largestDataInterval);\n    const bboxBottom = yScale.convert(0);\n    const nodeDatum = ({\n      datum,\n      datumIndex,\n      valueIndex,\n      xValue,\n      yValue,\n      cumulativeValue,\n      phantom,\n      currY,\n      prevY,\n      x,\n      width: width2,\n      isPositive,\n      yRange,\n      labelText,\n      opacity,\n      crossScale = 1\n    }) => {\n      const isUpward = isPositive !== yReversed;\n      const y = yScale.convert(currY);\n      const bottomY = yScale.convert(prevY);\n      const bboxHeight = yScale.convert(yRange);\n      const barAlongX = this.getBarDirection() === \"x\" /* X */;\n      const xOffset = width2 * 0.5 * (1 - crossScale);\n      const rect = {\n        x: barAlongX ? Math.min(y, bottomY) : x + xOffset,\n        y: barAlongX ? x + xOffset : Math.min(y, bottomY),\n        width: barAlongX ? Math.abs(bottomY - y) : width2 * crossScale,\n        height: barAlongX ? width2 * crossScale : Math.abs(bottomY - y)\n      };\n      const clipBBox = new BBox(rect.x, rect.y, rect.width, rect.height);\n      const barRect = {\n        x: barAlongX ? Math.min(bboxBottom, bboxHeight) : x + xOffset,\n        y: barAlongX ? x + xOffset : Math.min(bboxBottom, bboxHeight),\n        width: barAlongX ? Math.abs(bboxBottom - bboxHeight) : width2 * crossScale,\n        height: barAlongX ? width2 * crossScale : Math.abs(bboxBottom - bboxHeight)\n      };\n      const lengthRatioMultiplier = this.shouldFlipXY() ? rect.height : rect.width;\n      return {\n        series: this,\n        itemId: phantom ? createDatumId(yKey, phantom) : yKey,\n        datum,\n        datumIndex,\n        valueIndex,\n        cumulativeValue,\n        phantom,\n        xValue,\n        yValue,\n        yKey,\n        xKey,\n        capDefaults: {\n          lengthRatioMultiplier,\n          lengthMax: lengthRatioMultiplier\n        },\n        x: barRect.x,\n        y: barRect.y,\n        width: barRect.width,\n        height: barRect.height,\n        midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },\n        opacity,\n        topLeftCornerRadius: barAlongX !== isUpward,\n        topRightCornerRadius: isUpward,\n        bottomRightCornerRadius: barAlongX === isUpward,\n        bottomLeftCornerRadius: !isUpward,\n        clipBBox,\n        crisp,\n        label: labelText != null ? {\n          text: labelText,\n          ...adjustLabelPlacement({\n            isUpward,\n            isVertical: !barAlongX,\n            placement: label.placement,\n            padding: label.padding,\n            rect\n          })\n        } : void 0,\n        missing: yValue == null,\n        focusable: !phantom\n      };\n    };\n    const phantomNodes = [];\n    const nodes = [];\n    const labels = [];\n    const handleDatum = (datumIndex, valueIndex, x, width2, yStart, yEnd, yRange, opacity) => {\n      const xValue = xValues[datumIndex];\n      if (xValue == null)\n        return;\n      const yRawValue = yRawValues[datumIndex];\n      const yFilterValue = yFilterValues != null ? Number(yFilterValues[datumIndex]) : void 0;\n      const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);\n      if (!Number.isFinite(yEnd))\n        return;\n      if (yFilterValue != null && !Number.isFinite(yFilterValue))\n        return;\n      const labelText = yRawValue != null ? this.getLabelText(this.properties.label, {\n        datum: rawData[datumIndex],\n        value: yFilterValue ?? yRawValue,\n        xKey,\n        yKey,\n        xName,\n        yName,\n        legendItemName\n      }) : void 0;\n      const inset = yFilterValue != null && yFilterValue > yRawValue;\n      const nodeData = nodeDatum({\n        datum: rawData[datumIndex],\n        datumIndex,\n        valueIndex,\n        xValue,\n        yValue: yFilterValue ?? yRawValue,\n        cumulativeValue: yFilterValue ?? yEnd,\n        phantom: false,\n        currY: yFilterValue != null ? yStart + yFilterValue : yEnd,\n        prevY: yStart,\n        x,\n        width: width2,\n        isPositive,\n        yRange: Math.max(yStart + (yFilterValue ?? -Infinity), yRange),\n        labelText,\n        opacity,\n        crossScale: inset ? 0.6 : void 0\n      });\n      nodes.push(nodeData);\n      labels.push(nodeData);\n      if (yFilterValue != null) {\n        const phantomNodeData = nodeDatum({\n          datum: rawData[datumIndex],\n          datumIndex,\n          valueIndex,\n          xValue,\n          yValue: yFilterValue,\n          cumulativeValue: yFilterValue,\n          phantom: true,\n          currY: yEnd,\n          prevY: yStart,\n          x,\n          width: width2,\n          isPositive,\n          yRange,\n          labelText: void 0,\n          opacity,\n          crossScale: void 0\n        });\n        phantomNodes.push(phantomNodeData);\n      }\n    };\n    const [r0, r1] = xScale.range;\n    const range3 = r1 - r0;\n    const dataAggregationFilter = dataAggregationFilters?.find((f) => f.maxRange > range3);\n    if (processedData.type === \"grouped\") {\n      const width2 = barWidth;\n      const stacked = dataModel.hasColumnById(this, `yValue-start`);\n      const yStartValues = stacked ? dataModel.resolveColumnById(this, `yValue-start`, processedData) : void 0;\n      const yEndValues = stacked ? dataModel.resolveColumnById(this, `yValue-end`, processedData) : void 0;\n      const yRangeIndex = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValue-range`) : -1;\n      for (const {\n        datumIndex,\n        valueIndex,\n        group: { aggregation }\n      } of dataModel.forEachGroupDatum(this, processedData)) {\n        const x = xPosition(datumIndex);\n        const yRawValue = yRawValues[datumIndex];\n        const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);\n        const yStart = stacked ? Number(yStartValues?.[datumIndex]) : 0;\n        const yEnd = stacked ? Number(yEndValues?.[datumIndex]) : yRawValue;\n        let yRange = yEnd;\n        if (stacked) {\n          yRange = aggregation[yRangeIndex][isPositive ? 1 : 0];\n        }\n        handleDatum(datumIndex, valueIndex, x, width2, yStart, yEnd, yRange, 1);\n      }\n    } else if (dataAggregationFilter == null) {\n      const width2 = barWidth;\n      let [start2, end2] = this.visibleRange(\"xValue\", xAxis.range);\n      if (processedData.input.count < 1e3) {\n        start2 = 0;\n        end2 = processedData.input.count;\n      }\n      for (let datumIndex = start2; datumIndex < end2; datumIndex += 1) {\n        const x = xPosition(datumIndex);\n        const yEnd = Number(yRawValues[datumIndex]);\n        handleDatum(datumIndex, 0, x, width2, 0, yEnd, yEnd, 1);\n      }\n    } else {\n      const { indexData, indices } = dataAggregationFilter;\n      const [start2, end2] = this.visibleRange(\"xValue\", xAxis.range, indices);\n      for (let i = start2; i < end2; i += 1) {\n        const aggIndex = i * SPAN2;\n        const xMinIndex = indexData[aggIndex + X_MIN];\n        const xMaxIndex = indexData[aggIndex + X_MAX];\n        const yMinIndex = indexData[aggIndex + Y_MIN];\n        const yMaxIndex = indexData[aggIndex + Y_MAX];\n        if (xMinIndex === -1)\n          continue;\n        const x = xPosition((xMinIndex + xMaxIndex) / 2 | 0);\n        const width2 = Math.abs(xPosition(xMaxIndex) - xPosition(xMinIndex)) + barWidth;\n        const yEndMax = xValues[yMaxIndex] != null ? Number(yRawValues[yMaxIndex]) : NaN;\n        const yEndMin = xValues[yMinIndex] != null ? Number(yRawValues[yMinIndex]) : NaN;\n        if (yEndMax > 0) {\n          const opacity = yEndMin >= 0 ? yEndMin / yEndMax : 1;\n          handleDatum(yMaxIndex, 0, x, width2, 0, yEndMax, yEndMax, opacity);\n        }\n        if (yEndMin < 0) {\n          const opacity = yEndMax <= 0 ? yEndMax / yEndMin : 1;\n          handleDatum(yMinIndex, 1, x, width2, 0, yEndMin, yEndMin, opacity);\n        }\n      }\n    }\n    return {\n      itemId: yKey,\n      nodeData: phantomNodes.length > 0 ? [...phantomNodes, ...nodes] : nodes,\n      labelData: labels,\n      scales: this.calculateScaling(),\n      visible: this.visible || animationEnabled,\n      groupScale: this.getScaling(this.groupScale)\n    };\n  }\n  nodeFactory() {\n    return new Rect();\n  }\n  getHighlightData(nodeData, highlightedItem) {\n    const highlightItem = nodeData.find(\n      (nodeDatum) => nodeDatum.datum === highlightedItem.datum && !nodeDatum.phantom\n    );\n    return highlightItem != null ? [highlightItem] : void 0;\n  }\n  updateDatumSelection(opts) {\n    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => this.getDatumId(datum));\n  }\n  getItemBaseStyle(highlighted) {\n    const { properties } = this;\n    const { cornerRadius } = properties;\n    const highlightStyle = highlighted ? properties.highlightStyle.item : void 0;\n    return {\n      fill: highlightStyle?.fill ?? properties.fill,\n      fillOpacity: highlightStyle?.fillOpacity ?? properties.fillOpacity,\n      stroke: highlightStyle?.stroke ?? properties.stroke,\n      strokeWidth: highlightStyle?.strokeWidth ?? this.getStrokeWidth(properties.strokeWidth),\n      strokeOpacity: highlightStyle?.strokeOpacity ?? properties.strokeOpacity,\n      lineDash: highlightStyle?.lineDash ?? properties.lineDash ?? [],\n      lineDashOffset: highlightStyle?.lineDashOffset ?? properties.lineDashOffset,\n      cornerRadius\n    };\n  }\n  getItemStyleOverrides(datumId, datum, xValue, yValue, format, highlighted) {\n    const { id: seriesId, properties } = this;\n    const { xKey, yKey, itemStyler } = properties;\n    if (itemStyler == null)\n      return;\n    const { xDomain, yDomain } = this.cachedDatumCallback(\"domain\", () => ({\n      xDomain: this.getSeriesDomain(\"x\" /* X */),\n      yDomain: this.getSeriesDomain(\"y\" /* Y */)\n    }));\n    return this.cachedDatumCallback(createDatumId(datumId, highlighted ? \"highlight\" : \"node\"), () => {\n      return itemStyler({\n        seriesId,\n        ...datumStylerProperties(datum, xKey, yKey, xDomain, yDomain),\n        xValue,\n        yValue,\n        highlighted,\n        ...format\n      });\n    });\n  }\n  updateDatumNodes(opts) {\n    if (!this.properties.isValid()) {\n      return;\n    }\n    const { shadow } = this.properties;\n    const categoryAlongX = this.getCategoryDirection() === \"x\" /* X */;\n    const style = this.getItemBaseStyle(opts.isHighlight);\n    opts.datumSelection.each((rect, datum) => {\n      const overrides = this.getItemStyleOverrides(\n        String(datum.datumIndex),\n        datum.datum,\n        datum.xValue,\n        datum.yValue,\n        style,\n        opts.isHighlight\n      );\n      rect.opacity = datum.opacity ?? 0;\n      applyShapeStyle(rect, style, overrides);\n      const cornerRadius = overrides?.cornerRadius ?? style.cornerRadius;\n      rect.topLeftCornerRadius = datum.topLeftCornerRadius ? cornerRadius : 0;\n      rect.topRightCornerRadius = datum.topRightCornerRadius ? cornerRadius : 0;\n      rect.bottomRightCornerRadius = datum.bottomRightCornerRadius ? cornerRadius : 0;\n      rect.bottomLeftCornerRadius = datum.bottomLeftCornerRadius ? cornerRadius : 0;\n      rect.visible = categoryAlongX ? (datum.clipBBox?.width ?? datum.width) > 0 : (datum.clipBBox?.height ?? datum.height) > 0;\n      rect.crisp = datum.crisp;\n      rect.fillShadow = shadow;\n    });\n  }\n  updateLabelSelection(opts) {\n    const data = this.isLabelEnabled() ? opts.labelData : [];\n    return opts.labelSelection.update(data, (text2) => {\n      text2.pointerEvents = 1 /* None */;\n    });\n  }\n  updateLabelNodes(opts) {\n    opts.labelSelection.each((textNode, datum) => {\n      updateLabelNode(textNode, this.properties.label, datum.label);\n    });\n  }\n  getTooltipContent(nodeDatum) {\n    const { id: seriesId, dataModel, processedData, properties } = this;\n    const { xKey, xName, yKey, yName, legendItemName, stackGroup, tooltip } = properties;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!dataModel || !processedData || !xAxis || !yAxis) {\n      return;\n    }\n    const { datumIndex } = nodeDatum;\n    const datum = processedData.dataSources.get(this.id)?.[datumIndex];\n    const xValue = dataModel.resolveKeysById(this, `xValue`, processedData)[datumIndex];\n    const yValue = dataModel.resolveColumnById(this, `yValue-raw`, processedData)[datumIndex];\n    if (xValue == null)\n      return;\n    const format = this.getItemBaseStyle(false);\n    Object.assign(format, this.getItemStyleOverrides(String(datumIndex), datum, xValue, yValue, format, false));\n    return tooltip.formatTooltip(\n      {\n        heading: xAxis.formatDatum(xValue),\n        symbol: this.legendItemSymbol(),\n        data: [{ label: yName, fallbackLabel: yKey, value: yAxis.formatDatum(yValue) }]\n      },\n      {\n        seriesId,\n        datum,\n        title: yName,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        legendItemName,\n        stackGroup,\n        ...format,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  legendItemSymbol() {\n    const { fill, stroke: stroke2, strokeWidth, fillOpacity, strokeOpacity, lineDash, lineDashOffset } = this.properties;\n    return {\n      marker: {\n        fill,\n        fillOpacity,\n        stroke: stroke2,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset\n      }\n    };\n  }\n  getLegendData(legendType) {\n    const { showInLegend } = this.properties;\n    if (legendType !== \"category\" || !this.properties.isValid()) {\n      return [];\n    }\n    const {\n      id: seriesId,\n      ctx: { legendManager },\n      visible\n    } = this;\n    const { yKey: itemId, yName, legendItemName } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: seriesId,\n        itemId,\n        seriesId,\n        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),\n        label: { text: legendItemName ?? yName ?? itemId },\n        symbol: this.legendItemSymbol(),\n        legendItemName,\n        hideInLegend: !showInLegend\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ datumSelection, labelSelection, annotationSelections }) {\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, \"normal\"));\n    fromToMotion(this.id, \"nodes\", this.ctx.animationManager, [datumSelection], fns);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n  }\n  animateWaitingUpdateReady(data) {\n    const { datumSelection, labelSelection, annotationSelections, previousContextData } = data;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    let dataDiff = this.processedData?.reduced?.diff?.[this.id];\n    if (dataDiff == null && this.processedData?.reduced?.diff != null) {\n      dataDiff = {\n        changed: true,\n        added: new Set(Array.from(datumSelection, ({ datum }) => this.getDatumId(datum))),\n        updated: /* @__PURE__ */ new Set(),\n        removed: /* @__PURE__ */ new Set(),\n        moved: /* @__PURE__ */ new Set()\n      };\n    }\n    const mode = previousContextData == null ? \"fade\" : \"normal\";\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, mode));\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      this.ctx.animationManager,\n      [datumSelection],\n      fns,\n      (_, datum) => this.getDatumId(datum),\n      dataDiff\n    );\n    const scalingChanged = previousContextData != null && (!areScalingEqual(data.contextData.scales.x, previousContextData.scales.x) || !areScalingEqual(data.contextData.scales.y, previousContextData.scales.y) || !areScalingEqual(\n      data.contextData.groupScale,\n      data.previousContextData.groupScale\n    ));\n    const hasMotion = (dataDiff?.changed ?? false) || scalingChanged;\n    if (hasMotion) {\n      seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n      seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n    }\n  }\n  getDatumId(datum) {\n    return createDatumId(datum.xValue, datum.valueIndex, datum.phantom);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  computeFocusBounds({ datumIndex }) {\n    const datumBox = this.contextNodeData?.nodeData[datumIndex].clipBBox;\n    return computeBarFocusBounds(this, datumBox);\n  }\n};\nBarSeries.className = \"BarSeries\";\nBarSeries.type = \"bar\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeriesModule.ts\nvar BarSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"bar\",\n  moduleFactory: (ctx) => new BarSeries(ctx),\n  stackable: true,\n  groupable: true,\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: swapAxisCondition(\n    [\n      { type: \"number\" /* NUMBER */, position: \"left\" /* LEFT */ },\n      { type: \"category\" /* CATEGORY */, position: \"bottom\" /* BOTTOM */ }\n    ],\n    (series) => series?.direction === \"horizontal\"\n  ),\n  themeTemplate: {\n    series: {\n      direction: \"vertical\",\n      fillOpacity: 1,\n      strokeWidth: 0,\n      lineDash: [0],\n      lineDashOffset: 0,\n      label: {\n        enabled: false,\n        fontWeight: { $ref: \"fontWeight\" },\n        fontSize: { $ref: \"fontSize\" },\n        fontFamily: { $ref: \"fontFamily\" },\n        color: {\n          $if: [\n            {\n              $or: [\n                { $eq: [{ $path: \"./placement\" }, \"outside-start\"] },\n                { $eq: [{ $path: \"./placement\" }, \"outside-end\"] }\n              ]\n            },\n            { $ref: \"textColor\" },\n            { $ref: \"backgroundColor\" }\n          ]\n        },\n        placement: \"inside-center\"\n      },\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 0.3\n        }\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesProperties.ts\nvar BubbleSeriesMarker = class extends SeriesMarker {\n  constructor() {\n    super(...arguments);\n    this.maxSize = 30;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection()\n], BubbleSeriesMarker.prototype, \"maxSize\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true }),\n  SceneChangeDetection()\n], BubbleSeriesMarker.prototype, \"domain\", 2);\nvar BubbleSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"top\";\n  }\n};\n__decorateClass([\n  Validate(LABEL_PLACEMENT)\n], BubbleSeriesLabel.prototype, \"placement\", 2);\nvar BubbleSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.colorRange = [\"#ffff00\", \"#00ff00\", \"#0000ff\"];\n    this.label = new BubbleSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    // No validation. Not a part of the options contract.\n    this.marker = new BubbleSeriesMarker();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"xFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"sizeFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"sizeName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorDomain\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], BubbleSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.shape\")\n], BubbleSeriesProperties.prototype, \"shape\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.size\")\n], BubbleSeriesProperties.prototype, \"size\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.maxSize\")\n], BubbleSeriesProperties.prototype, \"maxSize\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.domain\", { optional: true })\n], BubbleSeriesProperties.prototype, \"domain\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fill\", { optional: true })\n], BubbleSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fillOpacity\")\n], BubbleSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.stroke\", { optional: true })\n], BubbleSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeWidth\")\n], BubbleSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeOpacity\")\n], BubbleSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.lineDash\")\n], BubbleSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.lineDashOffset\")\n], BubbleSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.itemStyler\", { optional: true })\n], BubbleSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BubbleSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BubbleSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeries.ts\nvar BubbleSeriesNodeEvent = class extends CartesianSeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.sizeKey = series.properties.sizeKey;\n  }\n};\nvar BubbleSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [\n        2 /* AXIS_ALIGNED */,\n        1 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      pathsPerSeries: [],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        label: resetLabelFn,\n        marker: resetMarkerFn\n      },\n      usesPlacedLabels: true\n    });\n    this.NodeEvent = BubbleSeriesNodeEvent;\n    this.clipFocusBox = false;\n    this.properties = new BubbleSeriesProperties();\n    this.sizeScale = new LinearScale();\n    this.colorScale = new ColorScale();\n  }\n  get pickModeAxis() {\n    return \"main-category\";\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || this.data == null || !this.visible)\n      return;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const colorScaleType = this.colorScale.type;\n    const sizeScaleType = this.sizeScale.type;\n    const {\n      xKey,\n      yKey,\n      sizeKey,\n      xFilterKey,\n      yFilterKey,\n      sizeFilterKey,\n      labelKey,\n      colorDomain,\n      colorRange,\n      colorKey,\n      marker\n    } = this.properties;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        valueProperty(xKey, xScaleType, { id: `xValue` }),\n        valueProperty(yKey, yScaleType, { id: `yValue` }),\n        ...xFilterKey != null ? [valueProperty(xFilterKey, xScaleType, { id: `xFilterValue` })] : [],\n        ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: `yFilterValue` })] : [],\n        ...sizeFilterKey != null ? [valueProperty(sizeFilterKey, sizeScaleType, { id: `sizeFilterValue` })] : [],\n        valueProperty(sizeKey, sizeScaleType, { id: `sizeValue` }),\n        ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],\n        ...labelKey ? [valueProperty(labelKey, \"band\", { id: `labelValue` })] : []\n      ]\n    });\n    const sizeKeyIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);\n    const processedSize = processedData.domain.values[sizeKeyIdx] ?? [];\n    this.sizeScale.domain = marker.domain ? marker.domain : processedSize;\n    if (colorKey) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);\n      this.colorScale.domain = colorDomain ?? processedData.domain.values[colorKeyIdx] ?? [];\n      this.colorScale.range = colorRange;\n      this.colorScale.update();\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  xCoordinateRange(xValue, pixelSize, index) {\n    const { properties, sizeScale } = this;\n    const { size, sizeKey } = properties;\n    const x = this.axes[\"x\" /* X */].scale.convert(xValue);\n    const sizeValues = sizeKey != null ? this.dataModel.resolveColumnById(this, `sizeValue`, this.processedData) : void 0;\n    const sizeValue = sizeValues != null ? sizeScale.convert(sizeValues[index]) : size;\n    const r = 0.5 * sizeValue * pixelSize;\n    return [x - r, x + r];\n  }\n  yCoordinateRange(yValues, pixelSize, index) {\n    const { properties, sizeScale } = this;\n    const { size, sizeKey } = properties;\n    const y = this.axes[\"y\" /* Y */].scale.convert(yValues[0]);\n    const sizeValues = sizeKey != null ? this.dataModel.resolveColumnById(this, `sizeValue`, this.processedData) : void 0;\n    const sizeValue = sizeValues != null ? sizeScale.convert(sizeValues[index]) : size;\n    const r = 0.5 * sizeValue * pixelSize;\n    return [y - r, y + r];\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!processedData || !dataModel)\n      return [];\n    const dataValues = {\n      [\"x\" /* X */]: \"xValue\",\n      [\"y\" /* Y */]: \"yValue\"\n    };\n    const id = dataValues[direction];\n    const dataDef = dataModel.resolveProcessedDataDefById(this, id);\n    const domain = dataModel.getDomain(this, id, \"value\", processedData);\n    if (dataDef?.def.type === \"value\" && dataDef?.def.valueType === \"category\") {\n      return domain;\n    }\n    const crossDirection = direction === \"x\" /* X */ ? \"y\" /* Y */ : \"x\" /* X */;\n    const crossId = dataValues[crossDirection];\n    const ext = this.domainForClippedRange(direction, [id], crossId, false);\n    return fixNumericExtent(extent(ext));\n  }\n  getSeriesRange(_direction, visibleRange) {\n    return this.domainForVisibleRange(\"y\" /* Y */, [\"yValue\"], \"xValue\", visibleRange, false);\n  }\n  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {\n    return this.countVisibleItems(\"xValue\", [\"yValue\"], xVisibleRange, yVisibleRange, minVisibleItems);\n  }\n  createNodeData() {\n    const { axes, dataModel, processedData, colorScale, sizeScale, visible } = this;\n    const {\n      xKey,\n      yKey,\n      sizeKey,\n      xFilterKey,\n      yFilterKey,\n      sizeFilterKey,\n      labelKey,\n      xName,\n      yName,\n      sizeName,\n      labelName,\n      label,\n      colorKey,\n      marker\n    } = this.properties;\n    const { placement } = label;\n    const anchor = Marker.anchor(marker.shape);\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!(dataModel && processedData && visible && xAxis && yAxis)) {\n      return;\n    }\n    const xDataValues = dataModel.resolveColumnById(this, `xValue`, processedData);\n    const yDataValues = dataModel.resolveColumnById(this, `yValue`, processedData);\n    const sizeDataValues = sizeKey != null ? dataModel.resolveColumnById(this, `sizeValue`, processedData) : void 0;\n    const colorDataValues = colorKey != null ? dataModel.resolveColumnById(this, `colorValue`, processedData) : void 0;\n    const labelDataValues = labelKey != null ? dataModel.resolveColumnById(this, `labelValue`, processedData) : void 0;\n    const xFilterDataValues = xFilterKey != null ? dataModel.resolveColumnById(this, `xFilterValue`, processedData) : void 0;\n    const yFilterDataValues = yFilterKey != null ? dataModel.resolveColumnById(this, `yFilterValue`, processedData) : void 0;\n    const sizeFilterDataValues = sizeFilterKey != null ? dataModel.resolveColumnById(this, `sizeFilterValue`, processedData) : void 0;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    sizeScale.range = [marker.size, marker.maxSize];\n    const font2 = label.getFont();\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font: font2 });\n    processedData.dataSources.get(this.id)?.forEach((datum, datumIndex) => {\n      const xDatum = xDataValues[datumIndex];\n      const yDatum = yDataValues[datumIndex];\n      const sizeValue = sizeDataValues?.[datumIndex];\n      const x = xScale.convert(xDatum) + xOffset;\n      const y = yScale.convert(yDatum) + yOffset;\n      let selected;\n      if (xFilterDataValues != null && yFilterDataValues != null) {\n        selected = xFilterDataValues[datumIndex] === xDatum && yFilterDataValues[datumIndex] === yDatum;\n        if (sizeFilterDataValues != null) {\n          selected && (selected = sizeFilterDataValues[datumIndex] === sizeValue);\n        }\n      }\n      const labelText = this.getLabelText(label, {\n        value: labelDataValues != null ? labelDataValues[datumIndex] : yDatum,\n        datum,\n        xKey,\n        yKey,\n        sizeKey,\n        labelKey,\n        xName,\n        yName,\n        sizeName,\n        labelName\n      });\n      const size = textMeasurer.measureText(String(labelText));\n      const markerSize = sizeValue != null ? sizeScale.convert(sizeValue) : marker.size;\n      const fill = colorDataValues != null ? colorScale.convert(colorDataValues[datumIndex]) : void 0;\n      nodeData.push({\n        series: this,\n        itemId: yKey,\n        yKey,\n        xKey,\n        datum,\n        datumIndex,\n        xValue: xDatum,\n        yValue: yDatum,\n        sizeValue,\n        point: { x, y, size: markerSize },\n        midPoint: { x, y },\n        fill,\n        label: { text: labelText, ...size },\n        anchor,\n        placement,\n        selected\n      });\n    });\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  getLabelData() {\n    if (!this.isLabelEnabled())\n      return [];\n    return this.contextNodeData?.labelData ?? [];\n  }\n  updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    const data = this.properties.marker.enabled ? nodeData : [];\n    return markerSelection.update(\n      data,\n      void 0,\n      (datum) => createDatumId([datum.xValue, datum.yValue, datum.label.text])\n    );\n  }\n  getMarkerItemBaseStyle(highlighted) {\n    const { properties } = this;\n    const { marker } = properties;\n    const highlightStyle = highlighted ? properties.highlightStyle.item : void 0;\n    return {\n      fill: highlightStyle?.fill ?? marker.fill,\n      fillOpacity: highlightStyle?.fillOpacity ?? marker.fillOpacity,\n      stroke: highlightStyle?.stroke ?? marker.stroke,\n      strokeWidth: highlightStyle?.strokeWidth ?? marker.strokeWidth,\n      strokeOpacity: highlightStyle?.strokeOpacity ?? marker.strokeOpacity,\n      lineDash: highlightStyle?.lineDash ?? marker.lineDash,\n      lineDashOffset: highlightStyle?.lineDashOffset ?? marker.lineDashOffset\n    };\n  }\n  getMarkerItemStyleOverrides(datumId, datum, format, highlighted) {\n    const { id: seriesId, properties } = this;\n    const { xKey, yKey, sizeKey, labelKey, marker } = properties;\n    const { itemStyler } = marker;\n    if (itemStyler == null)\n      return;\n    return this.cachedDatumCallback(createDatumId(datumId, highlighted ? \"highlight\" : \"node\"), () => {\n      return itemStyler({\n        seriesId,\n        datum,\n        xKey,\n        yKey,\n        sizeKey,\n        labelKey,\n        highlighted,\n        ...format\n      });\n    });\n  }\n  updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;\n    const { size, shape, fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = mergeDefaults(highlighted && this.properties.highlightStyle.item, marker.getStyle());\n    const baseStyle = {\n      size,\n      shape,\n      fill,\n      fillOpacity,\n      stroke: stroke2,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset\n    };\n    this.sizeScale.range = [marker.size, marker.maxSize];\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, sizeKey, labelKey }, baseStyle, {\n        selected: datum.selected\n      });\n    });\n    if (!highlighted) {\n      this.properties.marker.markClean();\n    }\n  }\n  updatePlacedLabelData(labelData) {\n    this.labelSelection.update(\n      labelData.map((v) => ({\n        ...v.datum,\n        point: {\n          x: v.x,\n          y: v.y,\n          size: v.datum.point.size\n        }\n      })),\n      (text2) => {\n        text2.pointerEvents = 1 /* None */;\n      }\n    );\n    this.updateLabelNodes({ labelSelection: this.labelSelection });\n  }\n  updateLabelNodes(opts) {\n    const { label } = this.properties;\n    opts.labelSelection.each((text2, datum) => {\n      text2.text = datum.label.text;\n      text2.fill = label.color;\n      text2.x = datum.point?.x ?? 0;\n      text2.y = datum.point?.y ?? 0;\n      text2.fontStyle = label.fontStyle;\n      text2.fontWeight = label.fontWeight;\n      text2.fontSize = label.fontSize;\n      text2.fontFamily = label.fontFamily;\n      text2.textAlign = \"left\";\n      text2.textBaseline = \"top\";\n    });\n  }\n  getTooltipContent(nodeDatum) {\n    const { id: seriesId, dataModel, processedData, axes, properties } = this;\n    const { xKey, xName, yKey, yName, sizeKey, sizeName, labelKey, labelName, title, tooltip } = properties;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!dataModel || !processedData || !xAxis || !yAxis)\n      return;\n    const { datumIndex } = nodeDatum;\n    const datum = processedData.dataSources.get(this.id)?.[datumIndex];\n    const xValue = dataModel.resolveColumnById(this, `xValue`, processedData)[datumIndex];\n    const yValue = dataModel.resolveColumnById(this, `yValue`, processedData)[datumIndex];\n    if (xValue == null)\n      return;\n    const data = [\n      { label: xName, fallbackLabel: xKey, value: xAxis.formatDatum(xValue) },\n      { label: yName, fallbackLabel: yKey, value: yAxis.formatDatum(yValue) }\n    ];\n    if (sizeKey != null) {\n      const sizeValue = dataModel.resolveColumnById(this, `sizeValue`, processedData)[datumIndex];\n      data.push({ label: sizeName, fallbackLabel: sizeKey, value: String(sizeValue) });\n    }\n    const format = this.getMarkerItemBaseStyle(false);\n    Object.assign(format, this.getMarkerItemStyleOverrides(String(datumIndex), datum, format, false));\n    return tooltip.formatTooltip(\n      {\n        title,\n        symbol: this.legendItemSymbol(),\n        data\n      },\n      {\n        seriesId,\n        datum,\n        title: yKey,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        sizeKey,\n        sizeName,\n        labelKey,\n        labelName,\n        ...format,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  legendItemSymbol() {\n    const { marker } = this.properties;\n    const { shape, fill, stroke: stroke2, fillOpacity, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = marker;\n    return {\n      marker: {\n        shape,\n        fill: fill ?? \"rgba(0, 0, 0, 0)\",\n        stroke: stroke2 ?? \"rgba(0, 0, 0, 0)\",\n        fillOpacity,\n        strokeOpacity,\n        strokeWidth,\n        lineDash,\n        lineDashOffset\n      }\n    };\n  }\n  getLegendData() {\n    if (!this.properties.isValid()) {\n      return [];\n    }\n    const {\n      id: seriesId,\n      ctx: { legendManager },\n      visible\n    } = this;\n    const { yKey: itemId, yName, title } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: seriesId,\n        itemId,\n        seriesId,\n        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),\n        label: {\n          text: title ?? yName ?? itemId\n        },\n        symbol: this.legendItemSymbol()\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ markerSelection, labelSelection }) {\n    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey, sizeKey, labelKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, {\n      datum,\n      xKey,\n      yKey,\n      sizeKey,\n      labelKey,\n      highlighted: false\n    });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nBubbleSeries.className = \"BubbleSeries\";\nBubbleSeries.type = \"bubble\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesModule.ts\nvar BubbleSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"bubble\",\n  moduleFactory: (ctx) => new BubbleSeries(ctx),\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      shape: \"circle\",\n      size: 7,\n      maxSize: 30,\n      fillOpacity: 0.8,\n      tooltip: { position: { type: \"node\" } },\n      label: {\n        enabled: false,\n        fontSize: { $ref: \"fontSize\" },\n        fontFamily: { $ref: \"fontFamily\" },\n        fontWeight: { $ref: \"fontWeight\" },\n        color: { $ref: \"textColor\" }\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesProperties.ts\nvar HistogramSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.areaPlot = false;\n    this.aggregation = \"sum\";\n    this.shadow = new DropShadow();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], HistogramSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], HistogramSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], HistogramSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], HistogramSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], HistogramSeriesProperties.prototype, \"areaPlot\", 2);\n__decorateClass([\n  Validate(ARRAY, { optional: true })\n], HistogramSeriesProperties.prototype, \"bins\", 2);\n__decorateClass([\n  Validate(UNION([\"count\", \"sum\", \"mean\"], \"a histogram aggregation\"))\n], HistogramSeriesProperties.prototype, \"aggregation\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], HistogramSeriesProperties.prototype, \"binCount\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeries.ts\nvar defaultBinCount = 10;\nvar HistogramSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      datumSelectionGarbageCollection: false,\n      animationResetFns: {\n        datum: resetBarSelectionsFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new HistogramSeriesProperties();\n    this.calculatedBins = [];\n  }\n  // During processData phase, used to unify different ways of the user specifying\n  // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].\n  deriveBins(xDomain) {\n    const binStarts = createTicks(xDomain[0], xDomain[1], defaultBinCount);\n    const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);\n    const [firstBinEnd] = binStarts;\n    const expandStartToBin = (n) => [n, n + binSize];\n    return [[firstBinEnd - binSize, firstBinEnd], ...binStarts.map(expandStartToBin)];\n  }\n  calculateNiceBins(domain, binCount) {\n    const startGuess = Math.floor(domain[0]);\n    const stop = domain[1];\n    const segments = binCount || 1;\n    const { start: start2, binSize } = this.calculateNiceStart(startGuess, stop, segments);\n    return this.getBins(start2, stop, binSize, segments);\n  }\n  getBins(start2, stop, step, count) {\n    const bins = [];\n    const precision = this.calculatePrecision(step);\n    for (let i = 0; i < count; i++) {\n      const a = Math.round((start2 + i * step) * precision) / precision;\n      let b = Math.round((start2 + (i + 1) * step) * precision) / precision;\n      if (i === count - 1) {\n        b = Math.max(b, stop);\n      }\n      bins[i] = [a, b];\n    }\n    return bins;\n  }\n  calculatePrecision(step) {\n    let precision = 10;\n    if (isFinite(step) && step > 0) {\n      while (step < 1) {\n        precision *= 10;\n        step *= 10;\n      }\n    }\n    return precision;\n  }\n  calculateNiceStart(a, b, segments) {\n    const binSize = Math.abs(b - a) / segments;\n    const order = Math.floor(Math.log10(binSize));\n    const magnitude = Math.pow(10, order);\n    const start2 = Math.floor(a / magnitude) * magnitude;\n    return {\n      start: start2,\n      binSize\n    };\n  }\n  async processData(dataController) {\n    if (!this.visible) {\n      this.processedData = void 0;\n      this.animationState.transition(\"updateData\");\n    }\n    const { xKey, yKey, areaPlot, aggregation } = this.properties;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ yScale, xScale });\n    const props = [keyProperty(xKey, xScaleType), SORT_DOMAIN_GROUPS];\n    if (yKey) {\n      let aggProp = groupCount(\"groupAgg\");\n      if (aggregation === \"count\") {\n      } else if (aggregation === \"sum\") {\n        aggProp = groupSum(\"groupAgg\");\n      } else if (aggregation === \"mean\") {\n        aggProp = groupAverage(\"groupAgg\");\n      }\n      if (areaPlot) {\n        aggProp = area(\"groupAgg\", aggProp);\n      }\n      props.push(valueProperty(yKey, yScaleType, { invalidValue: void 0 }), aggProp);\n    } else {\n      props.push(rowCountProperty(\"count\"));\n      let aggProp = groupCount(\"groupAgg\");\n      if (areaPlot) {\n        aggProp = area(\"groupAgg\", aggProp);\n      }\n      props.push(aggProp);\n    }\n    const groupByFn = (dataSet) => {\n      const xExtent = fixNumericExtent(dataSet.domain.keys[0]);\n      if (xExtent.length === 0) {\n        dataSet.domain.groups = [];\n        return () => [];\n      }\n      const bins = isNumber(this.properties.binCount) ? this.calculateNiceBins(xExtent, this.properties.binCount) : this.properties.bins ?? this.deriveBins(xExtent);\n      const binCount = bins.length;\n      this.calculatedBins = [...bins];\n      return (keys) => {\n        let xValue = keys[0];\n        if (isDate(xValue)) {\n          xValue = xValue.getTime();\n        }\n        if (!isNumber(xValue))\n          return [];\n        for (let i = 0; i < binCount; i++) {\n          const nextBin = bins[i];\n          if (xValue >= nextBin[0] && xValue < nextBin[1]) {\n            return nextBin;\n          }\n          if (i === binCount - 1 && xValue <= nextBin[1]) {\n            return nextBin;\n          }\n        }\n        return [];\n      };\n    };\n    if (!this.ctx.animationManager.isSkipped() && this.processedData) {\n      props.push(diff(this.id, this.processedData, false));\n    }\n    await this.requestDataModel(dataController, this.data, {\n      props,\n      groupByFn\n    });\n    this.animationState.transition(\"updateData\");\n  }\n  xCoordinateRange() {\n    return [NaN, NaN];\n  }\n  yCoordinateRange() {\n    return [NaN, NaN];\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel } = this;\n    if (!processedData || !dataModel || !this.calculatedBins.length)\n      return [];\n    const yDomain = dataModel.getDomain(this, `groupAgg`, \"aggregate\", processedData);\n    const xDomainMin = this.calculatedBins?.[0][0];\n    const xDomainMax = this.calculatedBins?.[(this.calculatedBins?.length ?? 0) - 1][1];\n    if (direction === \"x\" /* X */) {\n      return fixNumericExtent([xDomainMin, xDomainMax]);\n    }\n    return fixNumericExtent(yDomain);\n  }\n  getSeriesRange(_direction, [r0, r1]) {\n    const { dataModel, processedData } = this;\n    if (!dataModel || processedData?.type !== \"grouped\")\n      return [NaN, NaN];\n    const xScale = this.axes[\"x\" /* X */].scale;\n    const yMin = 0;\n    let yMax = -Infinity;\n    processedData.groups.forEach(({ keys, aggregation }) => {\n      const [[negativeAgg, positiveAgg] = [0, 0]] = aggregation;\n      const [xDomainMin, xDomainMax] = keys;\n      const [x0, x1] = findMinMax([xScale.convert(xDomainMin), xScale.convert(xDomainMax)]);\n      if (x1 >= r0 && x0 <= r1) {\n        const total = negativeAgg + positiveAgg;\n        yMax = Math.max(yMax, total);\n      }\n    });\n    if (yMin > yMax)\n      return [NaN, NaN];\n    return [yMin, yMax];\n  }\n  createNodeData() {\n    const { id: seriesId, axes, processedData, dataModel } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!xAxis || !yAxis || !dataModel) {\n      return;\n    }\n    const { scale: xScale } = xAxis;\n    const { scale: yScale } = yAxis;\n    const { xKey, yKey, xName, yName } = this.properties;\n    const labelFormatter = this.properties.label.formatter ?? ((params) => String(params.value));\n    const nodeData = [];\n    const context = {\n      itemId: this.properties.yKey ?? this.id,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      animationValid: true,\n      visible: this.visible\n    };\n    if (!this.visible || processedData == null || processedData.type !== \"grouped\") {\n      return context;\n    }\n    processedData.groups.forEach((group, groupIndex) => {\n      const { keys, datumIndices, aggregation } = group;\n      const [[negativeAgg, positiveAgg] = [0, 0]] = aggregation;\n      const frequency = datumIndices.length;\n      const domain = keys;\n      const [xDomainMin, xDomainMax] = domain;\n      const datum = [...dataModel.forEachDatum(this, processedData, group)];\n      const xMinPx = xScale.convert(xDomainMin);\n      const xMaxPx = xScale.convert(xDomainMax);\n      const total = negativeAgg + positiveAgg;\n      const yZeroPx = yScale.convert(0);\n      const yMaxPx = yScale.convert(total);\n      const w = Math.abs(xMaxPx - xMinPx);\n      const h = Math.abs(yMaxPx - yZeroPx);\n      const x = Math.min(xMinPx, xMaxPx);\n      const y = Math.min(yZeroPx, yMaxPx);\n      let selectionDatumLabel = void 0;\n      if (total !== 0) {\n        selectionDatumLabel = {\n          x: x + w / 2,\n          y: y + h / 2,\n          text: this.cachedDatumCallback(\n            createDatumId(groupIndex, \"label\"),\n            () => labelFormatter({\n              value: total,\n              datum,\n              seriesId,\n              xKey,\n              yKey,\n              xName,\n              yName\n            })\n          ) ?? String(total)\n        };\n      }\n      const nodeMidPoint = {\n        x: x + w / 2,\n        y: y + h / 2\n      };\n      const yAxisReversed = yAxis.isReversed();\n      nodeData.push({\n        series: this,\n        datumIndex: groupIndex,\n        datum,\n        // required by SeriesNodeDatum, but might not make sense here\n        // since each selection is an aggregation of multiple data.\n        aggregatedValue: total,\n        frequency,\n        domain,\n        yKey,\n        xKey,\n        x,\n        y,\n        xValue: xMinPx,\n        yValue: yMaxPx,\n        width: w,\n        height: h,\n        midPoint: nodeMidPoint,\n        topLeftCornerRadius: !yAxisReversed,\n        topRightCornerRadius: !yAxisReversed,\n        bottomRightCornerRadius: yAxisReversed,\n        bottomLeftCornerRadius: yAxisReversed,\n        label: selectionDatumLabel,\n        crisp: true\n      });\n    });\n    nodeData.sort((a, b) => a.x - b.x);\n    return context;\n  }\n  nodeFactory() {\n    return new Rect();\n  }\n  updateDatumSelection(opts) {\n    const { nodeData, datumSelection } = opts;\n    return datumSelection.update(nodeData, void 0, (datum) => datum.domain.join(\"_\"));\n  }\n  getItemBaseStyle(highlighted) {\n    const { properties } = this;\n    const highlightStyle = highlighted ? properties.highlightStyle.item : void 0;\n    return {\n      fill: highlightStyle?.fill ?? properties.fill,\n      fillOpacity: highlightStyle?.fillOpacity ?? properties.fillOpacity,\n      stroke: highlightStyle?.stroke ?? properties.stroke,\n      strokeWidth: highlightStyle?.strokeWidth ?? this.getStrokeWidth(properties.strokeWidth),\n      strokeOpacity: highlightStyle?.strokeOpacity ?? properties.strokeOpacity,\n      lineDash: highlightStyle?.lineDash ?? properties.lineDash,\n      lineDashOffset: highlightStyle?.lineDashOffset ?? properties.lineDashOffset,\n      cornerRadius: properties.cornerRadius\n    };\n  }\n  updateDatumNodes(opts) {\n    const { isHighlight: isDatumHighlighted } = opts;\n    const { shadow } = this.properties;\n    const style = this.getItemBaseStyle(isDatumHighlighted);\n    opts.datumSelection.each((rect, datum) => {\n      const { cornerRadius } = style;\n      const { topLeftCornerRadius, topRightCornerRadius, bottomRightCornerRadius, bottomLeftCornerRadius } = datum;\n      applyShapeStyle(rect, style);\n      rect.topLeftCornerRadius = topLeftCornerRadius ? cornerRadius : 0;\n      rect.topRightCornerRadius = topRightCornerRadius ? cornerRadius : 0;\n      rect.bottomRightCornerRadius = bottomRightCornerRadius ? cornerRadius : 0;\n      rect.bottomLeftCornerRadius = bottomLeftCornerRadius ? cornerRadius : 0;\n      rect.crisp = datum.crisp;\n      rect.fillShadow = shadow;\n      rect.visible = datum.height > 0;\n    });\n  }\n  updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    return labelSelection.update(labelData, (text2) => {\n      text2.pointerEvents = 1 /* None */;\n      text2.textAlign = \"center\";\n      text2.textBaseline = \"middle\";\n    });\n  }\n  updateLabelNodes(opts) {\n    const { fontStyle, fontWeight, fontFamily, fontSize, color } = this.properties.label;\n    const labelEnabled = this.isLabelEnabled();\n    opts.labelSelection.each((text2, datum) => {\n      if (labelEnabled && datum?.label) {\n        text2.text = datum.label.text;\n        text2.x = datum.label.x;\n        text2.y = datum.label.y;\n        text2.fontStyle = fontStyle;\n        text2.fontWeight = fontWeight;\n        text2.fontFamily = fontFamily;\n        text2.fontSize = fontSize;\n        text2.fill = color;\n        text2.visible = true;\n      } else {\n        text2.visible = false;\n      }\n    });\n  }\n  initQuadTree(quadtree) {\n    const { value: childNode } = this.contentGroup.children().next();\n    if (childNode) {\n      addHitTestersToQuadtree(quadtree, childNode.children());\n    }\n  }\n  pickNodeClosestDatum(point) {\n    return findQuadtreeMatch(this, point);\n  }\n  getTooltipContent(nodeDatum) {\n    const {\n      id: seriesId,\n      dataModel,\n      processedData,\n      axes,\n      properties,\n      ctx: { localeManager }\n    } = this;\n    const { xKey, xName, yKey, yName, tooltip } = properties;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!dataModel || processedData?.type !== \"grouped\" || !xAxis || !yAxis) {\n      return;\n    }\n    const groupIndex = nodeDatum.datumIndex;\n    const group = processedData.groups[groupIndex];\n    const { aggregation, datumIndices, keys } = group;\n    const [[negativeAgg, positiveAgg] = [0, 0]] = aggregation;\n    const frequency = datumIndices.length;\n    const domain = keys;\n    const [rangeMin, rangeMax] = domain;\n    const aggregatedValue = negativeAgg + positiveAgg;\n    const datum = {\n      data: [...dataModel.forEachDatum(this, processedData, group)],\n      aggregatedValue,\n      frequency,\n      domain\n    };\n    const data = [\n      {\n        label: xName,\n        fallbackLabel: xKey,\n        value: `${xAxis.formatDatum(rangeMin)} - ${xAxis.formatDatum(rangeMax)}`\n      },\n      { label: localeManager.t(\"seriesHistogramTooltipFrequency\"), value: yAxis.formatDatum(frequency) }\n    ];\n    if (yKey != null) {\n      let label;\n      switch (properties.aggregation) {\n        case \"sum\":\n          label = localeManager.t(\"seriesHistogramTooltipSum\", { yName });\n          break;\n        case \"mean\":\n          label = localeManager.t(\"seriesHistogramTooltipMean\", { yName });\n          break;\n        case \"count\":\n          label = localeManager.t(\"seriesHistogramTooltipCount\", { yName });\n          break;\n      }\n      data.push({ label, value: yAxis.formatDatum(aggregatedValue) });\n    }\n    return tooltip.formatTooltip(\n      {\n        symbol: this.legendItemSymbol(),\n        data\n      },\n      {\n        seriesId,\n        datum,\n        title: yName,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        xRange: [rangeMin, rangeMax],\n        frequency,\n        ...this.getItemBaseStyle(false)\n      }\n    );\n  }\n  legendItemSymbol() {\n    const { fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this.properties;\n    return {\n      marker: {\n        fill: fill ?? \"rgba(0, 0, 0, 0)\",\n        stroke: stroke2 ?? \"rgba(0, 0, 0, 0)\",\n        fillOpacity,\n        strokeOpacity,\n        strokeWidth,\n        lineDash,\n        lineDashOffset\n      }\n    };\n  }\n  getLegendData(legendType) {\n    if (legendType !== \"category\") {\n      return [];\n    }\n    const {\n      id: seriesId,\n      ctx: { legendManager },\n      visible\n    } = this;\n    const { xKey: itemId, yName, showInLegend } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: seriesId,\n        itemId,\n        seriesId,\n        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),\n        label: {\n          text: yName ?? itemId ?? \"Frequency\"\n        },\n        symbol: this.legendItemSymbol(),\n        hideInLegend: !showInLegend\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ datumSelection, labelSelection }) {\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, \"normal\"));\n    fromToMotion(this.id, \"datums\", this.ctx.animationManager, [datumSelection], fns);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n  }\n  animateWaitingUpdateReady(data) {\n    const dataDiff = this.processedData?.reduced?.diff?.[this.id];\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, \"normal\"));\n    fromToMotion(\n      this.id,\n      \"datums\",\n      this.ctx.animationManager,\n      [data.datumSelection],\n      fns,\n      (_, datum) => createDatumId(datum.domain),\n      dataDiff\n    );\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, data.labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  computeFocusBounds({ datumIndex }) {\n    return computeBarFocusBounds(this, this.contextNodeData?.nodeData[datumIndex]);\n  }\n};\nHistogramSeries.className = \"HistogramSeries\";\nHistogramSeries.type = \"histogram\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesModule.ts\nvar HistogramSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"histogram\",\n  moduleFactory: (ctx) => new HistogramSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      strokeWidth: 1,\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      lineDash: [0],\n      lineDashOffset: 0,\n      label: {\n        enabled: false,\n        fontSize: { $ref: \"fontSize\" },\n        fontFamily: { $ref: \"fontFamily\" },\n        fontWeight: { $ref: \"fontWeight\" },\n        color: { $ref: \"backgroundColor\" }\n      },\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      }\n    }\n  },\n  paletteFactory: ({ takeColors }) => {\n    const {\n      fills: [fill],\n      strokes: [stroke2]\n    } = takeColors(1);\n    return { fill, stroke: stroke2 };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesProperties.ts\nvar LineSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.stroke = \"#874349\";\n    this.strokeWidth = 2;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.interpolation = new InterpolationProperties();\n    this.marker = new SeriesMarker();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n    this.connectMissingData = false;\n    this.sparklineMode = false;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], LineSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], LineSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"stackGroup\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LineSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], LineSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LineSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], LineSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], LineSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LineSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"interpolation\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LineSeriesProperties.prototype, \"connectMissingData\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LineSeriesProperties.prototype, \"sparklineMode\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeries.ts\nvar CROSS_FILTER_LINE_STROKE_OPACITY_FACTOR = 0.25;\nvar LineSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      hasMarkers: true,\n      pickModes: [\n        2 /* AXIS_ALIGNED */,\n        1 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),\n        label: resetLabelFn,\n        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })\n      }\n    });\n    this.clipFocusBox = false;\n    this.properties = new LineSeriesProperties();\n    this.dataAggregationFilters = void 0;\n  }\n  get pickModeAxis() {\n    return this.properties.sparklineMode ? \"main\" : \"main-category\";\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 0 } = {} } = this;\n    const { xKey, yKey, yFilterKey, connectMissingData, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const stacked = stackCount >= 1 || normalizedTo != null;\n    const common = { invalidValue: null };\n    if (connectMissingData && stacked) {\n      common.invalidValue = 0;\n    }\n    if (stacked && !visible) {\n      common.forceValue = 0;\n    }\n    const props = [];\n    if (!isContinuousX || stacked) {\n      props.push(keyProperty(xKey, xScaleType, { id: \"xKey\" }));\n    }\n    props.push(\n      valueProperty(xKey, xScaleType, { id: \"xValue\" }),\n      valueProperty(yKey, yScaleType, {\n        id: `yValueRaw`,\n        ...common,\n        invalidValue: void 0\n      })\n    );\n    if (yFilterKey != null) {\n      props.push(valueProperty(yFilterKey, yScaleType, { id: \"yFilterRaw\" }));\n    }\n    if (stacked) {\n      const ids = [\n        `line-stack-${groupIndex}-yValues`,\n        `line-stack-${groupIndex}-yValues-trailing`,\n        `line-stack-${groupIndex}-yValues-marker`\n      ];\n      props.push(\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window\",\n          \"current\",\n          { id: `yValueEnd`, ...common, groupId: ids[0] },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window-trailing\",\n          \"current\",\n          { id: `yValueStart`, ...common, groupId: ids[1] },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          { id: `yValueCumulative`, ...common, groupId: ids[2] },\n          yScaleType\n        )\n      );\n      if (isDefined(normalizedTo)) {\n        props.push(normaliseGroupTo([ids[0], ids[1], ids[2]], normalizedTo));\n      }\n    }\n    if (animationEnabled) {\n      props.push(animationValidation(isContinuousX ? [\"xValue\"] : void 0));\n      if (this.processedData) {\n        props.push(diff(this.id, this.processedData));\n      }\n    }\n    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {\n      props,\n      groupByKeys: stacked,\n      groupByData: !stacked\n    });\n    this.dataAggregationFilters = this.aggregateData(dataModel, processedData);\n    this.animationState.transition(\"updateData\");\n  }\n  xCoordinateRange(xValue, pixelSize) {\n    const { marker } = this.properties;\n    const x = this.axes[\"x\" /* X */].scale.convert(xValue);\n    const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;\n    return [x - r, x + r];\n  }\n  yCoordinateRange(yValues, pixelSize) {\n    const { marker } = this.properties;\n    const y = this.axes[\"y\" /* Y */].scale.convert(yValues[0]);\n    const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;\n    return [y - r, y + r];\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!dataModel || !processedData)\n      return [];\n    if (direction === \"x\" /* X */) {\n      const xDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n      const domain = dataModel.getDomain(this, `xValue`, \"value\", processedData);\n      if (xDef?.def.type === \"value\" && xDef.def.valueType === \"category\") {\n        return domain;\n      }\n      return fixNumericExtent(extent(domain));\n    }\n    const yKey = this.dataModel?.hasColumnById(this, `yValueEnd`) ? \"yValueEnd\" : \"yValueRaw\";\n    const yExtent = this.domainForClippedRange(\"y\" /* Y */, [yKey], \"xValue\", true);\n    return fixNumericExtent(yExtent);\n  }\n  getSeriesRange(_direction, visibleRange) {\n    const yKey = this.dataModel?.hasColumnById(this, `yValueEnd`) ? \"yValueEnd\" : \"yValueRaw\";\n    return this.domainForVisibleRange(\"y\" /* Y */, [yKey], \"xValue\", visibleRange, true);\n  }\n  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {\n    const yKey = this.dataModel?.hasColumnById(this, `yValueEnd`) ? \"yValueEnd\" : \"yValueRaw\";\n    return this.countVisibleItems(\"xValue\", [yKey], xVisibleRange, yVisibleRange, minVisibleItems);\n  }\n  aggregateData(_dataModel, _processedData) {\n    return;\n  }\n  createNodeData() {\n    const { dataModel, processedData, axes, dataAggregationFilters } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!dataModel || !processedData || !xAxis || !yAxis)\n      return;\n    const {\n      xKey,\n      yKey,\n      yFilterKey,\n      xName,\n      yName,\n      marker,\n      label,\n      connectMissingData,\n      interpolation,\n      legendItemName\n    } = this.properties;\n    const stacked = this.dataModel?.hasColumnById(this, `yValueEnd`);\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const size = marker.enabled ? marker.size : 0;\n    const rawData = processedData.dataSources.get(this.id) ?? [];\n    const xValues = dataModel.resolveColumnById(this, `xValue`, processedData);\n    const yValues = dataModel.resolveColumnById(this, `yValueRaw`, processedData);\n    const yEndValues = stacked ? dataModel.resolveColumnById(this, `yValueEnd`, processedData) : void 0;\n    const yCumulativeValues = stacked ? dataModel.resolveColumnById(this, `yValueCumulative`, processedData) : yValues;\n    const selectionValues = yFilterKey != null ? dataModel.resolveColumnById(this, `yFilterRaw`, processedData) : void 0;\n    const xPosition = (index) => xScale.convert(xValues[index]) + xOffset;\n    const yPosition = (index) => yScale.convert(yCumulativeValues[index]) + yOffset;\n    const capDefaults = {\n      lengthRatioMultiplier: this.properties.marker.getDiameter(),\n      lengthMax: Infinity\n    };\n    const nodeData = [];\n    let spanPoints;\n    const handleDatum = (datumIndex) => {\n      const datum = rawData[datumIndex];\n      const xDatum = xValues[datumIndex];\n      const yDatum = yValues[datumIndex];\n      const yEndDatum = yEndValues?.[datumIndex];\n      const selected = selectionValues?.[datumIndex];\n      const x = xPosition(datumIndex);\n      const y = yPosition(datumIndex);\n      if (!Number.isFinite(x))\n        return;\n      if (yDatum != null) {\n        const labelText = label.enabled ? this.getLabelText(label, {\n          value: yDatum,\n          datum,\n          xKey,\n          yKey,\n          xName,\n          yName,\n          legendItemName\n        }) : void 0;\n        nodeData.push({\n          series: this,\n          datum,\n          datumIndex,\n          yKey,\n          xKey,\n          point: { x, y, size },\n          midPoint: { x, y },\n          cumulativeValue: yEndDatum,\n          yValue: yDatum,\n          xValue: xDatum,\n          capDefaults,\n          labelText,\n          selected\n        });\n      }\n      if (spanPoints == null)\n        return;\n      const currentSpanPoints = spanPoints[spanPoints.length - 1];\n      if (yDatum != null) {\n        const spanPoint = {\n          point: { x, y },\n          xDatum,\n          yDatum\n        };\n        if (Array.isArray(currentSpanPoints)) {\n          currentSpanPoints.push(spanPoint);\n        } else if (currentSpanPoints != null) {\n          currentSpanPoints.skip += 1;\n          spanPoints.push([spanPoint]);\n        } else {\n          spanPoints.push([spanPoint]);\n        }\n      } else if (!connectMissingData) {\n        if (Array.isArray(currentSpanPoints) || currentSpanPoints == null) {\n          spanPoints.push({ skip: 0 });\n        } else {\n          currentSpanPoints.skip += 1;\n        }\n      }\n    };\n    const [r0, r1] = xScale.range;\n    const range3 = r1 - r0;\n    const dataAggregationFilter = dataAggregationFilters?.find((f) => f.maxRange > range3);\n    const indices = dataAggregationFilter?.indices;\n    let [start2, end2] = this.visibleRange(\"xValue\", xAxis.range, indices);\n    start2 = Math.max(start2 - 1, 0);\n    end2 = Math.min(end2 + 1, indices?.length ?? xValues.length);\n    if (processedData.input.count < 1e3) {\n      start2 = 0;\n      end2 = processedData.input.count;\n    }\n    if (indices == null) {\n      spanPoints = [];\n    }\n    for (let i = start2; i < end2; i += 1) {\n      handleDatum(indices?.[i] ?? i);\n    }\n    const strokeSpans = spanPoints?.flatMap((p) => {\n      return Array.isArray(p) ? interpolatePoints(p, interpolation) : [];\n    });\n    const strokeData = strokeSpans != null ? { itemId: yKey, spans: strokeSpans } : void 0;\n    const crossFiltering = selectionValues?.some((selectionValue, index) => selectionValue === yValues[index]) ?? false;\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      strokeData,\n      scales: this.calculateScaling(),\n      visible: this.visible,\n      crossFiltering\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  updatePathNodes(opts) {\n    const {\n      paths: [lineNode],\n      opacity,\n      visible,\n      animationEnabled\n    } = opts;\n    const crossFiltering = this.contextNodeData?.crossFiltering === true;\n    lineNode.setProperties({\n      fill: void 0,\n      lineJoin: \"round\",\n      pointerEvents: 1 /* None */,\n      opacity,\n      stroke: this.properties.stroke,\n      strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n      strokeOpacity: this.properties.strokeOpacity * (crossFiltering ? CROSS_FILTER_LINE_STROKE_OPACITY_FACTOR : 1),\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset\n    });\n    if (!animationEnabled) {\n      lineNode.visible = visible;\n    }\n    updateClipPath(this, lineNode);\n  }\n  getMarkerItemBaseStyle(highlighted) {\n    const { properties } = this;\n    const { marker } = properties;\n    const highlightStyle = highlighted ? properties.highlightStyle.item : void 0;\n    return {\n      size: marker.size,\n      shape: marker.shape,\n      fill: highlightStyle?.fill ?? marker.fill,\n      fillOpacity: highlightStyle?.fillOpacity ?? marker.fillOpacity,\n      stroke: highlightStyle?.stroke ?? marker.stroke,\n      strokeWidth: highlightStyle?.strokeWidth ?? marker.strokeWidth,\n      strokeOpacity: highlightStyle?.strokeOpacity ?? marker.strokeOpacity,\n      lineDash: highlightStyle?.lineDash ?? marker.lineDash,\n      lineDashOffset: highlightStyle?.lineDashOffset ?? marker.lineDashOffset\n    };\n  }\n  getMarkerItemStyleOverrides(datumId, datum, format, highlighted) {\n    const { id: seriesId, properties } = this;\n    const { xKey, yKey, marker } = properties;\n    const { itemStyler } = marker;\n    if (itemStyler == null)\n      return;\n    return this.cachedDatumCallback(createDatumId(datumId, highlighted ? \"highlight\" : \"node\"), () => {\n      const xDomain = this.getSeriesDomain(\"x\" /* X */);\n      const yDomain = this.getSeriesDomain(\"y\" /* Y */);\n      return itemStyler({\n        seriesId,\n        ...datumStylerProperties(datum, xKey, yKey, xDomain, yDomain),\n        highlighted,\n        ...format\n      });\n    });\n  }\n  updateMarkerSelection(opts) {\n    let { nodeData } = opts;\n    const { markerSelection } = opts;\n    const markersEnabled = this.properties.marker.enabled || this.contextNodeData?.crossFiltering === true;\n    nodeData = markersEnabled ? nodeData : [];\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(nodeData, void 0, (datum) => createDatumId(datum.xValue));\n  }\n  updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, stroke: stroke2, strokeWidth, strokeOpacity, marker, highlightStyle } = this.properties;\n    const xDomain = this.getSeriesDomain(\"x\" /* X */);\n    const yDomain = this.getSeriesDomain(\"y\" /* Y */);\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {\n      stroke: stroke2,\n      strokeWidth,\n      strokeOpacity\n    });\n    const applyTranslation = this.ctx.animationManager.isSkipped();\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(\n        node,\n        marker,\n        { ...datumStylerProperties(datum, xKey, yKey, xDomain, yDomain), highlighted },\n        baseStyle,\n        { applyTranslation, selected: datum.selected }\n      );\n    });\n    if (!highlighted) {\n      marker.markClean();\n    }\n  }\n  updateLabelSelection(opts) {\n    return opts.labelSelection.update(this.isLabelEnabled() ? opts.labelData : []);\n  }\n  updateLabelNodes(opts) {\n    const { enabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;\n    opts.labelSelection.each((text2, datum) => {\n      if (enabled && datum?.labelText) {\n        text2.fontStyle = fontStyle;\n        text2.fontWeight = fontWeight;\n        text2.fontSize = fontSize;\n        text2.fontFamily = fontFamily;\n        text2.textAlign = \"center\";\n        text2.textBaseline = \"bottom\";\n        text2.text = datum.labelText;\n        text2.x = datum.point.x;\n        text2.y = datum.point.y - 10;\n        text2.fill = color;\n        text2.visible = true;\n      } else {\n        text2.visible = false;\n      }\n    });\n  }\n  getTooltipContent(nodeDatum) {\n    const { id: seriesId, dataModel, processedData, axes, properties } = this;\n    const { xKey, xName, yKey, yName, tooltip } = properties;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!dataModel || !processedData || !xAxis || !yAxis) {\n      return;\n    }\n    const { datumIndex } = nodeDatum;\n    const datum = processedData.dataSources.get(this.id)?.[datumIndex];\n    const xValue = dataModel.resolveColumnById(this, `xValue`, processedData)[datumIndex];\n    const yValue = dataModel.resolveColumnById(this, `yValueRaw`, processedData)[datumIndex];\n    if (xValue == null)\n      return;\n    const format = this.getMarkerItemBaseStyle(false);\n    Object.assign(format, this.getMarkerItemStyleOverrides(String(datumIndex), datum, format, false));\n    return tooltip.formatTooltip(\n      {\n        heading: xAxis.formatDatum(xValue),\n        symbol: this.legendItemSymbol(),\n        data: [{ label: yName, fallbackLabel: yKey, value: yAxis.formatDatum(yValue) }]\n      },\n      {\n        seriesId,\n        datum,\n        title: yName,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        ...format,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  legendItemSymbol() {\n    const color0 = \"rgba(0, 0, 0, 0)\";\n    const { stroke: stroke2, strokeOpacity, strokeWidth, lineDash, marker } = this.properties;\n    return {\n      marker: {\n        shape: marker.shape,\n        fill: marker.fill ?? color0,\n        stroke: marker.stroke ?? stroke2 ?? color0,\n        fillOpacity: marker.fillOpacity,\n        strokeOpacity: marker.strokeOpacity,\n        strokeWidth: marker.strokeWidth,\n        lineDash: marker.lineDash,\n        lineDashOffset: marker.lineDashOffset,\n        enabled: marker.enabled\n      },\n      line: {\n        stroke: stroke2 ?? color0,\n        strokeOpacity,\n        strokeWidth,\n        lineDash\n      }\n    };\n  }\n  getLegendData(legendType) {\n    if (!(this.properties.isValid() && legendType === \"category\")) {\n      return [];\n    }\n    const {\n      id: seriesId,\n      ctx: { legendManager },\n      visible\n    } = this;\n    const { yKey: itemId, yName, title, legendItemName, showInLegend } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: seriesId,\n        itemId,\n        legendItemName,\n        seriesId,\n        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),\n        label: {\n          text: legendItemName ?? title ?? yName ?? itemId\n        },\n        symbol: this.legendItemSymbol(),\n        hideInLegend: !showInLegend\n      }\n    ];\n  }\n  updatePaths(opts) {\n    this.updateLinePaths(opts.paths, opts.contextData);\n  }\n  plotNodeDataPoints(path, nodeData) {\n    if (nodeData.length === 0)\n      return;\n    const initialPoint = nodeData[0].point;\n    path.moveTo(initialPoint.x, initialPoint.y);\n    for (let i = 1; i < nodeData.length; i += 1) {\n      const { x, y } = nodeData[i].point;\n      path.lineTo(x, y);\n    }\n  }\n  updateLinePaths(paths, contextData) {\n    const spans = contextData.strokeData?.spans;\n    const [lineNode] = paths;\n    lineNode.path.clear();\n    if (spans != null) {\n      plotLinePathStroke(lineNode, spans);\n    } else {\n      this.plotNodeDataPoints(lineNode.path, contextData.nodeData);\n    }\n    lineNode.markDirty();\n  }\n  animateEmptyUpdateReady(animationData) {\n    const { markerSelection, labelSelection, annotationSelections, contextData, paths } = animationData;\n    const { animationManager } = this.ctx;\n    this.updateLinePaths(paths, contextData);\n    pathSwipeInAnimation(this, animationManager, ...paths);\n    resetMotion([markerSelection], resetMarkerPositionFn);\n    markerSwipeScaleInAnimation(this, animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n  }\n  animateReadyResize(animationData) {\n    const { contextData, paths } = animationData;\n    this.updateLinePaths(paths, contextData);\n    super.animateReadyResize(animationData);\n  }\n  animateWaitingUpdateReady(animationData) {\n    const { animationManager } = this.ctx;\n    const {\n      markerSelection: markerSelections,\n      labelSelection: labelSelections,\n      annotationSelections,\n      contextData,\n      paths,\n      previousContextData\n    } = animationData;\n    const [path] = paths;\n    this.resetMarkerAnimation(animationData);\n    this.resetLabelAnimation(animationData);\n    const update = () => {\n      this.resetPathAnimation(animationData);\n      this.updateLinePaths(paths, contextData);\n    };\n    const skip = () => {\n      animationManager.skipCurrentBatch();\n      update();\n    };\n    if (contextData == null || previousContextData == null) {\n      update();\n      markerFadeInAnimation(this, animationManager, \"added\", markerSelections);\n      pathFadeInAnimation(this, \"path_properties\", animationManager, \"add\", path);\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelections);\n      seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n      return;\n    }\n    if (contextData.crossFiltering !== previousContextData.crossFiltering) {\n      skip();\n      return;\n    }\n    const fns = prepareLinePathAnimation(\n      contextData,\n      previousContextData,\n      this.processedData?.reduced?.diff?.[this.id]\n    );\n    if (fns === void 0) {\n      skip();\n      return;\n    } else if (fns.status === \"no-op\") {\n      return;\n    }\n    fromToMotion(this.id, \"path_properties\", animationManager, [path], fns.stroke.pathProperties);\n    if (fns.status === \"added\") {\n      this.updateLinePaths(paths, contextData);\n    } else if (fns.status === \"removed\") {\n      this.updateLinePaths(paths, previousContextData);\n    } else {\n      pathMotion(this.id, \"path_update\", animationManager, [path], fns.stroke.path);\n    }\n    if (fns.hasMotion) {\n      markerFadeInAnimation(this, animationManager, void 0, markerSelections);\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelections);\n      seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n    }\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  getBandScalePadding() {\n    return { inner: 1, outer: 0.1 };\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey } = this.properties;\n    const xDomain = this.getSeriesDomain(\"x\" /* X */);\n    const yDomain = this.getSeriesDomain(\"y\" /* Y */);\n    return this.getMarkerStyle(this.properties.marker, {\n      ...datumStylerProperties(datum, xKey, yKey, xDomain, yDomain),\n      highlighted: true\n    });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nLineSeries.className = \"LineSeries\";\nLineSeries.type = \"line\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesModule.ts\nvar LineSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"line\",\n  moduleFactory: (ctx) => new LineSeries(ctx),\n  stackable: true,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      tooltip: { position: { type: \"node\" } },\n      strokeWidth: 2,\n      strokeOpacity: 1,\n      lineDash: [0],\n      lineDashOffset: 0,\n      interpolation: {\n        type: \"linear\",\n        tension: 1,\n        position: \"end\"\n      },\n      marker: {\n        shape: \"circle\",\n        size: 7,\n        strokeWidth: 0\n      },\n      label: {\n        enabled: false,\n        fontSize: { $ref: \"fontSize\" },\n        fontFamily: { $ref: \"fontFamily\" },\n        fontWeight: { $ref: \"fontWeight\" },\n        color: { $ref: \"textColor\" }\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 1\n        }\n      }\n    }\n  },\n  paletteFactory: (params) => {\n    const { marker } = markerPaletteFactory(params);\n    return { stroke: marker.fill, marker };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesProperties.ts\nvar ScatterSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"top\";\n  }\n};\n__decorateClass([\n  Validate(LABEL_PLACEMENT)\n], ScatterSeriesLabel.prototype, \"placement\", 2);\nvar ScatterSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.colorRange = [\"#ffff00\", \"#00ff00\", \"#0000ff\"];\n    this.label = new ScatterSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    // No validation. Not a part of the options contract.\n    this.marker = new SeriesMarker();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], ScatterSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], ScatterSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"xFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorDomain\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], ScatterSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.shape\")\n], ScatterSeriesProperties.prototype, \"shape\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.size\")\n], ScatterSeriesProperties.prototype, \"size\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fill\")\n], ScatterSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fillOpacity\")\n], ScatterSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.stroke\")\n], ScatterSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeWidth\")\n], ScatterSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeOpacity\")\n], ScatterSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.lineDash\")\n], ScatterSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.lineDashOffset\")\n], ScatterSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.itemStyler\", { optional: true })\n], ScatterSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ScatterSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ScatterSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeries.ts\nvar ScatterSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [\n        2 /* AXIS_ALIGNED */,\n        1 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      pathsPerSeries: [],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        marker: resetMarkerFn,\n        label: resetLabelFn\n      },\n      usesPlacedLabels: true\n    });\n    this.clipFocusBox = false;\n    this.properties = new ScatterSeriesProperties();\n    this.colorScale = new ColorScale();\n  }\n  get pickModeAxis() {\n    return \"main-category\";\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || this.data == null || !this.visible)\n      return;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const colorScaleType = this.colorScale.type;\n    const { xKey, yKey, xFilterKey, yFilterKey, labelKey, colorKey, colorDomain, colorRange } = this.properties;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        valueProperty(xKey, xScaleType, { id: `xValue` }),\n        valueProperty(yKey, yScaleType, { id: `yValue` }),\n        ...xFilterKey != null ? [valueProperty(xFilterKey, xScaleType, { id: \"xFilterValue\" })] : [],\n        ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: \"yFilterValue\" })] : [],\n        ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],\n        ...labelKey ? [valueProperty(labelKey, \"band\", { id: `labelValue` })] : []\n      ]\n    });\n    if (colorKey) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);\n      this.colorScale.domain = colorDomain ?? processedData.domain.values[colorKeyIdx] ?? [];\n      this.colorScale.range = colorRange;\n      this.colorScale.update();\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  xCoordinateRange(xValue, pixelSize) {\n    const x = this.axes[\"x\" /* X */].scale.convert(xValue);\n    const r = 0.5 * this.properties.size * pixelSize;\n    return [x - r, x + r];\n  }\n  yCoordinateRange(yValues, pixelSize) {\n    const y = this.axes[\"y\" /* Y */].scale.convert(yValues[0]);\n    const r = 0.5 * this.properties.size * pixelSize;\n    return [y - r, y + r];\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!processedData || !dataModel)\n      return [];\n    const dataValues = {\n      [\"x\" /* X */]: \"xValue\",\n      [\"y\" /* Y */]: \"yValue\"\n    };\n    const id = dataValues[direction];\n    const dataDef = dataModel.resolveProcessedDataDefById(this, id);\n    const domain = dataModel.getDomain(this, id, \"value\", processedData);\n    if (dataDef?.def.type === \"value\" && dataDef?.def.valueType === \"category\") {\n      return domain;\n    }\n    const crossDirection = direction === \"x\" /* X */ ? \"y\" /* Y */ : \"x\" /* X */;\n    const crossId = dataValues[crossDirection];\n    const ext = this.domainForClippedRange(direction, [id], crossId, false);\n    return fixNumericExtent(extent(ext));\n  }\n  getSeriesRange(_direction, visibleRange) {\n    return this.domainForVisibleRange(\"y\" /* Y */, [\"yValue\"], \"xValue\", visibleRange, false);\n  }\n  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {\n    return this.countVisibleItems(\"xValue\", [\"yValue\"], xVisibleRange, yVisibleRange, minVisibleItems);\n  }\n  createNodeData() {\n    const { axes, dataModel, processedData, colorScale, visible } = this;\n    const { xKey, yKey, xFilterKey, yFilterKey, labelKey, colorKey, xName, yName, labelName, marker, label } = this.properties;\n    const { placement } = label;\n    const anchor = Marker.anchor(marker.shape);\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!(dataModel && processedData && visible && xAxis && yAxis))\n      return;\n    const xDataValues = dataModel.resolveColumnById(this, `xValue`, processedData);\n    const yDataValues = dataModel.resolveColumnById(this, `yValue`, processedData);\n    const colorDataValues = colorKey != null ? dataModel.resolveColumnById(this, `colorValue`, processedData) : void 0;\n    const labelDataValues = labelKey != null ? dataModel.resolveColumnById(this, `labelValue`, processedData) : void 0;\n    const xFilterDataValues = xFilterKey != null ? dataModel.resolveColumnById(this, `xFilterValue`, processedData) : void 0;\n    const yFilterDataValues = yFilterKey != null ? dataModel.resolveColumnById(this, `yFilterValue`, processedData) : void 0;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    const font2 = label.getFont();\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font: font2 });\n    const rawData = processedData.dataSources.get(this.id) ?? [];\n    rawData.forEach((datum, datumIndex) => {\n      const xDatum = xDataValues[datumIndex];\n      const yDatum = yDataValues[datumIndex];\n      const x = xScale.convert(xDatum) + xOffset;\n      const y = yScale.convert(yDatum) + yOffset;\n      const selected = xFilterDataValues != null && yFilterDataValues != null ? xFilterDataValues[datumIndex] === xDatum && yFilterDataValues[datumIndex] === yDatum : void 0;\n      const labelText = this.getLabelText(label, {\n        value: labelDataValues != null ? labelDataValues?.[datumIndex] : yDatum,\n        datum,\n        xKey,\n        yKey,\n        labelKey,\n        xName,\n        yName,\n        labelName\n      });\n      const size = textMeasurer.measureText(labelText);\n      const fill = colorDataValues != null ? colorScale.convert(colorDataValues[datumIndex]) : void 0;\n      nodeData.push({\n        series: this,\n        itemId: yKey,\n        yKey,\n        xKey,\n        datum,\n        datumIndex,\n        xValue: xDatum,\n        yValue: yDatum,\n        capDefaults: { lengthRatioMultiplier: marker.getDiameter(), lengthMax: Infinity },\n        point: { x, y, size: marker.size },\n        midPoint: { x, y },\n        fill,\n        label: { text: labelText, ...size },\n        anchor,\n        placement,\n        selected\n      });\n    });\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  getLabelData() {\n    if (!this.isLabelEnabled())\n      return [];\n    return this.contextNodeData?.labelData ?? [];\n  }\n  updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(this.properties.marker.enabled ? nodeData : []);\n  }\n  getMarkerItemBaseStyle(highlighted) {\n    const { properties } = this;\n    const { marker } = properties;\n    const highlightStyle = highlighted ? properties.highlightStyle.item : void 0;\n    return {\n      fill: highlightStyle?.fill ?? marker.fill,\n      fillOpacity: highlightStyle?.fillOpacity ?? marker.fillOpacity,\n      stroke: highlightStyle?.stroke ?? marker.stroke,\n      strokeWidth: highlightStyle?.strokeWidth ?? marker.strokeWidth,\n      strokeOpacity: highlightStyle?.strokeOpacity ?? marker.strokeOpacity,\n      lineDash: highlightStyle?.lineDash ?? marker.lineDash,\n      lineDashOffset: highlightStyle?.lineDashOffset ?? marker.lineDashOffset\n    };\n  }\n  getMarkerItemStyleOverrides(datumId, datum, format, highlighted) {\n    const { id: seriesId, properties } = this;\n    const { xKey, yKey, labelKey, marker } = properties;\n    const { itemStyler } = marker;\n    if (itemStyler == null)\n      return;\n    return this.cachedDatumCallback(createDatumId(datumId, highlighted ? \"highlight\" : \"node\"), () => {\n      return itemStyler({\n        seriesId,\n        datum,\n        xKey,\n        yKey,\n        labelKey,\n        highlighted,\n        ...format\n      });\n    });\n  }\n  updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, labelKey, marker, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle());\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, labelKey }, baseStyle, {\n        selected: datum.selected\n      });\n    });\n    if (!highlighted) {\n      marker.markClean();\n    }\n  }\n  updatePlacedLabelData(labelData) {\n    this.labelSelection.update(\n      labelData.map((v) => ({\n        ...v.datum,\n        point: {\n          x: v.x,\n          y: v.y,\n          size: v.datum.point.size\n        }\n      })),\n      (text2) => {\n        text2.pointerEvents = 1 /* None */;\n      }\n    );\n    this.updateLabelNodes({ labelSelection: this.labelSelection });\n  }\n  updateLabelNodes(opts) {\n    const { label } = this.properties;\n    opts.labelSelection.each((text2, datum) => {\n      text2.text = datum.label.text;\n      text2.fill = label.color;\n      text2.x = datum.point?.x ?? 0;\n      text2.y = datum.point?.y ?? 0;\n      text2.fontStyle = label.fontStyle;\n      text2.fontWeight = label.fontWeight;\n      text2.fontSize = label.fontSize;\n      text2.fontFamily = label.fontFamily;\n      text2.textAlign = \"left\";\n      text2.textBaseline = \"top\";\n    });\n  }\n  getTooltipContent(nodeDatum) {\n    const { id: seriesId, dataModel, processedData, axes, properties } = this;\n    const { xKey, xName, yKey, yName, labelKey, labelName, title, tooltip } = properties;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!dataModel || !processedData || !xAxis || !yAxis) {\n      return;\n    }\n    const { datumIndex } = nodeDatum;\n    const datum = processedData.dataSources.get(this.id)?.[datumIndex];\n    const xValue = dataModel.resolveColumnById(this, `xValue`, processedData)[datumIndex];\n    const yValue = dataModel.resolveColumnById(this, `yValue`, processedData)[datumIndex];\n    if (xValue == null)\n      return;\n    const format = this.getMarkerItemBaseStyle(false);\n    Object.assign(format, this.getMarkerItemStyleOverrides(String(datumIndex), datum, format, false));\n    return tooltip.formatTooltip(\n      {\n        symbol: this.legendItemSymbol(),\n        title,\n        data: [\n          { label: xName, fallbackLabel: xKey, value: xAxis.formatDatum(xValue) },\n          { label: yName, fallbackLabel: yKey, value: yAxis.formatDatum(yValue) }\n        ]\n      },\n      {\n        seriesId,\n        datum,\n        title: yName,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        labelKey,\n        labelName,\n        ...format,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  legendItemSymbol() {\n    const { shape, fill, stroke: stroke2, fillOpacity, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = this.properties.marker;\n    return {\n      marker: {\n        shape,\n        fill: fill ?? \"rgba(0, 0, 0, 0)\",\n        stroke: stroke2 ?? \"rgba(0, 0, 0, 0)\",\n        fillOpacity,\n        strokeOpacity,\n        strokeWidth,\n        lineDash,\n        lineDashOffset\n      }\n    };\n  }\n  getLegendData(legendType) {\n    if (!this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    const { yKey: itemId, yName, title, showInLegend } = this.properties;\n    const {\n      id: seriesId,\n      ctx: { legendManager },\n      visible\n    } = this;\n    return [\n      {\n        legendType: \"category\",\n        id: seriesId,\n        itemId,\n        seriesId,\n        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),\n        label: {\n          text: title ?? yName ?? itemId\n        },\n        symbol: this.legendItemSymbol(),\n        hideInLegend: !showInLegend\n      }\n    ];\n  }\n  animateEmptyUpdateReady(data) {\n    const { markerSelection, labelSelection, annotationSelections } = data;\n    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey, labelKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, labelKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nScatterSeries.className = \"ScatterSeries\";\nScatterSeries.type = \"scatter\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesModule.ts\nvar ScatterSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"scatter\",\n  moduleFactory: (ctx) => new ScatterSeries(ctx),\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      shape: \"circle\",\n      size: 7,\n      fillOpacity: 0.8,\n      tooltip: { position: { type: \"node\" } },\n      label: {\n        enabled: false,\n        fontSize: { $ref: \"fontSize\" },\n        fontFamily: { $ref: \"fontFamily\" },\n        fontWeight: { $ref: \"fontWeight\" },\n        color: { $ref: \"textColor\" }\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 1\n        }\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/scene/sectorBox.ts\nvar SectorBox = class _SectorBox {\n  constructor(startAngle, endAngle, innerRadius, outerRadius) {\n    this.startAngle = startAngle;\n    this.endAngle = endAngle;\n    this.innerRadius = innerRadius;\n    this.outerRadius = outerRadius;\n  }\n  clone() {\n    const { startAngle, endAngle, innerRadius, outerRadius } = this;\n    return new _SectorBox(startAngle, endAngle, innerRadius, outerRadius);\n  }\n  equals(other) {\n    return this.startAngle === other.startAngle && this.endAngle === other.endAngle && this.innerRadius === other.innerRadius && this.outerRadius === other.outerRadius;\n  }\n  [interpolate](other, d) {\n    return new _SectorBox(\n      this.startAngle * (1 - d) + other.startAngle * d,\n      this.endAngle * (1 - d) + other.endAngle * d,\n      this.innerRadius * (1 - d) + other.innerRadius * d,\n      this.outerRadius * (1 - d) + other.outerRadius * d\n    );\n  }\n};\n\n// packages/ag-charts-community/src/scene/util/sector.ts\nfunction sectorBox({ startAngle, endAngle, innerRadius, outerRadius }) {\n  let x0 = Infinity;\n  let y0 = Infinity;\n  let x1 = -Infinity;\n  let y1 = -Infinity;\n  const addPoint = (x, y) => {\n    x0 = Math.min(x, x0);\n    y0 = Math.min(y, y0);\n    x1 = Math.max(x, x1);\n    y1 = Math.max(y, y1);\n  };\n  addPoint(innerRadius * Math.cos(startAngle), innerRadius * Math.sin(startAngle));\n  addPoint(innerRadius * Math.cos(endAngle), innerRadius * Math.sin(endAngle));\n  addPoint(outerRadius * Math.cos(startAngle), outerRadius * Math.sin(startAngle));\n  addPoint(outerRadius * Math.cos(endAngle), outerRadius * Math.sin(endAngle));\n  if (isBetweenAngles(0, startAngle, endAngle)) {\n    addPoint(outerRadius, 0);\n  }\n  if (isBetweenAngles(Math.PI * 0.5, startAngle, endAngle)) {\n    addPoint(0, outerRadius);\n  }\n  if (isBetweenAngles(Math.PI, startAngle, endAngle)) {\n    addPoint(-outerRadius, 0);\n  }\n  if (isBetweenAngles(Math.PI * 1.5, startAngle, endAngle)) {\n    addPoint(0, -outerRadius);\n  }\n  return new BBox(x0, y0, x1 - x0, y1 - y0);\n}\nfunction isPointInSector(x, y, sector) {\n  const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n  const { innerRadius, outerRadius } = sector;\n  if (sector.startAngle === sector.endAngle || radius < Math.min(innerRadius, outerRadius) || radius > Math.max(innerRadius, outerRadius)) {\n    return false;\n  }\n  const startAngle = normalizeAngle180(sector.startAngle);\n  const endAngle = normalizeAngle180(sector.endAngle);\n  const angle2 = Math.atan2(y, x);\n  return startAngle < endAngle ? angle2 <= endAngle && angle2 >= startAngle : angle2 <= endAngle && angle2 >= -Math.PI || angle2 >= startAngle && angle2 <= Math.PI;\n}\nfunction lineCollidesSector(line, sector) {\n  const { startAngle, endAngle, innerRadius, outerRadius } = sector;\n  const outerStart = { x: outerRadius * Math.cos(startAngle), y: outerRadius * Math.sin(startAngle) };\n  const outerEnd = { x: outerRadius * Math.cos(endAngle), y: outerRadius * Math.sin(endAngle) };\n  const innerStart = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(startAngle), y: innerRadius * Math.sin(startAngle) };\n  const innerEnd = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(endAngle), y: innerRadius * Math.sin(endAngle) };\n  return segmentIntersection(\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y,\n    outerStart.x,\n    outerStart.y,\n    innerStart.x,\n    innerStart.y\n  ) || segmentIntersection(\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y,\n    outerEnd.x,\n    outerEnd.y,\n    innerEnd.x,\n    innerEnd.y\n  ) || arcIntersections(\n    0,\n    0,\n    outerRadius,\n    startAngle,\n    endAngle,\n    true,\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y\n  );\n}\nfunction boxCollidesSector(box, sector) {\n  const topLeft = { x: box.x, y: box.y };\n  const topRight = { x: box.x + box.width, y: box.y };\n  const bottomLeft = { x: box.x, y: box.y + box.height };\n  const bottomRight = { x: box.x + box.width, y: box.y + box.height };\n  return lineCollidesSector({ start: topLeft, end: topRight }, sector) || lineCollidesSector({ start: bottomLeft, end: bottomRight }, sector);\n}\nfunction radiiScalingFactor(r, sweep, a, b) {\n  if (a === 0 && b === 0)\n    return 0;\n  const fs1 = Math.asin(Math.abs(1 * a) / (r + 1 * a)) + Math.asin(Math.abs(1 * b) / (r + 1 * b)) - sweep;\n  if (fs1 < 0)\n    return 1;\n  let start2 = 0;\n  let end2 = 1;\n  for (let i = 0; i < 8; i += 1) {\n    const s = (start2 + end2) / 2;\n    const fs = Math.asin(Math.abs(s * a) / (r + s * a)) + Math.asin(Math.abs(s * b) / (r + s * b)) - sweep;\n    if (fs < 0) {\n      start2 = s;\n    } else {\n      end2 = s;\n    }\n  }\n  return start2;\n}\nvar delta2 = 1e-6;\nfunction clockwiseAngle(angle2, relativeToStartAngle) {\n  if (angleBetween(angle2, relativeToStartAngle) < delta2) {\n    return relativeToStartAngle;\n  } else {\n    return normalizeAngle360(angle2 - relativeToStartAngle) + relativeToStartAngle;\n  }\n}\nfunction clockwiseAngles(startAngle, endAngle, relativeToStartAngle = 0) {\n  const fullPie = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n  const sweepAngle = fullPie ? 2 * Math.PI : normalizeAngle360(endAngle - startAngle);\n  startAngle = clockwiseAngle(startAngle, relativeToStartAngle);\n  endAngle = startAngle + sweepAngle;\n  return { startAngle, endAngle };\n}\nfunction arcRadialLineIntersectionAngle(cx, cy, r, startAngle, endAngle, clipAngle) {\n  const sinA = Math.sin(clipAngle);\n  const cosA = Math.cos(clipAngle);\n  const c = cx ** 2 + cy ** 2 - r ** 2;\n  let p0x;\n  let p0y;\n  let p1x;\n  let p1y;\n  if (cosA > 0.5) {\n    const tanA = sinA / cosA;\n    const a = 1 + tanA ** 2;\n    const b = -2 * (cx + cy * tanA);\n    const d = b ** 2 - 4 * a * c;\n    if (d < 0)\n      return;\n    const x0 = (-b + Math.sqrt(d)) / (2 * a);\n    const x1 = (-b - Math.sqrt(d)) / (2 * a);\n    p0x = x0;\n    p0y = x0 * tanA;\n    p1x = x1;\n    p1y = x1 * tanA;\n  } else {\n    const cotA = cosA / sinA;\n    const a = 1 + cotA ** 2;\n    const b = -2 * (cy + cx * cotA);\n    const d = b ** 2 - 4 * a * c;\n    if (d < 0)\n      return;\n    const y0 = (-b + Math.sqrt(d)) / (2 * a);\n    const y1 = (-b - Math.sqrt(d)) / (2 * a);\n    p0x = y0 * cotA;\n    p0y = y0;\n    p1x = y1 * cotA;\n    p1y = y1;\n  }\n  const normalisedX = cosA;\n  const normalisedY = sinA;\n  const p0DotNormalized = p0x * normalisedX + p0y * normalisedY;\n  const p1DotNormalized = p1x * normalisedX + p1y * normalisedY;\n  const a0 = p0DotNormalized > 0 ? clockwiseAngle(Math.atan2(p0y - cy, p0x - cx), startAngle) : NaN;\n  const a1 = p1DotNormalized > 0 ? clockwiseAngle(Math.atan2(p1y - cy, p1x - cx), startAngle) : NaN;\n  if (a0 >= startAngle && a0 <= endAngle) {\n    return a0;\n  } else if (a1 >= startAngle && a1 <= endAngle) {\n    return a1;\n  }\n}\nfunction arcCircleIntersectionAngle(cx, cy, r, startAngle, endAngle, circleR) {\n  const d = Math.hypot(cx, cy);\n  const d1 = (d ** 2 - r ** 2 + circleR ** 2) / (2 * d);\n  const d2 = d - d1;\n  const theta = Math.atan2(cy, cx);\n  const deltaTheta = Math.acos(-d2 / r);\n  const a0 = clockwiseAngle(theta + deltaTheta, startAngle);\n  const a1 = clockwiseAngle(theta - deltaTheta, startAngle);\n  if (a0 >= startAngle && a0 <= endAngle) {\n    return a0;\n  } else if (a1 >= startAngle && a1 <= endAngle) {\n    return a1;\n  }\n}\n\n// packages/ag-charts-community/src/scene/shape/sector.ts\nvar Arc = class {\n  constructor(cx, cy, r, a0, a1) {\n    this.cx = cx;\n    this.cy = cy;\n    this.r = r;\n    this.a0 = a0;\n    this.a1 = a1;\n    if (this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n  isValid() {\n    return Number.isFinite(this.a0) && Number.isFinite(this.a1);\n  }\n  pointAt(a) {\n    return {\n      x: this.cx + this.r * Math.cos(a),\n      y: this.cy + this.r * Math.sin(a)\n    };\n  }\n  clipStart(a) {\n    if (a == null || !this.isValid() || a < this.a0)\n      return;\n    this.a0 = a;\n    if (Number.isNaN(a) || this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n  clipEnd(a) {\n    if (a == null || !this.isValid() || a > this.a1)\n      return;\n    this.a1 = a;\n    if (Number.isNaN(a) || this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n};\nvar Sector = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.centerX = 0;\n    this.centerY = 0;\n    this.innerRadius = 10;\n    this.outerRadius = 20;\n    this.startAngle = 0;\n    this.endAngle = Math.PI * 2;\n    this.clipSector = void 0;\n    this.concentricEdgeInset = 0;\n    this.radialEdgeInset = 0;\n    this.startOuterCornerRadius = 0;\n    this.endOuterCornerRadius = 0;\n    this.startInnerCornerRadius = 0;\n    this.endInnerCornerRadius = 0;\n  }\n  set inset(value) {\n    this.concentricEdgeInset = value;\n    this.radialEdgeInset = value;\n  }\n  set cornerRadius(value) {\n    this.startOuterCornerRadius = value;\n    this.endOuterCornerRadius = value;\n    this.startInnerCornerRadius = value;\n    this.endInnerCornerRadius = value;\n  }\n  computeBBox() {\n    return sectorBox(this).translate(this.centerX, this.centerY);\n  }\n  normalizedRadii() {\n    const { concentricEdgeInset } = this;\n    let { innerRadius, outerRadius } = this;\n    innerRadius = innerRadius > 0 ? innerRadius + concentricEdgeInset : 0;\n    outerRadius = Math.max(outerRadius - concentricEdgeInset, 0);\n    return { innerRadius, outerRadius };\n  }\n  normalizedClipSector() {\n    const { clipSector } = this;\n    if (clipSector == null)\n      return;\n    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipAngles = clockwiseAngles(clipSector.startAngle, clipSector.endAngle, startAngle);\n    return new SectorBox(\n      Math.max(startAngle, clipAngles.startAngle),\n      Math.min(endAngle, clipAngles.endAngle),\n      Math.max(innerRadius, clipSector.innerRadius),\n      Math.min(outerRadius, clipSector.outerRadius)\n    );\n  }\n  getAngleOffset(radius) {\n    return radius > 0 ? this.radialEdgeInset / radius : 0;\n  }\n  arc(r, angleSweep, a0, a1, outerArc, innerArc, start2, inner) {\n    if (r <= 0)\n      return;\n    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipSector = this.normalizedClipSector();\n    if (inner && innerRadius <= 0)\n      return;\n    const angleOffset = inner ? this.getAngleOffset(innerRadius + r) : this.getAngleOffset(outerRadius - r);\n    const angle2 = start2 ? startAngle + angleOffset + angleSweep : endAngle - angleOffset - angleSweep;\n    const radius = inner ? innerRadius + r : outerRadius - r;\n    const cx = radius * Math.cos(angle2);\n    const cy = radius * Math.sin(angle2);\n    if (clipSector != null) {\n      const delta3 = 1e-6;\n      if (!start2 && !(angle2 >= startAngle - delta3 && angle2 <= clipSector.endAngle - delta3))\n        return;\n      if (start2 && !(angle2 >= clipSector.startAngle + delta3 && angle2 <= endAngle - delta3))\n        return;\n      if (inner && radius < clipSector.innerRadius - delta3)\n        return;\n      if (!inner && radius > clipSector.outerRadius + delta3)\n        return;\n    }\n    const arc = new Arc(cx, cy, r, a0, a1);\n    if (clipSector != null) {\n      if (inner) {\n        arc.clipStart(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle));\n        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle));\n      } else {\n        arc.clipStart(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle));\n        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle));\n      }\n      let circleClipStart;\n      let circleClipEnd;\n      if (start2) {\n        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);\n        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);\n      } else {\n        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);\n        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);\n      }\n      arc.clipStart(circleClipStart);\n      arc.clipEnd(circleClipEnd);\n      if (circleClipStart != null) {\n        const { x: x2, y: y2 } = arc.pointAt(circleClipStart);\n        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);\n        if (start2) {\n          innerArc?.clipStart(theta2);\n        } else {\n          outerArc.clipEnd(theta2);\n        }\n      }\n      if (circleClipEnd != null) {\n        const { x: x2, y: y2 } = arc.pointAt(circleClipEnd);\n        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);\n        if (start2) {\n          outerArc.clipStart(theta2);\n        } else {\n          innerArc?.clipEnd(theta2);\n        }\n      }\n    }\n    if (clipSector != null) {\n      const { x: x2, y: y2 } = arc.pointAt((arc.a0 + arc.a1) / 2);\n      if (!isPointInSector(x2, y2, clipSector))\n        return;\n    }\n    const { x, y } = arc.pointAt(start2 === inner ? arc.a0 : arc.a1);\n    const theta = clockwiseAngle(Math.atan2(y, x), startAngle);\n    const radialArc = inner ? innerArc : outerArc;\n    if (start2) {\n      radialArc?.clipStart(theta);\n    } else {\n      radialArc?.clipEnd(theta);\n    }\n    return arc;\n  }\n  updatePath() {\n    const delta3 = 1e-6;\n    const { path, centerX, centerY, concentricEdgeInset, radialEdgeInset } = this;\n    let { startOuterCornerRadius, endOuterCornerRadius, startInnerCornerRadius, endInnerCornerRadius } = this;\n    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipSector = this.normalizedClipSector();\n    const sweepAngle = endAngle - startAngle;\n    const fullPie = sweepAngle >= 2 * Math.PI - delta3;\n    path.clear();\n    if (innerRadius === 0 && outerRadius === 0 || innerRadius > outerRadius) {\n      return;\n    } else if ((clipSector?.startAngle ?? startAngle) === (clipSector?.endAngle ?? endAngle)) {\n      return;\n    } else if (fullPie && this.clipSector == null && startOuterCornerRadius === 0 && endOuterCornerRadius === 0 && startInnerCornerRadius === 0 && endInnerCornerRadius === 0) {\n      path.moveTo(centerX + outerRadius * Math.cos(startAngle), centerY + outerRadius * Math.sin(startAngle));\n      path.arc(centerX, centerY, outerRadius, startAngle, endAngle);\n      if (innerRadius > concentricEdgeInset) {\n        path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));\n        path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);\n      }\n      path.closePath();\n      return;\n    } else if (this.clipSector == null && Math.abs(innerRadius - outerRadius) < 1e-6) {\n      path.arc(centerX, centerY, outerRadius, startAngle, endAngle, false);\n      path.arc(centerX, centerY, outerRadius, endAngle, startAngle, true);\n      path.closePath();\n      return;\n    }\n    const innerAngleOffset = this.getAngleOffset(innerRadius);\n    const outerAngleOffset = this.getAngleOffset(outerRadius);\n    const outerAngleExceeded = sweepAngle < 2 * outerAngleOffset;\n    if (outerAngleExceeded)\n      return;\n    const hasInnerSweep = (clipSector?.innerRadius ?? innerRadius) > concentricEdgeInset;\n    const innerAngleExceeded = innerRadius < concentricEdgeInset || sweepAngle < 2 * innerAngleOffset;\n    const radialLength = outerRadius - innerRadius;\n    const maxRadialLength = Math.max(\n      startOuterCornerRadius,\n      startInnerCornerRadius,\n      endOuterCornerRadius,\n      endInnerCornerRadius\n    );\n    const initialScalingFactor = maxRadialLength > 0 ? Math.min(radialLength / maxRadialLength, 1) : 1;\n    startOuterCornerRadius *= initialScalingFactor;\n    endOuterCornerRadius *= initialScalingFactor;\n    startInnerCornerRadius *= initialScalingFactor;\n    endInnerCornerRadius *= initialScalingFactor;\n    const outerScalingFactor = radiiScalingFactor(\n      outerRadius,\n      sweepAngle - 2 * outerAngleOffset,\n      -startOuterCornerRadius,\n      -endOuterCornerRadius\n    );\n    startOuterCornerRadius *= outerScalingFactor;\n    endOuterCornerRadius *= outerScalingFactor;\n    if (!innerAngleExceeded && hasInnerSweep) {\n      const innerScalingFactor = radiiScalingFactor(\n        innerRadius,\n        sweepAngle - 2 * innerAngleOffset,\n        startInnerCornerRadius,\n        endInnerCornerRadius\n      );\n      startInnerCornerRadius *= innerScalingFactor;\n      endInnerCornerRadius *= innerScalingFactor;\n    } else {\n      startInnerCornerRadius = 0;\n      endInnerCornerRadius = 0;\n    }\n    const maxCombinedRadialLength = Math.max(\n      startOuterCornerRadius + startInnerCornerRadius,\n      endOuterCornerRadius + endInnerCornerRadius\n    );\n    const edgesScalingFactor = maxCombinedRadialLength > 0 ? Math.min(radialLength / maxCombinedRadialLength, 1) : 1;\n    startOuterCornerRadius *= edgesScalingFactor;\n    endOuterCornerRadius *= edgesScalingFactor;\n    startInnerCornerRadius *= edgesScalingFactor;\n    endInnerCornerRadius *= edgesScalingFactor;\n    let startOuterCornerRadiusAngleSweep = 0;\n    let endOuterCornerRadiusAngleSweep = 0;\n    const startOuterCornerRadiusSweep = startOuterCornerRadius / (outerRadius - startOuterCornerRadius);\n    const endOuterCornerRadiusSweep = endOuterCornerRadius / (outerRadius - endOuterCornerRadius);\n    if (startOuterCornerRadiusSweep >= 0 && startOuterCornerRadiusSweep < 1 - delta3) {\n      startOuterCornerRadiusAngleSweep = Math.asin(startOuterCornerRadiusSweep);\n    } else {\n      startOuterCornerRadiusAngleSweep = sweepAngle / 2;\n      const maxStartOuterCornerRadius = outerRadius / (1 / Math.sin(startOuterCornerRadiusAngleSweep) + 1);\n      startOuterCornerRadius = Math.min(maxStartOuterCornerRadius, startOuterCornerRadius);\n    }\n    if (endOuterCornerRadiusSweep >= 0 && endOuterCornerRadiusSweep < 1 - delta3) {\n      endOuterCornerRadiusAngleSweep = Math.asin(endOuterCornerRadiusSweep);\n    } else {\n      endOuterCornerRadiusAngleSweep = sweepAngle / 2;\n      const maxEndOuterCornerRadius = outerRadius / (1 / Math.sin(endOuterCornerRadiusAngleSweep) + 1);\n      endOuterCornerRadius = Math.min(maxEndOuterCornerRadius, endOuterCornerRadius);\n    }\n    const startInnerCornerRadiusAngleSweep = Math.asin(\n      startInnerCornerRadius / (innerRadius + startInnerCornerRadius)\n    );\n    const endInnerCornerRadiusAngleSweep = Math.asin(endInnerCornerRadius / (innerRadius + endInnerCornerRadius));\n    const outerArcRadius = clipSector?.outerRadius ?? outerRadius;\n    const outerArcRadiusOffset = this.getAngleOffset(outerArcRadius);\n    const outerArc = new Arc(\n      0,\n      0,\n      outerArcRadius,\n      startAngle + outerArcRadiusOffset,\n      endAngle - outerArcRadiusOffset\n    );\n    const innerArcRadius = clipSector?.innerRadius ?? innerRadius;\n    const innerArcRadiusOffset = this.getAngleOffset(innerArcRadius);\n    const innerArc = hasInnerSweep ? new Arc(0, 0, innerArcRadius, startAngle + innerArcRadiusOffset, endAngle - innerArcRadiusOffset) : void 0;\n    if (clipSector != null) {\n      outerArc.clipStart(clipSector.startAngle);\n      outerArc.clipEnd(clipSector.endAngle);\n      innerArc?.clipStart(clipSector.startAngle);\n      innerArc?.clipEnd(clipSector.endAngle);\n    }\n    const startOuterArc = this.arc(\n      startOuterCornerRadius,\n      startOuterCornerRadiusAngleSweep,\n      startAngle - Math.PI * 0.5,\n      startAngle + startOuterCornerRadiusAngleSweep,\n      outerArc,\n      innerArc,\n      true,\n      false\n    );\n    const endOuterArc = this.arc(\n      endOuterCornerRadius,\n      endOuterCornerRadiusAngleSweep,\n      endAngle - endOuterCornerRadiusAngleSweep,\n      endAngle + Math.PI * 0.5,\n      outerArc,\n      innerArc,\n      false,\n      false\n    );\n    const endInnerArc = this.arc(\n      endInnerCornerRadius,\n      endInnerCornerRadiusAngleSweep,\n      endAngle + Math.PI * 0.5,\n      endAngle + Math.PI - endInnerCornerRadiusAngleSweep,\n      outerArc,\n      innerArc,\n      false,\n      true\n    );\n    const startInnerArc = this.arc(\n      startInnerCornerRadius,\n      startInnerCornerRadiusAngleSweep,\n      startAngle + Math.PI + startInnerCornerRadiusAngleSweep,\n      startAngle + Math.PI * 1.5,\n      outerArc,\n      innerArc,\n      true,\n      true\n    );\n    if (innerAngleExceeded) {\n      const x = sweepAngle < Math.PI * 0.5 ? radialEdgeInset * (1 + Math.cos(sweepAngle)) / Math.sin(sweepAngle) : NaN;\n      let r;\n      if (x > 0 && x < outerRadius) {\n        r = Math.max(Math.hypot(radialEdgeInset, x), innerRadius);\n      } else {\n        r = radialEdgeInset;\n      }\n      r = Math.max(r, innerRadius);\n      const midAngle = startAngle + sweepAngle * 0.5;\n      path.moveTo(centerX + r * Math.cos(midAngle), centerY + r * Math.sin(midAngle));\n    } else if (startInnerArc?.isValid() === true || innerArc?.isValid() === true) {\n    } else {\n      const midAngle = startAngle + sweepAngle / 2;\n      const cx = innerRadius * Math.cos(midAngle);\n      const cy = innerRadius * Math.sin(midAngle);\n      path.moveTo(centerX + cx, centerY + cy);\n    }\n    if (startOuterArc?.isValid() === true) {\n      const { cx, cy, r, a0, a1 } = startOuterArc;\n      path.arc(centerX + cx, centerY + cy, r, a0, a1);\n    }\n    if (outerArc.isValid()) {\n      const { r, a0, a1 } = outerArc;\n      path.arc(centerX, centerY, r, a0, a1);\n    }\n    if (endOuterArc?.isValid() === true) {\n      const { cx, cy, r, a0, a1 } = endOuterArc;\n      path.arc(centerX + cx, centerY + cy, r, a0, a1);\n    }\n    if (!innerAngleExceeded) {\n      if (endInnerArc?.isValid() === true) {\n        const { cx, cy, r, a0, a1 } = endInnerArc;\n        path.arc(centerX + cx, centerY + cy, r, a0, a1);\n      }\n      if (innerArc?.isValid() === true) {\n        const { r, a0, a1 } = innerArc;\n        path.arc(centerX, centerY, r, a1, a0, true);\n      }\n      if (startInnerArc?.isValid() === true) {\n        const { cx, cy, r, a0, a1 } = startInnerArc;\n        path.arc(centerX + cx, centerY + cy, r, a0, a1);\n      }\n    }\n    path.closePath();\n  }\n  isPointInPath(x, y) {\n    const { startAngle, endAngle, innerRadius, outerRadius } = this.clipSector ?? this;\n    return isPointInSector(x - this.centerX, y - this.centerY, {\n      startAngle,\n      endAngle,\n      innerRadius: Math.min(innerRadius, outerRadius),\n      outerRadius: Math.max(innerRadius, outerRadius)\n    });\n  }\n};\nSector.className = \"Sector\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"centerX\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"centerY\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"innerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"outerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"clipSector\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"concentricEdgeInset\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"radialEdgeInset\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startOuterCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endOuterCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startInnerCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endInnerCornerRadius\", 2);\n\n// packages/ag-charts-community/src/chart/themes/defaultColors.ts\nvar DEFAULT_FILLS = {\n  BLUE: \"#5090dc\",\n  ORANGE: \"#ffa03a\",\n  GREEN: \"#459d55\",\n  CYAN: \"#34bfe1\",\n  YELLOW: \"#e1cc00\",\n  VIOLET: \"#9669cb\",\n  GRAY: \"#b5b5b5\",\n  MAGENTA: \"#bd5aa7\",\n  BROWN: \"#8a6224\",\n  RED: \"#ef5452\"\n};\nvar DEFAULT_STROKES = {\n  BLUE: \"#2b5c95\",\n  ORANGE: \"#cc6f10\",\n  GREEN: \"#1e652e\",\n  CYAN: \"#18859e\",\n  YELLOW: \"#a69400\",\n  VIOLET: \"#603c88\",\n  GRAY: \"#575757\",\n  MAGENTA: \"#7d2f6d\",\n  BROWN: \"#4f3508\",\n  RED: \"#a82529\"\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeriesProperties.ts\nvar DonutTitle = class extends Caption {\n  constructor() {\n    super(...arguments);\n    this.showInLegend = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], DonutTitle.prototype, \"showInLegend\", 2);\nvar DonutInnerLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.spacing = 2;\n  }\n  set(properties, _reset) {\n    return super.set(properties);\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], DonutInnerLabel.prototype, \"text\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutInnerLabel.prototype, \"spacing\", 2);\nvar DonutInnerCircle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"transparent\";\n    this.fillOpacity = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING)\n], DonutInnerCircle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutInnerCircle.prototype, \"fillOpacity\", 2);\nvar DonutSeriesCalloutLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.offset = 3;\n    this.minAngle = 0;\n    this.minSpacing = 4;\n    this.maxCollisionOffset = 50;\n    this.avoidCollisions = true;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"offset\", 2);\n__decorateClass([\n  Validate(NUMBER.restrict({ min: 0, max: 360 }))\n], DonutSeriesCalloutLabel.prototype, \"minAngle\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"maxCollisionOffset\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], DonutSeriesCalloutLabel.prototype, \"avoidCollisions\", 2);\nvar DonutSeriesSectorLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.positionOffset = 0;\n    this.positionRatio = 0.5;\n  }\n};\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesSectorLabel.prototype, \"positionOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesSectorLabel.prototype, \"positionRatio\", 2);\nvar DonutSeriesCalloutLine = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.length = 10;\n    this.strokeWidth = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], DonutSeriesCalloutLine.prototype, \"colors\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLine.prototype, \"length\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLine.prototype, \"strokeWidth\", 2);\nvar DonutSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.rotation = 0;\n    this.outerRadiusOffset = 0;\n    this.outerRadiusRatio = 1;\n    this.strokeWidth = 1;\n    this.sectorSpacing = 0;\n    this.hideZeroValueSectorsInLegend = false;\n    this.innerLabels = new PropertiesArray(DonutInnerLabel);\n    this.title = new DonutTitle();\n    this.innerCircle = new DonutInnerCircle();\n    this.shadow = new DropShadow();\n    this.calloutLabel = new DonutSeriesCalloutLabel();\n    this.sectorLabel = new DonutSeriesSectorLabel();\n    this.calloutLine = new DonutSeriesCalloutLine();\n    this.tooltip = new SeriesTooltip();\n  }\n  isValid() {\n    const superIsValid = super.isValid();\n    if (this.innerRadiusRatio == null && this.innerRadiusOffset == null) {\n      logger_exports.warnOnce(\n        \"Either an [innerRadiusRatio] or an [innerRadiusOffset] must be set to render a donut series.\"\n      );\n      return false;\n    }\n    return superIsValid;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], DonutSeriesProperties.prototype, \"angleKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"angleName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"angleFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusMin\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusMax\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"calloutLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"calloutLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"sectorLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"sectorLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"legendItemKey\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], DonutSeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], DonutSeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], DonutSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], DonutSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesProperties.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesProperties.prototype, \"outerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"outerRadiusRatio\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"innerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], DonutSeriesProperties.prototype, \"innerRadiusRatio\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesProperties.prototype, \"sectorSpacing\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], DonutSeriesProperties.prototype, \"hideZeroValueSectorsInLegend\", 2);\n__decorateClass([\n  Validate(OBJECT_ARRAY)\n], DonutSeriesProperties.prototype, \"innerLabels\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"innerCircle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"calloutLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"sectorLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"calloutLine\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/polar/pieUtil.ts\nfunction preparePieSeriesAnimationFunctions(initialLoad, rotationDegrees, scaleFn, oldScaleFn) {\n  const scale2 = [scaleFn.convert(0), scaleFn.convert(1)];\n  const oldScale = [oldScaleFn.convert(0), oldScaleFn.convert(1)];\n  const rotation = Math.PI / -2 + toRadians(rotationDegrees);\n  const phase = initialLoad ? \"initial\" : \"update\";\n  const scaleToNewRadius = ({ radius }) => {\n    return { innerRadius: scale2[0], outerRadius: scale2[0] + (scale2[1] - scale2[0]) * radius };\n  };\n  const scaleToOldRadius = ({ radius }) => {\n    return { innerRadius: oldScale[0], outerRadius: oldScale[0] + (oldScale[1] - oldScale[0]) * radius };\n  };\n  const fromFn = (sect, datum, status, { prevFromProps }) => {\n    let { startAngle, endAngle, innerRadius, outerRadius } = sect;\n    let { fill, stroke: stroke2 } = datum.sectorFormat;\n    if (status === \"unknown\" || status === \"added\" && !prevFromProps) {\n      startAngle = rotation;\n      endAngle = rotation;\n      innerRadius = datum.innerRadius;\n      outerRadius = datum.outerRadius;\n    } else if (status === \"added\" && prevFromProps) {\n      startAngle = prevFromProps.endAngle ?? rotation;\n      endAngle = prevFromProps.endAngle ?? rotation;\n      innerRadius = prevFromProps.innerRadius ?? datum.innerRadius;\n      outerRadius = prevFromProps.outerRadius ?? datum.outerRadius;\n    }\n    if (status === \"added\" && !initialLoad) {\n      const radii = scaleToOldRadius(datum);\n      innerRadius = radii.innerRadius;\n      outerRadius = radii.outerRadius;\n    }\n    if (status === \"updated\") {\n      fill = sect.fill ?? fill;\n      stroke2 = (typeof sect.stroke === \"string\" ? sect.stroke : void 0) ?? stroke2;\n    }\n    return { startAngle, endAngle, innerRadius, outerRadius, fill, stroke: stroke2, phase };\n  };\n  const toFn = (_sect, datum, status, { prevLive }) => {\n    let { startAngle, endAngle, innerRadius, outerRadius } = datum;\n    const { stroke: stroke2, fill } = datum.sectorFormat;\n    if (status === \"removed\" && prevLive) {\n      startAngle = prevLive.datum?.endAngle;\n      endAngle = prevLive.datum?.endAngle;\n    } else if (status === \"removed\" && !prevLive) {\n      startAngle = rotation;\n      endAngle = rotation;\n    }\n    if (status === \"removed\") {\n      const radii = scaleToNewRadius(datum);\n      innerRadius = radii.innerRadius;\n      outerRadius = radii.outerRadius;\n    }\n    return { startAngle, endAngle, outerRadius, innerRadius, stroke: stroke2, fill };\n  };\n  const innerCircleFromFn = (node, _) => {\n    return { size: node.previousDatum?.radius ?? node.size ?? 0, phase };\n  };\n  const innerCircleToFn = (_, datum) => {\n    return { size: datum.radius ?? 0 };\n  };\n  return { nodes: { toFn, fromFn }, innerCircle: { fromFn: innerCircleFromFn, toFn: innerCircleToFn } };\n}\nfunction resetPieSelectionsFn(_node, datum) {\n  return {\n    startAngle: datum.startAngle,\n    endAngle: datum.endAngle,\n    innerRadius: datum.innerRadius,\n    outerRadius: datum.outerRadius,\n    fill: datum.sectorFormat.fill,\n    stroke: datum.sectorFormat.stroke\n  };\n}\nfunction pickByMatchingAngle(series, point) {\n  const dy = point.y - series.centerY;\n  const dx = point.x - series.centerX;\n  const angle2 = Math.atan2(dy, dx);\n  const sectors = series.getItemNodes();\n  for (const sector of sectors) {\n    if (sector.datum.missing === true)\n      continue;\n    if (isBetweenAngles(angle2, sector.startAngle, sector.endAngle)) {\n      const radius = Math.sqrt(dx * dx + dy * dy);\n      let distance2 = 0;\n      if (radius < sector.innerRadius) {\n        distance2 = sector.innerRadius - radius;\n      } else if (radius > sector.outerRadius) {\n        distance2 = radius - sector.outerRadius;\n      }\n      return { datum: sector.datum, distance: distance2 };\n    }\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/polar/polarZIndexMap.ts\nvar PolarZIndexMap = /* @__PURE__ */ ((PolarZIndexMap2) => {\n  PolarZIndexMap2[PolarZIndexMap2[\"BACKGROUND\"] = 0] = \"BACKGROUND\";\n  PolarZIndexMap2[PolarZIndexMap2[\"FOREGROUND\"] = 1] = \"FOREGROUND\";\n  PolarZIndexMap2[PolarZIndexMap2[\"HIGHLIGHT\"] = 2] = \"HIGHLIGHT\";\n  PolarZIndexMap2[PolarZIndexMap2[\"LABEL\"] = 3] = \"LABEL\";\n  return PolarZIndexMap2;\n})(PolarZIndexMap || {});\n\n// packages/ag-charts-community/src/chart/series/polar/polarSeries.ts\nvar PolarSeries = class extends DataModelSeries {\n  constructor({\n    useLabelLayer = false,\n    pickModes = [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n    canHaveAxes = false,\n    animationResetFns,\n    ...opts\n  }) {\n    super({\n      ...opts,\n      useLabelLayer,\n      pickModes,\n      directionKeys: {\n        [\"x\" /* X */]: [\"angleKey\"],\n        [\"y\" /* Y */]: [\"radiusKey\"]\n      },\n      directionNames: {\n        [\"x\" /* X */]: [\"angleName\"],\n        [\"y\" /* Y */]: [\"radiusName\"]\n      },\n      canHaveAxes\n    });\n    this.itemGroup = this.contentGroup.appendChild(new Group());\n    this.nodeData = [];\n    this.itemSelection = Selection.select(\n      this.itemGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.labelSelection = Selection.select(\n      this.labelGroup,\n      () => this.labelFactory(),\n      false\n    );\n    this.highlightSelection = Selection.select(\n      this.highlightGroup,\n      () => this.nodeFactory()\n    );\n    this.highlightLabelSelection = Selection.select(\n      this.highlightLabel,\n      () => this.labelFactory()\n    );\n    /**\n     * The center of the polar series (for example, the center of a pie).\n     * If the polar chart has multiple series, all of them will have their\n     * center set to the same value as a result of the polar chart layout.\n     * The center coordinates are not supposed to be set by the user.\n     */\n    this.centerX = 0;\n    this.centerY = 0;\n    /**\n     * The maximum radius the series can use.\n     * This value is set automatically as a result of the polar chart layout\n     * and is not supposed to be set by the user.\n     */\n    this.radius = 0;\n    this.animationResetFns = animationResetFns;\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  getItemNodes() {\n    return [...this.itemGroup.children()];\n  }\n  getNodeData() {\n    return this.nodeData;\n  }\n  setSeriesIndex(index) {\n    if (!super.setSeriesIndex(index))\n      return false;\n    this.contentGroup.zIndex = [index, 1 /* FOREGROUND */];\n    this.highlightGroup.zIndex = [index, 2 /* HIGHLIGHT */];\n    this.labelGroup.zIndex = [index, 3 /* LABEL */];\n    return true;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    }\n  }\n  labelFactory() {\n    const text2 = new Text();\n    text2.pointerEvents = 1 /* None */;\n    return text2;\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager?.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event))\n    );\n  }\n  getInnerRadius() {\n    return 0;\n  }\n  computeLabelsBBox(_options, _seriesRect) {\n    return null;\n  }\n  resetAllAnimation() {\n    const { item, label } = this.animationResetFns ?? {};\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    if (item) {\n      resetMotion([this.itemSelection, this.highlightSelection], item);\n    }\n    if (label) {\n      resetMotion([this.labelSelection, this.highlightLabelSelection], label);\n    }\n    this.itemSelection.cleanup();\n    this.labelSelection.cleanup();\n    this.highlightSelection.cleanup();\n    this.highlightLabelSelection.cleanup();\n  }\n  animateEmptyUpdateReady(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animateWaitingUpdateReady(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animateReadyHighlight(_data) {\n    const { item, label } = this.animationResetFns ?? {};\n    if (item) {\n      resetMotion([this.highlightSelection], item);\n    }\n    if (label) {\n      resetMotion([this.highlightLabelSelection], label);\n    }\n  }\n  animateReadyHighlightMarkers(_data) {\n  }\n  animateReadyResize(_data) {\n    this.resetAllAnimation();\n  }\n  animateClearingUpdateEmpty(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  computeFocusBounds(opts) {\n    const datum = this.getNodeData()?.[opts.datumIndex];\n    if (datum !== void 0) {\n      return this.itemSelection.select((node) => node instanceof Path && node.datum === datum)[0];\n    }\n    return void 0;\n  }\n  getSeriesRange(_direction, _visibleRange) {\n    return [NaN, NaN];\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeries.ts\nvar DonutSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.properties.angleKey;\n    this.radiusKey = series.properties.radiusKey;\n    this.calloutLabelKey = series.properties.calloutLabelKey;\n    this.sectorLabelKey = series.properties.sectorLabelKey;\n  }\n};\nvar DonutSeries = class extends PolarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      useLabelLayer: true,\n      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }\n    });\n    this.properties = new DonutSeriesProperties();\n    this.phantomNodeData = void 0;\n    this.backgroundGroup = new TranslatableGroup({\n      name: `${this.id}-background`,\n      zIndex: 0 /* BACKGROUND */\n    });\n    this.noVisibleData = false;\n    this.previousRadiusScale = new LinearScale();\n    this.radiusScale = new LinearScale();\n    this.phantomGroup = this.backgroundGroup.appendChild(new Group({ name: \"phantom\" }));\n    this.phantomSelection = Selection.select(\n      this.phantomGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: \"pieCalloutLabels\" }));\n    this.calloutLabelSelection = new Selection(\n      this.calloutLabelGroup,\n      Group\n    );\n    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.\n    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));\n    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Marker({ shape: \"circle\" }));\n    this.zerosumInnerRing = this.zerosumRingsGroup.appendChild(new Marker({ shape: \"circle\" }));\n    this.innerLabelsGroup = this.contentGroup.appendChild(new Group({ name: \"innerLabels\" }));\n    this.innerCircleGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-innerCircle` }));\n    this.innerLabelsSelection = Selection.select(this.innerLabelsGroup, Text);\n    this.innerCircleSelection = Selection.select(\n      this.innerCircleGroup,\n      () => new Marker({ shape: \"circle\" })\n    );\n    this.surroundingRadius = void 0;\n    this.NodeEvent = DonutSeriesNodeEvent;\n    this.angleScale = new LinearScale();\n    this.angleScale.domain = [0, 1];\n    this.angleScale.range = [-Math.PI, Math.PI].map((angle2) => angle2 + Math.PI / 2);\n    this.phantomGroup.opacity = 0.2;\n  }\n  get calloutNodeData() {\n    return this.phantomNodeData ?? this.nodeData;\n  }\n  attachSeries(seriesContentNode, seriesNode, annotationNode) {\n    super.attachSeries(seriesContentNode, seriesNode, annotationNode);\n    seriesContentNode?.appendChild(this.backgroundGroup);\n  }\n  detachSeries(seriesContentNode, seriesNode, annotationNode) {\n    super.detachSeries(seriesContentNode, seriesNode, annotationNode);\n    seriesContentNode?.removeChild(this.backgroundGroup);\n  }\n  setSeriesIndex(index) {\n    if (!super.setSeriesIndex(index))\n      return false;\n    this.backgroundGroup.zIndex = [0 /* BACKGROUND */, index];\n    return true;\n  }\n  nodeFactory() {\n    return new Sector();\n  }\n  getSeriesDomain(direction) {\n    if (direction === \"x\" /* X */) {\n      return this.angleScale.domain;\n    } else {\n      return this.radiusScale.domain;\n    }\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { visible, id: seriesId } = this;\n    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const validSector = (_value, _datum, index) => {\n      return visible && this.ctx.legendManager.getItemEnabled({ seriesId, itemId: index });\n    };\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const extraKeyProps = [];\n    const extraProps = [];\n    if (legendItemKey) {\n      extraKeyProps.push(keyProperty(legendItemKey, \"band\", { id: `legendItemKey` }));\n    } else if (calloutLabelKey) {\n      extraKeyProps.push(keyProperty(calloutLabelKey, \"band\", { id: `calloutLabelKey` }));\n    } else if (sectorLabelKey) {\n      extraKeyProps.push(keyProperty(sectorLabelKey, \"band\", { id: `sectorLabelKey` }));\n    }\n    const radiusScaleType = this.radiusScale.type;\n    const angleScaleType = this.angleScale.type;\n    if (radiusKey) {\n      extraProps.push(\n        rangedValueProperty(radiusKey, {\n          id: \"radiusValue\",\n          min: this.properties.radiusMin ?? 0,\n          max: this.properties.radiusMax\n        }),\n        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"radiusValue\", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)\n      );\n    }\n    if (calloutLabelKey) {\n      extraProps.push(valueProperty(calloutLabelKey, \"band\", { id: `calloutLabelValue` }));\n    }\n    if (sectorLabelKey) {\n      extraProps.push(valueProperty(sectorLabelKey, \"band\", { id: `sectorLabelValue` }));\n    }\n    if (legendItemKey) {\n      extraProps.push(valueProperty(legendItemKey, \"band\", { id: `legendItemValue` }));\n    }\n    if (angleFilterKey) {\n      extraProps.push(\n        accumulativeValueProperty(angleFilterKey, angleScaleType, {\n          id: `angleFilterValue`,\n          onlyPositive: true,\n          validation: validSector,\n          invalidValue: 0\n        }),\n        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),\n        normalisePropertyTo(\"angleFilterValue\", [0, 1], 0, 0)\n      );\n    }\n    if (animationEnabled && this.processedData && extraKeyProps.length > 0) {\n      extraProps.push(diff(this.id, this.processedData));\n    }\n    extraProps.push(animationValidation());\n    await this.requestDataModel(dataController, this.data, {\n      props: [\n        ...extraKeyProps,\n        accumulativeValueProperty(angleKey, angleScaleType, {\n          id: `angleValue`,\n          onlyPositive: true,\n          validation: validSector,\n          invalidValue: 0\n        }),\n        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"angleValue\", [0, 1], 0, 0),\n        ...extraProps\n      ]\n    });\n    for (const valueDef of this.processedData?.defs?.values ?? []) {\n      const { id, missing, property } = valueDef;\n      const missCount = getMissCount(this, missing);\n      if (id !== \"angleRaw\" && missCount > 0) {\n        logger_exports.warnOnce(\n          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? \"s\" : \"\"}`\n        );\n      }\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  maybeRefreshNodeData() {\n    if (!this.nodeDataRefresh)\n      return;\n    const { nodeData = [], phantomNodeData } = this.createNodeData() ?? {};\n    this.nodeData = nodeData;\n    this.phantomNodeData = phantomNodeData;\n    this.nodeDataRefresh = false;\n  }\n  getProcessedDataValues(dataModel, processedData) {\n    const angleValues = dataModel.resolveColumnById(this, `angleValue`, processedData);\n    const angleRawValues = dataModel.resolveColumnById(this, `angleRaw`, processedData);\n    const angleFilterValues = this.properties.angleFilterKey != null ? dataModel.resolveColumnById(this, `angleFilterValue`, processedData) : void 0;\n    const angleFilterRawValues = this.properties.angleFilterKey != null ? dataModel.resolveColumnById(this, `angleFilterRaw`, processedData) : void 0;\n    const radiusValues = this.properties.radiusKey ? dataModel.resolveColumnById(this, `radiusValue`, processedData) : void 0;\n    const radiusRawValues = this.properties.radiusKey ? dataModel.resolveColumnById(this, `radiusRaw`, processedData) : void 0;\n    const calloutLabelValues = this.properties.calloutLabelKey ? dataModel.resolveColumnById(this, `calloutLabelValue`, processedData) : void 0;\n    const sectorLabelValues = this.properties.sectorLabelKey ? dataModel.resolveColumnById(this, `sectorLabelValue`, processedData) : void 0;\n    const legendItemValues = this.properties.legendItemKey ? dataModel.resolveColumnById(this, `legendItemValue`, processedData) : void 0;\n    return {\n      angleValues,\n      angleRawValues,\n      angleFilterValues,\n      angleFilterRawValues,\n      radiusValues,\n      radiusRawValues,\n      calloutLabelValues,\n      sectorLabelValues,\n      legendItemValues\n    };\n  }\n  createNodeData() {\n    const {\n      id: seriesId,\n      processedData,\n      dataModel,\n      angleScale,\n      ctx: { legendManager },\n      visible\n    } = this;\n    const { rotation, innerRadiusRatio } = this.properties;\n    if (!this.properties.isValid()) {\n      this.zerosumOuterRing.visible = true;\n      this.zerosumInnerRing.visible = true;\n      return { itemId: seriesId, nodeData: [], labelData: [] };\n    }\n    if (!dataModel || processedData?.type !== \"ungrouped\")\n      return;\n    const {\n      angleValues,\n      angleRawValues,\n      angleFilterValues,\n      angleFilterRawValues,\n      radiusValues,\n      radiusRawValues,\n      calloutLabelValues,\n      sectorLabelValues,\n      legendItemValues\n    } = this.getProcessedDataValues(dataModel, processedData);\n    const useFilterAngles = angleFilterRawValues?.some((filterRawValue, index) => {\n      return filterRawValue > angleRawValues[index];\n    }) ?? false;\n    let currentStart = 0;\n    let sum2 = 0;\n    const nodes = [];\n    const phantomNodes = angleFilterRawValues != null ? [] : void 0;\n    const rawData = processedData.dataSources.get(this.id) ?? [];\n    const invalidData = processedData.invalidData?.get(this.id);\n    rawData.forEach((datum, datumIndex) => {\n      if (invalidData?.[datumIndex] === true)\n        return;\n      const currentValue = useFilterAngles ? angleFilterValues[datumIndex] : angleValues[datumIndex];\n      const crossFilterScale = angleFilterRawValues != null && !useFilterAngles ? Math.sqrt(angleFilterRawValues[datumIndex] / angleRawValues[datumIndex]) : 1;\n      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      currentStart = currentValue;\n      sum2 += currentValue;\n      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      const span = Math.abs(endAngle - startAngle);\n      const midAngle = startAngle + span / 2;\n      const angleValue = angleRawValues[datumIndex];\n      const radiusRaw = radiusValues?.[datumIndex] ?? 1;\n      const radius = radiusRaw * crossFilterScale;\n      const radiusValue = radiusRawValues?.[datumIndex];\n      const legendItemValue = legendItemValues?.[datumIndex];\n      const nodeLabels = this.getLabels(\n        datum,\n        midAngle,\n        span,\n        true,\n        calloutLabelValues?.[datumIndex],\n        sectorLabelValues?.[datumIndex],\n        legendItemValue\n      );\n      const sectorFormat = this.getSectorFormat(datum, datumIndex, false);\n      const node = {\n        itemId: datumIndex,\n        series: this,\n        datum,\n        datumIndex,\n        angleValue,\n        midAngle,\n        midCos: Math.cos(midAngle),\n        midSin: Math.sin(midAngle),\n        startAngle,\n        endAngle,\n        radius,\n        innerRadius: Math.max(this.radiusScale.convert(0), 0),\n        outerRadius: Math.max(this.radiusScale.convert(radius), 0),\n        sectorFormat,\n        radiusValue,\n        legendItemValue,\n        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId: datumIndex }),\n        focusable: true,\n        ...nodeLabels\n      };\n      nodes.push(node);\n      if (phantomNodes != null) {\n        phantomNodes.push({\n          ...node,\n          radius: 1,\n          innerRadius: Math.max(this.radiusScale.convert(0), 0),\n          outerRadius: Math.max(this.radiusScale.convert(1), 0),\n          focusable: false\n        });\n      }\n    });\n    this.zerosumOuterRing.visible = sum2 === 0;\n    this.zerosumInnerRing.visible = sum2 === 0 && innerRadiusRatio != null && innerRadiusRatio !== 1 && innerRadiusRatio > 0;\n    return {\n      itemId: seriesId,\n      nodeData: nodes,\n      labelData: nodes,\n      phantomNodeData: phantomNodes\n    };\n  }\n  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {\n    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;\n    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;\n    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;\n    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {\n      return {};\n    }\n    const labelFormatterParams = {\n      datum,\n      angleKey: this.properties.angleKey,\n      angleName: this.properties.angleName,\n      radiusKey: this.properties.radiusKey,\n      radiusName: this.properties.radiusName,\n      calloutLabelKey: this.properties.calloutLabelKey,\n      calloutLabelName: this.properties.calloutLabelName,\n      sectorLabelKey: this.properties.sectorLabelKey,\n      sectorLabelName: this.properties.sectorLabelName,\n      legendItemKey: this.properties.legendItemKey\n    };\n    const result = {};\n    if (calloutLabelKey && span >= toRadians(calloutLabel.minAngle)) {\n      result.calloutLabel = {\n        ...this.getTextAlignment(midAngle),\n        text: this.getLabelText(calloutLabel, {\n          ...labelFormatterParams,\n          value: calloutLabelValue\n        }),\n        hidden: false,\n        collisionTextAlign: void 0,\n        collisionOffsetY: 0,\n        box: void 0\n      };\n    }\n    if (sectorLabelKey) {\n      result.sectorLabel = {\n        text: this.getLabelText(sectorLabel, {\n          ...labelFormatterParams,\n          value: sectorLabelValue\n        })\n      };\n    }\n    if (legendItemKey != null && legendItemValue != null) {\n      result.legendItem = { key: legendItemKey, text: legendItemValue };\n    }\n    return result;\n  }\n  getTextAlignment(midAngle) {\n    const quadrantTextOpts = [\n      { textAlign: \"center\", textBaseline: \"bottom\" },\n      { textAlign: \"left\", textBaseline: \"middle\" },\n      { textAlign: \"center\", textBaseline: \"hanging\" },\n      { textAlign: \"right\", textBaseline: \"middle\" }\n    ];\n    const midAngle180 = normalizeAngle180(midAngle);\n    const quadrantStart = -0.75 * Math.PI;\n    const quadrantOffset = midAngle180 - quadrantStart;\n    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));\n    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);\n    return quadrantTextOpts[quadrantIndex];\n  }\n  getSectorFormat(datum, datumIndex, highlighted) {\n    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, fills, strokes, itemStyler } = this.properties;\n    const defaultStroke = strokes[datumIndex % strokes.length];\n    const { fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      {\n        fill: fills.length > 0 ? fills[datumIndex % fills.length] : void 0,\n        stroke: defaultStroke,\n        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n        strokeOpacity: this.getOpacity()\n      },\n      this.properties\n    );\n    let format;\n    if (itemStyler) {\n      format = this.cachedDatumCallback(\n        this.getDatumId(datum, datumIndex) + (highlighted ? \"-highlight\" : \"-hide\"),\n        () => itemStyler({\n          datum,\n          angleKey,\n          radiusKey,\n          calloutLabelKey,\n          sectorLabelKey,\n          legendItemKey,\n          fill,\n          fillOpacity,\n          stroke: stroke2,\n          strokeWidth,\n          strokeOpacity,\n          lineDash,\n          lineDashOffset,\n          cornerRadius,\n          highlighted,\n          seriesId: this.id\n        })\n      );\n    }\n    return {\n      fill: format?.fill ?? fill,\n      fillOpacity: format?.fillOpacity ?? fillOpacity,\n      stroke: format?.stroke ?? stroke2,\n      strokeWidth: format?.strokeWidth ?? strokeWidth,\n      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n      lineDash: format?.lineDash ?? lineDash,\n      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n      cornerRadius: format?.cornerRadius ?? cornerRadius\n    };\n  }\n  getInnerRadius() {\n    const { radius } = this;\n    const { innerRadiusRatio = 1, innerRadiusOffset = 0 } = this.properties;\n    const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;\n    if (innerRadius === radius || innerRadius < 0) {\n      return 0;\n    }\n    return innerRadius;\n  }\n  getOuterRadius() {\n    const { outerRadiusRatio, outerRadiusOffset } = this.properties;\n    return Math.max(this.radius * outerRadiusRatio + outerRadiusOffset, 0);\n  }\n  updateRadiusScale(resize) {\n    const newRange = [this.getInnerRadius(), this.getOuterRadius()];\n    this.radiusScale.range = newRange;\n    if (resize) {\n      this.previousRadiusScale.range = newRange;\n    }\n    const setRadii = (d) => ({\n      ...d,\n      innerRadius: Math.max(this.radiusScale.convert(0), 0),\n      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)\n    });\n    this.nodeData = this.nodeData.map(setRadii);\n    this.phantomNodeData = this.phantomNodeData?.map(setRadii);\n  }\n  getTitleTranslationY() {\n    const outerRadius = Math.max(0, this.radiusScale.range[1]);\n    if (outerRadius === 0) {\n      return NaN;\n    }\n    const spacing = this.properties.title?.spacing ?? 0;\n    const titleOffset = 2 + spacing;\n    const dy = Math.max(0, -outerRadius);\n    return -outerRadius - titleOffset - dy;\n  }\n  update({ seriesRect }) {\n    const { title } = this.properties;\n    const newNodeDataDependencies = {\n      seriesRectWidth: seriesRect?.width,\n      seriesRectHeight: seriesRect?.height\n    };\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n    }\n    this.maybeRefreshNodeData();\n    this.updateTitleNodes();\n    this.updateRadiusScale(resize);\n    this.contentGroup.translationX = this.centerX;\n    this.contentGroup.translationY = this.centerY;\n    this.highlightGroup.translationX = this.centerX;\n    this.highlightGroup.translationY = this.centerY;\n    this.backgroundGroup.translationX = this.centerX;\n    this.backgroundGroup.translationY = this.centerY;\n    if (this.labelGroup) {\n      this.labelGroup.translationX = this.centerX;\n      this.labelGroup.translationY = this.centerY;\n    }\n    if (title) {\n      const dy = this.getTitleTranslationY();\n      title.node.y = isFinite(dy) ? dy : 0;\n      const titleBox = title.node.getBBox();\n      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox);\n    }\n    for (const circle of [this.zerosumInnerRing, this.zerosumOuterRing]) {\n      circle.fillOpacity = 0;\n      circle.stroke = this.properties.calloutLabel.color;\n      circle.strokeWidth = 1;\n      circle.strokeOpacity = 1;\n    }\n    this.updateNodeMidPoint();\n    this.updateSelections();\n    this.updateNodes(seriesRect);\n  }\n  updateTitleNodes() {\n    const { oldTitle } = this;\n    const { title } = this.properties;\n    if (oldTitle !== title) {\n      if (oldTitle) {\n        this.labelGroup?.removeChild(oldTitle.node);\n      }\n      if (title) {\n        title.node.textBaseline = \"bottom\";\n        this.labelGroup?.appendChild(title.node);\n      }\n      this.oldTitle = title;\n    }\n  }\n  updateNodeMidPoint() {\n    const setMidPoint = (d) => {\n      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;\n      d.midPoint = {\n        x: d.midCos * Math.max(0, radius),\n        y: d.midSin * Math.max(0, radius)\n      };\n    };\n    this.nodeData.forEach(setMidPoint);\n    this.phantomNodeData?.forEach(setMidPoint);\n  }\n  updateSelections() {\n    this.updateGroupSelection();\n    this.updateInnerCircleSelection();\n  }\n  updateGroupSelection() {\n    const {\n      itemSelection,\n      highlightSelection,\n      phantomSelection,\n      highlightLabelSelection,\n      calloutLabelSelection,\n      labelSelection,\n      innerLabelsSelection\n    } = this;\n    const highlightedNodeData = this.nodeData.map((datum) => ({\n      ...datum,\n      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied\n      // between normal and highlighted cases.\n      sectorFormat: { ...datum.sectorFormat }\n    }));\n    const update = (selection, nodeData) => {\n      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum.datum, datum.datumIndex));\n      if (this.ctx.animationManager.isSkipped()) {\n        selection.cleanup();\n      }\n    };\n    update(itemSelection, this.nodeData);\n    update(highlightSelection, highlightedNodeData);\n    update(phantomSelection, this.phantomNodeData ?? []);\n    calloutLabelSelection.update(this.calloutNodeData, (group) => {\n      const line = new Line();\n      line.tag = 0 /* Callout */;\n      line.pointerEvents = 1 /* None */;\n      group.appendChild(line);\n      const text2 = new Text();\n      text2.tag = 1 /* Label */;\n      text2.pointerEvents = 1 /* None */;\n      group.appendChild(text2);\n    });\n    labelSelection.update(this.nodeData);\n    highlightLabelSelection.update(highlightedNodeData);\n    innerLabelsSelection.update(this.properties.innerLabels, (node) => {\n      node.pointerEvents = 1 /* None */;\n    });\n  }\n  updateInnerCircleSelection() {\n    const { innerCircle } = this.properties;\n    let radius = 0;\n    const innerRadius = this.getInnerRadius();\n    if (innerRadius > 0) {\n      const circleRadius = Math.min(innerRadius, this.getOuterRadius());\n      const antiAliasingPadding = 1;\n      radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);\n    }\n    const datums = innerCircle ? [{ radius }] : [];\n    this.innerCircleSelection.update(datums);\n  }\n  updateNodes(seriesRect) {\n    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\n    const { visible } = this;\n    this.backgroundGroup.visible = visible;\n    this.contentGroup.visible = visible;\n    this.highlightGroup.visible = visible && highlightedDatum?.series === this;\n    this.highlightLabel.visible = visible && highlightedDatum?.series === this;\n    this.labelGroup.visible = visible;\n    this.contentGroup.opacity = this.getOpacity();\n    this.innerCircleSelection.each((node, { radius }) => {\n      node.setProperties({\n        fill: this.properties.innerCircle?.fill,\n        opacity: this.properties.innerCircle?.fillOpacity,\n        size: radius\n      });\n    });\n    const animationDisabled = this.ctx.animationManager.isSkipped();\n    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {\n      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);\n      datum.sectorFormat.fill = format.fill;\n      datum.sectorFormat.stroke = format.stroke;\n      if (animationDisabled) {\n        sector.startAngle = datum.startAngle;\n        sector.endAngle = datum.endAngle;\n        sector.innerRadius = datum.innerRadius;\n        sector.outerRadius = datum.outerRadius;\n      }\n      if (isDatumHighlighted || animationDisabled) {\n        sector.fill = format.fill;\n        sector.stroke = format.stroke;\n      }\n      sector.strokeWidth = format.strokeWidth;\n      sector.fillOpacity = format.fillOpacity;\n      sector.strokeOpacity = format.strokeOpacity;\n      sector.lineDash = format.lineDash;\n      sector.lineDashOffset = format.lineDashOffset;\n      sector.cornerRadius = format.cornerRadius;\n      sector.fillShadow = this.properties.shadow;\n      const inset = Math.max(\n        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,\n        0\n      );\n      sector.inset = inset;\n      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? \"miter\" : \"round\";\n    };\n    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.highlightSelection.each((node, datum, index) => {\n      updateSectorFn(node, datum, index, true);\n      node.visible = datum.itemId === highlightedDatum?.itemId;\n    });\n    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.updateCalloutLineNodes();\n    this.updateCalloutLabelNodes(seriesRect);\n    this.updateSectorLabelNodes();\n    this.updateInnerLabelNodes();\n    this.updateZerosumRings();\n    this.animationState.transition(\"update\");\n  }\n  updateCalloutLineNodes() {\n    const { calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const calloutStrokeWidth = calloutLine.strokeWidth;\n    const calloutColors = calloutLine.colors ?? this.properties.strokes;\n    const { offset: offset4 } = this.properties.calloutLabel;\n    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {\n      const datum = line.datum;\n      const { calloutLabel: label, outerRadius } = datum;\n      if (label?.text && !label.hidden && outerRadius !== 0) {\n        line.visible = true;\n        line.strokeWidth = calloutStrokeWidth;\n        line.stroke = calloutColors[index % calloutColors.length];\n        line.fill = void 0;\n        const x1 = datum.midCos * outerRadius;\n        const y1 = datum.midSin * outerRadius;\n        let x2 = datum.midCos * (outerRadius + calloutLength);\n        let y2 = datum.midSin * (outerRadius + calloutLength);\n        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;\n        if (isMoved && label.box != null) {\n          const box = label.box;\n          let cx = x2;\n          let cy = y2;\n          if (x2 < box.x) {\n            cx = box.x;\n          } else if (x2 > box.x + box.width) {\n            cx = box.x + box.width;\n          }\n          if (y2 < box.y) {\n            cy = box.y;\n          } else if (y2 > box.y + box.height) {\n            cy = box.y + box.height;\n          }\n          const dx = cx - x2;\n          const dy = cy - y2;\n          const length2 = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          const paddedLength = length2 - offset4;\n          if (paddedLength > 0) {\n            x2 = x2 + dx * paddedLength / length2;\n            y2 = y2 + dy * paddedLength / length2;\n          }\n        }\n        line.x1 = x1;\n        line.y1 = y1;\n        line.x2 = x2;\n        line.y2 = y2;\n      } else {\n        line.visible = false;\n      }\n    });\n  }\n  getLabelOverflow(text2, box, seriesRect) {\n    const seriesLeft = -this.centerX;\n    const seriesRight = seriesLeft + seriesRect.width;\n    const seriesTop = -this.centerY;\n    const seriesBottom = seriesTop + seriesRect.height;\n    const errPx = 1;\n    let visibleTextPart = 1;\n    if (box.x + errPx < seriesLeft) {\n      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;\n    } else if (box.x + box.width - errPx > seriesRight) {\n      visibleTextPart = (seriesRight - box.x) / box.width;\n    }\n    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;\n    const textLength = visibleTextPart === 1 ? text2.length : Math.floor(text2.length * visibleTextPart) - 1;\n    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);\n    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };\n  }\n  bboxIntersectsSurroundingSeries(box) {\n    const { surroundingRadius } = this;\n    if (surroundingRadius == null) {\n      return false;\n    }\n    const corners = [\n      { x: box.x, y: box.y },\n      { x: box.x + box.width, y: box.y },\n      { x: box.x + box.width, y: box.y + box.height },\n      { x: box.x, y: box.y + box.height }\n    ];\n    const sur2 = surroundingRadius ** 2;\n    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);\n  }\n  computeCalloutLabelCollisionOffsets() {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const { offset: offset4, minSpacing } = calloutLabel;\n    const innerRadius = radiusScale.convert(0);\n    const shouldSkip = (datum) => {\n      const label = datum.calloutLabel;\n      return !label || datum.outerRadius === 0;\n    };\n    const fullData = this.calloutNodeData;\n    const data = fullData.filter((t) => !shouldSkip(t));\n    data.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return;\n      label.hidden = false;\n      label.collisionTextAlign = void 0;\n      label.collisionOffsetY = 0;\n    });\n    if (data.length <= 1) {\n      return;\n    }\n    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);\n    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);\n    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const getTextBBox = (datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return BBox.zero.clone();\n      const labelRadius = datum.outerRadius + calloutLine.length + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const textAlign = label.collisionTextAlign ?? label.textAlign;\n      const textBaseline = label.textBaseline;\n      return Text.computeBBox(label.text, x, y, {\n        font: this.properties.calloutLabel,\n        textAlign,\n        textBaseline\n      });\n    };\n    const avoidNeighbourYCollision = (label, next, direction) => {\n      const box = getTextBBox(label).grow(minSpacing / 2);\n      const other = getTextBBox(next).grow(minSpacing / 2);\n      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === \"to-top\" ? box.y < other.y + other.height : box.y + box.height > other.y);\n      if (collidesOrBehind) {\n        next.calloutLabel.collisionOffsetY = direction === \"to-top\" ? box.y - other.y - other.height : box.y + box.height - other.y;\n      }\n    };\n    const avoidYCollisions = (labels) => {\n      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];\n      const midIndex = labels.indexOf(midLabel);\n      for (let i = midIndex - 1; i >= 0; i--) {\n        const prev = labels[i + 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-top\");\n      }\n      for (let i = midIndex + 1; i < labels.length; i++) {\n        const prev = labels[i - 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-bottom\");\n      }\n    };\n    const avoidXCollisions = (labels) => {\n      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);\n      const boxes = labels.map((label) => getTextBBox(label));\n      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));\n      let labelsCollideLabelsByX = false;\n      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {\n        const box = paddedBoxes[i];\n        for (let j = i + 1; j < labels.length; j++) {\n          const other = paddedBoxes[j];\n          if (box.collidesBBox(other)) {\n            labelsCollideLabelsByX = true;\n            break;\n          }\n        }\n      }\n      const sectors = fullData.map((datum) => {\n        const { startAngle, endAngle, outerRadius } = datum;\n        return { startAngle, endAngle, innerRadius, outerRadius };\n      });\n      const labelsCollideSectors = boxes.some((box) => {\n        return sectors.some((sector) => boxCollidesSector(box, sector));\n      });\n      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {\n        return;\n      }\n      labels.filter((d) => d.calloutLabel.textAlign === \"center\").forEach((d) => {\n        const label = d.calloutLabel;\n        if (d.midCos < 0) {\n          label.collisionTextAlign = \"right\";\n        } else if (d.midCos > 0) {\n          label.collisionTextAlign = \"left\";\n        } else {\n          label.collisionTextAlign = \"center\";\n        }\n      });\n    };\n    avoidYCollisions(leftLabels);\n    avoidYCollisions(rightLabels);\n    avoidXCollisions(topLabels);\n    avoidXCollisions(bottomLabels);\n  }\n  updateCalloutLabelNodes(seriesRect) {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, color } = calloutLabel;\n    const tempTextNode = new Text();\n    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text2) => {\n      const { datum } = text2;\n      const label = datum.calloutLabel;\n      const radius = radiusScale.convert(datum.radius);\n      const outerRadius = Math.max(0, radius);\n      if (!label?.text || outerRadius === 0 || label.hidden) {\n        text2.visible = false;\n        return;\n      }\n      const labelRadius = outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const align2 = {\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      };\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.properties.calloutLabel);\n      tempTextNode.setAlign(align2);\n      const box = tempTextNode.getBBox();\n      let displayText = label.text;\n      let visible = true;\n      if (calloutLabel.avoidCollisions) {\n        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\n        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\\u2026`;\n        visible = !hasVerticalOverflow;\n      }\n      text2.text = displayText;\n      text2.x = x;\n      text2.y = y;\n      text2.setFont(this.properties.calloutLabel);\n      text2.setAlign(align2);\n      text2.fill = color;\n      text2.visible = visible;\n    });\n  }\n  computeLabelsBBox(options, seriesRect) {\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;\n    if (!calloutLabel.avoidCollisions) {\n      return null;\n    }\n    this.maybeRefreshNodeData();\n    this.updateRadiusScale(false);\n    this.computeCalloutLabelCollisionOffsets();\n    const textBoxes = [];\n    const text2 = new Text();\n    let titleBox;\n    const { title } = this.properties;\n    if (title?.text && title.enabled) {\n      const dy = this.getTitleTranslationY();\n      if (isFinite(dy)) {\n        text2.text = title.text;\n        text2.x = 0;\n        text2.y = dy;\n        text2.setFont(title);\n        text2.setAlign({\n          textBaseline: \"bottom\",\n          textAlign: \"center\"\n        });\n        titleBox = text2.getBBox();\n        textBoxes.push(titleBox);\n      }\n    }\n    this.calloutNodeData.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (!label || datum.outerRadius === 0) {\n        return null;\n      }\n      const labelRadius = datum.outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      text2.text = label.text;\n      text2.x = x;\n      text2.y = y;\n      text2.setFont(this.properties.calloutLabel);\n      text2.setAlign({\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      });\n      const box = text2.getBBox();\n      label.box = box;\n      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {\n        label.hidden = true;\n        return;\n      }\n      if (titleBox) {\n        const seriesTop = -this.centerY;\n        const titleCleanArea = new BBox(\n          titleBox.x - minSpacing,\n          seriesTop,\n          titleBox.width + 2 * minSpacing,\n          titleBox.y + titleBox.height + minSpacing - seriesTop\n        );\n        if (box.collidesBBox(titleCleanArea)) {\n          label.hidden = true;\n          return;\n        }\n      }\n      if (options.hideWhenNecessary) {\n        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(\n          label.text,\n          box,\n          seriesRect\n        );\n        const isTooShort = label.text.length > 2 && textLength < 2;\n        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {\n          label.hidden = true;\n          return;\n        }\n      }\n      label.hidden = false;\n      textBoxes.push(box);\n    });\n    if (textBoxes.length === 0) {\n      return null;\n    }\n    return BBox.merge(textBoxes);\n  }\n  updateSectorLabelNodes() {\n    const { radiusScale } = this;\n    const innerRadius = radiusScale.convert(0);\n    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;\n    const updateSectorLabel = (text2, datum) => {\n      const { sectorLabel, outerRadius } = datum;\n      let isTextVisible = false;\n      if (sectorLabel && outerRadius !== 0) {\n        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;\n        text2.fill = color;\n        text2.fontStyle = fontStyle;\n        text2.fontWeight = fontWeight;\n        text2.fontSize = fontSize;\n        text2.fontFamily = fontFamily;\n        text2.text = sectorLabel.text;\n        text2.x = datum.midCos * labelRadius;\n        text2.y = datum.midSin * labelRadius;\n        text2.textAlign = \"center\";\n        text2.textBaseline = \"middle\";\n        const bbox = text2.getBBox();\n        const corners = [\n          [bbox.x, bbox.y],\n          [bbox.x + bbox.width, bbox.y],\n          [bbox.x + bbox.width, bbox.y + bbox.height],\n          [bbox.x, bbox.y + bbox.height]\n        ];\n        const { startAngle, endAngle } = datum;\n        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };\n        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {\n          isTextVisible = true;\n        }\n      }\n      text2.visible = isTextVisible;\n    };\n    this.labelSelection.each(updateSectorLabel);\n    this.highlightLabelSelection.each(updateSectorLabel);\n  }\n  updateInnerLabelNodes() {\n    const textBBoxes = [];\n    const margins = [];\n    this.innerLabelsSelection.each((text2, datum) => {\n      const { fontStyle, fontWeight, fontSize, fontFamily, color } = datum;\n      text2.fontStyle = fontStyle;\n      text2.fontWeight = fontWeight;\n      text2.fontSize = fontSize;\n      text2.fontFamily = fontFamily;\n      text2.text = datum.text;\n      text2.x = 0;\n      text2.y = 0;\n      text2.fill = color;\n      text2.textAlign = \"center\";\n      text2.textBaseline = \"alphabetic\";\n      textBBoxes.push(text2.getBBox());\n      margins.push(datum.spacing);\n    });\n    const getMarginTop = (index) => index === 0 ? 0 : margins[index];\n    const getMarginBottom = (index) => index === margins.length - 1 ? 0 : margins[index];\n    const totalHeight = textBBoxes.reduce((sum2, bbox, i) => {\n      return sum2 + bbox.height + getMarginTop(i) + getMarginBottom(i);\n    }, 0);\n    const totalWidth = Math.max(...textBBoxes.map((bbox) => bbox.width));\n    const innerRadius = this.getInnerRadius();\n    const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));\n    const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());\n    const textBottoms = [];\n    for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {\n      const bbox = textBBoxes[i];\n      const bottom = bbox.height + prev + getMarginTop(i);\n      textBottoms.push(bottom);\n      prev = bottom + getMarginBottom(i);\n    }\n    this.innerLabelsSelection.each((text2, _datum, index) => {\n      text2.y = textBottoms[index];\n      text2.visible = labelsVisible;\n    });\n  }\n  updateZerosumRings() {\n    this.zerosumOuterRing.size = this.getOuterRadius() * 2;\n    this.zerosumInnerRing.size = this.getInnerRadius() * 2;\n  }\n  pickNodeClosestDatum(point) {\n    return pickByMatchingAngle(this, point);\n  }\n  getTooltipContent(nodeDatum) {\n    const { id: seriesId, dataModel, processedData, properties } = this;\n    const {\n      legendItemKey,\n      calloutLabelKey,\n      calloutLabelName,\n      sectorLabelKey,\n      sectorLabelName,\n      angleKey,\n      angleName,\n      radiusKey,\n      radiusName,\n      tooltip\n    } = properties;\n    const title = this.properties.title.text;\n    if (!dataModel || !processedData)\n      return;\n    const { datumIndex } = nodeDatum;\n    const datum = processedData.dataSources.get(this.id)?.[datumIndex];\n    const { angleRawValues, legendItemValues, calloutLabelValues, sectorLabelValues } = this.getProcessedDataValues(\n      dataModel,\n      processedData\n    );\n    const angleRawValue = angleRawValues[datumIndex];\n    const label = legendItemValues?.[datumIndex] ?? (calloutLabelKey === angleKey ? void 0 : calloutLabelValues?.[datumIndex]) ?? (sectorLabelKey === angleKey ? void 0 : sectorLabelValues?.[datumIndex]) ?? angleName;\n    return tooltip.formatTooltip(\n      {\n        title,\n        symbol: this.legendItemSymbol(datumIndex),\n        data: [\n          {\n            label,\n            fallbackLabel: angleKey,\n            value: formatValue(angleRawValue, 3)\n          }\n        ]\n      },\n      {\n        seriesId,\n        datum,\n        title: angleName,\n        legendItemKey,\n        calloutLabelKey,\n        calloutLabelName,\n        sectorLabelKey,\n        sectorLabelName,\n        angleKey,\n        angleName,\n        radiusKey,\n        radiusName,\n        ...this.getSectorFormat(datum, datumIndex, false)\n      }\n    );\n  }\n  legendItemSymbol(datumIndex) {\n    const datum = this.processedData?.dataSources.get(this.id)?.[datumIndex];\n    const sectorFormat = this.getSectorFormat(datum, datumIndex, false);\n    return {\n      marker: {\n        fill: sectorFormat.fill,\n        stroke: sectorFormat.stroke,\n        fillOpacity: this.properties.fillOpacity,\n        strokeOpacity: this.properties.strokeOpacity,\n        strokeWidth: this.properties.strokeWidth,\n        lineDash: this.properties.lineDash,\n        lineDashOffset: this.properties.lineDashOffset\n      }\n    };\n  }\n  getLegendData(legendType) {\n    const {\n      visible,\n      processedData,\n      dataModel,\n      id: seriesId,\n      ctx: { legendManager }\n    } = this;\n    if (!dataModel || !processedData || !this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey, showInLegend } = this.properties;\n    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey))\n      return [];\n    const { angleRawValues, calloutLabelValues, sectorLabelValues, legendItemValues } = this.getProcessedDataValues(\n      dataModel,\n      processedData\n    );\n    const titleText = this.properties.title?.showInLegend && this.properties.title.text;\n    const legendData = [];\n    const hideZeros = this.properties.hideZeroValueSectorsInLegend;\n    const rawData = processedData.dataSources.get(this.id);\n    const invalidData = processedData.invalidData?.get(this.id);\n    for (let datumIndex = 0; datumIndex < processedData.input.count; datumIndex++) {\n      const datum = rawData?.[datumIndex];\n      const angleRawValue = angleRawValues[datumIndex];\n      if (invalidData?.[datumIndex] === true || hideZeros && angleRawValue === 0) {\n        continue;\n      }\n      const labelParts = [];\n      if (titleText) {\n        labelParts.push(titleText);\n      }\n      const labels = this.getLabels(\n        datum,\n        2 * Math.PI,\n        2 * Math.PI,\n        false,\n        calloutLabelValues?.[datumIndex],\n        sectorLabelValues?.[datumIndex],\n        legendItemValues?.[datumIndex]\n      );\n      if (legendItemKey && labels.legendItem !== void 0) {\n        labelParts.push(labels.legendItem.text);\n      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {\n        labelParts.push(labels.calloutLabel?.text);\n      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {\n        labelParts.push(labels.sectorLabel?.text);\n      }\n      if (labelParts.length === 0)\n        continue;\n      legendData.push({\n        legendType: \"category\",\n        id: seriesId,\n        datum,\n        itemId: datumIndex,\n        seriesId,\n        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId: datumIndex }),\n        label: {\n          text: labelParts.join(\" - \")\n        },\n        symbol: this.legendItemSymbol(datumIndex),\n        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0,\n        hideInLegend: !showInLegend\n      });\n    }\n    return legendData;\n  }\n  // Used for grid\n  setLegendState(enabledItems) {\n    const {\n      id: seriesId,\n      ctx: { legendManager, updateService }\n    } = this;\n    enabledItems.forEach((enabled, itemId) => legendManager.toggleItem({ enabled, seriesId, itemId }));\n    legendManager.update();\n    updateService.update(4 /* SERIES_UPDATE */);\n  }\n  animateEmptyUpdateReady(_data) {\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      true,\n      this.properties.rotation,\n      this.radiusScale,\n      this.previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [this.itemSelection, this.highlightSelection, this.phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum.datum, datum.datumIndex)\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeInAnimation(this, \"callout\", animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", animationManager, this.highlightLabelSelection);\n    seriesLabelFadeInAnimation(this, \"inner\", animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateWaitingUpdateReady() {\n    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const dataDiff = processedData?.reduced?.diff?.[this.id];\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;\n    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;\n    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;\n    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    const noVisibleData = !this.nodeData.some((n) => n.enabled);\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum.datum, datum.datumIndex),\n      dataDiff\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeInAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    if (this.noVisibleData !== noVisibleData) {\n      this.noVisibleData = noVisibleData;\n      seriesLabelFadeInAnimation(this, \"inner\", this.ctx.animationManager, this.innerLabelsSelection);\n    }\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateClearingUpdateEmpty() {\n    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum.datum, datum.datumIndex)\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeOutAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeOutAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"inner\", this.ctx.animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  getDatumId(datum, datumIndex) {\n    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!this.processedData?.reduced?.animationValidation?.uniqueKeys) {\n      return `${datumIndex}`;\n    }\n    if (legendItemKey) {\n      return createDatumId(datum[legendItemKey]);\n    } else if (calloutLabelKey) {\n      return createDatumId(datum[calloutLabelKey]);\n    } else if (sectorLabelKey) {\n      return createDatumId(datum[sectorLabelKey]);\n    }\n    return `${datumIndex}`;\n  }\n};\nDonutSeries.className = \"DonutSeries\";\nDonutSeries.type = \"donut\";\n\n// packages/ag-charts-community/src/chart/series/polar/donutTheme.ts\nvar donutTheme = {\n  series: {\n    title: {\n      enabled: true,\n      fontWeight: { $ref: \"fontWeight\" },\n      fontSize: { $rem: [1.1666666666666667 /* LARGE */] },\n      fontFamily: { $ref: \"fontFamily\" },\n      color: { $ref: \"subtleTextColor\" },\n      spacing: 5\n    },\n    calloutLabel: {\n      enabled: true,\n      fontSize: { $ref: \"fontSize\" },\n      fontFamily: { $ref: \"fontFamily\" },\n      fontWeight: { $ref: \"fontWeight\" },\n      color: { $ref: \"textColor\" },\n      offset: 3,\n      minAngle: 1e-3\n    },\n    sectorLabel: {\n      enabled: true,\n      fontWeight: { $ref: \"fontWeight\" },\n      fontSize: { $ref: \"fontSize\" },\n      fontFamily: { $ref: \"fontFamily\" },\n      color: { $ref: \"backgroundColor\" },\n      positionOffset: 0,\n      positionRatio: 0.5\n    },\n    calloutLine: {\n      length: 10,\n      strokeWidth: 2\n    },\n    fillOpacity: 1,\n    strokeOpacity: 1,\n    strokeWidth: 0,\n    lineDash: [0],\n    lineDashOffset: 0,\n    rotation: 0,\n    sectorSpacing: 1,\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    },\n    innerLabels: {\n      fontSize: { $ref: \"fontSize\" },\n      fontFamily: { $ref: \"fontFamily\" },\n      fontWeight: { $ref: \"fontWeight\" },\n      color: { $ref: \"textColor\" },\n      spacing: 2\n    }\n  },\n  legend: { enabled: true }\n};\n\n// packages/ag-charts-community/src/chart/series/polar/pieTheme.ts\nvar pieTheme = {\n  series: {\n    title: {\n      enabled: true,\n      fontWeight: { $ref: \"fontWeight\" },\n      fontSize: { $rem: [1.1666666666666667 /* LARGE */] },\n      fontFamily: { $ref: \"fontFamily\" },\n      color: { $ref: \"subtleTextColor\" },\n      spacing: 5\n    },\n    calloutLabel: {\n      enabled: true,\n      fontSize: { $ref: \"fontSize\" },\n      fontFamily: { $ref: \"fontFamily\" },\n      fontWeight: { $ref: \"fontWeight\" },\n      color: { $ref: \"textColor\" },\n      offset: 3,\n      minAngle: 1e-3\n    },\n    sectorLabel: {\n      enabled: true,\n      fontWeight: { $ref: \"fontWeight\" },\n      fontSize: { $ref: \"fontSize\" },\n      fontFamily: { $ref: \"fontFamily\" },\n      color: { $ref: \"backgroundColor\" },\n      positionOffset: 0,\n      positionRatio: 0.5\n    },\n    calloutLine: {\n      length: 10,\n      strokeWidth: 2\n    },\n    fillOpacity: 1,\n    strokeOpacity: 1,\n    strokeWidth: 0,\n    lineDash: [0],\n    lineDashOffset: 0,\n    rotation: 0,\n    sectorSpacing: 1,\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    }\n  },\n  legend: { enabled: true }\n};\nvar piePaletteFactory = ({ takeColors, colorsCount }) => {\n  const { fills, strokes } = takeColors(colorsCount);\n  return { fills, strokes, calloutLine: { colors: strokes } };\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeriesModule.ts\nvar DonutSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"polar\"],\n  identifier: \"donut\",\n  moduleFactory: (ctx) => new DonutSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: donutTheme,\n  paletteFactory: piePaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeriesProperties.ts\nvar PieTitle = class extends Caption {\n  constructor() {\n    super(...arguments);\n    this.showInLegend = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], PieTitle.prototype, \"showInLegend\", 2);\nvar PieSeriesCalloutLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.offset = 3;\n    this.minAngle = 0;\n    this.minSpacing = 4;\n    this.maxCollisionOffset = 50;\n    this.avoidCollisions = true;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"offset\", 2);\n__decorateClass([\n  Validate(NUMBER.restrict({ min: 0, max: 360 }))\n], PieSeriesCalloutLabel.prototype, \"minAngle\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"maxCollisionOffset\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], PieSeriesCalloutLabel.prototype, \"avoidCollisions\", 2);\nvar PieSeriesSectorLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.positionOffset = 0;\n    this.positionRatio = 0.5;\n  }\n};\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesSectorLabel.prototype, \"positionOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesSectorLabel.prototype, \"positionRatio\", 2);\nvar PieSeriesCalloutLine = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.length = 10;\n    this.strokeWidth = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], PieSeriesCalloutLine.prototype, \"colors\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLine.prototype, \"length\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLine.prototype, \"strokeWidth\", 2);\nvar PieSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.rotation = 0;\n    this.outerRadiusOffset = 0;\n    this.outerRadiusRatio = 1;\n    this.strokeWidth = 1;\n    this.sectorSpacing = 0;\n    this.hideZeroValueSectorsInLegend = false;\n    this.title = new PieTitle();\n    this.shadow = new DropShadow();\n    this.calloutLabel = new PieSeriesCalloutLabel();\n    this.sectorLabel = new PieSeriesSectorLabel();\n    this.calloutLine = new PieSeriesCalloutLine();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], PieSeriesProperties.prototype, \"angleKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"angleName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"angleFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"radiusKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"radiusName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], PieSeriesProperties.prototype, \"radiusMin\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], PieSeriesProperties.prototype, \"radiusMax\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"calloutLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"calloutLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"sectorLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"sectorLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"legendItemKey\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], PieSeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], PieSeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], PieSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], PieSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesProperties.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesProperties.prototype, \"outerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"outerRadiusRatio\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesProperties.prototype, \"sectorSpacing\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], PieSeriesProperties.prototype, \"hideZeroValueSectorsInLegend\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"calloutLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"sectorLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"calloutLine\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeries.ts\nvar PieSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.properties.angleKey;\n    this.radiusKey = series.properties.radiusKey;\n    this.calloutLabelKey = series.properties.calloutLabelKey;\n    this.sectorLabelKey = series.properties.sectorLabelKey;\n  }\n};\nvar PieSeries = class extends PolarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      useLabelLayer: true,\n      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }\n    });\n    this.properties = new PieSeriesProperties();\n    this.phantomNodeData = void 0;\n    this.backgroundGroup = new TranslatableGroup({\n      name: `${this.id}-background`,\n      zIndex: 0 /* BACKGROUND */\n    });\n    this.previousRadiusScale = new LinearScale();\n    this.radiusScale = new LinearScale();\n    this.phantomGroup = this.backgroundGroup.appendChild(new Group({ name: \"phantom\" }));\n    this.phantomSelection = Selection.select(\n      this.phantomGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: \"pieCalloutLabels\" }));\n    this.calloutLabelSelection = new Selection(\n      this.calloutLabelGroup,\n      Group\n    );\n    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.\n    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));\n    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Marker({ shape: \"circle\" }));\n    this.surroundingRadius = void 0;\n    this.NodeEvent = PieSeriesNodeEvent;\n    this.angleScale = new LinearScale();\n    this.angleScale.domain = [0, 1];\n    this.angleScale.range = [-Math.PI, Math.PI].map((angle2) => angle2 + Math.PI / 2);\n    this.phantomGroup.opacity = 0.2;\n  }\n  get calloutNodeData() {\n    return this.phantomNodeData ?? this.nodeData;\n  }\n  attachSeries(seriesContentNode, seriesNode, annotationNode) {\n    super.attachSeries(seriesContentNode, seriesNode, annotationNode);\n    seriesContentNode.appendChild(this.backgroundGroup);\n  }\n  detachSeries(seriesContentNode, seriesNode, annotationNode) {\n    super.detachSeries(seriesContentNode, seriesNode, annotationNode);\n    seriesContentNode?.removeChild(this.backgroundGroup);\n  }\n  setSeriesIndex(index) {\n    if (!super.setSeriesIndex(index))\n      return false;\n    this.backgroundGroup.zIndex = [0 /* BACKGROUND */, index];\n    return true;\n  }\n  nodeFactory() {\n    const sector = new Sector();\n    sector.miterLimit = 1e9;\n    return sector;\n  }\n  getSeriesDomain(direction) {\n    if (direction === \"x\" /* X */) {\n      return this.angleScale.domain;\n    } else {\n      return this.radiusScale.domain;\n    }\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const {\n      visible,\n      id: seriesId,\n      ctx: { legendManager }\n    } = this;\n    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const validSector = (_value, _datum, index) => {\n      return visible && legendManager.getItemEnabled({ seriesId, itemId: index });\n    };\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const extraKeyProps = [];\n    const extraProps = [];\n    if (legendItemKey) {\n      extraKeyProps.push(keyProperty(legendItemKey, \"band\", { id: `legendItemKey` }));\n    } else if (calloutLabelKey) {\n      extraKeyProps.push(keyProperty(calloutLabelKey, \"band\", { id: `calloutLabelKey` }));\n    } else if (sectorLabelKey) {\n      extraKeyProps.push(keyProperty(sectorLabelKey, \"band\", { id: `sectorLabelKey` }));\n    }\n    const radiusScaleType = this.radiusScale.type;\n    const angleScaleType = this.angleScale.type;\n    if (radiusKey) {\n      extraProps.push(\n        rangedValueProperty(radiusKey, {\n          id: \"radiusValue\",\n          min: this.properties.radiusMin ?? 0,\n          max: this.properties.radiusMax\n        }),\n        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"radiusValue\", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)\n      );\n    }\n    if (calloutLabelKey) {\n      extraProps.push(valueProperty(calloutLabelKey, \"band\", { id: `calloutLabelValue` }));\n    }\n    if (sectorLabelKey) {\n      extraProps.push(valueProperty(sectorLabelKey, \"band\", { id: `sectorLabelValue` }));\n    }\n    if (legendItemKey) {\n      extraProps.push(valueProperty(legendItemKey, \"band\", { id: `legendItemValue` }));\n    }\n    if (angleFilterKey) {\n      extraProps.push(\n        accumulativeValueProperty(angleFilterKey, angleScaleType, {\n          id: `angleFilterValue`,\n          onlyPositive: true,\n          validation: validSector,\n          invalidValue: 0\n        }),\n        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),\n        normalisePropertyTo(\"angleFilterValue\", [0, 1], 0, 0)\n      );\n    }\n    if (animationEnabled && this.processedData?.reduced?.animationValidation?.uniqueKeys && extraKeyProps.length > 0) {\n      extraProps.push(diff(this.id, this.processedData));\n    }\n    extraProps.push(animationValidation());\n    await this.requestDataModel(dataController, this.data, {\n      props: [\n        ...extraKeyProps,\n        accumulativeValueProperty(angleKey, angleScaleType, {\n          id: `angleValue`,\n          onlyPositive: true,\n          validation: validSector,\n          invalidValue: 0\n        }),\n        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"angleValue\", [0, 1], 0, 0),\n        ...extraProps\n      ]\n    });\n    for (const valueDef of this.processedData?.defs?.values ?? []) {\n      const { id, missing, property } = valueDef;\n      const missCount = getMissCount(this, missing);\n      if (id !== \"angleRaw\" && missCount > 0) {\n        logger_exports.warnOnce(\n          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? \"s\" : \"\"}`\n        );\n      }\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  maybeRefreshNodeData() {\n    if (!this.nodeDataRefresh)\n      return;\n    const { nodeData = [], phantomNodeData } = this.createNodeData() ?? {};\n    this.nodeData = nodeData;\n    this.phantomNodeData = phantomNodeData;\n    this.nodeDataRefresh = false;\n  }\n  getProcessedDataValues(dataModel, processedData) {\n    const angleValues = dataModel.resolveColumnById(this, `angleValue`, processedData);\n    const angleRawValues = dataModel.resolveColumnById(this, `angleRaw`, processedData);\n    const angleFilterValues = this.properties.angleFilterKey != null ? dataModel.resolveColumnById(this, `angleFilterValue`, processedData) : void 0;\n    const angleFilterRawValues = this.properties.angleFilterKey != null ? dataModel.resolveColumnById(this, `angleFilterRaw`, processedData) : void 0;\n    const radiusValues = this.properties.radiusKey ? dataModel.resolveColumnById(this, `radiusValue`, processedData) : void 0;\n    const radiusRawValues = this.properties.radiusKey ? dataModel.resolveColumnById(this, `radiusRaw`, processedData) : void 0;\n    const calloutLabelValues = this.properties.calloutLabelKey ? dataModel.resolveColumnById(this, `calloutLabelValue`, processedData) : void 0;\n    const sectorLabelValues = this.properties.sectorLabelKey ? dataModel.resolveColumnById(this, `sectorLabelValue`, processedData) : void 0;\n    const legendItemValues = this.properties.legendItemKey ? dataModel.resolveColumnById(this, `legendItemValue`, processedData) : void 0;\n    return {\n      angleValues,\n      angleRawValues,\n      angleFilterValues,\n      angleFilterRawValues,\n      radiusValues,\n      radiusRawValues,\n      calloutLabelValues,\n      sectorLabelValues,\n      legendItemValues\n    };\n  }\n  createNodeData() {\n    const {\n      id: seriesId,\n      processedData,\n      dataModel,\n      angleScale,\n      ctx: { legendManager },\n      visible\n    } = this;\n    const { rotation } = this.properties;\n    if (!dataModel || processedData?.type !== \"ungrouped\")\n      return;\n    const {\n      angleValues,\n      angleRawValues,\n      angleFilterValues,\n      angleFilterRawValues,\n      radiusValues,\n      radiusRawValues,\n      calloutLabelValues,\n      sectorLabelValues,\n      legendItemValues\n    } = this.getProcessedDataValues(dataModel, processedData);\n    const useFilterAngles = angleFilterRawValues?.some((filterRawValue, index) => {\n      return filterRawValue > angleRawValues[index];\n    }) ?? false;\n    let currentStart = 0;\n    let sum2 = 0;\n    const nodes = [];\n    const phantomNodes = angleFilterRawValues != null ? [] : void 0;\n    const rawData = processedData.dataSources.get(this.id) ?? [];\n    const invalidData = processedData.invalidData?.get(this.id);\n    rawData.forEach((datum, datumIndex) => {\n      if (invalidData?.[datumIndex] === true)\n        return;\n      const currentValue = useFilterAngles ? angleFilterValues[datumIndex] : angleValues[datumIndex];\n      const crossFilterScale = angleFilterRawValues != null && !useFilterAngles ? Math.sqrt(angleFilterRawValues[datumIndex] / angleRawValues[datumIndex]) : 1;\n      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      currentStart = currentValue;\n      sum2 += currentValue;\n      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      const span = Math.abs(endAngle - startAngle);\n      const midAngle = startAngle + span / 2;\n      const angleValue = angleRawValues[datumIndex];\n      const radiusRaw = radiusValues?.[datumIndex] ?? 1;\n      const radius = radiusRaw * crossFilterScale;\n      const radiusValue = radiusRawValues?.[datumIndex];\n      const legendItemValue = legendItemValues?.[datumIndex];\n      const nodeLabels = this.getLabels(\n        datum,\n        midAngle,\n        span,\n        true,\n        calloutLabelValues?.[datumIndex],\n        sectorLabelValues?.[datumIndex],\n        legendItemValue\n      );\n      const sectorFormat = this.getSectorFormat(datum, datumIndex, false);\n      const node = {\n        itemId: datumIndex,\n        series: this,\n        datum,\n        datumIndex,\n        angleValue,\n        midAngle,\n        midCos: Math.cos(midAngle),\n        midSin: Math.sin(midAngle),\n        startAngle,\n        endAngle,\n        radius,\n        innerRadius: Math.max(this.radiusScale.convert(0), 0),\n        outerRadius: Math.max(this.radiusScale.convert(radius), 0),\n        sectorFormat,\n        radiusValue,\n        legendItemValue,\n        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId: datumIndex }),\n        ...nodeLabels\n      };\n      nodes.push(node);\n      if (phantomNodes != null) {\n        phantomNodes.push({\n          ...node,\n          radius: 1,\n          innerRadius: Math.max(this.radiusScale.convert(0), 0),\n          outerRadius: Math.max(this.radiusScale.convert(1), 0)\n        });\n      }\n    });\n    this.zerosumOuterRing.visible = sum2 === 0;\n    return {\n      itemId: seriesId,\n      nodeData: nodes,\n      labelData: nodes,\n      phantomNodeData: phantomNodes\n    };\n  }\n  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {\n    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;\n    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;\n    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;\n    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {\n      return {};\n    }\n    const labelFormatterParams = {\n      datum,\n      angleKey: this.properties.angleKey,\n      angleName: this.properties.angleName,\n      radiusKey: this.properties.radiusKey,\n      radiusName: this.properties.radiusName,\n      calloutLabelKey: this.properties.calloutLabelKey,\n      calloutLabelName: this.properties.calloutLabelName,\n      sectorLabelKey: this.properties.sectorLabelKey,\n      sectorLabelName: this.properties.sectorLabelName,\n      legendItemKey: this.properties.legendItemKey\n    };\n    const result = {};\n    if (calloutLabelKey && span >= toRadians(calloutLabel.minAngle)) {\n      result.calloutLabel = {\n        ...this.getTextAlignment(midAngle),\n        text: this.getLabelText(calloutLabel, {\n          ...labelFormatterParams,\n          value: calloutLabelValue\n        }),\n        hidden: false,\n        collisionTextAlign: void 0,\n        collisionOffsetY: 0,\n        box: void 0\n      };\n    }\n    if (sectorLabelKey) {\n      result.sectorLabel = {\n        text: this.getLabelText(sectorLabel, {\n          ...labelFormatterParams,\n          value: sectorLabelValue\n        })\n      };\n    }\n    if (legendItemKey != null && legendItemValue != null) {\n      result.legendItem = { key: legendItemKey, text: legendItemValue };\n    }\n    return result;\n  }\n  getTextAlignment(midAngle) {\n    const quadrantTextOpts = [\n      { textAlign: \"center\", textBaseline: \"bottom\" },\n      { textAlign: \"left\", textBaseline: \"middle\" },\n      { textAlign: \"center\", textBaseline: \"hanging\" },\n      { textAlign: \"right\", textBaseline: \"middle\" }\n    ];\n    const midAngle180 = normalizeAngle180(midAngle);\n    const quadrantStart = -0.75 * Math.PI;\n    const quadrantOffset = midAngle180 - quadrantStart;\n    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));\n    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);\n    return quadrantTextOpts[quadrantIndex];\n  }\n  getSectorFormat(datum, datumIndex, highlighted) {\n    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, fills, strokes, itemStyler } = this.properties;\n    const defaultStroke = strokes[datumIndex % strokes.length];\n    const { fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      {\n        fill: fills.length > 0 ? fills[datumIndex % fills.length] : void 0,\n        stroke: defaultStroke,\n        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n        strokeOpacity: this.getOpacity()\n      },\n      this.properties\n    );\n    let format;\n    if (itemStyler) {\n      format = this.cachedDatumCallback(\n        this.getDatumId(datum, datumIndex) + (highlighted ? \"-highlight\" : \"-hide\"),\n        () => itemStyler({\n          datum,\n          angleKey,\n          radiusKey,\n          calloutLabelKey,\n          sectorLabelKey,\n          legendItemKey,\n          fill,\n          strokeOpacity,\n          stroke: stroke2,\n          strokeWidth,\n          fillOpacity,\n          lineDash,\n          lineDashOffset,\n          cornerRadius,\n          highlighted,\n          seriesId: this.id\n        })\n      );\n    }\n    return {\n      fill: format?.fill ?? fill,\n      fillOpacity: format?.fillOpacity ?? fillOpacity,\n      stroke: format?.stroke ?? stroke2,\n      strokeWidth: format?.strokeWidth ?? strokeWidth,\n      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n      lineDash: format?.lineDash ?? lineDash,\n      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n      cornerRadius: format?.cornerRadius ?? cornerRadius\n    };\n  }\n  getOuterRadius() {\n    return Math.max(this.radius * this.properties.outerRadiusRatio + this.properties.outerRadiusOffset, 0);\n  }\n  updateRadiusScale(resize) {\n    const newRange = [0, this.getOuterRadius()];\n    this.radiusScale.range = newRange;\n    if (resize) {\n      this.previousRadiusScale.range = newRange;\n    }\n    const setRadii = (d) => ({\n      ...d,\n      innerRadius: Math.max(this.radiusScale.convert(0), 0),\n      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)\n    });\n    this.nodeData = this.nodeData.map(setRadii);\n    this.phantomNodeData = this.phantomNodeData?.map(setRadii);\n  }\n  getTitleTranslationY() {\n    const outerRadius = Math.max(0, this.radiusScale.range[1]);\n    if (outerRadius === 0) {\n      return NaN;\n    }\n    const spacing = this.properties.title?.spacing ?? 0;\n    const titleOffset = 2 + spacing;\n    const dy = Math.max(0, -outerRadius);\n    return -outerRadius - titleOffset - dy;\n  }\n  update({ seriesRect }) {\n    const { title } = this.properties;\n    const newNodeDataDependencies = {\n      seriesRectWidth: seriesRect?.width,\n      seriesRectHeight: seriesRect?.height\n    };\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n    }\n    this.maybeRefreshNodeData();\n    this.updateTitleNodes();\n    this.updateRadiusScale(resize);\n    this.contentGroup.translationX = this.centerX;\n    this.contentGroup.translationY = this.centerY;\n    this.highlightGroup.translationX = this.centerX;\n    this.highlightGroup.translationY = this.centerY;\n    this.backgroundGroup.translationX = this.centerX;\n    this.backgroundGroup.translationY = this.centerY;\n    if (this.labelGroup) {\n      this.labelGroup.translationX = this.centerX;\n      this.labelGroup.translationY = this.centerY;\n    }\n    if (title) {\n      const dy = this.getTitleTranslationY();\n      title.node.y = isFinite(dy) ? dy : 0;\n      const titleBox = title.node.getBBox();\n      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox);\n    }\n    this.zerosumOuterRing.fillOpacity = 0;\n    this.zerosumOuterRing.stroke = this.properties.calloutLabel.color;\n    this.zerosumOuterRing.strokeWidth = 1;\n    this.zerosumOuterRing.strokeOpacity = 1;\n    this.updateNodeMidPoint();\n    this.updateSelections();\n    this.updateNodes(seriesRect);\n  }\n  updateTitleNodes() {\n    const { oldTitle } = this;\n    const { title } = this.properties;\n    if (oldTitle !== title) {\n      if (oldTitle) {\n        this.labelGroup?.removeChild(oldTitle.node);\n      }\n      if (title) {\n        title.node.textBaseline = \"bottom\";\n        this.labelGroup?.appendChild(title.node);\n      }\n      this.oldTitle = title;\n    }\n  }\n  updateNodeMidPoint() {\n    const setMidPoint = (d) => {\n      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;\n      d.midPoint = {\n        x: d.midCos * Math.max(0, radius),\n        y: d.midSin * Math.max(0, radius)\n      };\n    };\n    this.nodeData.forEach(setMidPoint);\n    this.phantomNodeData?.forEach(setMidPoint);\n  }\n  updateSelections() {\n    const {\n      itemSelection,\n      highlightSelection,\n      phantomSelection,\n      highlightLabelSelection,\n      calloutLabelSelection,\n      labelSelection\n    } = this;\n    const highlightedNodeData = this.nodeData.map((datum) => ({\n      ...datum,\n      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied\n      // between normal and highlighted cases.\n      sectorFormat: { ...datum.sectorFormat }\n    }));\n    const update = (selection, nodeData) => {\n      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum.datum, datum.datumIndex));\n      if (this.ctx.animationManager.isSkipped()) {\n        selection.cleanup();\n      }\n    };\n    update(itemSelection, this.nodeData);\n    update(highlightSelection, highlightedNodeData);\n    update(phantomSelection, this.phantomNodeData ?? []);\n    calloutLabelSelection.update(this.calloutNodeData, (group) => {\n      const line = new Line();\n      line.tag = 0 /* Callout */;\n      line.pointerEvents = 1 /* None */;\n      group.appendChild(line);\n      const text2 = new Text();\n      text2.tag = 1 /* Label */;\n      text2.pointerEvents = 1 /* None */;\n      group.appendChild(text2);\n    });\n    labelSelection.update(this.nodeData);\n    highlightLabelSelection.update(highlightedNodeData);\n  }\n  updateNodes(seriesRect) {\n    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\n    const { visible } = this;\n    this.backgroundGroup.visible = visible;\n    this.contentGroup.visible = visible;\n    this.highlightGroup.visible = visible && highlightedDatum?.series === this;\n    this.highlightLabel.visible = visible && highlightedDatum?.series === this;\n    if (this.labelGroup) {\n      this.labelGroup.visible = visible;\n    }\n    this.contentGroup.opacity = this.getOpacity();\n    const animationDisabled = this.ctx.animationManager.isSkipped();\n    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {\n      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);\n      datum.sectorFormat.fill = format.fill;\n      datum.sectorFormat.stroke = format.stroke;\n      if (animationDisabled) {\n        sector.startAngle = datum.startAngle;\n        sector.endAngle = datum.endAngle;\n        sector.innerRadius = datum.innerRadius;\n        sector.outerRadius = datum.outerRadius;\n      }\n      if (isDatumHighlighted || animationDisabled) {\n        sector.fill = format.fill;\n        sector.stroke = format.stroke;\n      }\n      sector.strokeWidth = format.strokeWidth;\n      sector.fillOpacity = format.fillOpacity;\n      sector.strokeOpacity = format.strokeOpacity;\n      sector.lineDash = format.lineDash;\n      sector.lineDashOffset = format.lineDashOffset;\n      sector.cornerRadius = format.cornerRadius;\n      sector.fillShadow = this.properties.shadow;\n      const inset = Math.max(\n        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,\n        0\n      );\n      sector.inset = inset;\n      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? \"miter\" : \"round\";\n    };\n    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.highlightSelection.each((node, datum, index) => {\n      updateSectorFn(node, datum, index, true);\n      node.visible = datum.itemId === highlightedDatum?.itemId;\n    });\n    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.updateCalloutLineNodes();\n    this.updateCalloutLabelNodes(seriesRect);\n    this.updateSectorLabelNodes();\n    this.updateZerosumRings();\n    this.animationState.transition(\"update\");\n  }\n  updateCalloutLineNodes() {\n    const { calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const calloutStrokeWidth = calloutLine.strokeWidth;\n    const calloutColors = calloutLine.colors ?? this.properties.strokes;\n    const { offset: offset4 } = this.properties.calloutLabel;\n    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {\n      const datum = line.datum;\n      const { calloutLabel: label, outerRadius } = datum;\n      if (label?.text && !label.hidden && outerRadius !== 0) {\n        line.visible = true;\n        line.strokeWidth = calloutStrokeWidth;\n        line.stroke = calloutColors[index % calloutColors.length];\n        line.fill = void 0;\n        const x1 = datum.midCos * outerRadius;\n        const y1 = datum.midSin * outerRadius;\n        let x2 = datum.midCos * (outerRadius + calloutLength);\n        let y2 = datum.midSin * (outerRadius + calloutLength);\n        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;\n        if (isMoved && label.box != null) {\n          const box = label.box;\n          let cx = x2;\n          let cy = y2;\n          if (x2 < box.x) {\n            cx = box.x;\n          } else if (x2 > box.x + box.width) {\n            cx = box.x + box.width;\n          }\n          if (y2 < box.y) {\n            cy = box.y;\n          } else if (y2 > box.y + box.height) {\n            cy = box.y + box.height;\n          }\n          const dx = cx - x2;\n          const dy = cy - y2;\n          const length2 = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          const paddedLength = length2 - offset4;\n          if (paddedLength > 0) {\n            x2 = x2 + dx * paddedLength / length2;\n            y2 = y2 + dy * paddedLength / length2;\n          }\n        }\n        line.x1 = x1;\n        line.y1 = y1;\n        line.x2 = x2;\n        line.y2 = y2;\n      } else {\n        line.visible = false;\n      }\n    });\n  }\n  getLabelOverflow(text2, box, seriesRect) {\n    const seriesLeft = -this.centerX;\n    const seriesRight = seriesLeft + seriesRect.width;\n    const seriesTop = -this.centerY;\n    const seriesBottom = seriesTop + seriesRect.height;\n    const errPx = 1;\n    let visibleTextPart = 1;\n    if (box.x + errPx < seriesLeft) {\n      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;\n    } else if (box.x + box.width - errPx > seriesRight) {\n      visibleTextPart = (seriesRight - box.x) / box.width;\n    }\n    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;\n    const textLength = visibleTextPart === 1 ? text2.length : Math.floor(text2.length * visibleTextPart) - 1;\n    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);\n    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };\n  }\n  bboxIntersectsSurroundingSeries(box) {\n    const { surroundingRadius } = this;\n    if (surroundingRadius == null) {\n      return false;\n    }\n    const corners = [\n      { x: box.x, y: box.y },\n      { x: box.x + box.width, y: box.y },\n      { x: box.x + box.width, y: box.y + box.height },\n      { x: box.x, y: box.y + box.height }\n    ];\n    const sur2 = surroundingRadius ** 2;\n    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);\n  }\n  computeCalloutLabelCollisionOffsets() {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const { offset: offset4, minSpacing } = calloutLabel;\n    const innerRadius = radiusScale.convert(0);\n    const shouldSkip = (datum) => {\n      const label = datum.calloutLabel;\n      return !label || datum.outerRadius === 0;\n    };\n    const fullData = this.calloutNodeData;\n    const data = fullData.filter((t) => !shouldSkip(t));\n    data.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return;\n      label.hidden = false;\n      label.collisionTextAlign = void 0;\n      label.collisionOffsetY = 0;\n    });\n    if (data.length <= 1) {\n      return;\n    }\n    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);\n    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);\n    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const getTextBBox = (datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return BBox.zero.clone();\n      const labelRadius = datum.outerRadius + calloutLine.length + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const textAlign = label.collisionTextAlign ?? label.textAlign;\n      const textBaseline = label.textBaseline;\n      return Text.computeBBox(label.text, x, y, {\n        font: this.properties.calloutLabel,\n        textAlign,\n        textBaseline\n      });\n    };\n    const avoidNeighbourYCollision = (label, next, direction) => {\n      const box = getTextBBox(label).grow(minSpacing / 2);\n      const other = getTextBBox(next).grow(minSpacing / 2);\n      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === \"to-top\" ? box.y < other.y + other.height : box.y + box.height > other.y);\n      if (collidesOrBehind) {\n        next.calloutLabel.collisionOffsetY = direction === \"to-top\" ? box.y - other.y - other.height : box.y + box.height - other.y;\n      }\n    };\n    const avoidYCollisions = (labels) => {\n      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];\n      const midIndex = labels.indexOf(midLabel);\n      for (let i = midIndex - 1; i >= 0; i--) {\n        const prev = labels[i + 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-top\");\n      }\n      for (let i = midIndex + 1; i < labels.length; i++) {\n        const prev = labels[i - 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-bottom\");\n      }\n    };\n    const avoidXCollisions = (labels) => {\n      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);\n      const boxes = labels.map((label) => getTextBBox(label));\n      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));\n      let labelsCollideLabelsByX = false;\n      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {\n        const box = paddedBoxes[i];\n        for (let j = i + 1; j < labels.length; j++) {\n          const other = paddedBoxes[j];\n          if (box.collidesBBox(other)) {\n            labelsCollideLabelsByX = true;\n            break;\n          }\n        }\n      }\n      const sectors = fullData.map((datum) => {\n        const { startAngle, endAngle, outerRadius } = datum;\n        return { startAngle, endAngle, innerRadius, outerRadius };\n      });\n      const labelsCollideSectors = boxes.some((box) => {\n        return sectors.some((sector) => boxCollidesSector(box, sector));\n      });\n      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {\n        return;\n      }\n      labels.filter((d) => d.calloutLabel.textAlign === \"center\").forEach((d) => {\n        const label = d.calloutLabel;\n        if (d.midCos < 0) {\n          label.collisionTextAlign = \"right\";\n        } else if (d.midCos > 0) {\n          label.collisionTextAlign = \"left\";\n        } else {\n          label.collisionTextAlign = \"center\";\n        }\n      });\n    };\n    avoidYCollisions(leftLabels);\n    avoidYCollisions(rightLabels);\n    avoidXCollisions(topLabels);\n    avoidXCollisions(bottomLabels);\n  }\n  updateCalloutLabelNodes(seriesRect) {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, color } = calloutLabel;\n    const tempTextNode = new Text();\n    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text2) => {\n      const { datum } = text2;\n      const label = datum.calloutLabel;\n      const radius = radiusScale.convert(datum.radius);\n      const outerRadius = Math.max(0, radius);\n      if (!label?.text || outerRadius === 0 || label.hidden) {\n        text2.visible = false;\n        return;\n      }\n      const labelRadius = outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const align2 = {\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      };\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.properties.calloutLabel);\n      tempTextNode.setAlign(align2);\n      const box = tempTextNode.getBBox();\n      let displayText = label.text;\n      let visible = true;\n      if (calloutLabel.avoidCollisions) {\n        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\n        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\\u2026`;\n        visible = !hasVerticalOverflow;\n      }\n      text2.text = displayText;\n      text2.x = x;\n      text2.y = y;\n      text2.setFont(this.properties.calloutLabel);\n      text2.setAlign(align2);\n      text2.fill = color;\n      text2.visible = visible;\n    });\n  }\n  computeLabelsBBox(options, seriesRect) {\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;\n    if (!calloutLabel.avoidCollisions) {\n      return null;\n    }\n    this.maybeRefreshNodeData();\n    this.updateRadiusScale(false);\n    this.computeCalloutLabelCollisionOffsets();\n    const textBoxes = [];\n    const text2 = new Text();\n    let titleBox;\n    const { title } = this.properties;\n    if (title?.text && title.enabled) {\n      const dy = this.getTitleTranslationY();\n      if (isFinite(dy)) {\n        text2.text = title.text;\n        text2.x = 0;\n        text2.y = dy;\n        text2.setFont(title);\n        text2.setAlign({\n          textBaseline: \"bottom\",\n          textAlign: \"center\"\n        });\n        titleBox = text2.getBBox();\n        textBoxes.push(titleBox);\n      }\n    }\n    this.calloutNodeData.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (!label || datum.outerRadius === 0) {\n        return null;\n      }\n      const labelRadius = datum.outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      text2.text = label.text;\n      text2.x = x;\n      text2.y = y;\n      text2.setFont(this.properties.calloutLabel);\n      text2.setAlign({\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      });\n      const box = text2.getBBox();\n      label.box = box;\n      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {\n        label.hidden = true;\n        return;\n      }\n      if (titleBox) {\n        const seriesTop = -this.centerY;\n        const titleCleanArea = new BBox(\n          titleBox.x - minSpacing,\n          seriesTop,\n          titleBox.width + 2 * minSpacing,\n          titleBox.y + titleBox.height + minSpacing - seriesTop\n        );\n        if (box.collidesBBox(titleCleanArea)) {\n          label.hidden = true;\n          return;\n        }\n      }\n      if (options.hideWhenNecessary) {\n        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(\n          label.text,\n          box,\n          seriesRect\n        );\n        const isTooShort = label.text.length > 2 && textLength < 2;\n        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {\n          label.hidden = true;\n          return;\n        }\n      }\n      label.hidden = false;\n      textBoxes.push(box);\n    });\n    if (textBoxes.length === 0) {\n      return null;\n    }\n    return BBox.merge(textBoxes);\n  }\n  updateSectorLabelNodes() {\n    const { radiusScale } = this;\n    const innerRadius = radiusScale.convert(0);\n    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;\n    const isDonut = innerRadius > 0;\n    const singleVisibleSector = this.ctx.legendManager.getData(this.id)?.filter((d) => d.enabled).length === 1;\n    const updateSectorLabel = (text2, datum) => {\n      const { sectorLabel, outerRadius, startAngle, endAngle } = datum;\n      let isTextVisible = false;\n      if (sectorLabel && outerRadius !== 0) {\n        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;\n        text2.fill = color;\n        text2.fontStyle = fontStyle;\n        text2.fontWeight = fontWeight;\n        text2.fontSize = fontSize;\n        text2.fontFamily = fontFamily;\n        text2.text = sectorLabel.text;\n        const shouldPutTextInCenter = !isDonut && singleVisibleSector;\n        if (shouldPutTextInCenter) {\n          text2.x = 0;\n          text2.y = 0;\n        } else {\n          text2.x = datum.midCos * labelRadius;\n          text2.y = datum.midSin * labelRadius;\n        }\n        text2.textAlign = \"center\";\n        text2.textBaseline = \"middle\";\n        const bbox = text2.getBBox();\n        const corners = [\n          [bbox.x, bbox.y],\n          [bbox.x + bbox.width, bbox.y],\n          [bbox.x + bbox.width, bbox.y + bbox.height],\n          [bbox.x, bbox.y + bbox.height]\n        ];\n        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };\n        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {\n          isTextVisible = true;\n        }\n      }\n      text2.visible = isTextVisible;\n    };\n    this.labelSelection.each(updateSectorLabel);\n    this.highlightLabelSelection.each(updateSectorLabel);\n  }\n  updateZerosumRings() {\n    this.zerosumOuterRing.size = this.getOuterRadius() * 2;\n  }\n  pickNodeClosestDatum(point) {\n    return pickByMatchingAngle(this, point);\n  }\n  getTooltipContent(nodeDatum) {\n    const { id: seriesId, dataModel, processedData, properties } = this;\n    const {\n      legendItemKey,\n      calloutLabelKey,\n      calloutLabelName,\n      sectorLabelKey,\n      sectorLabelName,\n      angleKey,\n      angleName,\n      radiusKey,\n      radiusName,\n      tooltip\n    } = properties;\n    const title = this.properties.title.text;\n    if (!dataModel || !processedData)\n      return;\n    const { datumIndex } = nodeDatum;\n    const datum = processedData.dataSources.get(this.id)?.[datumIndex];\n    const { angleRawValues, legendItemValues, calloutLabelValues, sectorLabelValues } = this.getProcessedDataValues(\n      dataModel,\n      processedData\n    );\n    const angleRawValue = angleRawValues[datumIndex];\n    const label = legendItemValues?.[datumIndex] ?? (calloutLabelKey === angleKey ? void 0 : calloutLabelValues?.[datumIndex]) ?? (sectorLabelKey === angleKey ? void 0 : sectorLabelValues?.[datumIndex]) ?? angleName;\n    return tooltip.formatTooltip(\n      {\n        title,\n        symbol: this.legendItemSymbol(datumIndex),\n        data: [\n          {\n            label,\n            fallbackLabel: angleKey,\n            value: formatValue(angleRawValue, 3)\n          }\n        ]\n      },\n      {\n        seriesId,\n        datum,\n        title: angleName,\n        legendItemKey,\n        calloutLabelKey,\n        calloutLabelName,\n        sectorLabelKey,\n        sectorLabelName,\n        angleKey,\n        angleName,\n        radiusKey,\n        radiusName,\n        ...this.getSectorFormat(datum, datumIndex, false)\n      }\n    );\n  }\n  legendItemSymbol(datumIndex) {\n    const datum = this.processedData?.dataSources.get(this.id)?.[datumIndex];\n    const sectorFormat = this.getSectorFormat(datum, datumIndex, false);\n    return {\n      marker: {\n        fill: sectorFormat.fill,\n        stroke: sectorFormat.stroke,\n        fillOpacity: this.properties.fillOpacity,\n        strokeOpacity: this.properties.strokeOpacity,\n        strokeWidth: this.properties.strokeWidth,\n        lineDash: this.properties.lineDash,\n        lineDashOffset: this.properties.lineDashOffset\n      }\n    };\n  }\n  getLegendData(legendType) {\n    const {\n      id: seriesId,\n      visible,\n      processedData,\n      dataModel,\n      ctx: { legendManager }\n    } = this;\n    if (!dataModel || !processedData || legendType !== \"category\") {\n      return [];\n    }\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey, showInLegend } = this.properties;\n    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey)) {\n      return [];\n    }\n    const { calloutLabelValues, sectorLabelValues, legendItemValues, angleRawValues } = this.getProcessedDataValues(\n      dataModel,\n      processedData\n    );\n    const titleText = this.properties.title?.showInLegend && this.properties.title.text;\n    const legendData = [];\n    const hideZeros = this.properties.hideZeroValueSectorsInLegend;\n    const rawData = processedData.dataSources.get(this.id);\n    const invalidData = processedData.invalidData?.get(this.id);\n    for (let datumIndex = 0; datumIndex < processedData.input.count; datumIndex++) {\n      const datum = rawData?.[datumIndex];\n      const angleRawValue = angleRawValues[datumIndex];\n      if (invalidData?.[datumIndex] === true || hideZeros && angleRawValue === 0) {\n        continue;\n      }\n      const labelParts = [];\n      if (titleText) {\n        labelParts.push(titleText);\n      }\n      const labels = this.getLabels(\n        datum,\n        2 * Math.PI,\n        2 * Math.PI,\n        false,\n        calloutLabelValues?.[datumIndex],\n        sectorLabelValues?.[datumIndex],\n        legendItemValues?.[datumIndex]\n      );\n      if (legendItemKey && labels.legendItem !== void 0) {\n        labelParts.push(labels.legendItem.text);\n      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {\n        labelParts.push(labels.calloutLabel?.text);\n      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {\n        labelParts.push(labels.sectorLabel?.text);\n      }\n      if (labelParts.length === 0)\n        continue;\n      legendData.push({\n        legendType: \"category\",\n        id: seriesId,\n        datum,\n        itemId: datumIndex,\n        seriesId,\n        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId: datumIndex }),\n        label: {\n          text: labelParts.join(\" - \")\n        },\n        symbol: this.legendItemSymbol(datumIndex),\n        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0,\n        hideInLegend: !showInLegend\n      });\n    }\n    return legendData;\n  }\n  // Used for grid\n  setLegendState(enabledItems) {\n    const {\n      id: seriesId,\n      ctx: { legendManager, updateService }\n    } = this;\n    enabledItems.forEach((enabled, itemId) => legendManager.toggleItem({ enabled, seriesId, itemId }));\n    legendManager.update();\n    updateService.update(4 /* SERIES_UPDATE */);\n  }\n  animateEmptyUpdateReady(_data) {\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      true,\n      this.properties.rotation,\n      this.radiusScale,\n      this.previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [this.itemSelection, this.highlightSelection, this.phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum.datum, datum.datumIndex)\n    );\n    seriesLabelFadeInAnimation(this, \"callout\", animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateWaitingUpdateReady() {\n    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const dataDiff = processedData?.reduced?.diff?.[this.id];\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;\n    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;\n    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;\n    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum.datum, datum.datumIndex),\n      dataDiff\n    );\n    seriesLabelFadeInAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateClearingUpdateEmpty() {\n    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum.datum, datum.datumIndex)\n    );\n    seriesLabelFadeOutAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeOutAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  getDatumId(datum, datumIndex) {\n    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!this.processedData?.reduced?.animationValidation?.uniqueKeys) {\n      return `${datumIndex}`;\n    }\n    if (legendItemKey) {\n      return createDatumId(datum[legendItemKey]);\n    } else if (calloutLabelKey) {\n      return createDatumId(datum[calloutLabelKey]);\n    } else if (sectorLabelKey) {\n      return createDatumId(datum[sectorLabelKey]);\n    }\n    return `${datumIndex}`;\n  }\n};\nPieSeries.className = \"PieSeries\";\nPieSeries.type = \"pie\";\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeriesModule.ts\nvar PieSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"polar\"],\n  identifier: \"pie\",\n  moduleFactory: (ctx) => new PieSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: pieTheme,\n  paletteFactory: piePaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/factory/registerInbuiltModules.ts\nfunction registerInbuiltModules() {\n  moduleRegistry.register(\n    BackgroundModule,\n    CommunityLegendModule,\n    LocaleModule,\n    AreaSeriesModule,\n    BarSeriesModule,\n    BubbleSeriesModule,\n    LineSeriesModule,\n    ScatterSeriesModule,\n    DonutSeriesModule,\n    PieSeriesModule,\n    HistogramSeriesModule\n  );\n  for (const AxisConstructor of [NumberAxis, CategoryAxis, TimeAxis, GroupedCategoryAxis, LogAxis]) {\n    axisRegistry.register(AxisConstructor.type, {\n      moduleFactory: (ctx) => new AxisConstructor(ctx)\n    });\n  }\n}\n\n// packages/ag-charts-community/src/chart/factory/setupModules.ts\nfunction setupModules() {\n  for (const m of moduleRegistry.modules) {\n    if (m.packageType === \"enterprise\" && !verifyIfModuleExpected(m)) {\n      logger_exports.errorOnce(\"Unexpected enterprise module registered: \" + m.identifier);\n    }\n    if (m.type === \"root\" && m.themeTemplate) {\n      for (const chartType of m.chartTypes) {\n        chartDefaults.set(chartType, m.themeTemplate);\n      }\n    }\n    if (m.type === \"series\") {\n      if (m.chartTypes.length > 1) {\n        throw new Error(`AG Charts - Module definition error: ${m.identifier}`);\n      }\n      seriesRegistry.register(m.identifier, m);\n    }\n    if (m.type === \"series-option\" && m.themeTemplate) {\n      for (const seriesType of m.seriesTypes) {\n        seriesRegistry.setThemeTemplate(seriesType, m.themeTemplate);\n      }\n    }\n    if (m.type === \"axis-option\" && m.themeTemplate) {\n      for (const axisType of m.axisTypes) {\n        const axisTypeTheme = axisRegistry.getThemeTemplate(axisType);\n        const theme = mergeDefaults(m.themeTemplate, axisTypeTheme);\n        axisRegistry.setThemeTemplate(axisType, theme);\n      }\n    }\n    if (m.type === \"axis\") {\n      axisRegistry.register(m.identifier, m);\n    }\n    if (m.type === \"legend\") {\n      legendRegistry.register(m.identifier, m);\n    }\n  }\n  if (moduleRegistry.hasEnterpriseModules()) {\n    const expectedButUnused = getUnusedExpectedModules();\n    if (expectedButUnused.length > 0) {\n      logger_exports.errorOnce(\"Enterprise modules expected but not registered: \", expectedButUnused);\n    }\n  }\n}\n\n// packages/ag-charts-community/src/chart/axis/polarAxis.ts\nvar PolarAxis = class extends Axis {\n  constructor() {\n    super(...arguments);\n    this.shape = \"polygon\";\n    this.innerRadiusRatio = 0;\n    this.defaultTickMinSpacing = 20;\n  }\n  updatePosition() {\n    super.updatePosition();\n    const selectionCtx = prepareAxisAnimationContext(this);\n    const resetAxisFn = resetAxisSelectionFn(selectionCtx);\n    this.axisGroup.setProperties(this.getAxisTransform());\n    this.gridLineGroupSelection.each(resetAxisFn);\n    this.tickLineGroupSelection.each(resetAxisFn);\n    this.tickLabelGroupSelection.each(resetAxisLabelSelectionFn());\n  }\n  computeLabelsBBox(_options, _seriesRect) {\n    return null;\n  }\n  computeRange() {\n  }\n  getAxisLinePoints() {\n    return void 0;\n  }\n};\n__decorateClass([\n  Validate(UNION([\"polygon\", \"circle\"], \"a polar axis shape\"))\n], PolarAxis.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PolarAxis.prototype, \"innerRadiusRatio\", 2);\n\n// packages/ag-charts-community/src/chart/polarChart.ts\nvar PolarChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    this.padding = new Padding(40);\n    this.ctx.axisManager.axisGroup.zIndex = 6 /* AXIS_FOREGROUND */;\n  }\n  getChartType() {\n    return \"polar\";\n  }\n  async performLayout(ctx) {\n    const { layoutBox } = ctx;\n    layoutBox.shrink(this.seriesArea.padding.toJson());\n    const seriesRect = layoutBox.clone();\n    this.seriesRect = seriesRect;\n    this.animationRect = seriesRect;\n    this.seriesRoot.translationX = seriesRect.x;\n    this.seriesRoot.translationY = seriesRect.y;\n    await this.computeCircle(seriesRect);\n    this.axes.forEach((axis) => axis.update());\n    this.ctx.layoutManager.emitLayoutComplete(ctx, {\n      series: { visible: true, rect: seriesRect, paddedRect: seriesRect }\n    });\n  }\n  updateAxes(seriesBox, cx, cy, radius) {\n    const angleAxis = this.axes.find((axis) => axis.direction === \"x\" /* X */);\n    const radiusAxis = this.axes.find((axis) => axis.direction === \"y\" /* Y */);\n    if (!(angleAxis instanceof PolarAxis) || !(radiusAxis instanceof PolarAxis))\n      return;\n    const angleScale = angleAxis.scale;\n    const innerRadiusRatio = radiusAxis.innerRadiusRatio;\n    angleAxis.innerRadiusRatio = innerRadiusRatio;\n    angleAxis.computeRange();\n    angleAxis.gridLength = radius;\n    radiusAxis.gridAngles = angleScale.ticks({\n      nice: angleAxis.nice,\n      interval: void 0,\n      tickCount: void 0,\n      minTickCount: 0,\n      maxTickCount: Infinity\n    })?.map((value) => angleScale.convert(value));\n    radiusAxis.gridRange = angleAxis.range;\n    radiusAxis.range = [radius, radius * innerRadiusRatio];\n    [angleAxis, radiusAxis].forEach((axis) => {\n      axis.translation.x = seriesBox.x + cx;\n      axis.translation.y = seriesBox.y + cy;\n      axis.calculateLayout();\n    });\n  }\n  async computeCircle(seriesBox) {\n    const polarSeries = this.series.filter(isPolarSeries);\n    const polarAxes = this.axes.filter(isPolarAxis);\n    const setSeriesCircle = (cx, cy, r) => {\n      this.updateAxes(seriesBox, cx, cy, r);\n      polarSeries.forEach((series) => {\n        series.centerX = cx;\n        series.centerY = cy;\n        series.radius = r;\n      });\n      const pieSeries = polarSeries.filter((s) => s.type === \"donut\" || s.type === \"pie\");\n      if (pieSeries.length > 1) {\n        const innerRadii = pieSeries.map((series) => {\n          const innerRadius = series.getInnerRadius();\n          return { series, innerRadius };\n        }).sort((a, b) => a.innerRadius - b.innerRadius);\n        innerRadii.at(-1).series.surroundingRadius = void 0;\n        for (let i = 0; i < innerRadii.length - 1; i++) {\n          innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;\n        }\n      }\n    };\n    const centerX = seriesBox.width / 2;\n    const centerY = seriesBox.height / 2;\n    const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);\n    let radius = initialRadius;\n    setSeriesCircle(centerX, centerY, radius);\n    const shake = async ({ hideWhenNecessary = false } = {}) => {\n      const labelBoxes = [];\n      for (const series of iterate(polarAxes, polarSeries)) {\n        const box = await series.computeLabelsBBox({ hideWhenNecessary }, seriesBox);\n        if (box) {\n          labelBoxes.push(box);\n        }\n      }\n      if (labelBoxes.length === 0) {\n        setSeriesCircle(centerX, centerY, initialRadius);\n        return;\n      }\n      const labelBox = BBox.merge(labelBoxes);\n      const refined = this.refineCircle(labelBox, radius, seriesBox);\n      setSeriesCircle(refined.centerX, refined.centerY, refined.radius);\n      radius = refined.radius;\n    };\n    await shake();\n    await shake();\n    await shake();\n    await shake({ hideWhenNecessary: true });\n    await shake({ hideWhenNecessary: true });\n    for (const series of iterate(polarAxes, polarSeries)) {\n      await series.computeLabelsBBox({ hideWhenNecessary: true }, seriesBox);\n    }\n    return { radius, centerX, centerY };\n  }\n  refineCircle(labelsBox, radius, seriesBox) {\n    const minCircleRatio = 0.5;\n    const circleLeft = -radius;\n    const circleTop = -radius;\n    const circleRight = radius;\n    const circleBottom = radius;\n    let padLeft = Math.max(0, circleLeft - labelsBox.x);\n    let padTop = Math.max(0, circleTop - labelsBox.y);\n    let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);\n    let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);\n    padLeft = padRight = Math.max(padLeft, padRight);\n    padTop = padBottom = Math.max(padTop, padBottom);\n    const availCircleWidth = seriesBox.width - padLeft - padRight;\n    const availCircleHeight = seriesBox.height - padTop - padBottom;\n    let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;\n    const minHorizontalRadius = minCircleRatio * seriesBox.width / 2;\n    const minVerticalRadius = minCircleRatio * seriesBox.height / 2;\n    const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);\n    if (newRadius < minRadius) {\n      newRadius = minRadius;\n      const horizontalPadding = padLeft + padRight;\n      const verticalPadding = padTop + padBottom;\n      if (2 * newRadius + verticalPadding > seriesBox.height) {\n        const padHeight = seriesBox.height - 2 * newRadius;\n        if (Math.min(padTop, padBottom) * 2 > padHeight) {\n          padTop = padHeight / 2;\n          padBottom = padHeight / 2;\n        } else if (padTop > padBottom) {\n          padTop = padHeight - padBottom;\n        } else {\n          padBottom = padHeight - padTop;\n        }\n      }\n      if (2 * newRadius + horizontalPadding > seriesBox.width) {\n        const padWidth = seriesBox.width - 2 * newRadius;\n        if (Math.min(padLeft, padRight) * 2 > padWidth) {\n          padLeft = padWidth / 2;\n          padRight = padWidth / 2;\n        } else if (padLeft > padRight) {\n          padLeft = padWidth - padRight;\n        } else {\n          padRight = padWidth - padLeft;\n        }\n      }\n    }\n    const newWidth = padLeft + 2 * newRadius + padRight;\n    const newHeight = padTop + 2 * newRadius + padBottom;\n    return {\n      centerX: (seriesBox.width - newWidth) / 2 + padLeft + newRadius,\n      centerY: (seriesBox.height - newHeight) / 2 + padTop + newRadius,\n      radius: newRadius\n    };\n  }\n};\nPolarChart.className = \"PolarChart\";\nPolarChart.type = \"polar\";\nfunction isPolarSeries(series) {\n  return series instanceof PolarSeries;\n}\nfunction isPolarAxis(axis) {\n  return axis instanceof PolarAxis;\n}\n\n// packages/ag-charts-community/src/chart/polarChartModule.ts\nvar PolarChartModule = {\n  type: \"chart\",\n  name: \"polar\",\n  detect: isAgPolarChartOptions,\n  create(options, resources) {\n    return new PolarChart(options, resources);\n  }\n};\n\n// packages/ag-charts-community/src/module/enterpriseModule.ts\nvar enterpriseModule = {\n  isEnterprise: false\n};\n\n// packages/ag-charts-types/src/chart/errorBarOptions.ts\nvar AgErrorBarSupportedSeriesTypes = [\"bar\", \"line\", \"scatter\"];\n\n// packages/ag-charts-types/src/chart/navigatorOptions.ts\nvar __MINI_CHART_SERIES_OPTIONS = void 0;\nvar __VERIFY_MINI_CHART_SERIES_OPTIONS = void 0;\n__VERIFY_MINI_CHART_SERIES_OPTIONS = __MINI_CHART_SERIES_OPTIONS;\n\n// packages/ag-charts-types/src/chart/themeOptions.ts\nvar __THEME_OVERRIDES = void 0;\nvar __VERIFY_THEME_OVERRIDES = void 0;\n__VERIFY_THEME_OVERRIDES = __THEME_OVERRIDES;\n\n// packages/ag-charts-types/src/chart/tooltipOptions.ts\nvar AgTooltipPositionType = /* @__PURE__ */ ((AgTooltipPositionType2) => {\n  AgTooltipPositionType2[\"POINTER\"] = \"pointer\";\n  AgTooltipPositionType2[\"NODE\"] = \"node\";\n  AgTooltipPositionType2[\"TOP\"] = \"top\";\n  AgTooltipPositionType2[\"RIGHT\"] = \"right\";\n  AgTooltipPositionType2[\"BOTTOM\"] = \"bottom\";\n  AgTooltipPositionType2[\"LEFT\"] = \"left\";\n  AgTooltipPositionType2[\"TOP_LEFT\"] = \"top-left\";\n  AgTooltipPositionType2[\"TOP_RIGHT\"] = \"top-right\";\n  AgTooltipPositionType2[\"BOTTOM_RIGHT\"] = \"bottom-right\";\n  AgTooltipPositionType2[\"BOTTOM_LEFT\"] = \"bottom-left\";\n  return AgTooltipPositionType2;\n})(AgTooltipPositionType || {});\n\n// packages/ag-charts-types/src/presets/gauge/commonOptions.ts\nvar __THEMEABLE_OPTIONS = void 0;\nvar __VERIFY_THEMEABLE_OPTIONS = void 0;\n__VERIFY_THEMEABLE_OPTIONS = __THEMEABLE_OPTIONS;\nvar __AXIS_LABEL_OPTIONS = void 0;\nvar __VERIFY_AXIS_LABEL_OPTIONS = void 0;\n__VERIFY_AXIS_LABEL_OPTIONS = __AXIS_LABEL_OPTIONS;\n\n// packages/ag-charts-community/src/api/preset/presetUtils.ts\nvar IGNORED_PROP = Symbol(\"IGNORED_PROP\");\nfunction pickProps(opts, values) {\n  const out = {};\n  for (const [key, value] of Object.entries(values)) {\n    if (value !== IGNORED_PROP && Object.hasOwn(opts, key)) {\n      out[key] = value;\n    }\n  }\n  return out;\n}\n\n// packages/ag-charts-community/src/api/preset/gauge.ts\nfunction pickTooltipProps(tooltip) {\n  if (tooltip === void 0)\n    return void 0;\n  const { enabled, showArrow, range: range3, position, delay, wrapping } = tooltip;\n  const result = {\n    enabled,\n    showArrow,\n    range: range3,\n    position,\n    delay,\n    wrapping\n  };\n  return Object.fromEntries(Object.entries(result).filter(([_, value]) => value !== void 0));\n}\nfunction isRadialGauge(opts) {\n  return opts.type === \"radial-gauge\";\n}\nfunction isLinearGauge(opts) {\n  return opts.type === \"linear-gauge\";\n}\nfunction radialGaugeOptions(opts) {\n  const {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    overrideDevicePixelRatio,\n    padding,\n    subtitle,\n    theme,\n    title,\n    width: width2,\n    type,\n    cursor,\n    nodeClickRange,\n    tooltip,\n    value,\n    scale: scale2 = {},\n    startAngle,\n    endAngle,\n    highlightStyle,\n    segmentation,\n    bar,\n    needle,\n    targets,\n    outerRadius,\n    innerRadius,\n    outerRadiusRatio,\n    innerRadiusRatio,\n    cornerRadius,\n    cornerMode,\n    label,\n    secondaryLabel,\n    spacing,\n    ...rest\n  } = opts;\n  const {\n    fills: scaleFills,\n    fillMode: scaleFillMode,\n    fill: scaleFill,\n    fillOpacity: scaleFillOpacity,\n    stroke: scaleStroke,\n    strokeWidth: scaleStrokeWidth,\n    strokeOpacity: scaleStrokeOpacity,\n    lineDash: scaleLineDash,\n    lineDashOffset: scaleLineDashOffset,\n    min: scaleMin = 0,\n    max: scaleMax = 1,\n    interval: scaleInterval = {},\n    label: scaleLabel = {}\n  } = scale2;\n  const chartOpts = pickProps(opts, {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    overrideDevicePixelRatio,\n    padding,\n    subtitle,\n    theme,\n    title,\n    tooltip: pickTooltipProps(tooltip),\n    width: width2\n  });\n  const scaleOpts = pickProps(scale2, {\n    fills: scaleFills,\n    fillMode: scaleFillMode,\n    fill: scaleFill,\n    fillOpacity: scaleFillOpacity,\n    stroke: scaleStroke,\n    strokeWidth: scaleStrokeWidth,\n    strokeOpacity: scaleStrokeOpacity,\n    lineDash: scaleLineDash,\n    lineDashOffset: scaleLineDashOffset\n  });\n  const seriesOpts = pickProps(opts, {\n    startAngle: IGNORED_PROP,\n    endAngle: IGNORED_PROP,\n    needle: needle != null ? { enabled: true, ...needle } : IGNORED_PROP,\n    scale: scaleOpts,\n    type,\n    cursor,\n    nodeClickRange,\n    listeners,\n    tooltip,\n    value,\n    highlightStyle,\n    segmentation,\n    bar,\n    targets,\n    outerRadius,\n    innerRadius,\n    outerRadiusRatio,\n    innerRadiusRatio,\n    cornerRadius,\n    cornerMode,\n    label,\n    secondaryLabel,\n    spacing,\n    ...rest\n  });\n  const axesOpts = [\n    {\n      type: \"angle-number\",\n      min: scaleMin,\n      max: scaleMax,\n      startAngle,\n      endAngle,\n      interval: scaleInterval ?? {},\n      label: scaleLabel ?? {}\n    },\n    { type: \"radius-number\" }\n  ];\n  return {\n    ...chartOpts,\n    series: [seriesOpts],\n    axes: axesOpts\n  };\n}\nfunction linearGaugeOptions(opts) {\n  const {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    overrideDevicePixelRatio,\n    padding,\n    subtitle,\n    theme,\n    title,\n    width: width2,\n    type,\n    cursor,\n    nodeClickRange,\n    tooltip,\n    value,\n    scale: scale2 = {},\n    direction = \"vertical\",\n    thickness,\n    highlightStyle,\n    segmentation,\n    bar,\n    targets,\n    cornerRadius,\n    cornerMode,\n    label,\n    ...rest\n  } = opts;\n  const {\n    fills: scaleFills,\n    fillMode: scaleFillMode,\n    fill: scaleFill,\n    fillOpacity: scaleFillOpacity,\n    stroke: scaleStroke,\n    strokeWidth: scaleStrokeWidth,\n    strokeOpacity: scaleStrokeOpacity,\n    lineDash: scaleLineDash,\n    lineDashOffset: scaleLineDashOffset,\n    min: scaleMin = 0,\n    max: scaleMax = 1,\n    interval: scaleInterval = {},\n    label: scaleLabel = {}\n  } = scale2;\n  const chartOpts = pickProps(opts, {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    overrideDevicePixelRatio,\n    padding,\n    subtitle,\n    theme,\n    title,\n    tooltip: pickTooltipProps(tooltip),\n    width: width2\n  });\n  const scaleOpts = pickProps(scale2, {\n    fills: scaleFills,\n    fillMode: scaleFillMode,\n    fill: scaleFill,\n    fillOpacity: scaleFillOpacity,\n    stroke: scaleStroke,\n    strokeWidth: scaleStrokeWidth,\n    strokeOpacity: scaleStrokeOpacity,\n    lineDash: scaleLineDash,\n    lineDashOffset: scaleLineDashOffset\n  });\n  const seriesOpts = pickProps(opts, {\n    scale: scaleOpts,\n    type,\n    cursor,\n    nodeClickRange,\n    listeners,\n    tooltip,\n    value,\n    direction,\n    thickness,\n    highlightStyle,\n    segmentation,\n    bar,\n    targets,\n    cornerRadius,\n    cornerMode,\n    label,\n    ...rest\n  });\n  const { placement: labelPlacement, ...axisLabel2 } = scaleLabel;\n  let mainAxisPosition;\n  let crossAxisPosition;\n  const horizontal = direction === \"horizontal\";\n  if (horizontal) {\n    mainAxisPosition = labelPlacement === \"before\" ? \"top\" : \"bottom\";\n    crossAxisPosition = \"left\";\n  } else {\n    mainAxisPosition = labelPlacement === \"after\" ? \"right\" : \"left\";\n    crossAxisPosition = \"bottom\";\n  }\n  const mainAxis = {\n    type: \"number\",\n    position: mainAxisPosition,\n    min: scaleMin,\n    max: scaleMax,\n    reverse: !horizontal,\n    interval: scaleInterval,\n    label: axisLabel2,\n    nice: false\n  };\n  const crossAxis = {\n    type: \"number\",\n    position: crossAxisPosition,\n    min: 0,\n    max: 1,\n    label: {\n      enabled: false\n    }\n  };\n  const axesOpts = horizontal ? [mainAxis, crossAxis] : [crossAxis, mainAxis];\n  return {\n    ...chartOpts,\n    series: [seriesOpts],\n    axes: axesOpts\n  };\n}\nfunction applyThemeDefaults(opts, presetTheme) {\n  if (presetTheme == null)\n    return opts;\n  const { targets: targetsTheme, ...gaugeTheme } = presetTheme;\n  opts = mergeDefaults(opts, gaugeTheme);\n  if (opts.targets != null && targetsTheme != null) {\n    opts.targets = mergeArrayDefaults(opts.targets, targetsTheme);\n  }\n  return opts;\n}\nfunction gauge(opts, presetTheme) {\n  if (isRadialGauge(opts)) {\n    const radialGaugeOpts = applyThemeDefaults(opts, presetTheme);\n    return radialGaugeOptions(radialGaugeOpts);\n  } else if (isLinearGauge(opts)) {\n    const linearGaugeOpts = applyThemeDefaults(opts, presetTheme);\n    return linearGaugeOptions(linearGaugeOpts);\n  }\n  const {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    subtitle,\n    theme,\n    title,\n    tooltip,\n    width: width2\n  } = opts;\n  return pickProps(opts, {\n    animation,\n    background,\n    container,\n    contextMenu,\n    footnote,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    padding,\n    subtitle,\n    theme,\n    title,\n    tooltip,\n    width: width2\n  });\n}\n\n// packages/ag-charts-community/src/api/preset/priceVolumePresetTheme.ts\nvar stroke = {\n  stroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR\n};\nvar handle = {\n  fill: DEFAULT_ANNOTATION_HANDLE_FILL\n};\nvar axisLabel = {\n  color: \"white\",\n  fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR\n};\nvar lineText = {\n  color: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR\n};\nvar font = {\n  color: DEFAULT_TEXT_ANNOTATION_COLOR,\n  fontSize: { $rem: [1.1666666666666667 /* LARGE */] },\n  fontFamily: { $ref: \"fontFamily\" }\n};\nvar text = {\n  ...font,\n  textAlign: \"left\"\n};\nvar measurerStatistics = {\n  ...font,\n  fontSize: { $ref: \"fontSize\" },\n  color: DEFAULT_ANNOTATION_STATISTICS_COLOR,\n  fill: DEFAULT_ANNOTATION_STATISTICS_FILL,\n  stroke: DEFAULT_ANNOTATION_STATISTICS_STROKE,\n  strokeWidth: 1,\n  divider: {\n    stroke: DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE,\n    strokeWidth: 1,\n    strokeOpacity: 0.5\n  }\n};\nvar measurer = {\n  ...stroke,\n  background: {\n    fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,\n    fillOpacity: 0.2\n  },\n  handle: { ...handle },\n  text: { ...lineText },\n  statistics: { ...measurerStatistics }\n};\nvar annotationsTheme = {\n  // Lines\n  line: {\n    ...stroke,\n    handle: { ...handle },\n    text: { ...lineText }\n  },\n  \"horizontal-line\": {\n    ...stroke,\n    handle: { ...handle },\n    axisLabel: { ...axisLabel },\n    text: { ...lineText }\n  },\n  \"vertical-line\": {\n    ...stroke,\n    handle: { ...handle },\n    axisLabel: { ...axisLabel },\n    text: { ...lineText }\n  },\n  // Channels\n  \"disjoint-channel\": {\n    ...stroke,\n    background: {\n      fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,\n      fillOpacity: 0.2\n    },\n    handle: { ...handle },\n    text: { ...lineText }\n  },\n  \"parallel-channel\": {\n    ...stroke,\n    background: {\n      fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,\n      fillOpacity: 0.2\n    },\n    handle: { ...handle },\n    text: { ...lineText }\n  },\n  // Fibonnaccis\n  \"fibonacci-retracement\": {\n    ...stroke,\n    strokes: DEFAULT_FIBONACCI_STROKES,\n    rangeStroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,\n    handle: { ...handle },\n    text: { ...lineText, position: \"center\" },\n    label: {\n      ...font,\n      color: void 0,\n      fontSize: {\n        $round: [{ $mul: [{ $ref: \"fontSize\" }, 10 / 12] }]\n      }\n    }\n  },\n  \"fibonacci-retracement-trend-based\": {\n    ...stroke,\n    strokes: DEFAULT_FIBONACCI_STROKES,\n    rangeStroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,\n    handle: { ...handle },\n    text: { ...lineText, position: \"center\" },\n    label: {\n      ...font,\n      color: void 0,\n      fontSize: {\n        $round: [{ $mul: [{ $ref: \"fontSize\" }, 10 / 12] }]\n      }\n    }\n  },\n  // Texts\n  callout: {\n    ...stroke,\n    ...text,\n    color: { $ref: \"textColor\" },\n    handle: { ...handle },\n    fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,\n    fillOpacity: 0.2\n  },\n  comment: {\n    ...text,\n    color: \"white\",\n    fontWeight: 700,\n    handle: { ...handle },\n    fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR\n  },\n  note: {\n    ...text,\n    color: DEFAULT_TEXTBOX_COLOR,\n    fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,\n    stroke: { $ref: \"backgroundColor\" },\n    strokeWidth: 1,\n    strokeOpacity: 1,\n    handle: { ...handle },\n    background: {\n      fill: DEFAULT_TEXTBOX_FILL,\n      stroke: DEFAULT_TEXTBOX_STROKE,\n      strokeWidth: 1\n    }\n  },\n  text: {\n    ...text,\n    handle: { ...handle }\n  },\n  // Shapes\n  arrow: {\n    ...stroke,\n    handle: { ...handle },\n    text: { ...lineText }\n  },\n  \"arrow-up\": {\n    fill: PALETTE_UP_FILL,\n    handle: { ...handle, stroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR }\n  },\n  \"arrow-down\": {\n    fill: PALETTE_DOWN_FILL,\n    handle: { ...handle, stroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR }\n  },\n  // Measurers\n  \"date-range\": {\n    ...measurer\n  },\n  \"price-range\": {\n    ...measurer\n  },\n  \"date-price-range\": {\n    ...measurer\n  },\n  \"quick-date-price-range\": {\n    up: {\n      ...stroke,\n      fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,\n      fillOpacity: 0.2,\n      handle: { ...handle },\n      statistics: {\n        ...measurerStatistics,\n        color: \"#fff\",\n        fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,\n        strokeWidth: 0,\n        divider: {\n          stroke: \"#fff\",\n          strokeWidth: 1,\n          strokeOpacity: 0.5\n        }\n      }\n    },\n    down: {\n      ...stroke,\n      stroke: DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE,\n      fill: DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,\n      fillOpacity: 0.2,\n      handle: {\n        ...handle,\n        stroke: DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE\n      },\n      statistics: {\n        ...measurerStatistics,\n        color: \"#fff\",\n        fill: DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,\n        strokeWidth: 0,\n        divider: {\n          stroke: \"#fff\",\n          strokeWidth: 1,\n          strokeOpacity: 0.5\n        }\n      }\n    }\n  }\n};\n\n// packages/ag-charts-community/src/api/preset/priceVolumePreset.ts\nfunction fromTheme(theme, cb) {\n  if (isObject(theme)) {\n    return cb(theme);\n  }\n}\nvar chartTypes3 = [\"ohlc\", \"line\", \"step-line\", \"hlc\", \"high-low\", \"candlestick\", \"hollow-candlestick\"];\nvar toolbarButtons = [\n  {\n    icon: \"trend-line-drawing\",\n    tooltip: \"toolbarAnnotationsLineAnnotations\",\n    value: \"line-menu\"\n  },\n  {\n    icon: \"fibonacci-retracement-drawing\",\n    tooltip: \"toolbarAnnotationsFibonacciAnnotations\",\n    value: \"fibonacci-menu\"\n  },\n  {\n    icon: \"text-annotation\",\n    tooltip: \"toolbarAnnotationsTextAnnotations\",\n    value: \"text-menu\"\n  },\n  {\n    icon: \"arrow-drawing\",\n    tooltip: \"toolbarAnnotationsShapeAnnotations\",\n    value: \"shape-menu\"\n  },\n  {\n    icon: \"measurer-drawing\",\n    tooltip: \"toolbarAnnotationsMeasurerAnnotations\",\n    value: \"measurer-menu\"\n  },\n  {\n    icon: \"delete\",\n    tooltip: \"toolbarAnnotationsClearAll\",\n    value: \"clear\"\n  }\n];\nfunction priceVolume(opts, _presetTheme, getTheme) {\n  const {\n    dateKey = \"date\",\n    highKey = \"high\",\n    openKey = \"open\",\n    lowKey = \"low\",\n    closeKey = \"close\",\n    volumeKey = \"volume\",\n    chartType = \"candlestick\",\n    navigator = false,\n    volume = true,\n    rangeButtons = true,\n    statusBar = true,\n    toolbar = true,\n    zoom = true,\n    theme,\n    data,\n    ...unusedOpts\n  } = opts;\n  const priceSeries = createPriceSeries(theme, chartType, dateKey, highKey, lowKey, openKey, closeKey);\n  const volumeSeries = createVolumeSeries(theme, getTheme, openKey, closeKey, volume, volumeKey);\n  const miniChart = volume ? {\n    miniChart: {\n      enabled: navigator,\n      series: [\n        {\n          type: \"line\",\n          xKey: dateKey,\n          yKey: volumeKey,\n          marker: { enabled: false }\n        }\n      ]\n    },\n    height: 40,\n    minHandle: {\n      height: 46\n    },\n    maxHandle: {\n      height: 46\n    }\n  } : null;\n  const navigatorOpts = {\n    navigator: {\n      enabled: navigator,\n      ...miniChart\n    }\n  };\n  const axesButtonsEnabled = typeof theme === \"string\" ? true : theme?.overrides?.common?.annotations?.axesButtons?.enabled ?? true;\n  const annotationOpts = {\n    annotations: {\n      enabled: toolbar,\n      optionsToolbar: {\n        enabled: toolbar\n      },\n      snap: true,\n      axesButtons: {\n        enabled: axesButtonsEnabled\n      },\n      toolbar: {\n        enabled: toolbar,\n        buttons: toolbarButtons,\n        // @ts-expect-error undocumented option\n        padding: 0\n      },\n      data,\n      xKey: dateKey,\n      volumeKey: volume ? volumeKey : void 0\n    }\n  };\n  const statusBarOpts = statusBar ? {\n    statusBar: {\n      enabled: true,\n      data,\n      highKey,\n      openKey,\n      lowKey,\n      closeKey,\n      volumeKey: volume ? volumeKey : void 0\n    }\n  } : null;\n  const zoomOpts = {\n    zoom: {\n      enabled: zoom,\n      autoScaling: {\n        enabled: true\n      },\n      // @ts-expect-error undocumented option\n      enableIndependentAxes: true\n    }\n  };\n  const toolbarOpts = {\n    ranges: {\n      enabled: rangeButtons\n    }\n  };\n  const volumeAxis = volume ? [\n    {\n      type: \"number\",\n      position: \"left\",\n      keys: [volumeKey],\n      label: { enabled: false },\n      crosshair: { enabled: false },\n      gridLine: { enabled: false },\n      nice: false,\n      // @ts-expect-error undocumented option\n      layoutConstraints: {\n        stacked: false,\n        width: 20,\n        unit: \"percentage\",\n        align: \"end\"\n      }\n    }\n  ] : [];\n  return {\n    theme: {\n      baseTheme: typeof theme === \"string\" ? theme : \"ag-financial\",\n      ...mergeDefaults(typeof theme === \"object\" ? theme : null, {\n        overrides: {\n          common: {\n            title: { padding: 4 },\n            padding: {\n              top: 6,\n              right: 8,\n              bottom: 5\n            },\n            chartToolbar: {\n              enabled: toolbar\n            },\n            annotations: { ...annotationsTheme }\n          }\n        }\n      })\n    },\n    animation: { enabled: false },\n    legend: { enabled: false },\n    series: [...volumeSeries, ...priceSeries],\n    axes: [\n      {\n        type: \"number\",\n        position: \"right\",\n        keys: [openKey, closeKey, highKey, lowKey],\n        interval: {\n          maxSpacing: fromTheme(theme, (t) => t.overrides?.common?.axes?.number?.interval?.maxSpacing) ?? 45\n        },\n        label: {\n          format: fromTheme(theme, (t) => t.overrides?.common?.axes?.number?.label?.format) ?? \".2f\"\n        },\n        crosshair: {\n          enabled: true,\n          snap: false\n        },\n        // @ts-expect-error undocumented option\n        layoutConstraints: {\n          stacked: false,\n          width: 100,\n          unit: \"percentage\",\n          align: \"start\"\n        }\n      },\n      ...volumeAxis,\n      {\n        type: \"ordinal-time\",\n        position: \"bottom\",\n        line: {\n          enabled: false\n        },\n        label: {\n          enabled: true\n        },\n        crosshair: {\n          enabled: true\n        }\n      }\n    ],\n    tooltip: { enabled: false },\n    data,\n    ...annotationOpts,\n    ...navigatorOpts,\n    ...statusBarOpts,\n    ...zoomOpts,\n    ...toolbarOpts,\n    ...unusedOpts\n  };\n}\nfunction createVolumeSeries(theme, getTheme, openKey, closeKey, volume, volumeKey) {\n  if (!volume)\n    return [];\n  const barSeriesFill = fromTheme(theme, (t) => t.overrides?.bar?.series?.fill);\n  const itemStyler = barSeriesFill ? { fill: barSeriesFill } : {\n    itemStyler({ datum }) {\n      const { up, down } = getTheme().palette;\n      return { fill: datum[openKey] < datum[closeKey] ? up?.fill : down?.fill };\n    }\n  };\n  return [\n    {\n      type: \"bar\",\n      xKey: \"date\",\n      yKey: volumeKey,\n      tooltip: { enabled: false },\n      highlight: { enabled: false },\n      fillOpacity: fromTheme(theme, (t) => t.overrides?.bar?.series?.fillOpacity) ?? 0.5,\n      ...itemStyler,\n      // @ts-expect-error undocumented option\n      focusPriority: 1,\n      fastDataProcessing: true\n    }\n  ];\n}\nvar RANGE_AREA_TYPE = \"range-area\";\nfunction createPriceSeries(theme, chartType, xKey, highKey, lowKey, openKey, closeKey) {\n  const keys = {\n    xKey,\n    openKey,\n    closeKey,\n    highKey,\n    lowKey\n  };\n  const singleKeys = {\n    xKey,\n    yKey: closeKey\n  };\n  const common = {\n    pickOutsideVisibleMinorAxis: true\n  };\n  switch (chartType ?? \"candlestick\") {\n    case \"ohlc\":\n      return createPriceSeriesOHLC(common, keys);\n    case \"line\":\n      return createPriceSeriesLine(common, theme, singleKeys);\n    case \"step-line\":\n      return createPriceSeriesStepLine(common, theme, singleKeys);\n    case \"hlc\":\n      return createPriceSeriesHLC(common, theme, singleKeys, keys);\n    case \"high-low\":\n      return createPriceSeriesHighLow(common, theme, keys);\n    case \"candlestick\":\n      return createPriceSeriesCandlestick(common, keys);\n    case \"hollow-candlestick\":\n      return createPriceSeriesHollowCandlestick(common, theme, keys);\n    default:\n      logger_exports.warnOnce(`unknown chart type: ${chartType}; expected one of: ${chartTypes3.join(\", \")}`);\n      return createPriceSeriesCandlestick(common, keys);\n  }\n}\nfunction createPriceSeriesOHLC(common, keys) {\n  return [\n    {\n      type: \"ohlc\",\n      // @ts-expect-error undocumented option\n      focusPriority: 0,\n      ...common,\n      ...keys\n    }\n  ];\n}\nfunction createPriceSeriesLine(common, theme, singleKeys) {\n  return [\n    {\n      type: \"line\",\n      // @ts-expect-error undocumented option\n      focusPriority: 0,\n      ...common,\n      ...singleKeys,\n      stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_NEUTRAL_STROKE,\n      marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n    }\n  ];\n}\nfunction createPriceSeriesStepLine(common, theme, singleKeys) {\n  return [\n    {\n      type: \"line\",\n      // @ts-expect-error undocumented option\n      focusPriority: 0,\n      ...common,\n      ...singleKeys,\n      stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_NEUTRAL_STROKE,\n      interpolation: fromTheme(theme, (t) => t.overrides?.line?.series?.interpolation) ?? {\n        type: \"step\"\n      },\n      marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n    }\n  ];\n}\nfunction createPriceSeriesHLC(common, theme, singleKeys, { xKey, highKey, closeKey, lowKey }) {\n  const rangeAreaColors = getThemeColors(RANGE_AREA_TYPE, theme);\n  return [\n    {\n      type: RANGE_AREA_TYPE,\n      // @ts-expect-error undocumented option\n      focusPriority: 0,\n      ...common,\n      xKey,\n      yHighKey: highKey,\n      yLowKey: closeKey,\n      fill: rangeAreaColors.fill ?? PALETTE_UP_FILL,\n      stroke: rangeAreaColors.stroke ?? PALETTE_UP_STROKE,\n      fillOpacity: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.fillOpacity) ?? 0.3,\n      strokeWidth: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.strokeWidth) ?? 2\n    },\n    {\n      type: RANGE_AREA_TYPE,\n      // @ts-expect-error undocumented option\n      focusPriority: 0,\n      ...common,\n      xKey,\n      yHighKey: closeKey,\n      yLowKey: lowKey,\n      fill: rangeAreaColors.fill ?? PALETTE_DOWN_FILL,\n      stroke: rangeAreaColors.stroke ?? PALETTE_DOWN_STROKE,\n      fillOpacity: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.fillOpacity) ?? 0.3,\n      strokeWidth: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.strokeWidth) ?? 2\n    },\n    {\n      type: \"line\",\n      ...common,\n      ...singleKeys,\n      stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_ALT_NEUTRAL_STROKE,\n      strokeWidth: fromTheme(theme, (t) => t.overrides?.line?.series?.strokeWidth) ?? 2,\n      marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n    }\n  ];\n}\nfunction createPriceSeriesHighLow(common, theme, { xKey, highKey, lowKey }) {\n  const rangeBarColors = getThemeColors(\"range-bar\", theme);\n  return [\n    {\n      type: \"range-bar\",\n      ...common,\n      xKey,\n      yHighKey: highKey,\n      yLowKey: lowKey,\n      fill: rangeBarColors.fill ?? PALETTE_NEUTRAL_FILL,\n      stroke: rangeBarColors.stroke ?? PALETTE_NEUTRAL_STROKE,\n      tooltip: {\n        range: \"nearest\"\n      },\n      // @ts-expect-error undocumented option\n      focusPriority: 0,\n      fastDataProcessing: true\n    }\n  ];\n}\nfunction createPriceSeriesCandlestick(common, keys) {\n  return [\n    {\n      type: \"candlestick\",\n      // @ts-expect-error undocumented option\n      focusPriority: 0,\n      ...common,\n      ...keys\n    }\n  ];\n}\nfunction createPriceSeriesHollowCandlestick(common, theme, keys) {\n  const item = fromTheme(theme, (t) => t.overrides?.candlestick?.series?.item);\n  return [\n    {\n      type: \"candlestick\",\n      // @ts-expect-error undocumented option\n      focusPriority: 0,\n      ...common,\n      ...keys,\n      item: {\n        up: {\n          fill: item?.up?.fill ?? \"transparent\"\n        }\n      }\n    }\n  ];\n}\nfunction getThemeColors(seriesType, theme) {\n  const fill = fromTheme(theme, (t) => t.overrides?.[seriesType]?.series?.fill);\n  const stroke2 = fromTheme(theme, (t) => t.overrides?.[seriesType]?.series?.stroke);\n  return { fill, stroke: stroke2 };\n}\n\n// packages/ag-charts-community/src/api/preset/sparkline.ts\nvar commonAxisProperties = {\n  title: {\n    enabled: false\n  },\n  label: {\n    enabled: false\n  },\n  line: {\n    enabled: false\n  },\n  gridLine: {\n    enabled: false\n  },\n  crosshair: {\n    enabled: false,\n    stroke: DEFAULT_SPARKLINE_CROSSHAIR_STROKE,\n    lineDash: [0],\n    label: {\n      enabled: false\n    }\n  }\n};\nvar numericAxisProperties = {\n  ...commonAxisProperties,\n  nice: false\n};\nvar tooltipDefaults = {\n  position: {\n    type: \"sparkline\"\n  }\n};\nvar barGridLineDefaults = {\n  style: [{ stroke: { $ref: \"gridLineColor\" } }],\n  width: 2\n};\nvar barAxisDefaults = {\n  number: {\n    gridLine: barGridLineDefaults\n  },\n  time: {\n    gridLine: barGridLineDefaults\n  },\n  category: {\n    gridLine: barGridLineDefaults\n  }\n};\nvar SPARKLINE_THEME = {\n  overrides: {\n    common: {\n      animation: { enabled: false },\n      contextMenu: { enabled: false },\n      keyboard: { enabled: false },\n      background: { visible: false },\n      padding: {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      },\n      axes: {\n        number: {\n          ...numericAxisProperties,\n          interval: {\n            values: [0]\n          }\n        },\n        log: {\n          ...numericAxisProperties\n        },\n        time: {\n          ...numericAxisProperties\n        },\n        category: {\n          ...commonAxisProperties\n        }\n      }\n    },\n    bar: {\n      series: {\n        crisp: false,\n        label: {\n          placement: \"inside-end\",\n          padding: 4\n        },\n        // @ts-expect-error undocumented option\n        sparklineMode: true\n      },\n      tooltip: {\n        ...tooltipDefaults,\n        range: \"nearest\"\n      },\n      axes: barAxisDefaults\n    },\n    line: {\n      seriesArea: {\n        padding: {\n          top: 2,\n          right: 2,\n          bottom: 2,\n          left: 2\n        }\n      },\n      series: {\n        // @ts-expect-error undocumented option\n        sparklineMode: true,\n        strokeWidth: 1,\n        marker: {\n          enabled: false,\n          size: 3\n        },\n        tooltip: tooltipDefaults\n      }\n    },\n    area: {\n      seriesArea: {\n        padding: {\n          top: 1,\n          right: 0,\n          bottom: 1,\n          left: 0\n        }\n      },\n      series: {\n        strokeWidth: 1,\n        fillOpacity: 0.4,\n        tooltip: tooltipDefaults\n      }\n    }\n  }\n};\nvar setInitialBaseTheme = simpleMemorize(createInitialBaseTheme);\nfunction createInitialBaseTheme(baseTheme, initialBaseTheme) {\n  if (typeof baseTheme === \"string\") {\n    return {\n      ...initialBaseTheme,\n      baseTheme\n    };\n  }\n  if (baseTheme != null) {\n    return {\n      ...baseTheme,\n      // @ts-expect-error internal implementation\n      baseTheme: setInitialBaseTheme(baseTheme.baseTheme, initialBaseTheme)\n    };\n  }\n  return initialBaseTheme;\n}\nfunction sparklineDataPreset(data) {\n  if (Array.isArray(data) && data.length !== 0) {\n    const firstItem = data[0];\n    if (typeof firstItem === \"number\") {\n      const mappedData = data.map((y, x) => ({ x, y }));\n      return { data: mappedData, series: [{ xKey: \"x\", yKey: \"y\" }], datumKey: \"y\" };\n    } else if (Array.isArray(firstItem)) {\n      const mappedData = data.map((datum) => ({ x: datum[0], y: datum[1], datum }));\n      return { data: mappedData, series: [{ xKey: \"x\", yKey: \"y\" }], datumKey: \"datum\" };\n    }\n  }\n  return { data };\n}\nfunction axisPreset(opts, defaultType) {\n  switch (opts?.type) {\n    case \"number\": {\n      const { type, min, max, reverse } = opts;\n      return pickProps(opts, {\n        type,\n        reverse,\n        min,\n        max\n      });\n    }\n    case \"time\": {\n      const { type, min, max, reverse } = opts;\n      return pickProps(opts, {\n        type,\n        reverse,\n        min,\n        max\n      });\n    }\n    case \"category\": {\n      const { type, paddingInner, paddingOuter, reverse } = opts;\n      return pickProps(opts, {\n        type,\n        reverse,\n        paddingInner,\n        paddingOuter\n      });\n    }\n  }\n  return { type: defaultType };\n}\nfunction gridLinePreset(opts, defaultEnabled, sparkOpts) {\n  const gridLineOpts = {};\n  if (opts?.stroke != null) {\n    gridLineOpts.style = [{ stroke: opts?.stroke }];\n    gridLineOpts.enabled ?? (gridLineOpts.enabled = true);\n  }\n  if (opts?.strokeWidth != null) {\n    gridLineOpts.width = opts?.strokeWidth;\n    gridLineOpts.enabled ?? (gridLineOpts.enabled = true);\n  }\n  if (sparkOpts.type === \"bar\" && sparkOpts.direction !== \"horizontal\") {\n    gridLineOpts.enabled ?? (gridLineOpts.enabled = true);\n  }\n  if (opts?.visible != null) {\n    gridLineOpts.enabled = opts.visible;\n  }\n  gridLineOpts.enabled ?? (gridLineOpts.enabled = defaultEnabled);\n  return gridLineOpts;\n}\nvar tooltipRendererFn = simpleMemorize((context, tooltip, datumKey) => {\n  return (params) => {\n    const xValue = params.datum[params.xKey];\n    const yValue = params.datum[params.yKey];\n    const datum = datumKey != null ? params.datum[datumKey] : params.datum;\n    const userContent = tooltip?.renderer?.({ context, datum, xValue, yValue });\n    if (typeof userContent === \"string\")\n      return userContent;\n    const title = userContent?.title;\n    const content = userContent?.content;\n    return title != null && content != null ? {\n      heading: title,\n      title: void 0,\n      // Undocumented 'compact' tooltip mode\n      data: [{ label: void 0, value: content }]\n    } : {\n      heading: title ?? content ?? yValue.toFixed(2),\n      title: void 0,\n      data: []\n    };\n  };\n});\nfunction sparkline(opts) {\n  const {\n    background,\n    container,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    overrideDevicePixelRatio,\n    padding,\n    width: width2,\n    theme: baseTheme,\n    data: baseData,\n    crosshair,\n    axis,\n    min,\n    max,\n    tooltip,\n    context,\n    ...optsRest\n  } = opts;\n  const chartOpts = pickProps(opts, {\n    background,\n    container,\n    height: height2,\n    listeners,\n    locale,\n    minHeight,\n    minWidth,\n    overrideDevicePixelRatio,\n    padding,\n    width: width2,\n    tooltip: IGNORED_PROP,\n    context: IGNORED_PROP,\n    data: IGNORED_PROP,\n    crosshair: IGNORED_PROP,\n    axis: IGNORED_PROP,\n    min: IGNORED_PROP,\n    max: IGNORED_PROP,\n    theme: IGNORED_PROP\n  });\n  const { data, series: [seriesOverrides] = [], datumKey } = sparklineDataPreset(baseData);\n  const seriesOptions = optsRest;\n  if (seriesOverrides != null)\n    Object.assign(seriesOptions, seriesOverrides);\n  seriesOptions.tooltip = {\n    ...tooltip,\n    renderer: tooltipRendererFn(context, tooltip, datumKey)\n  };\n  chartOpts.theme = setInitialBaseTheme(baseTheme, SPARKLINE_THEME);\n  chartOpts.data = data;\n  chartOpts.series = [seriesOptions];\n  const swapAxes = seriesOptions.type !== \"bar\" || seriesOptions.direction !== \"horizontal\";\n  const [xAxisPosition, yAxisPosition] = swapAxes ? [\"bottom\", \"left\"] : [\"left\", \"bottom\"];\n  const xAxis = {\n    ...axisPreset(axis, \"category\"),\n    position: xAxisPosition,\n    ...pickProps(opts, { crosshair })\n  };\n  const yAxis = {\n    type: \"number\",\n    gridLine: gridLinePreset(axis, false, opts),\n    position: yAxisPosition,\n    ...pickProps(opts, { min, max })\n  };\n  chartOpts.axes = swapAxes ? [yAxis, xAxis] : [xAxis, yAxis];\n  return chartOpts;\n}\n\n// packages/ag-charts-community/src/api/preset/presets.ts\nvar PRESETS = {\n  \"price-volume\": priceVolume,\n  gauge,\n  sparkline\n};\nvar PRESET_DATA_PROCESSORS = {\n  sparkline: sparklineDataPreset\n};\n\n// packages/ag-charts-community/src/chart/factory/processEnterpriseOptions.ts\nfunction removeUsedEnterpriseOptions(options, silent) {\n  let usedOptions = [];\n  const isGaugeChart = isAgGaugeChartOptions(options);\n  const optsType = optionsType(options);\n  const optionsChartType = optsType ? chartTypes2.get(optsType) : \"unknown\";\n  for (const module of EXPECTED_ENTERPRISE_MODULES) {\n    if (optionsChartType !== \"unknown\" && !module.chartTypes.includes(optionsChartType))\n      continue;\n    if (module.type === \"root\" || module.type === \"legend\") {\n      const optionValue = options[module.optionsKey];\n      if (optionValue == null)\n        continue;\n      if (!module.optionsInnerKey) {\n        usedOptions.push(module.optionsKey);\n        delete options[module.optionsKey];\n      } else if (optionValue[module.optionsInnerKey]) {\n        usedOptions.push(`${module.optionsKey}.${module.optionsInnerKey}`);\n        delete optionValue[module.optionsInnerKey];\n      }\n    } else if (module.type === \"axis\") {\n      if (!(\"axes\" in options) || !options.axes?.some((axis) => axis.type === module.identifier))\n        continue;\n      usedOptions.push(`axis[type=${module.identifier}]`);\n      options.axes = options.axes.filter((axis) => axis.type !== module.identifier);\n    } else if (module.type === \"axis-option\") {\n      if (!(\"axes\" in options) || !options.axes?.some((axis) => axis[module.optionsKey]))\n        continue;\n      usedOptions.push(`axis.${module.optionsKey}`);\n      options.axes.forEach((axis) => {\n        if (axis[module.optionsKey]) {\n          delete axis[module.optionsKey];\n        }\n      });\n    } else if (module.type === \"series\") {\n      if (module.community)\n        continue;\n      if (!options.series?.some((series) => series.type === module.identifier))\n        continue;\n      usedOptions.push(`series[type=${module.identifier}]`);\n      options.series = options.series.filter((series) => series.type !== module.identifier);\n    } else if (module.type === \"series-option\") {\n      if (!options.series?.some((series) => series[module.optionsKey]))\n        continue;\n      usedOptions.push(`series.${module.optionsKey}`);\n      options.series.forEach((series) => {\n        if (series[module.optionsKey]) {\n          delete series[module.optionsKey];\n        }\n      });\n    }\n  }\n  if (usedOptions.length && !silent) {\n    if (isGaugeChart) {\n      usedOptions = [\"AgCharts.createGauge\"];\n    }\n    let enterprisePackageName = \"ag-charts-enterprise\";\n    let enterpriseReferenceUrl = \"https://www.ag-grid.com/charts/javascript/installation/\";\n    if (options.mode === \"integrated\") {\n      enterprisePackageName = \"ag-grid-charts-enterprise' or 'ag-grid-enterprise/charts-enterprise\";\n      enterpriseReferenceUrl = \"https://www.ag-grid.com/javascript-data-grid/integrated-charts-installation/\";\n    }\n    logger_exports.warnOnce(\n      [\n        `unable to use these enterprise features as '${enterprisePackageName}' has not been loaded:`,\n        \"\",\n        ...usedOptions,\n        \"\",\n        `See: ${enterpriseReferenceUrl}`\n      ].join(\"\\n\")\n    );\n  }\n}\nfunction removeUnusedEnterpriseOptions(options) {\n  const integratedMode = \"mode\" in options && options.mode === \"integrated\";\n  for (const module of moduleRegistry.byType(\"root\", \"legend\")) {\n    const moduleOptions = options[module.optionsKey];\n    const isPresentAndDisabled = moduleOptions != null && moduleOptions.enabled === false;\n    const removable = !(\"removable\" in module) || module.removable === true || module.removable === \"standalone-only\" && !integratedMode;\n    if (isPresentAndDisabled && removable) {\n      delete options[module.optionsKey];\n    }\n  }\n}\n\n// packages/ag-charts-community/src/module/coreModulesTypes.ts\nfunction paletteType(partial) {\n  if (partial?.up || partial?.down || partial?.neutral) {\n    return \"user-full\";\n  } else if (partial?.fills || partial?.strokes) {\n    return \"user-indexed\";\n  }\n  return \"inbuilt\";\n}\n\n// packages/ag-charts-community/src/chart/themes/chartTheme.ts\nvar DEFAULT_BACKGROUND_FILL = \"white\";\nvar CHART_TYPE_CONFIG = {\n  get cartesian() {\n    return { seriesTypes: chartTypes2.cartesianTypes, commonOptions: [\"zoom\", \"navigator\"] };\n  },\n  get polar() {\n    return { seriesTypes: chartTypes2.polarTypes, commonOptions: [] };\n  },\n  get hierarchy() {\n    return { seriesTypes: chartTypes2.hierarchyTypes, commonOptions: [] };\n  },\n  get topology() {\n    return { seriesTypes: chartTypes2.topologyTypes, commonOptions: [] };\n  },\n  get \"flow-proportion\"() {\n    return { seriesTypes: chartTypes2.flowProportionTypes, commonOptions: [] };\n  },\n  get standalone() {\n    return { seriesTypes: chartTypes2.standaloneTypes, commonOptions: [] };\n  },\n  get gauge() {\n    return { seriesTypes: chartTypes2.gaugeTypes, commonOptions: [] };\n  }\n};\nvar PRESET_OVERRIDES_TYPES = {\n  \"radial-gauge\": true,\n  \"linear-gauge\": true\n};\nfunction isPresetOverridesType(type) {\n  return PRESET_OVERRIDES_TYPES[type] === true;\n}\nvar CHART_TYPE_SPECIFIC_COMMON_OPTIONS = Object.values(CHART_TYPE_CONFIG).reduce((r, { commonOptions }) => r.concat(commonOptions), []);\nvar _ChartTheme = class _ChartTheme {\n  static getAxisDefaults(overrideDefaults) {\n    return mergeDefaults(overrideDefaults, {\n      title: {\n        enabled: false,\n        text: \"Axis Title\",\n        spacing: 25,\n        fontWeight: { $ref: \"fontWeight\" },\n        fontSize: { $rem: [1.0833333333333333 /* MEDIUM */] },\n        fontFamily: { $ref: \"fontFamily\" },\n        color: { $ref: \"textColor\" }\n      },\n      label: {\n        fontSize: { $ref: \"fontSize\" },\n        fontFamily: { $ref: \"fontFamily\" },\n        fontWeight: { $ref: \"fontWeight\" },\n        spacing: 11,\n        color: { $ref: \"textColor\" },\n        avoidCollisions: true\n      },\n      line: {\n        enabled: true,\n        width: 1,\n        stroke: { $ref: \"axisColor\" }\n      },\n      tick: {\n        enabled: false,\n        width: 1,\n        stroke: { $ref: \"axisColor\" }\n      },\n      gridLine: {\n        enabled: true,\n        style: [{ stroke: { $ref: \"gridLineColor\" }, lineDash: [] }]\n      },\n      crossLines: {\n        enabled: false,\n        fill: { $ref: \"foregroundColor\" },\n        stroke: { $ref: \"foregroundColor\" },\n        fillOpacity: 0.1,\n        strokeWidth: 1,\n        label: {\n          enabled: false,\n          fontSize: { $ref: \"fontSize\" },\n          fontFamily: { $ref: \"fontFamily\" },\n          fontWeight: { $ref: \"fontWeight\" },\n          padding: 5,\n          color: { $ref: \"textColor\" }\n        }\n      },\n      crosshair: {\n        enabled: true\n      }\n    });\n  }\n  getChartDefaults() {\n    return {\n      minHeight: 300,\n      minWidth: 300,\n      background: { visible: true, fill: { $ref: \"backgroundColor\" } },\n      padding: {\n        top: { $ref: \"padding\" },\n        right: { $ref: \"padding\" },\n        bottom: { $ref: \"padding\" },\n        left: { $ref: \"padding\" }\n      },\n      seriesArea: {\n        padding: {\n          top: 0,\n          right: 0,\n          bottom: 0,\n          left: 0\n        }\n      },\n      keyboard: { enabled: true },\n      title: {\n        enabled: false,\n        text: \"Title\",\n        fontWeight: { $ref: \"fontWeight\" },\n        fontSize: { $rem: [1.4166666666666667 /* LARGEST */] },\n        fontFamily: { $ref: \"fontFamily\" },\n        color: { $ref: \"textColor\" },\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      subtitle: {\n        enabled: false,\n        text: \"Subtitle\",\n        spacing: 20,\n        fontWeight: { $ref: \"fontWeight\" },\n        fontSize: { $rem: [1.0833333333333333 /* MEDIUM */] },\n        fontFamily: { $ref: \"fontFamily\" },\n        color: { $ref: \"subtleTextColor\" },\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      footnote: {\n        enabled: false,\n        text: \"Footnote\",\n        spacing: 20,\n        fontSize: { $rem: [1.0833333333333333 /* MEDIUM */] },\n        fontFamily: { $ref: \"fontFamily\" },\n        fontWeight: { $ref: \"fontWeight\" },\n        color: { $ref: \"subtleTextColor\" },\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      legend: {\n        position: \"bottom\" /* BOTTOM */,\n        spacing: 30,\n        listeners: {},\n        toggleSeries: true,\n        item: {\n          paddingX: 16,\n          paddingY: 8,\n          marker: { size: 15, padding: 8 },\n          showSeriesStroke: true,\n          label: {\n            color: { $ref: \"textColor\" },\n            fontSize: { $ref: \"fontSize\" },\n            fontFamily: { $ref: \"fontFamily\" },\n            fontWeight: { $ref: \"fontWeight\" }\n          }\n        },\n        reverseOrder: false,\n        pagination: {\n          marker: { size: 12 },\n          activeStyle: { fill: { $ref: \"foregroundColor\" } },\n          inactiveStyle: { fill: { $ref: \"subtleTextColor\" } },\n          highlightStyle: { fill: { $ref: \"foregroundColor\" } },\n          label: { color: { $ref: \"textColor\" } }\n        }\n      },\n      tooltip: {\n        enabled: true,\n        darkTheme: IS_DARK_THEME,\n        delay: 0\n      },\n      overlays: { darkTheme: IS_DARK_THEME },\n      listeners: {}\n    };\n  }\n  constructor(options = {}) {\n    const { overrides, palette } = deepClone(options);\n    const defaults = this.createChartConfigPerChartType(this.getDefaults());\n    const presets = {};\n    if (overrides) {\n      this.mergeOverrides(defaults, presets, overrides);\n    }\n    const { fills, strokes, ...otherColors } = this.getDefaultColors();\n    this.palette = deepFreeze(\n      mergeDefaults(palette, {\n        fills: Object.values(fills),\n        strokes: Object.values(strokes),\n        ...otherColors\n      })\n    );\n    this.paletteType = paletteType(palette);\n    this.config = deepFreeze(this.templateTheme(defaults));\n    this.presets = deepFreeze(presets);\n  }\n  mergeOverrides(defaults, presets, overrides) {\n    for (const { seriesTypes, commonOptions } of Object.values(CHART_TYPE_CONFIG)) {\n      const cleanedCommon = { ...overrides.common };\n      for (const commonKey of CHART_TYPE_SPECIFIC_COMMON_OPTIONS) {\n        if (!commonOptions.includes(commonKey)) {\n          delete cleanedCommon[commonKey];\n        }\n      }\n      if (!cleanedCommon)\n        continue;\n      for (const s of seriesTypes) {\n        const seriesType = s;\n        if (!isPresetOverridesType(seriesType)) {\n          defaults[seriesType] = mergeDefaults(cleanedCommon, defaults[seriesType]);\n        }\n      }\n    }\n    chartTypes2.seriesTypes.forEach((s) => {\n      const seriesType = s;\n      const seriesOverrides = overrides[seriesType];\n      if (isPresetOverridesType(seriesType)) {\n        presets[seriesType] = seriesOverrides;\n      } else {\n        defaults[seriesType] = mergeDefaults(seriesOverrides, defaults[seriesType]);\n      }\n    });\n  }\n  createChartConfigPerChartType(config) {\n    for (const [nextType, { seriesTypes }] of Object.entries(CHART_TYPE_CONFIG)) {\n      const typeDefaults = chartDefaults.get(nextType);\n      for (const seriesType of seriesTypes) {\n        config[seriesType] ?? (config[seriesType] = deepClone(typeDefaults));\n      }\n    }\n    return config;\n  }\n  getDefaults() {\n    const getOverridesByType = (chartType, seriesTypes) => {\n      const result = {};\n      const chartTypeDefaults = {\n        axes: {},\n        ...legendRegistry.getThemeTemplates(),\n        ...this.getChartDefaults(),\n        ...chartDefaults.get(chartType)\n      };\n      for (const seriesType of seriesTypes) {\n        result[seriesType] = mergeDefaults(\n          seriesRegistry.getThemeTemplate(seriesType),\n          result[seriesType] ?? deepClone(chartTypeDefaults)\n        );\n        const { axes } = result[seriesType];\n        for (const axisType of axisRegistry.keys()) {\n          axes[axisType] = mergeDefaults(\n            axes[axisType],\n            axisRegistry.getThemeTemplate(axisType),\n            _ChartTheme.cartesianAxisDefault[axisType]\n          );\n        }\n      }\n      return result;\n    };\n    return mergeDefaults(\n      getOverridesByType(\"cartesian\", chartTypes2.cartesianTypes),\n      getOverridesByType(\"polar\", chartTypes2.polarTypes),\n      getOverridesByType(\"hierarchy\", chartTypes2.hierarchyTypes),\n      getOverridesByType(\"topology\", chartTypes2.topologyTypes),\n      getOverridesByType(\"flow-proportion\", chartTypes2.flowProportionTypes),\n      getOverridesByType(\"standalone\", chartTypes2.standaloneTypes),\n      getOverridesByType(\"gauge\", chartTypes2.gaugeTypes)\n    );\n  }\n  static applyTemplateTheme(node, _other, params) {\n    if (isArray(node)) {\n      for (let i = 0; i < node.length; i++) {\n        const symbol = node[i];\n        if (typeof symbol === \"symbol\" && params?.has(symbol)) {\n          node[i] = params.get(symbol);\n        }\n      }\n    } else {\n      for (const [name, value] of Object.entries(node)) {\n        if (typeof value === \"symbol\" && params?.has(value)) {\n          node[name] = params.get(value);\n        }\n      }\n    }\n  }\n  templateTheme(themeTemplate, clone2 = true) {\n    const themeInstance = clone2 ? deepClone(themeTemplate) : themeTemplate;\n    const params = this.getTemplateParameters();\n    jsonWalk(themeInstance, _ChartTheme.applyTemplateTheme, void 0, void 0, params);\n    return themeInstance;\n  }\n  getDefaultColors() {\n    return {\n      fills: DEFAULT_FILLS,\n      strokes: DEFAULT_STROKES,\n      up: { fill: DEFAULT_FILLS.GREEN, stroke: DEFAULT_STROKES.GREEN },\n      down: { fill: DEFAULT_FILLS.RED, stroke: DEFAULT_STROKES.RED },\n      neutral: { fill: DEFAULT_FILLS.GRAY, stroke: DEFAULT_STROKES.GRAY },\n      altUp: { fill: DEFAULT_FILLS.BLUE, stroke: DEFAULT_STROKES.BLUE },\n      altDown: { fill: DEFAULT_FILLS.ORANGE, stroke: DEFAULT_STROKES.ORANGE },\n      altNeutral: { fill: DEFAULT_FILLS.GRAY, stroke: DEFAULT_STROKES.GRAY }\n    };\n  }\n  getPublicParameters() {\n    return {\n      accentColor: \"#2196f3\",\n      axisColor: { $foregroundBackgroundMix: [0.675] },\n      backgroundColor: DEFAULT_BACKGROUND_FILL,\n      borderColor: { $foregroundBackgroundMix: [0.818] },\n      foregroundColor: \"#464646\",\n      fontFamily: \"Verdana, sans-serif\",\n      fontSize: 12 /* SMALL */,\n      fontWeight: 400,\n      gridLineColor: { $foregroundBackgroundAccentMix: [0.93, 0.085] },\n      padding: 20,\n      subtleTextColor: { $mix: [{ $ref: \"textColor\" }, { $ref: \"backgroundColor\" }, 0.38] },\n      textColor: { $ref: \"foregroundColor\" },\n      chromeBackgroundColor: { $foregroundBackgroundMix: [0.975] },\n      chromeFontFamily: { $ref: \"fontFamily\" },\n      chromeFontSize: { $ref: \"fontSize\" },\n      chromeFontWeight: { $ref: \"fontWeight\" },\n      chromeTextColor: \"#181d1f\",\n      chromeSubtleTextColor: { $mix: [{ $ref: \"chromeTextColor\" }, { $ref: \"backgroundColor\" }, 0.38] },\n      inputBackgroundColor: { $ref: \"backgroundColor\" },\n      inputTextColor: { $ref: \"textColor\" },\n      crosshairLabelBackgroundColor: { $ref: \"foregroundColor\" },\n      crosshairLabelTextColor: { $ref: \"backgroundColor\" }\n    };\n  }\n  // Private parameters that are not exposed in the themes API.\n  getTemplateParameters() {\n    const { isEnterprise } = enterpriseModule;\n    const params = /* @__PURE__ */ new Map();\n    params.set(IS_DARK_THEME, false);\n    params.set(IS_ENTERPRISE, isEnterprise);\n    params.set(IS_COMMUNITY, !isEnterprise);\n    params.set(DEFAULT_SEPARATION_LINES_COLOUR, \"#d9d9d9\");\n    params.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_SHADOW_COLOUR, \"#00000080\");\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      DEFAULT_FILLS.ORANGE,\n      DEFAULT_FILLS.YELLOW,\n      DEFAULT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_COLOR_RANGE, [DEFAULT_FILLS.BLUE, DEFAULT_FILLS.RED]);\n    params.set(DEFAULT_SPARKLINE_CROSSHAIR_STROKE, \"#aaa\");\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [DEFAULT_FILLS.GREEN, DEFAULT_FILLS.YELLOW, DEFAULT_FILLS.RED]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#5090dc\",\n      \"#629be0\",\n      \"#73a6e3\",\n      \"#85b1e7\",\n      \"#96bcea\",\n      \"#a8c8ee\",\n      \"#b9d3f1\",\n      \"#cbdef5\"\n    ]);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"block\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"center\");\n    params.set(DEFAULT_HIERARCHY_FILLS, [\"#fff\", \"#e0e5ea\", \"#c1ccd5\", \"#a3b4c1\", \"#859cad\"]);\n    params.set(DEFAULT_HIERARCHY_STROKES, [\"#fff\", \"#c5cbd1\", \"#a4b1bd\", \"#8498a9\", \"#648096\"]);\n    params.set(DEFAULT_FIBONACCI_STROKES, [\n      \"#797b86\",\n      \"#e24c4a\",\n      \"#f49d2d\",\n      \"#65ab58\",\n      \"#409682\",\n      \"#4db9d2\",\n      \"#5090dc\",\n      \"#3068f9\",\n      \"#e24c4a\",\n      \"#913aac\",\n      \"#d93e64\"\n    ]);\n    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_TEXT_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_STATISTICS_FILL, \"#fafafa\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_STROKE, \"#ddd\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_COLOR, \"#000\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE, \"#181d1f\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL, \"#e35c5c\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE, \"#e35c5c\");\n    params.set(DEFAULT_TEXTBOX_FILL, \"#fafafa\");\n    params.set(DEFAULT_TEXTBOX_STROKE, \"#ddd\");\n    params.set(DEFAULT_TEXTBOX_COLOR, \"#000\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"top\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, false);\n    const defaultColors = this.getDefaultColors();\n    params.set(PALETTE_UP_STROKE, this.palette.up?.stroke ?? defaultColors.up.stroke);\n    params.set(PALETTE_UP_FILL, this.palette.up?.fill ?? defaultColors.up.fill);\n    params.set(PALETTE_DOWN_STROKE, this.palette.down?.stroke ?? defaultColors.down.stroke);\n    params.set(PALETTE_DOWN_FILL, this.palette.down?.fill ?? defaultColors.down.fill);\n    params.set(PALETTE_NEUTRAL_STROKE, this.palette.neutral?.stroke ?? defaultColors.neutral.stroke);\n    params.set(PALETTE_NEUTRAL_FILL, this.palette.neutral?.fill ?? defaultColors.neutral.fill);\n    params.set(PALETTE_ALT_UP_STROKE, this.palette.altUp?.stroke ?? defaultColors.up.stroke);\n    params.set(PALETTE_ALT_UP_FILL, this.palette.altUp?.fill ?? defaultColors.up.fill);\n    params.set(PALETTE_ALT_DOWN_STROKE, this.palette.altDown?.stroke ?? defaultColors.down.stroke);\n    params.set(PALETTE_ALT_DOWN_FILL, this.palette.altDown?.fill ?? defaultColors.down.fill);\n    params.set(PALETTE_ALT_NEUTRAL_FILL, this.palette.altNeutral?.fill ?? defaultColors.altNeutral.fill);\n    params.set(PALETTE_ALT_NEUTRAL_STROKE, this.palette.altNeutral?.stroke ?? defaultColors.altNeutral.stroke);\n    return params;\n  }\n};\n_ChartTheme.cartesianAxisDefault = {\n  [\"number\" /* NUMBER */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  [\"log\" /* LOG */]: _ChartTheme.getAxisDefaults({\n    base: 10,\n    line: { enabled: false },\n    interval: { minSpacing: NaN }\n  }),\n  [\"category\" /* CATEGORY */]: _ChartTheme.getAxisDefaults({\n    groupPaddingInner: 0.1,\n    label: { autoRotate: true },\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED },\n    crosshair: { enabled: false }\n  }),\n  [\"grouped-category\" /* GROUPED_CATEGORY */]: _ChartTheme.getAxisDefaults({\n    tick: { enabled: true, stroke: DEFAULT_SEPARATION_LINES_COLOUR },\n    label: { spacing: 10, rotation: 270 },\n    paddingInner: 0.4,\n    groupPaddingInner: 0.2,\n    crosshair: { enabled: false }\n  }),\n  [\"time\" /* TIME */]: _ChartTheme.getAxisDefaults({ gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED } }),\n  [\"ordinal-time\" /* ORDINAL_TIME */]: _ChartTheme.getAxisDefaults({\n    groupPaddingInner: 0,\n    label: { autoRotate: false },\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }\n  }),\n  [\"angle-category\" /* ANGLE_CATEGORY */]: _ChartTheme.getAxisDefaults({\n    label: { spacing: 5 },\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }\n  }),\n  [\"angle-number\" /* ANGLE_NUMBER */]: _ChartTheme.getAxisDefaults({\n    label: { spacing: 5 },\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }\n  }),\n  [\"radius-category\" /* RADIUS_CATEGORY */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  [\"radius-number\" /* RADIUS_NUMBER */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  })\n};\nvar ChartTheme = _ChartTheme;\n\n// packages/ag-charts-community/src/chart/themes/darkTheme.ts\nvar DEFAULT_DARK_BACKGROUND_FILL = \"#192232\";\nvar DEFAULT_DARK_FILLS = {\n  BLUE: \"#5090dc\",\n  ORANGE: \"#ffa03a\",\n  GREEN: \"#459d55\",\n  CYAN: \"#34bfe1\",\n  YELLOW: \"#e1cc00\",\n  VIOLET: \"#9669cb\",\n  GRAY: \"#b5b5b5\",\n  MAGENTA: \"#bd5aa7\",\n  BROWN: \"#8a6224\",\n  RED: \"#ef5452\"\n};\nvar DEFAULT_DARK_STROKES = {\n  BLUE: \"#74a8e6\",\n  ORANGE: \"#ffbe70\",\n  GREEN: \"#6cb176\",\n  CYAN: \"#75d4ef\",\n  YELLOW: \"#f6e559\",\n  VIOLET: \"#aa86d8\",\n  GRAY: \"#a1a1a1\",\n  MAGENTA: \"#ce7ab9\",\n  BROWN: \"#997b52\",\n  RED: \"#ff7872\"\n};\nvar DarkTheme = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: DEFAULT_DARK_FILLS,\n      strokes: DEFAULT_DARK_STROKES,\n      up: { fill: DEFAULT_DARK_FILLS.GREEN, stroke: DEFAULT_DARK_STROKES.GREEN },\n      down: { fill: DEFAULT_DARK_FILLS.RED, stroke: DEFAULT_DARK_STROKES.RED },\n      neutral: { fill: DEFAULT_DARK_FILLS.GRAY, stroke: DEFAULT_DARK_STROKES.GRAY },\n      altUp: { fill: DEFAULT_DARK_FILLS.BLUE, stroke: DEFAULT_DARK_STROKES.BLUE },\n      altDown: { fill: DEFAULT_DARK_FILLS.ORANGE, stroke: DEFAULT_DARK_STROKES.ORANGE },\n      altNeutral: { fill: DEFAULT_DARK_FILLS.GRAY, stroke: DEFAULT_DARK_STROKES.GRAY }\n    };\n  }\n  getPublicParameters() {\n    return {\n      ...super.getPublicParameters(),\n      axisColor: { $foregroundBackgroundMix: [0.263] },\n      backgroundColor: DEFAULT_DARK_BACKGROUND_FILL,\n      borderColor: { $foregroundBackgroundMix: [0.784] },\n      chromeBackgroundColor: { $foregroundBackgroundMix: [0.93] },\n      foregroundColor: \"#fff\",\n      gridLineColor: { $foregroundBackgroundAccentMix: [0.743, 0.01] },\n      subtleTextColor: { $mix: [{ $ref: \"textColor\" }, { $ref: \"backgroundColor\" }, 0.57] },\n      chromeTextColor: { $ref: \"textColor\" },\n      crosshairLabelBackgroundColor: { $foregroundBackgroundAccentMix: [0.35, 0.1] }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(IS_DARK_THEME, true);\n    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_SEPARATION_LINES_COLOUR, \"#7f8389\");\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      DEFAULT_DARK_FILLS.ORANGE,\n      DEFAULT_DARK_FILLS.YELLOW,\n      DEFAULT_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      DEFAULT_DARK_FILLS.GREEN,\n      DEFAULT_DARK_FILLS.YELLOW,\n      DEFAULT_DARK_FILLS.RED\n    ]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#5090dc\",\n      \"#4882c6\",\n      \"#4073b0\",\n      \"#38659a\",\n      \"#305684\",\n      \"#28486e\",\n      \"#203a58\",\n      \"#182b42\"\n    ]);\n    params.set(DEFAULT_HIERARCHY_FILLS, [\"#192834\", \"#253746\", \"#324859\", \"#3f596c\", \"#4d6a80\"]);\n    params.set(DEFAULT_HIERARCHY_STROKES, [\"#192834\", \"#3b5164\", \"#496275\", \"#577287\", \"#668399\"]);\n    params.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, DEFAULT_DARK_FILLS.BLUE);\n    params.set(DEFAULT_TEXT_ANNOTATION_COLOR, \"#fff\");\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, DEFAULT_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_STATISTICS_FILL, \"#28313e\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_STROKE, \"#4b525d\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_COLOR, \"#fff\");\n    params.set(DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE, \"#fff\");\n    params.set(DEFAULT_TEXTBOX_FILL, \"#28313e\");\n    params.set(DEFAULT_TEXTBOX_STROKE, \"#4b525d\");\n    params.set(DEFAULT_TEXTBOX_COLOR, \"#fff\");\n    return params;\n  }\n  constructor(options) {\n    super(options);\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/financialDark.ts\nvar FINANCIAL_DARK_FILLS = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#A9A9A9\"\n};\nvar FINANCIAL_DARK_STROKES = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#909090\"\n};\nvar FinancialDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...FINANCIAL_DARK_FILLS },\n      strokes: { ...FINANCIAL_DARK_STROKES },\n      up: { fill: FINANCIAL_DARK_FILLS.GREEN, stroke: FINANCIAL_DARK_STROKES.GREEN },\n      down: { fill: FINANCIAL_DARK_FILLS.RED, stroke: FINANCIAL_DARK_STROKES.RED },\n      neutral: { fill: FINANCIAL_DARK_FILLS.BLUE, stroke: FINANCIAL_DARK_STROKES.BLUE },\n      altUp: { fill: FINANCIAL_DARK_FILLS.GREEN, stroke: FINANCIAL_DARK_STROKES.GREEN },\n      altDown: { fill: FINANCIAL_DARK_FILLS.RED, stroke: FINANCIAL_DARK_STROKES.RED },\n      altNeutral: { fill: FINANCIAL_DARK_FILLS.GRAY, stroke: FINANCIAL_DARK_STROKES.GRAY }\n    };\n  }\n  getPublicParameters() {\n    return {\n      ...super.getPublicParameters(),\n      gridLineColor: { $foregroundBackgroundAccentMix: [0.88, 0.01] },\n      padding: 0\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      FINANCIAL_DARK_FILLS.GREEN,\n      FINANCIAL_DARK_FILLS.BLUE,\n      FINANCIAL_DARK_FILLS.RED\n    ]);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, FINANCIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, FINANCIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"overlay\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"left\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"bottom\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, true);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/financialLight.ts\nvar FINANCIAL_LIGHT_FILLS = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#A9A9A9\"\n};\nvar FINANCIAL_LIGHT_STROKES = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#909090\"\n};\nvar FinancialLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...FINANCIAL_LIGHT_FILLS },\n      strokes: { ...FINANCIAL_LIGHT_STROKES },\n      up: { fill: FINANCIAL_LIGHT_FILLS.GREEN, stroke: FINANCIAL_LIGHT_STROKES.GREEN },\n      down: { fill: FINANCIAL_LIGHT_FILLS.RED, stroke: FINANCIAL_LIGHT_STROKES.RED },\n      neutral: { fill: FINANCIAL_LIGHT_FILLS.BLUE, stroke: FINANCIAL_LIGHT_STROKES.BLUE },\n      altUp: { fill: FINANCIAL_LIGHT_FILLS.GREEN, stroke: FINANCIAL_LIGHT_STROKES.GREEN },\n      altDown: { fill: FINANCIAL_LIGHT_FILLS.RED, stroke: FINANCIAL_LIGHT_STROKES.RED },\n      altNeutral: { fill: FINANCIAL_LIGHT_FILLS.GRAY, stroke: FINANCIAL_LIGHT_STROKES.GRAY }\n    };\n  }\n  getPublicParameters() {\n    return {\n      ...super.getPublicParameters(),\n      gridLineColor: { $foregroundBackgroundAccentMix: [0.94, 0.01] },\n      padding: 0\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      FINANCIAL_LIGHT_FILLS.GREEN,\n      FINANCIAL_LIGHT_FILLS.BLUE,\n      FINANCIAL_LIGHT_FILLS.RED\n    ]);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, FINANCIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, FINANCIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"overlay\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"left\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"bottom\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, true);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/materialDark.ts\nvar MATERIAL_DARK_FILLS = {\n  BLUE: \"#2196F3\",\n  ORANGE: \"#FF9800\",\n  GREEN: \"#4CAF50\",\n  CYAN: \"#00BCD4\",\n  YELLOW: \"#FFEB3B\",\n  VIOLET: \"#7E57C2\",\n  GRAY: \"#9E9E9E\",\n  MAGENTA: \"#F06292\",\n  BROWN: \"#795548\",\n  RED: \"#F44336\"\n};\nvar MATERIAL_DARK_STROKES = {\n  BLUE: \"#90CAF9\",\n  ORANGE: \"#FFCC80\",\n  GREEN: \"#A5D6A7\",\n  CYAN: \"#80DEEA\",\n  YELLOW: \"#FFF9C4\",\n  VIOLET: \"#B39DDB\",\n  GRAY: \"#E0E0E0\",\n  MAGENTA: \"#F48FB1\",\n  BROWN: \"#A1887F\",\n  RED: \"#EF9A9A\"\n};\nvar MaterialDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: MATERIAL_DARK_FILLS,\n      strokes: MATERIAL_DARK_STROKES,\n      up: { fill: MATERIAL_DARK_FILLS.GREEN, stroke: MATERIAL_DARK_STROKES.GREEN },\n      down: { fill: MATERIAL_DARK_FILLS.RED, stroke: MATERIAL_DARK_STROKES.RED },\n      neutral: { fill: MATERIAL_DARK_FILLS.GRAY, stroke: MATERIAL_DARK_STROKES.GRAY },\n      altUp: { fill: MATERIAL_DARK_FILLS.BLUE, stroke: MATERIAL_DARK_STROKES.BLUE },\n      altDown: { fill: MATERIAL_DARK_FILLS.RED, stroke: MATERIAL_DARK_STROKES.RED },\n      altNeutral: { fill: MATERIAL_DARK_FILLS.GRAY, stroke: MATERIAL_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      MATERIAL_DARK_FILLS.ORANGE,\n      MATERIAL_DARK_FILLS.YELLOW,\n      MATERIAL_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#2196f3\",\n      // 500\n      \"#208FEC\",\n      // (interpolated)\n      \"#1E88E5\",\n      // 600\n      \"#1C7FDC\",\n      // (interpolated)\n      \"#1976d2\",\n      // 700\n      \"#176EC9\",\n      // (interpolated)\n      \"#1565c0\"\n      // 800\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      MATERIAL_DARK_FILLS.GREEN,\n      MATERIAL_DARK_FILLS.YELLOW,\n      MATERIAL_DARK_FILLS.RED\n    ]);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, MATERIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, MATERIAL_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/materialLight.ts\nvar MATERIAL_LIGHT_FILLS = {\n  BLUE: \"#2196F3\",\n  ORANGE: \"#FF9800\",\n  GREEN: \"#4CAF50\",\n  CYAN: \"#00BCD4\",\n  YELLOW: \"#FFEB3B\",\n  VIOLET: \"#7E57C2\",\n  GRAY: \"#9E9E9E\",\n  MAGENTA: \"#F06292\",\n  BROWN: \"#795548\",\n  RED: \"#F44336\"\n};\nvar MATERIAL_LIGHT_STROKES = {\n  BLUE: \"#1565C0\",\n  ORANGE: \"#E65100\",\n  GREEN: \"#2E7D32\",\n  CYAN: \"#00838F\",\n  YELLOW: \"#F9A825\",\n  VIOLET: \"#4527A0\",\n  GRAY: \"#616161\",\n  MAGENTA: \"#C2185B\",\n  BROWN: \"#4E342E\",\n  RED: \"#B71C1C\"\n};\nvar MaterialLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: MATERIAL_LIGHT_FILLS,\n      strokes: MATERIAL_LIGHT_STROKES,\n      up: { fill: MATERIAL_LIGHT_FILLS.GREEN, stroke: MATERIAL_LIGHT_STROKES.GREEN },\n      down: { fill: MATERIAL_LIGHT_FILLS.RED, stroke: MATERIAL_LIGHT_STROKES.RED },\n      neutral: { fill: MATERIAL_LIGHT_FILLS.GRAY, stroke: MATERIAL_LIGHT_STROKES.GRAY },\n      altUp: { fill: MATERIAL_LIGHT_FILLS.BLUE, stroke: MATERIAL_LIGHT_STROKES.BLUE },\n      altDown: { fill: MATERIAL_LIGHT_FILLS.RED, stroke: MATERIAL_LIGHT_STROKES.RED },\n      altNeutral: { fill: MATERIAL_LIGHT_FILLS.GRAY, stroke: MATERIAL_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      MATERIAL_LIGHT_FILLS.ORANGE,\n      MATERIAL_LIGHT_FILLS.YELLOW,\n      MATERIAL_LIGHT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#2196f3\",\n      // 500\n      \"#329EF4\",\n      // (interpolated)\n      \"#42a5f5\",\n      // 400\n      \"#53ADF6\",\n      // (interpolated)\n      \"#64b5f6\",\n      // 300\n      \"#7AC0F8\",\n      // (interpolated)\n      \"#90caf9\"\n      // 200\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      MATERIAL_LIGHT_FILLS.GREEN,\n      MATERIAL_LIGHT_FILLS.YELLOW,\n      MATERIAL_LIGHT_FILLS.RED\n    ]);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, MATERIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, MATERIAL_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/polychromaDark.ts\nvar POLYCHROMA_DARK_FILLS = {\n  BLUE: \"#436ff4\",\n  PURPLE: \"#9a7bff\",\n  MAGENTA: \"#d165d2\",\n  PINK: \"#f0598b\",\n  RED: \"#f47348\",\n  ORANGE: \"#f2a602\",\n  YELLOW: \"#e9e201\",\n  GREEN: \"#21b448\",\n  CYAN: \"#00b9a2\",\n  MODERATE_BLUE: \"#00aee4\",\n  GRAY: \"#bbbbbb\"\n};\nvar POLYCHROMA_DARK_STROKES = {\n  BLUE: \"#6698ff\",\n  PURPLE: \"#c0a3ff\",\n  MAGENTA: \"#fc8dfc\",\n  PINK: \"#ff82b1\",\n  RED: \"#ff9b70\",\n  ORANGE: \"#ffcf4e\",\n  YELLOW: \"#ffff58\",\n  GREEN: \"#58dd70\",\n  CYAN: \"#51e2c9\",\n  MODERATE_BLUE: \"#4fd7ff\",\n  GRAY: \"#eeeeee\"\n};\nvar PolychromaDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: POLYCHROMA_DARK_FILLS,\n      strokes: POLYCHROMA_DARK_STROKES,\n      up: { fill: POLYCHROMA_DARK_FILLS.GREEN, stroke: POLYCHROMA_DARK_STROKES.GREEN },\n      down: { fill: POLYCHROMA_DARK_FILLS.RED, stroke: POLYCHROMA_DARK_STROKES.RED },\n      neutral: { fill: POLYCHROMA_DARK_FILLS.GRAY, stroke: POLYCHROMA_DARK_STROKES.GRAY },\n      altUp: { fill: POLYCHROMA_DARK_FILLS.BLUE, stroke: POLYCHROMA_DARK_STROKES.BLUE },\n      altDown: { fill: POLYCHROMA_DARK_FILLS.RED, stroke: POLYCHROMA_DARK_STROKES.RED },\n      altNeutral: { fill: POLYCHROMA_DARK_FILLS.GRAY, stroke: POLYCHROMA_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [POLYCHROMA_DARK_FILLS.BLUE, POLYCHROMA_DARK_FILLS.RED]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      POLYCHROMA_DARK_FILLS.BLUE,\n      POLYCHROMA_DARK_FILLS.PURPLE,\n      POLYCHROMA_DARK_FILLS.MAGENTA,\n      POLYCHROMA_DARK_FILLS.PINK,\n      POLYCHROMA_DARK_FILLS.RED,\n      POLYCHROMA_DARK_FILLS.ORANGE,\n      POLYCHROMA_DARK_FILLS.YELLOW,\n      POLYCHROMA_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [POLYCHROMA_DARK_FILLS.BLUE, POLYCHROMA_DARK_FILLS.RED]);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, POLYCHROMA_DARK_FILLS.BLUE);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/polychromaLight.ts\nvar POLYCHROMA_LIGHT_FILLS = {\n  BLUE: \"#436ff4\",\n  PURPLE: \"#9a7bff\",\n  MAGENTA: \"#d165d2\",\n  PINK: \"#f0598b\",\n  RED: \"#f47348\",\n  ORANGE: \"#f2a602\",\n  YELLOW: \"#e9e201\",\n  GREEN: \"#21b448\",\n  CYAN: \"#00b9a2\",\n  MODERATE_BLUE: \"#00aee4\",\n  GRAY: \"#bbbbbb\"\n};\nvar POLYCHROMA_LIGHT_STROKES = {\n  BLUE: \"#2346c9\",\n  PURPLE: \"#7653d4\",\n  MAGENTA: \"#a73da9\",\n  PINK: \"#c32d66\",\n  RED: \"#c84b1c\",\n  ORANGE: \"#c87f00\",\n  YELLOW: \"#c1b900\",\n  GREEN: \"#008c1c\",\n  CYAN: \"#00927c\",\n  MODERATE_BLUE: \"#0087bb\",\n  GRAY: \"#888888\"\n};\nvar PolychromaLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: POLYCHROMA_LIGHT_FILLS,\n      strokes: POLYCHROMA_LIGHT_STROKES,\n      up: { fill: POLYCHROMA_LIGHT_FILLS.GREEN, stroke: POLYCHROMA_LIGHT_STROKES.GREEN },\n      down: { fill: POLYCHROMA_LIGHT_FILLS.RED, stroke: POLYCHROMA_LIGHT_STROKES.RED },\n      neutral: { fill: POLYCHROMA_LIGHT_FILLS.GRAY, stroke: POLYCHROMA_LIGHT_STROKES.GRAY },\n      altUp: { fill: POLYCHROMA_LIGHT_FILLS.BLUE, stroke: POLYCHROMA_LIGHT_STROKES.BLUE },\n      altDown: { fill: POLYCHROMA_LIGHT_FILLS.RED, stroke: POLYCHROMA_LIGHT_STROKES.RED },\n      altNeutral: { fill: POLYCHROMA_LIGHT_FILLS.GRAY, stroke: POLYCHROMA_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [POLYCHROMA_LIGHT_FILLS.BLUE, POLYCHROMA_LIGHT_FILLS.RED]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      POLYCHROMA_LIGHT_FILLS.BLUE,\n      POLYCHROMA_LIGHT_FILLS.PURPLE,\n      POLYCHROMA_LIGHT_FILLS.MAGENTA,\n      POLYCHROMA_LIGHT_FILLS.PINK,\n      POLYCHROMA_LIGHT_FILLS.RED,\n      POLYCHROMA_LIGHT_FILLS.ORANGE,\n      POLYCHROMA_LIGHT_FILLS.YELLOW,\n      POLYCHROMA_LIGHT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [POLYCHROMA_LIGHT_FILLS.BLUE, POLYCHROMA_LIGHT_FILLS.RED]);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, POLYCHROMA_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/sheetsDark.ts\nvar SHEETS_DARK_FILLS = {\n  BLUE: \"#4472C4\",\n  ORANGE: \"#ED7D31\",\n  GRAY: \"#A5A5A5\",\n  YELLOW: \"#FFC000\",\n  MODERATE_BLUE: \"#5B9BD5\",\n  GREEN: \"#70AD47\",\n  DARK_GRAY: \"#7B7B7B\",\n  DARK_BLUE: \"#264478\",\n  VERY_DARK_GRAY: \"#636363\",\n  DARK_YELLOW: \"#997300\"\n};\nvar SHEETS_DARK_STROKES = {\n  BLUE: \"#6899ee\",\n  ORANGE: \"#ffa55d\",\n  GRAY: \"#cdcdcd\",\n  YELLOW: \"#ffea53\",\n  MODERATE_BLUE: \"#82c3ff\",\n  GREEN: \"#96d56f\",\n  DARK_GRAY: \"#a1a1a1\",\n  DARK_BLUE: \"#47689f\",\n  VERY_DARK_GRAY: \"#878787\",\n  DARK_YELLOW: \"#c0993d\"\n};\nvar SheetsDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...SHEETS_DARK_FILLS, RED: SHEETS_DARK_FILLS.ORANGE },\n      strokes: { ...SHEETS_DARK_STROKES, RED: SHEETS_DARK_STROKES.ORANGE },\n      up: { fill: SHEETS_DARK_FILLS.GREEN, stroke: SHEETS_DARK_STROKES.GREEN },\n      down: { fill: SHEETS_DARK_FILLS.ORANGE, stroke: SHEETS_DARK_STROKES.ORANGE },\n      neutral: { fill: SHEETS_DARK_FILLS.GRAY, stroke: SHEETS_DARK_STROKES.GRAY },\n      altUp: { fill: SHEETS_DARK_FILLS.BLUE, stroke: SHEETS_DARK_STROKES.BLUE },\n      altDown: { fill: SHEETS_DARK_FILLS.ORANGE, stroke: SHEETS_DARK_STROKES.ORANGE },\n      altNeutral: { fill: SHEETS_DARK_FILLS.GRAY, stroke: SHEETS_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      SHEETS_DARK_FILLS.ORANGE,\n      SHEETS_DARK_FILLS.YELLOW,\n      SHEETS_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      SHEETS_DARK_FILLS.GREEN,\n      SHEETS_DARK_FILLS.YELLOW,\n      SHEETS_DARK_FILLS.ORANGE\n    ]);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, SHEETS_DARK_FILLS.BLUE);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, SHEETS_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/sheetsLight.ts\nvar SHEETS_LIGHT_FILLS = {\n  BLUE: \"#5281d5\",\n  ORANGE: \"#ff8d44\",\n  GRAY: \"#b5b5b5\",\n  YELLOW: \"#ffd02f\",\n  MODERATE_BLUE: \"#6aabe6\",\n  GREEN: \"#7fbd57\",\n  DARK_GRAY: \"#8a8a8a\",\n  DARK_BLUE: \"#335287\",\n  VERY_DARK_GRAY: \"#717171\",\n  DARK_YELLOW: \"#a98220\"\n};\nvar SHEETS_LIGHT_STROKES = {\n  BLUE: \"#214d9b\",\n  ORANGE: \"#c25600\",\n  GRAY: \"#7f7f7f\",\n  YELLOW: \"#d59800\",\n  MODERATE_BLUE: \"#3575ac\",\n  GREEN: \"#4b861a\",\n  DARK_GRAY: \"#575757\",\n  DARK_BLUE: \"#062253\",\n  VERY_DARK_GRAY: \"#414141\",\n  DARK_YELLOW: \"#734f00\"\n};\nvar SheetsLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...SHEETS_LIGHT_FILLS, RED: SHEETS_LIGHT_FILLS.ORANGE },\n      strokes: { ...SHEETS_LIGHT_STROKES, RED: SHEETS_LIGHT_STROKES.ORANGE },\n      up: { fill: SHEETS_LIGHT_FILLS.GREEN, stroke: SHEETS_LIGHT_STROKES.GREEN },\n      down: { fill: SHEETS_LIGHT_FILLS.ORANGE, stroke: SHEETS_LIGHT_STROKES.ORANGE },\n      neutral: { fill: SHEETS_LIGHT_STROKES.GRAY, stroke: SHEETS_LIGHT_STROKES.GRAY },\n      altUp: { fill: SHEETS_LIGHT_FILLS.BLUE, stroke: SHEETS_LIGHT_STROKES.BLUE },\n      altDown: { fill: SHEETS_LIGHT_FILLS.ORANGE, stroke: SHEETS_LIGHT_STROKES.ORANGE },\n      altNeutral: { fill: SHEETS_LIGHT_FILLS.GRAY, stroke: SHEETS_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      SHEETS_LIGHT_FILLS.ORANGE,\n      SHEETS_LIGHT_FILLS.YELLOW,\n      SHEETS_LIGHT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      SHEETS_LIGHT_FILLS.GREEN,\n      SHEETS_LIGHT_FILLS.YELLOW,\n      SHEETS_LIGHT_FILLS.ORANGE\n    ]);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, SHEETS_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, SHEETS_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/vividDark.ts\nvar VIVID_DARK_FILLS = {\n  BLUE: \"#0083ff\",\n  ORANGE: \"#ff6600\",\n  GREEN: \"#00af00\",\n  CYAN: \"#00ccff\",\n  YELLOW: \"#f7c700\",\n  VIOLET: \"#ac26ff\",\n  GRAY: \"#a7a7b7\",\n  MAGENTA: \"#e800c5\",\n  BROWN: \"#b54300\",\n  RED: \"#ff0000\"\n};\nvar VIVID_DARK_STROKES = {\n  BLUE: \"#67b7ff\",\n  ORANGE: \"#ffc24d\",\n  GREEN: \"#5cc86f\",\n  CYAN: \"#54ebff\",\n  VIOLET: \"#fff653\",\n  YELLOW: \"#c18aff\",\n  GRAY: \"#aeaeae\",\n  MAGENTA: \"#f078d4\",\n  BROWN: \"#ba8438\",\n  RED: \"#ff726e\"\n};\nvar VividDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: VIVID_DARK_FILLS,\n      strokes: VIVID_DARK_STROKES,\n      up: { fill: VIVID_DARK_FILLS.GREEN, stroke: VIVID_DARK_STROKES.GREEN },\n      down: { fill: VIVID_DARK_FILLS.RED, stroke: VIVID_DARK_STROKES.RED },\n      neutral: { fill: VIVID_DARK_FILLS.GRAY, stroke: VIVID_DARK_STROKES.GRAY },\n      altUp: { fill: VIVID_DARK_FILLS.BLUE, stroke: VIVID_DARK_STROKES.BLUE },\n      altDown: { fill: VIVID_DARK_FILLS.ORANGE, stroke: VIVID_DARK_STROKES.ORANGE },\n      altNeutral: { fill: VIVID_DARK_FILLS.GRAY, stroke: VIVID_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [\n      VIVID_DARK_FILLS.ORANGE,\n      VIVID_DARK_FILLS.YELLOW,\n      VIVID_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#0083ff\",\n      \"#0076e6\",\n      \"#0069cc\",\n      \"#005cb3\",\n      \"#004f99\",\n      \"#004280\",\n      \"#003466\",\n      \"#00274c\"\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [\n      VIVID_DARK_FILLS.GREEN,\n      VIVID_DARK_FILLS.YELLOW,\n      VIVID_DARK_FILLS.RED\n    ]);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, VIVID_DARK_FILLS.BLUE);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, VIVID_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/vividLight.ts\nvar VIVID_FILLS = {\n  BLUE: \"#0083ff\",\n  ORANGE: \"#ff6600\",\n  GREEN: \"#00af00\",\n  CYAN: \"#00ccff\",\n  YELLOW: \"#f7c700\",\n  VIOLET: \"#ac26ff\",\n  GRAY: \"#a7a7b7\",\n  MAGENTA: \"#e800c5\",\n  BROWN: \"#b54300\",\n  RED: \"#ff0000\"\n};\nvar VIVID_STROKES = {\n  BLUE: \"#0f68c0\",\n  ORANGE: \"#d47100\",\n  GREEN: \"#007922\",\n  CYAN: \"#009ac2\",\n  VIOLET: \"#bca400\",\n  YELLOW: \"#753cac\",\n  GRAY: \"#646464\",\n  MAGENTA: \"#9b2685\",\n  BROWN: \"#6c3b00\",\n  RED: \"#cb0021\"\n};\nvar VividLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: VIVID_FILLS,\n      strokes: VIVID_STROKES,\n      up: { fill: VIVID_FILLS.GREEN, stroke: VIVID_STROKES.GREEN },\n      down: { fill: VIVID_FILLS.RED, stroke: VIVID_STROKES.RED },\n      neutral: { fill: VIVID_FILLS.GRAY, stroke: VIVID_STROKES.GRAY },\n      altUp: { fill: VIVID_FILLS.BLUE, stroke: VIVID_STROKES.BLUE },\n      altDown: { fill: VIVID_FILLS.ORANGE, stroke: VIVID_STROKES.ORANGE },\n      altNeutral: { fill: VIVID_FILLS.GRAY, stroke: VIVID_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOR_RANGE, [VIVID_FILLS.ORANGE, VIVID_FILLS.YELLOW, VIVID_FILLS.GREEN]);\n    params.set(DEFAULT_FUNNEL_SERIES_COLOR_RANGE, [\n      \"#0083ff\",\n      \"#1a8fff\",\n      \"#339cff\",\n      \"#4da8ff\",\n      \"#66b5ff\",\n      \"#80c1ff\",\n      \"#99cdff\",\n      \"#b3daff\"\n    ]);\n    params.set(DEFAULT_GAUGE_SERIES_COLOR_RANGE, [VIVID_FILLS.GREEN, VIVID_FILLS.YELLOW, VIVID_FILLS.RED]);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, VIVID_FILLS.BLUE);\n    params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, VIVID_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/mapping/themes.ts\nvar lightTheme = simpleMemorize(() => new ChartTheme());\nvar darkTheme = simpleMemorize(() => new DarkTheme());\nvar themes = {\n  // darkThemes,\n  \"ag-default-dark\": darkTheme,\n  \"ag-sheets-dark\": simpleMemorize(() => new SheetsDark()),\n  \"ag-polychroma-dark\": simpleMemorize(() => new PolychromaDark()),\n  \"ag-vivid-dark\": simpleMemorize(() => new VividDark()),\n  \"ag-material-dark\": simpleMemorize(() => new MaterialDark()),\n  \"ag-financial-dark\": simpleMemorize(() => new FinancialDark()),\n  // lightThemes,\n  null: lightTheme,\n  undefined: lightTheme,\n  \"ag-default\": lightTheme,\n  \"ag-sheets\": simpleMemorize(() => new SheetsLight()),\n  \"ag-polychroma\": simpleMemorize(() => new PolychromaLight()),\n  \"ag-vivid\": simpleMemorize(() => new VividLight()),\n  \"ag-material\": simpleMemorize(() => new MaterialLight()),\n  \"ag-financial\": simpleMemorize(() => new FinancialLight())\n};\nvar getChartTheme = simpleMemorize(createChartTheme);\nfunction createChartTheme(value) {\n  if (value instanceof ChartTheme) {\n    return value;\n  }\n  if (value == null || typeof value === \"string\") {\n    const stockTheme = themes[value];\n    if (stockTheme) {\n      return stockTheme();\n    }\n    logger_exports.warnOnce(`the theme [${value}] is invalid, using [ag-default] instead.`);\n    return lightTheme();\n  }\n  const { errors } = validate(value, themeOptionsDef, \"theme\");\n  if (!errors.length) {\n    const flattenedTheme = reduceThemeOptions(value);\n    const baseTheme = flattenedTheme.baseTheme ? getChartTheme(flattenedTheme.baseTheme) : lightTheme();\n    return new baseTheme.constructor(flattenedTheme);\n  }\n  for (const { message } of errors) {\n    logger_exports.warnOnce(message);\n  }\n  return lightTheme();\n}\nfunction reduceThemeOptions(options) {\n  let maybeNested = options;\n  let palette;\n  let params;\n  const overrides = [];\n  while (typeof maybeNested === \"object\") {\n    palette ?? (palette = maybeNested.palette);\n    params ?? (params = maybeNested.params);\n    if (maybeNested.overrides) {\n      overrides.push(maybeNested.overrides);\n    }\n    maybeNested = maybeNested.baseTheme;\n  }\n  return {\n    baseTheme: maybeNested,\n    overrides: mergeDefaults(...overrides),\n    params,\n    palette\n  };\n}\nvar themeOptionsDef = {\n  baseTheme: or(string, object),\n  overrides: object,\n  params: object,\n  palette: {\n    fills: arrayOf(string),\n    strokes: arrayOf(string),\n    up: { fill: string, stroke: string },\n    down: { fill: string, stroke: string },\n    neutral: { fill: string, stroke: string }\n  }\n};\n\n// packages/ag-charts-community/src/module/optionsModule.ts\nvar unthemedSeries = /* @__PURE__ */ new Set([\"map-shape-background\", \"map-line-background\"]);\nvar _ChartOptions = class _ChartOptions {\n  constructor(userOptions, processedOverrides, specialOverrides, metadata, deltaOptions, stripSymbols = false) {\n    this.themeParameters = {};\n    this.debug = Debug.create(true, \"opts\");\n    this.optionMetadata = metadata ?? {};\n    this.processedOverrides = processedOverrides ?? {};\n    let baseChartOptions = null;\n    if (userOptions instanceof _ChartOptions) {\n      baseChartOptions = userOptions;\n      this.specialOverrides = baseChartOptions.specialOverrides;\n      if (!deltaOptions)\n        throw new Error(\"AG Charts - internal error: deltaOptions must be supplied.\");\n      this.userOptions = mergeDefaults(\n        deltaOptions,\n        deepClone(baseChartOptions.userOptions, _ChartOptions.OPTIONS_CLONE_OPTS)\n      );\n    } else {\n      this.userOptions = userOptions;\n      this.specialOverrides = this.specialOverridesDefaults({ ...specialOverrides });\n    }\n    if (stripSymbols) {\n      this.removeLeftoverSymbols(this.userOptions);\n    }\n    let activeTheme, processedOptions, defaultAxes, fastDelta, themeParameters;\n    if (!stripSymbols && deltaOptions != null && _ChartOptions.isFastPathDelta(deltaOptions) && baseChartOptions != null) {\n      ({ activeTheme, processedOptions, defaultAxes, fastDelta } = this.fastSetup(\n        deltaOptions,\n        baseChartOptions\n      ));\n    } else {\n      ({ activeTheme, processedOptions, defaultAxes, themeParameters } = this.slowSetup(\n        processedOverrides,\n        deltaOptions,\n        stripSymbols\n      ));\n    }\n    this.activeTheme = activeTheme;\n    this.processedOptions = processedOptions;\n    this.defaultAxes = defaultAxes;\n    this.fastDelta = fastDelta;\n    this.themeParameters = themeParameters ?? {};\n  }\n  static isFastPathDelta(deltaOptions) {\n    for (const key of Object.keys(deltaOptions)) {\n      if (!this.FAST_PATH_OPTIONS.has(key))\n        return false;\n    }\n    return true;\n  }\n  fastSetup(deltaOptions, baseChartOptions) {\n    const { activeTheme, defaultAxes, processedOptions: baseOptions } = baseChartOptions;\n    const { presetType } = this.optionMetadata;\n    const processor = presetType ? PRESET_DATA_PROCESSORS[presetType] : void 0;\n    if (presetType != null && deltaOptions.data != null && processor != null) {\n      const { series, data } = processor(deltaOptions.data);\n      deltaOptions = mergeDefaults({ series, data }, deltaOptions);\n    }\n    this.fastSeriesSetup(deltaOptions, baseOptions);\n    const processedOptions = mergeDefaults(deltaOptions, baseOptions);\n    return { activeTheme, defaultAxes, processedOptions, fastDelta: deltaOptions };\n  }\n  fastSeriesSetup(deltaOptions, baseOptions) {\n    if (!deltaOptions.series)\n      return;\n    if (deltaOptions.series?.every((s, i) => jsonPropertyCompare(s, baseOptions.series?.[i] ?? {}))) {\n      delete deltaOptions[\"series\"];\n    } else {\n      deltaOptions.series = deltaOptions.series.map((s, i) => {\n        return mergeDefaults(s, baseOptions.series?.[i] ?? {});\n      });\n    }\n  }\n  slowSetup(processedOverrides, deltaOptions, stripSymbols = false) {\n    let options = deepClone(this.userOptions, _ChartOptions.OPTIONS_CLONE_OPTS);\n    if (deltaOptions) {\n      options = mergeDefaults(deltaOptions, options);\n      if (stripSymbols) {\n        this.removeLeftoverSymbols(options);\n      }\n    }\n    const { presetType } = this.optionMetadata;\n    if (presetType != null) {\n      const presetConstructor = PRESETS[presetType];\n      const presetParams = this.userOptions;\n      const presetSubType = this.userOptions.type;\n      const presetTheme = presetSubType != null ? getChartTheme(this.userOptions.theme).presets[presetSubType] : void 0;\n      this.debug(\">>> AgCharts.createOrUpdate() - applying preset\", presetParams);\n      options = presetConstructor?.(presetParams, presetTheme, () => this.activeTheme) ?? options;\n    }\n    if (!enterpriseModule.isEnterprise) {\n      removeUsedEnterpriseOptions(options);\n    }\n    const activeTheme = getChartTheme(options.theme);\n    this.sanityCheck(options);\n    this.removeDisabledOptions(options);\n    const seriesType = this.optionsType(options);\n    const {\n      axes: axesThemes = {},\n      annotations = {},\n      series: seriesTheme,\n      ...themeDefaults\n    } = this.getSeriesThemeConfig(seriesType, activeTheme);\n    const [annotationsOptions, annotationsThemes] = this.splitAnnotationsOptions(annotations);\n    this.annotationThemes = deepClone(annotationsThemes);\n    const defaultAxes = this.getDefaultAxes(options, seriesTheme);\n    let processedOptions = mergeDefaults(\n      processedOverrides,\n      options,\n      annotationsOptions,\n      themeDefaults,\n      defaultAxes\n    );\n    this.processAxesOptions(processedOptions, axesThemes);\n    this.processSeriesOptions(processedOptions, activeTheme);\n    this.processMiniChartSeriesOptions(processedOptions, activeTheme);\n    processedOptions = deepClone(processedOptions, _ChartOptions.OPTIONS_CLONE_OPTS);\n    const themeParameters = this.getThemeParameters(activeTheme, processedOptions);\n    this.resolveThemeOperations(themeParameters, themeParameters);\n    this.resolveThemeOperations(themeParameters, processedOptions);\n    this.resolveThemeOperations(themeParameters, this.annotationThemes);\n    if ((isAgCartesianChartOptions(processedOptions) || isAgStandaloneChartOptions(processedOptions) || isAgPolarChartOptionsWithSeriesBasedLegend(processedOptions)) && processedOptions.legend?.enabled == null) {\n      processedOptions.legend ?? (processedOptions.legend = {});\n      processedOptions.legend.enabled = processedOptions.series.length > 1;\n    }\n    this.enableConfiguredOptions(processedOptions, this.userOptions);\n    activeTheme.templateTheme(processedOptions, false);\n    this.removeDisabledOptions(options);\n    removeUnusedEnterpriseOptions(processedOptions);\n    if (!enterpriseModule.isEnterprise) {\n      removeUsedEnterpriseOptions(processedOptions, true);\n    }\n    this.debug(\"AgCharts.createOrUpdate() - processed options\", processedOptions);\n    return { activeTheme, processedOptions, defaultAxes, themeParameters };\n  }\n  diffOptions(other) {\n    if (this === other)\n      return {};\n    if (other == null)\n      return this.processedOptions;\n    return this.fastDelta ?? jsonDiff(other.processedOptions, this.processedOptions);\n  }\n  getSeriesThemeConfig(seriesType, activeTheme) {\n    return activeTheme?.config[seriesType] ?? {};\n  }\n  getDefaultAxes(options, seriesTheme) {\n    const optionsType2 = this.optionsType(options);\n    let firstSeriesOptions = options.series?.find((series) => (series.type ?? \"line\") === optionsType2) ?? {};\n    if (seriesRegistry.isDerivedDefaultAxes(optionsType2)) {\n      firstSeriesOptions = mergeDefaults(firstSeriesOptions, seriesTheme);\n    }\n    return seriesRegistry.cloneDefaultAxes(optionsType2, firstSeriesOptions);\n  }\n  optionsType(options) {\n    return options.series?.[0]?.type ?? \"line\";\n  }\n  sanityCheck(options) {\n    this.axesTypeIntegrity(options);\n    this.seriesTypeIntegrity(options);\n    this.soloSeriesIntegrity(options);\n  }\n  splitAnnotationsOptions(annotations) {\n    const {\n      axesButtons = null,\n      enabled = null,\n      optionsToolbar = null,\n      toolbar = null,\n      ...annotationsThemes\n    } = annotations;\n    if (axesButtons == null && enabled == null && optionsToolbar == null && toolbar == null) {\n      return [{}, annotationsThemes];\n    }\n    return [{ annotations: { axesButtons, enabled, optionsToolbar, toolbar } }, annotationsThemes];\n  }\n  processAxesOptions(options, axesThemes) {\n    if (!(\"axes\" in options))\n      return;\n    options.axes = options.axes?.map((axis) => {\n      const { crossLines: crossLinesTheme, ...axisTheme } = mergeDefaults(\n        axesThemes[axis.type]?.[axis.position],\n        axesThemes[axis.type]\n      );\n      if (axis.crossLines) {\n        axis.crossLines = mergeArrayDefaults(axis.crossLines, crossLinesTheme);\n      }\n      const gridLineStyle = axisTheme.gridLine?.style;\n      if (axis.gridLine?.style && gridLineStyle?.length) {\n        axis.gridLine.style = axis.gridLine.style.map(\n          (style, index) => style.stroke != null || style.lineDash != null ? mergeDefaults(style, gridLineStyle.at(index % gridLineStyle.length)) : style\n        );\n      }\n      const { top: _1, right: _2, bottom: _3, left: _4, ...axisOptions } = mergeDefaults(axis, axisTheme);\n      return axisOptions;\n    });\n  }\n  processSeriesOptions(options, activeTheme) {\n    const defaultTooltipPosition = this.getTooltipPositionDefaults(options);\n    const userPalette = isObject(options.theme) ? paletteType(options.theme?.palette) : \"inbuilt\";\n    const paletteOptions = {\n      colourIndex: 0,\n      userPalette\n    };\n    const processedSeries = options.series?.map((series) => {\n      series.type ?? (series.type = this.getDefaultSeriesType(options));\n      const { innerLabels: innerLabelsTheme, ...seriesTheme } = this.getSeriesThemeConfig(series.type, activeTheme).series ?? {};\n      const seriesPaletteOptions = unthemedSeries.has(series.type) ? { colourIndex: 0, userPalette } : paletteOptions;\n      const palette = this.getSeriesPalette(series.type, seriesPaletteOptions, activeTheme);\n      const defaultTooltipRange = this.getTooltipRangeDefaults(options, series.type);\n      const seriesOptions = mergeDefaults(\n        this.getSeriesGroupingOptions(series),\n        series,\n        defaultTooltipPosition,\n        defaultTooltipRange,\n        seriesTheme,\n        palette,\n        { visible: true }\n      );\n      if (seriesOptions.innerLabels) {\n        seriesOptions.innerLabels = mergeArrayDefaults(seriesOptions.innerLabels, innerLabelsTheme);\n      }\n      return seriesOptions;\n    });\n    options.series = this.setSeriesGroupingOptions(processedSeries ?? []);\n  }\n  processMiniChartSeriesOptions(options, activeTheme) {\n    let miniChartSeries = options.navigator?.miniChart?.series;\n    if (miniChartSeries == null)\n      return;\n    const paletteOptions = {\n      colourIndex: 0,\n      userPalette: isObject(options.theme) ? paletteType(options.theme.palette) : \"inbuilt\"\n    };\n    miniChartSeries = miniChartSeries.map((series) => {\n      series.type ?? (series.type = \"line\");\n      const { innerLabels: _, ...seriesTheme } = this.getSeriesThemeConfig(series.type, activeTheme).series ?? {};\n      return mergeDefaults(\n        this.getSeriesGroupingOptions(series),\n        series,\n        seriesTheme,\n        this.getSeriesPalette(series.type, paletteOptions, activeTheme)\n      );\n    });\n    options.navigator.miniChart.series = this.setSeriesGroupingOptions(miniChartSeries);\n  }\n  getThemeParameters(theme, options) {\n    const defaultParameters = theme.getPublicParameters();\n    if (!isPlainObject(options.theme) || !options.theme.params) {\n      return defaultParameters;\n    }\n    const color = attachDescription(\n      (value) => isString(value) && Color.validColorString(value),\n      `a color`\n    );\n    const themeParamsOptionsDef = {\n      accentColor: color,\n      axisColor: color,\n      backgroundColor: color,\n      borderColor: color,\n      foregroundColor: color,\n      fontFamily: string,\n      fontSize: number,\n      fontWeight: or(string, number),\n      gridLineColor: color,\n      padding: number,\n      subtleTextColor: color,\n      textColor: color,\n      chromeBackgroundColor: color,\n      chromeFontFamily: string,\n      chromeFontSize: number,\n      chromeFontWeight: or(string, number),\n      chromeSubtleTextColor: color,\n      chromeTextColor: color,\n      inputBackgroundColor: color,\n      inputTextColor: color,\n      crosshairLabelBackgroundColor: color,\n      crosshairLabelTextColor: color\n    };\n    const { valid, errors } = validate(options.theme.params, themeParamsOptionsDef);\n    for (const { message } of errors) {\n      logger_exports.warnOnce(message);\n    }\n    return mergeDefaults(valid, defaultParameters);\n  }\n  resolveThemeOperations(params, options) {\n    const modifiedPaths = jsonResolveOperations(options, params, /* @__PURE__ */ new Set([\"palette\", \"data\"]));\n    this.debug(\"resolveTheme()\", modifiedPaths);\n  }\n  getSeriesPalette(seriesType, options, activeTheme) {\n    const paletteFactory = seriesRegistry.getPaletteFactory(seriesType);\n    const { colourIndex: colourOffset, userPalette } = options;\n    const { fills = [], strokes = [] } = activeTheme.palette;\n    return paletteFactory?.({\n      userPalette,\n      colorsCount: Math.max(fills.length, strokes.length),\n      themeTemplateParameters: activeTheme.getTemplateParameters(),\n      palette: activeTheme.palette,\n      takeColors(count) {\n        options.colourIndex += count;\n        return {\n          fills: circularSliceArray(fills, count, colourOffset),\n          strokes: circularSliceArray(strokes, count, colourOffset)\n        };\n      }\n    });\n  }\n  getSeriesGroupingOptions(series) {\n    const groupable = seriesRegistry.isGroupable(series.type);\n    const stackable = seriesRegistry.isStackable(series.type);\n    const stackedByDefault = seriesRegistry.isStackedByDefault(series.type);\n    if (series.grouped && !groupable) {\n      logger_exports.warnOnce(`unsupported grouping of series type \"${series.type}\".`);\n    }\n    if ((series.stacked || series.stackGroup) && !stackable) {\n      logger_exports.warnOnce(`unsupported stacking of series type \"${series.type}\".`);\n    }\n    let { grouped, stacked } = series;\n    stacked ?? (stacked = (stackedByDefault || series.stackGroup != null) && !(groupable && grouped));\n    grouped ?? (grouped = true);\n    return {\n      stacked: stackable && stacked,\n      grouped: groupable && grouped && !(stackable && stacked)\n    };\n  }\n  setSeriesGroupingOptions(allSeries) {\n    const seriesGroups = this.getSeriesGrouping(allSeries);\n    this.debug(\"setSeriesGroupingOptions() - series grouping: \", seriesGroups);\n    const groupIdx = {};\n    const groupCount2 = seriesGroups.reduce((countMap, seriesGroup) => {\n      var _a;\n      if (seriesGroup.groupType === \"default\" /* DEFAULT */) {\n        return countMap;\n      }\n      countMap[_a = seriesGroup.seriesType] ?? (countMap[_a] = 0);\n      countMap[seriesGroup.seriesType] += seriesGroup.groupType === \"stack\" /* STACK */ ? 1 : seriesGroup.series.length;\n      return countMap;\n    }, {});\n    return seriesGroups.flatMap((seriesGroup) => {\n      var _a;\n      groupIdx[_a = seriesGroup.seriesType] ?? (groupIdx[_a] = 0);\n      switch (seriesGroup.groupType) {\n        case \"stack\" /* STACK */: {\n          const groupIndex = groupIdx[seriesGroup.seriesType]++;\n          return seriesGroup.series.map(\n            (series, stackIndex) => Object.assign(series, {\n              seriesGrouping: {\n                groupId: seriesGroup.groupId,\n                groupIndex,\n                groupCount: groupCount2[seriesGroup.seriesType],\n                stackIndex,\n                stackCount: seriesGroup.series.length\n              }\n            })\n          );\n        }\n        case \"group\" /* GROUP */:\n          return seriesGroup.series.map(\n            (series) => Object.assign(series, {\n              seriesGrouping: {\n                groupId: seriesGroup.groupId,\n                groupIndex: groupIdx[seriesGroup.seriesType]++,\n                groupCount: groupCount2[seriesGroup.seriesType],\n                stackIndex: 0,\n                stackCount: 0\n              }\n            })\n          );\n      }\n      return seriesGroup.series;\n    }).map(({ stacked: _, grouped: __, ...seriesOptions }) => seriesOptions);\n  }\n  getSeriesGroupId(series) {\n    return [series.type, series.xKey, series.stacked ? series.stackGroup ?? \"stacked\" : \"grouped\"].filter(Boolean).join(\"-\");\n  }\n  getSeriesGrouping(allSeries) {\n    const groupMap = /* @__PURE__ */ new Map();\n    return allSeries.reduce((result, series) => {\n      const seriesType = series.type;\n      if (!series.stacked && !series.grouped) {\n        result.push({ groupType: \"default\" /* DEFAULT */, seriesType, series: [series], groupId: \"__default__\" });\n      } else {\n        const groupId = this.getSeriesGroupId(series);\n        if (!groupMap.has(groupId)) {\n          const groupType = series.stacked ? \"stack\" /* STACK */ : \"group\" /* GROUP */;\n          const record = { groupType, seriesType, series: [], groupId };\n          groupMap.set(groupId, record);\n          result.push(record);\n        }\n        groupMap.get(groupId).series.push(series);\n      }\n      return result;\n    }, []);\n  }\n  getDefaultSeriesType(options) {\n    const chartDef = ModuleRegistry.detectChartDefinition(options);\n    switch (chartDef.name) {\n      case \"cartesian\":\n        return \"line\";\n      case \"polar\":\n        return \"pie\";\n      case \"hierarchy\":\n        return \"treemap\";\n      case \"topology\":\n        return \"map-shape\";\n      case \"flow-proportion\":\n        return \"sankey\";\n      case \"standalone\":\n        return \"pyramid\";\n      case \"gauge\":\n        return \"radial-gauge\";\n      default:\n        throw new Error(\"Invalid chart options type detected.\");\n    }\n  }\n  getTooltipPositionDefaults(options) {\n    const position = options.tooltip?.position;\n    if (!isPlainObject(position)) {\n      return;\n    }\n    const { type, xOffset, yOffset } = position;\n    const result = {};\n    if (isString(type) && isEnumValue(AgTooltipPositionType, type)) {\n      result.type = type;\n    }\n    if (isFiniteNumber(xOffset)) {\n      result.xOffset = xOffset;\n    }\n    if (isFiniteNumber(yOffset)) {\n      result.yOffset = yOffset;\n    }\n    return { tooltip: { position: result } };\n  }\n  // AG-11591 Support for new series-specific & legacy chart-global 'tooltip.range' options\n  //\n  // The `chart.series[].tooltip.range` option is a bit different for legacy reason. This use to be\n  // global option (`chart.tooltip.range`) that could override the theme. But now, the tooltip range\n  // option is series-specific.\n  //\n  // To preserve backward compatibility, the `chart.tooltip.range` theme default has been changed from\n  // 'nearest' to undefined.\n  getTooltipRangeDefaults(options, seriesType) {\n    return {\n      tooltip: {\n        range: options.tooltip?.range ?? seriesRegistry.getTooltipDefauls(seriesType)?.range\n      }\n    };\n  }\n  axesTypeIntegrity(options) {\n    if (\"axes\" in options && options.axes) {\n      const axes = options.axes;\n      for (const { type } of axes) {\n        if (!isAxisOptionType(type)) {\n          delete options.axes;\n          const expectedTypes = [...axisRegistry.keys()].join(\", \");\n          logger_exports.warnOnce(`unknown axis type: ${type}; expected one of: ${expectedTypes}`);\n        }\n      }\n    }\n  }\n  seriesTypeIntegrity(options) {\n    options.series = options.series?.filter(({ type }) => {\n      if (type == null || isSeriesOptionType(type) || isEnterpriseSeriesType(type)) {\n        return true;\n      }\n      logger_exports.warnOnce(\n        `unknown series type: ${JSON.stringify(type)}; expected one of: ${publicChartTypes.seriesTypes.join(\", \")}`\n      );\n    });\n  }\n  soloSeriesIntegrity(options) {\n    const allSeries = options.series;\n    if (allSeries && allSeries.length > 1 && allSeries.some((series) => seriesRegistry.isSolo(series.type))) {\n      const mainSeriesType = this.optionsType(options);\n      if (seriesRegistry.isSolo(mainSeriesType)) {\n        logger_exports.warn(\n          `series[0] of type '${mainSeriesType}' is incompatible with other series types. Only processing series[0]`\n        );\n        options.series = allSeries.slice(0, 1);\n      } else {\n        const { solo, nonSolo } = groupBy(\n          allSeries,\n          (s) => seriesRegistry.isSolo(s.type) ? \"solo\" : \"nonSolo\"\n        );\n        const rejects = unique(solo.map((s) => s.type)).join(\", \");\n        logger_exports.warn(`Unable to mix these series types with the lead series type: ${rejects}`);\n        options.series = nonSolo;\n      }\n    }\n  }\n  static enableConfiguredJsonOptions(visitingUserOpts, visitingMergedOpts) {\n    if (typeof visitingMergedOpts === \"object\" && \"enabled\" in visitingMergedOpts && !visitingMergedOpts._enabledFromTheme && visitingUserOpts.enabled == null) {\n      visitingMergedOpts.enabled = true;\n    }\n  }\n  static cleanupEnabledFromThemeJsonOptions(visitingMergedOpts) {\n    if (visitingMergedOpts._enabledFromTheme != null) {\n      delete visitingMergedOpts._enabledFromTheme;\n    }\n  }\n  enableConfiguredOptions(options, userOptions) {\n    jsonWalk(userOptions, _ChartOptions.enableConfiguredJsonOptions, /* @__PURE__ */ new Set([\"data\", \"theme\"]), options);\n    jsonWalk(options, _ChartOptions.cleanupEnabledFromThemeJsonOptions, /* @__PURE__ */ new Set([\"data\", \"theme\"]));\n  }\n  static removeDisabledOptionJson(optionsNode) {\n    if (\"enabled\" in optionsNode && optionsNode.enabled === false) {\n      Object.keys(optionsNode).forEach((key) => {\n        if (key === \"enabled\")\n          return;\n        delete optionsNode[key];\n      });\n    }\n  }\n  removeDisabledOptions(options) {\n    jsonWalk(options, _ChartOptions.removeDisabledOptionJson, /* @__PURE__ */ new Set([\"data\", \"theme\"]));\n  }\n  static removeLeftoverSymbolsJson(optionsNode) {\n    if (!optionsNode || !isObject(optionsNode))\n      return;\n    for (const [key, value] of Object.entries(optionsNode)) {\n      if (isSymbol(value)) {\n        delete optionsNode[key];\n      }\n    }\n  }\n  removeLeftoverSymbols(options) {\n    jsonWalk(options, _ChartOptions.removeLeftoverSymbolsJson, /* @__PURE__ */ new Set([\"data\"]));\n  }\n  specialOverridesDefaults(options) {\n    if (options.window != null) {\n      setWindow(options.window);\n    } else if (typeof window !== \"undefined\") {\n      options.window = window;\n    } else if (typeof global !== \"undefined\") {\n      options.window = global.window;\n    }\n    if (options.document != null) {\n      setDocument(options.document);\n    } else if (typeof document !== \"undefined\") {\n      options.document = document;\n    } else if (typeof global !== \"undefined\") {\n      options.document = global.document;\n    }\n    if (options.window == null) {\n      throw new Error(\"AG Charts - unable to resolve global window\");\n    }\n    if (options.document == null) {\n      throw new Error(\"AG Charts - unable to resolve global document\");\n    }\n    return options;\n  }\n};\n_ChartOptions.OPTIONS_CLONE_OPTS = /* @__PURE__ */ new Set([\"data\", \"container\"]);\n_ChartOptions.FAST_PATH_OPTIONS = /* @__PURE__ */ new Set([\"data\", \"width\", \"height\"]);\nvar ChartOptions = _ChartOptions;\n\n// packages/ag-charts-community/src/util/pool.ts\nvar CLEANUP_TIMEOUT_MS = 100;\nvar _Pool = class _Pool {\n  constructor(name, buildItem, releaseItem, destroyItem, maxPoolSize, cleanupTimeMs = CLEANUP_TIMEOUT_MS) {\n    this.name = name;\n    this.buildItem = buildItem;\n    this.releaseItem = releaseItem;\n    this.destroyItem = destroyItem;\n    this.maxPoolSize = maxPoolSize;\n    this.cleanupTimeMs = cleanupTimeMs;\n    this.freePool = [];\n    this.busyPool = /* @__PURE__ */ new Set();\n  }\n  static getPool(name, buildItem, releaseItem, destroyItem, maxPoolSize) {\n    if (!this.pools.has(name)) {\n      this.pools.set(name, new _Pool(name, buildItem, releaseItem, destroyItem, maxPoolSize));\n    }\n    return this.pools.get(name);\n  }\n  isFull() {\n    return this.freePool.length + this.busyPool.size >= this.maxPoolSize;\n  }\n  obtain(params) {\n    if (this.freePool.length === 0 && this.isFull()) {\n      throw new Error(\"AG Charts - pool exhausted\");\n    }\n    let nextFree = this.freePool.pop();\n    if (nextFree == null) {\n      nextFree = this.buildItem(params);\n      _Pool.debug(\n        `Pool[name=${this.name}]: Created instance (${this.freePool.length} / ${this.busyPool.size + 1} / ${this.maxPoolSize})`,\n        nextFree\n      );\n    } else {\n      _Pool.debug(\n        `Pool[name=${this.name}]: Re-used instance (${this.freePool.length} / ${this.busyPool.size + 1} / ${this.maxPoolSize})`,\n        nextFree\n      );\n    }\n    this.busyPool.add(nextFree);\n    return { item: nextFree, release: () => this.release(nextFree) };\n  }\n  release(item) {\n    if (!this.busyPool.has(item)) {\n      throw new Error(\"AG Charts - cannot free item from pool which is not tracked as busy.\");\n    }\n    _Pool.debug(\n      `Pool[name=${this.name}]: Releasing instance (${this.freePool.length} / ${this.busyPool.size} / ${this.maxPoolSize})`,\n      item\n    );\n    this.releaseItem(item);\n    this.busyPool.delete(item);\n    this.freePool.push(item);\n    _Pool.debug(\n      `Pool[name=${this.name}]: Returned instance to free pool (${this.freePool.length} / ${this.busyPool.size} / ${this.maxPoolSize})`,\n      item\n    );\n    if (this.cleanPoolTimer) {\n      clearTimeout(this.cleanPoolTimer);\n    }\n    this.cleanPoolTimer = setTimeout(() => {\n      this.cleanPool();\n    }, this.cleanupTimeMs);\n  }\n  cleanPool() {\n    const itemsToFree = this.freePool.splice(0);\n    for (const item of itemsToFree) {\n      this.destroyItem(item);\n    }\n    _Pool.debug(\n      `Pool[name=${this.name}]: Cleaned pool of ${itemsToFree.length} items (${this.freePool.length} / ${this.busyPool.size} / ${this.maxPoolSize})`\n    );\n  }\n  destroy() {\n    this.cleanPool();\n    for (const item of this.busyPool.values()) {\n      this.destroyItem(item);\n    }\n    this.busyPool.clear();\n  }\n};\n_Pool.pools = /* @__PURE__ */ new Map();\n_Pool.debug = Debug.create(true, \"pool\");\nvar Pool = _Pool;\n\n// packages/ag-charts-community/src/api/agCharts.ts\nModuleRegistry.registerMany([CartesianChartModule, PolarChartModule]);\nvar debug3 = Debug.create(true, \"opts\");\nvar AgCharts = class {\n  static licenseCheck(options) {\n    if (this.licenseChecked)\n      return;\n    this.licenseManager = enterpriseModule.licenseManager?.(options);\n    this.licenseManager?.validateLicense();\n    this.licenseChecked = true;\n  }\n  static getLicenseDetails(licenseKey) {\n    return enterpriseModule.licenseManager?.({}).getLicenseDetails(licenseKey);\n  }\n  /**\n   * Returns the `AgChartInstance` for a DOM node, if there is one.\n   */\n  static getInstance(element2) {\n    return AgChartsInternal.getInstance(element2);\n  }\n  /**\n   * Create a new `AgChartInstance` based upon the given configuration options.\n   */\n  static create(userOptions, optionsMetadata) {\n    return debug3.group(\"AgCharts.create()\", () => {\n      this.licenseCheck(userOptions);\n      const chart = AgChartsInternal.createOrUpdate({\n        userOptions,\n        licenseManager: this.licenseManager,\n        optionsMetadata\n      });\n      if (this.licenseManager?.isDisplayWatermark() && this.licenseManager) {\n        enterpriseModule.injectWatermark?.(\n          chart.chart.ctx.domManager,\n          this.licenseManager.getWatermarkMessage()\n        );\n      }\n      return chart;\n    });\n  }\n  static createFinancialChart(options) {\n    return debug3.group(\"AgCharts.createFinancialChart()\", () => {\n      return this.create(options, { presetType: \"price-volume\" });\n    });\n  }\n  static createGauge(options) {\n    return debug3.group(\"AgCharts.createGauge()\", () => {\n      return this.create(options, { presetType: \"gauge\" });\n    });\n  }\n  static __createSparkline(options) {\n    return debug3.group(\"AgCharts.__createSparkline()\", () => {\n      const { pool, ...normalOptions } = options;\n      return this.create(normalOptions, { presetType: \"sparkline\", pool: pool ?? true });\n    });\n  }\n};\nAgCharts.licenseChecked = false;\nvar _AgChartsInternal = class _AgChartsInternal {\n  static getInstance(element2) {\n    const chart = Chart.getInstance(element2);\n    return chart ? AgChartInstanceProxy.chartInstances.get(chart) : void 0;\n  }\n  static initialiseModules() {\n    if (_AgChartsInternal.initialised)\n      return;\n    registerInbuiltModules();\n    setupModules();\n    _AgChartsInternal.initialised = true;\n  }\n  static createOrUpdate(opts) {\n    let { proxy } = opts;\n    const {\n      userOptions,\n      licenseManager,\n      processedOverrides = proxy?.chart.chartOptions.processedOverrides ?? {},\n      specialOverrides = proxy?.chart.chartOptions.specialOverrides ?? {},\n      optionsMetadata = proxy?.chart.chartOptions.optionMetadata ?? {},\n      deltaOptions,\n      stripSymbols = false\n    } = opts;\n    const styles = enterpriseModule.styles != null ? [[\"ag-charts-enterprise\", enterpriseModule.styles]] : [];\n    const { presetType } = optionsMetadata;\n    _AgChartsInternal.initialiseModules();\n    debug3(() => [\">>> AgCharts.createOrUpdate() user options\", deepClone(userOptions)]);\n    let mutableOptions = userOptions;\n    if (AgCharts.optionsMutationFn && mutableOptions) {\n      mutableOptions = AgCharts.optionsMutationFn(deepClone(mutableOptions), presetType);\n      debug3(() => [\">>> AgCharts.createOrUpdate() MUTATED user options\", deepClone(mutableOptions)]);\n    }\n    const { document: document2, window: userWindow, styleContainer, ...options } = mutableOptions ?? {};\n    const baseOptions = (deltaOptions ? proxy?.chart.getChartOptions() : options) ?? options;\n    const chartOptions = new ChartOptions(\n      baseOptions,\n      processedOverrides,\n      {\n        ...specialOverrides,\n        document: document2,\n        window: userWindow,\n        styleContainer\n      },\n      optionsMetadata,\n      deltaOptions,\n      stripSymbols\n    );\n    let create = false;\n    let chart = proxy?.chart;\n    let poolResult;\n    if (chart == null || ModuleRegistry.detectChartDefinition(chartOptions.processedOptions) !== ModuleRegistry.detectChartDefinition(chart.chartOptions.processedOptions)) {\n      poolResult = this.getPool(chartOptions)?.obtain(chartOptions);\n      if (poolResult) {\n        chart = poolResult.item;\n      } else {\n        create = true;\n        chart = _AgChartsInternal.createChartInstance(chartOptions, chart);\n      }\n      styles.forEach(([id, css]) => {\n        chart?.ctx.domManager.addStyles(id, css);\n      });\n    }\n    if (proxy == null) {\n      proxy = new AgChartInstanceProxy(chart, _AgChartsInternal.callbackApi, licenseManager);\n      proxy.releaseChart = poolResult?.release;\n    } else if (poolResult || create) {\n      proxy.releaseChart?.();\n      proxy.chart = chart;\n      proxy.releaseChart = poolResult?.release;\n    }\n    if (debug3.check() && typeof window !== \"undefined\") {\n      window.agChartInstances ?? (window.agChartInstances = {});\n      window.agChartInstances[chart.id] = chart;\n    }\n    chart.queuedUserOptions.push(chartOptions.userOptions);\n    chart.queuedChartOptions.push(chartOptions);\n    chart.requestFactoryUpdate((chartRef) => {\n      debug3.group(\">>>> Chart.applyOptions()\", () => {\n        chartRef.applyOptions(chartOptions);\n        const queueIdx = chartRef.queuedUserOptions.indexOf(chartOptions.userOptions) + 1;\n        chartRef.queuedUserOptions.splice(0, queueIdx);\n        chartRef.queuedChartOptions.splice(0, queueIdx);\n      });\n    });\n    return proxy;\n  }\n  static markRemovedProperties(node, _, modified = false) {\n    if (typeof node !== \"object\")\n      return modified;\n    for (const [key, value] of Object.entries(node)) {\n      if (typeof value === \"undefined\") {\n        Object.assign(node, { [key]: Symbol(\"UNSET\") });\n        modified || (modified = true);\n      }\n    }\n    return modified;\n  }\n  static updateUserDelta(proxy, deltaOptions) {\n    deltaOptions = deepClone(deltaOptions, /* @__PURE__ */ new Set([\"data\"]));\n    const stripSymbols = jsonWalk(\n      deltaOptions,\n      _AgChartsInternal.markRemovedProperties,\n      /* @__PURE__ */ new Set([\"data\"]),\n      void 0,\n      void 0,\n      false\n    );\n    debug3(() => [\">>> AgCharts.updateUserDelta() user delta\", deepClone(deltaOptions)]);\n    _AgChartsInternal.createOrUpdate({\n      proxy,\n      deltaOptions,\n      stripSymbols\n    });\n  }\n  static createChartInstance(options, oldChart) {\n    const transferableResource = oldChart?.destroy({ keepTransferableResources: true });\n    const chartDef = ModuleRegistry.detectChartDefinition(options.processedOptions);\n    return chartDef.create(options, transferableResource);\n  }\n  static getPool(options) {\n    if (options.optionMetadata.pool !== true)\n      return;\n    return Pool.getPool(\n      options.optionMetadata.presetType ?? \"default\",\n      this.createChartInstance,\n      this.detachAndClear,\n      this.destroy,\n      Infinity\n      // AG-13480 - Prevent Grid exhausting pool during sorting.\n    );\n  }\n};\n_AgChartsInternal.caretaker = new MementoCaretaker(VERSION);\n_AgChartsInternal.initialised = false;\n_AgChartsInternal.callbackApi = {\n  caretaker: _AgChartsInternal.caretaker,\n  create(userOptions, processedOverrides, specialOverrides, optionsMetadata) {\n    return _AgChartsInternal.createOrUpdate({\n      userOptions,\n      processedOverrides,\n      specialOverrides,\n      optionsMetadata\n    });\n  },\n  update(opts, chart) {\n    return _AgChartsInternal.createOrUpdate({ userOptions: opts, proxy: chart });\n  },\n  updateUserDelta(chart, deltaOptions) {\n    return _AgChartsInternal.updateUserDelta(chart, deltaOptions);\n  }\n};\n_AgChartsInternal.detachAndClear = (chart) => chart.detachAndClear();\n_AgChartsInternal.destroy = (chart) => chart.destroy();\nvar AgChartsInternal = _AgChartsInternal;\n\n// packages/ag-charts-community/src/integrated-charts-scene.ts\nvar integrated_charts_scene_exports = {};\n__export(integrated_charts_scene_exports, {\n  Arc: () => Arc2,\n  BBox: () => BBox,\n  Caption: () => Caption,\n  CategoryScale: () => CategoryScale,\n  Group: () => Group,\n  Line: () => Line,\n  LinearScale: () => LinearScale,\n  Marker: () => Marker,\n  Path: () => Path,\n  RadialColumnShape: () => RadialColumnShape,\n  Rect: () => Rect,\n  Scene: () => Scene,\n  Sector: () => Sector,\n  Shape: () => Shape,\n  TranslatableGroup: () => TranslatableGroup,\n  getRadialColumnWidth: () => getRadialColumnWidth,\n  toRadians: () => toRadians\n});\n\n// packages/ag-charts-community/src/scene/shape/arc.ts\nvar Arc2 = class extends Path {\n  constructor() {\n    super();\n    this.centerX = 0;\n    this.centerY = 0;\n    this.radius = 10;\n    this.startAngle = 0;\n    this.endAngle = Math.PI * 2;\n    this.counterClockwise = false;\n    this.type = 0 /* Open */;\n    this.restoreOwnStyles();\n  }\n  get fullPie() {\n    return isNumberEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));\n  }\n  updatePath() {\n    const path = this.path;\n    path.clear();\n    path.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, this.counterClockwise);\n    if (this.type === 1 /* Chord */) {\n      path.closePath();\n    } else if (this.type === 2 /* Round */ && !this.fullPie) {\n      path.lineTo(this.centerX, this.centerY);\n      path.closePath();\n    }\n  }\n  computeBBox() {\n    return new BBox(this.centerX - this.radius, this.centerY - this.radius, this.radius * 2, this.radius * 2);\n  }\n  isPointInPath(x, y) {\n    const bbox = this.getBBox();\n    return this.type !== 0 /* Open */ && bbox.containsPoint(x, y) && this.path.isPointInPath(x, y);\n  }\n};\nArc2.className = \"Arc\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"centerX\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"centerY\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"radius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"counterClockwise\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"type\", 2);\n\n// packages/ag-charts-community/src/scene/shape/radialColumnShape.ts\nfunction rotatePoint(x, y, rotation) {\n  const radius = Math.sqrt(x ** 2 + y ** 2);\n  const angle2 = Math.atan2(y, x);\n  const rotated = angle2 + rotation;\n  return {\n    x: Math.cos(rotated) * radius,\n    y: Math.sin(rotated) * radius\n  };\n}\nvar RadialColumnShape = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.isBeveled = true;\n    this.columnWidth = 0;\n    this.startAngle = 0;\n    this.endAngle = 0;\n    this.outerRadius = 0;\n    this.innerRadius = 0;\n    this.axisInnerRadius = 0;\n    this.axisOuterRadius = 0;\n    this.isRadiusAxisReversed = false;\n  }\n  set cornerRadius(_value) {\n  }\n  computeBBox() {\n    const { innerRadius, outerRadius, columnWidth } = this;\n    const rotation = this.getRotation();\n    const left = -columnWidth / 2;\n    const right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius;\n    let x0 = Infinity;\n    let y0 = Infinity;\n    let x1 = -Infinity;\n    let y1 = -Infinity;\n    for (let i = 0; i < 4; i += 1) {\n      const { x, y } = rotatePoint(i % 2 === 0 ? left : right, i < 2 ? top : bottom, rotation);\n      x0 = Math.min(x, x0);\n      y0 = Math.min(y, y0);\n      x1 = Math.max(x, x1);\n      y1 = Math.max(y, y1);\n    }\n    return new BBox(x0, y0, x1 - x0, y1 - y0);\n  }\n  getRotation() {\n    const { startAngle, endAngle } = this;\n    const midAngle = angleBetween(startAngle, endAngle);\n    return normalizeAngle360(startAngle + midAngle / 2 + Math.PI / 2);\n  }\n  updatePath() {\n    const { isBeveled } = this;\n    if (isBeveled) {\n      this.updateBeveledPath();\n    } else {\n      this.updateRectangularPath();\n    }\n    this.checkPathDirty();\n  }\n  updateRectangularPath() {\n    const { columnWidth, innerRadius, outerRadius, path } = this;\n    const left = -columnWidth / 2;\n    const right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius;\n    const rotation = this.getRotation();\n    const points = [\n      [left, bottom],\n      [left, top],\n      [right, top],\n      [right, bottom]\n    ].map(([x, y]) => rotatePoint(x, y, rotation));\n    path.clear(true);\n    path.moveTo(points[0].x, points[0].y);\n    path.lineTo(points[1].x, points[1].y);\n    path.lineTo(points[2].x, points[2].y);\n    path.lineTo(points[3].x, points[3].y);\n    path.closePath();\n  }\n  updateBeveledPath() {\n    const { columnWidth, path, outerRadius, innerRadius, axisInnerRadius, axisOuterRadius, isRadiusAxisReversed } = this;\n    const isStackBottom = isNumberEqual(innerRadius, axisInnerRadius);\n    const sideRotation = Math.asin(columnWidth / 2 / innerRadius);\n    const pointRotation = this.getRotation();\n    const rotate2 = (x, y) => rotatePoint(x, y, pointRotation);\n    const getTriangleHypotenuse = (leg, otherLeg) => Math.sqrt(leg ** 2 + otherLeg ** 2);\n    const getTriangleLeg = (hypotenuse, otherLeg) => {\n      if (otherLeg > hypotenuse) {\n        return 0;\n      }\n      return Math.sqrt(hypotenuse ** 2 - otherLeg ** 2);\n    };\n    const compare = (value, otherValue, lessThan2) => lessThan2 ? value < otherValue : value > otherValue;\n    const shouldConnectBottomCircle = isStackBottom && !isNaN(sideRotation) && sideRotation < Math.PI / 6;\n    let left = -columnWidth / 2;\n    let right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius * (shouldConnectBottomCircle ? Math.cos(sideRotation) : 1);\n    const hasBottomIntersection = compare(\n      axisOuterRadius,\n      getTriangleHypotenuse(innerRadius, columnWidth / 2),\n      !isRadiusAxisReversed\n    );\n    if (hasBottomIntersection) {\n      const bottomIntersectionX = getTriangleLeg(axisOuterRadius, innerRadius);\n      left = -bottomIntersectionX;\n      right = bottomIntersectionX;\n    }\n    path.clear(true);\n    const bottomLeftPt = rotate2(left, bottom);\n    path.moveTo(bottomLeftPt.x, bottomLeftPt.y);\n    const isEmpty2 = isNumberEqual(innerRadius, outerRadius);\n    const hasSideIntersection = compare(\n      axisOuterRadius,\n      getTriangleHypotenuse(outerRadius, columnWidth / 2),\n      !isRadiusAxisReversed\n    );\n    if (isEmpty2 && shouldConnectBottomCircle) {\n      path.arc(\n        0,\n        0,\n        innerRadius,\n        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,\n        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,\n        false\n      );\n    } else if (hasSideIntersection) {\n      const sideIntersectionY = -getTriangleLeg(axisOuterRadius, columnWidth / 2);\n      const topIntersectionX = getTriangleLeg(axisOuterRadius, outerRadius);\n      if (!hasBottomIntersection) {\n        const topLeftPt = rotate2(left, sideIntersectionY);\n        path.lineTo(topLeftPt.x, topLeftPt.y);\n      }\n      path.arc(\n        0,\n        0,\n        axisOuterRadius,\n        Math.atan2(sideIntersectionY, left) + pointRotation,\n        Math.atan2(top, -topIntersectionX) + pointRotation,\n        false\n      );\n      if (!isNumberEqual(topIntersectionX, 0)) {\n        const topRightBevelPt = rotate2(topIntersectionX, top);\n        path.lineTo(topRightBevelPt.x, topRightBevelPt.y);\n      }\n      path.arc(\n        0,\n        0,\n        axisOuterRadius,\n        Math.atan2(top, topIntersectionX) + pointRotation,\n        Math.atan2(sideIntersectionY, right) + pointRotation,\n        false\n      );\n    } else {\n      const topLeftPt = rotate2(left, top);\n      const topRightPt = rotate2(right, top);\n      path.lineTo(topLeftPt.x, topLeftPt.y);\n      path.lineTo(topRightPt.x, topRightPt.y);\n    }\n    const bottomRightPt = rotate2(right, bottom);\n    path.lineTo(bottomRightPt.x, bottomRightPt.y);\n    if (shouldConnectBottomCircle) {\n      path.arc(\n        0,\n        0,\n        innerRadius,\n        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,\n        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,\n        true\n      );\n    } else {\n      const rotatedBottomLeftPt = rotate2(left, bottom);\n      path.lineTo(rotatedBottomLeftPt.x, rotatedBottomLeftPt.y);\n    }\n    path.closePath();\n  }\n};\nRadialColumnShape.className = \"RadialColumnShape\";\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"isBeveled\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"columnWidth\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"outerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"innerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"axisInnerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"axisOuterRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"isRadiusAxisReversed\", 2);\nfunction getRadialColumnWidth(startAngle, endAngle, axisOuterRadius, columnWidthRatio, maxColumnWidthRatio) {\n  const rotation = angleBetween(startAngle, endAngle);\n  const pad2 = rotation * (1 - columnWidthRatio) / 2;\n  startAngle += pad2;\n  endAngle -= pad2;\n  if (rotation < 1e-3) {\n    return 2 * axisOuterRadius * maxColumnWidthRatio;\n  }\n  if (rotation >= 2 * Math.PI) {\n    const midAngle = startAngle + rotation / 2;\n    startAngle = midAngle - Math.PI;\n    endAngle = midAngle + Math.PI;\n  }\n  const startX = axisOuterRadius * Math.cos(startAngle);\n  const startY = axisOuterRadius * Math.sin(startAngle);\n  const endX = axisOuterRadius * Math.cos(endAngle);\n  const endY = axisOuterRadius * Math.sin(endAngle);\n  const colWidth = Math.floor(Math.sqrt((startX - endX) ** 2 + (startY - endY) ** 2));\n  const maxWidth = 2 * axisOuterRadius * maxColumnWidthRatio;\n  return Math.max(1, Math.min(maxWidth, colWidth));\n}\n\n// packages/ag-charts-community/src/integrated-charts-theme.ts\nvar integrated_charts_theme_exports = {};\n__export(integrated_charts_theme_exports, {\n  ChartTheme: () => ChartTheme,\n  DEFAULT_ANNOTATION_HANDLE_FILL: () => DEFAULT_ANNOTATION_HANDLE_FILL,\n  DEFAULT_ANNOTATION_STATISTICS_COLOR: () => DEFAULT_ANNOTATION_STATISTICS_COLOR,\n  DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE,\n  DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL: () => DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,\n  DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE,\n  DEFAULT_ANNOTATION_STATISTICS_FILL: () => DEFAULT_ANNOTATION_STATISTICS_FILL,\n  DEFAULT_ANNOTATION_STATISTICS_STROKE: () => DEFAULT_ANNOTATION_STATISTICS_STROKE,\n  DEFAULT_BACKGROUND_COLOUR: () => DEFAULT_BACKGROUND_COLOUR,\n  DEFAULT_CAPTION_ALIGNMENT: () => DEFAULT_CAPTION_ALIGNMENT,\n  DEFAULT_CAPTION_LAYOUT_STYLE: () => DEFAULT_CAPTION_LAYOUT_STYLE,\n  DEFAULT_COLOR_RANGE: () => DEFAULT_COLOR_RANGE,\n  DEFAULT_DIVERGING_SERIES_COLOR_RANGE: () => DEFAULT_DIVERGING_SERIES_COLOR_RANGE,\n  DEFAULT_FIBONACCI_STROKES: () => DEFAULT_FIBONACCI_STROKES,\n  DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL: () => DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,\n  DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR: () => DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,\n  DEFAULT_FUNNEL_SERIES_COLOR_RANGE: () => DEFAULT_FUNNEL_SERIES_COLOR_RANGE,\n  DEFAULT_GAUGE_SERIES_COLOR_RANGE: () => DEFAULT_GAUGE_SERIES_COLOR_RANGE,\n  DEFAULT_GRIDLINE_ENABLED: () => DEFAULT_GRIDLINE_ENABLED,\n  DEFAULT_HIERARCHY_FILLS: () => DEFAULT_HIERARCHY_FILLS,\n  DEFAULT_HIERARCHY_STROKES: () => DEFAULT_HIERARCHY_STROKES,\n  DEFAULT_POLAR_SERIES_STROKE: () => DEFAULT_POLAR_SERIES_STROKE,\n  DEFAULT_SEPARATION_LINES_COLOUR: () => DEFAULT_SEPARATION_LINES_COLOUR,\n  DEFAULT_SHADOW_COLOUR: () => DEFAULT_SHADOW_COLOUR,\n  DEFAULT_SPARKLINE_CROSSHAIR_STROKE: () => DEFAULT_SPARKLINE_CROSSHAIR_STROKE,\n  DEFAULT_TEXTBOX_COLOR: () => DEFAULT_TEXTBOX_COLOR,\n  DEFAULT_TEXTBOX_FILL: () => DEFAULT_TEXTBOX_FILL,\n  DEFAULT_TEXTBOX_STROKE: () => DEFAULT_TEXTBOX_STROKE,\n  DEFAULT_TEXT_ANNOTATION_COLOR: () => DEFAULT_TEXT_ANNOTATION_COLOR,\n  DEFAULT_TOOLBAR_POSITION: () => DEFAULT_TOOLBAR_POSITION,\n  IS_COMMUNITY: () => IS_COMMUNITY,\n  IS_DARK_THEME: () => IS_DARK_THEME,\n  IS_ENTERPRISE: () => IS_ENTERPRISE,\n  PALETTE_ALT_DOWN_FILL: () => PALETTE_ALT_DOWN_FILL,\n  PALETTE_ALT_DOWN_STROKE: () => PALETTE_ALT_DOWN_STROKE,\n  PALETTE_ALT_NEUTRAL_FILL: () => PALETTE_ALT_NEUTRAL_FILL,\n  PALETTE_ALT_NEUTRAL_STROKE: () => PALETTE_ALT_NEUTRAL_STROKE,\n  PALETTE_ALT_UP_FILL: () => PALETTE_ALT_UP_FILL,\n  PALETTE_ALT_UP_STROKE: () => PALETTE_ALT_UP_STROKE,\n  PALETTE_DOWN_FILL: () => PALETTE_DOWN_FILL,\n  PALETTE_DOWN_STROKE: () => PALETTE_DOWN_STROKE,\n  PALETTE_NEUTRAL_FILL: () => PALETTE_NEUTRAL_FILL,\n  PALETTE_NEUTRAL_STROKE: () => PALETTE_NEUTRAL_STROKE,\n  PALETTE_UP_FILL: () => PALETTE_UP_FILL,\n  PALETTE_UP_STROKE: () => PALETTE_UP_STROKE,\n  getChartTheme: () => getChartTheme,\n  themeNames: () => themeNames,\n  themeSymbols: () => symbols_exports,\n  themes: () => themes\n});\nvar themeNames = Object.keys(themes);\n\n// packages/ag-charts-community/src/integrated-charts-util.ts\nvar integrated_charts_util_exports = {};\n__export(integrated_charts_util_exports, {\n  Color: () => Color,\n  interpolateColor: () => interpolateColor\n});\n\n// packages/ag-charts-community/src/module-support.ts\nvar module_support_exports = {};\n__export(module_support_exports, {\n  AND: () => AND,\n  ARRAY: () => ARRAY,\n  ARRAY_OF: () => ARRAY_OF,\n  AbstractBarSeries: () => AbstractBarSeries,\n  AbstractBarSeriesProperties: () => AbstractBarSeriesProperties,\n  ActionOnSet: () => ActionOnSet,\n  AnchoredPopover: () => AnchoredPopover,\n  Animation: () => Animation,\n  AnimationManager: () => AnimationManager,\n  Arc: () => Arc2,\n  Axis: () => Axis,\n  AxisGroupZIndexMap: () => AxisGroupZIndexMap,\n  AxisInterval: () => AxisInterval,\n  AxisLabel: () => AxisLabel,\n  AxisTick: () => AxisTick,\n  AxisTickGenerator: () => AxisTickGenerator,\n  AxisTicks: () => AxisTicks,\n  BBox: () => BBox,\n  BBoxValues: () => BBoxValues,\n  BOOLEAN: () => BOOLEAN,\n  BOOLEAN_ARRAY: () => BOOLEAN_ARRAY,\n  Background: () => Background,\n  BackgroundModule: () => BackgroundModule,\n  BandScale: () => BandScale,\n  BarSeries: () => BarSeries,\n  BarSeriesModule: () => BarSeriesModule,\n  BaseModuleInstance: () => BaseModuleInstance,\n  BaseProperties: () => BaseProperties,\n  BaseToolbar: () => BaseToolbar,\n  ButtonWidget: () => ButtonWidget,\n  COLOR_GRADIENT: () => COLOR_GRADIENT,\n  COLOR_STRING: () => COLOR_STRING,\n  COLOR_STRING_ARRAY: () => COLOR_STRING_ARRAY,\n  CachedTextMeasurer: () => CachedTextMeasurer,\n  CachedTextMeasurerPool: () => CachedTextMeasurerPool,\n  Caption: () => Caption,\n  CartesianAxis: () => CartesianAxis,\n  CartesianSeries: () => CartesianSeries,\n  CartesianSeriesNodeEvent: () => CartesianSeriesNodeEvent,\n  CartesianSeriesProperties: () => CartesianSeriesProperties,\n  CategoryAxis: () => CategoryAxis,\n  CategoryScale: () => CategoryScale,\n  ChangeDetectableProperties: () => ChangeDetectableProperties,\n  Chart: () => Chart,\n  ChartAxisDirection: () => ChartAxisDirection,\n  ChartEventManager: () => ChartEventManager,\n  ChartOptions: () => ChartOptions,\n  ChartUpdateType: () => ChartUpdateType,\n  CollapseMode: () => CollapseMode,\n  Color: () => Color,\n  ColorScale: () => ColorScale,\n  ConicGradient: () => ConicGradient,\n  ContextMenuRegistry: () => ContextMenuRegistry,\n  ContinuousScale: () => ContinuousScale,\n  DATE: () => DATE,\n  DATE_ARRAY: () => DATE_ARRAY,\n  DATE_OR_DATETIME_MS: () => DATE_OR_DATETIME_MS,\n  DEFAULT_CARTESIAN_DIRECTION_KEYS: () => DEFAULT_CARTESIAN_DIRECTION_KEYS,\n  DEFAULT_CARTESIAN_DIRECTION_NAMES: () => DEFAULT_CARTESIAN_DIRECTION_NAMES,\n  DEFAULT_TOOLTIP_CLASS: () => DEFAULT_TOOLTIP_CLASS,\n  DEFAULT_TOOLTIP_DARK_CLASS: () => DEFAULT_TOOLTIP_DARK_CLASS,\n  DIRECTION: () => DIRECTION,\n  DOMManager: () => DOMManager,\n  DataController: () => DataController,\n  DataModel: () => DataModel,\n  DataModelSeries: () => DataModelSeries,\n  DataService: () => DataService,\n  Debug: () => Debug,\n  Default: () => Default,\n  Deprecated: () => Deprecated,\n  DeprecatedAndRenamedTo: () => DeprecatedAndRenamedTo,\n  DragInterpreter: () => DragInterpreter,\n  DraggablePopover: () => DraggablePopover,\n  DropShadow: () => DropShadow,\n  ExtendedPath2D: () => ExtendedPath2D,\n  FONT_SIZE_RATIO: () => FONT_SIZE_RATIO,\n  FONT_STYLE: () => FONT_STYLE,\n  FONT_WEIGHT: () => FONT_WEIGHT,\n  FUNCTION: () => FUNCTION,\n  FloatingToolbar: () => FloatingToolbar,\n  GREATER_THAN: () => GREATER_THAN,\n  Gradient: () => Gradient,\n  Group: () => Group,\n  GroupedCategoryAxis: () => GroupedCategoryAxis,\n  HdpiCanvas: () => HdpiCanvas,\n  HierarchyNode: () => HierarchyNode,\n  HierarchySeries: () => HierarchySeries,\n  HierarchySeriesProperties: () => HierarchySeriesProperties,\n  HighlightManager: () => HighlightManager,\n  HighlightProperties: () => HighlightProperties,\n  HighlightStyle: () => HighlightStyle,\n  INTERACTION_RANGE: () => INTERACTION_RANGE,\n  INTERPOLATION_STEP_POSITION: () => INTERPOLATION_STEP_POSITION,\n  INTERPOLATION_TYPE: () => INTERPOLATION_TYPE,\n  Image: () => Image,\n  InteractionManager: () => InteractionManager,\n  InteractionState: () => InteractionState,\n  InterpolationProperties: () => InterpolationProperties,\n  Invalidating: () => Invalidating,\n  LABEL_PLACEMENT: () => LABEL_PLACEMENT,\n  LARGEST_KEY_INTERVAL: () => LARGEST_KEY_INTERVAL,\n  LESS_THAN: () => LESS_THAN,\n  LINE_CAP: () => LINE_CAP,\n  LINE_DASH: () => LINE_DASH,\n  LINE_JOIN: () => LINE_JOIN,\n  LINE_STYLE: () => LINE_STYLE,\n  Label: () => Label,\n  LayoutElement: () => LayoutElement,\n  LayoutManager: () => LayoutManager,\n  LegendMarkerLabel: () => LegendMarkerLabel,\n  Line: () => Line,\n  LineSeries: () => LineSeries,\n  LineSeriesModule: () => LineSeriesModule,\n  LinearGradient: () => LinearGradient,\n  LinearScale: () => LinearScale,\n  Listeners: () => Listeners,\n  LogScale: () => LogScale,\n  LonLatBBox: () => LonLatBBox,\n  MARKER_SHAPE: () => MARKER_SHAPE,\n  MATCHING_CROSSLINE_TYPE: () => MATCHING_CROSSLINE_TYPE,\n  MAX_SPACING: () => MAX_SPACING,\n  MIN_SPACING: () => MIN_SPACING,\n  Marker: () => Marker,\n  Menu: () => Menu,\n  MercatorScale: () => MercatorScale,\n  ModuleRegistry: () => ModuleRegistry,\n  Motion: () => easing_exports,\n  NAN: () => NAN,\n  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,\n  NUMBER: () => NUMBER,\n  NUMBER_ARRAY: () => NUMBER_ARRAY,\n  NUMBER_OR_NAN: () => NUMBER_OR_NAN,\n  NativeWidget: () => NativeWidget,\n  NiceMode: () => NiceMode,\n  Node: () => Node,\n  NumberAxis: () => NumberAxis,\n  OBJECT: () => OBJECT,\n  OBJECT_ARRAY: () => OBJECT_ARRAY,\n  OR: () => OR,\n  OVERFLOW_STRATEGY: () => OVERFLOW_STRATEGY,\n  ObserveChanges: () => ObserveChanges,\n  OrdinalTimeScale: () => OrdinalTimeScale,\n  PHASE_METADATA: () => PHASE_METADATA,\n  PHASE_ORDER: () => PHASE_ORDER,\n  PLACEMENT: () => PLACEMENT,\n  PLAIN_OBJECT: () => PLAIN_OBJECT,\n  POSITION: () => POSITION,\n  POSITION_TOP_COORDINATES: () => POSITION_TOP_COORDINATES,\n  POSITIVE_NUMBER: () => POSITIVE_NUMBER,\n  PREV_NEXT_KEYS: () => PREV_NEXT_KEYS,\n  Padding: () => Padding,\n  ParallelStateMachine: () => ParallelStateMachine,\n  Path: () => Path,\n  PointerEvents: () => PointerEvents,\n  PolarAxis: () => PolarAxis,\n  PolarSeries: () => PolarSeries,\n  PolarZIndexMap: () => PolarZIndexMap,\n  Popover: () => Popover,\n  PropertiesArray: () => PropertiesArray,\n  ProxyInteractionService: () => ProxyInteractionService,\n  ProxyOnWrite: () => ProxyOnWrite,\n  ProxyProperty: () => ProxyProperty,\n  ProxyPropertyOnWrite: () => ProxyPropertyOnWrite,\n  QUICK_TRANSITION: () => QUICK_TRANSITION,\n  RATIO: () => RATIO,\n  REAL_NUMBER: () => REAL_NUMBER,\n  RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD: () => RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD,\n  RadialColumnShape: () => RadialColumnShape,\n  Range: () => Range,\n  Rect: () => Rect,\n  RepeatType: () => RepeatType,\n  Rotatable: () => Rotatable,\n  RotatableGroup: () => RotatableGroup,\n  RotatableText: () => RotatableText,\n  SKIP_JS_BUILTINS: () => SKIP_JS_BUILTINS,\n  SMALLEST_KEY_INTERVAL: () => SMALLEST_KEY_INTERVAL,\n  SORT_DOMAIN_GROUPS: () => SORT_DOMAIN_GROUPS,\n  STRING: () => STRING,\n  STRING_ARRAY: () => STRING_ARRAY,\n  Scalable: () => Scalable,\n  ScalableGroup: () => ScalableGroup,\n  Scene: () => Scene,\n  SceneChangeDetection: () => SceneChangeDetection,\n  ScenePathChangeDetection: () => ScenePathChangeDetection,\n  Sector: () => Sector,\n  SectorBox: () => SectorBox,\n  Selection: () => Selection,\n  Series: () => Series,\n  SeriesContentZIndexMap: () => SeriesContentZIndexMap,\n  SeriesGroupingChangedEvent: () => SeriesGroupingChangedEvent,\n  SeriesItemHighlightStyle: () => SeriesItemHighlightStyle,\n  SeriesMarker: () => SeriesMarker,\n  SeriesNodeEvent: () => SeriesNodeEvent,\n  SeriesNodePickMode: () => SeriesNodePickMode,\n  SeriesProperties: () => SeriesProperties,\n  SeriesTooltip: () => SeriesTooltip,\n  SeriesZIndexMap: () => SeriesZIndexMap,\n  Shape: () => Shape,\n  SimpleTextMeasurer: () => SimpleTextMeasurer,\n  SliderWidget: () => SliderWidget,\n  StateMachine: () => StateMachine,\n  StateMachineProperty: () => StateMachineProperty,\n  StopProperties: () => StopProperties,\n  SvgPath: () => SvgPath,\n  TEXT_ALIGN: () => TEXT_ALIGN,\n  TEXT_WRAP: () => TEXT_WRAP,\n  TICK_INTERVAL: () => TICK_INTERVAL,\n  Text: () => Text,\n  TextUtils: () => TextUtils,\n  TextWrapper: () => TextWrapper,\n  ThemeConstants: () => constants_exports,\n  ThemeSymbols: () => symbols_exports,\n  TimeScale: () => TimeScale,\n  Toolbar: () => Toolbar,\n  ToolbarButtonProperties: () => ToolbarButtonProperties,\n  ToolbarButtonWidget: () => ToolbarButtonWidget,\n  ToolbarWidget: () => ToolbarWidget,\n  Tooltip: () => Tooltip,\n  TooltipManager: () => TooltipManager,\n  TooltipPosition: () => TooltipPosition,\n  Transformable: () => Transformable,\n  TransformableText: () => TransformableText,\n  Translatable: () => Translatable,\n  TranslatableGroup: () => TranslatableGroup,\n  TranslatableLine: () => TranslatableLine,\n  UNION: () => UNION,\n  UpdateService: () => UpdateService,\n  VERTICAL_ALIGN: () => VERTICAL_ALIGN,\n  Validate: () => Validate,\n  Vec2: () => Vec2,\n  Vec4: () => Vec4,\n  WIDGET_HTML_EVENTS: () => WIDGET_HTML_EVENTS,\n  Widget: () => Widget,\n  WidgetEventUtil: () => WidgetEventUtil,\n  ZIndexMap: () => ZIndexMap,\n  ZoomManager: () => ZoomManager,\n  accumulateGroup: () => accumulateGroup,\n  accumulateStack: () => accumulateStack,\n  accumulatedValue: () => accumulatedValue,\n  accumulativeValueProperty: () => accumulativeValueProperty,\n  addHitTestersToQuadtree: () => addHitTestersToQuadtree,\n  adjustLabelPlacement: () => adjustLabelPlacement,\n  angleBetween: () => angleBetween,\n  animationValidation: () => animationValidation,\n  applyShapeStyle: () => applyShapeStyle,\n  areScalingEqual: () => areScalingEqual,\n  area: () => area,\n  buildFormatter: () => buildFormatter,\n  buildResetPathFn: () => buildResetPathFn,\n  calculateDefaultTimeTickFormat: () => calculateDefaultTimeTickFormat,\n  calculateDerivativeExtrema: () => calculateDerivativeExtrema,\n  calculateDerivativeExtremaXY: () => calculateDerivativeExtremaXY,\n  calculateLabelChartPadding: () => calculateLabelChartPadding,\n  calculateLabelTranslation: () => calculateLabelTranslation,\n  calculatePlacement: () => calculatePlacement,\n  checkCrisp: () => checkCrisp,\n  clamp: () => clamp,\n  clampArray: () => clampArray,\n  clippedRoundRect: () => clippedRoundRect,\n  collapsedStartingBarPosition: () => collapsedStartingBarPosition,\n  compareDates: () => compareDates,\n  computeBarFocusBounds: () => computeBarFocusBounds,\n  computeMarkerFocusBounds: () => computeMarkerFocusBounds,\n  countExpandingSearch: () => countExpandingSearch,\n  countFractionDigits: () => countFractionDigits,\n  createButton: () => createButton,\n  createCheckbox: () => createCheckbox,\n  createDatumId: () => createDatumId,\n  createDeprecationWarning: () => createDeprecationWarning,\n  createElement: () => createElement,\n  createElementId: () => createElementId,\n  createIcon: () => createIcon,\n  createId: () => createId,\n  createSelect: () => createSelect,\n  createSvgElement: () => createSvgElement,\n  createTextArea: () => createTextArea,\n  dateToNumber: () => dateToNumber,\n  datesSortOrder: () => datesSortOrder,\n  datumKeys: () => datumKeys,\n  datumStylerProperties: () => datumStylerProperties,\n  deconstructSelectionsOrNodes: () => deconstructSelectionsOrNodes,\n  deepClone: () => deepClone,\n  deepFreeze: () => deepFreeze,\n  defaultTimeTickFormat: () => defaultTimeTickFormat,\n  diff: () => diff,\n  downloadUrl: () => downloadUrl,\n  drawCorner: () => drawCorner,\n  drawMarkerUnitPolygon: () => drawMarkerUnitPolygon,\n  easing: () => easing_exports,\n  enterpriseModule: () => enterpriseModule,\n  evaluateBezier: () => evaluateBezier,\n  extent: () => extent,\n  extractDecoratedProperties: () => extractDecoratedProperties,\n  findMinMax: () => findMinMax,\n  findQuadtreeMatch: () => findQuadtreeMatch,\n  findRangeExtent: () => findRangeExtent,\n  fixNumericExtent: () => fixNumericExtent,\n  focusCursorAtEnd: () => focusCursorAtEnd,\n  formatNumber: () => formatNumber,\n  formatPercent: () => formatPercent,\n  formatValue: () => formatValue,\n  fromToMotion: () => fromToMotion,\n  generateUUID: () => generateUUID,\n  getAngleRatioRadians: () => getAngleRatioRadians,\n  getColorStops: () => getColorStops,\n  getDateTicksForInterval: () => getDateTicksForInterval,\n  getDatumRefPoint: () => getDatumRefPoint,\n  getDocument: () => getDocument,\n  getElementBBox: () => getElementBBox,\n  getIconClassNames: () => getIconClassNames,\n  getLastFocus: () => getLastFocus,\n  getMissCount: () => getMissCount,\n  getPath: () => getPath,\n  getPathComponents: () => getPathComponents,\n  getRadialColumnWidth: () => getRadialColumnWidth,\n  getWindow: () => getWindow,\n  groupAccumulativeValueProperty: () => groupAccumulativeValueProperty,\n  groupAverage: () => groupAverage,\n  groupCount: () => groupCount,\n  groupStackValueProperty: () => groupStackValueProperty,\n  groupSum: () => groupSum,\n  hasNoModifiers: () => hasNoModifiers,\n  inRange: () => inRange,\n  initMenuKeyNav: () => initMenuKeyNav,\n  initRovingTabIndex: () => initRovingTabIndex,\n  interpolatePoints: () => interpolatePoints,\n  isAgFlowProportionChartOptions: () => isAgFlowProportionChartOptions,\n  isAgGaugeChartOptions: () => isAgGaugeChartOptions,\n  isAgHierarchyChartOptions: () => isAgHierarchyChartOptions,\n  isAgStandaloneChartOptions: () => isAgStandaloneChartOptions,\n  isAgTopologyChartOptions: () => isAgTopologyChartOptions,\n  isBetweenAngles: () => isBetweenAngles,\n  isButtonClickEvent: () => isButtonClickEvent,\n  isContinuous: () => isContinuous,\n  isDecoratedObject: () => isDecoratedObject,\n  isDenseInterval: () => isDenseInterval,\n  isInputPending: () => isInputPending,\n  isInteger: () => isInteger,\n  isNegative: () => isNegative,\n  isNumberEqual: () => isNumberEqual,\n  isProperties: () => isProperties,\n  isScaleValid: () => isScaleValid,\n  jsonApply: () => jsonApply,\n  jsonDiff: () => jsonDiff,\n  jsonPropertyCompare: () => jsonPropertyCompare,\n  jsonResolveOperations: () => jsonResolveOperations,\n  jsonWalk: () => jsonWalk,\n  keyProperty: () => keyProperty,\n  labelDirectionHandling: () => labelDirectionHandling,\n  legendSymbolSvg: () => legendSymbolSvg,\n  lineDistanceSquared: () => lineDistanceSquared,\n  listDecoratedProperties: () => listDecoratedProperties,\n  makeAccessibleClickListener: () => makeAccessibleClickListener,\n  mapValues: () => mapValues,\n  markerFadeInAnimation: () => markerFadeInAnimation,\n  markerPaletteFactory: () => markerPaletteFactory,\n  markerScaleInAnimation: () => markerScaleInAnimation,\n  markerSwipeScaleInAnimation: () => markerSwipeScaleInAnimation,\n  mergeArrayDefaults: () => mergeArrayDefaults,\n  mergeDefaults: () => mergeDefaults,\n  midpointStartingBarPosition: () => midpointStartingBarPosition,\n  mod: () => mod,\n  moduleRegistry: () => moduleRegistry,\n  motion: () => motion,\n  nearestSquared: () => nearestSquared,\n  nearestSquaredInContainer: () => nearestSquaredInContainer,\n  normaliseGroupTo: () => normaliseGroupTo,\n  normalisePropertyTo: () => normalisePropertyTo,\n  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,\n  normalizeAngle180: () => normalizeAngle180,\n  normalizeAngle360: () => normalizeAngle360,\n  normalizeAngle360Inclusive: () => normalizeAngle360Inclusive,\n  objectsEqual: () => objectsEqual,\n  objectsEqualWith: () => objectsEqualWith,\n  pairUpSpans: () => pairUpSpans,\n  partialAssign: () => partialAssign,\n  pathFadeInAnimation: () => pathFadeInAnimation,\n  pathMotion: () => pathMotion,\n  pathSwipeInAnimation: () => pathSwipeInAnimation,\n  pickByMatchingAngle: () => pickByMatchingAngle,\n  plotAreaPathFill: () => plotAreaPathFill,\n  plotInterpolatedAreaSeriesFillSpans: () => plotInterpolatedAreaSeriesFillSpans,\n  plotInterpolatedLinePathStroke: () => plotInterpolatedLinePathStroke,\n  plotLinePathStroke: () => plotLinePathStroke,\n  predicateWithMessage: () => predicateWithMessage,\n  prepareAreaFillAnimationFns: () => prepareAreaFillAnimationFns,\n  prepareAreaPathAnimation: () => prepareAreaPathAnimation,\n  prepareAxisAnimationContext: () => prepareAxisAnimationContext,\n  prepareAxisAnimationFunctions: () => prepareAxisAnimationFunctions,\n  prepareBarAnimationFunctions: () => prepareBarAnimationFunctions,\n  prepareLinePathAnimation: () => prepareLinePathAnimation,\n  prepareLinePathPropertyAnimation: () => prepareLinePathPropertyAnimation,\n  prepareLinePathStrokeAnimationFns: () => prepareLinePathStrokeAnimationFns,\n  preparePieSeriesAnimationFunctions: () => preparePieSeriesAnimationFunctions,\n  range: () => range,\n  rangedValueProperty: () => rangedValueProperty,\n  resetAxisGroupFn: () => resetAxisGroupFn,\n  resetAxisLabelSelectionFn: () => resetAxisLabelSelectionFn,\n  resetAxisLineSelectionFn: () => resetAxisLineSelectionFn,\n  resetAxisSelectionFn: () => resetAxisSelectionFn,\n  resetBarSelectionsFn: () => resetBarSelectionsFn,\n  resetIds: () => resetIds,\n  resetLabelFn: () => resetLabelFn,\n  resetMarkerFn: () => resetMarkerFn,\n  resetMarkerPositionFn: () => resetMarkerPositionFn,\n  resetMotion: () => resetMotion,\n  resetPieSelectionsFn: () => resetPieSelectionsFn,\n  round: () => round,\n  rowCountProperty: () => rowCountProperty,\n  sanitizeHtml: () => sanitizeHtml,\n  scale: () => scale,\n  sectorBox: () => sectorBox,\n  seriesLabelFadeInAnimation: () => seriesLabelFadeInAnimation,\n  seriesLabelFadeOutAnimation: () => seriesLabelFadeOutAnimation,\n  setAttribute: () => setAttribute,\n  setAttributes: () => setAttributes,\n  setDocument: () => setDocument,\n  setElementBBox: () => setElementBBox,\n  setElementStyle: () => setElementStyle,\n  setPath: () => setPath,\n  setWindow: () => setWindow,\n  shallowClone: () => shallowClone,\n  singleSeriesPaletteFactory: () => singleSeriesPaletteFactory,\n  solveBezier: () => solveBezier,\n  sortAndUniqueDates: () => sortAndUniqueDates,\n  splitBezier: () => splitBezier,\n  staticFromToMotion: () => staticFromToMotion,\n  stopPageScrolling: () => stopPageScrolling,\n  sum: () => sum,\n  sumValues: () => sumValues,\n  swapAxisCondition: () => swapAxisCondition,\n  toDegrees: () => toDegrees,\n  toRadians: () => toRadians,\n  tooltipContentAriaLabel: () => tooltipContentAriaLabel,\n  trailingAccumulatedValue: () => trailingAccumulatedValue,\n  trailingAccumulatedValueProperty: () => trailingAccumulatedValueProperty,\n  updateClipPath: () => updateClipPath,\n  updateLabelNode: () => updateLabelNode,\n  validateCrossLineValues: () => validateCrossLineValues,\n  valueProperty: () => valueProperty,\n  visibleRangeIndices: () => visibleRangeIndices,\n  without: () => without\n});\n\n// packages/ag-charts-community/src/util/deprecation.ts\nfunction createDeprecationWarning() {\n  return (key, message) => {\n    const msg = [`Property [${key}] is deprecated.`, message].filter(Boolean).join(\" \");\n    logger_exports.warnOnce(msg);\n  };\n}\nfunction Deprecated(message, opts) {\n  const warnDeprecated = createDeprecationWarning();\n  const def = opts?.default;\n  return addTransformToInstanceProperty((_, key, value) => {\n    if (value !== def) {\n      warnDeprecated(key.toString(), message);\n    }\n    return value;\n  });\n}\nfunction DeprecatedAndRenamedTo(newPropName, mapValue) {\n  const warnDeprecated = createDeprecationWarning();\n  return addTransformToInstanceProperty(\n    (target, key, value) => {\n      if (value !== target[newPropName]) {\n        warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);\n        setPath(target, newPropName, mapValue ? mapValue(value) : value);\n      }\n      return BREAK_TRANSFORM_CHAIN;\n    },\n    (target, key) => {\n      warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);\n      return getPath(target, newPropName);\n    }\n  );\n}\n\n// packages/ag-charts-community/src/util/vector.ts\nvar Vec2 = {\n  add,\n  angle,\n  apply,\n  equal,\n  distance,\n  distanceSquared,\n  from: from2,\n  gradient,\n  intercept,\n  intersectAtX,\n  intersectAtY,\n  length,\n  lengthSquared,\n  multiply,\n  normalized,\n  origin: origin2,\n  required,\n  rotate,\n  round: round4,\n  sub\n};\nfunction add(a, b) {\n  if (typeof b === \"number\") {\n    return { x: a.x + b, y: a.y + b };\n  }\n  return { x: a.x + b.x, y: a.y + b.y };\n}\nfunction sub(a, b) {\n  if (typeof b === \"number\") {\n    return { x: a.x - b, y: a.y - b };\n  }\n  return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction multiply(a, b) {\n  if (typeof b === \"number\") {\n    return { x: a.x * b, y: a.y * b };\n  }\n  return { x: a.x * b.x, y: a.y * b.y };\n}\nfunction length(a) {\n  return Math.sqrt(a.x * a.x + a.y * a.y);\n}\nfunction lengthSquared(a) {\n  return a.x * a.x + a.y * a.y;\n}\nfunction distance(a, b) {\n  const d = sub(a, b);\n  return Math.sqrt(d.x * d.x + d.y * d.y);\n}\nfunction distanceSquared(a, b) {\n  const d = sub(a, b);\n  return d.x * d.x + d.y * d.y;\n}\nfunction normalized(a) {\n  const l = length(a);\n  return { x: a.x / l, y: a.y / l };\n}\nfunction angle(a, b = origin2()) {\n  return Math.atan2(a.y, a.x) - Math.atan2(b.y, b.x);\n}\nfunction rotate(a, theta, b = origin2()) {\n  const l = length(a);\n  return { x: b.x + l * Math.cos(theta), y: b.y + l * Math.sin(theta) };\n}\nfunction gradient(a, b, reflection) {\n  const dx = b.x - a.x;\n  const dy = reflection == null ? b.y - a.y : reflection - b.y - (reflection - a.y);\n  return dy / dx;\n}\nfunction intercept(a, gradient2, reflection) {\n  const y = reflection == null ? a.y : reflection - a.y;\n  return y - gradient2 * a.x;\n}\nfunction intersectAtY(gradient2, coefficient, y = 0, reflection) {\n  return {\n    x: gradient2 === Infinity ? Infinity : (y - coefficient) / gradient2,\n    y: reflection == null ? y : reflection - y\n  };\n}\nfunction intersectAtX(gradient2, coefficient, x = 0, reflection) {\n  const y = gradient2 === Infinity ? Infinity : gradient2 * x + coefficient;\n  return { x, y: reflection == null ? y : reflection - y };\n}\nfunction round4(a) {\n  return { x: Math.round(a.x), y: Math.round(a.y) };\n}\nfunction equal(a, b) {\n  return a.x === b.x && a.y === b.y;\n}\nfunction from2(a, b) {\n  if (typeof a === \"number\") {\n    return { x: a, y: b };\n  }\n  if (\"currentX\" in a) {\n    return { x: a.currentX, y: a.currentY };\n  }\n  if (\"offsetWidth\" in a) {\n    return { x: a.offsetWidth, y: a.offsetHeight };\n  }\n  if (\"width\" in a) {\n    return [\n      { x: a.x, y: a.y },\n      { x: a.x + a.width, y: a.y + a.height }\n    ];\n  }\n  if (\"x1\" in a) {\n    return [\n      { x: a.x1, y: a.y1 },\n      { x: a.x2, y: a.y2 }\n    ];\n  }\n  throw new Error(`Values can not be converted into a vector: [${JSON.stringify(a)}] [${b}]`);\n}\nfunction apply(a, b) {\n  a.x = b.x;\n  a.y = b.y;\n  return a;\n}\nfunction required(a) {\n  return { x: a?.x ?? 0, y: a?.y ?? 0 };\n}\nfunction origin2() {\n  return { x: 0, y: 0 };\n}\n\n// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeries.ts\nvar _HierarchyNode = class _HierarchyNode {\n  constructor(series, datumIndex, datum, sizeValue, colorValue, sumSize, depth, parent, children) {\n    this.series = series;\n    this.datumIndex = datumIndex;\n    this.datum = datum;\n    this.sizeValue = sizeValue;\n    this.colorValue = colorValue;\n    this.sumSize = sumSize;\n    this.depth = depth;\n    this.parent = parent;\n    this.children = children;\n    this.midPoint = { x: 0, y: 0 };\n  }\n  get hasChildren() {\n    return this.children.length > 0;\n  }\n  walk(callback2, order = _HierarchyNode.Walk.PreOrder) {\n    if (order === _HierarchyNode.Walk.PreOrder) {\n      callback2(this);\n    }\n    this.children.forEach((child) => {\n      child.walk(callback2, order);\n    });\n    if (order === _HierarchyNode.Walk.PostOrder) {\n      callback2(this);\n    }\n  }\n  *[Symbol.iterator]() {\n    yield this;\n    for (const child of this.children) {\n      yield* child;\n    }\n  }\n};\n_HierarchyNode.Walk = {\n  PreOrder: 0,\n  PostOrder: 1\n};\nvar HierarchyNode = _HierarchyNode;\nvar HierarchySeries = class extends Series {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */]\n    });\n    this.colorDomain = [0, 0];\n    this.maxDepth = 0;\n    this.colorScale = new ColorScale();\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    }\n  }\n  processData() {\n    const { NodeClass } = this;\n    const { childrenKey, sizeKey, colorKey, colorRange } = this.properties;\n    let maxDepth = 0;\n    let minColor = Infinity;\n    let maxColor = -Infinity;\n    const createNode = (datum, indexPath, parent) => {\n      const depth = parent.depth != null ? parent.depth + 1 : 0;\n      const children = childrenKey != null ? datum[childrenKey] : void 0;\n      const isLeaf = children == null || children.length === 0;\n      let sizeValue = sizeKey != null ? datum[sizeKey] : void 0;\n      if (Number.isFinite(sizeValue)) {\n        sizeValue = Math.max(sizeValue, 0);\n      } else {\n        sizeValue = isLeaf ? 1 : 0;\n      }\n      const sumSize = sizeValue;\n      maxDepth = Math.max(maxDepth, depth);\n      const colorValue = colorKey != null ? datum[colorKey] : void 0;\n      if (typeof colorValue === \"number\") {\n        minColor = Math.min(minColor, colorValue);\n        maxColor = Math.max(maxColor, colorValue);\n      }\n      return appendChildren(\n        new NodeClass(this, indexPath, datum, sizeValue, colorValue, sumSize, depth, parent, []),\n        children\n      );\n    };\n    const appendChildren = (node, data) => {\n      const { datumIndex } = node;\n      data?.forEach((datum, childIndex) => {\n        const child = createNode(datum, datumIndex.concat(childIndex), node);\n        node.children.push(child);\n        node.sumSize += child.sumSize;\n      });\n      return node;\n    };\n    const rootNode = appendChildren(\n      new NodeClass(this, [], void 0, 0, void 0, 0, void 0, void 0, []),\n      this.data\n    );\n    const colorDomain = [minColor, maxColor];\n    this.colorScale.domain = minColor < maxColor ? [minColor, maxColor] : [0, 1];\n    this.colorScale.range = colorRange ?? [\"black\"];\n    this.colorScale.update();\n    this.rootNode = rootNode;\n    this.maxDepth = maxDepth;\n    this.colorDomain = colorDomain;\n  }\n  update({ seriesRect }) {\n    this.updateSelections();\n    this.updateNodes();\n    const animationData = this.getAnimationData();\n    const resize = this.checkResize(seriesRect);\n    if (resize) {\n      this.animationState.transition(\"resize\", animationData);\n    }\n    this.animationState.transition(\"update\", animationData);\n  }\n  resetAllAnimation(_data) {\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n  }\n  animateEmptyUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateWaitingUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateReadyHighlight(_data) {\n  }\n  animateReadyResize(data) {\n    this.resetAllAnimation(data);\n  }\n  animateClearingUpdateEmpty(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  getAnimationData() {\n    return {};\n  }\n  isProcessedDataAnimatable() {\n    return true;\n  }\n  checkProcessedDataAnimatable() {\n    if (!this.isProcessedDataAnimatable()) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  getSeriesDomain() {\n    return [NaN, NaN];\n  }\n  getSeriesRange(_direction, _visibleRange) {\n    return [NaN, NaN];\n  }\n  getLegendData(legendType) {\n    const { colorKey, colorName, colorRange } = this.properties;\n    const {\n      id: seriesId,\n      ctx: { legendManager },\n      visible\n    } = this;\n    return legendType === \"gradient\" && colorKey != null && colorRange != null ? [\n      {\n        legendType: \"gradient\",\n        enabled: visible && legendManager.getItemEnabled({ seriesId }),\n        seriesId,\n        colorName,\n        colorRange,\n        colorDomain: this.colorDomain\n      }\n    ] : [];\n  }\n  getDatumIdFromData(node) {\n    return node.datumIndex.join(\":\");\n  }\n  getDatumId(node) {\n    return this.getDatumIdFromData(node);\n  }\n  removeMeIndexPathForIndex(index) {\n    return this.datumSelection.at(index + 1)?.datum.datumIndex ?? [];\n  }\n  removeMeIndexForIndexPath(indexPath) {\n    for (const { index, datum } of this.datumSelection) {\n      if (arraysEqual(datum.datumIndex, indexPath)) {\n        return index - 1;\n      }\n    }\n    return 0;\n  }\n  pickFocus(opts) {\n    if (!this.rootNode?.children.length)\n      return void 0;\n    const index = clamp(0, opts.datumIndex - opts.datumIndexDelta, this.datumSelection.length - 1);\n    const { datumIndexDelta: childDelta, otherIndexDelta: depthDelta } = opts;\n    let path = this.removeMeIndexPathForIndex(index);\n    const currentNode = path.reduce((n, childIndex) => n.children[childIndex], this.rootNode);\n    if (depthDelta > 0 && currentNode.hasChildren) {\n      path = [...path, 0];\n    } else if (depthDelta < 0 && path.length > 1) {\n      path = path.slice(0, -1);\n    } else if (depthDelta === 0 && childDelta !== 0) {\n      const maxIndex = currentNode.parent.children.length - 1;\n      path = path.slice();\n      path[path.length - 1] = clamp(0, path[path.length - 1] + childDelta, maxIndex);\n    }\n    const nextNode = path.reduce((n, childIndex) => n.children[childIndex], this.rootNode);\n    const bounds = this.computeFocusBounds(this.datumSelection.at(index + 1));\n    if (bounds == null)\n      return;\n    return {\n      datum: nextNode,\n      datumIndex: this.removeMeIndexForIndexPath(path),\n      otherIndex: nextNode.depth,\n      bounds,\n      clipFocusBox: true\n    };\n  }\n  getDatumAriaText(datum, description) {\n    if (!(datum instanceof this.NodeClass)) {\n      logger_exports.error(`datum is not HierarchyNode: ${JSON.stringify(datum)}`);\n      return;\n    }\n    return this.ctx.localeManager.t(\"ariaAnnounceHierarchyDatum\", {\n      level: (datum.depth ?? -1) + 1,\n      count: datum.children.length,\n      description\n    });\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeriesProperties.ts\nvar HierarchySeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.childrenKey = \"children\";\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], HierarchySeriesProperties.prototype, \"childrenKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], HierarchySeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], HierarchySeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorRange\", 2);\n\n// packages/ag-charts-community/src/chart/series/topology/lonLatBbox.ts\nvar LonLatBBox = class {\n  constructor(lon0, lat0, lon1, lat1) {\n    this.lon0 = lon0;\n    this.lat0 = lat0;\n    this.lon1 = lon1;\n    this.lat1 = lat1;\n  }\n  merge(other) {\n    this.lon0 = Math.min(this.lon0, other.lon0);\n    this.lat0 = Math.min(this.lat0, other.lat0);\n    this.lon1 = Math.max(this.lon1, other.lon1);\n    this.lat1 = Math.max(this.lat1, other.lat1);\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/topology/mercatorScale.ts\nvar radsInDeg = Math.PI / 180;\nvar lonX = (lon) => lon * radsInDeg;\nvar latY = (lat) => -Math.log(Math.tan(Math.PI * 0.25 + lat * radsInDeg * 0.5));\nvar xLon = (x) => x / radsInDeg;\nvar yLat = (y) => (Math.atan(Math.exp(-y)) - Math.PI * 0.25) / (radsInDeg * 0.5);\nvar MercatorScale = class _MercatorScale extends AbstractScale {\n  constructor(domain, range3) {\n    super();\n    this.domain = domain;\n    this.range = range3;\n    this.type = \"mercator\";\n    this.bounds = _MercatorScale.bounds(domain);\n  }\n  static bounds(domain) {\n    const [[lon0, lat0], [lon1, lat1]] = domain;\n    const x0 = lonX(lon0);\n    const y0 = latY(lat0);\n    const x1 = lonX(lon1);\n    const y1 = latY(lat1);\n    return new BBox(Math.min(x0, x1), Math.min(y0, y1), Math.abs(x1 - x0), Math.abs(y1 - y0));\n  }\n  static fixedScale() {\n    return new _MercatorScale(\n      [\n        [xLon(0), yLat(0)],\n        [xLon(1), yLat(1)]\n      ],\n      [\n        [0, 0],\n        [1, 1]\n      ]\n    );\n  }\n  toDomain() {\n    return;\n  }\n  normalizeDomains(...domains) {\n    let x0 = -Infinity;\n    let x1 = Infinity;\n    let y0 = -Infinity;\n    let y1 = Infinity;\n    for (const domain of domains) {\n      for (const [x, y] of domain) {\n        x0 = Math.min(x, x0);\n        x1 = Math.max(x, x1);\n        y0 = Math.min(y, y0);\n        y1 = Math.max(y, y1);\n      }\n    }\n    return {\n      domain: [\n        [x0, y0],\n        [x1, y1]\n      ],\n      animatable: true\n    };\n  }\n  convert([lon, lat]) {\n    const [[x0, y0], [x1, y1]] = this.range;\n    const xScale = (x1 - x0) / this.bounds.width;\n    const yScale = (y1 - y0) / this.bounds.height;\n    return [(lonX(lon) - this.bounds.x) * xScale + x0, (latY(lat) - this.bounds.y) * yScale + y0];\n  }\n  invert([x, y]) {\n    const [[x0, y0], [x1, y1]] = this.range;\n    const xScale = (x1 - x0) / this.bounds.width;\n    const yScale = (y1 - y0) / this.bounds.height;\n    return [xLon((x - x0) / xScale + this.bounds.x), yLat((y - y0) / yScale + this.bounds.y)];\n  }\n};\n\n// packages/ag-charts-community/src/chart/axis/axisTicks.ts\nvar _AxisTicks = class _AxisTicks {\n  constructor() {\n    this.id = createId(this);\n    this.axisGroup = new TranslatableGroup({ name: `${this.id}-AxisTicks`, zIndex: 2 /* AXIS */ });\n    this.labelSelection = Selection.select(this.axisGroup, Text);\n    this.interval = new AxisInterval();\n    this.label = new AxisLabel();\n    this.scale = new LinearScale();\n    this.position = \"bottom\";\n    this.translationX = 0;\n    this.translationY = 0;\n    this.padding = 0;\n  }\n  attachAxis(axisNode) {\n    axisNode.appendChild(this.axisGroup);\n  }\n  calculateLayout() {\n    const boxes = [];\n    const tickData = this.generateTicks();\n    const { translationX, translationY } = this;\n    this.labelSelection.update(\n      tickData.ticks.map((d) => this.createLabelDatum(d)),\n      void 0,\n      (datum) => datum.tickId\n    );\n    this.labelSelection.each((node, datum) => {\n      node.setProperties(datum);\n      if (datum.visible) {\n        boxes.push(node.getBBox());\n      }\n    });\n    this.axisGroup.setProperties({ translationX, translationY });\n    return BBox.merge(boxes);\n  }\n  getLabelParams(datum) {\n    const { padding } = this;\n    const { translate } = datum;\n    switch (this.position) {\n      case \"top\":\n      case \"bottom\":\n        return {\n          x: translate,\n          y: padding,\n          textAlign: \"center\",\n          textBaseline: \"top\"\n        };\n      case \"left\":\n      case \"right\":\n        return {\n          x: padding,\n          y: translate,\n          textAlign: \"start\",\n          textBaseline: \"middle\"\n        };\n    }\n  }\n  inRange(x, tolerance = 1e-3) {\n    const [min, max] = findMinMax(this.scale.range);\n    return x >= min - tolerance && x <= max + tolerance;\n  }\n  createLabelDatum(datum) {\n    const { x, y, textBaseline, textAlign } = this.getLabelParams(datum);\n    return {\n      visible: Boolean(datum.tickLabel),\n      tickId: datum.tickId,\n      fill: this.label.color,\n      fontFamily: this.label.fontFamily,\n      fontSize: this.label.fontSize,\n      fontStyle: this.label.fontStyle,\n      fontWeight: this.label.fontWeight,\n      rotation: 0,\n      rotationCenterX: 0,\n      text: datum.tickLabel,\n      textAlign,\n      textBaseline,\n      x,\n      y\n    };\n  }\n  generateTicks() {\n    const { minSpacing, maxSpacing } = this.interval;\n    const { maxTickCount, minTickCount, tickCount } = estimateTickCount(\n      findRangeExtent(this.scale.range),\n      1,\n      minSpacing,\n      maxSpacing,\n      _AxisTicks.DefaultTickCount,\n      _AxisTicks.DefaultMinSpacing\n    );\n    const tickData = this.getTicksData({\n      nice: true,\n      interval: this.interval.step,\n      tickCount,\n      minTickCount,\n      maxTickCount\n    });\n    if (this.position === \"bottom\" || this.position === \"top\") {\n      const measurer2 = CachedTextMeasurerPool.getMeasurer({ font: this.label });\n      const { domain } = this.scale;\n      const reversed = domain[0] > domain[1];\n      const direction = reversed ? -1 : 1;\n      let lastTickPosition = -Infinity * direction;\n      tickData.ticks = tickData.ticks.filter((data) => {\n        if (Math.sign(data.translate - lastTickPosition) !== direction)\n          return false;\n        lastTickPosition = data.translate + measurer2.textWidth(data.tickLabel, true) * direction;\n        return true;\n      });\n    }\n    return tickData;\n  }\n  getTicksData(tickParams) {\n    const ticks = [];\n    const niceDomain = tickParams.nice ? this.scale.niceDomain(tickParams) : this.scale.domain;\n    const rawTicks = this.scale.ticks(tickParams, niceDomain);\n    const fractionDigits = rawTicks.reduce((max, tick) => Math.max(max, countFractionDigits(tick)), 0);\n    const idGenerator = createIdsGenerator();\n    const labelFormatter = this.label.format ? this.scale.tickFormatter({\n      domain: niceDomain,\n      ticks: rawTicks,\n      fractionDigits,\n      specifier: this.label.format\n    }) : (x) => formatValue(x, fractionDigits);\n    for (let index = 0; index < rawTicks.length; index++) {\n      const tick = rawTicks[index];\n      const translate = this.scale.convert(tick);\n      if (!this.inRange(translate))\n        continue;\n      const tickLabel = this.label.formatter?.({ value: tick, index, fractionDigits }) ?? labelFormatter(tick);\n      const tickId = idGenerator(tickLabel);\n      ticks.push({ tick, tickId, tickLabel, translate });\n    }\n    return { rawTicks, fractionDigits, ticks };\n  }\n};\n_AxisTicks.DefaultTickCount = 5;\n_AxisTicks.DefaultMinSpacing = 10;\nvar AxisTicks = _AxisTicks;\n\n// packages/ag-charts-community/src/dom/elements.ts\nfunction createButton(options, attrs) {\n  const button = createElement(\"button\", getClassName(\"ag-charts-input ag-charts-button\", attrs));\n  if (options.label !== void 0) {\n    button.append(options.label);\n  } else {\n    button.append(createIcon(options.icon));\n    button.ariaLabel = options.altText;\n  }\n  button.addEventListener(\"click\", options.onPress);\n  setAttributes(button, attrs);\n  return button;\n}\nfunction createCheckbox(options, attrs) {\n  const checkbox = createElement(\"input\", getClassName(\"ag-charts-input ag-charts-checkbox\", attrs));\n  checkbox.type = \"checkbox\";\n  checkbox.checked = options.checked;\n  checkbox.addEventListener(\"change\", (event) => options.onChange(checkbox.checked, event));\n  checkbox.addEventListener(\"keydown\", (event) => {\n    if (isButtonClickEvent(event)) {\n      event.preventDefault();\n      checkbox.click();\n    }\n  });\n  setAttributes(checkbox, attrs);\n  return checkbox;\n}\nfunction createSelect(options, attrs) {\n  const select = createElement(\"select\", getClassName(\"ag-charts-input ag-charts-select\", attrs));\n  select.append(\n    ...options.options.map((option) => {\n      const optionEl = createElement(\"option\");\n      optionEl.value = option.value;\n      optionEl.textContent = option.label;\n      return optionEl;\n    })\n  );\n  setAttribute(select, \"data-preventdefault\", false);\n  select.value = options.value;\n  select.addEventListener(\"change\", (event) => options.onChange(select.value, event));\n  setAttributes(select, attrs);\n  return select;\n}\nfunction createTextArea(options, attrs) {\n  const textArea = createElement(\"textarea\", getClassName(\"ag-charts-input ag-charts-textarea\", attrs));\n  textArea.value = options.value;\n  textArea.addEventListener(\"input\", (event) => options.onChange(textArea.value, event));\n  setAttributes(textArea, attrs);\n  setAttribute(textArea, \"data-preventdefault\", false);\n  return textArea;\n}\nfunction createIcon(icon) {\n  const el = createElement(\"span\", `ag-charts-icon ag-charts-icon-${icon}`);\n  setAttribute(el, \"aria-hidden\", true);\n  return el;\n}\nfunction getClassName(baseClass, attrs) {\n  if (attrs == null)\n    return baseClass;\n  return `${baseClass} ${attrs.class}`;\n}\n\n// packages/ag-charts-community/src/scene/gradient/conicGradient.ts\nvar ConicGradient = class extends Gradient {\n  constructor(colorSpace, stops, angle2 = 0, bbox) {\n    super(colorSpace, stops, bbox);\n    this.angle = angle2;\n  }\n  createCanvasGradient(ctx, bbox) {\n    const angleOffset = 90;\n    const { angle: angle2 } = this;\n    const radians = normalizeAngle360(toRadians(angle2 + angleOffset));\n    const cx = bbox.x + bbox.width * 0.5;\n    const cy = bbox.y + bbox.height * 0.5;\n    return ctx.createConicGradient(radians, cx, cy);\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/svgPath.ts\nvar SvgPath = class extends Path {\n  constructor(d = \"\") {\n    super();\n    this.x = 0;\n    this.y = 0;\n    this.commands = [];\n    this._d = \"\";\n    this.d = d;\n  }\n  get d() {\n    return this._d;\n  }\n  set d(d) {\n    if (d === this._d)\n      return;\n    this._d = d;\n    this.commands.length = 0;\n    for (const [_, command, paramsString] of d.matchAll(/([A-Z])([0-9. ]*)/g)) {\n      const params = paramsString.split(/\\s+/g).map(Number);\n      this.commands.push([command, params]);\n    }\n    this.checkPathDirty();\n  }\n  updatePath() {\n    const { path, x, y } = this;\n    path.clear();\n    let lastX = x;\n    let lastY = y;\n    for (const [command, params] of this.commands) {\n      switch (command) {\n        case \"M\":\n          path.moveTo(x + params[0], y + params[1]);\n          lastX = x + params[0];\n          break;\n        case \"C\":\n          path.cubicCurveTo(\n            x + params[0],\n            y + params[1],\n            x + params[2],\n            y + params[3],\n            x + params[4],\n            y + params[5]\n          );\n          lastX = x + params[4];\n          lastY = y + params[5];\n          break;\n        case \"H\":\n          path.lineTo(x + params[0], lastY);\n          lastX = y + params[0];\n          break;\n        case \"L\":\n          path.lineTo(x + params[0], y + params[1]);\n          lastX = x + params[0];\n          lastY = y + params[1];\n          break;\n        case \"V\":\n          path.lineTo(lastX, y + params[0]);\n          lastY = y + params[0];\n          break;\n        case \"Z\":\n          path.closePath();\n          break;\n        default:\n          throw new Error(`Could not translate command '${command}' with '${params.join(\" \")}'`);\n      }\n    }\n    path.closePath();\n  }\n};\n__decorateClass([\n  ScenePathChangeDetection()\n], SvgPath.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], SvgPath.prototype, \"y\", 2);\n\n// packages/ag-charts-community/src/scene/image.ts\nvar Image = class extends Node {\n  constructor(sourceImage) {\n    super();\n    this.sourceImage = sourceImage;\n    this.x = 0;\n    this.y = 0;\n    this.width = 0;\n    this.height = 0;\n    this.opacity = 1;\n  }\n  render(renderCtx) {\n    const { ctx } = renderCtx;\n    const image = this.sourceImage;\n    if (image) {\n      ctx.globalAlpha = this.opacity;\n      ctx.drawImage(image, 0, 0, image.width, image.height, this.x, this.y, this.width, this.height);\n    }\n    super.render(renderCtx);\n  }\n};\n__decorateClass([\n  SceneChangeDetection()\n], Image.prototype, \"x\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], Image.prototype, \"y\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], Image.prototype, \"width\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], Image.prototype, \"height\", 2);\n__decorateClass([\n  SceneChangeDetection()\n], Image.prototype, \"opacity\", 2);\n\n// packages/ag-charts-community/src/widget/exports.ts\nvar exports_exports = {};\n__export(exports_exports, {\n  ButtonWidget: () => ButtonWidget,\n  NativeWidget: () => NativeWidget,\n  SliderWidget: () => SliderWidget,\n  ToolbarWidget: () => ToolbarWidget,\n  WIDGET_HTML_EVENTS: () => WIDGET_HTML_EVENTS,\n  Widget: () => Widget,\n  WidgetEventUtil: () => WidgetEventUtil\n});\n\n// packages/ag-charts-community/src/components/popover/popover.ts\nvar canvasOverlay = \"canvas-overlay\";\nvar Popover = class extends BaseModuleInstance {\n  constructor(ctx, id, options) {\n    super();\n    this.ctx = ctx;\n    this.hideFns = [];\n    this.moduleId = `popover-${id}`;\n    if (options?.detached) {\n      this.element = createElement(\"div\");\n    } else {\n      this.element = ctx.domManager.addChild(canvasOverlay, this.moduleId);\n    }\n    this.element.setAttribute(\"role\", \"presentation\");\n    this.destroyFns.push(() => ctx.domManager.removeChild(canvasOverlay, this.moduleId));\n  }\n  attachTo(popover) {\n    if (this.element.parentElement)\n      return;\n    popover.element.append(this.element);\n  }\n  hide(opts) {\n    const { lastFocus = this.lastFocus } = opts ?? {};\n    if (this.element.children.length === 0)\n      return;\n    this.hideFns.forEach((fn) => fn());\n    lastFocus?.focus();\n    this.lastFocus = void 0;\n  }\n  removeChildren() {\n    this.element.replaceChildren();\n  }\n  showWithChildren(children, options) {\n    if (!this.element.parentElement) {\n      throw new Error(\"Can not show popover that has not been attached to a parent.\");\n    }\n    const popover = createElement(\"div\", \"ag-charts-popover\");\n    if (options.ariaLabel != null) {\n      popover.setAttribute(\"aria-label\", options.ariaLabel);\n    }\n    if (options.class != null) {\n      popover.classList.add(options.class);\n    }\n    popover.replaceChildren(...children);\n    this.element.replaceChildren(popover);\n    this.hideFns.push(() => this.removeChildren());\n    if (options.onHide) {\n      this.hideFns.push(options.onHide);\n    }\n    if (options.initialFocus && options.sourceEvent) {\n      const lastFocus = getLastFocus(options.sourceEvent);\n      if (lastFocus !== void 0) {\n        this.lastFocus = lastFocus;\n        this.initialFocus = options.initialFocus;\n      }\n    }\n    return popover;\n  }\n  getPopoverElement() {\n    return this.element.firstElementChild;\n  }\n  updatePosition(position) {\n    const popover = this.getPopoverElement();\n    if (!popover)\n      return;\n    popover.style.setProperty(\"right\", \"unset\");\n    popover.style.setProperty(\"bottom\", \"unset\");\n    if (position.x != null)\n      popover.style.setProperty(\"left\", `${Math.floor(position.x)}px`);\n    if (position.y != null)\n      popover.style.setProperty(\"top\", `${Math.floor(position.y)}px`);\n    this.initialFocus?.focus();\n    this.initialFocus = void 0;\n  }\n};\n\n// packages/ag-charts-community/src/components/popover/anchoredPopover.ts\nvar AnchoredPopover = class extends Popover {\n  setAnchor(anchor, fallbackAnchor) {\n    this.anchor = anchor;\n    this.fallbackAnchor = fallbackAnchor;\n    this.updatePosition(anchor);\n    this.repositionWithinBounds();\n  }\n  showWithChildren(children, options) {\n    const anchor = options.anchor ?? this.anchor;\n    const fallbackAnchor = options.fallbackAnchor ?? this.fallbackAnchor;\n    const popover = super.showWithChildren(children, options);\n    if (anchor) {\n      this.setAnchor(anchor, fallbackAnchor);\n    }\n    getWindow().requestAnimationFrame(() => {\n      this.repositionWithinBounds();\n    });\n    return popover;\n  }\n  repositionWithinBounds() {\n    const { anchor, ctx, fallbackAnchor } = this;\n    const popover = this.getPopoverElement();\n    if (!anchor || !popover)\n      return;\n    const canvasRect = ctx.domManager.getBoundingClientRect();\n    const { offsetWidth: width2, offsetHeight: height2 } = popover;\n    let x = clamp(0, anchor.x, canvasRect.width - width2);\n    let y = clamp(0, anchor.y, canvasRect.height - height2);\n    if (x !== anchor.x && fallbackAnchor?.x != null) {\n      x = clamp(0, fallbackAnchor.x - width2, canvasRect.width - width2);\n    }\n    if (y !== anchor.y && fallbackAnchor?.y != null) {\n      y = clamp(0, fallbackAnchor.y - height2, canvasRect.height - height2);\n    }\n    this.updatePosition({ x, y });\n  }\n};\n\n// packages/ag-charts-community/src/components/menu/menu.ts\nvar Menu = class extends AnchoredPopover {\n  show(options) {\n    const rows = options.items.map((item) => this.createRow(options, item));\n    const popover = this.showWithChildren(rows, options);\n    popover.classList.add(\"ag-charts-menu\");\n    popover.setAttribute(\"role\", \"menu\");\n    this.menuCloser = initMenuKeyNav({\n      orientation: \"vertical\",\n      menu: popover,\n      buttons: rows,\n      sourceEvent: options.sourceEvent,\n      closeCallback: () => this.hide()\n    });\n    this.hideFns.push(() => {\n      this.menuCloser?.finishClosing();\n      this.menuCloser = void 0;\n    });\n  }\n  createRow(options, item) {\n    const { menuItemRole = \"menuitem\" } = options;\n    const active = item.value === options.value;\n    const row = createElement(\"div\", \"ag-charts-menu__row\");\n    row.setAttribute(\"role\", menuItemRole);\n    if (menuItemRole === \"menuitemradio\") {\n      row.setAttribute(\"aria-checked\", (options.value === item.value).toString());\n    }\n    if (typeof item.value === \"string\") {\n      row.dataset.popoverId = item.value;\n    }\n    row.classList.toggle(`ag-charts-menu__row--active`, active);\n    if (item.icon != null) {\n      const icon = createElement(\"span\", `ag-charts-menu__icon ${getIconClassNames(item.icon)}`);\n      row.appendChild(icon);\n    }\n    const strokeWidthVisible = item.strokeWidth != null;\n    if (strokeWidthVisible) {\n      row.classList.toggle(`ag-charts-menu__row--stroke-width-visible`, strokeWidthVisible);\n      row.style.setProperty(\"--strokeWidth\", strokeWidthVisible ? `${item.strokeWidth}px` : null);\n    }\n    if (item.label != null) {\n      const label = createElement(\"span\", \"ag-charts-menu__label\");\n      label.textContent = this.ctx.localeManager.t(item.label);\n      row.appendChild(label);\n    }\n    if (\"altText\" in item) {\n      row.ariaLabel = this.ctx.localeManager.t(item.altText);\n    }\n    const select = () => {\n      options.onPress?.(item);\n    };\n    const onclick = (e) => {\n      if (isButtonClickEvent(e)) {\n        select();\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    };\n    row.addEventListener(\"keydown\", onclick);\n    row.addEventListener(\"click\", onclick);\n    row.addEventListener(\"mousemove\", () => {\n      row.focus({ preventScroll: true });\n    });\n    return row;\n  }\n};\n\n// packages/ag-charts-community/src/components/popover/draggablePopover.ts\nvar DraggablePopover = class extends Popover {\n  constructor() {\n    super(...arguments);\n    this.dragged = false;\n  }\n  setDragHandle(dragHandle) {\n    dragHandle.addListener(\"drag-start\", (event) => {\n      dragHandle.addClass(this.dragHandleDraggingClass);\n      this.onDragStart(event);\n    });\n    dragHandle.addListener(\"drag-move\", this.onDragMove.bind(this));\n    dragHandle.addListener(\"drag-end\", () => {\n      dragHandle.removeClass(this.dragHandleDraggingClass);\n      this.onDragEnd.bind(this);\n    });\n  }\n  onDragStart(event) {\n    const popover = this.getPopoverElement();\n    if (!popover)\n      return;\n    event.sourceEvent.preventDefault();\n    this.dragged = true;\n    this.dragStartState = {\n      client: Vec2.from(event.clientX, event.clientY),\n      position: Vec2.from(\n        Number(popover.style.getPropertyValue(\"left\").replace(\"px\", \"\")),\n        Number(popover.style.getPropertyValue(\"top\").replace(\"px\", \"\"))\n      )\n    };\n  }\n  onDragMove(event) {\n    const { dragStartState } = this;\n    const popover = this.getPopoverElement();\n    if (!dragStartState || !popover)\n      return;\n    const offset4 = Vec2.sub(Vec2.from(event.clientX, event.clientY), dragStartState.client);\n    const position = Vec2.add(dragStartState.position, offset4);\n    const bounds = this.ctx.domManager.getBoundingClientRect();\n    const partialPosition = {};\n    if (position.x >= bounds.x && position.x + popover.offsetWidth <= bounds.width) {\n      partialPosition.x = position.x;\n    }\n    if (position.y >= bounds.y && position.y + popover.offsetHeight <= bounds.height) {\n      partialPosition.y = position.y;\n    }\n    this.updatePosition(partialPosition);\n  }\n  onDragEnd() {\n    this.dragStartState = void 0;\n  }\n};\n\n// packages/ag-charts-community/src/components/toolbar/toolbarButtonProperties.ts\nvar ToolbarButtonProperties = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ToolbarButtonProperties.prototype, \"icon\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ToolbarButtonProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ToolbarButtonProperties.prototype, \"ariaLabel\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ToolbarButtonProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/components/toolbar/toolbarButtonWidget.ts\nvar ToolbarButtonWidget = class extends ButtonWidget {\n  constructor(localeManager) {\n    super();\n    this.localeManager = localeManager;\n  }\n  update(options) {\n    const { localeManager } = this;\n    if (options.tooltip) {\n      this.elem.title = localeManager.t(options.tooltip);\n    }\n    let innerHTML = \"\";\n    if (options.icon != null) {\n      innerHTML = `<span class=\"${getIconClassNames(options.icon)} ag-charts-toolbar__icon\"></span>`;\n    }\n    if (options.label != null) {\n      const label = localeManager.t(options.label);\n      innerHTML = `${innerHTML}<span class=\"ag-charts-toolbar__label\">${label}</span>`;\n    }\n    this.elem.innerHTML = innerHTML;\n  }\n  setChecked(checked) {\n    setAttribute(this.elem, \"aria-checked\", checked);\n  }\n};\n\n// packages/ag-charts-community/src/components/toolbar/toolbar.ts\nvar BUTTON_ACTIVE_CLASS = \"ag-charts-toolbar__button--active\";\nvar BaseToolbar = class extends ToolbarWidget {\n  constructor(localeManager, orientation = \"horizontal\") {\n    super(orientation);\n    this.localeManager = localeManager;\n    this.horizontalSpacing = 10;\n    this.verticalSpacing = 10;\n    this.events = new Listeners();\n    this.hasPrefix = false;\n    this.buttonWidgets = [];\n    this.addClass(\"ag-charts-toolbar\");\n    this.toggleClass(\"ag-charts-toolbar--horizontal\", orientation === \"horizontal\");\n    this.toggleClass(\"ag-charts-toolbar--vertical\", orientation === \"vertical\");\n  }\n  addToolbarListener(eventType, handler) {\n    return this.events.addListener(eventType, handler);\n  }\n  clearButtons() {\n    for (const button of this.buttonWidgets) {\n      button.destroy();\n    }\n    this.buttonWidgets.splice(0);\n  }\n  updateButtons(buttons) {\n    const { buttonWidgets } = this;\n    for (const [index, button] of buttons.entries()) {\n      const buttonWidget = this.buttonWidgets.at(index) ?? this.createButton(index, button);\n      buttonWidget.update(button);\n    }\n    for (let index = buttons.length; index < buttonWidgets.length; index++) {\n      const button = this.buttonWidgets.at(index);\n      button?.destroy();\n    }\n    this.buttonWidgets.splice(buttons.length);\n    this.refreshButtonClasses();\n  }\n  updateButtonByIndex(index, button) {\n    this.buttonWidgets.at(index)?.update(button);\n  }\n  clearActiveButton() {\n    for (const button of this.buttonWidgets) {\n      button.toggleClass(BUTTON_ACTIVE_CLASS, false);\n    }\n  }\n  toggleActiveButtonByIndex(index) {\n    if (index === -1)\n      return;\n    for (const [buttonIndex, button] of this.buttonWidgets.entries()) {\n      button.toggleClass(BUTTON_ACTIVE_CLASS, index != null && index === buttonIndex);\n    }\n  }\n  toggleButtonEnabledByIndex(index, enabled) {\n    if (index === -1)\n      return;\n    this.buttonWidgets.at(index)?.setEnabled(enabled);\n  }\n  toggleSwitchCheckedByIndex(index, checked) {\n    if (index === -1)\n      return;\n    this.buttonWidgets.at(index)?.setChecked(checked);\n  }\n  getButtonBounds() {\n    return this.buttonWidgets.map((buttonWidget) => this.getButtonWidgetBounds(buttonWidget));\n  }\n  setButtonHiddenByIndex(index, hidden) {\n    this.buttonWidgets.at(index)?.setHidden(hidden);\n  }\n  getButtonWidgetBounds(buttonWidget) {\n    const parent = this.getBounds();\n    const bounds = buttonWidget.getBounds();\n    return new BBox(bounds.x + parent.x, bounds.y + parent.y, bounds.width, bounds.height);\n  }\n  refreshButtonClasses() {\n    const { buttonWidgets, hasPrefix } = this;\n    let first2;\n    let last;\n    let section;\n    for (const [index, buttonWidget] of buttonWidgets.entries()) {\n      first2 = !hasPrefix && index === 0 || section != buttonWidget.section;\n      last = index === buttonWidgets.length - 1 || buttonWidget.section != buttonWidgets.at(index + 1)?.section;\n      buttonWidget.toggleClass(\"ag-charts-toolbar__button--first\", first2);\n      buttonWidget.toggleClass(\"ag-charts-toolbar__button--last\", last);\n      buttonWidget.toggleClass(\"ag-charts-toolbar__button--gap\", index > 0 && first2);\n      section = buttonWidget.section;\n    }\n  }\n  createButton(index, button) {\n    const buttonWidget = this.createButtonWidget();\n    buttonWidget.addClass(\"ag-charts-toolbar__button\");\n    buttonWidget.addListener(\"click\", (event) => {\n      const buttonOptions = { index, ...button instanceof BaseProperties ? button.toJson() : button };\n      const buttonBounds = this.getButtonWidgetBounds(buttonWidget);\n      this.events.dispatch(\"button-pressed\", { event, button: buttonOptions, buttonBounds });\n    });\n    buttonWidget.addListener(\"focus\", () => {\n      this.events.dispatch(\"button-focused\", { button: { index } });\n    });\n    if (button.section) {\n      buttonWidget.section = button.section;\n    }\n    this.buttonWidgets.push(buttonWidget);\n    this.addChild(buttonWidget);\n    return buttonWidget;\n  }\n};\nvar Toolbar = class extends BaseToolbar {\n  createButtonWidget() {\n    return new ToolbarButtonWidget(this.localeManager);\n  }\n};\n\n// packages/ag-charts-community/src/components/toolbar/floatingToolbar.ts\nvar FloatingToolbarPopover = class extends DraggablePopover {\n  constructor(ctx, id, onPopoverMoved) {\n    super(ctx, id);\n    this.onPopoverMoved = onPopoverMoved;\n    this.dragHandleDraggingClass = \"ag-charts-floating-toolbar__drag-handle--dragging\";\n  }\n  show(children, options = {}) {\n    this.showWithChildren(children, {\n      ...options,\n      class: \"ag-charts-floating-toolbar\"\n    });\n  }\n  hide() {\n    this.dragged = false;\n    super.hide();\n  }\n  getBounds() {\n    const element2 = this.getPopoverElement();\n    return new BBox(\n      element2?.offsetLeft ?? 0,\n      element2?.offsetTop ?? 0,\n      element2?.offsetWidth ?? 0,\n      element2?.offsetHeight ?? 0\n    );\n  }\n  hasBeenDragged() {\n    return this.dragged;\n  }\n  setAnchor(anchor, horizontalSpacing, verticalSpacing) {\n    const element2 = this.getPopoverElement();\n    if (!element2)\n      return;\n    const position = anchor.position ?? \"above\";\n    const { offsetWidth: width2, offsetHeight: height2 } = element2;\n    let top = anchor.y - height2 - verticalSpacing;\n    let left = anchor.x - width2 / 2;\n    if (position === \"below\") {\n      top = anchor.y + verticalSpacing;\n    } else if (position === \"right\") {\n      top = anchor.y - height2 / 2;\n      left = anchor.x + horizontalSpacing;\n    } else if (position === \"above-left\") {\n      left = anchor.x;\n    }\n    this.updatePosition({ x: left, y: top });\n  }\n  ignorePointerEvents() {\n    const element2 = this.getPopoverElement();\n    if (element2)\n      element2.style.pointerEvents = \"none\";\n  }\n  capturePointerEvents() {\n    const element2 = this.getPopoverElement();\n    if (element2)\n      element2.style.pointerEvents = \"unset\";\n  }\n  updatePosition(position) {\n    const bounds = this.getBounds();\n    const canvasRect = this.ctx.domManager.getBoundingClientRect();\n    position.x = Math.floor(clamp(0, position.x, canvasRect.width - bounds.width));\n    position.y = Math.floor(clamp(0, position.y, canvasRect.height - bounds.height));\n    super.updatePosition(position);\n    this.onPopoverMoved();\n  }\n};\nvar FloatingToolbar = class extends BaseToolbar {\n  constructor(ctx, id) {\n    super(ctx.localeManager);\n    this.hasPrefix = true;\n    this.popover = new FloatingToolbarPopover(ctx, id, this.onPopoverMoved.bind(this));\n    this.dragHandle = new DragHandleWidget(ctx.localeManager.t(\"toolbarAnnotationsDragHandle\"));\n    this.popover.setDragHandle(this.dragHandle);\n  }\n  show(options = {}) {\n    this.popover.show([this.dragHandle.getElement(), this.getElement()], options);\n  }\n  hide() {\n    this.popover.hide();\n  }\n  setAnchor(anchor) {\n    this.popover.setAnchor(anchor, this.horizontalSpacing, this.verticalSpacing);\n  }\n  hasBeenDragged() {\n    return this.popover.hasBeenDragged();\n  }\n  ignorePointerEvents() {\n    this.popover.ignorePointerEvents();\n  }\n  capturePointerEvents() {\n    this.popover.capturePointerEvents();\n  }\n  onPopoverMoved() {\n    const popoverBounds = this.popover.getBounds();\n    if (this.popoverBounds?.equals(popoverBounds))\n      return;\n    this.popoverBounds = popoverBounds.clone();\n    const buttonBounds = this.getButtonBounds();\n    this.events.dispatch(\"toolbar-moved\", { popoverBounds, buttonBounds });\n  }\n  getButtonWidgetBounds(buttonWidget) {\n    const popoverBounds = this.popover.getBounds();\n    const bounds = super.getButtonWidgetBounds(buttonWidget);\n    const dragHandleBounds = this.dragHandle.getBounds();\n    return new BBox(\n      bounds.x + popoverBounds.x - dragHandleBounds.width,\n      bounds.y + popoverBounds.y,\n      bounds.width,\n      bounds.height\n    );\n  }\n};\nvar DragHandleWidget = class extends NativeWidget {\n  constructor(title) {\n    super(createElement(\"div\", \"ag-charts-floating-toolbar__drag-handle\"));\n    const icon = new NativeWidget(\n      createElement(\"span\", `${getIconClassNames(\"drag-handle\")} ag-charts-toolbar__icon`)\n    );\n    icon.setAriaHidden(true);\n    this.addChild(icon);\n    this.elem.title = title;\n  }\n};\n\n// packages/ag-charts-community/src/module-support.ts\nvar motion = { ...fromToMotion_exports, ...resetMotion_exports };\n\n// packages/ag-charts-community/src/main.ts\nvar AgChartsCommunityModule = {\n  VERSION,\n  _Scene: integrated_charts_scene_exports,\n  _Theme: integrated_charts_theme_exports,\n  _Util: integrated_charts_util_exports,\n  create: AgCharts.create.bind(AgCharts),\n  createSparkline: AgCharts.__createSparkline.bind(AgCharts),\n  setup: registerInbuiltModules,\n  isEnterprise: false\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWctY2hhcnRzLWNvbW11bml0eS9kaXN0L3BhY2thZ2UvbWFpbi5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFlBQVksTUFBTTtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxrQ0FBa0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUNBQXlDLFFBQVEsZ0JBQWdCLE9BQU8sYUFBYSxFQUFFLFVBQVU7QUFDL0c7QUFDQSxZQUFZLG1CQUFtQixFQUFFLGFBQWEsRUFBRSxVQUFVO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEIsUUFBUSwwQkFBMEI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNEVBQTRFO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUssR0FBRyxJQUFJO0FBQzVCO0FBQ0EscUJBQXFCLEtBQUssR0FBRyxJQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixzQkFBc0IscUZBQXFGO0FBQzNHO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxLQUFLO0FBQ0w7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVksWUFBWTtBQUM3RCxvQ0FBb0MsS0FBSztBQUN6QyxZQUFZLFFBQVEscUJBQXFCLHNCQUFzQixJQUFJLFVBQVU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdDQUFnQyxFQUFFLElBQUk7QUFDakU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUssTUFBTSxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsTUFBTTtBQUNyRSxvRkFBb0YsU0FBUztBQUM3RjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVSxHQUFHLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1Q0FBdUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUJBQXVCO0FBQ2pDLG1CQUFtQjtBQUNuQjtBQUNBLFlBQVksNkNBQTZDO0FBQ3pEO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQ0FBc0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1Q0FBdUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1RUFBdUU7QUFDakYseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUSxFQUFFLFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxJQUFJO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUMsaUNBQWlDLFNBQVMsRUFBRSxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsSUFBSTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EseURBQXlELElBQUk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywyQ0FBMkMsSUFBSTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLLEVBQUUsNkNBQTZDLEVBQUUsNkNBQTZDO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUMsRUFBRSxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTiwwQkFBMEIsZUFBZSxFQUFFLHdCQUF3QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RUFBd0U7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1DQUFtQztBQUM1RDtBQUNBO0FBQ0EseUJBQXlCLHFDQUFxQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtDQUFrQztBQUMzRDtBQUNBO0FBQ0EseUJBQXlCLDhCQUE4QjtBQUN2RDtBQUNBO0FBQ0EseUJBQXlCLG1DQUFtQztBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUVBQXlFO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDaEQ7QUFDQTtBQUNBLFlBQVksZ0NBQWdDLEVBQUUsVUFBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtCQUErQjtBQUN6QztBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQkFBc0IsZUFBZTtB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QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2Q0FBNkM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxhQUFhO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxL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QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQ0FBcUM7QUFDL0MsVUFBVSxxQkFBcUI7QUFDL0IsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0g7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxZQUFZLHFDQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvREFBb0Q7QUFDaEUsMERBQTBELGVBQWU7QUFDekUsMkRBQTJELGVBQWU7QUFDMUUsMkRBQTJELGVBQWU7QUFDMUUseURBQXlELGVBQWU7QUFDeEUsMERBQTBELGVBQWU7QUFDekUsdURBQXVELGVBQWU7QUFDdEUsbURBQW1ELGVBQWU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0RBQW9EO0FBQ2hFLDZEQUE2RCxlQUFlO0FBQzVFLDhEQUE4RCxlQUFlO0FBQzdFLDhEQUE4RCxlQUFlO0FBQzdFLDREQUE0RCxlQUFlO0FBQzNFLDZEQUE2RCxlQUFlO0FBQzVFLDBEQUEwRCxlQUFlO0FBQ3pFLHNEQUFzRCxlQUFlO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQSw2REFBNkQsd0NBQXdDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFLDBEQUEwRCxnQkFBZ0I7QUFDMUUsNkRBQTZELGdCQUFnQjtBQUM3RSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDLHNEQUFzRCxnQkFBZ0I7QUFDdEUsc0RBQXNELGdCQUFnQjtBQUN0RSxvREFBb0QsZ0JBQWdCO0FBQ3BFLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9DQUFvQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUscUJBQXFCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQsVUFBVSxPQUFPO0FBQ2pCLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVSxxQkFBcUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZ0JBQWdCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrQkFBK0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFD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QTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGVBQWU7QUFDbEYscUVBQXFFLGVBQWU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWSx3Q0FBd0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQSxZQUFZLGlEQUFpRDtBQUM3RDtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwwQkFBMEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsZUFBZTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBCQUEwQjtBQUNwQyxVQUFVLDBCQUEwQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsV0FBVztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QkFBcUI7QUFDcEYsc0RBQXNELG9DQUFvQztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCLFFBQVEsZ0JBQWdCO0FBQ3hCLFFBQVEsa0JBQWtCO0FBQzFCLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUSxvQkFBb0I7QUFDNUIsUUFBUSxrQkFBa0I7QUFDMUIsUUFBUSxnQkFBZ0I7QUFDeEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDLGdDQUFnQyxtQ0FBbUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFVBQVUsa0JBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFFBQVEscUJBQXFCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVcsOEJBQThCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsa0JBQWtCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQ0FBMkM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxRkFBcUY7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QixvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNDQUFzQztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzQkFBc0IsVUFBVSxvQkFBb0I7QUFDbkYsSUFBSTtBQUNKLCtCQUErQixzQkFBc0IsVUFBVSxvQkFBb0I7QUFDbkY7QUFDQSwrQkFBK0Isc0JBQXNCLFVBQVUsb0JBQW9CO0FBQ25GO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQsMkJBQTJCLHdCQUF3QixJQUFJLFFBQVE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw4QkFBOEIsc0JBQXNCLFlBQVksOEJBQThCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNCQUFzQixXQUFXLE9BQU87QUFDdEU7QUFDQTtBQUNBLDhCQUE4QixzQkFBc0IsVUFBVSw0QkFBNEI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdCQUF3QixzQkFBc0IsWUFBWSxlQUFlO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDhEQUE4RDtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEtBQUssTUFBTSxJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0MsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLCtEQUErRCxzQkFBc0IsSUFBSSxLQUFLO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0IsU0FBUyxTQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUErRDtBQUMzRSxZQUFZLHlEQUF5RDtBQUNyRSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVEQUF1RDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5Q0FBeUM7QUFDekQsb0VBQW9FLG1EQUFtRCxJQUFJO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sb0NBQW9DLHNDQUFzQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQkFBK0I7QUFDdkMsUUFBUSwwQkFBMEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekMsb0NBQW9DLE1BQU07QUFDMUM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNDQUFzQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNDQUFzQztBQUNsRCwwQ0FBMEMsc0VBQXNFO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZDQUE2QztBQUM1RDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0VBQXNFO0FBQzFHO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQSxZQUFZLGdDQUFnQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSxrQ0FBa0MsMEJBQTBCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzQ0FBc0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUNBQXVDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUE4QztBQUMxRCxZQUFZLGdEQUFnRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkNBQTJDLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFFQUFxRTtBQUNqRixZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0EsNEVBQTRFLDJCQUEyQjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUNBQXVDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQ0FBcUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQThEO0FBQzFFLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0EsNkVBQTZFLFdBQVc7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0RBQW9EO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsVUFBVSxFQUFFLFVBQVU7QUFDbkY7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsVUFBVSxFQUFFLFVBQVU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVSxRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDLG9DQUFvQyxPQUFPO0FBQzNDLHNDQUFzQyxXQUFXO0FBQ2pELHVDQUF1QyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUNBQW1DO0FBQzFEO0FBQ0E7QUFDQSx1QkFBdUIseUNBQXlDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQ0FBc0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsNENBQTRDO0FBQzFGLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBc0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUNBQWlDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0VB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0RBQXdEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVDQUF1QztBQUNuRCxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNB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WUFBWSx3Q0FBd0M7QUFDcEQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUZBQWlGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQ0FBbUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0NBQWtDO0FBQzVGO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDRCQUE0QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtDQUFrQztBQUN4RCxhQUFhO0FBQ2IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSw0QkFBNEI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCLGdCQUFnQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixHQUFHO0FBQ2xDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFZLFdBQVc7QUFDdkIsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxtREFBbUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sY0FBYztBQUNwQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjLElBQUksY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0EsWUFBWSx1Q0FBdUM7QUFDbkQsMkJBQTJCLDhCQUE4QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5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O0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixTQUFTO0FBQ1Q7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0QkFBNEIsSUFBSTtBQUMzRDtBQUNBO0FBQ0EscURBQXFELG1CQUFtQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0Msa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBLHVDQUF1Qyx5QkFBeUI7QUFDaEU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDZCQUE2Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0RBQStEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJCQUEyQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3QkFBd0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscURBQXFELGlDQUFpQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLDhDQUE4QyxpQ0FBaUM7QUFDL0UsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdDQUF3QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzR0FBc0c7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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cUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVMsUUFBUSxtQ0FBbUM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUNBQW1DLDRCQUE0QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDZCQUE2QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtDQUFrQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFlRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxNdWtlc2gua2FzaW1haGFudGhpXFxEZXNrdG9wXFx2aXN1bGl6YXRpb25cXGFpQWdlbnRGcm9udGVuZENvZGVcXG5vZGVfbW9kdWxlc1xcYWctY2hhcnRzLWNvbW11bml0eVxcZGlzdFxccGFja2FnZVxcbWFpbi5lc20ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19kZWNvcmF0ZUNsYXNzID0gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBraW5kKSA9PiB7XG4gIHZhciByZXN1bHQgPSBraW5kID4gMSA/IHZvaWQgMCA6IGtpbmQgPyBfX2dldE93blByb3BEZXNjKHRhcmdldCwga2V5KSA6IHRhcmdldDtcbiAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMSwgZGVjb3JhdG9yOyBpID49IDA7IGktLSlcbiAgICBpZiAoZGVjb3JhdG9yID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgIHJlc3VsdCA9IChraW5kID8gZGVjb3JhdG9yKHRhcmdldCwga2V5LCByZXN1bHQpIDogZGVjb3JhdG9yKHJlc3VsdCkpIHx8IHJlc3VsdDtcbiAgaWYgKGtpbmQgJiYgcmVzdWx0KVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb3JlL3NyYy9nbG9iYWxzL2xvZ2dlci50c1xudmFyIGxvZ2dlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChsb2dnZXJfZXhwb3J0cywge1xuICBlcnJvcjogKCkgPT4gZXJyb3IsXG4gIGVycm9yT25jZTogKCkgPT4gZXJyb3JPbmNlLFxuICBsb2c6ICgpID0+IGxvZyxcbiAgbG9nR3JvdXA6ICgpID0+IGxvZ0dyb3VwLFxuICByZXNldDogKCkgPT4gcmVzZXQsXG4gIHRhYmxlOiAoKSA9PiB0YWJsZSxcbiAgd2FybjogKCkgPT4gd2FybixcbiAgd2Fybk9uY2U6ICgpID0+IHdhcm5PbmNlXG59KTtcbnZhciBkb09uY2VDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5mdW5jdGlvbiBsb2coLi4ubG9nQ29udGVudCkge1xuICBjb25zb2xlLmxvZyguLi5sb2dDb250ZW50KTtcbn1cbmZ1bmN0aW9uIHdhcm4obWVzc2FnZSwgLi4ubG9nQ29udGVudCkge1xuICBjb25zb2xlLndhcm4oYEFHIENoYXJ0cyAtICR7bWVzc2FnZX1gLCAuLi5sb2dDb250ZW50KTtcbn1cbmZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIC4uLmxvZ0NvbnRlbnQpIHtcbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc29sZS5lcnJvcihgQUcgQ2hhcnRzIGVycm9yYCwgbWVzc2FnZSwgLi4ubG9nQ29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcihgQUcgQ2hhcnRzIC0gJHttZXNzYWdlfWAsIC4uLmxvZ0NvbnRlbnQpO1xuICB9XG59XG5mdW5jdGlvbiB0YWJsZSguLi5sb2dDb250ZW50KSB7XG4gIGNvbnNvbGUudGFibGUoLi4ubG9nQ29udGVudCk7XG59XG5mdW5jdGlvbiB3YXJuT25jZShtZXNzYWdlLCAuLi5sb2dDb250ZW50KSB7XG4gIGNvbnN0IGNhY2hlS2V5ID0gYExvZ2dlci53YXJuOiAke21lc3NhZ2V9YDtcbiAgaWYgKGRvT25jZUNhY2hlLmhhcyhjYWNoZUtleSkpXG4gICAgcmV0dXJuO1xuICB3YXJuKG1lc3NhZ2UsIC4uLmxvZ0NvbnRlbnQpO1xuICBkb09uY2VDYWNoZS5hZGQoY2FjaGVLZXkpO1xufVxuZnVuY3Rpb24gZXJyb3JPbmNlKG1lc3NhZ2UsIC4uLmxvZ0NvbnRlbnQpIHtcbiAgY29uc3QgY2FjaGVLZXkgPSBgTG9nZ2VyLmVycm9yOiAke21lc3NhZ2V9YDtcbiAgaWYgKGRvT25jZUNhY2hlLmhhcyhjYWNoZUtleSkpXG4gICAgcmV0dXJuO1xuICBlcnJvcihtZXNzYWdlLCAuLi5sb2dDb250ZW50KTtcbiAgZG9PbmNlQ2FjaGUuYWRkKGNhY2hlS2V5KTtcbn1cbmZ1bmN0aW9uIHJlc2V0KCkge1xuICBkb09uY2VDYWNoZS5jbGVhcigpO1xufVxuZnVuY3Rpb24gbG9nR3JvdXAobmFtZSwgY2IpIHtcbiAgY29uc29sZS5ncm91cENvbGxhcHNlZChuYW1lKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY2IoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvcmUvc3JjL2dsb2JhbHMvbW9kdWxlUmVnaXN0cnkudHNcbnZhciBNb2R1bGVSZWdpc3RyeSA9IGNsYXNzIHtcbiAgc3RhdGljIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyZWRNb2R1bGVzLnZhbHVlcygpO1xuICB9XG4gIHN0YXRpYyByZWdpc3RlcihkZWZpbml0aW9uKSB7XG4gICAgY29uc3QgZXhpc3RpbmdEZWZpbml0aW9uID0gdGhpcy5yZWdpc3RlcmVkTW9kdWxlcy5nZXQoZGVmaW5pdGlvbi5uYW1lKTtcbiAgICBpZiAoZXhpc3RpbmdEZWZpbml0aW9uICYmIChleGlzdGluZ0RlZmluaXRpb24uZW50ZXJwcmlzZSB8fCAhZGVmaW5pdGlvbi5lbnRlcnByaXNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBNb2R1bGUgJyR7ZGVmaW5pdGlvbi5uYW1lfScgYWxyZWFkeSByZWdpc3RlcmVkYCk7XG4gICAgfVxuICAgIHRoaXMucmVnaXN0ZXJlZE1vZHVsZXMuc2V0KGRlZmluaXRpb24ubmFtZSwgZGVmaW5pdGlvbik7XG4gIH1cbiAgc3RhdGljIHJlZ2lzdGVyTWFueShkZWZpbml0aW9ucykge1xuICAgIGZvciAoY29uc3QgZGVmaW5pdGlvbiBvZiBkZWZpbml0aW9ucykge1xuICAgICAgdGhpcy5yZWdpc3RlcihkZWZpbml0aW9uKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHJlc2V0KCkge1xuICAgIHRoaXMucmVnaXN0ZXJlZE1vZHVsZXMuY2xlYXIoKTtcbiAgfVxuICBzdGF0aWMgZGV0ZWN0Q2hhcnREZWZpbml0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5kZXRlY3REZWZpbml0aW9uKFwiY2hhcnRcIiAvKiBDaGFydCAqLywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGRldGVjdFNlcmllc0RlZmluaXRpb24ob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmRldGVjdERlZmluaXRpb24oXCJzZXJpZXNcIiAvKiBTZXJpZXMgKi8sIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBkZXRlY3REZWZpbml0aW9uKG1vZHVsZVR5cGUsIG9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGRlZmluaXRpb24gb2YgdGhpcy5yZWdpc3RlcmVkTW9kdWxlcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGRlZmluaXRpb24udHlwZSA9PT0gbW9kdWxlVHlwZSAmJiBkZWZpbml0aW9uLmRldGVjdChvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEFHIENoYXJ0cyAtIFVua25vd24gJHttb2R1bGVUeXBlfSB0eXBlOyBDaGVjayBvcHRpb25zIGFyZSBjb3JyZWN0bHkgc3RydWN0dXJlZCBhbmQgc2VyaWVzIHR5cGVzIGFyZSBzcGVjaWZpZWRgXG4gICAgKTtcbiAgfVxufTtcbk1vZHVsZVJlZ2lzdHJ5LnJlZ2lzdGVyZWRNb2R1bGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvcmUvc3JjL2NsYXNzZXMvZXZlbnRFbWl0dGVyLnRzXG52YXIgRXZlbnRFbWl0dGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lci5cbiAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBsaXN0ZW4gZm9yLlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gdGhlIGV2ZW50LlxuICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRvIHVucmVnaXN0ZXIgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5ldmVudHMuaGFzKGV2ZW50TmFtZSkpIHtcbiAgICAgIHRoaXMuZXZlbnRzLnNldChldmVudE5hbWUsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50cy5nZXQoZXZlbnROYW1lKT8uYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIHN0b3AgbGlzdGVuaW5nIGZvci5cbiAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBiZSByZW1vdmVkLlxuICAgKi9cbiAgb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBldmVudExpc3RlbmVycyA9IHRoaXMuZXZlbnRzLmdldChldmVudE5hbWUpO1xuICAgIGlmIChldmVudExpc3RlbmVycykge1xuICAgICAgZXZlbnRMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIGlmIChldmVudExpc3RlbmVycy5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzLmRlbGV0ZShldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQgdG8gYWxsIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBlbWl0LlxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHBheWxvYWQuXG4gICAqL1xuICBlbWl0KGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICB0aGlzLmV2ZW50cy5nZXQoZXZlbnROYW1lKT8uZm9yRWFjaCgoY2FsbGJhY2syKSA9PiBjYWxsYmFjazIoZXZlbnQpKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBsaXN0ZW5lcnMgZm9yIGEgc3BlY2lmaWMgZXZlbnQgb3IgYWxsIGV2ZW50cyBpZiBubyBldmVudCBuYW1lIGlzIHByb3ZpZGVkLlxuICAgKiBAcGFyYW0gZXZlbnROYW1lIChPcHRpb25hbCkgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGNsZWFyIGxpc3RlbmVycyBmb3IuIElmIG5vdCBwcm92aWRlZCwgYWxsIGxpc3RlbmVycyBmb3IgYWxsIGV2ZW50cyBhcmUgY2xlYXJlZC5cbiAgICovXG4gIGNsZWFyKGV2ZW50TmFtZSkge1xuICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgIHRoaXMuZXZlbnRzLmRlbGV0ZShldmVudE5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV2ZW50cy5jbGVhcigpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvcmUvc3JjL3V0aWxzL2FycmF5cy50c1xuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn1cbmZ1bmN0aW9uIHVuaXF1ZShhcnJheTIpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChhcnJheTIpKTtcbn1cbmZ1bmN0aW9uIGdyb3VwQnkoYXJyYXkyLCBpdGVyYXRlZSkge1xuICByZXR1cm4gYXJyYXkyLnJlZHVjZSgocmVzdWx0LCBpdGVtKSA9PiB7XG4gICAgY29uc3QgZ3JvdXBLZXkgPSBpdGVyYXRlZShpdGVtKTtcbiAgICByZXN1bHRbZ3JvdXBLZXldID8/IChyZXN1bHRbZ3JvdXBLZXldID0gW10pO1xuICAgIHJlc3VsdFtncm91cEtleV0ucHVzaChpdGVtKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBhcnJheXNFcXVhbChhLCBiKSB7XG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsIHx8IGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhW2ldKSAmJiBBcnJheS5pc0FycmF5KGJbaV0pKSB7XG4gICAgICBpZiAoIWFycmF5c0VxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjaXJjdWxhclNsaWNlQXJyYXkoZGF0YSwgc2l6ZSwgb2Zmc2V0NCA9IDApIHtcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIHJlc3VsdC5wdXNoKGRhdGEuYXQoKGkgKyBvZmZzZXQ0KSAlIGRhdGEubGVuZ3RoKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNvcnRCYXNlZE9uQXJyYXkoYmFzZUFycmF5LCBvcmRlckFycmF5KSB7XG4gIGNvbnN0IG9yZGVyTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgb3JkZXJBcnJheS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgIG9yZGVyTWFwLnNldChpdGVtLCBpbmRleCk7XG4gIH0pO1xuICByZXR1cm4gYmFzZUFycmF5LnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCBpbmRleEEgPSBvcmRlck1hcC5nZXQoYSkgPz8gSW5maW5pdHk7XG4gICAgY29uc3QgaW5kZXhCID0gb3JkZXJNYXAuZ2V0KGIpID8/IEluZmluaXR5O1xuICAgIHJldHVybiBpbmRleEEgLSBpbmRleEI7XG4gIH0pO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29yZS9zcmMvdXRpbHMvYmluYXJ5U2VhcmNoLnRzXG5mdW5jdGlvbiBmaW5kTWF4SW5kZXgobWluLCBtYXgsIGl0ZXJhdGVlKSB7XG4gIGlmIChtaW4gPiBtYXgpXG4gICAgcmV0dXJuO1xuICBsZXQgZm91bmQ7XG4gIHdoaWxlIChtYXggPj0gbWluKSB7XG4gICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKChtYXggKyBtaW4pIC8gMik7XG4gICAgY29uc3QgdmFsdWUgPSBpdGVyYXRlZShpbmRleCk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBmb3VuZCA9IGluZGV4O1xuICAgICAgbWluID0gaW5kZXggKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXggPSBpbmRleCAtIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGZpbmRNaW5JbmRleChtaW4sIG1heCwgaXRlcmF0ZWUpIHtcbiAgaWYgKG1pbiA+IG1heClcbiAgICByZXR1cm47XG4gIGxldCBmb3VuZDtcbiAgd2hpbGUgKG1heCA+PSBtaW4pIHtcbiAgICBjb25zdCBpbmRleCA9IE1hdGguZmxvb3IoKG1heCArIG1pbikgLyAyKTtcbiAgICBjb25zdCB2YWx1ZSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGZvdW5kID0gaW5kZXg7XG4gICAgICBtYXggPSBpbmRleCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbiA9IGluZGV4ICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gZmluZE1pblZhbHVlKG1pbiwgbWF4LCBpdGVyYXRlZSkge1xuICBpZiAobWluID4gbWF4KVxuICAgIHJldHVybjtcbiAgbGV0IGZvdW5kO1xuICB3aGlsZSAobWF4ID49IG1pbikge1xuICAgIGNvbnN0IGluZGV4ID0gTWF0aC5mbG9vcigobWF4ICsgbWluKSAvIDIpO1xuICAgIGNvbnN0IHZhbHVlID0gaXRlcmF0ZWUoaW5kZXgpO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBtaW4gPSBpbmRleCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvdW5kID0gdmFsdWU7XG4gICAgICBtYXggPSBpbmRleCAtIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3VuZDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvcmUvc3JjL3V0aWxzL2RpZmYudHNcbmZ1bmN0aW9uIGRpZmZBcnJheXMocHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KHByZXZpb3VzLmxlbmd0aCwgY3VycmVudC5sZW5ndGgpO1xuICBjb25zdCBhZGRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHJlbW92ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGNvbnN0IHByZXYgPSBwcmV2aW91c1tpXTtcbiAgICBjb25zdCBjdXJyID0gY3VycmVudFtpXTtcbiAgICBpZiAocHJldiA9PT0gY3VycilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChyZW1vdmVkLmhhcyhjdXJyKSkge1xuICAgICAgcmVtb3ZlZC5kZWxldGUoY3Vycik7XG4gICAgfSBlbHNlIGlmIChjdXJyKSB7XG4gICAgICBhZGRlZC5hZGQoY3Vycik7XG4gICAgfVxuICAgIGlmIChhZGRlZC5oYXMocHJldikpIHtcbiAgICAgIGFkZGVkLmRlbGV0ZShwcmV2KTtcbiAgICB9IGVsc2UgaWYgKHByZXYpIHtcbiAgICAgIHJlbW92ZWQuYWRkKHByZXYpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBjaGFuZ2VkOiBhZGRlZC5zaXplID4gMCB8fCByZW1vdmVkLnNpemUgPiAwLCBhZGRlZCwgcmVtb3ZlZCB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29yZS9zcmMvdXRpbHMvZnVuY3Rpb25zLnRzXG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjazIsIHdhaXRNcywgb3B0aW9ucykge1xuICBjb25zdCB7IGxlYWRpbmcgPSB0cnVlLCB0cmFpbGluZyA9IHRydWUgfSA9IG9wdGlvbnMgPz8ge307XG4gIGxldCB0aW1lcklkO1xuICBsZXQgbGFzdEFyZ3M7XG4gIGxldCBzaG91bGRXYWl0ID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHRpbWVvdXRIYW5kbGVyKCkge1xuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZW91dEhhbmRsZXIsIHdhaXRNcyk7XG4gICAgICBjYWxsYmFjazIoLi4ubGFzdEFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRXYWl0ID0gZmFsc2U7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiB0aHJvdHRsZUNhbGxiYWNrKC4uLmFyZ3MpIHtcbiAgICBpZiAoc2hvdWxkV2FpdCkge1xuICAgICAgbGFzdEFyZ3MgPSBhcmdzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRXYWl0ID0gdHJ1ZTtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVvdXRIYW5kbGVyLCB3YWl0TXMpO1xuICAgICAgaWYgKGxlYWRpbmcpIHtcbiAgICAgICAgY2FsbGJhY2syKC4uLmFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdEFyZ3MgPSBhcmdzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0aHJvdHRsZUNhbGxiYWNrLCB7XG4gICAgY2FuY2VsKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgc2hvdWxkV2FpdCA9IGZhbHNlO1xuICAgICAgbGFzdEFyZ3MgPSBudWxsO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb3JlL3NyYy91dGlscy9pdGVyYXRvcnMudHNcbmZ1bmN0aW9uKiBpdGVyYXRlKC4uLml0ZXJhdG9ycykge1xuICBmb3IgKGNvbnN0IGl0ZXJhdG9yIG9mIGl0ZXJhdG9ycykge1xuICAgIHlpZWxkKiBpdGVyYXRvcjtcbiAgfVxufVxuZnVuY3Rpb24gdG9JdGVyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuZnVuY3Rpb24gZmlyc3QoaXRlcmFibGUpIHtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBubyBmaXJzdCgpIHZhbHVlIGZvdW5kXCIpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29yZS9zcmMvdXRpbHMvc3RyaW5ncy50c1xuZnVuY3Rpb24gam9pbkZvcm1hdHRlZCh2YWx1ZXMsIGNvbmp1bmN0aW9uID0gXCJhbmRcIiwgZm9ybWF0ID0gU3RyaW5nLCBtYXhJdGVtcyA9IEluZmluaXR5KSB7XG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh2YWx1ZXNbMF0pO1xuICB9XG4gIHZhbHVlcyA9IHZhbHVlcy5tYXAoZm9ybWF0KTtcbiAgY29uc3QgbGFzdFZhbHVlID0gdmFsdWVzLnBvcCgpO1xuICBpZiAodmFsdWVzLmxlbmd0aCA+PSBtYXhJdGVtcykge1xuICAgIGNvbnN0IHJlbWFpbmluZ0NvdW50ID0gdmFsdWVzLmxlbmd0aCAtIChtYXhJdGVtcyAtIDEpO1xuICAgIHJldHVybiBgJHt2YWx1ZXMuc2xpY2UoMCwgbWF4SXRlbXMgLSAxKS5qb2luKFwiLCBcIil9LCBhbmQgJHtyZW1haW5pbmdDb3VudH0gbW9yZSAke2Nvbmp1bmN0aW9ufSAke2xhc3RWYWx1ZX1gO1xuICB9XG4gIHJldHVybiBgJHt2YWx1ZXMuam9pbihcIiwgXCIpfSAke2Nvbmp1bmN0aW9ufSAke2xhc3RWYWx1ZX1gO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5VmFsdWUodmFsdWUsIG1heExlbmd0aCA9IEluZmluaXR5KSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gXCJOYU5cIjtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBcIkluZmluaXR5XCI7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIFwiLUluZmluaXR5XCI7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICByZXR1cm4gYCR7dmFsdWUuc2xpY2UoMCwgbWF4TGVuZ3RoKX0uLi4gKCske3ZhbHVlLmxlbmd0aCAtIG1heExlbmd0aH0gY2hhcmFjdGVycylgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBjb3VudExpbmVzKHRleHQyKSB7XG4gIGxldCBjb3VudCA9IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dDIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGV4dDIuY2hhckNvZGVBdChpKSA9PT0gMTApIHtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvcmUvc3JjL3V0aWxzL3R5cGVHdWFyZHMudHNcbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPSBudWxsO1xufVxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWREYXRlKHZhbHVlKSB7XG4gIHJldHVybiBpc0RhdGUodmFsdWUpICYmICFpc05hTihOdW1iZXIodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhaXNBcnJheSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gaXNGaW5pdGVOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0h0bWxFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc0VudW1WYWx1ZShlbnVtT2JqZWN0LCBlbnVtVmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZW51bU9iamVjdCkuaW5jbHVkZXMoZW51bVZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3ltYm9sXCI7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb3JlL3NyYy91dGlscy92YWxpZGF0aW9uLnRzXG52YXIgZGVzY3JpcHRpb25TeW1ib2wgPSBTeW1ib2woXCJkZXNjcmlwdGlvblwiKTtcbnZhciByZXF1aXJlZFN5bWJvbCA9IFN5bWJvbChcInJlcXVpcmVkXCIpO1xuZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucywgb3B0aW9uc0RlZnMsIHBhdGggPSBcIlwiKSB7XG4gIGlmICghaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsaWQ6IG51bGwsXG4gICAgICBlcnJvcnM6IFt7IHBhdGgsIHZhbHVlOiBvcHRpb25zLCBtZXNzYWdlOiB2YWxpZGF0ZU1lc3NhZ2UocGF0aCwgb3B0aW9ucywgXCJhbiBvYmplY3RcIikgfV1cbiAgICB9O1xuICB9XG4gIGNvbnN0IG9wdGlvbnNLZXlzID0gbmV3IFNldChPYmplY3Qua2V5cyhvcHRpb25zKSk7XG4gIGNvbnN0IGVycm9ycyA9IFtdO1xuICBjb25zdCB2YWxpZCA9IHt9O1xuICBmdW5jdGlvbiBleHRlbmRQYXRoKGtleSkge1xuICAgIGlmIChpc0FycmF5KG9wdGlvbnNEZWZzKSkge1xuICAgICAgcmV0dXJuIGAke3BhdGh9WyR7a2V5fV1gO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aCA/IGAke3BhdGh9LiR7a2V5fWAgOiBrZXk7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCB2YWxpZGF0b3JPckRlZnNdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnNEZWZzKSkge1xuICAgIG9wdGlvbnNLZXlzLmRlbGV0ZShrZXkpO1xuICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1trZXldO1xuICAgIGlmICghdmFsaWRhdG9yT3JEZWZzW3JlcXVpcmVkU3ltYm9sXSAmJiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0b3JPckRlZnMpKSB7XG4gICAgICBpZiAodmFsaWRhdG9yT3JEZWZzKHZhbHVlLCBvcHRpb25zKSkge1xuICAgICAgICB2YWxpZFtrZXldID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcnMucHVzaCh7IGtleSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IHZhbGlkYXRlTWVzc2FnZShleHRlbmRQYXRoKGtleSksIHZhbHVlLCB2YWxpZGF0b3JPckRlZnMpIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXN0ZWRSZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgdmFsaWRhdG9yT3JEZWZzLCBleHRlbmRQYXRoKGtleSkpO1xuICAgICAgdmFsaWRba2V5XSA9IG5lc3RlZFJlc3VsdC52YWxpZDtcbiAgICAgIGVycm9ycy5wdXNoKC4uLm5lc3RlZFJlc3VsdC5lcnJvcnMpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBvcHRpb25zS2V5cykge1xuICAgIGVycm9ycy5wdXNoKHtcbiAgICAgIGtleSxcbiAgICAgIHBhdGgsXG4gICAgICB1bmtub3duOiB0cnVlLFxuICAgICAgbWVzc2FnZTogYFVua25vd24gb3B0aW9uIFxcYCR7ZXh0ZW5kUGF0aChrZXkpfVxcYCwgaWdub3JpbmcuYFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7IHZhbGlkLCBlcnJvcnMgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZShwYXRoLCB2YWx1ZSwgdmFsaWRhdG9yT3JEZWZzKSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gaXNTdHJpbmcodmFsaWRhdG9yT3JEZWZzKSA/IHZhbGlkYXRvck9yRGVmcyA6IHZhbGlkYXRvck9yRGVmc1tkZXNjcmlwdGlvblN5bWJvbF07XG4gIGNvbnN0IGV4cGVjdGluZyA9IGRlc2NyaXB0aW9uID8gYDsgZXhwZWN0aW5nICR7ZGVzY3JpcHRpb259YCA6IFwiXCI7XG4gIGNvbnN0IHByZWZpeCA9IHBhdGggPyBgT3B0aW9uIFxcYCR7cGF0aH1cXGBgIDogXCJWYWx1ZVwiO1xuICByZXR1cm4gYCR7cHJlZml4fSBjYW5ub3QgYmUgc2V0IHRvIFxcYCR7c3RyaW5naWZ5VmFsdWUodmFsdWUpfVxcYCR7ZXhwZWN0aW5nfSwgaWdub3JpbmcuYDtcbn1cbmZ1bmN0aW9uIGF0dGFjaERlc2NyaXB0aW9uKHZhbGlkYXRvciwgZGVzY3JpcHRpb24pIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oKHZhbHVlLCBjb250ZXh0KSA9PiB2YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpLCB7XG4gICAgW2Rlc2NyaXB0aW9uU3ltYm9sXTogZGVzY3JpcHRpb25cbiAgfSk7XG59XG52YXIgYW5kID0gKC4uLnZhbGlkYXRvcnMpID0+IGF0dGFjaERlc2NyaXB0aW9uKFxuICAodmFsdWUsIGNvbnRleHQpID0+IHZhbGlkYXRvcnMuZXZlcnkoKHZhbGlkYXRvcikgPT4gdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KSksXG4gIHZhbGlkYXRvcnMubWFwKCh2KSA9PiB2W2Rlc2NyaXB0aW9uU3ltYm9sXSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgYW5kIFwiKVxuKTtcbnZhciBvciA9ICguLi52YWxpZGF0b3JzKSA9PiBhdHRhY2hEZXNjcmlwdGlvbihcbiAgKHZhbHVlLCBjb250ZXh0KSA9PiB2YWxpZGF0b3JzLnNvbWUoKHZhbGlkYXRvcikgPT4gdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KSksXG4gIHZhbGlkYXRvcnMubWFwKCh2KSA9PiB2W2Rlc2NyaXB0aW9uU3ltYm9sXSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgb3IgXCIpXG4pO1xudmFyIGFycmF5ID0gYXR0YWNoRGVzY3JpcHRpb24oaXNBcnJheSwgXCJhbiBhcnJheVwiKTtcbnZhciBib29sZWFuID0gYXR0YWNoRGVzY3JpcHRpb24oaXNCb29sZWFuLCBcImEgYm9vbGVhblwiKTtcbnZhciBjYWxsYmFjayA9IGF0dGFjaERlc2NyaXB0aW9uKGlzRnVuY3Rpb24sIFwiYSBmdW5jdGlvblwiKTtcbnZhciBudW1iZXIgPSBhdHRhY2hEZXNjcmlwdGlvbihpc0Zpbml0ZU51bWJlciwgXCJhIG51bWJlclwiKTtcbnZhciBvYmplY3QgPSBhdHRhY2hEZXNjcmlwdGlvbihpc09iamVjdCwgXCJhbiBvYmplY3RcIik7XG52YXIgc3RyaW5nID0gYXR0YWNoRGVzY3JpcHRpb24oaXNTdHJpbmcsIFwiYSBzdHJpbmdcIik7XG52YXIgZGF0ZSA9IGF0dGFjaERlc2NyaXB0aW9uKFxuICAodmFsdWUpID0+IGlzRGF0ZSh2YWx1ZSkgfHwgKGlzRmluaXRlTnVtYmVyKHZhbHVlKSB8fCBpc1N0cmluZyh2YWx1ZSkpICYmIGlzVmFsaWREYXRlKG5ldyBEYXRlKHZhbHVlKSksXG4gIFwiYSBkYXRlXCJcbik7XG52YXIgbnVtYmVyTWluID0gKG1pbiwgaW5jbHVzaXZlID0gdHJ1ZSkgPT4gYXR0YWNoRGVzY3JpcHRpb24oXG4gICh2YWx1ZSkgPT4gaXNGaW5pdGVOdW1iZXIodmFsdWUpICYmICh2YWx1ZSA+IG1pbiB8fCBpbmNsdXNpdmUgJiYgdmFsdWUgPT09IG1pbiksXG4gIGBhIG51bWJlciBncmVhdGVyIHRoYW4gJHtpbmNsdXNpdmUgPyBcIm9yIGVxdWFsIHRvIFwiIDogXCJcIn0ke21pbn1gXG4pO1xudmFyIG51bWJlclJhbmdlID0gKG1pbiwgbWF4KSA9PiBhdHRhY2hEZXNjcmlwdGlvbihcbiAgKHZhbHVlKSA9PiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkgJiYgdmFsdWUgPj0gbWluICYmIHZhbHVlIDw9IG1heCxcbiAgYGEgbnVtYmVyIGJldHdlZW4gJHttaW59IGFuZCAke21heH0gaW5jbHVzaXZlYFxuKTtcbnZhciBwb3NpdGl2ZU51bWJlciA9IG51bWJlck1pbigwKTtcbnZhciByYXRpbyA9IG51bWJlclJhbmdlKDAsIDEpO1xudmFyIGlzQ29tcGFyYWJsZSA9ICh2YWx1ZSkgPT4gaXNGaW5pdGVOdW1iZXIodmFsdWUpIHx8IGlzVmFsaWREYXRlKHZhbHVlKTtcbnZhciBsZXNzVGhhbiA9IChvdGhlckZpZWxkKSA9PiBhdHRhY2hEZXNjcmlwdGlvbihcbiAgKHZhbHVlLCBjb250ZXh0KSA9PiAhaXNDb21wYXJhYmxlKHZhbHVlKSB8fCAhaXNDb21wYXJhYmxlKGNvbnRleHRbb3RoZXJGaWVsZF0pIHx8IHZhbHVlIDwgY29udGV4dFtvdGhlckZpZWxkXSxcbiAgYHRvIGJlIGxlc3MgdGhhbiAke290aGVyRmllbGR9YFxuKTtcbmZ1bmN0aW9uIHVuaW9uKC4uLmFsbG93ZWQpIHtcbiAgaWYgKGlzT2JqZWN0KGFsbG93ZWRbMF0pKSB7XG4gICAgYWxsb3dlZCA9IE9iamVjdC52YWx1ZXMoYWxsb3dlZFswXSk7XG4gIH1cbiAgY29uc3Qga2V5d29yZHMgPSBqb2luRm9ybWF0dGVkKGFsbG93ZWQsIFwib3JcIiwgKHZhbHVlKSA9PiBgJyR7dmFsdWV9J2AsIDYpO1xuICByZXR1cm4gYXR0YWNoRGVzY3JpcHRpb24oKHZhbHVlKSA9PiBhbGxvd2VkLmluY2x1ZGVzKHZhbHVlKSwgYGEga2V5d29yZCBzdWNoIGFzICR7a2V5d29yZHN9YCk7XG59XG52YXIgYXJyYXlPZiA9ICh2YWxpZGF0b3IsIGRlc2NyaXB0aW9uKSA9PiBhdHRhY2hEZXNjcmlwdGlvbihcbiAgKHZhbHVlLCBjb250ZXh0KSA9PiBpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeSgodikgPT4gdmFsaWRhdG9yKHYsIGNvbnRleHQpKSxcbiAgZGVzY3JpcHRpb24gPz8gYCR7dmFsaWRhdG9yW2Rlc2NyaXB0aW9uU3ltYm9sXX0gYXJyYXlgXG4pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb3Rpb24vZnJvbVRvTW90aW9uLnRzXG52YXIgZnJvbVRvTW90aW9uX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGZyb21Ub01vdGlvbl9leHBvcnRzLCB7XG4gIE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkc6ICgpID0+IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkcsXG4gIGZyb21Ub01vdGlvbjogKCkgPT4gZnJvbVRvTW90aW9uLFxuICBzdGF0aWNGcm9tVG9Nb3Rpb246ICgpID0+IHN0YXRpY0Zyb21Ub01vdGlvblxufSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NvcmUvZ2xvYmFsc1Byb3h5LnRzXG52YXIgdmVyaWZpZWRHbG9iYWxzID0ge307XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2ZXJpZmllZEdsb2JhbHMud2luZG93ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHZlcmlmaWVkR2xvYmFscy53aW5kb3cgPSBnbG9iYWwud2luZG93O1xufVxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2ZXJpZmllZEdsb2JhbHMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2ZXJpZmllZEdsb2JhbHMuZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudChwcm9wZXJ0eU5hbWUpIHtcbiAgcmV0dXJuIHByb3BlcnR5TmFtZSA/IHZlcmlmaWVkR2xvYmFscy5kb2N1bWVudD8uW3Byb3BlcnR5TmFtZV0gOiB2ZXJpZmllZEdsb2JhbHMuZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3cocHJvcGVydHlOYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0eU5hbWUgPyB2ZXJpZmllZEdsb2JhbHMud2luZG93Py5bcHJvcGVydHlOYW1lXSA6IHZlcmlmaWVkR2xvYmFscy53aW5kb3c7XG59XG5mdW5jdGlvbiBzZXREb2N1bWVudChkb2N1bWVudDIpIHtcbiAgdmVyaWZpZWRHbG9iYWxzLmRvY3VtZW50ID0gZG9jdW1lbnQyO1xufVxuZnVuY3Rpb24gc2V0V2luZG93KHdpbmRvdzIpIHtcbiAgdmVyaWZpZWRHbG9iYWxzLndpbmRvdyA9IHdpbmRvdzI7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NvcmUvZG9tRWxlbWVudHMudHNcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgY2xhc3NOYW1lLCBzdHlsZSkge1xuICBjb25zdCBlbGVtZW50MiA9IGdldERvY3VtZW50KCkuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHR5cGVvZiBjbGFzc05hbWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICBzdHlsZSA9IGNsYXNzTmFtZTtcbiAgICBjbGFzc05hbWUgPSB2b2lkIDA7XG4gIH1cbiAgaWYgKGNsYXNzTmFtZSkge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBjbGFzc05hbWUuc3BsaXQoXCIgXCIpKSB7XG4gICAgICBlbGVtZW50Mi5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgIH1cbiAgfVxuICBpZiAoc3R5bGUpIHtcbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQyLnN0eWxlLCBzdHlsZSk7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQyO1xufVxuZnVuY3Rpb24gY3JlYXRlU3ZnRWxlbWVudChlbGVtZW50TmFtZSkge1xuICByZXR1cm4gZ2V0RG9jdW1lbnQoKS5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBlbGVtZW50TmFtZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NvcmUvZG9tRG93bmxvYWQudHNcbmZ1bmN0aW9uIGRvd25sb2FkVXJsKGRhdGFVcmwsIGZpbGVOYW1lKSB7XG4gIGNvbnN0IGJvZHkgPSBnZXREb2N1bWVudChcImJvZHlcIik7XG4gIGNvbnN0IGVsZW1lbnQyID0gY3JlYXRlRWxlbWVudChcImFcIiwgeyBkaXNwbGF5OiBcIm5vbmVcIiB9KTtcbiAgZWxlbWVudDIuaHJlZiA9IGRhdGFVcmw7XG4gIGVsZW1lbnQyLmRvd25sb2FkID0gZmlsZU5hbWU7XG4gIGJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudDIpO1xuICBlbGVtZW50Mi5jbGljaygpO1xuICBzZXRUaW1lb3V0KCgpID0+IGJvZHkucmVtb3ZlQ2hpbGQoZWxlbWVudDIpKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9pZC50c1xudmFyIElEX01BUCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiByZXNldElkcygpIHtcbiAgSURfTUFQLmNsZWFyKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVJZChpbnN0YW5jZSkge1xuICBjb25zdCBjb25zdHJ1Y3RvciA9IGluc3RhbmNlLmNvbnN0cnVjdG9yO1xuICBjb25zdCBjbGFzc05hbWUgPSBPYmplY3QuaGFzT3duKGNvbnN0cnVjdG9yLCBcImNsYXNzTmFtZVwiKSA/IGNvbnN0cnVjdG9yLmNsYXNzTmFtZSA6IGNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmICghY2xhc3NOYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJHtjb25zdHJ1Y3Rvcn0gaXMgbWlzc2luZyB0aGUgJ2NsYXNzTmFtZScgcHJvcGVydHkuYCk7XG4gIH1cbiAgY29uc3QgbmV4dElkID0gKElEX01BUC5nZXQoY2xhc3NOYW1lKSA/PyAwKSArIDE7XG4gIElEX01BUC5zZXQoY2xhc3NOYW1lLCBuZXh0SWQpO1xuICByZXR1cm4gYCR7Y2xhc3NOYW1lfS0ke25leHRJZH1gO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCkge1xuICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQ/LigpID8/IGdlbmVyYXRlVVVJRHY0KCk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUR2NCgpIHtcbiAgY29uc3QgdXVpZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHV1aWRBcnJheSk7XG4gIHV1aWRBcnJheVs2XSA9IHV1aWRBcnJheVs2XSAmIDE1IHwgNjQ7XG4gIHV1aWRBcnJheVs4XSA9IHV1aWRBcnJheVs4XSAmIDYzIHwgMTI4O1xuICBsZXQgdXVpZCA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdXVpZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IDQgfHwgaSA9PT0gNiB8fCBpID09PSA4IHx8IGkgPT09IDEwKSB7XG4gICAgICB1dWlkICs9IFwiLVwiO1xuICAgIH1cbiAgICB1dWlkICs9IHV1aWRBcnJheVtpXS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xuICB9XG4gIHJldHVybiB1dWlkO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2Jib3hpbnRlcmZhY2UudHNcbnZhciBCQm94VmFsdWVzID0geyBjb250YWluc1BvaW50LCBpc0VtcHR5LCBub3JtYWxpemUgfTtcbmZ1bmN0aW9uIGNvbnRhaW5zUG9pbnQoYmJveCwgeCwgeSkge1xuICByZXR1cm4geCA+PSBiYm94LnggJiYgeCA8PSBiYm94LnggKyBiYm94LndpZHRoICYmIHkgPj0gYmJveC55ICYmIHkgPD0gYmJveC55ICsgYmJveC5oZWlnaHQ7XG59XG5mdW5jdGlvbiBpc0VtcHR5KGJib3gpIHtcbiAgcmV0dXJuIGJib3ggPT0gbnVsbCB8fCBiYm94LmhlaWdodCA9PT0gMCB8fCBiYm94LndpZHRoID09PSAwIHx8IGlzTmFOKGJib3guaGVpZ2h0KSB8fCBpc05hTihiYm94LndpZHRoKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShiYm94KSB7XG4gIGxldCB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gYmJveDtcbiAgaWYgKCh3aWR0aDIgPT0gbnVsbCB8fCB3aWR0aDIgPiAwKSAmJiAoaGVpZ2h0MiA9PSBudWxsIHx8IGhlaWdodDIgPiAwKSlcbiAgICByZXR1cm4gYmJveDtcbiAgaWYgKHggIT0gbnVsbCAmJiB3aWR0aDIgIT0gbnVsbCAmJiB3aWR0aDIgPCAwKSB7XG4gICAgd2lkdGgyID0gLXdpZHRoMjtcbiAgICB4ID0geCAtIHdpZHRoMjtcbiAgfVxuICBpZiAoeSAhPSBudWxsICYmIGhlaWdodDIgIT0gbnVsbCAmJiBoZWlnaHQyIDwgMCkge1xuICAgIGhlaWdodDIgPSAtaGVpZ2h0MjtcbiAgICB5ID0geSAtIGhlaWdodDI7XG4gIH1cbiAgcmV0dXJuIHsgeCwgeSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvaW50ZXJwb2xhdGluZy50c1xudmFyIGludGVycG9sYXRlID0gU3ltYm9sKFwiaW50ZXJwb2xhdGVcIik7XG52YXIgaXNJbnRlcnBvbGF0aW5nID0gKHgpID0+IHhbaW50ZXJwb2xhdGVdICE9IG51bGw7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvbmVhcmVzdC50c1xuZnVuY3Rpb24gbmVhcmVzdFNxdWFyZWQoeCwgeSwgb2JqZWN0cywgbWF4RGlzdGFuY2VTcXVhcmVkID0gSW5maW5pdHkpIHtcbiAgY29uc3QgcmVzdWx0ID0geyBuZWFyZXN0OiB2b2lkIDAsIGRpc3RhbmNlU3F1YXJlZDogbWF4RGlzdGFuY2VTcXVhcmVkIH07XG4gIGZvciAoY29uc3Qgb2JqIG9mIG9iamVjdHMpIHtcbiAgICBjb25zdCB0aGlzRGlzdGFuY2UgPSBvYmouZGlzdGFuY2VTcXVhcmVkKHgsIHkpO1xuICAgIGlmICh0aGlzRGlzdGFuY2UgPT09IDApIHtcbiAgICAgIHJldHVybiB7IG5lYXJlc3Q6IG9iaiwgZGlzdGFuY2VTcXVhcmVkOiAwIH07XG4gICAgfSBlbHNlIGlmICh0aGlzRGlzdGFuY2UgPCByZXN1bHQuZGlzdGFuY2VTcXVhcmVkKSB7XG4gICAgICByZXN1bHQubmVhcmVzdCA9IG9iajtcbiAgICAgIHJlc3VsdC5kaXN0YW5jZVNxdWFyZWQgPSB0aGlzRGlzdGFuY2U7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBuZWFyZXN0U3F1YXJlZEluQ29udGFpbmVyKHgsIHksIGNvbnRhaW5lciwgbWF4RGlzdGFuY2VTcXVhcmVkID0gSW5maW5pdHkpIHtcbiAgY29uc3QgeyB4OiB0eCA9IHgsIHk6IHR5ID0geSB9ID0gY29udGFpbmVyLnRyYW5zZm9ybVBvaW50Py4oeCwgeSkgPz8ge307XG4gIGNvbnN0IHJlc3VsdCA9IHsgbmVhcmVzdDogdm9pZCAwLCBkaXN0YW5jZVNxdWFyZWQ6IG1heERpc3RhbmNlU3F1YXJlZCB9O1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNvbnRhaW5lci5jaGlsZHJlbikge1xuICAgIGNvbnN0IHsgbmVhcmVzdCwgZGlzdGFuY2VTcXVhcmVkOiBkaXN0YW5jZVNxdWFyZWQyIH0gPSBjaGlsZC5uZWFyZXN0U3F1YXJlZCh0eCwgdHksIHJlc3VsdC5kaXN0YW5jZVNxdWFyZWQpO1xuICAgIGlmIChkaXN0YW5jZVNxdWFyZWQyID09PSAwKSB7XG4gICAgICByZXR1cm4geyBuZWFyZXN0LCBkaXN0YW5jZVNxdWFyZWQ6IGRpc3RhbmNlU3F1YXJlZDIgfTtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlU3F1YXJlZDIgPCByZXN1bHQuZGlzdGFuY2VTcXVhcmVkKSB7XG4gICAgICByZXN1bHQubmVhcmVzdCA9IG5lYXJlc3Q7XG4gICAgICByZXN1bHQuZGlzdGFuY2VTcXVhcmVkID0gZGlzdGFuY2VTcXVhcmVkMjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9udW1iZXIudHNcbmZ1bmN0aW9uIGNsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xuICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBjbGFtcEFycmF5KHZhbHVlLCBhcnJheTIpIHtcbiAgY29uc3QgW21pbiwgbWF4XSA9IGZpbmRNaW5NYXgoYXJyYXkyKTtcbiAgcmV0dXJuIGNsYW1wKG1pbiwgdmFsdWUsIG1heCk7XG59XG5mdW5jdGlvbiBmaW5kTWluTWF4KGFycmF5Mikge1xuICBpZiAoYXJyYXkyLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IHJlc3VsdCA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgZm9yIChjb25zdCB2YWwgb2YgYXJyYXkyKSB7XG4gICAgaWYgKHZhbCA8IHJlc3VsdFswXSlcbiAgICAgIHJlc3VsdFswXSA9IHZhbDtcbiAgICBpZiAodmFsID4gcmVzdWx0WzFdKVxuICAgICAgcmVzdWx0WzFdID0gdmFsO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaW5kUmFuZ2VFeHRlbnQoYXJyYXkyKSB7XG4gIGNvbnN0IFttaW4sIG1heF0gPSBmaW5kTWluTWF4KGFycmF5Mik7XG4gIHJldHVybiBtYXggLSBtaW47XG59XG5mdW5jdGlvbiBpblJhbmdlKHZhbHVlLCByYW5nZTMsIGVwc2lsb24yID0gMWUtMTApIHtcbiAgcmV0dXJuIHZhbHVlID49IHJhbmdlM1swXSAtIGVwc2lsb24yICYmIHZhbHVlIDw9IHJhbmdlM1sxXSArIGVwc2lsb24yO1xufVxuZnVuY3Rpb24gaXNOdW1iZXJFcXVhbChhLCBiLCBlcHNpbG9uMiA9IDFlLTEwKSB7XG4gIHJldHVybiBhID09PSBiIHx8IE1hdGguYWJzKGEgLSBiKSA8IGVwc2lsb24yO1xufVxuZnVuY3Rpb24gaXNOZWdhdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5zaWduKHZhbHVlKSA9PT0gLTEgfHwgT2JqZWN0LmlzKHZhbHVlLCAtMCk7XG59XG5mdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICUgMSA9PT0gMDtcbn1cbmZ1bmN0aW9uIHJvdW5kKHZhbHVlLCBkZWNpbWFscyA9IDIpIHtcbiAgY29uc3QgYmFzZSA9IDEwICoqIGRlY2ltYWxzO1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIGJhc2UpIC8gYmFzZTtcbn1cbmZ1bmN0aW9uIG1vZChuLCBtKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKG4gJSBtICsgKG4gPCAwID8gbSA6IDApKTtcbn1cbmZ1bmN0aW9uIGNvdW50RnJhY3Rpb25EaWdpdHModmFsdWUpIHtcbiAgaWYgKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSlcbiAgICByZXR1cm4gMDtcbiAgbGV0IHZhbHVlU3RyaW5nID0gU3RyaW5nKHZhbHVlKTtcbiAgbGV0IGV4cG9uZW50ID0gMDtcbiAgaWYgKHZhbHVlIDwgMWUtNiB8fCB2YWx1ZSA+PSAxZTIxKSB7XG4gICAgbGV0IGV4cG9uZW50U3RyaW5nO1xuICAgIFt2YWx1ZVN0cmluZywgZXhwb25lbnRTdHJpbmddID0gdmFsdWVTdHJpbmcuc3BsaXQoXCJlXCIpO1xuICAgIGlmIChleHBvbmVudFN0cmluZyAhPSBudWxsKSB7XG4gICAgICBleHBvbmVudCA9IE51bWJlcihleHBvbmVudFN0cmluZyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRlY2ltYWxQbGFjZXMyID0gdmFsdWVTdHJpbmcuc3BsaXQoXCIuXCIpWzFdPy5sZW5ndGggPz8gMDtcbiAgcmV0dXJuIE1hdGgubWF4KGRlY2ltYWxQbGFjZXMyIC0gZXhwb25lbnQsIDApO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9iYm94LnRzXG52YXIgX0JCb3ggPSBjbGFzcyBfQkJveCB7XG4gIGNvbnN0cnVjdG9yKHgsIHksIHdpZHRoMiwgaGVpZ2h0Mikge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGgyO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0MjtcbiAgfVxuICBzdGF0aWMgZnJvbURPTVJlY3QoeyB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSkge1xuICAgIHJldHVybiBuZXcgX0JCb3goeCwgeSwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgfVxuICBzdGF0aWMgbWVyZ2UoYm94ZXMpIHtcbiAgICBsZXQgbGVmdCA9IEluZmluaXR5O1xuICAgIGxldCB0b3AgPSBJbmZpbml0eTtcbiAgICBsZXQgcmlnaHQgPSAtSW5maW5pdHk7XG4gICAgbGV0IGJvdHRvbSA9IC1JbmZpbml0eTtcbiAgICBmb3IgKGNvbnN0IGJveCBvZiBib3hlcykge1xuICAgICAgaWYgKGJveC54IDwgbGVmdCkge1xuICAgICAgICBsZWZ0ID0gYm94Lng7XG4gICAgICB9XG4gICAgICBpZiAoYm94LnkgPCB0b3ApIHtcbiAgICAgICAgdG9wID0gYm94Lnk7XG4gICAgICB9XG4gICAgICBpZiAoYm94LnggKyBib3gud2lkdGggPiByaWdodCkge1xuICAgICAgICByaWdodCA9IGJveC54ICsgYm94LndpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGJveC55ICsgYm94LmhlaWdodCA+IGJvdHRvbSkge1xuICAgICAgICBib3R0b20gPSBib3gueSArIGJveC5oZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgX0JCb3gobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG4gIH1cbiAgc3RhdGljIG5lYXJlc3RCb3goeCwgeSwgYm94ZXMpIHtcbiAgICByZXR1cm4gbmVhcmVzdFNxdWFyZWQoeCwgeSwgYm94ZXMpO1xuICB9XG4gIHRvRE9NUmVjdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55LFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgdG9wOiB0aGlzLnksXG4gICAgICBsZWZ0OiB0aGlzLngsXG4gICAgICByaWdodDogdGhpcy54ICsgdGhpcy53aWR0aCxcbiAgICAgIGJvdHRvbTogdGhpcy55ICsgdGhpcy5oZWlnaHQsXG4gICAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSB0aGlzO1xuICAgIHJldHVybiBuZXcgX0JCb3goeCwgeSwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy54ID09PSBvdGhlci54ICYmIHRoaXMueSA9PT0gb3RoZXIueSAmJiB0aGlzLndpZHRoID09PSBvdGhlci53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gb3RoZXIuaGVpZ2h0O1xuICB9XG4gIGNvbnRhaW5zUG9pbnQoeCwgeSkge1xuICAgIHJldHVybiBCQm94VmFsdWVzLmNvbnRhaW5zUG9pbnQodGhpcywgeCwgeSk7XG4gIH1cbiAgaW50ZXJzZWN0aW9uKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmNvbGxpZGVzQkJveChvdGhlcikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbmV3WDEgPSBjbGFtcChvdGhlci54LCB0aGlzLngsIG90aGVyLnggKyBvdGhlci53aWR0aCk7XG4gICAgY29uc3QgbmV3WTEgPSBjbGFtcChvdGhlci55LCB0aGlzLnksIG90aGVyLnkgKyBvdGhlci5oZWlnaHQpO1xuICAgIGNvbnN0IG5ld1gyID0gY2xhbXAob3RoZXIueCwgdGhpcy54ICsgdGhpcy53aWR0aCwgb3RoZXIueCArIG90aGVyLndpZHRoKTtcbiAgICBjb25zdCBuZXdZMiA9IGNsYW1wKG90aGVyLnksIHRoaXMueSArIHRoaXMuaGVpZ2h0LCBvdGhlci55ICsgb3RoZXIuaGVpZ2h0KTtcbiAgICByZXR1cm4gbmV3IF9CQm94KG5ld1gxLCBuZXdZMSwgbmV3WDIgLSBuZXdYMSwgbmV3WTIgLSBuZXdZMSk7XG4gIH1cbiAgY29sbGlkZXNCQm94KG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMueCA8IG90aGVyLnggKyBvdGhlci53aWR0aCAmJiB0aGlzLnggKyB0aGlzLndpZHRoID4gb3RoZXIueCAmJiB0aGlzLnkgPCBvdGhlci55ICsgb3RoZXIuaGVpZ2h0ICYmIHRoaXMueSArIHRoaXMuaGVpZ2h0ID4gb3RoZXIueTtcbiAgfVxuICBjb21wdXRlQ2VudGVyKCkge1xuICAgIHJldHVybiB7IHg6IHRoaXMueCArIHRoaXMud2lkdGggLyAyLCB5OiB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDIgfTtcbiAgfVxuICBpc0Zpbml0ZSgpIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHRoaXMueCkgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMueSkgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMud2lkdGgpICYmIE51bWJlci5pc0Zpbml0ZSh0aGlzLmhlaWdodCk7XG4gIH1cbiAgZGlzdGFuY2VTcXVhcmVkKHgsIHkpIHtcbiAgICBpZiAodGhpcy5jb250YWluc1BvaW50KHgsIHkpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgZHggPSB4IC0gY2xhbXAodGhpcy54LCB4LCB0aGlzLnggKyB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBkeSA9IHkgLSBjbGFtcCh0aGlzLnksIHksIHRoaXMueSArIHRoaXMuaGVpZ2h0KTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gIH1cbiAgc2hyaW5rKGFtb3VudCwgcG9zaXRpb24pIHtcbiAgICBpZiAodHlwZW9mIGFtb3VudCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGhpcy5hcHBseU1hcmdpbihhbW91bnQsIHBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYW1vdW50KSkge1xuICAgICAgICB0aGlzLmFwcGx5TWFyZ2luKHZhbHVlLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy53aWR0aCA8IDApIHtcbiAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5oZWlnaHQgPCAwKSB7XG4gICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdyb3coYW1vdW50LCBwb3NpdGlvbikge1xuICAgIGlmICh0eXBlb2YgYW1vdW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0aGlzLmFwcGx5TWFyZ2luKC1hbW91bnQsIHBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYW1vdW50KSkge1xuICAgICAgICB0aGlzLmFwcGx5TWFyZ2luKC12YWx1ZSwga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXBwbHlNYXJnaW4odmFsdWUsIHBvc2l0aW9uKSB7XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICB0aGlzLnkgKz0gdmFsdWU7XG4gICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgIHRoaXMuaGVpZ2h0IC09IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgIHRoaXMueCArPSB2YWx1ZTtcbiAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICB0aGlzLndpZHRoIC09IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgICB0aGlzLnkgKz0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGVpZ2h0IC09IHZhbHVlICogMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOlxuICAgICAgICB0aGlzLnggKz0gdmFsdWU7XG4gICAgICAgIHRoaXMud2lkdGggLT0gdmFsdWUgKiAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgICB0aGlzLnggKz0gdmFsdWU7XG4gICAgICAgIHRoaXMueSArPSB2YWx1ZTtcbiAgICAgICAgdGhpcy53aWR0aCAtPSB2YWx1ZSAqIDI7XG4gICAgICAgIHRoaXMuaGVpZ2h0IC09IHZhbHVlICogMjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgdGhpcy54ICs9IHg7XG4gICAgdGhpcy55ICs9IHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgW2ludGVycG9sYXRlXShvdGhlciwgZCkge1xuICAgIHJldHVybiBuZXcgX0JCb3goXG4gICAgICB0aGlzLnggKiAoMSAtIGQpICsgb3RoZXIueCAqIGQsXG4gICAgICB0aGlzLnkgKiAoMSAtIGQpICsgb3RoZXIueSAqIGQsXG4gICAgICB0aGlzLndpZHRoICogKDEgLSBkKSArIG90aGVyLndpZHRoICogZCxcbiAgICAgIHRoaXMuaGVpZ2h0ICogKDEgLSBkKSArIG90aGVyLmhlaWdodCAqIGRcbiAgICApO1xuICB9XG59O1xuX0JCb3guemVybyA9IE9iamVjdC5mcmVlemUobmV3IF9CQm94KDAsIDAsIDAsIDApKTtcbl9CQm94Lk5hTiA9IE9iamVjdC5mcmVlemUobmV3IF9CQm94KE5hTiwgTmFOLCBOYU4sIE5hTikpO1xudmFyIEJCb3ggPSBfQkJveDtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvY2hhbmdlRGV0ZWN0YWJsZS50c1xuZnVuY3Rpb24gU2NlbmVDaGFuZ2VEZXRlY3Rpb24ob3B0cykge1xuICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gYF9fJHtrZXl9YDtcbiAgICBpZiAodGFyZ2V0W2tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJlcGFyZUdldFNldCh0YXJnZXQsIGtleSwgcHJpdmF0ZUtleSwgb3B0cyk7XG4gIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlR2V0U2V0KHRhcmdldCwga2V5LCBwcml2YXRlS2V5LCBvcHRzKSB7XG4gIGNvbnN0IHsgdHlwZSA9IFwibm9ybWFsXCIsIGNoYW5nZUNiLCBjb252ZXJ0b3IsIGNoZWNrRGlydHlPbkFzc2lnbm1lbnQgPSBmYWxzZSB9ID0gb3B0cyA/PyB7fTtcbiAgY29uc3QgcmVxdWlyZWRPcHRzID0geyB0eXBlLCBjaGFuZ2VDYiwgY2hlY2tEaXJ0eU9uQXNzaWdubWVudCwgY29udmVydG9yIH07XG4gIGxldCBzZXR0ZXI7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJub3JtYWxcIjpcbiAgICAgIHNldHRlciA9IGJ1aWxkTm9ybWFsU2V0dGVyKHByaXZhdGVLZXksIHJlcXVpcmVkT3B0cyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidHJhbnNmb3JtXCI6XG4gICAgICBzZXR0ZXIgPSBidWlsZFRyYW5zZm9ybVNldHRlcihwcml2YXRlS2V5KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJwYXRoXCI6XG4gICAgICBzZXR0ZXIgPSBidWlsZFBhdGhTZXR0ZXIocHJpdmF0ZUtleSk7XG4gICAgICBicmVhaztcbiAgfVxuICBzZXR0ZXIgPSBidWlsZENoZWNrRGlydHlDaGFpbihcbiAgICBidWlsZENoYW5nZUNhbGxiYWNrQ2hhaW4oYnVpbGRDb252ZXJ0b3JDaGFpbihzZXR0ZXIsIHJlcXVpcmVkT3B0cyksIHJlcXVpcmVkT3B0cyksXG4gICAgcmVxdWlyZWRPcHRzXG4gICk7XG4gIGNvbnN0IGdldHRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzW3ByaXZhdGVLZXldO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICBzZXQ6IHNldHRlcixcbiAgICBnZXQ6IGdldHRlcixcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ29udmVydG9yQ2hhaW4oc2V0dGVyRm4sIG9wdHMpIHtcbiAgY29uc3QgeyBjb252ZXJ0b3IgfSA9IG9wdHM7XG4gIGlmIChjb252ZXJ0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHNldHRlckZuLmNhbGwodGhpcywgY29udmVydG9yKHZhbHVlKSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gc2V0dGVyRm47XG59XG52YXIgTk9fQ0hBTkdFID0gU3ltYm9sKFwibm8tY2hhbmdlXCIpO1xuZnVuY3Rpb24gYnVpbGRDaGFuZ2VDYWxsYmFja0NoYWluKHNldHRlckZuLCBvcHRzKSB7XG4gIGNvbnN0IHsgY2hhbmdlQ2IgfSA9IG9wdHM7XG4gIGlmIChjaGFuZ2VDYikge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgY29uc3QgY2hhbmdlID0gc2V0dGVyRm4uY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICBpZiAoY2hhbmdlICE9PSBOT19DSEFOR0UpIHtcbiAgICAgICAgY2hhbmdlQ2IuY2FsbCh0aGlzLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gc2V0dGVyRm47XG59XG5mdW5jdGlvbiBidWlsZENoZWNrRGlydHlDaGFpbihzZXR0ZXJGbiwgb3B0cykge1xuICBjb25zdCB7IGNoZWNrRGlydHlPbkFzc2lnbm1lbnQgfSA9IG9wdHM7XG4gIGlmIChjaGVja0RpcnR5T25Bc3NpZ25tZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjb25zdCBjaGFuZ2UgPSBzZXR0ZXJGbi5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZT8uX2RpcnR5ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHNldHRlckZuO1xufVxuZnVuY3Rpb24gYnVpbGROb3JtYWxTZXR0ZXIocHJpdmF0ZUtleSwgb3B0cykge1xuICBjb25zdCB7IGNoYW5nZUNiIH0gPSBvcHRzO1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXNbcHJpdmF0ZUtleV07XG4gICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgdGhpc1twcml2YXRlS2V5XSA9IHZhbHVlO1xuICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgIGNoYW5nZUNiPy4odGhpcyk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBOT19DSEFOR0U7XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZFRyYW5zZm9ybVNldHRlcihwcml2YXRlS2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpc1twcml2YXRlS2V5XTtcbiAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICB0aGlzW3ByaXZhdGVLZXldID0gdmFsdWU7XG4gICAgICB0aGlzLm1hcmtEaXJ0eVRyYW5zZm9ybSgpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gTk9fQ0hBTkdFO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRQYXRoU2V0dGVyKHByaXZhdGVLZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzW3ByaXZhdGVLZXldO1xuICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgIHRoaXNbcHJpdmF0ZUtleV0gPSB2YWx1ZTtcbiAgICAgIGlmICghdGhpcy5fZGlydHlQYXRoKSB7XG4gICAgICAgIHRoaXMuX2RpcnR5UGF0aCA9IHRydWU7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBOT19DSEFOR0U7XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL25vZGUudHNcbnZhciBQb2ludGVyRXZlbnRzID0gLyogQF9fUFVSRV9fICovICgoUG9pbnRlckV2ZW50czIpID0+IHtcbiAgUG9pbnRlckV2ZW50czJbUG9pbnRlckV2ZW50czJbXCJBbGxcIl0gPSAwXSA9IFwiQWxsXCI7XG4gIFBvaW50ZXJFdmVudHMyW1BvaW50ZXJFdmVudHMyW1wiTm9uZVwiXSA9IDFdID0gXCJOb25lXCI7XG4gIHJldHVybiBQb2ludGVyRXZlbnRzMjtcbn0pKFBvaW50ZXJFdmVudHMgfHwge30pO1xudmFyIF9Ob2RlID0gY2xhc3MgX05vZGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgLyoqIFVuaXF1ZSBudW1iZXIgdG8gYWxsb3cgY3JlYXRpb24gb3JkZXIgdG8gYmUgZWFzaWx5IGRldGVybWluZWQuICovXG4gICAgdGhpcy5zZXJpYWxOdW1iZXIgPSBfTm9kZS5fbmV4dFNlcmlhbE51bWJlcisrO1xuICAgIHRoaXMuY2hpbGROb2RlQ291bnRzID0geyBncm91cHM6IDAsIG5vbkdyb3VwczogMCwgdGhpc0NvbXBsZXhpdHk6IDAsIGNvbXBsZXhpdHk6IDAgfTtcbiAgICAvKiogVW5pcXVlIG5vZGUgSUQgaW4gdGhlIGZvcm0gYENsYXNzTmFtZS1OYXR1cmFsTnVtYmVyYC4gKi9cbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5wb2ludGVyRXZlbnRzID0gMCAvKiBBbGwgKi87XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuZGlydHlaSW5kZXggPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUbyBzaW1wbGlmeSB0aGUgdHlwZSBzeXN0ZW0gKGVzcGVjaWFsbHkgaW4gU2VsZWN0aW9ucykgd2UgZG9uJ3QgaGF2ZSB0aGUgYFBhcmVudGAgbm9kZVxuICAgICAqIChvbmUgdGhhdCBoYXMgY2hpbGRyZW4pLiBJbnN0ZWFkLCB3ZSBtaW1pYyBIVE1MIERPTSwgd2hlcmUgYW55IG5vZGUgY2FuIGhhdmUgY2hpbGRyZW4uXG4gICAgICogQnV0IHdlIHN0aWxsIG5lZWQgdG8gZGlzdGluZ3Vpc2ggcmVndWxhciBsZWFmIG5vZGVzIGZyb20gY29udGFpbmVyIGxlYWZzIHNvbWVob3cuXG4gICAgICovXG4gICAgdGhpcy5pc0NvbnRhaW5lck5vZGUgPSBmYWxzZTtcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zPy5uYW1lO1xuICAgIHRoaXMudGFnID0gb3B0aW9ucz8udGFnID8/IE5hTjtcbiAgICB0aGlzLnpJbmRleCA9IG9wdGlvbnM/LnpJbmRleCA/PyAwO1xuICB9XG4gIHN0YXRpYyB0b1NWRyhub2RlLCB3aWR0aDIsIGhlaWdodDIpIHtcbiAgICBjb25zdCBzdmcgPSBub2RlPy50b1NWRygpO1xuICAgIGlmIChzdmcgPT0gbnVsbCB8fCAhc3ZnLmVsZW1lbnRzLmxlbmd0aCAmJiAhc3ZnLmRlZnM/Lmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByb290ID0gY3JlYXRlU3ZnRWxlbWVudChcInN2Z1wiKTtcbiAgICByb290LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFN0cmluZyh3aWR0aDIpKTtcbiAgICByb290LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBTdHJpbmcoaGVpZ2h0MikpO1xuICAgIHJvb3Quc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgMCAwICR7d2lkdGgyfSAke2hlaWdodDJ9YCk7XG4gICAgaWYgKHN2Zy5kZWZzPy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGRlZnMgPSBjcmVhdGVTdmdFbGVtZW50KFwiZGVmc1wiKTtcbiAgICAgIGRlZnMuYXBwZW5kKC4uLnN2Zy5kZWZzKTtcbiAgICAgIHJvb3QuYXBwZW5kKGRlZnMpO1xuICAgIH1cbiAgICByb290LmFwcGVuZCguLi5zdmcuZWxlbWVudHMpO1xuICAgIHJldHVybiByb290Lm91dGVySFRNTDtcbiAgfVxuICBzdGF0aWMgKmV4dHJhY3RCQm94ZXMobm9kZXMsIHNraXBJbnZpc2libGUpIHtcbiAgICBmb3IgKGNvbnN0IG4gb2Ygbm9kZXMpIHtcbiAgICAgIGlmICghc2tpcEludmlzaWJsZSB8fCBuLnZpc2libGUgJiYgIW4udHJhbnNpdGlvbk91dCkge1xuICAgICAgICBjb25zdCBiYm94ID0gbi5nZXRCQm94KCk7XG4gICAgICAgIGlmIChiYm94KVxuICAgICAgICAgIHlpZWxkIGJib3g7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTb21lIGFyYml0cmFyeSBkYXRhIGJvdW5kIHRvIHRoZSBub2RlLlxuICAgKi9cbiAgZ2V0IGRhdHVtKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXR1bSA/PyB0aGlzLnBhcmVudE5vZGU/LmRhdHVtO1xuICB9XG4gIHNldCBkYXR1bShkYXR1bSkge1xuICAgIGlmICh0aGlzLl9kYXR1bSAhPT0gZGF0dW0pIHtcbiAgICAgIHRoaXMuX3ByZXZpb3VzRGF0dW0gPSB0aGlzLl9kYXR1bTtcbiAgICAgIHRoaXMuX2RhdHVtID0gZGF0dW07XG4gICAgfVxuICB9XG4gIGdldCBwcmV2aW91c0RhdHVtKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0RhdHVtO1xuICB9XG4gIGdldCBsYXllck1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xheWVyTWFuYWdlcjtcbiAgfVxuICBnZXQgZGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcnR5O1xuICB9XG4gIC8qKiBQZXJmb3JtIGFueSBwcmUtcmVuZGVyaW5nIGluaXRpYWxpemF0aW9uLiAqL1xuICBwcmVSZW5kZXIocmVuZGVyQ3R4LCB0aGlzQ29tcGxleGl0eSA9IDEpIHtcbiAgICB0aGlzLmNoaWxkTm9kZUNvdW50cy5ncm91cHMgPSAwO1xuICAgIHRoaXMuY2hpbGROb2RlQ291bnRzLm5vbkdyb3VwcyA9IDE7XG4gICAgdGhpcy5jaGlsZE5vZGVDb3VudHMuY29tcGxleGl0eSA9IHRoaXNDb21wbGV4aXR5O1xuICAgIHRoaXMuY2hpbGROb2RlQ291bnRzLnRoaXNDb21wbGV4aXR5ID0gdGhpc0NvbXBsZXhpdHk7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKCkpIHtcbiAgICAgIGNvbnN0IGNoaWxkQ291bnRzID0gY2hpbGQucHJlUmVuZGVyKHJlbmRlckN0eCk7XG4gICAgICB0aGlzLmNoaWxkTm9kZUNvdW50cy5ncm91cHMgKz0gY2hpbGRDb3VudHMuZ3JvdXBzO1xuICAgICAgdGhpcy5jaGlsZE5vZGVDb3VudHMubm9uR3JvdXBzICs9IGNoaWxkQ291bnRzLm5vbkdyb3VwcztcbiAgICAgIHRoaXMuY2hpbGROb2RlQ291bnRzLmNvbXBsZXhpdHkgKz0gY2hpbGRDb3VudHMuY29tcGxleGl0eTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2hpbGROb2RlQ291bnRzO1xuICB9XG4gIHJlbmRlcihyZW5kZXJDdHgpIHtcbiAgICBjb25zdCB7IHN0YXRzIH0gPSByZW5kZXJDdHg7XG4gICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICBpZiAocmVuZGVyQ3R4LmRlYnVnTm9kZVNlYXJjaCkge1xuICAgICAgY29uc3QgaWRPck5hbWUgPSB0aGlzLm5hbWUgPz8gdGhpcy5pZDtcbiAgICAgIGlmIChyZW5kZXJDdHguZGVidWdOb2RlU2VhcmNoLnNvbWUoKHYpID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiID8gdiA9PT0gaWRPck5hbWUgOiB2LnRlc3QoaWRPck5hbWUpKSkge1xuICAgICAgICByZW5kZXJDdHguZGVidWdOb2Rlc1t0aGlzLm5hbWUgPz8gdGhpcy5pZF0gPSB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdHMpIHtcbiAgICAgIHN0YXRzLm5vZGVzUmVuZGVyZWQrKztcbiAgICAgIHN0YXRzLm9wc1BlcmZvcm1lZCArPSB0aGlzLmNoaWxkTm9kZUNvdW50cy50aGlzQ29tcGxleGl0eTtcbiAgICB9XG4gIH1cbiAgX3NldExheWVyTWFuYWdlcih2YWx1ZSkge1xuICAgIHRoaXMuX2xheWVyTWFuYWdlciA9IHZhbHVlO1xuICAgIHRoaXMuX2RlYnVnID0gdmFsdWU/LmRlYnVnO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbigpKSB7XG4gICAgICBjaGlsZC5fc2V0TGF5ZXJNYW5hZ2VyKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgc29ydENoaWxkcmVuKGNvbXBhcmVGbikge1xuICAgIHRoaXMuZGlydHlaSW5kZXggPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuY2hpbGROb2RlcylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzb3J0ZWRDaGlsZHJlbiA9IFsuLi50aGlzLmNoaWxkTm9kZXNdLnNvcnQoY29tcGFyZUZuKTtcbiAgICB0aGlzLmNoaWxkTm9kZXMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHNvcnRlZENoaWxkcmVuKSB7XG4gICAgICB0aGlzLmNoaWxkTm9kZXMuYWRkKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgKnRyYXZlcnNlVXAoaW5jbHVkZVNlbGYpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXM7XG4gICAgaWYgKGluY2x1ZGVTZWxmKSB7XG4gICAgICB5aWVsZCBub2RlO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgeWllbGQgbm9kZTtcbiAgICB9XG4gIH1cbiAgKmNoaWxkcmVuKCkge1xuICAgIGlmICghdGhpcy5jaGlsZE5vZGVzKVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZE5vZGVzKSB7XG4gICAgICB5aWVsZCBjaGlsZDtcbiAgICB9XG4gIH1cbiAgKmRlc2NlbmRhbnRzKCkge1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbigpKSB7XG4gICAgICB5aWVsZCBjaGlsZDtcbiAgICAgIHlpZWxkKiBjaGlsZC5kZXNjZW5kYW50cygpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBub2RlIGlzIGEgbGVhZiAoaGFzIG5vIGNoaWxkcmVuKS5cbiAgICovXG4gIGlzTGVhZigpIHtcbiAgICByZXR1cm4gIXRoaXMuY2hpbGROb2Rlcz8uc2l6ZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBub2RlIGlzIHRoZSByb290IChoYXMgbm8gcGFyZW50KS5cbiAgICovXG4gIGlzUm9vdCgpIHtcbiAgICByZXR1cm4gIXRoaXMucGFyZW50Tm9kZTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyBvbmUgb3IgbW9yZSBuZXcgbm9kZSBpbnN0YW5jZXMgdG8gdGhpcyBwYXJlbnQuXG4gICAqIElmIG9uZSBuZWVkcyB0bzpcbiAgICogLSBtb3ZlIGEgY2hpbGQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdCBvZiBjaGlsZHJlblxuICAgKiAtIG1vdmUgYSBjaGlsZCBmcm9tIG9uZSBwYXJlbnQgdG8gYW5vdGhlciAoaW5jbHVkaW5nIHBhcmVudHMgaW4gb3RoZXIgc2NlbmVzKVxuICAgKiBvbmUgc2hvdWxkIHVzZSB0aGUge0BsaW5rIGluc2VydEJlZm9yZX0gbWV0aG9kIGluc3RlYWQuXG4gICAqIEBwYXJhbSBub2RlcyBBIG5vZGUgb3Igbm9kZXMgdG8gYXBwZW5kLlxuICAgKi9cbiAgYXBwZW5kKG5vZGVzKSB7XG4gICAgdGhpcy5jaGlsZE5vZGVzID8/ICh0aGlzLmNoaWxkTm9kZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdG9JdGVyYWJsZShub2RlcykpIHtcbiAgICAgIG5vZGUucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB0aGlzLmNoaWxkTm9kZXMuYWRkKG5vZGUpO1xuICAgICAgbm9kZS5wYXJlbnROb2RlID0gdGhpcztcbiAgICAgIG5vZGUuX3NldExheWVyTWFuYWdlcih0aGlzLmxheWVyTWFuYWdlcik7XG4gICAgfVxuICAgIHRoaXMuaW52YWxpZGF0ZUNhY2hlZEJCb3goKTtcbiAgICB0aGlzLmRpcnR5WkluZGV4ID0gdHJ1ZTtcbiAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICB9XG4gIGFwcGVuZENoaWxkKG5vZGUpIHtcbiAgICB0aGlzLmFwcGVuZChub2RlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICByZW1vdmVDaGlsZChub2RlKSB7XG4gICAgaWYgKCF0aGlzLmNoaWxkTm9kZXM/LmRlbGV0ZShub2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkZWxldGUgbm9kZS5wYXJlbnROb2RlO1xuICAgIG5vZGUuX3NldExheWVyTWFuYWdlcigpO1xuICAgIHRoaXMuaW52YWxpZGF0ZUNhY2hlZEJCb3goKTtcbiAgICB0aGlzLmRpcnR5WkluZGV4ID0gdHJ1ZTtcbiAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZCh0aGlzKSA/PyBmYWxzZTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4oKSkge1xuICAgICAgZGVsZXRlIGNoaWxkLnBhcmVudE5vZGU7XG4gICAgICBjaGlsZC5fc2V0TGF5ZXJNYW5hZ2VyKCk7XG4gICAgfVxuICAgIHRoaXMuY2hpbGROb2Rlcz8uY2xlYXIoKTtcbiAgICB0aGlzLmludmFsaWRhdGVDYWNoZWRCQm94KCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKHRoaXMpO1xuICB9XG4gIHNldFByb3BlcnRpZXMoc3R5bGVzLCBwaWNrS2V5cykge1xuICAgIGlmIChwaWNrS2V5cykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgcGlja0tleXMpIHtcbiAgICAgICAgdGhpc1trZXldID0gc3R5bGVzW2tleV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgc3R5bGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29udGFpbnNQb2ludChfeCwgX3kpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEhpdCB0ZXN0aW5nIG1ldGhvZC5cbiAgICogUmVjdXJzaXZlbHkgY2hlY2tzIGlmIHRoZSBnaXZlbiBwb2ludCBpcyBpbnNpZGUgdGhpcyBub2RlIG9yIGFueSBvZiBpdHMgY2hpbGRyZW4uXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IG1hdGNoaW5nIG5vZGUgb3IgYHVuZGVmaW5lZGAuXG4gICAqIE5vZGVzIHRoYXQgcmVuZGVyIGxhdGVyIChzaG93IG9uIHRvcCkgYXJlIGhpdCB0ZXN0ZWQgZmlyc3QuXG4gICAqL1xuICBwaWNrTm9kZSh4LCB5LCBfbG9jYWxDb29yZHMgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy52aXNpYmxlIHx8IHRoaXMucG9pbnRlckV2ZW50cyA9PT0gMSAvKiBOb25lICovIHx8ICF0aGlzLmNvbnRhaW5zUG9pbnQoeCwgeSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbLi4udGhpcy5jaGlsZHJlbigpXTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMWUzKSB7XG4gICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgY29uc3QgY29udGFpbnNQb2ludDMgPSBjaGlsZC5jb250YWluc1BvaW50KHgsIHkpO1xuICAgICAgICBjb25zdCBoaXQgPSBjb250YWluc1BvaW50MyA/IGNoaWxkLnBpY2tOb2RlKHgsIHkpIDogdm9pZCAwO1xuICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgcmV0dXJuIGhpdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgaGl0ID0gY2hpbGRyZW5baV0ucGlja05vZGUoeCwgeSk7XG4gICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICByZXR1cm4gaGl0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5pc0NvbnRhaW5lck5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuICBpbnZhbGlkYXRlQ2FjaGVkQkJveCgpIHtcbiAgICBpZiAodGhpcy5jYWNoZWRCQm94ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuY2FjaGVkQkJveCA9IHZvaWQgMDtcbiAgICAgIHRoaXMucGFyZW50Tm9kZT8uaW52YWxpZGF0ZUNhY2hlZEJCb3goKTtcbiAgICB9XG4gIH1cbiAgZ2V0QkJveCgpIHtcbiAgICBpZiAodGhpcy5jYWNoZWRCQm94ID09IG51bGwpIHtcbiAgICAgIHRoaXMuY2FjaGVkQkJveCA9IE9iamVjdC5mcmVlemUodGhpcy5jb21wdXRlQkJveCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVkQkJveDtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbWFya0RpcnR5KCkge1xuICAgIGNvbnN0IHsgX2RpcnR5IH0gPSB0aGlzO1xuICAgIGNvbnN0IG5vUGFyZW50Q2FjaGVkQkJveCA9IHRoaXMuY2FjaGVkQkJveCA9PSBudWxsO1xuICAgIGlmIChub1BhcmVudENhY2hlZEJCb3ggJiYgX2RpcnR5KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaW52YWxpZGF0ZUNhY2hlZEJCb3goKTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5wYXJlbnROb2RlLm1hcmtEaXJ0eSgpO1xuICAgIH1cbiAgfVxuICBtYXJrQ2xlYW4oKSB7XG4gICAgaWYgKCF0aGlzLl9kaXJ0eSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbigpKSB7XG4gICAgICBjaGlsZC5tYXJrQ2xlYW4oKTtcbiAgICB9XG4gIH1cbiAgb25aSW5kZXhDaGFuZ2UoKSB7XG4gICAgY29uc3QgeyBwYXJlbnROb2RlIH0gPSB0aGlzO1xuICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICBwYXJlbnROb2RlLmRpcnR5WkluZGV4ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgdG9TVkcoKSB7XG4gICAgcmV0dXJuO1xuICB9XG59O1xuX05vZGUuX25leHRTZXJpYWxOdW1iZXIgPSAwO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgX05vZGUucHJvdG90eXBlLCBcInZpc2libGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7XG4gICAgY2hhbmdlQ2I6ICh0YXJnZXQpID0+IHRhcmdldC5vblpJbmRleENoYW5nZSgpXG4gIH0pXG5dLCBfTm9kZS5wcm90b3R5cGUsIFwiekluZGV4XCIsIDIpO1xudmFyIE5vZGUgPSBfTm9kZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9jb2xvci50c1xudmFyIGxlcnAgPSAoeCwgeSwgdCkgPT4geCAqICgxIC0gdCkgKyB5ICogdDtcbnZhciBzcmdiVG9MaW5lYXIgPSAodmFsdWUpID0+IHtcbiAgY29uc3Qgc2lnbiA9IHZhbHVlIDwgMCA/IC0xIDogMTtcbiAgY29uc3QgYWJzID0gTWF0aC5hYnModmFsdWUpO1xuICBpZiAoYWJzIDw9IDAuMDQwNDUpXG4gICAgcmV0dXJuIHZhbHVlIC8gMTIuOTI7XG4gIHJldHVybiBzaWduICogKChhYnMgKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40O1xufTtcbnZhciBzcmdiRnJvbUxpbmVhciA9ICh2YWx1ZSkgPT4ge1xuICBjb25zdCBzaWduID0gdmFsdWUgPCAwID8gLTEgOiAxO1xuICBjb25zdCBhYnMgPSBNYXRoLmFicyh2YWx1ZSk7XG4gIGlmIChhYnMgPiAzMTMwOGUtNykge1xuICAgIHJldHVybiBzaWduICogKDEuMDU1ICogYWJzICoqICgxIC8gMi40KSAtIDAuMDU1KTtcbiAgfVxuICByZXR1cm4gMTIuOTIgKiB2YWx1ZTtcbn07XG52YXIgX0NvbG9yID0gY2xhc3MgX0NvbG9yIHtcbiAgLyoqXG4gICAqIEV2ZXJ5IGNvbG9yIGNvbXBvbmVudCBzaG91bGQgYmUgaW4gdGhlIFswLCAxXSByYW5nZS5cbiAgICogU29tZSBlYXNpbmcgZnVuY3Rpb25zIChzdWNoIGFzIGVsYXN0aWMgZWFzaW5nKSBjYW4gb3ZlcnNob290IHRoZSB0YXJnZXQgdmFsdWUgYnkgc29tZSBhbW91bnQuXG4gICAqIFNvLCB3aGVuIGFuaW1hdGluZyBjb2xvcnMsIGlmIHRoZSBzb3VyY2Ugb3IgdGFyZ2V0IGNvbG9yIGNvbXBvbmVudHMgYXJlIGFscmVhZHkgbmVhclxuICAgKiBvciBhdCB0aGUgZWRnZSBvZiB0aGUgYWxsb3dlZCBbMCwgMV0gcmFuZ2UsIGl0IGlzIHBvc3NpYmxlIGZvciB0aGUgaW50ZXJtZWRpYXRlIGNvbG9yXG4gICAqIGNvbXBvbmVudCB2YWx1ZSB0byBlbmQgdXAgb3V0c2lkZSBvZiB0aGF0IHJhbmdlIG1pZC1hbmltYXRpb24uIEZvciB0aGlzIHJlYXNvbiB0aGUgY29uc3RydWN0b3JcbiAgICogcGVyZm9ybXMgcmFuZ2UgY2hlY2tpbmcvY29uc3RyYWluaW5nLlxuICAgKiBAcGFyYW0gciBSZWQgY29tcG9uZW50LlxuICAgKiBAcGFyYW0gZyBHcmVlbiBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBiIEJsdWUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0gYSBBbHBoYSAob3BhY2l0eSkgY29tcG9uZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IociwgZywgYiwgYSA9IDEpIHtcbiAgICB0aGlzLnIgPSBjbGFtcCgwLCByIHx8IDAsIDEpO1xuICAgIHRoaXMuZyA9IGNsYW1wKDAsIGcgfHwgMCwgMSk7XG4gICAgdGhpcy5iID0gY2xhbXAoMCwgYiB8fCAwLCAxKTtcbiAgICB0aGlzLmEgPSBjbGFtcCgwLCBhIHx8IDAsIDEpO1xuICB9XG4gIC8qKlxuICAgKiBBIGNvbG9yIHN0cmluZyBjYW4gYmUgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0cyB0byBiZSB2YWxpZDpcbiAgICogLSAjcmdiXG4gICAqIC0gI3JyZ2diYlxuICAgKiAtIHJnYihyLCBnLCBiKVxuICAgKiAtIHJnYmEociwgZywgYiwgYSlcbiAgICogLSBDU1MgY29sb3IgbmFtZSBzdWNoIGFzICd3aGl0ZScsICdvcmFuZ2UnLCAnY3lhbicsIGV0Yy5cbiAgICovXG4gIHN0YXRpYyB2YWxpZENvbG9yU3RyaW5nKHN0cikge1xuICAgIGlmIChzdHIuaW5kZXhPZihcIiNcIikgPj0gMCkge1xuICAgICAgcmV0dXJuICEhX0NvbG9yLnBhcnNlSGV4KHN0cik7XG4gICAgfVxuICAgIGlmIChzdHIuaW5kZXhPZihcInJnYlwiKSA+PSAwKSB7XG4gICAgICByZXR1cm4gISFfQ29sb3Iuc3RyaW5nVG9SZ2JhKHN0cik7XG4gICAgfVxuICAgIHJldHVybiBfQ29sb3IubmFtZVRvSGV4LmhhcyhzdHIudG9Mb3dlckNhc2UoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBnaXZlbiBzdHJpbmcgY2FuIGJlIGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1hdHM6XG4gICAqIC0gI3JnYlxuICAgKiAtICNycmdnYmJcbiAgICogLSByZ2IociwgZywgYilcbiAgICogLSByZ2JhKHIsIGcsIGIsIGEpXG4gICAqIC0gQ1NTIGNvbG9yIG5hbWUgc3VjaCBhcyAnd2hpdGUnLCAnb3JhbmdlJywgJ2N5YW4nLCBldGMuXG4gICAqIEBwYXJhbSBzdHJcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHN0cikge1xuICAgIGlmIChzdHIuaW5kZXhPZihcIiNcIikgPj0gMCkge1xuICAgICAgcmV0dXJuIF9Db2xvci5mcm9tSGV4U3RyaW5nKHN0cik7XG4gICAgfVxuICAgIGNvbnN0IGhleCA9IF9Db2xvci5uYW1lVG9IZXguZ2V0KHN0ci50b0xvd2VyQ2FzZSgpKTtcbiAgICBpZiAoaGV4KSB7XG4gICAgICByZXR1cm4gX0NvbG9yLmZyb21IZXhTdHJpbmcoaGV4KTtcbiAgICB9XG4gICAgaWYgKHN0ci5pbmRleE9mKFwicmdiXCIpID49IDApIHtcbiAgICAgIHJldHVybiBfQ29sb3IuZnJvbVJnYmFTdHJpbmcoc3RyKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbG9yIHN0cmluZzogJyR7c3RyfSdgKTtcbiAgfVxuICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy1jb2xvci8jaGV4LW5vdGF0aW9uXG4gIHN0YXRpYyBwYXJzZUhleChpbnB1dCkge1xuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvIC9nLCBcIlwiKS5zbGljZSgxKTtcbiAgICBsZXQgcGFydHM7XG4gICAgc3dpdGNoIChpbnB1dC5sZW5ndGgpIHtcbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgODpcbiAgICAgICAgcGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIHBhcnRzLnB1c2gocGFyc2VJbnQoYCR7aW5wdXRbaV19JHtpbnB1dFtpICsgMV19YCwgMTYpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcGFydHMgPSBpbnB1dC5zcGxpdChcIlwiKS5tYXAoKHApID0+IHBhcnNlSW50KHAsIDE2KSkubWFwKChwKSA9PiBwICsgcCAqIDE2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChwYXJ0cz8ubGVuZ3RoID49IDMgJiYgcGFydHMuZXZlcnkoKHApID0+IHAgPj0gMCkpIHtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcGFydHMucHVzaCgyNTUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbUhleFN0cmluZyhzdHIpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBfQ29sb3IucGFyc2VIZXgoc3RyKTtcbiAgICBpZiAodmFsdWVzKSB7XG4gICAgICBjb25zdCBbciwgZywgYiwgYV0gPSB2YWx1ZXM7XG4gICAgICByZXR1cm4gbmV3IF9Db2xvcihyIC8gMjU1LCBnIC8gMjU1LCBiIC8gMjU1LCBhIC8gMjU1KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNYWxmb3JtZWQgaGV4YWRlY2ltYWwgY29sb3Igc3RyaW5nOiAnJHtzdHJ9J2ApO1xuICB9XG4gIHN0YXRpYyBzdHJpbmdUb1JnYmEoc3RyKSB7XG4gICAgbGV0IHBvID0gLTE7XG4gICAgbGV0IHBjID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBzdHJbaV07XG4gICAgICBpZiAocG8gPT09IC0xICYmIGMgPT09IFwiKFwiKSB7XG4gICAgICAgIHBvID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gXCIpXCIpIHtcbiAgICAgICAgcGMgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvID09PSAtMSB8fCBwYyA9PT0gLTEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY29udGVudHMgPSBzdHIuc3Vic3RyaW5nKHBvICsgMSwgcGMpO1xuICAgIGNvbnN0IHBhcnRzID0gY29udGVudHMuc3BsaXQoXCIsXCIpO1xuICAgIGNvbnN0IHJnYmEgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBsZXQgdmFsdWUgPSBwYXJzZUZsb2F0KHBhcnQpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0LmluZGV4T2YoXCIlXCIpID49IDApIHtcbiAgICAgICAgdmFsdWUgPSBjbGFtcCgwLCB2YWx1ZSwgMTAwKTtcbiAgICAgICAgdmFsdWUgLz0gMTAwO1xuICAgICAgfSBlbHNlIGlmIChpID09PSAzKSB7XG4gICAgICAgIHZhbHVlID0gY2xhbXAoMCwgdmFsdWUsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBjbGFtcCgwLCB2YWx1ZSwgMjU1KTtcbiAgICAgICAgdmFsdWUgLz0gMjU1O1xuICAgICAgfVxuICAgICAgcmdiYS5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJnYmE7XG4gIH1cbiAgc3RhdGljIGZyb21SZ2JhU3RyaW5nKHN0cikge1xuICAgIGNvbnN0IHJnYmEgPSBfQ29sb3Iuc3RyaW5nVG9SZ2JhKHN0cik7XG4gICAgaWYgKHJnYmEpIHtcbiAgICAgIGlmIChyZ2JhLmxlbmd0aCA9PT0gMykge1xuICAgICAgICByZXR1cm4gbmV3IF9Db2xvcihyZ2JhWzBdLCByZ2JhWzFdLCByZ2JhWzJdKTtcbiAgICAgIH0gZWxzZSBpZiAocmdiYS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfQ29sb3IocmdiYVswXSwgcmdiYVsxXSwgcmdiYVsyXSwgcmdiYVszXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkIHJnYi9yZ2JhIGNvbG9yIHN0cmluZzogJyR7c3RyfSdgKTtcbiAgfVxuICBzdGF0aWMgZnJvbUFycmF5KGFycikge1xuICAgIGlmIChhcnIubGVuZ3RoID09PSA0KSB7XG4gICAgICByZXR1cm4gbmV3IF9Db2xvcihhcnJbMF0sIGFyclsxXSwgYXJyWzJdLCBhcnJbM10pO1xuICAgIH1cbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIG5ldyBfQ29sb3IoYXJyWzBdLCBhcnJbMV0sIGFyclsyXSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBnaXZlbiBhcnJheSBzaG91bGQgY29udGFpbiAzIG9yIDQgY29sb3IgY29tcG9uZW50cyAobnVtYmVycykuXCIpO1xuICB9XG4gIHN0YXRpYyBmcm9tSFNCKGgsIHMsIGIsIGFscGhhID0gMSkge1xuICAgIGNvbnN0IHJnYiA9IF9Db2xvci5IU0J0b1JHQihoLCBzLCBiKTtcbiAgICByZXR1cm4gbmV3IF9Db2xvcihyZ2JbMF0sIHJnYlsxXSwgcmdiWzJdLCBhbHBoYSk7XG4gIH1cbiAgc3RhdGljIGZyb21IU0woaCwgcywgbCwgYWxwaGEgPSAxKSB7XG4gICAgY29uc3QgcmdiID0gX0NvbG9yLkhTTHRvUkdCKGgsIHMsIGwpO1xuICAgIHJldHVybiBuZXcgX0NvbG9yKHJnYlswXSwgcmdiWzFdLCByZ2JbMl0sIGFscGhhKTtcbiAgfVxuICBzdGF0aWMgZnJvbU9LTENIKGwsIGMsIGgsIGFscGhhID0gMSkge1xuICAgIGNvbnN0IHJnYiA9IF9Db2xvci5PS0xDSHRvUkdCKGwsIGMsIGgpO1xuICAgIHJldHVybiBuZXcgX0NvbG9yKHJnYlswXSwgcmdiWzFdLCByZ2JbMl0sIGFscGhhKTtcbiAgfVxuICBzdGF0aWMgcGFkSGV4KHN0cikge1xuICAgIHJldHVybiBzdHIubGVuZ3RoID09PSAxID8gXCIwXCIgKyBzdHIgOiBzdHI7XG4gIH1cbiAgdG9IZXhTdHJpbmcoKSB7XG4gICAgbGV0IGhleCA9IFwiI1wiICsgX0NvbG9yLnBhZEhleChNYXRoLnJvdW5kKHRoaXMuciAqIDI1NSkudG9TdHJpbmcoMTYpKSArIF9Db2xvci5wYWRIZXgoTWF0aC5yb3VuZCh0aGlzLmcgKiAyNTUpLnRvU3RyaW5nKDE2KSkgKyBfQ29sb3IucGFkSGV4KE1hdGgucm91bmQodGhpcy5iICogMjU1KS50b1N0cmluZygxNikpO1xuICAgIGlmICh0aGlzLmEgPCAxKSB7XG4gICAgICBoZXggKz0gX0NvbG9yLnBhZEhleChNYXRoLnJvdW5kKHRoaXMuYSAqIDI1NSkudG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbiAgfVxuICB0b1JnYmFTdHJpbmcoZnJhY3Rpb25EaWdpdHMgPSAzKSB7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IFtNYXRoLnJvdW5kKHRoaXMuciAqIDI1NSksIE1hdGgucm91bmQodGhpcy5nICogMjU1KSwgTWF0aC5yb3VuZCh0aGlzLmIgKiAyNTUpXTtcbiAgICBjb25zdCBrID0gTWF0aC5wb3coMTAsIGZyYWN0aW9uRGlnaXRzKTtcbiAgICBpZiAodGhpcy5hICE9PSAxKSB7XG4gICAgICBjb21wb25lbnRzLnB1c2goTWF0aC5yb3VuZCh0aGlzLmEgKiBrKSAvIGspO1xuICAgICAgcmV0dXJuIGByZ2JhKCR7Y29tcG9uZW50cy5qb2luKFwiLCBcIil9KWA7XG4gICAgfVxuICAgIHJldHVybiBgcmdiKCR7Y29tcG9uZW50cy5qb2luKFwiLCBcIil9KWA7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMuYSA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9SZ2JhU3RyaW5nKCk7XG4gIH1cbiAgdG9IU0IoKSB7XG4gICAgcmV0dXJuIF9Db2xvci5SR0J0b0hTQih0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgfVxuICBzdGF0aWMgUkdCdG9PS0xDSChyLCBnLCBiKSB7XG4gICAgY29uc3QgTFNSR0IwID0gc3JnYlRvTGluZWFyKHIpO1xuICAgIGNvbnN0IExTUkdCMSA9IHNyZ2JUb0xpbmVhcihnKTtcbiAgICBjb25zdCBMU1JHQjIgPSBzcmdiVG9MaW5lYXIoYik7XG4gICAgY29uc3QgTE1TMCA9IE1hdGguY2JydCgwLjQxMjIyMTQ3MDggKiBMU1JHQjAgKyAwLjUzNjMzMjUzNjMgKiBMU1JHQjEgKyAwLjA1MTQ0NTk5MjkgKiBMU1JHQjIpO1xuICAgIGNvbnN0IExNUzEgPSBNYXRoLmNicnQoMC4yMTE5MDM0OTgyICogTFNSR0IwICsgMC42ODA2OTk1NDUxICogTFNSR0IxICsgMC4xMDczOTY5NTY2ICogTFNSR0IyKTtcbiAgICBjb25zdCBMTVMyID0gTWF0aC5jYnJ0KDAuMDg4MzAyNDYxOSAqIExTUkdCMCArIDAuMjgxNzE4ODM3NiAqIExTUkdCMSArIDAuNjI5OTc4NzAwNSAqIExTUkdCMik7XG4gICAgY29uc3QgT0tMQUIwID0gMC4yMTA0NTQyNTUzICogTE1TMCArIDAuNzkzNjE3Nzg1ICogTE1TMSAtIDAuMDA0MDcyMDQ2OCAqIExNUzI7XG4gICAgY29uc3QgT0tMQUIxID0gMS45Nzc5OTg0OTUxICogTE1TMCAtIDIuNDI4NTkyMjA1ICogTE1TMSArIDAuNDUwNTkzNzA5OSAqIExNUzI7XG4gICAgY29uc3QgT0tMQUIyID0gMC4wMjU5MDQwMzcxICogTE1TMCArIDAuNzgyNzcxNzY2MiAqIExNUzEgLSAwLjgwODY3NTc2NiAqIExNUzI7XG4gICAgY29uc3QgaHVlID0gTWF0aC5hdGFuMihPS0xBQjIsIE9LTEFCMSkgKiAxODAgLyBNYXRoLlBJO1xuICAgIGNvbnN0IE9LTENIMCA9IE9LTEFCMDtcbiAgICBjb25zdCBPS0xDSDEgPSBNYXRoLmh5cG90KE9LTEFCMSwgT0tMQUIyKTtcbiAgICBjb25zdCBPS0xDSDIgPSBodWUgPj0gMCA/IGh1ZSA6IGh1ZSArIDM2MDtcbiAgICByZXR1cm4gW09LTENIMCwgT0tMQ0gxLCBPS0xDSDJdO1xuICB9XG4gIHN0YXRpYyBPS0xDSHRvUkdCKGwsIGMsIGgpIHtcbiAgICBjb25zdCBPS0xBQjAgPSBsO1xuICAgIGNvbnN0IE9LTEFCMSA9IGMgKiBNYXRoLmNvcyhoICogTWF0aC5QSSAvIDE4MCk7XG4gICAgY29uc3QgT0tMQUIyID0gYyAqIE1hdGguc2luKGggKiBNYXRoLlBJIC8gMTgwKTtcbiAgICBjb25zdCBMTVMwID0gKE9LTEFCMCArIDAuMzk2MzM3Nzc3NCAqIE9LTEFCMSArIDAuMjE1ODAzNzU3MyAqIE9LTEFCMikgKiogMztcbiAgICBjb25zdCBMTVMxID0gKE9LTEFCMCAtIDAuMTA1NTYxMzQ1OCAqIE9LTEFCMSAtIDAuMDYzODU0MTcyOCAqIE9LTEFCMikgKiogMztcbiAgICBjb25zdCBMTVMyID0gKE9LTEFCMCAtIDAuMDg5NDg0MTc3NSAqIE9LTEFCMSAtIDEuMjkxNDg1NTQ4ICogT0tMQUIyKSAqKiAzO1xuICAgIGNvbnN0IExTUkdCMCA9IDQuMDc2NzQxNjYyMSAqIExNUzAgLSAzLjMwNzcxMTU5MTMgKiBMTVMxICsgMC4yMzA5Njk5MjkyICogTE1TMjtcbiAgICBjb25zdCBMU1JHQjEgPSAtMS4yNjg0MzgwMDQ2ICogTE1TMCArIDIuNjA5NzU3NDAxMSAqIExNUzEgLSAwLjM0MTMxOTM5NjUgKiBMTVMyO1xuICAgIGNvbnN0IExTUkdCMiA9IC0wLjAwNDE5NjA4NjMgKiBMTVMwIC0gMC43MDM0MTg2MTQ3ICogTE1TMSArIDEuNzA3NjE0NzAxICogTE1TMjtcbiAgICBjb25zdCBTUkdCMCA9IHNyZ2JGcm9tTGluZWFyKExTUkdCMCk7XG4gICAgY29uc3QgU1JHQjEgPSBzcmdiRnJvbUxpbmVhcihMU1JHQjEpO1xuICAgIGNvbnN0IFNSR0IyID0gc3JnYkZyb21MaW5lYXIoTFNSR0IyKTtcbiAgICByZXR1cm4gW1NSR0IwLCBTUkdCMSwgU1JHQjJdO1xuICB9XG4gIHN0YXRpYyBSR0J0b0hTTChyLCBnLCBiKSB7XG4gICAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgICBsZXQgaDtcbiAgICBsZXQgcztcbiAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgIGggPSAwO1xuICAgICAgcyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRlbHRhMyA9IG1heCAtIG1pbjtcbiAgICAgIHMgPSBsID4gMC41ID8gZGVsdGEzIC8gKDIgLSBtYXggLSBtaW4pIDogZGVsdGEzIC8gKG1heCArIG1pbik7XG4gICAgICBpZiAobWF4ID09PSByKSB7XG4gICAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGEzICsgKGcgPCBiID8gNiA6IDApO1xuICAgICAgfSBlbHNlIGlmIChtYXggPT09IGcpIHtcbiAgICAgICAgaCA9IChiIC0gcikgLyBkZWx0YTMgKyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaCA9IChyIC0gZykgLyBkZWx0YTMgKyA0O1xuICAgICAgfVxuICAgICAgaCAqPSAzNjAgLyA2O1xuICAgIH1cbiAgICByZXR1cm4gW2gsIHMsIGxdO1xuICB9XG4gIHN0YXRpYyBIU0x0b1JHQihoLCBzLCBsKSB7XG4gICAgaCA9IChoICUgMzYwICsgMzYwKSAlIDM2MDtcbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtsLCBsLCBsXTtcbiAgICB9XG4gICAgY29uc3QgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgY29uc3QgcCA9IDIgKiBsIC0gcTtcbiAgICBmdW5jdGlvbiBodWVUb1JnYih0KSB7XG4gICAgICBpZiAodCA8IDApXG4gICAgICAgIHQgKz0gMTtcbiAgICAgIGlmICh0ID4gMSlcbiAgICAgICAgdCAtPSAxO1xuICAgICAgaWYgKHQgPCAxIC8gNilcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgICBpZiAodCA8IDEgLyAyKVxuICAgICAgICByZXR1cm4gcTtcbiAgICAgIGlmICh0IDwgMiAvIDMpXG4gICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBjb25zdCByID0gaHVlVG9SZ2IoaCAvIDM2MCArIDEgLyAzKTtcbiAgICBjb25zdCBnID0gaHVlVG9SZ2IoaCAvIDM2MCk7XG4gICAgY29uc3QgYiA9IGh1ZVRvUmdiKGggLyAzNjAgLSAxIC8gMyk7XG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGdpdmVuIFJHQiB0cmlwbGUgdG8gYW4gYXJyYXkgb2YgSFNCIChIU1YpIGNvbXBvbmVudHMuXG4gICAqL1xuICBzdGF0aWMgUkdCdG9IU0IociwgZywgYikge1xuICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIGNvbnN0IFMgPSBtYXggPT09IDAgPyAwIDogKG1heCAtIG1pbikgLyBtYXg7XG4gICAgbGV0IEggPSAwO1xuICAgIGlmIChtaW4gIT09IG1heCkge1xuICAgICAgY29uc3QgZGVsdGEzID0gbWF4IC0gbWluO1xuICAgICAgY29uc3QgcmMgPSAobWF4IC0gcikgLyBkZWx0YTM7XG4gICAgICBjb25zdCBnYyA9IChtYXggLSBnKSAvIGRlbHRhMztcbiAgICAgIGNvbnN0IGJjID0gKG1heCAtIGIpIC8gZGVsdGEzO1xuICAgICAgaWYgKHIgPT09IG1heCkge1xuICAgICAgICBIID0gYmMgLSBnYztcbiAgICAgIH0gZWxzZSBpZiAoZyA9PT0gbWF4KSB7XG4gICAgICAgIEggPSAyICsgcmMgLSBiYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEggPSA0ICsgZ2MgLSByYztcbiAgICAgIH1cbiAgICAgIEggLz0gNjtcbiAgICAgIGlmIChIIDwgMCkge1xuICAgICAgICBIID0gSCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbSCAqIDM2MCwgUywgbWF4XTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGdpdmVuIEhTQiAoSFNWKSB0cmlwbGUgdG8gYW4gYXJyYXkgb2YgUkdCIGNvbXBvbmVudHMuXG4gICAqL1xuICBzdGF0aWMgSFNCdG9SR0IoSCwgUywgQikge1xuICAgIEggPSAoSCAlIDM2MCArIDM2MCkgJSAzNjAgLyAzNjA7XG4gICAgbGV0IHIgPSAwO1xuICAgIGxldCBnID0gMDtcbiAgICBsZXQgYiA9IDA7XG4gICAgaWYgKFMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGggPSAoSCAtIE1hdGguZmxvb3IoSCkpICogNjtcbiAgICAgIGNvbnN0IGYgPSBoIC0gTWF0aC5mbG9vcihoKTtcbiAgICAgIGNvbnN0IHAgPSBCICogKDEgLSBTKTtcbiAgICAgIGNvbnN0IHEgPSBCICogKDEgLSBTICogZik7XG4gICAgICBjb25zdCB0ID0gQiAqICgxIC0gUyAqICgxIC0gZikpO1xuICAgICAgc3dpdGNoIChoID4+IDApIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHIgPSBCO1xuICAgICAgICAgIGcgPSB0O1xuICAgICAgICAgIGIgPSBwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgciA9IHE7XG4gICAgICAgICAgZyA9IEI7XG4gICAgICAgICAgYiA9IHA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByID0gcDtcbiAgICAgICAgICBnID0gQjtcbiAgICAgICAgICBiID0gdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHIgPSBwO1xuICAgICAgICAgIGcgPSBxO1xuICAgICAgICAgIGIgPSBCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgciA9IHQ7XG4gICAgICAgICAgZyA9IHA7XG4gICAgICAgICAgYiA9IEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByID0gQjtcbiAgICAgICAgICBnID0gcDtcbiAgICAgICAgICBiID0gcTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgfVxuICBzdGF0aWMgbWl4KGMwLCBjMSwgdCkge1xuICAgIHJldHVybiBuZXcgX0NvbG9yKGxlcnAoYzAuciwgYzEuciwgdCksIGxlcnAoYzAuZywgYzEuZywgdCksIGxlcnAoYzAuYiwgYzEuYiwgdCksIGxlcnAoYzAuYSwgYzEuYSwgdCkpO1xuICB9XG59O1xuLyoqXG4gKiBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDQ6XG4gKiBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLWNvbG9yLyNuYW1lZC1jb2xvcnNcbiAqL1xuX0NvbG9yLm5hbWVUb0hleCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgW1wiYWxpY2VibHVlXCIsIFwiI0YwRjhGRlwiXSxcbiAgW1wiYW50aXF1ZXdoaXRlXCIsIFwiI0ZBRUJEN1wiXSxcbiAgW1wiYXF1YVwiLCBcIiMwMEZGRkZcIl0sXG4gIFtcImFxdWFtYXJpbmVcIiwgXCIjN0ZGRkQ0XCJdLFxuICBbXCJhenVyZVwiLCBcIiNGMEZGRkZcIl0sXG4gIFtcImJlaWdlXCIsIFwiI0Y1RjVEQ1wiXSxcbiAgW1wiYmlzcXVlXCIsIFwiI0ZGRTRDNFwiXSxcbiAgW1wiYmxhY2tcIiwgXCIjMDAwMDAwXCJdLFxuICBbXCJibGFuY2hlZGFsbW9uZFwiLCBcIiNGRkVCQ0RcIl0sXG4gIFtcImJsdWVcIiwgXCIjMDAwMEZGXCJdLFxuICBbXCJibHVldmlvbGV0XCIsIFwiIzhBMkJFMlwiXSxcbiAgW1wiYnJvd25cIiwgXCIjQTUyQTJBXCJdLFxuICBbXCJidXJseXdvb2RcIiwgXCIjREVCODg3XCJdLFxuICBbXCJjYWRldGJsdWVcIiwgXCIjNUY5RUEwXCJdLFxuICBbXCJjaGFydHJldXNlXCIsIFwiIzdGRkYwMFwiXSxcbiAgW1wiY2hvY29sYXRlXCIsIFwiI0QyNjkxRVwiXSxcbiAgW1wiY29yYWxcIiwgXCIjRkY3RjUwXCJdLFxuICBbXCJjb3JuZmxvd2VyYmx1ZVwiLCBcIiM2NDk1RURcIl0sXG4gIFtcImNvcm5zaWxrXCIsIFwiI0ZGRjhEQ1wiXSxcbiAgW1wiY3JpbXNvblwiLCBcIiNEQzE0M0NcIl0sXG4gIFtcImN5YW5cIiwgXCIjMDBGRkZGXCJdLFxuICBbXCJkYXJrYmx1ZVwiLCBcIiMwMDAwOEJcIl0sXG4gIFtcImRhcmtjeWFuXCIsIFwiIzAwOEI4QlwiXSxcbiAgW1wiZGFya2dvbGRlbnJvZFwiLCBcIiNCODg2MEJcIl0sXG4gIFtcImRhcmtncmF5XCIsIFwiI0E5QTlBOVwiXSxcbiAgW1wiZGFya2dyZWVuXCIsIFwiIzAwNjQwMFwiXSxcbiAgW1wiZGFya2dyZXlcIiwgXCIjQTlBOUE5XCJdLFxuICBbXCJkYXJra2hha2lcIiwgXCIjQkRCNzZCXCJdLFxuICBbXCJkYXJrbWFnZW50YVwiLCBcIiM4QjAwOEJcIl0sXG4gIFtcImRhcmtvbGl2ZWdyZWVuXCIsIFwiIzU1NkIyRlwiXSxcbiAgW1wiZGFya29yYW5nZVwiLCBcIiNGRjhDMDBcIl0sXG4gIFtcImRhcmtvcmNoaWRcIiwgXCIjOTkzMkNDXCJdLFxuICBbXCJkYXJrcmVkXCIsIFwiIzhCMDAwMFwiXSxcbiAgW1wiZGFya3NhbG1vblwiLCBcIiNFOTk2N0FcIl0sXG4gIFtcImRhcmtzZWFncmVlblwiLCBcIiM4RkJDOEZcIl0sXG4gIFtcImRhcmtzbGF0ZWJsdWVcIiwgXCIjNDgzRDhCXCJdLFxuICBbXCJkYXJrc2xhdGVncmF5XCIsIFwiIzJGNEY0RlwiXSxcbiAgW1wiZGFya3NsYXRlZ3JleVwiLCBcIiMyRjRGNEZcIl0sXG4gIFtcImRhcmt0dXJxdW9pc2VcIiwgXCIjMDBDRUQxXCJdLFxuICBbXCJkYXJrdmlvbGV0XCIsIFwiIzk0MDBEM1wiXSxcbiAgW1wiZGVlcHBpbmtcIiwgXCIjRkYxNDkzXCJdLFxuICBbXCJkZWVwc2t5Ymx1ZVwiLCBcIiMwMEJGRkZcIl0sXG4gIFtcImRpbWdyYXlcIiwgXCIjNjk2OTY5XCJdLFxuICBbXCJkaW1ncmV5XCIsIFwiIzY5Njk2OVwiXSxcbiAgW1wiZG9kZ2VyYmx1ZVwiLCBcIiMxRTkwRkZcIl0sXG4gIFtcImZpcmVicmlja1wiLCBcIiNCMjIyMjJcIl0sXG4gIFtcImZsb3JhbHdoaXRlXCIsIFwiI0ZGRkFGMFwiXSxcbiAgW1wiZm9yZXN0Z3JlZW5cIiwgXCIjMjI4QjIyXCJdLFxuICBbXCJmdWNoc2lhXCIsIFwiI0ZGMDBGRlwiXSxcbiAgW1wiZ2FpbnNib3JvXCIsIFwiI0RDRENEQ1wiXSxcbiAgW1wiZ2hvc3R3aGl0ZVwiLCBcIiNGOEY4RkZcIl0sXG4gIFtcImdvbGRcIiwgXCIjRkZENzAwXCJdLFxuICBbXCJnb2xkZW5yb2RcIiwgXCIjREFBNTIwXCJdLFxuICBbXCJncmF5XCIsIFwiIzgwODA4MFwiXSxcbiAgW1wiZ3JlZW5cIiwgXCIjMDA4MDAwXCJdLFxuICBbXCJncmVlbnllbGxvd1wiLCBcIiNBREZGMkZcIl0sXG4gIFtcImdyZXlcIiwgXCIjODA4MDgwXCJdLFxuICBbXCJob25leWRld1wiLCBcIiNGMEZGRjBcIl0sXG4gIFtcImhvdHBpbmtcIiwgXCIjRkY2OUI0XCJdLFxuICBbXCJpbmRpYW5yZWRcIiwgXCIjQ0Q1QzVDXCJdLFxuICBbXCJpbmRpZ29cIiwgXCIjNEIwMDgyXCJdLFxuICBbXCJpdm9yeVwiLCBcIiNGRkZGRjBcIl0sXG4gIFtcImtoYWtpXCIsIFwiI0YwRTY4Q1wiXSxcbiAgW1wibGF2ZW5kZXJcIiwgXCIjRTZFNkZBXCJdLFxuICBbXCJsYXZlbmRlcmJsdXNoXCIsIFwiI0ZGRjBGNVwiXSxcbiAgW1wibGF3bmdyZWVuXCIsIFwiIzdDRkMwMFwiXSxcbiAgW1wibGVtb25jaGlmZm9uXCIsIFwiI0ZGRkFDRFwiXSxcbiAgW1wibGlnaHRibHVlXCIsIFwiI0FERDhFNlwiXSxcbiAgW1wibGlnaHRjb3JhbFwiLCBcIiNGMDgwODBcIl0sXG4gIFtcImxpZ2h0Y3lhblwiLCBcIiNFMEZGRkZcIl0sXG4gIFtcImxpZ2h0Z29sZGVucm9keWVsbG93XCIsIFwiI0ZBRkFEMlwiXSxcbiAgW1wibGlnaHRncmF5XCIsIFwiI0QzRDNEM1wiXSxcbiAgW1wibGlnaHRncmVlblwiLCBcIiM5MEVFOTBcIl0sXG4gIFtcImxpZ2h0Z3JleVwiLCBcIiNEM0QzRDNcIl0sXG4gIFtcImxpZ2h0cGlua1wiLCBcIiNGRkI2QzFcIl0sXG4gIFtcImxpZ2h0c2FsbW9uXCIsIFwiI0ZGQTA3QVwiXSxcbiAgW1wibGlnaHRzZWFncmVlblwiLCBcIiMyMEIyQUFcIl0sXG4gIFtcImxpZ2h0c2t5Ymx1ZVwiLCBcIiM4N0NFRkFcIl0sXG4gIFtcImxpZ2h0c2xhdGVncmF5XCIsIFwiIzc3ODg5OVwiXSxcbiAgW1wibGlnaHRzbGF0ZWdyZXlcIiwgXCIjNzc4ODk5XCJdLFxuICBbXCJsaWdodHN0ZWVsYmx1ZVwiLCBcIiNCMEM0REVcIl0sXG4gIFtcImxpZ2h0eWVsbG93XCIsIFwiI0ZGRkZFMFwiXSxcbiAgW1wibGltZVwiLCBcIiMwMEZGMDBcIl0sXG4gIFtcImxpbWVncmVlblwiLCBcIiMzMkNEMzJcIl0sXG4gIFtcImxpbmVuXCIsIFwiI0ZBRjBFNlwiXSxcbiAgW1wibWFnZW50YVwiLCBcIiNGRjAwRkZcIl0sXG4gIFtcIm1hcm9vblwiLCBcIiM4MDAwMDBcIl0sXG4gIFtcIm1lZGl1bWFxdWFtYXJpbmVcIiwgXCIjNjZDREFBXCJdLFxuICBbXCJtZWRpdW1ibHVlXCIsIFwiIzAwMDBDRFwiXSxcbiAgW1wibWVkaXVtb3JjaGlkXCIsIFwiI0JBNTVEM1wiXSxcbiAgW1wibWVkaXVtcHVycGxlXCIsIFwiIzkzNzBEQlwiXSxcbiAgW1wibWVkaXVtc2VhZ3JlZW5cIiwgXCIjM0NCMzcxXCJdLFxuICBbXCJtZWRpdW1zbGF0ZWJsdWVcIiwgXCIjN0I2OEVFXCJdLFxuICBbXCJtZWRpdW1zcHJpbmdncmVlblwiLCBcIiMwMEZBOUFcIl0sXG4gIFtcIm1lZGl1bXR1cnF1b2lzZVwiLCBcIiM0OEQxQ0NcIl0sXG4gIFtcIm1lZGl1bXZpb2xldHJlZFwiLCBcIiNDNzE1ODVcIl0sXG4gIFtcIm1pZG5pZ2h0Ymx1ZVwiLCBcIiMxOTE5NzBcIl0sXG4gIFtcIm1pbnRjcmVhbVwiLCBcIiNGNUZGRkFcIl0sXG4gIFtcIm1pc3R5cm9zZVwiLCBcIiNGRkU0RTFcIl0sXG4gIFtcIm1vY2Nhc2luXCIsIFwiI0ZGRTRCNVwiXSxcbiAgW1wibmF2YWpvd2hpdGVcIiwgXCIjRkZERUFEXCJdLFxuICBbXCJuYXZ5XCIsIFwiIzAwMDA4MFwiXSxcbiAgW1wib2xkbGFjZVwiLCBcIiNGREY1RTZcIl0sXG4gIFtcIm9saXZlXCIsIFwiIzgwODAwMFwiXSxcbiAgW1wib2xpdmVkcmFiXCIsIFwiIzZCOEUyM1wiXSxcbiAgW1wib3JhbmdlXCIsIFwiI0ZGQTUwMFwiXSxcbiAgW1wib3JhbmdlcmVkXCIsIFwiI0ZGNDUwMFwiXSxcbiAgW1wib3JjaGlkXCIsIFwiI0RBNzBENlwiXSxcbiAgW1wicGFsZWdvbGRlbnJvZFwiLCBcIiNFRUU4QUFcIl0sXG4gIFtcInBhbGVncmVlblwiLCBcIiM5OEZCOThcIl0sXG4gIFtcInBhbGV0dXJxdW9pc2VcIiwgXCIjQUZFRUVFXCJdLFxuICBbXCJwYWxldmlvbGV0cmVkXCIsIFwiI0RCNzA5M1wiXSxcbiAgW1wicGFwYXlhd2hpcFwiLCBcIiNGRkVGRDVcIl0sXG4gIFtcInBlYWNocHVmZlwiLCBcIiNGRkRBQjlcIl0sXG4gIFtcInBlcnVcIiwgXCIjQ0Q4NTNGXCJdLFxuICBbXCJwaW5rXCIsIFwiI0ZGQzBDQlwiXSxcbiAgW1wicGx1bVwiLCBcIiNEREEwRERcIl0sXG4gIFtcInBvd2RlcmJsdWVcIiwgXCIjQjBFMEU2XCJdLFxuICBbXCJwdXJwbGVcIiwgXCIjODAwMDgwXCJdLFxuICBbXCJyZWJlY2NhcHVycGxlXCIsIFwiIzY2MzM5OVwiXSxcbiAgW1wicmVkXCIsIFwiI0ZGMDAwMFwiXSxcbiAgW1wicm9zeWJyb3duXCIsIFwiI0JDOEY4RlwiXSxcbiAgW1wicm95YWxibHVlXCIsIFwiIzQxNjlFMVwiXSxcbiAgW1wic2FkZGxlYnJvd25cIiwgXCIjOEI0NTEzXCJdLFxuICBbXCJzYWxtb25cIiwgXCIjRkE4MDcyXCJdLFxuICBbXCJzYW5keWJyb3duXCIsIFwiI0Y0QTQ2MFwiXSxcbiAgW1wic2VhZ3JlZW5cIiwgXCIjMkU4QjU3XCJdLFxuICBbXCJzZWFzaGVsbFwiLCBcIiNGRkY1RUVcIl0sXG4gIFtcInNpZW5uYVwiLCBcIiNBMDUyMkRcIl0sXG4gIFtcInNpbHZlclwiLCBcIiNDMEMwQzBcIl0sXG4gIFtcInNreWJsdWVcIiwgXCIjODdDRUVCXCJdLFxuICBbXCJzbGF0ZWJsdWVcIiwgXCIjNkE1QUNEXCJdLFxuICBbXCJzbGF0ZWdyYXlcIiwgXCIjNzA4MDkwXCJdLFxuICBbXCJzbGF0ZWdyZXlcIiwgXCIjNzA4MDkwXCJdLFxuICBbXCJzbm93XCIsIFwiI0ZGRkFGQVwiXSxcbiAgW1wic3ByaW5nZ3JlZW5cIiwgXCIjMDBGRjdGXCJdLFxuICBbXCJzdGVlbGJsdWVcIiwgXCIjNDY4MkI0XCJdLFxuICBbXCJ0YW5cIiwgXCIjRDJCNDhDXCJdLFxuICBbXCJ0ZWFsXCIsIFwiIzAwODA4MFwiXSxcbiAgW1widGhpc3RsZVwiLCBcIiNEOEJGRDhcIl0sXG4gIFtcInRvbWF0b1wiLCBcIiNGRjYzNDdcIl0sXG4gIFtcInRyYW5zcGFyZW50XCIsIFwiIzAwMDAwMDAwXCJdLFxuICBbXCJ0dXJxdW9pc2VcIiwgXCIjNDBFMEQwXCJdLFxuICBbXCJ2aW9sZXRcIiwgXCIjRUU4MkVFXCJdLFxuICBbXCJ3aGVhdFwiLCBcIiNGNURFQjNcIl0sXG4gIFtcIndoaXRlXCIsIFwiI0ZGRkZGRlwiXSxcbiAgW1wid2hpdGVzbW9rZVwiLCBcIiNGNUY1RjVcIl0sXG4gIFtcInllbGxvd1wiLCBcIiNGRkZGMDBcIl0sXG4gIFtcInllbGxvd2dyZWVuXCIsIFwiIzlBQ0QzMlwiXVxuXSk7XG52YXIgQ29sb3IgPSBfQ29sb3I7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvaW50ZXJwb2xhdGUudHNcbmZ1bmN0aW9uIGludGVycG9sYXRlTnVtYmVyKGEsIGIpIHtcbiAgcmV0dXJuIChkKSA9PiBOdW1iZXIoYSkgKiAoMSAtIGQpICsgTnVtYmVyKGIpICogZDtcbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlQ29sb3IoYSwgYikge1xuICBpZiAodHlwZW9mIGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgYSA9IENvbG9yLmZyb21TdHJpbmcoYSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBhID0gQ29sb3IuZnJvbUFycmF5KFswLCAwLCAwXSk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgYiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRyeSB7XG4gICAgICBiID0gQ29sb3IuZnJvbVN0cmluZyhiKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGIgPSBDb2xvci5mcm9tQXJyYXkoWzAsIDAsIDBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChkKSA9PiBDb2xvci5taXgoYSwgYiwgZCkudG9SZ2JhU3RyaW5nKCk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvZGVjb3JhdG9yLnRzXG52YXIgQlJFQUtfVFJBTlNGT1JNX0NIQUlOID0gU3ltYm9sKFwiQlJFQUtcIik7XG52YXIgQ09ORklHX0tFWSA9IFwiX19kZWNvcmF0b3JfY29uZmlnXCI7XG5mdW5jdGlvbiBpbml0aWFsaXNlQ29uZmlnKHRhcmdldCwgcHJvcGVydHlLZXlPclN5bWJvbCkge1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIENPTkZJR19LRVkpID09IG51bGwpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBDT05GSUdfS0VZLCB7IHZhbHVlOiB7fSB9KTtcbiAgfVxuICBjb25zdCBjb25maWcgPSB0YXJnZXRbQ09ORklHX0tFWV07XG4gIGNvbnN0IHByb3BlcnR5S2V5ID0gcHJvcGVydHlLZXlPclN5bWJvbC50b1N0cmluZygpO1xuICBpZiAodHlwZW9mIGNvbmZpZ1twcm9wZXJ0eUtleV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gY29uZmlnW3Byb3BlcnR5S2V5XTtcbiAgfVxuICBjb25zdCB2YWx1ZXNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgY29uZmlnW3Byb3BlcnR5S2V5XSA9IHsgc2V0dGVyczogW10sIGdldHRlcnM6IFtdLCBvYnNlcnZlcnM6IFtdLCB2YWx1ZXNNYXAgfTtcbiAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sKTtcbiAgY29uc3QgcHJldlNldCA9IGRlc2NyaXB0b3I/LnNldDtcbiAgY29uc3QgcHJldkdldCA9IGRlc2NyaXB0b3I/LmdldDtcbiAgY29uc3QgZ2V0dGVyID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IHZhbHVlID0gcHJldkdldCA/IHByZXZHZXQuY2FsbCh0aGlzKSA6IHZhbHVlc01hcC5nZXQodGhpcyk7XG4gICAgZm9yIChjb25zdCB0cmFuc2Zvcm1GbiBvZiBjb25maWdbcHJvcGVydHlLZXldLmdldHRlcnMpIHtcbiAgICAgIHZhbHVlID0gdHJhbnNmb3JtRm4odGhpcywgcHJvcGVydHlLZXlPclN5bWJvbCwgdmFsdWUpO1xuICAgICAgaWYgKHZhbHVlID09PSBCUkVBS19UUkFOU0ZPUk1fQ0hBSU4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIGNvbnN0IHNldHRlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgY29uc3QgeyBzZXR0ZXJzLCBvYnNlcnZlcnMgfSA9IGNvbmZpZ1twcm9wZXJ0eUtleV07XG4gICAgbGV0IG9sZFZhbHVlO1xuICAgIGlmIChzZXR0ZXJzLnNvbWUoKGYpID0+IGYubGVuZ3RoID4gMikpIHtcbiAgICAgIG9sZFZhbHVlID0gcHJldkdldCA/IHByZXZHZXQuY2FsbCh0aGlzKSA6IHZhbHVlc01hcC5nZXQodGhpcyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtRm4gb2Ygc2V0dGVycykge1xuICAgICAgdmFsdWUgPSB0cmFuc2Zvcm1Gbih0aGlzLCBwcm9wZXJ0eUtleU9yU3ltYm9sLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgaWYgKHZhbHVlID09PSBCUkVBS19UUkFOU0ZPUk1fQ0hBSU4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldlNldCkge1xuICAgICAgcHJldlNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzTWFwLnNldCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXJGbiBvZiBvYnNlcnZlcnMpIHtcbiAgICAgIG9ic2VydmVyRm4odGhpcywgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICB9XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5T3JTeW1ib2wsIHtcbiAgICBzZXQ6IHNldHRlcixcbiAgICBnZXQ6IGdldHRlcixcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBjb25maWdbcHJvcGVydHlLZXldO1xufVxuZnVuY3Rpb24gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KHNldFRyYW5zZm9ybSwgZ2V0VHJhbnNmb3JtLCBjb25maWdNZXRhZGF0YSkge1xuICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlLZXlPclN5bWJvbCkgPT4ge1xuICAgIGNvbnN0IGNvbmZpZyA9IGluaXRpYWxpc2VDb25maWcodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sKTtcbiAgICBjb25maWcuc2V0dGVycy5wdXNoKHNldFRyYW5zZm9ybSk7XG4gICAgaWYgKGdldFRyYW5zZm9ybSkge1xuICAgICAgY29uZmlnLmdldHRlcnMudW5zaGlmdChnZXRUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAoY29uZmlnTWV0YWRhdGEpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBjb25maWdNZXRhZGF0YSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYWRkT2JzZXJ2ZXJUb0luc3RhbmNlUHJvcGVydHkoc2V0T2JzZXJ2ZXIpIHtcbiAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5S2V5T3JTeW1ib2wpID0+IHtcbiAgICBpbml0aWFsaXNlQ29uZmlnKHRhcmdldCwgcHJvcGVydHlLZXlPclN5bWJvbCkub2JzZXJ2ZXJzLnB1c2goc2V0T2JzZXJ2ZXIpO1xuICB9O1xufVxuZnVuY3Rpb24gaXNEZWNvcmF0ZWRPYmplY3QodGFyZ2V0KSB7XG4gIHJldHVybiB0eXBlb2YgdGFyZ2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIENPTkZJR19LRVkgaW4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gbGlzdERlY29yYXRlZFByb3BlcnRpZXModGFyZ2V0KSB7XG4gIGNvbnN0IHRhcmdldHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB3aGlsZSAoaXNEZWNvcmF0ZWRPYmplY3QodGFyZ2V0KSkge1xuICAgIHRhcmdldHMuYWRkKHRhcmdldD8uW0NPTkZJR19LRVldKTtcbiAgICB0YXJnZXQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbSh0YXJnZXRzKS5mbGF0TWFwKChjb25maWdNYXApID0+IE9iamVjdC5rZXlzKGNvbmZpZ01hcCkpO1xufVxuZnVuY3Rpb24gZXh0cmFjdERlY29yYXRlZFByb3BlcnRpZXModGFyZ2V0KSB7XG4gIHJldHVybiBsaXN0RGVjb3JhdGVkUHJvcGVydGllcyh0YXJnZXQpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICByZXN1bHRba2V5XSA9IHRhcmdldFtrZXldID8/IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gZXh0cmFjdERlY29yYXRlZFByb3BlcnR5TWV0YWRhdGEodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sKSB7XG4gIGNvbnN0IHByb3BlcnR5S2V5ID0gcHJvcGVydHlLZXlPclN5bWJvbC50b1N0cmluZygpO1xuICB3aGlsZSAoaXNEZWNvcmF0ZWRPYmplY3QodGFyZ2V0KSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRhcmdldFtDT05GSUdfS0VZXTtcbiAgICBpZiAoT2JqZWN0Lmhhc093bihjb25maWcsIHByb3BlcnR5S2V5KSkge1xuICAgICAgcmV0dXJuIGNvbmZpZ1twcm9wZXJ0eUtleV07XG4gICAgfVxuICAgIHRhcmdldCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvb2JqZWN0LnRzXG5mdW5jdGlvbiBvYmplY3RzRXF1YWwoYSwgYikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShiKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBhLmV2ZXJ5KChhdiwgaSkgPT4gb2JqZWN0c0VxdWFsKGF2LCBiW2ldKSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChhKSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChiKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gb2JqZWN0c0VxdWFsV2l0aChhLCBiLCBvYmplY3RzRXF1YWwpO1xuICB9XG4gIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gb2JqZWN0c0VxdWFsV2l0aChhLCBiLCBjbXAyKSB7XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGIpKSB7XG4gICAgaWYgKCEoa2V5IGluIGEpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGEpKSB7XG4gICAgaWYgKCEoa2V5IGluIGIpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghY21wMihhW2tleV0sIGJba2V5XSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKC4uLnNvdXJjZXMpIHtcbiAgY29uc3QgdGFyZ2V0ID0ge307XG4gIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHNvdXJjZSkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBrZXlzID0gaXNEZWNvcmF0ZWRPYmplY3Qoc291cmNlKSA/IGxpc3REZWNvcmF0ZWRQcm9wZXJ0aWVzKHNvdXJjZSkgOiBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlRGVmYXVsdHModGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtrZXldID8/ICh0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIG1lcmdlQXJyYXlEZWZhdWx0cyhkYXRhQXJyYXksIC4uLml0ZW1EZWZhdWx0cykge1xuICBpZiAoaXRlbURlZmF1bHRzICYmIGlzQXJyYXkoZGF0YUFycmF5KSkge1xuICAgIHJldHVybiBkYXRhQXJyYXkubWFwKChpdGVtKSA9PiBtZXJnZURlZmF1bHRzKGl0ZW0sIC4uLml0ZW1EZWZhdWx0cykpO1xuICB9XG4gIHJldHVybiBkYXRhQXJyYXk7XG59XG5mdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0MiwgbWFwcGVyKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvYmplY3QyKS5yZWR1Y2UoXG4gICAgKHJlc3VsdCwgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICByZXN1bHRba2V5XSA9IG1hcHBlcih2YWx1ZSwga2V5LCBvYmplY3QyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICB7fVxuICApO1xufVxuZnVuY3Rpb24gd2l0aG91dChvYmplY3QyLCBrZXlzKSB7XG4gIGNvbnN0IGNsb25lMiA9IHsgLi4ub2JqZWN0MiB9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgZGVsZXRlIGNsb25lMltrZXldO1xuICB9XG4gIHJldHVybiBjbG9uZTI7XG59XG5mdW5jdGlvbiBnZXRQYXRoKG9iamVjdDIsIHBhdGgpIHtcbiAgY29uc3QgcGF0aEFycmF5ID0gaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgcmV0dXJuIHBhdGhBcnJheS5yZWR1Y2UoKHZhbHVlLCBwYXRoS2V5KSA9PiB2YWx1ZVtwYXRoS2V5XSwgb2JqZWN0Mik7XG59XG52YXIgU0tJUF9KU19CVUlMVElOUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcIl9fcHJvdG9fX1wiLCBcImNvbnN0cnVjdG9yXCIsIFwicHJvdG90eXBlXCJdKTtcbmZ1bmN0aW9uIHNldFBhdGgob2JqZWN0MiwgcGF0aCwgbmV3VmFsdWUpIHtcbiAgY29uc3QgcGF0aEFycmF5ID0gaXNBcnJheShwYXRoKSA/IHBhdGguc2xpY2UoKSA6IHBhdGguc3BsaXQoXCIuXCIpO1xuICBjb25zdCBsYXN0S2V5ID0gcGF0aEFycmF5LnBvcCgpO1xuICBpZiAocGF0aEFycmF5LnNvbWUoKHApID0+IFNLSVBfSlNfQlVJTFRJTlMuaGFzKHApKSlcbiAgICByZXR1cm47XG4gIGNvbnN0IGxhc3RPYmplY3QgPSBwYXRoQXJyYXkucmVkdWNlKCh2YWx1ZSwgcGF0aEtleSkgPT4gdmFsdWVbcGF0aEtleV0sIG9iamVjdDIpO1xuICBsYXN0T2JqZWN0W2xhc3RLZXldID0gbmV3VmFsdWU7XG4gIHJldHVybiBsYXN0T2JqZWN0W2xhc3RLZXldO1xufVxuZnVuY3Rpb24gcGFydGlhbEFzc2lnbihrZXlzVG9Db3B5LCB0YXJnZXQsIHNvdXJjZSkge1xuICBpZiAoc291cmNlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXNUb0NvcHkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gZGVlcEZyZWV6ZShvYmopIHtcbiAgT2JqZWN0LmZyZWV6ZShvYmopO1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IG9ialtwcm9wXTtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgIU9iamVjdC5pc0Zyb3plbih2YWx1ZSkpIHtcbiAgICAgIGRlZXBGcmVlemUodmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvYmo7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vdGlvbi9lYXNpbmcudHNcbnZhciBlYXNpbmdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZWFzaW5nX2V4cG9ydHMsIHtcbiAgZWFzZUluOiAoKSA9PiBlYXNlSW4sXG4gIGVhc2VJbk91dDogKCkgPT4gZWFzZUluT3V0LFxuICBlYXNlSW5PdXRRdWFkOiAoKSA9PiBlYXNlSW5PdXRRdWFkLFxuICBlYXNlSW5RdWFkOiAoKSA9PiBlYXNlSW5RdWFkLFxuICBlYXNlT3V0OiAoKSA9PiBlYXNlT3V0LFxuICBlYXNlT3V0UXVhZDogKCkgPT4gZWFzZU91dFF1YWQsXG4gIGludmVyc2VFYXNlT3V0OiAoKSA9PiBpbnZlcnNlRWFzZU91dCxcbiAgbGluZWFyOiAoKSA9PiBsaW5lYXJcbn0pO1xudmFyIGxpbmVhciA9IChuKSA9PiBuO1xudmFyIGVhc2VJbiA9IChuKSA9PiAxIC0gTWF0aC5jb3MobiAqIE1hdGguUEkgLyAyKTtcbnZhciBlYXNlT3V0ID0gKG4pID0+IE1hdGguc2luKG4gKiBNYXRoLlBJIC8gMik7XG52YXIgZWFzZUluT3V0ID0gKG4pID0+IC0oTWF0aC5jb3MobiAqIE1hdGguUEkpIC0gMSkgLyAyO1xudmFyIGVhc2VJblF1YWQgPSAobikgPT4gbiAqIG47XG52YXIgZWFzZU91dFF1YWQgPSAobikgPT4gMSAtICgxIC0gbikgKiogMjtcbnZhciBlYXNlSW5PdXRRdWFkID0gKG4pID0+IG4gPCAwLjUgPyAyICogbiAqIG4gOiAxIC0gKC0yICogbiArIDIpICoqIDIgLyAyO1xudmFyIGludmVyc2VFYXNlT3V0ID0gKHgpID0+IDIgKiBNYXRoLmFzaW4oeCkgLyBNYXRoLlBJO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb3Rpb24vYW5pbWF0aW9uLnRzXG52YXIgUVVJQ0tfVFJBTlNJVElPTiA9IDAuMjtcbnZhciBQSEFTRV9PUkRFUiA9IFtcImluaXRpYWxcIiwgXCJyZW1vdmVcIiwgXCJ1cGRhdGVcIiwgXCJhZGRcIiwgXCJ0cmFpbGluZ1wiLCBcImVuZFwiLCBcIm5vbmVcIl07XG52YXIgUEhBU0VfTUVUQURBVEEgPSB7XG4gIGluaXRpYWw6IHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMSxcbiAgICBhbmltYXRpb25EZWxheTogMFxuICB9LFxuICBhZGQ6IHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMC4yNSxcbiAgICBhbmltYXRpb25EZWxheTogMC43NVxuICB9LFxuICByZW1vdmU6IHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMC4yNSxcbiAgICBhbmltYXRpb25EZWxheTogMFxuICB9LFxuICB1cGRhdGU6IHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMC41LFxuICAgIGFuaW1hdGlvbkRlbGF5OiAwLjI1XG4gIH0sXG4gIHRyYWlsaW5nOiB7XG4gICAgYW5pbWF0aW9uRHVyYXRpb246IFFVSUNLX1RSQU5TSVRJT04sXG4gICAgYW5pbWF0aW9uRGVsYXk6IDEsXG4gICAgc2tpcElmTm9FYXJsaWVyQW5pbWF0aW9uczogdHJ1ZVxuICB9LFxuICBlbmQ6IHtcbiAgICBhbmltYXRpb25EZWxheTogMSArIFFVSUNLX1RSQU5TSVRJT04sXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDAsXG4gICAgc2tpcElmTm9FYXJsaWVyQW5pbWF0aW9uczogdHJ1ZVxuICB9LFxuICBub25lOiB7XG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDAsXG4gICAgYW5pbWF0aW9uRGVsYXk6IDBcbiAgfVxufTtcbnZhciBSZXBlYXRUeXBlID0gLyogQF9fUFVSRV9fICovICgoUmVwZWF0VHlwZTIpID0+IHtcbiAgUmVwZWF0VHlwZTJbXCJMb29wXCJdID0gXCJsb29wXCI7XG4gIFJlcGVhdFR5cGUyW1wiUmV2ZXJzZVwiXSA9IFwicmV2ZXJzZVwiO1xuICByZXR1cm4gUmVwZWF0VHlwZTI7XG59KShSZXBlYXRUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIGlzTm9kZUFycmF5KGFycmF5Mikge1xuICByZXR1cm4gYXJyYXkyLmV2ZXJ5KChuKSA9PiBuIGluc3RhbmNlb2YgTm9kZSk7XG59XG5mdW5jdGlvbiBkZWNvbnN0cnVjdFNlbGVjdGlvbnNPck5vZGVzKHNlbGVjdGlvbnNPck5vZGVzKSB7XG4gIHJldHVybiBpc05vZGVBcnJheShzZWxlY3Rpb25zT3JOb2RlcykgPyB7IG5vZGVzOiBzZWxlY3Rpb25zT3JOb2Rlcywgc2VsZWN0aW9uczogW10gfSA6IHsgbm9kZXM6IFtdLCBzZWxlY3Rpb25zOiBzZWxlY3Rpb25zT3JOb2RlcyB9O1xufVxuZnVuY3Rpb24gYW5pbWF0aW9uVmFsdWVzRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeSgodiwgaSkgPT4gYW5pbWF0aW9uVmFsdWVzRXF1YWwodiwgYltpXSkpO1xuICB9IGVsc2UgaWYgKGlzSW50ZXJwb2xhdGluZyhhKSAmJiBpc0ludGVycG9sYXRpbmcoYikpIHtcbiAgICByZXR1cm4gYS5lcXVhbHMoYik7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChhKSAmJiBpc1BsYWluT2JqZWN0KGIpKSB7XG4gICAgcmV0dXJuIG9iamVjdHNFcXVhbFdpdGgoYSwgYiwgYW5pbWF0aW9uVmFsdWVzRXF1YWwpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBBbmltYXRpb24gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLmlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICB0aGlzLmVsYXBzZWQgPSAwO1xuICAgIHRoaXMuaXRlcmF0aW9uID0gMDtcbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNSZXZlcnNlID0gZmFsc2U7XG4gICAgdGhpcy5pZCA9IG9wdHMuaWQ7XG4gICAgdGhpcy5ncm91cElkID0gb3B0cy5ncm91cElkO1xuICAgIHRoaXMuYXV0b3BsYXkgPSBvcHRzLmF1dG9wbGF5ID8/IHRydWU7XG4gICAgdGhpcy5lYXNlID0gb3B0cy5lYXNlID8/IGxpbmVhcjtcbiAgICB0aGlzLnBoYXNlID0gb3B0cy5waGFzZTtcbiAgICBjb25zdCBkdXJhdGlvblByb3BvcnRpb24gPSBvcHRzLmR1cmF0aW9uID8/IFBIQVNFX01FVEFEQVRBW3RoaXMucGhhc2VdLmFuaW1hdGlvbkR1cmF0aW9uO1xuICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvblByb3BvcnRpb24gKiBvcHRzLmRlZmF1bHREdXJhdGlvbjtcbiAgICB0aGlzLmRlbGF5ID0gKG9wdHMuZGVsYXkgPz8gMCkgKiBvcHRzLmRlZmF1bHREdXJhdGlvbjtcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBvcHRzLm9uQ29tcGxldGU7XG4gICAgdGhpcy5vblBsYXkgPSBvcHRzLm9uUGxheTtcbiAgICB0aGlzLm9uU3RvcCA9IG9wdHMub25TdG9wO1xuICAgIHRoaXMub25VcGRhdGUgPSBvcHRzLm9uVXBkYXRlO1xuICAgIHRoaXMuaW50ZXJwb2xhdGUgPSB0aGlzLmNyZWF0ZUludGVycG9sYXRvcihvcHRzLmZyb20sIG9wdHMudG8pO1xuICAgIHRoaXMuZnJvbSA9IG9wdHMuZnJvbTtcbiAgICBpZiAob3B0cy5za2lwID09PSB0cnVlKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlPy4ob3B0cy50bywgZmFsc2UsIHRoaXMpO1xuICAgICAgdGhpcy5vblN0b3A/Lih0aGlzKTtcbiAgICAgIHRoaXMub25Db21wbGV0ZT8uKHRoaXMpO1xuICAgICAgdGhpcy5pc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdHMuY29sbGFwc2FibGUgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmR1cmF0aW9uID0gdGhpcy5jaGVja0NvbGxhcHNlKG9wdHMsIHRoaXMuZHVyYXRpb24pO1xuICAgIH1cbiAgfVxuICBjaGVja0NvbGxhcHNlKG9wdHMsIGNhbGN1bGF0ZWREdXJhdGlvbikge1xuICAgIHJldHVybiBhbmltYXRpb25WYWx1ZXNFcXVhbChvcHRzLmZyb20sIG9wdHMudG8pID8gMCA6IGNhbGN1bGF0ZWREdXJhdGlvbjtcbiAgfVxuICBwbGF5KGluaXRpYWxVcGRhdGUgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzUGxheWluZyB8fCB0aGlzLmlzQ29tcGxldGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuICAgIHRoaXMub25QbGF5Py4odGhpcyk7XG4gICAgaWYgKCF0aGlzLmF1dG9wbGF5KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuYXV0b3BsYXkgPSBmYWxzZTtcbiAgICBpZiAoIWluaXRpYWxVcGRhdGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5vblVwZGF0ZT8uKHRoaXMuZnJvbSwgdHJ1ZSwgdGhpcyk7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5pc0NvbXBsZXRlKSB7XG4gICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgdGhpcy5vblN0b3A/Lih0aGlzKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKHRpbWUyKSB7XG4gICAgaWYgKHRoaXMuaXNDb21wbGV0ZSlcbiAgICAgIHJldHVybiB0aW1lMjtcbiAgICBpZiAoIXRoaXMuaXNQbGF5aW5nICYmIHRoaXMuYXV0b3BsYXkpIHtcbiAgICAgIHRoaXMucGxheSh0cnVlKTtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNFbGFwc2VkID0gdGhpcy5lbGFwc2VkO1xuICAgIHRoaXMuZWxhcHNlZCArPSB0aW1lMjtcbiAgICBpZiAodGhpcy5kZWxheSA+IHRoaXMuZWxhcHNlZClcbiAgICAgIHJldHVybiAwO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnRlcnBvbGF0ZSh0aGlzLmlzUmV2ZXJzZSA/IDEgLSB0aGlzLmRlbHRhIDogdGhpcy5kZWx0YSk7XG4gICAgdGhpcy5vblVwZGF0ZT8uKHZhbHVlLCBmYWxzZSwgdGhpcyk7XG4gICAgY29uc3QgdG90YWxEdXJhdGlvbiA9IHRoaXMuZGVsYXkgKyB0aGlzLmR1cmF0aW9uO1xuICAgIGlmICh0aGlzLmVsYXBzZWQgPj0gdG90YWxEdXJhdGlvbikge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgdGhpcy5vbkNvbXBsZXRlPy4odGhpcyk7XG4gICAgICByZXR1cm4gdGltZTIgLSAodG90YWxEdXJhdGlvbiAtIHByZXZpb3VzRWxhcHNlZCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGdldCBkZWx0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5lYXNlKGNsYW1wKDAsICh0aGlzLmVsYXBzZWQgLSB0aGlzLmRlbGF5KSAvIHRoaXMuZHVyYXRpb24sIDEpKTtcbiAgfVxuICBjcmVhdGVJbnRlcnBvbGF0b3IoZnJvbTMsIHRvKSB7XG4gICAgaWYgKHR5cGVvZiB0byAhPT0gXCJvYmplY3RcIiB8fCBpc0ludGVycG9sYXRpbmcodG8pKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnBvbGF0ZVZhbHVlKGZyb20zLCB0byk7XG4gICAgfVxuICAgIGNvbnN0IGludGVycG9sYXRvckVudHJpZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0bykpIHtcbiAgICAgIGNvbnN0IGludGVycG9sYXRvciA9IHRoaXMuaW50ZXJwb2xhdGVWYWx1ZShmcm9tM1trZXldLCB0b1trZXldKTtcbiAgICAgIGlmIChpbnRlcnBvbGF0b3IgIT0gbnVsbCkge1xuICAgICAgICBpbnRlcnBvbGF0b3JFbnRyaWVzLnB1c2goW2tleSwgaW50ZXJwb2xhdG9yXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoZCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIGludGVycG9sYXRvcl0gb2YgaW50ZXJwb2xhdG9yRW50cmllcykge1xuICAgICAgICByZXN1bHRba2V5XSA9IGludGVycG9sYXRvcihkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuICBpbnRlcnBvbGF0ZVZhbHVlKGEsIGIpIHtcbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoaXNJbnRlcnBvbGF0aW5nKGEpKSB7XG4gICAgICByZXR1cm4gKGQpID0+IGFbaW50ZXJwb2xhdGVdKGIsIGQpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgc3dpdGNoICh0eXBlb2YgYSkge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlTnVtYmVyKGEsIGIpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlQ29sb3IoYSwgYik7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gaW50ZXJwb2xhdGUgdmFsdWVzOiAke2F9LCAke2J9YCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vdGlvbi9mcm9tVG9Nb3Rpb24udHNcbnZhciBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HID0ge1xuICBhZGRlZDogXCJhZGRcIixcbiAgdXBkYXRlZDogXCJ1cGRhdGVcIixcbiAgcmVtb3ZlZDogXCJyZW1vdmVcIixcbiAgdW5rbm93bjogXCJpbml0aWFsXCIsXG4gIFwibm8tb3BcIjogXCJub25lXCJcbn07XG5mdW5jdGlvbiBmcm9tVG9Nb3Rpb24oZ3JvdXBJZCwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIHNlbGVjdGlvbnNPck5vZGVzLCBmbnMsIGdldERhdHVtSWQsIGRpZmYyKSB7XG4gIGNvbnN0IHsgZnJvbUZuLCB0b0ZuLCBhcHBseUZuID0gKG5vZGUsIHByb3BzKSA9PiBub2RlLnNldFByb3BlcnRpZXMocHJvcHMpIH0gPSBmbnM7XG4gIGNvbnN0IHsgbm9kZXMsIHNlbGVjdGlvbnMgfSA9IGRlY29uc3RydWN0U2VsZWN0aW9uc09yTm9kZXMoc2VsZWN0aW9uc09yTm9kZXMpO1xuICBjb25zdCBwcm9jZXNzTm9kZXMgPSAobGl2ZU5vZGVzLCBzdWJOb2RlcykgPT4ge1xuICAgIGxldCBwcmV2RnJvbVByb3BzO1xuICAgIGxldCBsaXZlTm9kZUluZGV4ID0gMDtcbiAgICBsZXQgbm9kZUluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc3ViTm9kZXMpIHtcbiAgICAgIGNvbnN0IGlzTGl2ZSA9IGxpdmVOb2Rlc1tsaXZlTm9kZUluZGV4XSA9PT0gbm9kZTtcbiAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgbGFzdDogbm9kZUluZGV4ID49IHN1Yk5vZGVzLmxlbmd0aCAtIDEsXG4gICAgICAgIGxhc3RMaXZlOiBsaXZlTm9kZUluZGV4ID49IGxpdmVOb2Rlcy5sZW5ndGggLSAxLFxuICAgICAgICBwcmV2OiBzdWJOb2Rlc1tub2RlSW5kZXggLSAxXSxcbiAgICAgICAgcHJldkZyb21Qcm9wcyxcbiAgICAgICAgcHJldkxpdmU6IGxpdmVOb2Rlc1tsaXZlTm9kZUluZGV4IC0gMV0sXG4gICAgICAgIG5leHQ6IHN1Yk5vZGVzW25vZGVJbmRleCArIDFdLFxuICAgICAgICBuZXh0TGl2ZTogbGl2ZU5vZGVzW2xpdmVOb2RlSW5kZXggKyAoaXNMaXZlID8gMSA6IDApXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGFuaW1hdGlvbklkID0gYCR7Z3JvdXBJZH1fJHtzdWJJZH1fJHtub2RlLmlkfWA7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLnN0b3BCeUFuaW1hdGlvbklkKGFuaW1hdGlvbklkKTtcbiAgICAgIGxldCBzdGF0dXMgPSBcInVua25vd25cIjtcbiAgICAgIGlmICghaXNMaXZlKSB7XG4gICAgICAgIHN0YXR1cyA9IFwicmVtb3ZlZFwiO1xuICAgICAgfSBlbHNlIGlmIChnZXREYXR1bUlkICYmIGRpZmYyKSB7XG4gICAgICAgIHN0YXR1cyA9IGNhbGN1bGF0ZVN0YXR1cyhub2RlLCBub2RlLmRhdHVtLCBnZXREYXR1bUlkLCBkaWZmMik7XG4gICAgICB9XG4gICAgICBub2RlLnRyYW5zaXRpb25PdXQgPSBzdGF0dXMgPT09IFwicmVtb3ZlZFwiO1xuICAgICAgY29uc3QgeyBwaGFzZSwgc3RhcnQ6IHN0YXJ0MiwgZmluaXNoLCBkZWxheSwgZHVyYXRpb24sIC4uLmZyb20zIH0gPSBmcm9tRm4obm9kZSwgbm9kZS5kYXR1bSwgc3RhdHVzLCBjdHgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwaGFzZTogdG9QaGFzZSxcbiAgICAgICAgc3RhcnQ6IHRvU3RhcnQsXG4gICAgICAgIGZpbmlzaDogdG9GaW5pc2gsXG4gICAgICAgIGRlbGF5OiB0b0RlbGF5LFxuICAgICAgICBkdXJhdGlvbjogdG9EdXJhdGlvbixcbiAgICAgICAgLi4udG9cbiAgICAgIH0gPSB0b0ZuKG5vZGUsIG5vZGUuZGF0dW0sIHN0YXR1cywgY3R4KTtcbiAgICAgIGNvbnN0IGNvbGxhcHNhYmxlID0gZmluaXNoID09IG51bGw7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLmFuaW1hdGUoe1xuICAgICAgICBpZDogYW5pbWF0aW9uSWQsXG4gICAgICAgIGdyb3VwSWQsXG4gICAgICAgIHBoYXNlOiBwaGFzZSA/PyB0b1BoYXNlID8/IFwidXBkYXRlXCIsXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiA/PyB0b0R1cmF0aW9uLFxuICAgICAgICBkZWxheTogZGVsYXkgPz8gdG9EZWxheSxcbiAgICAgICAgZnJvbTogZnJvbTMsXG4gICAgICAgIHRvLFxuICAgICAgICBlYXNlOiBlYXNlT3V0LFxuICAgICAgICBjb2xsYXBzYWJsZSxcbiAgICAgICAgb25QbGF5OiAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRQcm9wcyA9IHsgLi4uc3RhcnQyLCAuLi50b1N0YXJ0LCAuLi5mcm9tMyB9O1xuICAgICAgICAgIGFwcGx5Rm4obm9kZSwgc3RhcnRQcm9wcywgXCJzdGFydFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25VcGRhdGUocHJvcHMpIHtcbiAgICAgICAgICBhcHBseUZuKG5vZGUsIHByb3BzLCBcInVwZGF0ZVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TdG9wOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZW5kUHJvcHMgPSB7XG4gICAgICAgICAgICAuLi5zdGFydDIsXG4gICAgICAgICAgICAuLi50b1N0YXJ0LFxuICAgICAgICAgICAgLi4uZnJvbTMsXG4gICAgICAgICAgICAuLi50byxcbiAgICAgICAgICAgIC4uLmZpbmlzaCxcbiAgICAgICAgICAgIC4uLnRvRmluaXNoXG4gICAgICAgICAgfTtcbiAgICAgICAgICBhcHBseUZuKG5vZGUsIGVuZFByb3BzLCBcImVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoaXNMaXZlKSB7XG4gICAgICAgIGxpdmVOb2RlSW5kZXgrKztcbiAgICAgIH1cbiAgICAgIG5vZGVJbmRleCsrO1xuICAgICAgcHJldkZyb21Qcm9wcyA9IGZyb20zO1xuICAgIH1cbiAgfTtcbiAgbGV0IHNlbGVjdGlvbkluZGV4ID0gMDtcbiAgZm9yIChjb25zdCBzZWxlY3Rpb24gb2Ygc2VsZWN0aW9ucykge1xuICAgIGNvbnN0IHNlbGVjdGlvbk5vZGVzID0gc2VsZWN0aW9uLm5vZGVzKCk7XG4gICAgY29uc3QgbGl2ZU5vZGVzID0gc2VsZWN0aW9uTm9kZXMuZmlsdGVyKChuKSA9PiAhc2VsZWN0aW9uLmlzR2FyYmFnZShuKSk7XG4gICAgcHJvY2Vzc05vZGVzKGxpdmVOb2Rlcywgc2VsZWN0aW9uTm9kZXMpO1xuICAgIGFuaW1hdGlvbk1hbmFnZXIuYW5pbWF0ZSh7XG4gICAgICBpZDogYCR7Z3JvdXBJZH1fJHtzdWJJZH1fc2VsZWN0aW9uXyR7c2VsZWN0aW9uSW5kZXh9YCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBwaGFzZTogXCJlbmRcIixcbiAgICAgIGZyb206IDAsXG4gICAgICB0bzogMSxcbiAgICAgIGVhc2U6IGVhc2VPdXQsXG4gICAgICBvblN0b3AoKSB7XG4gICAgICAgIHNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2VsZWN0aW9uSW5kZXgrKztcbiAgfVxuICBwcm9jZXNzTm9kZXMobm9kZXMsIG5vZGVzKTtcbn1cbmZ1bmN0aW9uIHN0YXRpY0Zyb21Ub01vdGlvbihncm91cElkLCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgc2VsZWN0aW9uc09yTm9kZXMsIGZyb20zLCB0bywgZXh0cmFPcHRzKSB7XG4gIGNvbnN0IHsgbm9kZXMsIHNlbGVjdGlvbnMgfSA9IGRlY29uc3RydWN0U2VsZWN0aW9uc09yTm9kZXMoc2VsZWN0aW9uc09yTm9kZXMpO1xuICBjb25zdCB7IHN0YXJ0OiBzdGFydDIsIGZpbmlzaCwgcGhhc2UgfSA9IGV4dHJhT3B0cztcbiAgYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlKHtcbiAgICBpZDogYCR7Z3JvdXBJZH1fJHtzdWJJZH1gLFxuICAgIGdyb3VwSWQsXG4gICAgcGhhc2U6IHBoYXNlID8/IFwidXBkYXRlXCIsXG4gICAgZnJvbTogZnJvbTMsXG4gICAgdG8sXG4gICAgZWFzZTogZWFzZU91dCxcbiAgICBvblBsYXk6ICgpID0+IHtcbiAgICAgIGlmICghc3RhcnQyKVxuICAgICAgICByZXR1cm47XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHN0YXJ0Mik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzZWxlY3Rpb24ubm9kZXMoKSkge1xuICAgICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhzdGFydDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvblVwZGF0ZShwcm9wcykge1xuICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhwcm9wcyk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzZWxlY3Rpb24ubm9kZXMoKSkge1xuICAgICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9uU3RvcDogKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyh7IC4uLnRvLCAuLi5maW5pc2ggfSk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzZWxlY3Rpb24ubm9kZXMoKSkge1xuICAgICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyh7IC4uLnRvLCAuLi5maW5pc2ggfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlU3RhdHVzKG5vZGUsIGRhdHVtLCBnZXREYXR1bUlkLCBkaWZmMikge1xuICBjb25zdCBpZCA9IGdldERhdHVtSWQobm9kZSwgZGF0dW0pO1xuICBpZiAoZGlmZjIuYWRkZWQuaGFzKGlkKSkge1xuICAgIHJldHVybiBcImFkZGVkXCI7XG4gIH1cbiAgaWYgKGRpZmYyLnJlbW92ZWQuaGFzKGlkKSkge1xuICAgIHJldHVybiBcInJlbW92ZWRcIjtcbiAgfVxuICByZXR1cm4gXCJ1cGRhdGVkXCI7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL2Fic3RyYWN0U2NhbGUudHNcbnZhciBBYnN0cmFjdFNjYWxlID0gY2xhc3Mge1xuICB0aWNrcyhfdGlja3MsIF9kb21haW4sIF92aXNpYmxlUmFuZ2UpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIG5pY2VEb21haW4oX3RpY2tzLCBkb21haW4gPSB0aGlzLmRvbWFpbikge1xuICAgIHJldHVybiBkb21haW47XG4gIH1cbiAgdGlja0Zvcm1hdHRlcihfcGFyYW1zKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBkYXR1bUZvcm1hdHRlcihfcGFyYW1zKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBnZXQgYmFuZHdpZHRoKCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgZ2V0IHN0ZXAoKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBnZXQgaW5zZXQoKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NhbGUvY29udGludW91c1NjYWxlLnRzXG52YXIgX0NvbnRpbnVvdXNTY2FsZSA9IGNsYXNzIF9Db250aW51b3VzU2NhbGUgZXh0ZW5kcyBBYnN0cmFjdFNjYWxlIHtcbiAgY29uc3RydWN0b3IoZG9tYWluID0gW10sIHJhbmdlMyA9IFtdKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRvbWFpbiA9IGRvbWFpbjtcbiAgICB0aGlzLnJhbmdlID0gcmFuZ2UzO1xuICAgIHRoaXMuZGVmYXVsdENsYW1wID0gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgX0NvbnRpbnVvdXNTY2FsZTtcbiAgfVxuICBub3JtYWxpemVEb21haW5zKC4uLmRvbWFpbnMpIHtcbiAgICBsZXQgbWluO1xuICAgIGxldCBtaW5WYWx1ZSA9IEluZmluaXR5O1xuICAgIGxldCBtYXg7XG4gICAgbGV0IG1heFZhbHVlID0gLUluZmluaXR5O1xuICAgIGZvciAoY29uc3QgZG9tYWluIG9mIGRvbWFpbnMpIHtcbiAgICAgIGZvciAoY29uc3QgZCBvZiBkb21haW4pIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkLnZhbHVlT2YoKTtcbiAgICAgICAgaWYgKHZhbHVlIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICBtaW5WYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIG1pbiA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICBtYXhWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIG1heCA9IGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbiAhPSBudWxsICYmIG1heCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBkb21haW4gPSBbbWluLCBtYXhdO1xuICAgICAgcmV0dXJuIHsgZG9tYWluLCBhbmltYXRhYmxlOiB0cnVlIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IGRvbWFpbjogW10sIGFuaW1hdGFibGU6IGZhbHNlIH07XG4gICAgfVxuICB9XG4gIHRyYW5zZm9ybSh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgdHJhbnNmb3JtSW52ZXJ0KHgpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuICBjYWxjQmFuZHdpZHRoKHNtYWxsZXN0SW50ZXJ2YWwgPSAxKSB7XG4gICAgY29uc3QgeyBkb21haW4gfSA9IHRoaXM7XG4gICAgY29uc3QgcmFuZ2VEaXN0YW5jZSA9IHRoaXMuZ2V0UGl4ZWxSYW5nZSgpO1xuICAgIGlmIChkb21haW4ubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHJhbmdlRGlzdGFuY2U7XG4gICAgY29uc3QgaW50ZXJ2YWxzID0gTWF0aC5hYnMoZG9tYWluWzFdLnZhbHVlT2YoKSAtIGRvbWFpblswXS52YWx1ZU9mKCkpIC8gc21hbGxlc3RJbnRlcnZhbCArIDE7XG4gICAgY29uc3QgbWF4QmFuZHMgPSBNYXRoLmZsb29yKHJhbmdlRGlzdGFuY2UpO1xuICAgIGNvbnN0IGJhbmRzID0gTWF0aC5taW4oaW50ZXJ2YWxzLCBtYXhCYW5kcyk7XG4gICAgcmV0dXJuIHJhbmdlRGlzdGFuY2UgLyBNYXRoLm1heCgxLCBiYW5kcyk7XG4gIH1cbiAgY29udmVydCh2YWx1ZSwgY2xhbXAyID0gdGhpcy5kZWZhdWx0Q2xhbXApIHtcbiAgICBjb25zdCB7IGRvbWFpbiB9ID0gdGhpcztcbiAgICBpZiAoIWRvbWFpbiB8fCBkb21haW4ubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3QgZDAgPSBOdW1iZXIodGhpcy50cmFuc2Zvcm0oZG9tYWluWzBdKSk7XG4gICAgY29uc3QgZDEgPSBOdW1iZXIodGhpcy50cmFuc2Zvcm0oZG9tYWluWzFdKSk7XG4gICAgY29uc3QgeCA9IE51bWJlcih0aGlzLnRyYW5zZm9ybSh2YWx1ZSkpO1xuICAgIGNvbnN0IHsgcmFuZ2U6IHJhbmdlMyB9ID0gdGhpcztcbiAgICBjb25zdCBbcjAsIHIxXSA9IHJhbmdlMztcbiAgICBpZiAoY2xhbXAyKSB7XG4gICAgICBjb25zdCBbc3RhcnQyLCBzdG9wXSA9IGZpbmRNaW5NYXgoW2QwLCBkMV0pO1xuICAgICAgaWYgKHggPCBzdGFydDIpIHtcbiAgICAgICAgcmV0dXJuIHIwO1xuICAgICAgfSBlbHNlIGlmICh4ID4gc3RvcCkge1xuICAgICAgICByZXR1cm4gcjE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkMCA9PT0gZDEpIHtcbiAgICAgIHJldHVybiAocjAgKyByMSkgLyAyO1xuICAgIH0gZWxzZSBpZiAoeCA9PT0gZDApIHtcbiAgICAgIHJldHVybiByMDtcbiAgICB9IGVsc2UgaWYgKHggPT09IGQxKSB7XG4gICAgICByZXR1cm4gcjE7XG4gICAgfVxuICAgIHJldHVybiByMCArICh4IC0gZDApIC8gKGQxIC0gZDApICogKHIxIC0gcjApO1xuICB9XG4gIGludmVydCh4LCBfbmVhcmVzdCkge1xuICAgIGNvbnN0IGRvbWFpbiA9IHRoaXMuZG9tYWluLm1hcCgoZDIpID0+IHRoaXMudHJhbnNmb3JtKGQyKSk7XG4gICAgY29uc3QgW2QwLCBkMV0gPSBkb21haW47XG4gICAgY29uc3QgeyByYW5nZTogcmFuZ2UzIH0gPSB0aGlzO1xuICAgIGNvbnN0IFtyMCwgcjFdID0gcmFuZ2UzO1xuICAgIGxldCBkO1xuICAgIGlmIChyMCA9PT0gcjEpIHtcbiAgICAgIGQgPSB0aGlzLnRvRG9tYWluKChOdW1iZXIoZDApICsgTnVtYmVyKGQxKSkgLyAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZCA9IHRoaXMudG9Eb21haW4oTnVtYmVyKGQwKSArICh4IC0gcjApIC8gKHIxIC0gcjApICogKE51bWJlcihkMSkgLSBOdW1iZXIoZDApKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUludmVydChkKTtcbiAgfVxuICBnZXRQaXhlbFJhbmdlKCkge1xuICAgIGNvbnN0IFthLCBiXSA9IHRoaXMucmFuZ2U7XG4gICAgcmV0dXJuIE1hdGguYWJzKGIgLSBhKTtcbiAgfVxufTtcbl9Db250aW51b3VzU2NhbGUuZGVmYXVsdFRpY2tDb3VudCA9IDU7XG52YXIgQ29udGludW91c1NjYWxlID0gX0NvbnRpbnVvdXNTY2FsZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL2luZGV4LnRzXG52YXIgdGltZV9leHBvcnRzID0ge307XG5fX2V4cG9ydCh0aW1lX2V4cG9ydHMsIHtcbiAgVGltZUludGVydmFsOiAoKSA9PiBUaW1lSW50ZXJ2YWwsXG4gIGRheTogKCkgPT4gZGF5LFxuICBmcmlkYXk6ICgpID0+IGZyaWRheSxcbiAgaG91cjogKCkgPT4gaG91cixcbiAgbWlsbGlzZWNvbmQ6ICgpID0+IG1pbGxpc2Vjb25kLFxuICBtaW51dGU6ICgpID0+IG1pbnV0ZSxcbiAgbW9uZGF5OiAoKSA9PiBtb25kYXksXG4gIG1vbnRoOiAoKSA9PiBtb250aCxcbiAgc2F0dXJkYXk6ICgpID0+IHNhdHVyZGF5LFxuICBzZWNvbmQ6ICgpID0+IHNlY29uZCxcbiAgc3VuZGF5OiAoKSA9PiBzdW5kYXksXG4gIHRodXJzZGF5OiAoKSA9PiB0aHVyc2RheSxcbiAgdHVlc2RheTogKCkgPT4gdHVlc2RheSxcbiAgdXRjRGF5OiAoKSA9PiB1dGNEYXksXG4gIHV0Y0hvdXI6ICgpID0+IHV0Y0hvdXIsXG4gIHV0Y01pbnV0ZTogKCkgPT4gdXRjTWludXRlLFxuICB1dGNNb250aDogKCkgPT4gdXRjTW9udGgsXG4gIHV0Y1llYXI6ICgpID0+IHV0Y1llYXIsXG4gIHdlZG5lc2RheTogKCkgPT4gd2VkbmVzZGF5LFxuICB5ZWFyOiAoKSA9PiB5ZWFyXG59KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL2ludGVydmFsLnRzXG52YXIgVGltZUludGVydmFsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfZW5jb2RlLCBfZGVjb2RlLCBfcmFuZ2VDYWxsYmFjaykge1xuICAgIHRoaXMuX2VuY29kZSA9IF9lbmNvZGU7XG4gICAgdGhpcy5fZGVjb2RlID0gX2RlY29kZTtcbiAgICB0aGlzLl9yYW5nZUNhbGxiYWNrID0gX3JhbmdlQ2FsbGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgZGF0ZSByZXByZXNlbnRpbmcgdGhlIGxhdGVzdCBpbnRlcnZhbCBib3VuZGFyeSBkYXRlIGJlZm9yZSBvciBlcXVhbCB0byBkYXRlLlxuICAgKiBGb3IgZXhhbXBsZSwgYGRheS5mbG9vcihkYXRlKWAgdHlwaWNhbGx5IHJldHVybnMgMTI6MDAgQU0gbG9jYWwgdGltZSBvbiB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICogQHBhcmFtIGRhdGVcbiAgICovXG4gIGZsb29yKGRhdGUyKSB7XG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKGRhdGUyKTtcbiAgICBjb25zdCBlID0gdGhpcy5fZW5jb2RlKGQpO1xuICAgIHJldHVybiB0aGlzLl9kZWNvZGUoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgZGF0ZSByZXByZXNlbnRpbmcgdGhlIGVhcmxpZXN0IGludGVydmFsIGJvdW5kYXJ5IGRhdGUgYWZ0ZXIgb3IgZXF1YWwgdG8gZGF0ZS5cbiAgICogQHBhcmFtIGRhdGVcbiAgICovXG4gIGNlaWwoZGF0ZTIpIHtcbiAgICBjb25zdCBkID0gbmV3IERhdGUoTnVtYmVyKGRhdGUyKSAtIDEpO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9lbmNvZGUoZCk7XG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZShlICsgMSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgZGF0ZXMgcmVwcmVzZW50aW5nIGV2ZXJ5IGludGVydmFsIGJvdW5kYXJ5IGFmdGVyIG9yIGVxdWFsIHRvIHN0YXJ0IChpbmNsdXNpdmUpIGFuZCBiZWZvcmUgc3RvcCAoZXhjbHVzaXZlKS5cbiAgICogQHBhcmFtIHN0YXJ0IFJhbmdlIHN0YXJ0LlxuICAgKiBAcGFyYW0gc3RvcCBSYW5nZSBlbmQuXG4gICAqIEBwYXJhbSBleHRlbmQgSWYgc3BlY2lmaWVkLCB0aGUgcmVxdWVzdGVkIHJhbmdlIHdpbGwgYmUgZXh0ZW5kZWQgdG8gdGhlIGNsb3Nlc3QgXCJuaWNlXCIgdmFsdWVzLlxuICAgKi9cbiAgcmFuZ2Uoc3RhcnQyLCBzdG9wLCB7IGV4dGVuZCA9IGZhbHNlLCB2aXNpYmxlUmFuZ2UgPSBbMCwgMV0gfSA9IHt9KSB7XG4gICAgbGV0IHJldmVyc2VkID0gZmFsc2U7XG4gICAgaWYgKHN0YXJ0Mi5nZXRUaW1lKCkgPiBzdG9wLmdldFRpbWUoKSkge1xuICAgICAgW3N0YXJ0Miwgc3RvcF0gPSBbc3RvcCwgc3RhcnQyXTtcbiAgICAgIHJldmVyc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2VDYWxsYmFjayA9IHRoaXMuX3JhbmdlQ2FsbGJhY2s/LihzdGFydDIsIHN0b3ApO1xuICAgIGNvbnN0IGUwID0gdGhpcy5fZW5jb2RlKGV4dGVuZCA/IHRoaXMuZmxvb3Ioc3RhcnQyKSA6IHRoaXMuY2VpbChzdGFydDIpKTtcbiAgICBjb25zdCBlMSA9IHRoaXMuX2VuY29kZShleHRlbmQgPyB0aGlzLmNlaWwoc3RvcCkgOiB0aGlzLmZsb29yKHN0b3ApKTtcbiAgICBpZiAoZTEgPCBlMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBkZSA9IGUxIC0gZTA7XG4gICAgbGV0IHN0YXJ0SW5kZXg7XG4gICAgbGV0IGVuZEluZGV4O1xuICAgIGlmIChyZXZlcnNlZCkge1xuICAgICAgc3RhcnRJbmRleCA9IE1hdGguY2VpbChlMCArICgxIC0gdmlzaWJsZVJhbmdlWzFdKSAqIGRlKTtcbiAgICAgIGVuZEluZGV4ID0gTWF0aC5mbG9vcihlMCArICgxIC0gdmlzaWJsZVJhbmdlWzBdKSAqIGRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRJbmRleCA9IE1hdGguZmxvb3IoZTAgKyB2aXNpYmxlUmFuZ2VbMF0gKiBkZSk7XG4gICAgICBlbmRJbmRleCA9IE1hdGguY2VpbChlMCArIHZpc2libGVSYW5nZVsxXSAqIGRlKTtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2UzID0gW107XG4gICAgZm9yIChsZXQgZSA9IHN0YXJ0SW5kZXg7IGUgPD0gZW5kSW5kZXg7IGUgKz0gMSkge1xuICAgICAgY29uc3QgZCA9IHRoaXMuX2RlY29kZShlKTtcbiAgICAgIHJhbmdlMy5wdXNoKGQpO1xuICAgIH1cbiAgICByYW5nZUNhbGxiYWNrPy4oKTtcbiAgICByZXR1cm4gcmFuZ2UzO1xuICB9XG59O1xudmFyIENvdW50YWJsZVRpbWVJbnRlcnZhbCA9IGNsYXNzIGV4dGVuZHMgVGltZUludGVydmFsIHtcbiAgZ2V0T2Zmc2V0KHNuYXBUbywgc3RlcCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuX2VuY29kZShuZXcgRGF0ZShzbmFwVG8pKSkgJSBzdGVwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZmlsdGVyZWQgdmlldyBvZiB0aGlzIGludGVydmFsIHJlcHJlc2VudGluZyBldmVyeSBzdGVwJ3RoIGRhdGUuXG4gICAqIEl0IGNhbiBiZSBhIG51bWJlciBvZiBtaW51dGVzLCBob3VycywgZGF5cyBldGMuXG4gICAqIE11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLlxuICAgKiBAcGFyYW0gc3RlcFxuICAgKi9cbiAgZXZlcnkoc3RlcCwgb3B0aW9ucykge1xuICAgIGxldCBvZmZzZXQ0ID0gMDtcbiAgICBsZXQgcmFuZ2VDYWxsYmFjaztcbiAgICBjb25zdCB1bnNhZmVTdGVwID0gc3RlcDtcbiAgICBzdGVwID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChzdGVwKSk7XG4gICAgaWYgKHVuc2FmZVN0ZXAgIT09IHN0ZXApIHtcbiAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKGBpbnRlcnZhbCBzdGVwIG9mIFske3Vuc2FmZVN0ZXB9XSByb3VuZGVkIHRvIFske3N0ZXB9XS5gKTtcbiAgICB9XG4gICAgY29uc3QgeyBzbmFwVG8gPSBcInN0YXJ0XCIgfSA9IG9wdGlvbnMgPz8ge307XG4gICAgaWYgKHR5cGVvZiBzbmFwVG8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGluaXRpYWxPZmZzZXQgPSBvZmZzZXQ0O1xuICAgICAgcmFuZ2VDYWxsYmFjayA9IChzdGFydDIsIHN0b3ApID0+IHtcbiAgICAgICAgY29uc3QgcyA9IHNuYXBUbyA9PT0gXCJzdGFydFwiID8gc3RhcnQyIDogc3RvcDtcbiAgICAgICAgb2Zmc2V0NCA9IHRoaXMuZ2V0T2Zmc2V0KHMsIHN0ZXApO1xuICAgICAgICByZXR1cm4gKCkgPT4gb2Zmc2V0NCA9IGluaXRpYWxPZmZzZXQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNuYXBUbyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgb2Zmc2V0NCA9IHRoaXMuZ2V0T2Zmc2V0KG5ldyBEYXRlKHNuYXBUbyksIHN0ZXApO1xuICAgIH0gZWxzZSBpZiAoc25hcFRvIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgb2Zmc2V0NCA9IHRoaXMuZ2V0T2Zmc2V0KHNuYXBUbywgc3RlcCk7XG4gICAgfVxuICAgIGNvbnN0IGVuY29kZTEzID0gKGRhdGUyKSA9PiBNYXRoLmZsb29yKCh0aGlzLl9lbmNvZGUoZGF0ZTIpIC0gb2Zmc2V0NCkgLyBzdGVwKTtcbiAgICBjb25zdCBkZWNvZGUxMyA9IChlbmNvZGVkKSA9PiB0aGlzLl9kZWNvZGUoZW5jb2RlZCAqIHN0ZXAgKyBvZmZzZXQ0KTtcbiAgICByZXR1cm4gbmV3IFRpbWVJbnRlcnZhbChlbmNvZGUxMywgZGVjb2RlMTMsIHJhbmdlQ2FsbGJhY2spO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvbWlsbGlzZWNvbmQudHNcbmZ1bmN0aW9uIGVuY29kZShkYXRlMikge1xuICByZXR1cm4gZGF0ZTIuZ2V0VGltZSgpO1xufVxuZnVuY3Rpb24gZGVjb2RlKGVuY29kZWQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKGVuY29kZWQpO1xufVxudmFyIG1pbGxpc2Vjb25kID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUsIGRlY29kZSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS9kdXJhdGlvbi50c1xudmFyIGR1cmF0aW9uU2Vjb25kID0gMWUzO1xudmFyIGR1cmF0aW9uTWludXRlID0gZHVyYXRpb25TZWNvbmQgKiA2MDtcbnZhciBkdXJhdGlvbkhvdXIgPSBkdXJhdGlvbk1pbnV0ZSAqIDYwO1xudmFyIGR1cmF0aW9uRGF5ID0gZHVyYXRpb25Ib3VyICogMjQ7XG52YXIgZHVyYXRpb25XZWVrID0gZHVyYXRpb25EYXkgKiA3O1xudmFyIGR1cmF0aW9uTW9udGggPSBkdXJhdGlvbkRheSAqIDMwO1xudmFyIGR1cmF0aW9uWWVhciA9IGR1cmF0aW9uRGF5ICogMzY1O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvc2Vjb25kLnRzXG52YXIgb2Zmc2V0ID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpICogZHVyYXRpb25NaW51dGU7XG5mdW5jdGlvbiBlbmNvZGUyKGRhdGUyKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKChkYXRlMi5nZXRUaW1lKCkgLSBvZmZzZXQpIC8gZHVyYXRpb25TZWNvbmQpO1xufVxuZnVuY3Rpb24gZGVjb2RlMihlbmNvZGVkKSB7XG4gIHJldHVybiBuZXcgRGF0ZShvZmZzZXQgKyBlbmNvZGVkICogZHVyYXRpb25TZWNvbmQpO1xufVxudmFyIHNlY29uZCA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlMiwgZGVjb2RlMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS9taW51dGUudHNcbnZhciBvZmZzZXQyID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpICogZHVyYXRpb25NaW51dGU7XG5mdW5jdGlvbiBlbmNvZGUzKGRhdGUyKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKChkYXRlMi5nZXRUaW1lKCkgLSBvZmZzZXQyKSAvIGR1cmF0aW9uTWludXRlKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTMoZW5jb2RlZCkge1xuICByZXR1cm4gbmV3IERhdGUob2Zmc2V0MiArIGVuY29kZWQgKiBkdXJhdGlvbk1pbnV0ZSk7XG59XG52YXIgbWludXRlID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUzLCBkZWNvZGUzKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL2hvdXIudHNcbnZhciBvZmZzZXQzID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpICogZHVyYXRpb25NaW51dGU7XG5mdW5jdGlvbiBlbmNvZGU0KGRhdGUyKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKChkYXRlMi5nZXRUaW1lKCkgLSBvZmZzZXQzKSAvIGR1cmF0aW9uSG91cik7XG59XG5mdW5jdGlvbiBkZWNvZGU0KGVuY29kZWQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKG9mZnNldDMgKyBlbmNvZGVkICogZHVyYXRpb25Ib3VyKTtcbn1cbnZhciBob3VyID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGU0LCBkZWNvZGU0KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL2RheS50c1xuZnVuY3Rpb24gZW5jb2RlNShkYXRlMikge1xuICBjb25zdCB0ek9mZnNldE1zID0gZGF0ZTIuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIGR1cmF0aW9uTWludXRlO1xuICByZXR1cm4gTWF0aC5mbG9vcigoZGF0ZTIuZ2V0VGltZSgpIC0gdHpPZmZzZXRNcykgLyBkdXJhdGlvbkRheSk7XG59XG5mdW5jdGlvbiBkZWNvZGU1KGVuY29kZWQpIHtcbiAgY29uc3QgZCA9IG5ldyBEYXRlKDE5NzAsIDAsIDEpO1xuICBkLnNldERhdGUoZC5nZXREYXRlKCkgKyBlbmNvZGVkKTtcbiAgcmV0dXJuIGQ7XG59XG52YXIgZGF5ID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGU1LCBkZWNvZGU1KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL3dlZWsudHNcbmZ1bmN0aW9uIHdlZWtkYXkod2Vla1N0YXJ0KSB7XG4gIGNvbnN0IHRodXJzZGF5MiA9IDQ7XG4gIGNvbnN0IGRheVNoaWZ0ID0gKDcgKyB3ZWVrU3RhcnQgLSB0aHVyc2RheTIpICUgNztcbiAgZnVuY3Rpb24gZW5jb2RlMTMoZGF0ZTIpIHtcbiAgICBjb25zdCB0ek9mZnNldE1zID0gZGF0ZTIuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIGR1cmF0aW9uTWludXRlO1xuICAgIHJldHVybiBNYXRoLmZsb29yKChkYXRlMi5nZXRUaW1lKCkgLSB0ek9mZnNldE1zKSAvIGR1cmF0aW9uV2VlayAtIGRheVNoaWZ0IC8gNyk7XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlMTMoZW5jb2RlZCkge1xuICAgIGNvbnN0IGQgPSBuZXcgRGF0ZSgxOTcwLCAwLCAxKTtcbiAgICBkLnNldERhdGUoZC5nZXREYXRlKCkgKyBlbmNvZGVkICogNyArIGRheVNoaWZ0KTtcbiAgICByZXR1cm4gZDtcbiAgfVxuICByZXR1cm4gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUxMywgZGVjb2RlMTMpO1xufVxudmFyIHN1bmRheSA9IHdlZWtkYXkoMCk7XG52YXIgbW9uZGF5ID0gd2Vla2RheSgxKTtcbnZhciB0dWVzZGF5ID0gd2Vla2RheSgyKTtcbnZhciB3ZWRuZXNkYXkgPSB3ZWVrZGF5KDMpO1xudmFyIHRodXJzZGF5ID0gd2Vla2RheSg0KTtcbnZhciBmcmlkYXkgPSB3ZWVrZGF5KDUpO1xudmFyIHNhdHVyZGF5ID0gd2Vla2RheSg2KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL21vbnRoLnRzXG5mdW5jdGlvbiBlbmNvZGU2KGRhdGUyKSB7XG4gIHJldHVybiBkYXRlMi5nZXRGdWxsWWVhcigpICogMTIgKyBkYXRlMi5nZXRNb250aCgpO1xufVxuZnVuY3Rpb24gZGVjb2RlNihlbmNvZGVkKSB7XG4gIGNvbnN0IHllYXIyID0gTWF0aC5mbG9vcihlbmNvZGVkIC8gMTIpO1xuICBjb25zdCBtb250aDIgPSBlbmNvZGVkIC0geWVhcjIgKiAxMjtcbiAgcmV0dXJuIG5ldyBEYXRlKHllYXIyLCBtb250aDIsIDEpO1xufVxudmFyIG1vbnRoID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGU2LCBkZWNvZGU2KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL3llYXIudHNcbmZ1bmN0aW9uIGVuY29kZTcoZGF0ZTIpIHtcbiAgcmV0dXJuIGRhdGUyLmdldEZ1bGxZZWFyKCk7XG59XG5mdW5jdGlvbiBkZWNvZGU3KGVuY29kZWQpIHtcbiAgY29uc3QgZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICBkLnNldEZ1bGxZZWFyKGVuY29kZWQpO1xuICBkLnNldE1vbnRoKDAsIDEpO1xuICBkLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gZDtcbn1cbnZhciB5ZWFyID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGU3LCBkZWNvZGU3KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL3V0Y01pbnV0ZS50c1xuZnVuY3Rpb24gZW5jb2RlOChkYXRlMikge1xuICByZXR1cm4gTWF0aC5mbG9vcihkYXRlMi5nZXRUaW1lKCkgLyBkdXJhdGlvbk1pbnV0ZSk7XG59XG5mdW5jdGlvbiBkZWNvZGU4KGVuY29kZWQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKGVuY29kZWQgKiBkdXJhdGlvbk1pbnV0ZSk7XG59XG52YXIgdXRjTWludXRlID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGU4LCBkZWNvZGU4KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL3V0Y0hvdXIudHNcbmZ1bmN0aW9uIGVuY29kZTkoZGF0ZTIpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZGF0ZTIuZ2V0VGltZSgpIC8gZHVyYXRpb25Ib3VyKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTkoZW5jb2RlZCkge1xuICByZXR1cm4gbmV3IERhdGUoZW5jb2RlZCAqIGR1cmF0aW9uSG91cik7XG59XG52YXIgdXRjSG91ciA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlOSwgZGVjb2RlOSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS91dGNEYXkudHNcbmZ1bmN0aW9uIGVuY29kZTEwKGRhdGUyKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKGRhdGUyLmdldFRpbWUoKSAvIGR1cmF0aW9uRGF5KTtcbn1cbmZ1bmN0aW9uIGRlY29kZTEwKGVuY29kZWQpIHtcbiAgY29uc3QgZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgwKTtcbiAgZC5zZXRVVENEYXRlKGQuZ2V0VVRDRGF0ZSgpICsgZW5jb2RlZCk7XG4gIGQuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiBkO1xufVxudmFyIHV0Y0RheSA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlMTAsIGRlY29kZTEwKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL3V0Y01vbnRoLnRzXG5mdW5jdGlvbiBlbmNvZGUxMShkYXRlMikge1xuICByZXR1cm4gZGF0ZTIuZ2V0VVRDRnVsbFllYXIoKSAqIDEyICsgZGF0ZTIuZ2V0VVRDTW9udGgoKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTExKGVuY29kZWQpIHtcbiAgY29uc3QgeWVhcjIgPSBNYXRoLmZsb29yKGVuY29kZWQgLyAxMik7XG4gIGNvbnN0IG1vbnRoMiA9IGVuY29kZWQgLSB5ZWFyMiAqIDEyO1xuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhcjIsIG1vbnRoMiwgMSkpO1xufVxudmFyIHV0Y01vbnRoID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUxMSwgZGVjb2RlMTEpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvdXRjWWVhci50c1xuZnVuY3Rpb24gZW5jb2RlMTIoZGF0ZTIpIHtcbiAgcmV0dXJuIGRhdGUyLmdldFVUQ0Z1bGxZZWFyKCk7XG59XG5mdW5jdGlvbiBkZWNvZGUxMihlbmNvZGVkKSB7XG4gIGNvbnN0IGQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgZC5zZXRVVENGdWxsWWVhcihlbmNvZGVkKTtcbiAgZC5zZXRVVENNb250aCgwLCAxKTtcbiAgZC5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGQ7XG59XG52YXIgdXRjWWVhciA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlMTIsIGRlY29kZTEyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lRm9ybWF0LnRzXG52YXIgQ09OU1RBTlRTID0ge1xuICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgc2hvcnREYXlzOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gIG1vbnRoczogW1xuICAgIFwiSmFudWFyeVwiLFxuICAgIFwiRmVicnVhcnlcIixcbiAgICBcIk1hcmNoXCIsXG4gICAgXCJBcHJpbFwiLFxuICAgIFwiTWF5XCIsXG4gICAgXCJKdW5lXCIsXG4gICAgXCJKdWx5XCIsXG4gICAgXCJBdWd1c3RcIixcbiAgICBcIlNlcHRlbWJlclwiLFxuICAgIFwiT2N0b2JlclwiLFxuICAgIFwiTm92ZW1iZXJcIixcbiAgICBcIkRlY2VtYmVyXCJcbiAgXSxcbiAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxufTtcbmZ1bmN0aW9uIGRheU9mWWVhcihkYXRlMiwgc3RhcnRPZlllYXIgPSBuZXcgRGF0ZShkYXRlMi5nZXRGdWxsWWVhcigpLCAwLCAxKSkge1xuICBjb25zdCBzdGFydE9mZnNldCA9IGRhdGUyLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydE9mWWVhci5nZXRUaW1lem9uZU9mZnNldCgpO1xuICBjb25zdCB0aW1lRGlmZiA9IGRhdGUyLmdldFRpbWUoKSAtIHN0YXJ0T2ZZZWFyLmdldFRpbWUoKSArIHN0YXJ0T2Zmc2V0ICogNmU0O1xuICBjb25zdCB0aW1lT25lRGF5ID0gMzZlNSAqIDI0O1xuICByZXR1cm4gTWF0aC5mbG9vcih0aW1lRGlmZiAvIHRpbWVPbmVEYXkpO1xufVxuZnVuY3Rpb24gd2Vla09mWWVhcihkYXRlMiwgc3RhcnREYXkpIHtcbiAgY29uc3Qgc3RhcnRPZlllYXIgPSBuZXcgRGF0ZShkYXRlMi5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgY29uc3Qgc3RhcnRPZlllYXJEYXkgPSBzdGFydE9mWWVhci5nZXREYXkoKTtcbiAgY29uc3QgZmlyc3RXZWVrU3RhcnRPZmZzZXQgPSAoc3RhcnREYXkgLSBzdGFydE9mWWVhckRheSArIDcpICUgNztcbiAgY29uc3Qgc3RhcnRPZmZzZXQgPSBuZXcgRGF0ZShkYXRlMi5nZXRGdWxsWWVhcigpLCAwLCBmaXJzdFdlZWtTdGFydE9mZnNldCArIDEpO1xuICBpZiAoc3RhcnRPZmZzZXQgPD0gZGF0ZTIpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlPZlllYXIoZGF0ZTIsIHN0YXJ0T2Zmc2V0KSAvIDcpICsgMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbnZhciBTVU5EQVkgPSAwO1xudmFyIE1PTkRBWSA9IDE7XG52YXIgVEhVUlNEQVkgPSA0O1xuZnVuY3Rpb24gaXNvV2Vla09mWWVhcihkYXRlMiwgeWVhcjIgPSBkYXRlMi5nZXRGdWxsWWVhcigpKSB7XG4gIGNvbnN0IGZpcnN0T2ZZZWFyID0gbmV3IERhdGUoeWVhcjIsIDAsIDEpO1xuICBjb25zdCBmaXJzdE9mWWVhckRheSA9IGZpcnN0T2ZZZWFyLmdldERheSgpO1xuICBjb25zdCBmaXJzdFRodXJzZGF5T2Zmc2V0ID0gKFRIVVJTREFZIC0gZmlyc3RPZlllYXJEYXkgKyA3KSAlIDc7XG4gIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gbmV3IERhdGUoeWVhcjIsIDAsIGZpcnN0VGh1cnNkYXlPZmZzZXQgLSAoVEhVUlNEQVkgLSBNT05EQVkpICsgMSk7XG4gIGlmIChzdGFydE9mZnNldCA8PSBkYXRlMikge1xuICAgIHJldHVybiBNYXRoLmZsb29yKGRheU9mWWVhcihkYXRlMiwgc3RhcnRPZmZzZXQpIC8gNykgKyAxO1xuICB9XG4gIHJldHVybiBpc29XZWVrT2ZZZWFyKGRhdGUyLCB5ZWFyMiAtIDEpO1xufVxuZnVuY3Rpb24gdGltZXpvbmUoZGF0ZTIpIHtcbiAgY29uc3Qgb2Zmc2V0NCA9IGRhdGUyLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIGNvbnN0IHVuc2lnbmVkT2Zmc2V0ID0gTWF0aC5hYnMob2Zmc2V0NCk7XG4gIGNvbnN0IHNpZ24gPSBvZmZzZXQ0ID4gMCA/IFwiLVwiIDogXCIrXCI7XG4gIHJldHVybiBgJHtzaWdufSR7cGFkKE1hdGguZmxvb3IodW5zaWduZWRPZmZzZXQgLyA2MCksIDIsIFwiMFwiKX0ke3BhZChNYXRoLmZsb29yKHVuc2lnbmVkT2Zmc2V0ICUgNjApLCAyLCBcIjBcIil9YDtcbn1cbnZhciBGT1JNQVRURVJTID0ge1xuICBhOiAoZCkgPT4gQ09OU1RBTlRTLnNob3J0RGF5c1tkLmdldERheSgpXSxcbiAgQTogKGQpID0+IENPTlNUQU5UUy5kYXlzW2QuZ2V0RGF5KCldLFxuICBiOiAoZCkgPT4gQ09OU1RBTlRTLnNob3J0TW9udGhzW2QuZ2V0TW9udGgoKV0sXG4gIEI6IChkKSA9PiBDT05TVEFOVFMubW9udGhzW2QuZ2V0TW9udGgoKV0sXG4gIGM6IFwiJXgsICVYXCIsXG4gIGQ6IChkLCBwKSA9PiBwYWQoZC5nZXREYXRlKCksIDIsIHAgPz8gXCIwXCIpLFxuICBlOiBcIiVfZFwiLFxuICBmOiAoZCwgcCkgPT4gcGFkKGQuZ2V0TWlsbGlzZWNvbmRzKCkgKiAxZTMsIDYsIHAgPz8gXCIwXCIpLFxuICBIOiAoZCwgcCkgPT4gcGFkKGQuZ2V0SG91cnMoKSwgMiwgcCA/PyBcIjBcIiksXG4gIEk6IChkLCBwKSA9PiB7XG4gICAgY29uc3QgaG91cnMgPSBkLmdldEhvdXJzKCkgJSAxMjtcbiAgICByZXR1cm4gaG91cnMgPT09IDAgPyBcIjEyXCIgOiBwYWQoaG91cnMsIDIsIHAgPz8gXCIwXCIpO1xuICB9LFxuICBqOiAoZCwgcCkgPT4gcGFkKGRheU9mWWVhcihkKSArIDEsIDMsIHAgPz8gXCIwXCIpLFxuICBtOiAoZCwgcCkgPT4gcGFkKGQuZ2V0TW9udGgoKSArIDEsIDIsIHAgPz8gXCIwXCIpLFxuICBNOiAoZCwgcCkgPT4gcGFkKGQuZ2V0TWludXRlcygpLCAyLCBwID8/IFwiMFwiKSxcbiAgTDogKGQsIHApID0+IHBhZChkLmdldE1pbGxpc2Vjb25kcygpLCAzLCBwID8/IFwiMFwiKSxcbiAgcDogKGQpID0+IGQuZ2V0SG91cnMoKSA8IDEyID8gXCJBTVwiIDogXCJQTVwiLFxuICBROiAoZCkgPT4gU3RyaW5nKGQuZ2V0VGltZSgpKSxcbiAgczogKGQpID0+IFN0cmluZyhNYXRoLmZsb29yKGQuZ2V0VGltZSgpIC8gMWUzKSksXG4gIFM6IChkLCBwKSA9PiBwYWQoZC5nZXRTZWNvbmRzKCksIDIsIHAgPz8gXCIwXCIpLFxuICB1OiAoZCkgPT4ge1xuICAgIGxldCBkYXkyID0gZC5nZXREYXkoKTtcbiAgICBpZiAoZGF5MiA8IDEpXG4gICAgICBkYXkyICs9IDc7XG4gICAgcmV0dXJuIFN0cmluZyhkYXkyICUgNyk7XG4gIH0sXG4gIFU6IChkLCBwKSA9PiBwYWQod2Vla09mWWVhcihkLCBTVU5EQVkpLCAyLCBwID8/IFwiMFwiKSxcbiAgVjogKGQsIHApID0+IHBhZChpc29XZWVrT2ZZZWFyKGQpLCAyLCBwID8/IFwiMFwiKSxcbiAgdzogKGQsIHApID0+IHBhZChkLmdldERheSgpLCAyLCBwID8/IFwiMFwiKSxcbiAgVzogKGQsIHApID0+IHBhZCh3ZWVrT2ZZZWFyKGQsIE1PTkRBWSksIDIsIHAgPz8gXCIwXCIpLFxuICB4OiBcIiUtbS8lLWQvJVlcIixcbiAgWDogXCIlLUk6JU06JVMgJXBcIixcbiAgeTogKGQsIHApID0+IHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAsIDIsIHAgPz8gXCIwXCIpLFxuICBZOiAoZCwgcCkgPT4gcGFkKGQuZ2V0RnVsbFllYXIoKSwgNCwgcCA/PyBcIjBcIiksXG4gIFo6IChkKSA9PiB0aW1lem9uZShkKSxcbiAgXCIlXCI6ICgpID0+IFwiJVwiXG59O1xudmFyIFBBRFMgPSB7XG4gIF86IFwiIFwiLFxuICBcIjBcIjogXCIwXCIsXG4gIFwiLVwiOiBcIlwiXG59O1xuZnVuY3Rpb24gcGFkKHZhbHVlLCBzaXplLCBwYWRDaGFyKSB7XG4gIGNvbnN0IG91dHB1dCA9IFN0cmluZyhNYXRoLmZsb29yKHZhbHVlKSk7XG4gIGlmIChvdXRwdXQubGVuZ3RoID49IHNpemUpIHtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHJldHVybiBgJHtwYWRDaGFyLnJlcGVhdChzaXplIC0gb3V0cHV0Lmxlbmd0aCl9JHtvdXRwdXR9YDtcbn1cbmZ1bmN0aW9uIGJ1aWxkRm9ybWF0dGVyKGZvcm1hdFN0cmluZykge1xuICBjb25zdCBmb3JtYXRQYXJ0cyA9IFtdO1xuICB3aGlsZSAoZm9ybWF0U3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICBsZXQgbmV4dEVzY2FwZUlkeCA9IGZvcm1hdFN0cmluZy5pbmRleE9mKFwiJVwiKTtcbiAgICBpZiAobmV4dEVzY2FwZUlkeCAhPT0gMCkge1xuICAgICAgY29uc3QgbGl0ZXJhbFBhcnQgPSBuZXh0RXNjYXBlSWR4ID4gMCA/IGZvcm1hdFN0cmluZy5zdWJzdHJpbmcoMCwgbmV4dEVzY2FwZUlkeCkgOiBmb3JtYXRTdHJpbmc7XG4gICAgICBmb3JtYXRQYXJ0cy5wdXNoKGxpdGVyYWxQYXJ0KTtcbiAgICB9XG4gICAgaWYgKG5leHRFc2NhcGVJZHggPCAwKVxuICAgICAgYnJlYWs7XG4gICAgY29uc3QgbWF5YmVQYWRTcGVjaWZpZXIgPSBmb3JtYXRTdHJpbmdbbmV4dEVzY2FwZUlkeCArIDFdO1xuICAgIGNvbnN0IG1heWJlUGFkID0gUEFEU1ttYXliZVBhZFNwZWNpZmllcl07XG4gICAgaWYgKG1heWJlUGFkICE9IG51bGwpIHtcbiAgICAgIG5leHRFc2NhcGVJZHgrKztcbiAgICB9XG4gICAgY29uc3QgbWF5YmVGb3JtYXR0ZXJTcGVjaWZpZXIgPSBmb3JtYXRTdHJpbmdbbmV4dEVzY2FwZUlkeCArIDFdO1xuICAgIGNvbnN0IG1heWJlRm9ybWF0dGVyID0gRk9STUFUVEVSU1ttYXliZUZvcm1hdHRlclNwZWNpZmllcl07XG4gICAgaWYgKHR5cGVvZiBtYXliZUZvcm1hdHRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmb3JtYXRQYXJ0cy5wdXNoKFttYXliZUZvcm1hdHRlciwgbWF5YmVQYWRdKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXliZUZvcm1hdHRlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgZm9ybWF0dGVyID0gYnVpbGRGb3JtYXR0ZXIobWF5YmVGb3JtYXR0ZXIpO1xuICAgICAgZm9ybWF0UGFydHMucHVzaChbZm9ybWF0dGVyLCBtYXliZVBhZF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtYXRQYXJ0cy5wdXNoKGAke21heWJlUGFkID8/IFwiXCJ9JHttYXliZUZvcm1hdHRlclNwZWNpZmllcn1gKTtcbiAgICB9XG4gICAgZm9ybWF0U3RyaW5nID0gZm9ybWF0U3RyaW5nLnN1YnN0cmluZyhuZXh0RXNjYXBlSWR4ICsgMik7XG4gIH1cbiAgcmV0dXJuIChkYXRlVGltZSkgPT4ge1xuICAgIGNvbnN0IGRhdGVUaW1lQXNEYXRlID0gdHlwZW9mIGRhdGVUaW1lID09PSBcIm51bWJlclwiID8gbmV3IERhdGUoZGF0ZVRpbWUpIDogZGF0ZVRpbWU7XG4gICAgcmV0dXJuIGZvcm1hdFBhcnRzLm1hcCgoYykgPT4gdHlwZW9mIGMgPT09IFwic3RyaW5nXCIgPyBjIDogY1swXShkYXRlVGltZUFzRGF0ZSwgY1sxXSkpLmpvaW4oXCJcIik7XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZUZvcm1hdERlZmF1bHRzLnRzXG5mdW5jdGlvbiBkYXRlVG9OdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IHZhbHVlLmdldFRpbWUoKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZGVmYXVsdFRpbWVUaWNrRm9ybWF0KHRpY2tzLCBkb21haW4sIGZvcm1hdE9mZnNldCkge1xuICBjb25zdCBmb3JtYXRTdHJpbmcgPSBjYWxjdWxhdGVEZWZhdWx0VGltZVRpY2tGb3JtYXQodGlja3MsIGRvbWFpbiwgZm9ybWF0T2Zmc2V0KTtcbiAgY29uc3QgZm9ybWF0dGVyID0gYnVpbGRGb3JtYXR0ZXIoZm9ybWF0U3RyaW5nKTtcbiAgcmV0dXJuIChkYXRlMikgPT4gZm9ybWF0dGVyKGRhdGUyKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlZmF1bHRUaW1lVGlja0Zvcm1hdCh0aWNrcywgZG9tYWluLCBmb3JtYXRPZmZzZXQgPSAwKSB7XG4gIGxldCBtaW5JbnRlcnZhbCA9IEluZmluaXR5O1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgbWluSW50ZXJ2YWwgPSBNYXRoLm1pbihtaW5JbnRlcnZhbCwgTWF0aC5hYnModGlja3NbaV0udmFsdWVPZigpIC0gdGlja3NbaSAtIDFdLnZhbHVlT2YoKSkpO1xuICB9XG4gIGNvbnN0IFtkMCwgZDFdID0gZG9tYWluLmxlbmd0aCA9PT0gMCA/IFswLCAwXSA6IGZpbmRNaW5NYXgoW2RvbWFpblswXS52YWx1ZU9mKCksIGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0udmFsdWVPZigpXSk7XG4gIGNvbnN0IHN0YXJ0WWVhciA9IG5ldyBEYXRlKGQwKS5nZXRGdWxsWWVhcigpO1xuICBjb25zdCBzdG9wWWVhciA9IG5ldyBEYXRlKGQxKS5nZXRGdWxsWWVhcigpO1xuICBjb25zdCB5ZWFyQ2hhbmdlID0gc3RvcFllYXIgLSBzdGFydFllYXIgPiAwO1xuICBjb25zdCB0aW1lRm9ybWF0ID0gaXNGaW5pdGUobWluSW50ZXJ2YWwpID8gZ2V0SW50ZXJ2YWxMb3dlc3RHcmFudWxhcml0eUZvcm1hdChtaW5JbnRlcnZhbCwgdGlja3MpIDogZ2V0TG93ZXN0R3JhbnVsYXJpdHlGb3JtYXQodGlja3NbMF0pO1xuICByZXR1cm4gZm9ybWF0U3RyaW5nQnVpbGRlcihNYXRoLm1heCh0aW1lRm9ybWF0IC0gZm9ybWF0T2Zmc2V0LCAwKSwgeWVhckNoYW5nZSwgdGlja3MpO1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJ2YWxMb3dlc3RHcmFudWxhcml0eUZvcm1hdCh2YWx1ZSwgdGlja3MpIHtcbiAgaWYgKHZhbHVlIDwgZHVyYXRpb25TZWNvbmQpIHtcbiAgICByZXR1cm4gMCAvKiBNSUxMSVNFQ09ORCAqLztcbiAgfSBlbHNlIGlmICh2YWx1ZSA8IGR1cmF0aW9uTWludXRlKSB7XG4gICAgcmV0dXJuIDEgLyogU0VDT05EICovO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgZHVyYXRpb25Ib3VyKSB7XG4gICAgcmV0dXJuIDIgLyogTUlOVVRFICovO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgZHVyYXRpb25EYXkpIHtcbiAgICByZXR1cm4gMyAvKiBIT1VSICovO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgZHVyYXRpb25XZWVrKSB7XG4gICAgcmV0dXJuIDQgLyogV0VFS19EQVkgKi87XG4gIH0gZWxzZSBpZiAodmFsdWUgPCBkdXJhdGlvbkRheSAqIDI4IHx8IHZhbHVlIDwgZHVyYXRpb25EYXkgKiAzMSAmJiBoYXNEdXBsaWNhdGVNb250aCh0aWNrcykpIHtcbiAgICByZXR1cm4gNSAvKiBTSE9SVF9NT05USCAqLztcbiAgfSBlbHNlIGlmICh2YWx1ZSA8IGR1cmF0aW9uWWVhcikge1xuICAgIHJldHVybiA2IC8qIE1PTlRIICovO1xuICB9XG4gIHJldHVybiA3IC8qIFlFQVIgKi87XG59XG5mdW5jdGlvbiBnZXRMb3dlc3RHcmFudWxhcml0eUZvcm1hdCh2YWx1ZSkge1xuICBpZiAoc2Vjb25kLmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XG4gICAgcmV0dXJuIDAgLyogTUlMTElTRUNPTkQgKi87XG4gIH0gZWxzZSBpZiAobWludXRlLmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XG4gICAgcmV0dXJuIDEgLyogU0VDT05EICovO1xuICB9IGVsc2UgaWYgKGhvdXIuZmxvb3IodmFsdWUpIDwgdmFsdWUpIHtcbiAgICByZXR1cm4gMiAvKiBNSU5VVEUgKi87XG4gIH0gZWxzZSBpZiAoZGF5LmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XG4gICAgcmV0dXJuIDMgLyogSE9VUiAqLztcbiAgfSBlbHNlIGlmIChtb250aC5mbG9vcih2YWx1ZSkgPCB2YWx1ZSkge1xuICAgIGlmIChzdW5kYXkuZmxvb3IodmFsdWUpIDwgdmFsdWUpIHtcbiAgICAgIHJldHVybiA0IC8qIFdFRUtfREFZICovO1xuICAgIH1cbiAgICByZXR1cm4gNSAvKiBTSE9SVF9NT05USCAqLztcbiAgfSBlbHNlIGlmICh5ZWFyLmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XG4gICAgcmV0dXJuIDYgLyogTU9OVEggKi87XG4gIH1cbiAgcmV0dXJuIDcgLyogWUVBUiAqLztcbn1cbmZ1bmN0aW9uIGhhc0R1cGxpY2F0ZU1vbnRoKHRpY2tzKSB7XG4gIGxldCBwcmV2TW9udGggPSBuZXcgRGF0ZSh0aWNrc1swXSkuZ2V0TW9udGgoKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRpY2tNb250aCA9IG5ldyBEYXRlKHRpY2tzW2ldKS5nZXRNb250aCgpO1xuICAgIGlmIChwcmV2TW9udGggPT09IHRpY2tNb250aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHByZXZNb250aCA9IHRpY2tNb250aDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBmb3JtYXRTdHJpbmdCdWlsZGVyKGRlZmF1bHRUaW1lRm9ybWF0LCB5ZWFyQ2hhbmdlLCB0aWNrcykge1xuICBjb25zdCBmaXJzdFRpY2sgPSBkYXRlVG9OdW1iZXIodGlja3NbMF0pO1xuICBjb25zdCBsYXN0VGljayA9IGRhdGVUb051bWJlcih0aWNrcy5hdCgtMSkpO1xuICBjb25zdCBleHRlbnQyID0gTWF0aC5hYnMobGFzdFRpY2sgLSBmaXJzdFRpY2spO1xuICBjb25zdCBhY3RpdmVZZWFyID0geWVhckNoYW5nZSB8fCBkZWZhdWx0VGltZUZvcm1hdCA9PT0gNyAvKiBZRUFSICovO1xuICBjb25zdCBhY3RpdmVEYXRlID0gZXh0ZW50MiA9PT0gMDtcbiAgY29uc3QgcGFydHMgPSBbXG4gICAgW1wiaG91clwiLCA2ICogZHVyYXRpb25Ib3VyLCAxNCAqIGR1cmF0aW9uRGF5LCAzIC8qIEhPVVIgKi8sIFwiJUkgJXBcIl0sXG4gICAgW1wiaG91clwiLCBkdXJhdGlvbk1pbnV0ZSwgNiAqIGR1cmF0aW9uSG91ciwgMyAvKiBIT1VSICovLCBcIiVJOiVNXCJdLFxuICAgIFtcInNlY29uZFwiLCAxZTMsIDYgKiBkdXJhdGlvbkhvdXIsIDEgLyogU0VDT05EICovLCBcIjolU1wiXSxcbiAgICBbXCJtc1wiLCAwLCA2ICogZHVyYXRpb25Ib3VyLCAwIC8qIE1JTExJU0VDT05EICovLCBcIi4lTFwiXSxcbiAgICBbXCJhbS9wbVwiLCBkdXJhdGlvbk1pbnV0ZSwgNiAqIGR1cmF0aW9uSG91ciwgMyAvKiBIT1VSICovLCBcIiVwXCJdLFxuICAgIFwiIFwiLFxuICAgIFtcImRheVwiLCBkdXJhdGlvbkRheSwgZHVyYXRpb25XZWVrLCA0IC8qIFdFRUtfREFZICovLCBcIiVhXCJdLFxuICAgIFtcIm1vbnRoXCIsIGFjdGl2ZURhdGUgPyAwIDogZHVyYXRpb25XZWVrLCA1MiAqIGR1cmF0aW9uV2VlaywgNSAvKiBTSE9SVF9NT05USCAqLywgXCIlYiAlZFwiXSxcbiAgICBbXCJtb250aFwiLCA1ICogZHVyYXRpb25XZWVrLCAxMCAqIGR1cmF0aW9uWWVhciwgNiAvKiBNT05USCAqLywgXCIlQlwiXSxcbiAgICBcIiBcIixcbiAgICBbXCJ5ZWFyXCIsIGFjdGl2ZVllYXIgPyAwIDogZHVyYXRpb25ZZWFyLCBJbmZpbml0eSwgNyAvKiBZRUFSICovLCBcIiVZXCJdXG4gIF07XG4gIGNvbnN0IGZvcm1hdFBhcnRzID0gcGFydHMuZmlsdGVyKCh2KSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgW18sIG1pbiwgbWF4LCBmb3JtYXRdID0gdjtcbiAgICByZXR1cm4gZm9ybWF0ID49IGRlZmF1bHRUaW1lRm9ybWF0ICYmIG1pbiA8PSBleHRlbnQyICYmIGV4dGVudDIgPCBtYXg7XG4gIH0pLnJlZHVjZShcbiAgICAociwgbmV4dCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHIucmVzdWx0LnB1c2gobmV4dCk7XG4gICAgICB9IGVsc2UgaWYgKCFyLnVzZWQuaGFzKG5leHRbMF0pKSB7XG4gICAgICAgIHIucmVzdWx0LnB1c2gobmV4dCk7XG4gICAgICAgIHIudXNlZC5hZGQobmV4dFswXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIHsgcmVzdWx0OiBbXSwgdXNlZDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSB9XG4gICkucmVzdWx0O1xuICBjb25zdCBmaXJzdEZvcm1hdCA9IGZvcm1hdFBhcnRzLmZpbmRJbmRleCgodikgPT4gdHlwZW9mIHYgIT09IFwic3RyaW5nXCIpO1xuICBjb25zdCBsYXN0Rm9ybWF0ID0gZm9ybWF0UGFydHMuZmluZExhc3RJbmRleCgodikgPT4gdHlwZW9mIHYgIT09IFwic3RyaW5nXCIpO1xuICByZXR1cm4gZm9ybWF0UGFydHMuc2xpY2UoZmlyc3RGb3JtYXQsIGxhc3RGb3JtYXQgKyAxKS5tYXAoKHYpID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiID8gdiA6IHZbNF0pLmpvaW4oXCJcIikucmVwbGFjZUFsbCgvXFxzKy9nLCBcIiBcIikudHJpbSgpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2FsZS9pbnZhbGlkYXRpbmcudHNcbnZhciBJbnZhbGlkYXRpbmcgPSAodGFyZ2V0LCBwcm9wZXJ0eUtleSkgPT4ge1xuICBjb25zdCBtYXBwZWRQcm9wZXJ0eSA9IFN5bWJvbChTdHJpbmcocHJvcGVydHlLZXkpKTtcbiAgdGFyZ2V0W21hcHBlZFByb3BlcnR5XSA9IHZvaWQgMDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1ttYXBwZWRQcm9wZXJ0eV07XG4gICAgfSxcbiAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpc1ttYXBwZWRQcm9wZXJ0eV07XG4gICAgICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIHRoaXNbbWFwcGVkUHJvcGVydHldID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgfSk7XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2FsZS9zY2FsZVV0aWwudHNcbmZ1bmN0aW9uIGZpbHRlclZpc2libGVUaWNrcyh0aWNrcywgcmV2ZXJzZWQsIHZpc2libGVSYW5nZSkge1xuICBpZiAodmlzaWJsZVJhbmdlID09IG51bGwgfHwgdmlzaWJsZVJhbmdlWzBdID09PSAwICYmIHZpc2libGVSYW5nZVsxXSA9PT0gMSlcbiAgICByZXR1cm4gdGlja3M7XG4gIGNvbnN0IHZ0MCA9IGNsYW1wKDAsIE1hdGguZmxvb3IodmlzaWJsZVJhbmdlWzBdICogdGlja3MubGVuZ3RoKSwgdGlja3MubGVuZ3RoKTtcbiAgY29uc3QgdnQxID0gY2xhbXAoMCwgTWF0aC5jZWlsKHZpc2libGVSYW5nZVsxXSAqIHRpY2tzLmxlbmd0aCksIHRpY2tzLmxlbmd0aCk7XG4gIGNvbnN0IHQwID0gcmV2ZXJzZWQgPyB0aWNrcy5sZW5ndGggLSB2dDEgOiB2dDA7XG4gIGNvbnN0IHQxID0gcmV2ZXJzZWQgPyB0aWNrcy5sZW5ndGggLSB2dDAgOiB2dDE7XG4gIHJldHVybiB0aWNrcy5zbGljZSh0MCwgdDEpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2FsZS9iYW5kU2NhbGUudHNcbnZhciBfQmFuZFNjYWxlID0gY2xhc3MgX0JhbmRTY2FsZSBleHRlbmRzIEFic3RyYWN0U2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgdGhpcy5yYW5nZSA9IFswLCAxXTtcbiAgICB0aGlzLnJvdW5kID0gZmFsc2U7XG4gICAgdGhpcy5pbnRlcnZhbCA9IHZvaWQgMDtcbiAgICB0aGlzLl9iYW5kd2lkdGggPSAxO1xuICAgIHRoaXMuX3N0ZXAgPSAxO1xuICAgIHRoaXMuX2luc2V0ID0gMTtcbiAgICB0aGlzLl9yYXdCYW5kd2lkdGggPSAxO1xuICAgIC8qKlxuICAgICAqIFRoZSByYXRpbyBvZiB0aGUgcmFuZ2UgdGhhdCBpcyByZXNlcnZlZCBmb3Igc3BhY2UgYmV0d2VlbiBiYW5kcy5cbiAgICAgKi9cbiAgICB0aGlzLl9wYWRkaW5nSW5uZXIgPSAwO1xuICAgIC8qKlxuICAgICAqIFRoZSByYXRpbyBvZiB0aGUgcmFuZ2UgdGhhdCBpcyByZXNlcnZlZCBmb3Igc3BhY2UgYmVmb3JlIHRoZSBmaXJzdFxuICAgICAqIGFuZCBhZnRlciB0aGUgbGFzdCBiYW5kLlxuICAgICAqL1xuICAgIHRoaXMuX3BhZGRpbmdPdXRlciA9IDA7XG4gIH1cbiAgc3RhdGljIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgX0JhbmRTY2FsZTtcbiAgfVxuICBnZXQgYmFuZHdpZHRoKCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzLl9iYW5kd2lkdGg7XG4gIH1cbiAgZ2V0IHN0ZXAoKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZXA7XG4gIH1cbiAgZ2V0IGluc2V0KCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzLl9pbnNldDtcbiAgfVxuICBnZXQgcmF3QmFuZHdpZHRoKCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzLl9yYXdCYW5kd2lkdGg7XG4gIH1cbiAgc2V0IHBhZGRpbmcodmFsdWUpIHtcbiAgICB2YWx1ZSA9IGNsYW1wKDAsIHZhbHVlLCAxKTtcbiAgICB0aGlzLl9wYWRkaW5nSW5uZXIgPSB2YWx1ZTtcbiAgICB0aGlzLl9wYWRkaW5nT3V0ZXIgPSB2YWx1ZTtcbiAgfVxuICBnZXQgcGFkZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFkZGluZ0lubmVyO1xuICB9XG4gIHNldCBwYWRkaW5nSW5uZXIodmFsdWUpIHtcbiAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgIHRoaXMuX3BhZGRpbmdJbm5lciA9IGNsYW1wKDAsIHZhbHVlLCAxKTtcbiAgfVxuICBnZXQgcGFkZGluZ0lubmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWRkaW5nSW5uZXI7XG4gIH1cbiAgc2V0IHBhZGRpbmdPdXRlcih2YWx1ZSkge1xuICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgdGhpcy5fcGFkZGluZ091dGVyID0gY2xhbXAoMCwgdmFsdWUsIDEpO1xuICB9XG4gIGdldCBwYWRkaW5nT3V0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZGRpbmdPdXRlcjtcbiAgfVxuICByZWZyZXNoKCkge1xuICAgIGlmICghdGhpcy5pbnZhbGlkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaW52YWxpZCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoXCJFeHBlY3RlZCB1cGRhdGUgdG8gbm90IGludmFsaWRhdGUgc2NhbGVcIik7XG4gICAgfVxuICB9XG4gIHRpY2tzKF9wYXJhbXMsIGRvbWFpbiA9IHRoaXMuZG9tYWluLCB2aXNpYmxlUmFuZ2UpIHtcbiAgICByZXR1cm4gZmlsdGVyVmlzaWJsZVRpY2tzKGRvbWFpbiwgZmFsc2UsIHZpc2libGVSYW5nZSk7XG4gIH1cbiAgY29udmVydChkLCBfY2xhbXApIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCBpID0gdGhpcy5nZXRJbmRleChkKTtcbiAgICBpZiAoaSA9PSBudWxsIHx8IGkgPCAwIHx8IGkgPj0gdGhpcy5kb21haW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcmRpbmFsUmFuZ2UoaSk7XG4gIH1cbiAgaW52ZXJ0TmVhcmVzdEluZGV4KHBvc2l0aW9uKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgeyBkb21haW4gfSA9IHRoaXM7XG4gICAgaWYgKGRvbWFpbi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gLTE7XG4gICAgbGV0IGxvdyA9IDA7XG4gICAgbGV0IGhpZ2ggPSBkb21haW4ubGVuZ3RoIC0gMTtcbiAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgbGV0IGNsb3Nlc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICBjb25zdCBtaWQgPSAoaGlnaCArIGxvdykgLyAyIHwgMDtcbiAgICAgIGNvbnN0IHAgPSB0aGlzLm9yZGluYWxSYW5nZShtaWQpO1xuICAgICAgY29uc3QgZGlzdGFuY2UyID0gTWF0aC5hYnMocCAtIHBvc2l0aW9uKTtcbiAgICAgIGlmIChkaXN0YW5jZTIgPT09IDApXG4gICAgICAgIHJldHVybiBtaWQ7XG4gICAgICBpZiAoZGlzdGFuY2UyIDwgY2xvc2VzdERpc3RhbmNlKSB7XG4gICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IGRpc3RhbmNlMjtcbiAgICAgICAgY2xvc2VzdEluZGV4ID0gbWlkO1xuICAgICAgfVxuICAgICAgaWYgKHAgPCBwb3NpdGlvbikge1xuICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbG9zZXN0SW5kZXg7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5kb21haW4ubGVuZ3RoO1xuICAgIGlmIChjb3VudCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbcjAsIHIxXSA9IHRoaXMucmFuZ2U7XG4gICAgbGV0IHsgX3BhZGRpbmdJbm5lcjogcGFkZGluZ0lubmVyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgX3BhZGRpbmdPdXRlcjogcGFkZGluZ091dGVyLCByb3VuZDogcm91bmQ1IH0gPSB0aGlzO1xuICAgIGNvbnN0IHJhbmdlRGlzdGFuY2UgPSByMSAtIHIwO1xuICAgIGxldCByYXdTdGVwO1xuICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgcGFkZGluZ0lubmVyID0gMDtcbiAgICAgIHJhd1N0ZXAgPSByYW5nZURpc3RhbmNlICogKDEgLSBwYWRkaW5nT3V0ZXIgKiAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmF3U3RlcCA9IHJhbmdlRGlzdGFuY2UgLyBNYXRoLm1heCgxLCBjb3VudCAtIHBhZGRpbmdJbm5lciArIHBhZGRpbmdPdXRlciAqIDIpO1xuICAgIH1cbiAgICBjb25zdCBzdGVwID0gcm91bmQ1ID8gTWF0aC5mbG9vcihyYXdTdGVwKSA6IHJhd1N0ZXA7XG4gICAgbGV0IGluc2V0ID0gcjAgKyAocmFuZ2VEaXN0YW5jZSAtIHN0ZXAgKiAoY291bnQgLSBwYWRkaW5nSW5uZXIpKSAvIDI7XG4gICAgbGV0IGJhbmR3aWR0aCA9IHN0ZXAgKiAoMSAtIHBhZGRpbmdJbm5lcik7XG4gICAgaWYgKHJvdW5kNSkge1xuICAgICAgaW5zZXQgPSBNYXRoLnJvdW5kKGluc2V0KTtcbiAgICAgIGJhbmR3aWR0aCA9IE1hdGgucm91bmQoYmFuZHdpZHRoKTtcbiAgICB9XG4gICAgdGhpcy5fc3RlcCA9IHN0ZXA7XG4gICAgdGhpcy5faW5zZXQgPSBpbnNldDtcbiAgICB0aGlzLl9iYW5kd2lkdGggPSBiYW5kd2lkdGg7XG4gICAgdGhpcy5fcmF3QmFuZHdpZHRoID0gcmF3U3RlcCAqICgxIC0gcGFkZGluZ0lubmVyKTtcbiAgfVxuICBvcmRpbmFsUmFuZ2UoaSkge1xuICAgIGNvbnN0IHsgX2luc2V0OiBpbnNldCwgX3N0ZXA6IHN0ZXAsIHJhbmdlOiByYW5nZTMgfSA9IHRoaXM7XG4gICAgY29uc3QgbWluID0gTWF0aC5taW4ocmFuZ2UzWzBdLCByYW5nZTNbMV0pO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHJhbmdlM1swXSwgcmFuZ2UzWzFdKTtcbiAgICByZXR1cm4gY2xhbXAobWluLCBpbnNldCArIHN0ZXAgKiBpLCBtYXgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQmFuZFNjYWxlLnByb3RvdHlwZSwgXCJyYW5nZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0JhbmRTY2FsZS5wcm90b3R5cGUsIFwicm91bmRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9CYW5kU2NhbGUucHJvdG90eXBlLCBcImludGVydmFsXCIsIDIpO1xudmFyIEJhbmRTY2FsZSA9IF9CYW5kU2NhbGU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL2NhdGVnb3J5U2NhbGUudHNcbnZhciBDYXRlZ29yeVNjYWxlID0gY2xhc3MgZXh0ZW5kcyBCYW5kU2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9IFwiYmFuZFwiO1xuICAgIC8qKlxuICAgICAqIE1hcHMgZGF0dW0gdG8gaXRzIGluZGV4IGluIHRoZSB7QGxpbmsgZG9tYWlufSBhcnJheS5cbiAgICAgKiBVc2VkIHRvIGNoZWNrIGZvciBkdXBsaWNhdGUgZGF0YSAobm90IGFsbG93ZWQpLlxuICAgICAqL1xuICAgIHRoaXMuaW5kZXggPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQ29udGFpbnMgdW5pcXVlIGRhdGEgb25seS5cbiAgICAgKi9cbiAgICB0aGlzLl9kb21haW4gPSBbXTtcbiAgfVxuICBzZXQgZG9tYWluKHZhbHVlcykge1xuICAgIGlmICh0aGlzLl9kb21haW4gPT09IHZhbHVlcylcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgIHRoaXMuX2RvbWFpbiA9IHZhbHVlcztcbiAgICB0aGlzLmluZGV4ID0gdm9pZCAwO1xuICB9XG4gIGdldCBkb21haW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvbWFpbjtcbiAgfVxuICBub3JtYWxpemVEb21haW5zKC4uLmRvbWFpbnMpIHtcbiAgICBsZXQgbm9ybWFsaXplZERvbWFpbiA9IHZvaWQgMDtcbiAgICBjb25zdCBzZWVuRG9tYWlucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgbGV0IGFuaW1hdGFibGUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgZG9tYWluIG9mIGRvbWFpbnMpIHtcbiAgICAgIGlmIChzZWVuRG9tYWlucy5oYXMoZG9tYWluKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBzZWVuRG9tYWlucy5hZGQoZG9tYWluKTtcbiAgICAgIGlmIChub3JtYWxpemVkRG9tYWluID09IG51bGwpIHtcbiAgICAgICAgbm9ybWFsaXplZERvbWFpbiA9IGRlZHVwbGljYXRlQ2F0ZWdvcmllcyhkb21haW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5pbWF0YWJsZSAmJiAoYW5pbWF0YWJsZSA9IGRvbWFpbk9yZGVyZWRUb05vcm1hbGl6ZWREb21haW4oZG9tYWluLCBub3JtYWxpemVkRG9tYWluKSk7XG4gICAgICAgIG5vcm1hbGl6ZWREb21haW4gPSBkZWR1cGxpY2F0ZUNhdGVnb3JpZXMoWy4uLm5vcm1hbGl6ZWREb21haW4sIC4uLmRvbWFpbl0pO1xuICAgICAgfVxuICAgIH1cbiAgICBub3JtYWxpemVkRG9tYWluID8/IChub3JtYWxpemVkRG9tYWluID0gW10pO1xuICAgIHJldHVybiB7IGRvbWFpbjogbm9ybWFsaXplZERvbWFpbiwgYW5pbWF0YWJsZSB9O1xuICB9XG4gIHRvRG9tYWluKF92YWx1ZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaW52ZXJ0KHBvc2l0aW9uLCBuZWFyZXN0ID0gZmFsc2UpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCBvZmZzZXQ0ID0gbmVhcmVzdCA/IHRoaXMuYmFuZHdpZHRoIC8gMiA6IDA7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmludmVydE5lYXJlc3RJbmRleChNYXRoLm1heCgwLCBwb3NpdGlvbiAtIG9mZnNldDQpKTtcbiAgICBjb25zdCBtYXRjaGVzID0gbmVhcmVzdCB8fCBwb3NpdGlvbiA9PT0gdGhpcy5vcmRpbmFsUmFuZ2UoaW5kZXgpO1xuICAgIHJldHVybiBtYXRjaGVzID8gdGhpcy5kb21haW5baW5kZXhdIDogdm9pZCAwO1xuICB9XG4gIGdldEluZGV4KHZhbHVlKSB7XG4gICAgbGV0IHsgaW5kZXggfSA9IHRoaXM7XG4gICAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgZG9tYWluIH0gPSB0aGlzO1xuICAgICAgaW5kZXggPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb21haW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW5kZXguc2V0KGRhdGVUb051bWJlcihkb21haW5baV0pLCBpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4LmdldChkYXRlVG9OdW1iZXIodmFsdWUpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGRlZHVwbGljYXRlQ2F0ZWdvcmllcyhkKSB7XG4gIGxldCBkb21haW47XG4gIGNvbnN0IHVuaXF1ZVZhbHVlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgZCkge1xuICAgIGNvbnN0IGtleSA9IGRhdGVUb051bWJlcih2YWx1ZSk7XG4gICAgY29uc3QgbGFzdFNpemUgPSB1bmlxdWVWYWx1ZXMuc2l6ZTtcbiAgICB1bmlxdWVWYWx1ZXMuYWRkKGtleSk7XG4gICAgY29uc3QgaXNVbmlxdWVWYWx1ZSA9IHVuaXF1ZVZhbHVlcy5zaXplICE9PSBsYXN0U2l6ZTtcbiAgICBpZiAoaXNVbmlxdWVWYWx1ZSkge1xuICAgICAgZG9tYWluPy5wdXNoKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9tYWluID8/IChkb21haW4gPSBkLnNsaWNlKDAsIHVuaXF1ZVZhbHVlcy5zaXplKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkb21haW4gPz8gZDtcbn1cbmZ1bmN0aW9uIGRvbWFpbk9yZGVyZWRUb05vcm1hbGl6ZWREb21haW4oZG9tYWluLCBub3JtYWxpemVkRG9tYWluKSB7XG4gIGxldCBub3JtYWxpemVkSW5kZXggPSAtMTtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBkb21haW4pIHtcbiAgICBjb25zdCBub3JtYWxpemVkTmV4dEluZGV4ID0gbm9ybWFsaXplZERvbWFpbi5pbmRleE9mKHZhbHVlKTtcbiAgICBpZiAobm9ybWFsaXplZE5leHRJbmRleCA9PT0gLTEpIHtcbiAgICAgIG5vcm1hbGl6ZWRJbmRleCA9IEluZmluaXR5O1xuICAgIH0gZWxzZSBpZiAobm9ybWFsaXplZE5leHRJbmRleCA8PSBub3JtYWxpemVkSW5kZXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplZEluZGV4ID0gbm9ybWFsaXplZE5leHRJbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvcHJvcGVydGllcy50c1xudmFyIEJhc2VQcm9wZXJ0aWVzID0gY2xhc3Mge1xuICBzZXQocHJvcGVydGllcykge1xuICAgIGNvbnN0IHsgY2xhc3NOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIGlmICh0eXBlb2YgcHJvcGVydGllcyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgbG9nZ2VyX2V4cG9ydHMud2FybihgdW5hYmxlIHRvIHNldCAke2NsYXNzTmFtZX0gLSBleHBlY3RpbmcgYSBwcm9wZXJ0aWVzIG9iamVjdGApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHByb3BlcnRpZXMpKTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5S2V5IG9mIGxpc3REZWNvcmF0ZWRQcm9wZXJ0aWVzKHRoaXMpKSB7XG4gICAgICBpZiAoa2V5cy5oYXMocHJvcGVydHlLZXkpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcGVydGllc1twcm9wZXJ0eUtleV07XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoaXNQcm9wZXJ0aWVzKHNlbGZbcHJvcGVydHlLZXldKSkge1xuICAgICAgICAgIGlmIChzZWxmW3Byb3BlcnR5S2V5XSBpbnN0YW5jZW9mIFByb3BlcnRpZXNBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgYXJyYXkyID0gc2VsZltwcm9wZXJ0eUtleV0ucmVzZXQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGFycmF5MiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHNlbGZbcHJvcGVydHlLZXldID0gYXJyYXkyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG9nZ2VyX2V4cG9ydHMud2FybihgdW5hYmxlIHRvIHNldCBbJHtwcm9wZXJ0eUtleX1dIC0gZXhwZWN0aW5nIGEgcHJvcGVydGllcyBhcnJheWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmW3Byb3BlcnR5S2V5XS5zZXQodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmW3Byb3BlcnR5S2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGtleXMuZGVsZXRlKHByb3BlcnR5S2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB1bmtub3duS2V5IG9mIGtleXMpIHtcbiAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm4oYHVuYWJsZSB0byBzZXQgWyR7dW5rbm93bktleX1dIGluICR7Y2xhc3NOYW1lfSAtIHByb3BlcnR5IGlzIHVua25vd25gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaXNWYWxpZCh3YXJuaW5nUHJlZml4KSB7XG4gICAgcmV0dXJuIGxpc3REZWNvcmF0ZWRQcm9wZXJ0aWVzKHRoaXMpLmV2ZXJ5KChwcm9wZXJ0eUtleSkgPT4ge1xuICAgICAgY29uc3QgeyBvcHRpb25hbCB9ID0gZXh0cmFjdERlY29yYXRlZFByb3BlcnR5TWV0YWRhdGEodGhpcywgcHJvcGVydHlLZXkpO1xuICAgICAgY29uc3QgdmFsaWQgPSBvcHRpb25hbCA9PT0gdHJ1ZSB8fCB0eXBlb2YgdGhpc1twcm9wZXJ0eUtleV0gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKGAke3dhcm5pbmdQcmVmaXggPz8gXCJcIn1bJHtwcm9wZXJ0eUtleX1dIGlzIHJlcXVpcmVkLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH0pO1xuICB9XG4gIHRvSnNvbigpIHtcbiAgICByZXR1cm4gbGlzdERlY29yYXRlZFByb3BlcnRpZXModGhpcykucmVkdWNlKChvYmplY3QyLCBwcm9wZXJ0eUtleSkgPT4ge1xuICAgICAgY29uc3QgcHJvcGVydHlWYWx1ZSA9IHRoaXNbcHJvcGVydHlLZXldO1xuICAgICAgb2JqZWN0Mltwcm9wZXJ0eUtleV0gPSBpc1Byb3BlcnRpZXMocHJvcGVydHlWYWx1ZSkgPyBwcm9wZXJ0eVZhbHVlLnRvSnNvbigpIDogcHJvcGVydHlWYWx1ZTtcbiAgICAgIHJldHVybiBvYmplY3QyO1xuICAgIH0sIHt9KTtcbiAgfVxufTtcbnZhciBQcm9wZXJ0aWVzQXJyYXkgPSBjbGFzcyBfUHJvcGVydGllc0FycmF5IGV4dGVuZHMgQXJyYXkge1xuICBjb25zdHJ1Y3RvcihpdGVtRmFjdG9yeSwgLi4ucHJvcGVydGllcykge1xuICAgIHN1cGVyKHByb3BlcnRpZXMubGVuZ3RoKTtcbiAgICBjb25zdCBpc0NvbnN0cnVjdG9yID0gKHZhbHVlMikgPT4gQm9vbGVhbih2YWx1ZTI/LnByb3RvdHlwZT8uY29uc3RydWN0b3I/Lm5hbWUpO1xuICAgIGNvbnN0IHZhbHVlID0gaXNDb25zdHJ1Y3RvcihpdGVtRmFjdG9yeSkgPyAocGFyYW1zKSA9PiBuZXcgaXRlbUZhY3RvcnkoKS5zZXQocGFyYW1zKSA6IGl0ZW1GYWN0b3J5O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIml0ZW1GYWN0b3J5XCIsIHsgdmFsdWUsIGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlIH0pO1xuICAgIHRoaXMuc2V0KHByb3BlcnRpZXMpO1xuICB9XG4gIHNldChwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKGlzQXJyYXkocHJvcGVydGllcykpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gcHJvcGVydGllcy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpc1tpXSA9IHRoaXMuaXRlbUZhY3RvcnkocHJvcGVydGllc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc2V0KHByb3BlcnRpZXMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0aWVzKSkge1xuICAgICAgcmV0dXJuIG5ldyBfUHJvcGVydGllc0FycmF5KHRoaXMuaXRlbUZhY3RvcnksIC4uLnByb3BlcnRpZXMpO1xuICAgIH1cbiAgfVxuICB0b0pzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKCh2YWx1ZSkgPT4gdmFsdWU/LnRvSnNvbj8uKCkgPz8gdmFsdWUpO1xuICB9XG59O1xuZnVuY3Rpb24gaXNQcm9wZXJ0aWVzKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEJhc2VQcm9wZXJ0aWVzIHx8IHZhbHVlIGluc3RhbmNlb2YgUHJvcGVydGllc0FycmF5O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3ZhbGlkYXRpb24udHNcbmZ1bmN0aW9uIFZhbGlkYXRlKHByZWRpY2F0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgb3B0aW9uYWwgPSBmYWxzZSwgcHJvcGVydHk6IG92ZXJyaWRlUHJvcGVydHkgfSA9IG9wdGlvbnM7XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoXG4gICAgKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBjb250ZXh0ID0geyAuLi5vcHRpb25zLCB0YXJnZXQsIHByb3BlcnR5IH07XG4gICAgICBpZiAob3B0aW9uYWwgJiYgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IHByZWRpY2F0ZSh2YWx1ZSwgY29udGV4dCkpIHtcbiAgICAgICAgaWYgKGlzUHJvcGVydGllcyh0YXJnZXRbcHJvcGVydHldKSAmJiAhaXNQcm9wZXJ0aWVzKHZhbHVlKSkge1xuICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eV0uc2V0KHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjbGVhbktleSA9IG92ZXJyaWRlUHJvcGVydHkgPz8gU3RyaW5nKHByb3BlcnR5KS5yZXBsYWNlKC9eXyovLCBcIlwiKTtcbiAgICAgIGNvbnN0IHRhcmdldE5hbWUgPSB0YXJnZXQuY29uc3RydWN0b3IuY2xhc3NOYW1lID8/IHRhcmdldC5jb25zdHJ1Y3Rvci5uYW1lLnJlcGxhY2UoL1Byb3BlcnRpZXMkLywgXCJcIik7XG4gICAgICBjb25zdCB2YWx1ZVN0cmluZyA9IHN0cmluZ2lmeVZhbHVlKHZhbHVlLCA1MCk7XG4gICAgICBsb2dnZXJfZXhwb3J0cy53YXJuKFxuICAgICAgICBgUHJvcGVydHkgWyR7Y2xlYW5LZXl9XSBvZiBbJHt0YXJnZXROYW1lfV0gY2Fubm90IGJlIHNldCB0byBbJHt2YWx1ZVN0cmluZ31dJHtwcmVkaWNhdGUubWVzc2FnZSA/IGA7IGV4cGVjdGluZyAke2dldFByZWRpY2F0ZU1lc3NhZ2UocHJlZGljYXRlLCBjb250ZXh0KX1gIDogXCJcIn0sIGlnbm9yaW5nLmBcbiAgICAgICk7XG4gICAgICByZXR1cm4gQlJFQUtfVFJBTlNGT1JNX0NIQUlOO1xuICAgIH0sXG4gICAgdm9pZCAwLFxuICAgIHsgb3B0aW9uYWwgfVxuICApO1xufVxudmFyIEFORCA9ICguLi5wcmVkaWNhdGVzKSA9PiB7XG4gIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gIHJldHVybiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgICAodmFsdWUsIGN0eCkgPT4ge1xuICAgICAgbWVzc2FnZXMubGVuZ3RoID0gMDtcbiAgICAgIHJldHVybiBwcmVkaWNhdGVzLmV2ZXJ5KChwcmVkaWNhdGUpID0+IHtcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IHByZWRpY2F0ZSh2YWx1ZSwgY3R4KTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgbWVzc2FnZXMucHVzaChnZXRQcmVkaWNhdGVNZXNzYWdlKHByZWRpY2F0ZSwgY3R4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgICB9KTtcbiAgICB9LFxuICAgICgpID0+IG1lc3NhZ2VzLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIEFORCBcIilcbiAgKTtcbn07XG52YXIgT1IgPSAoLi4ucHJlZGljYXRlcykgPT4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICh2YWx1ZSwgY3R4KSA9PiBwcmVkaWNhdGVzLnNvbWUoKHByZWRpY2F0ZSkgPT4gcHJlZGljYXRlKHZhbHVlLCBjdHgpKSxcbiAgKGN0eCkgPT4gcHJlZGljYXRlcy5tYXAoZ2V0UHJlZGljYXRlTWVzc2FnZU1hcHBlcihjdHgpKS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBPUiBcIilcbik7XG52YXIgT0JKRUNUID0gYXR0YWNoT2JqZWN0UmVzdHJpY3Rpb25zKFxuICBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgICAodmFsdWUsIGN0eCkgPT4gaXNQcm9wZXJ0aWVzKHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkgJiYgaXNQcm9wZXJ0aWVzKGN0eC50YXJnZXRbY3R4LnByb3BlcnR5XSksXG4gICAgXCJhIHByb3BlcnRpZXMgb2JqZWN0XCJcbiAgKVxuKTtcbnZhciBQTEFJTl9PQkpFQ1QgPSBhdHRhY2hPYmplY3RSZXN0cmljdGlvbnMocHJlZGljYXRlV2l0aE1lc3NhZ2UoKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSksIFwiYW4gb2JqZWN0XCIpKTtcbnZhciBCT09MRUFOID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoaXNCb29sZWFuLCBcImEgYm9vbGVhblwiKTtcbnZhciBGVU5DVElPTiA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKGlzRnVuY3Rpb24sIFwiYSBmdW5jdGlvblwiKTtcbnZhciBTVFJJTkcgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShpc1N0cmluZywgXCJhIHN0cmluZ1wiKTtcbnZhciBOVU1CRVIgPSBhdHRhY2hOdW1iZXJSZXN0cmljdGlvbnMocHJlZGljYXRlV2l0aE1lc3NhZ2UoaXNGaW5pdGVOdW1iZXIsIFwiYSBudW1iZXJcIikpO1xudmFyIFJFQUxfTlVNQkVSID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHZhbHVlKSA9PiBpc051bWJlcih2YWx1ZSkgJiYgIWlzTmFOKHZhbHVlKSwgXCJhIHJlYWwgbnVtYmVyXCIpO1xudmFyIE5BTiA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2YWx1ZSkgPT4gaXNOdW1iZXIodmFsdWUpICYmIGlzTmFOKHZhbHVlKSwgXCJOYU5cIik7XG52YXIgUE9TSVRJVkVfTlVNQkVSID0gTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAwIH0pO1xudmFyIFJBVElPID0gTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAwLCBtYXg6IDEgfSk7XG52YXIgTlVNQkVSX09SX05BTiA9IE9SKE5VTUJFUiwgTkFOKTtcbnZhciBBUlJBWSA9IGF0dGFjaEFycmF5UmVzdHJpY3Rpb25zKHByZWRpY2F0ZVdpdGhNZXNzYWdlKGlzQXJyYXksIFwiYW4gYXJyYXlcIikpO1xudmFyIEFSUkFZX09GID0gKHByZWRpY2F0ZSwgbWVzc2FnZSkgPT4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICh2YWx1ZSwgY3R4KSA9PiBpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeSgoaXRlbSkgPT4gcHJlZGljYXRlKGl0ZW0sIGN0eCkpLFxuICAoY3R4KSA9PiB7XG4gICAgY29uc3QgYXJyYXlNZXNzYWdlID0gZ2V0UHJlZGljYXRlTWVzc2FnZShBUlJBWSwgY3R4KSA/PyBcIlwiO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYCR7YXJyYXlNZXNzYWdlfSBvZiAke21lc3NhZ2UoY3R4KX1gO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZSA/IGAke2FycmF5TWVzc2FnZX0gb2YgJHttZXNzYWdlfWAgOiBhcnJheU1lc3NhZ2U7XG4gIH1cbik7XG52YXIgaXNDb21wYXJhYmxlMiA9ICh2YWx1ZSkgPT4gaXNGaW5pdGVOdW1iZXIodmFsdWUpIHx8IGlzVmFsaWREYXRlKHZhbHVlKTtcbnZhciBMRVNTX1RIQU4gPSAob3RoZXJGaWVsZCkgPT4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICh2LCBjdHgpID0+ICFpc0NvbXBhcmFibGUyKHYpIHx8ICFpc0NvbXBhcmFibGUyKGN0eC50YXJnZXRbb3RoZXJGaWVsZF0pIHx8IHYgPCBjdHgudGFyZ2V0W290aGVyRmllbGRdLFxuICBgdG8gYmUgbGVzcyB0aGFuICR7b3RoZXJGaWVsZH1gXG4pO1xudmFyIEdSRUFURVJfVEhBTiA9IChvdGhlckZpZWxkKSA9PiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgKHYsIGN0eCkgPT4gIWlzQ29tcGFyYWJsZTIodikgfHwgIWlzQ29tcGFyYWJsZTIoY3R4LnRhcmdldFtvdGhlckZpZWxkXSkgfHwgdiA+IGN0eC50YXJnZXRbb3RoZXJGaWVsZF0sXG4gIGB0byBiZSBncmVhdGVyIHRoYW4gJHtvdGhlckZpZWxkfWBcbik7XG52YXIgREFURSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKGlzVmFsaWREYXRlLCBcIkRhdGUgb2JqZWN0XCIpO1xudmFyIERBVEVfT1JfREFURVRJTUVfTVMgPSBPUihEQVRFLCBQT1NJVElWRV9OVU1CRVIpO1xudmFyIGNvbG9yTWVzc2FnZSA9IGBBIGNvbG9yIHN0cmluZyBjYW4gYmUgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0cyB0byBiZSB2YWxpZDogI3JnYiwgI3JyZ2diYiwgcmdiKHIsIGcsIGIpLCByZ2JhKHIsIGcsIGIsIGEpIG9yIGEgQ1NTIGNvbG9yIG5hbWUgc3VjaCBhcyAnd2hpdGUnLCAnb3JhbmdlJywgJ2N5YW4nLCBldGNgO1xudmFyIENPTE9SX1NUUklORyA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAodikgPT4gaXNTdHJpbmcodikgJiYgQ29sb3IudmFsaWRDb2xvclN0cmluZyh2KSxcbiAgYGNvbG9yIFN0cmluZy4gJHtjb2xvck1lc3NhZ2V9YFxuKTtcbnZhciBDT0xPUl9HUkFESUVOVCA9IGF0dGFjaE9iamVjdFJlc3RyaWN0aW9ucyhcbiAgcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUudHlwZSA9PT0gXCJncmFkaWVudFwiLCBcImEgY29sb3IgZ3JhZGllbnQgb2JqZWN0XCIpXG4pO1xudmFyIENPTE9SX1NUUklOR19BUlJBWSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKEFSUkFZX09GKENPTE9SX1NUUklORyksIGBjb2xvciBzdHJpbmdzLiAke2NvbG9yTWVzc2FnZX1gKTtcbnZhciBCT09MRUFOX0FSUkFZID0gQVJSQVlfT0YoQk9PTEVBTiwgXCJib29sZWFuIHZhbHVlc1wiKTtcbnZhciBOVU1CRVJfQVJSQVkgPSBBUlJBWV9PRihOVU1CRVIsIFwibnVtYmVyc1wiKTtcbnZhciBTVFJJTkdfQVJSQVkgPSBBUlJBWV9PRihTVFJJTkcsIFwic3RyaW5nc1wiKTtcbnZhciBEQVRFX0FSUkFZID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoQVJSQVlfT0YoREFURSksIFwiRGF0ZSBvYmplY3RzXCIpO1xudmFyIE9CSkVDVF9BUlJBWSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKEFSUkFZX09GKE9CSkVDVCksIFwib2JqZWN0c1wiKTtcbnZhciBMSU5FX0NBUCA9IFVOSU9OKFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXSwgXCJhIGxpbmUgY2FwXCIpO1xudmFyIExJTkVfSk9JTiA9IFVOSU9OKFtcInJvdW5kXCIsIFwiYmV2ZWxcIiwgXCJtaXRlclwiXSwgXCJhIGxpbmUgam9pblwiKTtcbnZhciBMSU5FX1NUWUxFID0gVU5JT04oW1wic29saWRcIiwgXCJkYXNoZWRcIiwgXCJkb3R0ZWRcIl0sIFwiYSBsaW5lIHN0eWxlXCIpO1xudmFyIExJTkVfREFTSCA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICBBUlJBWV9PRihQT1NJVElWRV9OVU1CRVIpLFxuICBcIm51bWJlcnMgc3BlY2lmeWluZyB0aGUgbGVuZ3RoIGluIHBpeGVscyBvZiBhbHRlcm5hdGluZyBkYXNoZXMgYW5kIGdhcHMsIGZvciBleGFtcGxlLCBbNiwgM10gbWVhbnMgZGFzaGVzIHdpdGggYSBsZW5ndGggb2YgNiBwaXhlbHMgd2l0aCBnYXBzIGJldHdlZW4gb2YgMyBwaXhlbHMuXCJcbik7XG52YXIgUE9TSVRJT04gPSBVTklPTihbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIl0sIFwiYSBwb3NpdGlvblwiKTtcbnZhciBGT05UX1NUWUxFID0gVU5JT04oW1wibm9ybWFsXCIsIFwiaXRhbGljXCIsIFwib2JsaXF1ZVwiXSwgXCJhIGZvbnQgc3R5bGVcIik7XG52YXIgRk9OVF9XRUlHSFQgPSBPUihcbiAgVU5JT04oW1wibm9ybWFsXCIsIFwiYm9sZFwiLCBcImJvbGRlclwiLCBcImxpZ2h0ZXJcIl0sIFwiYSBmb250IHdlaWdodFwiKSxcbiAgTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAxLCBtYXg6IDFlMyB9KVxuKTtcbnZhciBURVhUX1dSQVAgPSBVTklPTihbXCJuZXZlclwiLCBcImFsd2F5c1wiLCBcImh5cGhlbmF0ZVwiLCBcIm9uLXNwYWNlXCJdLCBcImEgdGV4dCB3cmFwIHN0cmF0ZWd5XCIpO1xudmFyIFRFWFRfQUxJR04gPSBVTklPTihbXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIl0sIFwiYSB0ZXh0IGFsaWduXCIpO1xudmFyIFZFUlRJQ0FMX0FMSUdOID0gVU5JT04oW1widG9wXCIsIFwibWlkZGxlXCIsIFwiYm90dG9tXCJdLCBcImEgdmVydGljYWwgYWxpZ25cIik7XG52YXIgT1ZFUkZMT1dfU1RSQVRFR1kgPSBVTklPTihbXCJlbGxpcHNpc1wiLCBcImhpZGVcIl0sIFwiYW4gb3ZlcmZsb3cgc3RyYXRlZ3lcIik7XG52YXIgRElSRUNUSU9OID0gVU5JT04oW1wiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCJdLCBcImEgZGlyZWN0aW9uXCIpO1xudmFyIFBMQUNFTUVOVCA9IFVOSU9OKFtcImluc2lkZVwiLCBcIm91dHNpZGVcIl0sIFwiYSBwbGFjZW1lbnRcIik7XG52YXIgSU5URVJBQ1RJT05fUkFOR0UgPSBPUihVTklPTihbXCJleGFjdFwiLCBcIm5lYXJlc3RcIl0sIFwiaW50ZXJhY3Rpb24gcmFuZ2VcIiksIE5VTUJFUik7XG52YXIgTEFCRUxfUExBQ0VNRU5UID0gVU5JT04oW1widG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdKTtcbmZ1bmN0aW9uIFVOSU9OKG9wdGlvbnMsIG1lc3NhZ2UgPSBcImFcIikge1xuICByZXR1cm4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICAgKHYsIGN0eCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uID0gb3B0aW9ucy5maW5kKChvKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIG8gPT09IFwic3RyaW5nXCIgPyBvIDogby52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHYgPT09IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICBpZiAob3B0aW9uID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uICE9PSBcInN0cmluZ1wiICYmIChvcHRpb24uZGVwcmVjYXRlZCA9PT0gdHJ1ZSB8fCBvcHRpb24uZGVwcmVjYXRlZFRvICE9IG51bGwpKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gW2BQcm9wZXJ0eSBbJXNdIHdpdGggdmFsdWUgJyR7b3B0aW9uLnZhbHVlfScgaXMgZGVwcmVjYXRlZC5gXTtcbiAgICAgICAgaWYgKG9wdGlvbi5kZXByZWNhdGVkVG8pIHtcbiAgICAgICAgICBtZXNzYWdlcy5wdXNoKGBVc2UgJHtvcHRpb24uZGVwcmVjYXRlZFRvfSBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKG1lc3NhZ2VzLmpvaW4oXCIgXCIpLCBjdHgucHJvcGVydHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBgJHttZXNzYWdlfSBrZXl3b3JkIHN1Y2ggYXMgJHtqb2luVW5pb25PcHRpb25zKG9wdGlvbnMpfWBcbiAgKTtcbn1cbnZhciBNSU5fU1BBQ0lORyA9IE9SKEFORChOVU1CRVIucmVzdHJpY3QoeyBtaW46IDEgfSksIExFU1NfVEhBTihcIm1heFNwYWNpbmdcIikpLCBOQU4pO1xudmFyIE1BWF9TUEFDSU5HID0gT1IoQU5EKE5VTUJFUi5yZXN0cmljdCh7IG1pbjogMSB9KSwgR1JFQVRFUl9USEFOKFwibWluU3BhY2luZ1wiKSksIE5BTik7XG5mdW5jdGlvbiBwcmVkaWNhdGVXaXRoTWVzc2FnZShwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcbiAgcHJlZGljYXRlLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICByZXR1cm4gcHJlZGljYXRlO1xufVxuZnVuY3Rpb24gam9pblVuaW9uT3B0aW9ucyhvcHRpb25zKSB7XG4gIGNvbnN0IHZhbHVlcyA9IG9wdGlvbnMuZmlsdGVyKChvcHRpb24pID0+IHR5cGVvZiBvcHRpb24gPT09IFwic3RyaW5nXCIgfHwgb3B0aW9uLnVuZG9jdW1lbnRlZCAhPT0gdHJ1ZSkubWFwKChvcHRpb24pID0+IGAnJHt0eXBlb2Ygb3B0aW9uID09PSBcInN0cmluZ1wiID8gb3B0aW9uIDogb3B0aW9uLnZhbHVlfSdgKTtcbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdmFsdWVzWzBdO1xuICB9XG4gIGNvbnN0IGxhc3RWYWx1ZSA9IHZhbHVlcy5wb3AoKTtcbiAgcmV0dXJuIGAke3ZhbHVlcy5qb2luKFwiLCBcIil9IG9yICR7bGFzdFZhbHVlfWA7XG59XG5mdW5jdGlvbiBnZXRQcmVkaWNhdGVNZXNzYWdlKHByZWRpY2F0ZSwgY3R4KSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHByZWRpY2F0ZS5tZXNzYWdlKSA/IHByZWRpY2F0ZS5tZXNzYWdlKGN0eCkgOiBwcmVkaWNhdGUubWVzc2FnZTtcbn1cbmZ1bmN0aW9uIGdldFByZWRpY2F0ZU1lc3NhZ2VNYXBwZXIoY3R4KSB7XG4gIHJldHVybiAocHJlZGljYXRlKSA9PiBnZXRQcmVkaWNhdGVNZXNzYWdlKHByZWRpY2F0ZSwgY3R4KTtcbn1cbmZ1bmN0aW9uIGF0dGFjaEFycmF5UmVzdHJpY3Rpb25zKHByZWRpY2F0ZSkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihwcmVkaWNhdGUsIHtcbiAgICByZXN0cmljdCh7IGxlbmd0aDogbGVuZ3RoMiwgbWluTGVuZ3RoIH0gPSB7fSkge1xuICAgICAgbGV0IG1lc3NhZ2UgPSBcImFuIGFycmF5XCI7XG4gICAgICBpZiAoaXNOdW1iZXIobWluTGVuZ3RoKSAmJiBtaW5MZW5ndGggPiAwKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcImEgbm9uLWVtcHR5IGFycmF5XCI7XG4gICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGxlbmd0aDIpKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBgYW4gYXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3RoMn1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAgICAgICAodmFsdWUpID0+IGlzQXJyYXkodmFsdWUpICYmIChpc051bWJlcihsZW5ndGgyKSA/IHZhbHVlLmxlbmd0aCA9PT0gbGVuZ3RoMiA6IHRydWUpICYmIChpc051bWJlcihtaW5MZW5ndGgpID8gdmFsdWUubGVuZ3RoID49IG1pbkxlbmd0aCA6IHRydWUpLFxuICAgICAgICBtZXNzYWdlXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBhdHRhY2hOdW1iZXJSZXN0cmljdGlvbnMocHJlZGljYXRlKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHByZWRpY2F0ZSwge1xuICAgIHJlc3RyaWN0KHsgbWluLCBtYXggfSA9IHt9KSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gW1wiYSBudW1iZXJcIl07XG4gICAgICBjb25zdCBoYXNNaW4gPSBpc051bWJlcihtaW4pO1xuICAgICAgY29uc3QgaGFzTWF4ID0gaXNOdW1iZXIobWF4KTtcbiAgICAgIGlmIChoYXNNaW4gJiYgaGFzTWF4KSB7XG4gICAgICAgIG1lc3NhZ2UucHVzaChgYmV0d2VlbiAke21pbn0gYW5kICR7bWF4fSBpbmNsdXNpdmVgKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzTWluKSB7XG4gICAgICAgIG1lc3NhZ2UucHVzaChgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7bWlufWApO1xuICAgICAgfSBlbHNlIGlmIChoYXNNYXgpIHtcbiAgICAgICAgbWVzc2FnZS5wdXNoKGBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJHttYXh9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICAgICAgICh2YWx1ZSkgPT4gaXNGaW5pdGVOdW1iZXIodmFsdWUpICYmIChoYXNNaW4gPyB2YWx1ZSA+PSBtaW4gOiB0cnVlKSAmJiAoaGFzTWF4ID8gdmFsdWUgPD0gbWF4IDogdHJ1ZSksXG4gICAgICAgIG1lc3NhZ2Uuam9pbihcIiBcIilcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGF0dGFjaE9iamVjdFJlc3RyaWN0aW9ucyhwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJlZGljYXRlLCB7XG4gICAgcmVzdHJpY3Qob2JqZWN0VHlwZSkge1xuICAgICAgcmV0dXJuIHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAgICAgICAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2Ygb2JqZWN0VHlwZSxcbiAgICAgICAgKGN0eCkgPT4gZ2V0UHJlZGljYXRlTWVzc2FnZShwcmVkaWNhdGUsIGN0eCkgPz8gYGFuIGluc3RhbmNlIG9mICR7b2JqZWN0VHlwZS5uYW1lfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW90aW9uL3Jlc2V0TW90aW9uLnRzXG52YXIgcmVzZXRNb3Rpb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocmVzZXRNb3Rpb25fZXhwb3J0cywge1xuICByZXNldE1vdGlvbjogKCkgPT4gcmVzZXRNb3Rpb25cbn0pO1xuZnVuY3Rpb24gcmVzZXRNb3Rpb24oc2VsZWN0aW9uc09yTm9kZXMsIHByb3BzRm4pIHtcbiAgY29uc3QgeyBub2Rlcywgc2VsZWN0aW9ucyB9ID0gZGVjb25zdHJ1Y3RTZWxlY3Rpb25zT3JOb2RlcyhzZWxlY3Rpb25zT3JOb2Rlcyk7XG4gIGZvciAoY29uc3Qgc2VsZWN0aW9uIG9mIHNlbGVjdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc2VsZWN0aW9uLm5vZGVzKCkpIHtcbiAgICAgIGNvbnN0IGZyb20zID0gcHJvcHNGbihub2RlLCBub2RlLmRhdHVtKTtcbiAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhmcm9tMyk7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gIH1cbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgY29uc3QgZnJvbTMgPSBwcm9wc0ZuKG5vZGUsIG5vZGUuZGF0dW0pO1xuICAgIG5vZGUuc2V0UHJvcGVydGllcyhmcm9tMyk7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9kZWJ1Zy50c1xudmFyIExPTkdfVElNRV9QRVJJT0RfVEhSRVNIT0xEID0gMmUzO1xudmFyIHRpbWVPZkxhc3RMb2cgPSBEYXRlLm5vdygpO1xudmFyIGxvZ1RpbWVHYXAgPSAoKSA9PiB7XG4gIGNvbnN0IHRpbWVTaW5jZUxhc3RMb2cgPSBEYXRlLm5vdygpIC0gdGltZU9mTGFzdExvZztcbiAgaWYgKHRpbWVTaW5jZUxhc3RMb2cgPiBMT05HX1RJTUVfUEVSSU9EX1RIUkVTSE9MRCkge1xuICAgIGNvbnN0IHByZXR0eUR1cmF0aW9uID0gKE1hdGguZmxvb3IodGltZVNpbmNlTGFzdExvZyAvIDEwMCkgLyAxMCkudG9GaXhlZCgxKTtcbiAgICBsb2dnZXJfZXhwb3J0cy5sb2coYCoqKiogJHtwcmV0dHlEdXJhdGlvbn1zIHNpbmNlIGxhc3QgbG9nIG1lc3NhZ2UgKioqKmApO1xuICB9XG4gIHRpbWVPZkxhc3RMb2cgPSBEYXRlLm5vdygpO1xufTtcbnZhciBEZWJ1ZyA9IHtcbiAgY3JlYXRlKC4uLmRlYnVnU2VsZWN0b3JzKSB7XG4gICAgY29uc3QgcmVzdWx0Rm4gPSAoLi4ubG9nQ29udGVudCkgPT4ge1xuICAgICAgaWYgKERlYnVnLmNoZWNrKC4uLmRlYnVnU2VsZWN0b3JzKSkge1xuICAgICAgICBpZiAodHlwZW9mIGxvZ0NvbnRlbnRbMF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGxvZ0NvbnRlbnQgPSB0b0FycmF5KGxvZ0NvbnRlbnRbMF0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nVGltZUdhcCgpO1xuICAgICAgICBsb2dnZXJfZXhwb3J0cy5sb2coLi4ubG9nQ29udGVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihyZXN1bHRGbiwge1xuICAgICAgY2hlY2s6ICgpID0+IERlYnVnLmNoZWNrKC4uLmRlYnVnU2VsZWN0b3JzKSxcbiAgICAgIGdyb3VwOiAobmFtZSwgY2IpID0+IHtcbiAgICAgICAgaWYgKERlYnVnLmNoZWNrKC4uLmRlYnVnU2VsZWN0b3JzKSkge1xuICAgICAgICAgIHJldHVybiBsb2dnZXJfZXhwb3J0cy5sb2dHcm91cChuYW1lLCBjYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGNoZWNrKC4uLmRlYnVnU2VsZWN0b3JzKSB7XG4gICAgaWYgKGRlYnVnU2VsZWN0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVidWdTZWxlY3RvcnMucHVzaCh0cnVlKTtcbiAgICB9XG4gICAgY29uc3QgY2hhcnREZWJ1ZyA9IHRvQXJyYXkoZ2V0V2luZG93KFwiYWdDaGFydHNEZWJ1Z1wiKSk7XG4gICAgcmV0dXJuIGNoYXJ0RGVidWcuc29tZSgoc2VsZWN0b3IpID0+IGRlYnVnU2VsZWN0b3JzLmluY2x1ZGVzKHNlbGVjdG9yKSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2NhbnZhcy9jYW52YXNVdGlsLnRzXG5mdW5jdGlvbiBjbGVhckNvbnRleHQoe1xuICBjb250ZXh0LFxuICBwaXhlbFJhdGlvLFxuICB3aWR0aDogd2lkdGgyLFxuICBoZWlnaHQ6IGhlaWdodDJcbn0pIHtcbiAgY29udGV4dC5zYXZlKCk7XG4gIGNvbnRleHQucmVzZXRUcmFuc2Zvcm0oKTtcbiAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgTWF0aC5jZWlsKHdpZHRoMiAqIHBpeGVsUmF0aW8pLCBNYXRoLmNlaWwoaGVpZ2h0MiAqIHBpeGVsUmF0aW8pKTtcbiAgY29udGV4dC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBkZWJ1Z0NvbnRleHQoY3R4KSB7XG4gIGlmIChEZWJ1Zy5jaGVjayhcImNhbnZhc1wiKSkge1xuICAgIGNvbnN0IHNhdmUgPSBjdHguc2F2ZS5iaW5kKGN0eCk7XG4gICAgY29uc3QgcmVzdG9yZSA9IGN0eC5yZXN0b3JlLmJpbmQoY3R4KTtcbiAgICBsZXQgZGVwdGggPSAwO1xuICAgIE9iamVjdC5hc3NpZ24oY3R4LCB7XG4gICAgICBzYXZlKCkge1xuICAgICAgICBzYXZlKCk7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9LFxuICAgICAgcmVzdG9yZSgpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gVW5hYmxlIHRvIHJlc3RvcmUoKSBwYXN0IGRlcHRoIDBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdG9yZSgpO1xuICAgICAgICBkZXB0aC0tO1xuICAgICAgfSxcbiAgICAgIHZlcmlmeURlcHRoWmVybygpIHtcbiAgICAgICAgaWYgKGRlcHRoICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBTYXZlL3Jlc3RvcmUgZGVwdGggaXMgbm9uLXplcm86ICR7ZGVwdGh9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9jYW52YXMvaGRwaU9mZnNjcmVlbkNhbnZhcy50c1xuZnVuY3Rpb24gY2FudmFzRGltZW5zaW9ucyh3aWR0aDIsIGhlaWdodDIsIHBpeGVsUmF0aW8pIHtcbiAgcmV0dXJuIFtNYXRoLnJvdW5kKHdpZHRoMiAqIHBpeGVsUmF0aW8pLCBNYXRoLnJvdW5kKGhlaWdodDIgKiBwaXhlbFJhdGlvKV07XG59XG52YXIgSGRwaU9mZnNjcmVlbkNhbnZhcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyLCBwaXhlbFJhdGlvLCB3aWxsUmVhZEZyZXF1ZW50bHkgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICB0aGlzLndpZHRoID0gd2lkdGgyO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0MjtcbiAgICB0aGlzLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIGNvbnN0IFtjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0XSA9IGNhbnZhc0RpbWVuc2lvbnMod2lkdGgyLCBoZWlnaHQyLCBwaXhlbFJhdGlvKTtcbiAgICB0aGlzLmNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHsgd2lsbFJlYWRGcmVxdWVudGx5IH0pO1xuICAgIHRoaXMuY29udGV4dC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgZGVidWdDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gIH1cbiAgZHJhd0ltYWdlKGNvbnRleHQsIGR4ID0gMCwgZHkgPSAwKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuZHJhd0ltYWdlKHRoaXMuY2FudmFzLCBkeCwgZHkpO1xuICB9XG4gIHRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMudHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gIH1cbiAgcmVzaXplKHdpZHRoMiwgaGVpZ2h0MiwgcGl4ZWxSYXRpbykge1xuICAgIGlmICghKHdpZHRoMiA+IDAgJiYgaGVpZ2h0MiA+IDApKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgY2FudmFzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgIGlmICh3aWR0aDIgIT09IHRoaXMud2lkdGggfHwgaGVpZ2h0MiAhPT0gdGhpcy5oZWlnaHQgfHwgcGl4ZWxSYXRpbyAhPT0gdGhpcy5waXhlbFJhdGlvKSB7XG4gICAgICBjb25zdCBbY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodF0gPSBjYW52YXNEaW1lbnNpb25zKHdpZHRoMiwgaGVpZ2h0MiwgcGl4ZWxSYXRpbyk7XG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgfVxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDI7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQyO1xuICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgY2xlYXJDb250ZXh0KHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSAwO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCAwLCAwKTtcbiAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2FsZS9jb2xvclNjYWxlLnRzXG52YXIgY29udmVydENvbG9yU3RyaW5nVG9Pa2xjaGEgPSAodikgPT4ge1xuICBjb25zdCBjb2xvciA9IENvbG9yLmZyb21TdHJpbmcodik7XG4gIGNvbnN0IFtsLCBjLCBoXSA9IENvbG9yLlJHQnRvT0tMQ0goY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gIHJldHVybiB7IGwsIGMsIGgsIGE6IGNvbG9yLmEgfTtcbn07XG52YXIgZGVsdGEgPSAxZS02O1xudmFyIGlzQWNocm9tYXRpYyA9ICh4KSA9PiB4LmMgPCBkZWx0YSB8fCB4LmwgPCBkZWx0YSB8fCB4LmwgPiAxIC0gZGVsdGE7XG52YXIgaW50ZXJwb2xhdGVPa2xjaCA9ICh4LCB5LCBkKSA9PiB7XG4gIGQgPSBjbGFtcCgwLCBkLCAxKTtcbiAgbGV0IGg7XG4gIGlmIChpc0FjaHJvbWF0aWMoeCkpIHtcbiAgICBoID0geS5oO1xuICB9IGVsc2UgaWYgKGlzQWNocm9tYXRpYyh5KSkge1xuICAgIGggPSB4Lmg7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgeEggPSB4Lmg7XG4gICAgbGV0IHlIID0geS5oO1xuICAgIGNvbnN0IGRlbHRhSCA9IHkuaCAtIHguaDtcbiAgICBpZiAoZGVsdGFIID4gMTgwKSB7XG4gICAgICB5SCAtPSAzNjA7XG4gICAgfSBlbHNlIGlmIChkZWx0YUggPCAtMTgwKSB7XG4gICAgICB5SCArPSAzNjA7XG4gICAgfVxuICAgIGggPSB4SCAqICgxIC0gZCkgKyB5SCAqIGQ7XG4gIH1cbiAgY29uc3QgYyA9IHguYyAqICgxIC0gZCkgKyB5LmMgKiBkO1xuICBjb25zdCBsID0geC5sICogKDEgLSBkKSArIHkubCAqIGQ7XG4gIGNvbnN0IGEgPSB4LmEgKiAoMSAtIGQpICsgeS5hICogZDtcbiAgcmV0dXJuIENvbG9yLmZyb21PS0xDSChsLCBjLCBoLCBhKTtcbn07XG52YXIgQ29sb3JTY2FsZSA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gXCJjb2xvclwiO1xuICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgdGhpcy5kb21haW4gPSBbMCwgMV07XG4gICAgdGhpcy5yYW5nZSA9IFtcInJlZFwiLCBcImJsdWVcIl07XG4gICAgdGhpcy5wYXJzZWRSYW5nZSA9IHRoaXMucmFuZ2UubWFwKGNvbnZlcnRDb2xvclN0cmluZ1RvT2tsY2hhKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgeyBkb21haW4sIHJhbmdlOiByYW5nZTMgfSA9IHRoaXM7XG4gICAgaWYgKGRvbWFpbi5sZW5ndGggPCAyKSB7XG4gICAgICBsb2dnZXJfZXhwb3J0cy53YXJuT25jZShcImBjb2xvckRvbWFpbmAgc2hvdWxkIGhhdmUgYXQgbGVhc3QgMiB2YWx1ZXMuXCIpO1xuICAgICAgaWYgKGRvbWFpbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZG9tYWluLnB1c2goMCwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGRvbWFpbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZG9tYWluLnB1c2goZG9tYWluWzBdICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZG9tYWluLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhID0gZG9tYWluW2kgLSAxXTtcbiAgICAgIGNvbnN0IGIgPSBkb21haW5baV07XG4gICAgICBpZiAoYSA+PSBiKSB7XG4gICAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKFwiYGNvbG9yRG9tYWluYCB2YWx1ZXMgc2hvdWxkIGJlIHN1cHBsaWVkIGluIGFzY2VuZGluZyBvcmRlci5cIik7XG4gICAgICAgIGRvbWFpbi5zb3J0KChhMiwgYjIpID0+IGEyIC0gYjIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJhbmdlMy5sZW5ndGggPCBkb21haW4ubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gcmFuZ2UzLmxlbmd0aDsgaSA8IGRvbWFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgICByYW5nZTMucHVzaChyYW5nZTMubGVuZ3RoID4gMCA/IHJhbmdlM1swXSA6IFwiYmxhY2tcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucGFyc2VkUmFuZ2UgPSB0aGlzLnJhbmdlLm1hcChjb252ZXJ0Q29sb3JTdHJpbmdUb09rbGNoYSk7XG4gIH1cbiAgbm9ybWFsaXplRG9tYWlucyguLi5kb21haW5zKSB7XG4gICAgcmV0dXJuIHsgZG9tYWluOiBkb21haW5zLmZsYXQoKSwgYW5pbWF0YWJsZTogdHJ1ZSB9O1xuICB9XG4gIHRvRG9tYWluKCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb252ZXJ0KHgpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCB7IGRvbWFpbiwgcmFuZ2U6IHJhbmdlMywgcGFyc2VkUmFuZ2UgfSA9IHRoaXM7XG4gICAgY29uc3QgZDAgPSBkb21haW5bMF07XG4gICAgY29uc3QgZDEgPSBkb21haW4uYXQoLTEpO1xuICAgIGNvbnN0IHIwID0gcmFuZ2UzWzBdO1xuICAgIGNvbnN0IHIxID0gcmFuZ2UzW3JhbmdlMy5sZW5ndGggLSAxXTtcbiAgICBpZiAoeCA8PSBkMCkge1xuICAgICAgcmV0dXJuIHIwO1xuICAgIH1cbiAgICBpZiAoeCA+PSBkMSkge1xuICAgICAgcmV0dXJuIHIxO1xuICAgIH1cbiAgICBsZXQgaW5kZXg7XG4gICAgbGV0IHE7XG4gICAgaWYgKGRvbWFpbi5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IHQgPSAoeCAtIGQwKSAvIChkMSAtIGQwKTtcbiAgICAgIGNvbnN0IHN0ZXAgPSAxIC8gKHJhbmdlMy5sZW5ndGggLSAxKTtcbiAgICAgIGluZGV4ID0gcmFuZ2UzLmxlbmd0aCA8PSAyID8gMCA6IE1hdGgubWluKE1hdGguZmxvb3IodCAqIChyYW5nZTMubGVuZ3RoIC0gMSkpLCByYW5nZTMubGVuZ3RoIC0gMik7XG4gICAgICBxID0gKHQgLSBpbmRleCAqIHN0ZXApIC8gc3RlcDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgZG9tYWluLmxlbmd0aCAtIDI7IGluZGV4KyspIHtcbiAgICAgICAgaWYgKHggPCBkb21haW5baW5kZXggKyAxXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBhID0gZG9tYWluW2luZGV4XTtcbiAgICAgIGNvbnN0IGIgPSBkb21haW5baW5kZXggKyAxXTtcbiAgICAgIHEgPSAoeCAtIGEpIC8gKGIgLSBhKTtcbiAgICB9XG4gICAgY29uc3QgYzAgPSBwYXJzZWRSYW5nZVtpbmRleF07XG4gICAgY29uc3QgYzEgPSBwYXJzZWRSYW5nZVtpbmRleCArIDFdO1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZU9rbGNoKGMwLCBjMSwgcSkudG9SZ2JhU3RyaW5nKCk7XG4gIH1cbiAgaW52ZXJ0KCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZWZyZXNoKCkge1xuICAgIGlmICghdGhpcy5pbnZhbGlkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaW52YWxpZCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoXCJFeHBlY3RlZCB1cGRhdGUgdG8gbm90IGludmFsaWRhdGUgc2NhbGVcIik7XG4gICAgfVxuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBDb2xvclNjYWxlLnByb3RvdHlwZSwgXCJkb21haW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIENvbG9yU2NhbGUucHJvdG90eXBlLCBcInJhbmdlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9ncmFkaWVudC9ncmFkaWVudC50c1xudmFyIEdyYWRpZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb2xvclNwYWNlLCBzdG9wcyA9IFtdLCBiYm94KSB7XG4gICAgdGhpcy5jb2xvclNwYWNlID0gY29sb3JTcGFjZTtcbiAgICB0aGlzLnN0b3BzID0gc3RvcHM7XG4gICAgdGhpcy5iYm94ID0gYmJveDtcbiAgICB0aGlzLl9jYWNoZSA9IHZvaWQgMDtcbiAgfVxuICBjcmVhdGVHcmFkaWVudChjdHgsIHNoYXBlQmJveCkge1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLmJib3ggPz8gc2hhcGVCYm94O1xuICAgIGlmICh0aGlzLl9jYWNoZSAhPSBudWxsICYmIHRoaXMuX2NhY2hlLmN0eCA9PT0gY3R4ICYmIHRoaXMuX2NhY2hlLmJib3guZXF1YWxzKGJib3gpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGUuZ3JhZGllbnQ7XG4gICAgfVxuICAgIGNvbnN0IHsgc3RvcHMsIGNvbG9yU3BhY2UgfSA9IHRoaXM7XG4gICAgaWYgKHN0b3BzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoc3RvcHMubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIHN0b3BzWzBdLmNvbG9yO1xuICAgIGxldCBncmFkaWVudDIgPSB0aGlzLmNyZWF0ZUNhbnZhc0dyYWRpZW50KGN0eCwgYmJveCk7XG4gICAgaWYgKGdyYWRpZW50MiA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGlzT2tMY2ggPSBjb2xvclNwYWNlID09PSBcIm9rbGNoXCI7XG4gICAgY29uc3Qgc3RlcCA9IDAuMDU7XG4gICAgbGV0IGMwID0gc3RvcHNbMF07XG4gICAgZ3JhZGllbnQyLmFkZENvbG9yU3RvcChjMC5vZmZzZXQsIGMwLmNvbG9yKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0b3BzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBjMSA9IHN0b3BzW2ldO1xuICAgICAgaWYgKGlzT2tMY2gpIHtcbiAgICAgICAgY29uc3Qgc2NhbGUyID0gbmV3IENvbG9yU2NhbGUoKTtcbiAgICAgICAgc2NhbGUyLmRvbWFpbiA9IFtjMC5vZmZzZXQsIGMxLm9mZnNldF07XG4gICAgICAgIHNjYWxlMi5yYW5nZSA9IFtjMC5jb2xvciwgYzEuY29sb3JdO1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQ0ID0gYzAub2Zmc2V0ICsgc3RlcDsgb2Zmc2V0NCA8IGMxLm9mZnNldDsgb2Zmc2V0NCArPSBzdGVwKSB7XG4gICAgICAgICAgZ3JhZGllbnQyLmFkZENvbG9yU3RvcChvZmZzZXQ0LCBzY2FsZTIuY29udmVydChvZmZzZXQ0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdyYWRpZW50Mi5hZGRDb2xvclN0b3AoYzEub2Zmc2V0LCBjMS5jb2xvcik7XG4gICAgICBjMCA9IGMxO1xuICAgIH1cbiAgICBpZiAoXCJjcmVhdGVQYXR0ZXJuXCIgaW4gZ3JhZGllbnQyKSB7XG4gICAgICBncmFkaWVudDIgPSBncmFkaWVudDIuY3JlYXRlUGF0dGVybigpO1xuICAgIH1cbiAgICB0aGlzLl9jYWNoZSA9IHsgY3R4LCBiYm94LCBncmFkaWVudDogZ3JhZGllbnQyIH07XG4gICAgcmV0dXJuIGdyYWRpZW50MjtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9hbmdsZS50c1xudmFyIHR3b1BpID0gTWF0aC5QSSAqIDI7XG52YXIgaGFsZlBpID0gTWF0aC5QSSAvIDI7XG5mdW5jdGlvbiBub3JtYWxpemVBbmdsZTM2MChyYWRpYW5zKSB7XG4gIHJhZGlhbnMgJT0gdHdvUGk7XG4gIHJhZGlhbnMgKz0gdHdvUGk7XG4gIHJhZGlhbnMgJT0gdHdvUGk7XG4gIHJldHVybiByYWRpYW5zO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQW5nbGUzNjBJbmNsdXNpdmUocmFkaWFucykge1xuICByYWRpYW5zICU9IHR3b1BpO1xuICByYWRpYW5zICs9IHR3b1BpO1xuICBpZiAocmFkaWFucyAhPT0gdHdvUGkpIHtcbiAgICByYWRpYW5zICU9IHR3b1BpO1xuICB9XG4gIHJldHVybiByYWRpYW5zO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQW5nbGUxODAocmFkaWFucykge1xuICByYWRpYW5zICU9IHR3b1BpO1xuICBpZiAocmFkaWFucyA8IC1NYXRoLlBJKSB7XG4gICAgcmFkaWFucyArPSB0d29QaTtcbiAgfSBlbHNlIGlmIChyYWRpYW5zID49IE1hdGguUEkpIHtcbiAgICByYWRpYW5zIC09IHR3b1BpO1xuICB9XG4gIHJldHVybiByYWRpYW5zO1xufVxuZnVuY3Rpb24gaXNCZXR3ZWVuQW5nbGVzKHRhcmdldEFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkge1xuICBjb25zdCB0ID0gbm9ybWFsaXplQW5nbGUzNjAodGFyZ2V0QW5nbGUpO1xuICBjb25zdCBhMCA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHN0YXJ0QW5nbGUpO1xuICBjb25zdCBhMSA9IG5vcm1hbGl6ZUFuZ2xlMzYwKGVuZEFuZ2xlKTtcbiAgaWYgKGEwIDwgYTEpIHtcbiAgICByZXR1cm4gYTAgPD0gdCAmJiB0IDw9IGExO1xuICB9IGVsc2UgaWYgKGEwID4gYTEpIHtcbiAgICByZXR1cm4gYTAgPD0gdCB8fCB0IDw9IGExO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlcykge1xuICByZXR1cm4gZGVncmVlcyAvIDE4MCAqIE1hdGguUEk7XG59XG5mdW5jdGlvbiB0b0RlZ3JlZXMocmFkaWFucykge1xuICByZXR1cm4gcmFkaWFucyAvIE1hdGguUEkgKiAxODA7XG59XG5mdW5jdGlvbiBhbmdsZUJldHdlZW4oYW5nbGUwLCBhbmdsZTEpIHtcbiAgYW5nbGUwID0gbm9ybWFsaXplQW5nbGUzNjAoYW5nbGUwKTtcbiAgYW5nbGUxID0gbm9ybWFsaXplQW5nbGUzNjAoYW5nbGUxKTtcbiAgcmV0dXJuIGFuZ2xlMSAtIGFuZ2xlMCArIChhbmdsZTAgPiBhbmdsZTEgPyB0d29QaSA6IDApO1xufVxuZnVuY3Rpb24gZ2V0QW5nbGVSYXRpb1JhZGlhbnMoYW5nbGUyKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRBbmdsZSA9IG5vcm1hbGl6ZUFuZ2xlMzYwKGFuZ2xlMik7XG4gIGlmIChub3JtYWxpemVkQW5nbGUgPD0gaGFsZlBpKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRBbmdsZSAvIGhhbGZQaTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemVkQW5nbGUgPD0gTWF0aC5QSSkge1xuICAgIHJldHVybiAoTWF0aC5QSSAtIG5vcm1hbGl6ZWRBbmdsZSkgLyBoYWxmUGk7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXplZEFuZ2xlIDw9IDEuNSAqIE1hdGguUEkpIHtcbiAgICByZXR1cm4gKG5vcm1hbGl6ZWRBbmdsZSAtIE1hdGguUEkpIC8gaGFsZlBpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAodHdvUGkgLSBub3JtYWxpemVkQW5nbGUpIC8gaGFsZlBpO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2dyYWRpZW50L2xpbmVhckdyYWRpZW50LnRzXG52YXIgTGluZWFyR3JhZGllbnQgPSBjbGFzcyBleHRlbmRzIEdyYWRpZW50IHtcbiAgY29uc3RydWN0b3IoY29sb3JTcGFjZSwgc3RvcHMsIGFuZ2xlMiA9IDAsIGJib3gpIHtcbiAgICBzdXBlcihjb2xvclNwYWNlLCBzdG9wcywgYmJveCk7XG4gICAgdGhpcy5hbmdsZSA9IGFuZ2xlMjtcbiAgfVxuICBjcmVhdGVDYW52YXNHcmFkaWVudChjdHgsIGJib3gpIHtcbiAgICBjb25zdCBhbmdsZU9mZnNldCA9IDkwO1xuICAgIGNvbnN0IHsgYW5nbGU6IGFuZ2xlMiB9ID0gdGhpcztcbiAgICBjb25zdCByYWRpYW5zID0gbm9ybWFsaXplQW5nbGUzNjAodG9SYWRpYW5zKGFuZ2xlMiArIGFuZ2xlT2Zmc2V0KSk7XG4gICAgY29uc3QgY29zID0gTWF0aC5jb3MocmFkaWFucyk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4ocmFkaWFucyk7XG4gICAgY29uc3QgdyA9IGJib3gud2lkdGg7XG4gICAgY29uc3QgaCA9IGJib3guaGVpZ2h0O1xuICAgIGNvbnN0IGN4ID0gYmJveC54ICsgdyAqIDAuNTtcbiAgICBjb25zdCBjeSA9IGJib3gueSArIGggKiAwLjU7XG4gICAgY29uc3QgZGlhZ29uYWwgPSBNYXRoLnNxcnQoaCAqIGggKyB3ICogdykgLyAyO1xuICAgIGNvbnN0IGRpYWdvbmFsQW5nbGUgPSBNYXRoLmF0YW4yKGgsIHcpO1xuICAgIGxldCBxdWFydGVyZWRBbmdsZTtcbiAgICBpZiAocmFkaWFucyA8IE1hdGguUEkgLyAyKSB7XG4gICAgICBxdWFydGVyZWRBbmdsZSA9IHJhZGlhbnM7XG4gICAgfSBlbHNlIGlmIChyYWRpYW5zIDwgTWF0aC5QSSkge1xuICAgICAgcXVhcnRlcmVkQW5nbGUgPSBNYXRoLlBJIC0gcmFkaWFucztcbiAgICB9IGVsc2UgaWYgKHJhZGlhbnMgPCAxLjUgKiBNYXRoLlBJKSB7XG4gICAgICBxdWFydGVyZWRBbmdsZSA9IHJhZGlhbnMgLSBNYXRoLlBJO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWFydGVyZWRBbmdsZSA9IDIgKiBNYXRoLlBJIC0gcmFkaWFucztcbiAgICB9XG4gICAgY29uc3QgbCA9IGRpYWdvbmFsICogTWF0aC5hYnMoTWF0aC5jb3MocXVhcnRlcmVkQW5nbGUgLSBkaWFnb25hbEFuZ2xlKSk7XG4gICAgcmV0dXJuIGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChjeCArIGNvcyAqIGwsIGN5ICsgc2luICogbCwgY3ggLSBjb3MgKiBsLCBjeSAtIHNpbiAqIGwpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9ncmFkaWVudC9zdG9wcy50c1xudmFyIFN0b3BQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jb2xvciA9IFwiYmxhY2tcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU3RvcFByb3BlcnRpZXMucHJvdG90eXBlLCBcInN0b3BcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFN0b3BQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbmZ1bmN0aW9uIHN0b3BzQXJlQXNjZW5kaW5nKGZpbGxzKSB7XG4gIGxldCBjdXJyZW50U3RvcDtcbiAgZm9yIChjb25zdCB7IHN0b3AgfSBvZiBmaWxscykge1xuICAgIGlmIChzdG9wID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFN0b3AgIT0gbnVsbCAmJiBzdG9wIDwgY3VycmVudFN0b3ApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY3VycmVudFN0b3AgPSBzdG9wO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZGlzY3JldGVDb2xvclN0b3BzKGNvbG9yU3RvcHMpIHtcbiAgcmV0dXJuIGNvbG9yU3RvcHMuZmxhdE1hcCgoY29sb3JTdG9wLCBpKSA9PiB7XG4gICAgY29uc3QgeyBvZmZzZXQ6IG9mZnNldDQgfSA9IGNvbG9yU3RvcDtcbiAgICBjb25zdCBuZXh0Q29sb3IgPSBjb2xvclN0b3BzLmF0KGkgKyAxKT8uY29sb3I7XG4gICAgcmV0dXJuIG5leHRDb2xvciAhPSBudWxsID8gW2NvbG9yU3RvcCwgeyBvZmZzZXQ6IG9mZnNldDQsIGNvbG9yOiBuZXh0Q29sb3IgfV0gOiBbY29sb3JTdG9wXTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0Q29sb3JTdG9wcyhkZWZhdWx0Q29sb3JTdG9wcywgZmlsbE1vZGUpIHtcbiAgY29uc3Qgc3RvcE9mZnNldCA9IGZpbGxNb2RlID09PSBcImRpc2NyZXRlXCIgPyAxIDogMDtcbiAgY29uc3QgY29sb3JTdG9wcyA9IGRlZmF1bHRDb2xvclN0b3BzLm1hcChcbiAgICAoY29sb3IsIGluZGV4LCB7IGxlbmd0aDogbGVuZ3RoMiB9KSA9PiAoe1xuICAgICAgb2Zmc2V0OiAoaW5kZXggKyBzdG9wT2Zmc2V0KSAvIChsZW5ndGgyIC0gMSArIHN0b3BPZmZzZXQpLFxuICAgICAgY29sb3JcbiAgICB9KVxuICApO1xuICByZXR1cm4gZmlsbE1vZGUgPT09IFwiZGlzY3JldGVcIiA/IGRpc2NyZXRlQ29sb3JTdG9wcyhjb2xvclN0b3BzKSA6IGNvbG9yU3RvcHM7XG59XG5mdW5jdGlvbiBnZXRDb2xvclN0b3BzKGZpbGxzLCBkZWZhdWx0Q29sb3JTdG9wcywgZG9tYWluLCBmaWxsTW9kZSA9IFwiY29udGludW91c1wiKSB7XG4gIGlmIChmaWxscy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZ2V0RGVmYXVsdENvbG9yU3RvcHMoZGVmYXVsdENvbG9yU3RvcHMsIGZpbGxNb2RlKTtcbiAgfSBlbHNlIGlmICghc3RvcHNBcmVBc2NlbmRpbmcoZmlsbHMpKSB7XG4gICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoYFtmaWxsc10gbXVzdCBoYXZlIHRoZSBzdG9wcyBkZWZpbmVkIGluIGFzY2VuZGluZyBvcmRlcmApO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBkMCA9IE1hdGgubWluKC4uLmRvbWFpbik7XG4gIGNvbnN0IGQxID0gTWF0aC5tYXgoLi4uZG9tYWluKTtcbiAgY29uc3QgaXNEaXNjcmV0ZSA9IGZpbGxNb2RlID09PSBcImRpc2NyZXRlXCI7XG4gIGNvbnN0IG9mZnNldHMgPSBuZXcgRmxvYXQ2NEFycmF5KGZpbGxzLmxlbmd0aCk7XG4gIGxldCBwcmV2aW91c0RlZmluZWRTdG9wSW5kZXggPSAwO1xuICBsZXQgbmV4dERlZmluZWRTdG9wSW5kZXggPSAtMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxscy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGNvbG9yU3RvcCA9IGZpbGxzW2ldO1xuICAgIGlmIChpID49IG5leHREZWZpbmVkU3RvcEluZGV4KSB7XG4gICAgICBuZXh0RGVmaW5lZFN0b3BJbmRleCA9IGZpbGxzLmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBmaWxscy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBpZiAoZmlsbHNbal0uc3RvcCAhPSBudWxsKSB7XG4gICAgICAgICAgbmV4dERlZmluZWRTdG9wSW5kZXggPSBqO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB7IHN0b3AgfSA9IGNvbG9yU3RvcDtcbiAgICBpZiAoc3RvcCA9PSBudWxsKSB7XG4gICAgICBjb25zdCBzdG9wMCA9IGZpbGxzW3ByZXZpb3VzRGVmaW5lZFN0b3BJbmRleF0uc3RvcDtcbiAgICAgIGNvbnN0IHN0b3AxID0gZmlsbHNbbmV4dERlZmluZWRTdG9wSW5kZXhdLnN0b3A7XG4gICAgICBjb25zdCB2YWx1ZTAgPSBzdG9wMCA/PyBkMDtcbiAgICAgIGNvbnN0IHZhbHVlMSA9IHN0b3AxID8/IGQxO1xuICAgICAgY29uc3Qgc3RvcE9mZnNldCA9IGlzRGlzY3JldGUgJiYgc3RvcDAgPT0gbnVsbCA/IDEgOiAwO1xuICAgICAgc3RvcCA9IHZhbHVlMCArICh2YWx1ZTEgLSB2YWx1ZTApICogKGkgLSBwcmV2aW91c0RlZmluZWRTdG9wSW5kZXggKyBzdG9wT2Zmc2V0KSAvIChuZXh0RGVmaW5lZFN0b3BJbmRleCAtIHByZXZpb3VzRGVmaW5lZFN0b3BJbmRleCArIHN0b3BPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2aW91c0RlZmluZWRTdG9wSW5kZXggPSBpO1xuICAgIH1cbiAgICBvZmZzZXRzW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHN0b3AgLSBkMCkgLyAoZDEgLSBkMCkpKTtcbiAgfVxuICBsZXQgbGFzdERlZmluZWRDb2xvciA9IGZpbGxzLmZpbmQoKGMpID0+IGMuY29sb3IgIT0gbnVsbCk/LmNvbG9yO1xuICBsZXQgY29sb3JTY2FsZTtcbiAgY29uc3QgY29sb3JTdG9wcyA9IGZpbGxzLm1hcCgoeyBjb2xvciB9LCBpKSA9PiB7XG4gICAgY29uc3Qgb2Zmc2V0NCA9IG9mZnNldHNbaV07XG4gICAgaWYgKGNvbG9yICE9IG51bGwpIHtcbiAgICAgIGxhc3REZWZpbmVkQ29sb3IgPSBjb2xvcjtcbiAgICB9IGVsc2UgaWYgKGxhc3REZWZpbmVkQ29sb3IgIT0gbnVsbCkge1xuICAgICAgY29sb3IgPSBsYXN0RGVmaW5lZENvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29sb3JTY2FsZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbG9yU2NhbGUgPSBuZXcgQ29sb3JTY2FsZSgpO1xuICAgICAgICBjb2xvclNjYWxlLmRvbWFpbiA9IFswLCAxXTtcbiAgICAgICAgY29sb3JTY2FsZS5yYW5nZSA9IGRlZmF1bHRDb2xvclN0b3BzO1xuICAgICAgfVxuICAgICAgY29sb3IgPSBjb2xvclNjYWxlLmNvbnZlcnQob2Zmc2V0NCk7XG4gICAgfVxuICAgIHJldHVybiB7IG9mZnNldDogb2Zmc2V0NCwgY29sb3IgfTtcbiAgfSk7XG4gIHJldHVybiBmaWxsTW9kZSA9PT0gXCJkaXNjcmV0ZVwiID8gZGlzY3JldGVDb2xvclN0b3BzKGNvbG9yU3RvcHMpIDogY29sb3JTdG9wcztcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvdXRpbC9maWxsLnRzXG5mdW5jdGlvbiBpc0dyYWRpZW50RmlsbChmaWxsKSB7XG4gIHJldHVybiBmaWxsICE9PSBudWxsICYmIGlzT2JqZWN0KGZpbGwpICYmIGZpbGwudHlwZSA9PSBcImdyYWRpZW50XCI7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3V0aWwvcGl4ZWwudHNcbmZ1bmN0aW9uIGFsaWduKHBpeGVsUmF0aW8sIHN0YXJ0MiwgbGVuZ3RoMikge1xuICBjb25zdCBhbGlnbmVkU3RhcnQgPSBNYXRoLnJvdW5kKHN0YXJ0MiAqIHBpeGVsUmF0aW8pIC8gcGl4ZWxSYXRpbztcbiAgaWYgKGxlbmd0aDIgPT0gbnVsbCkge1xuICAgIHJldHVybiBhbGlnbmVkU3RhcnQ7XG4gIH0gZWxzZSBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKGxlbmd0aDIgPCAxKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbChsZW5ndGgyICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvO1xuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKChsZW5ndGgyICsgc3RhcnQyKSAqIHBpeGVsUmF0aW8pIC8gcGl4ZWxSYXRpbyAtIGFsaWduZWRTdGFydDtcbn1cbmZ1bmN0aW9uIGFsaWduQmVmb3JlKHBpeGVsUmF0aW8sIHN0YXJ0Mikge1xuICByZXR1cm4gTWF0aC5mbG9vcihzdGFydDIgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW87XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL3NoYXBlLnRzXG52YXIgTElORUFSX0dSQURJRU5UX1JFR0VYUCA9IC9ebGluZWFyLWdyYWRpZW50XFwoKC0/W1xcZC5dKylkZWcsKC4qPylcXCkkL2k7XG52YXIgX1NoYXBlID0gY2xhc3MgX1NoYXBlIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmZpbGwgPSBfU2hhcGUuZGVmYXVsdFN0eWxlcy5maWxsO1xuICAgIHRoaXMuc3Ryb2tlID0gX1NoYXBlLmRlZmF1bHRTdHlsZXMuc3Ryb2tlO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSBfU2hhcGUuZGVmYXVsdFN0eWxlcy5zdHJva2VXaWR0aDtcbiAgICB0aGlzLmxpbmVEYXNoID0gX1NoYXBlLmRlZmF1bHRTdHlsZXMubGluZURhc2g7XG4gICAgdGhpcy5saW5lRGFzaE9mZnNldCA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLmxpbmVEYXNoT2Zmc2V0O1xuICAgIHRoaXMubGluZUNhcCA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLmxpbmVDYXA7XG4gICAgdGhpcy5saW5lSm9pbiA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLmxpbmVKb2luO1xuICAgIHRoaXMubWl0ZXJMaW1pdCA9IHZvaWQgMDtcbiAgICB0aGlzLm9wYWNpdHkgPSBfU2hhcGUuZGVmYXVsdFN0eWxlcy5vcGFjaXR5O1xuICAgIHRoaXMuZmlsbFNoYWRvdyA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLmZpbGxTaGFkb3c7XG4gICAgdGhpcy5ncmFkaWVudEZpbGxPcHRpb25zID0ge1xuICAgICAgZG9tYWluOiBbMCwgMV0sXG4gICAgICBkZWZhdWx0Q29sb3JSYW5nZTogX1NoYXBlLmRlZmF1bHRTdHlsZXMuZGVmYXVsdENvbG9yUmFuZ2VcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXN0b3JlcyB0aGUgZGVmYXVsdCBzdHlsZXMgaW50cm9kdWNlZCBieSB0aGlzIHN1YmNsYXNzLlxuICAgKi9cbiAgcmVzdG9yZU93blN0eWxlcygpIHtcbiAgICBjb25zdCB7IGRlZmF1bHRTdHlsZXMgfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBkZWZhdWx0U3R5bGVzKTtcbiAgfVxuICBnZXRHcmFkaWVudChwYXR0ZXJuKSB7XG4gICAgbGV0IGxpbmVhckdyYWRpZW50TWF0Y2g7XG4gICAgaWYgKHBhdHRlcm4gaW5zdGFuY2VvZiBHcmFkaWVudCkge1xuICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIiAmJiBwYXR0ZXJuPy5zdGFydHNXaXRoKFwibGluZWFyLWdyYWRpZW50XCIpICYmIChsaW5lYXJHcmFkaWVudE1hdGNoID0gTElORUFSX0dSQURJRU5UX1JFR0VYUC5leGVjKHBhdHRlcm4pKSkge1xuICAgICAgY29uc3QgYW5nbGUyID0gcGFyc2VGbG9hdChsaW5lYXJHcmFkaWVudE1hdGNoWzFdKTtcbiAgICAgIGNvbnN0IGNvbG9ycyA9IFtdO1xuICAgICAgY29uc3QgY29sb3JzUGFydCA9IGxpbmVhckdyYWRpZW50TWF0Y2hbMl07XG4gICAgICBjb25zdCBjb2xvclJlZ2V4ID0gLygjWzAtOWEtZl0rKXwocmdiYT9cXCguKz9cXCkpfChbYS16XSspL2dpO1xuICAgICAgbGV0IGM7XG4gICAgICB3aGlsZSAoYyA9IGNvbG9yUmVnZXguZXhlYyhjb2xvcnNQYXJ0KSkge1xuICAgICAgICBjb2xvcnMucHVzaChjWzBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTGluZWFyR3JhZGllbnQoXG4gICAgICAgIFwicmdiXCIsXG4gICAgICAgIGNvbG9ycy5tYXAoKGNvbG9yLCBpbmRleCkgPT4gKHsgY29sb3IsIG9mZnNldDogaW5kZXggLyAoY29sb3JzLmxlbmd0aCAtIDEpIH0pKSxcbiAgICAgICAgYW5nbGUyXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNHcmFkaWVudEZpbGwocGF0dGVybikpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxpbmVhckdyYWRpZW50KHBhdHRlcm4pO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNyZWF0ZUxpbmVhckdyYWRpZW50KGZpbGwpIHtcbiAgICBjb25zdCB7IGNvbG9yU3RvcHMgPSBbXSwgZGlyZWN0aW9uIH0gPSBmaWxsO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gICAgY29uc3QgeyBkb21haW4sIGRlZmF1bHRDb2xvclJhbmdlID0gW10gfSA9IHRoaXMuZ3JhZGllbnRGaWxsT3B0aW9ucztcbiAgICBjb25zdCBzdG9wcyA9IGdldENvbG9yU3RvcHMoY29sb3JTdG9wcywgZGVmYXVsdENvbG9yUmFuZ2UsIGRvbWFpbik7XG4gICAgcmV0dXJuIG5ldyBMaW5lYXJHcmFkaWVudChcIm9rbGNoXCIsIHN0b3BzLCBpc0hvcml6b250YWwgPyAwIDogOTApO1xuICB9XG4gIG9uRmlsbENoYW5nZSgpIHtcbiAgICB0aGlzLmZpbGxHcmFkaWVudCA9IHRoaXMuZ2V0R3JhZGllbnQodGhpcy5maWxsKTtcbiAgfVxuICBvblN0cm9rZUNoYW5nZSgpIHtcbiAgICB0aGlzLnN0cm9rZUdyYWRpZW50ID0gdGhpcy5nZXRHcmFkaWVudCh0aGlzLnN0cm9rZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBkZXZpY2UtcGl4ZWwgYWxpZ25lZCBjb29yZGluYXRlIChvciBsZW5ndGggaWYgbGVuZ3RoIGlzIHN1cHBsaWVkKS5cbiAgICpcbiAgICogTk9URTogTm90IHN1aXRhYmxlIGZvciBzdHJva2VzLCBzaW5jZSB0aGUgc3Ryb2tlIG5lZWRzIHRvIGJlIG9mZnNldCB0byB0aGUgbWlkZGxlXG4gICAqIG9mIGEgZGV2aWNlIHBpeGVsLlxuICAgKi9cbiAgYWxpZ24oc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgcmV0dXJuIGFsaWduKHRoaXMubGF5ZXJNYW5hZ2VyPy5jYW52YXM/LnBpeGVsUmF0aW8gPz8gMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgfVxuICBmaWxsU3Ryb2tlKGN0eCwgcGF0aCkge1xuICAgIHRoaXMucmVuZGVyRmlsbChjdHgsIHBhdGgpO1xuICAgIHRoaXMucmVuZGVyU3Ryb2tlKGN0eCwgcGF0aCk7XG4gIH1cbiAgcmVuZGVyRmlsbChjdHgsIHBhdGgpIHtcbiAgICBpZiAodGhpcy5maWxsKSB7XG4gICAgICBjb25zdCB7IGdsb2JhbEFscGhhIH0gPSBjdHg7XG4gICAgICB0aGlzLmFwcGx5RmlsbChjdHgpO1xuICAgICAgdGhpcy5hcHBseUZpbGxBbHBoYShjdHgpO1xuICAgICAgdGhpcy5hcHBseVNoYWRvdyhjdHgpO1xuICAgICAgdGhpcy5leGVjdXRlRmlsbChjdHgsIHBhdGgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gZ2xvYmFsQWxwaGE7XG4gICAgfVxuICAgIGN0eC5zaGFkb3dDb2xvciA9IFwicmdiYSgwLCAwLCAwLCAwKVwiO1xuICB9XG4gIGV4ZWN1dGVGaWxsKGN0eCwgcGF0aCkge1xuICAgIGlmIChwYXRoKSB7XG4gICAgICBjdHguZmlsbChwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gIH1cbiAgYXBwbHlGaWxsKGN0eCkge1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLmdyYWRpZW50RmlsbE9wdGlvbnMuYmJveCA/PyB0aGlzLmdldEJCb3goKTtcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5maWxsR3JhZGllbnQ/LmNyZWF0ZUdyYWRpZW50KGN0eCwgYmJveCkgPz8gKHR5cGVvZiB0aGlzLmZpbGwgPT09IFwic3RyaW5nXCIgPyB0aGlzLmZpbGwgOiB2b2lkIDApID8/IFwiYmxhY2tcIjtcbiAgfVxuICBhcHBseVN0cm9rZShjdHgpIHtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZUdyYWRpZW50Py5jcmVhdGVHcmFkaWVudChjdHgsIHRoaXMuZ2V0QkJveCgpKSA/PyAodHlwZW9mIHRoaXMuc3Ryb2tlID09PSBcInN0cmluZ1wiID8gdGhpcy5zdHJva2UgOiB2b2lkIDApID8/IFwiYmxhY2tcIjtcbiAgfVxuICBhcHBseUZpbGxBbHBoYShjdHgpIHtcbiAgICBjdHguZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5ICogdGhpcy5maWxsT3BhY2l0eTtcbiAgfVxuICBhcHBseVNoYWRvdyhjdHgpIHtcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gdGhpcy5sYXllck1hbmFnZXI/LmNhbnZhcy5waXhlbFJhdGlvID8/IDE7XG4gICAgY29uc3QgZmlsbFNoYWRvdyA9IHRoaXMuZmlsbFNoYWRvdztcbiAgICBpZiAoZmlsbFNoYWRvdz8uZW5hYmxlZCkge1xuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gZmlsbFNoYWRvdy5jb2xvcjtcbiAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gZmlsbFNoYWRvdy54T2Zmc2V0ICogcGl4ZWxSYXRpbztcbiAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gZmlsbFNoYWRvdy55T2Zmc2V0ICogcGl4ZWxSYXRpbztcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gZmlsbFNoYWRvdy5ibHVyICogcGl4ZWxSYXRpbztcbiAgICB9XG4gIH1cbiAgcmVuZGVyU3Ryb2tlKGN0eCwgcGF0aCkge1xuICAgIGlmICh0aGlzLnN0cm9rZSAmJiB0aGlzLnN0cm9rZVdpZHRoKSB7XG4gICAgICBjb25zdCB7IGdsb2JhbEFscGhhIH0gPSBjdHg7XG4gICAgICB0aGlzLmFwcGx5U3Ryb2tlKGN0eCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5ICogdGhpcy5zdHJva2VPcGFjaXR5O1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICBpZiAodGhpcy5saW5lRGFzaCkge1xuICAgICAgICBjdHguc2V0TGluZURhc2godGhpcy5saW5lRGFzaCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5saW5lRGFzaE9mZnNldCkge1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSB0aGlzLmxpbmVEYXNoT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGluZUNhcCkge1xuICAgICAgICBjdHgubGluZUNhcCA9IHRoaXMubGluZUNhcDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpbmVKb2luKSB7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IHRoaXMubGluZUpvaW47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5taXRlckxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgY3R4Lm1pdGVyTGltaXQgPSB0aGlzLm1pdGVyTGltaXQ7XG4gICAgICB9XG4gICAgICB0aGlzLmV4ZWN1dGVTdHJva2UoY3R4LCBwYXRoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGdsb2JhbEFscGhhO1xuICAgIH1cbiAgfVxuICBleGVjdXRlU3Ryb2tlKGN0eCwgcGF0aCkge1xuICAgIGlmIChwYXRoKSB7XG4gICAgICBjdHguc3Ryb2tlKHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9XG4gIGNvbnRhaW5zUG9pbnQoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmlzUG9pbnRJblBhdGgoeCwgeSk7XG4gIH1cbiAgYXBwbHlTdmdGaWxsQXR0cmlidXRlcyhlbGVtZW50Mikge1xuICAgIGNvbnN0IHsgZmlsbCwgZmlsbE9wYWNpdHkgfSA9IHRoaXM7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCB0eXBlb2YgZmlsbCA9PT0gXCJzdHJpbmdcIiA/IGZpbGwgOiBcIm5vbmVcIik7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwiZmlsbC1vcGFjaXR5XCIsIFN0cmluZyhmaWxsT3BhY2l0eSkpO1xuICB9XG4gIGFwcGx5U3ZnU3Ryb2tlQXR0cmlidXRlcyhlbGVtZW50Mikge1xuICAgIGNvbnN0IHsgc3Ryb2tlOiBzdHJva2UyLCBzdHJva2VPcGFjaXR5LCBzdHJva2VXaWR0aCwgbGluZURhc2gsIGxpbmVEYXNoT2Zmc2V0IH0gPSB0aGlzO1xuICAgIGlmIChzdHJva2UyICE9IG51bGwpIHtcbiAgICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCB0eXBlb2Ygc3Ryb2tlMiA9PT0gXCJzdHJpbmdcIiA/IHN0cm9rZTIgOiBcIm5vbmVcIik7XG4gICAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utb3BhY2l0eVwiLCBTdHJpbmcoc3Ryb2tlT3BhY2l0eSkpO1xuICAgICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIFN0cmluZyhzdHJva2VXaWR0aCkpO1xuICAgIH1cbiAgICBpZiAobGluZURhc2g/LnNvbWUoKGQpID0+IGQgIT09IDApID09PSB0cnVlKSB7XG4gICAgICBjb25zdCBzdmdMaW5lRGFzaCA9IGxpbmVEYXNoLmxlbmd0aCAlIDIgPT09IDEgPyBbLi4ubGluZURhc2gsIC4uLmxpbmVEYXNoXSA6IGxpbmVEYXNoO1xuICAgICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBzdmdMaW5lRGFzaC5qb2luKFwiIFwiKSk7XG4gICAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaG9mZnNldFwiLCBTdHJpbmcobGluZURhc2hPZmZzZXQpKTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIERlZmF1bHRzIGZvciBzdHlsZSBwcm9wZXJ0aWVzLiBOb3RlIHRoYXQgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0aGUgcG9zaXRpb25cbiAqIGFuZCBzaGFwZSBvZiB0aGUgbm9kZSBhcmUgbm90IGNvbnNpZGVyZWQgc3R5bGUgcHJvcGVydGllcywgZm9yIGV4YW1wbGU6XG4gKiBgeGAsIGB5YCwgYHdpZHRoYCwgYGhlaWdodGAsIGByYWRpdXNgLCBgcm90YXRpb25gLCBldGMuXG4gKiBDYW4gYmUgdXNlZCB0byByZXNldCB0byB0aGUgb3JpZ2luYWwgc3R5bGluZyBhZnRlciBzb21lIGN1c3RvbSBzdHlsaW5nXG4gKiBoYXMgYmVlbiBhcHBsaWVkICh1c2luZyB0aGUgYHJlc3RvcmVPd25TdHlsZXNgIG1ldGhvZCkuXG4gKiBUaGVzZSBzdGF0aWMgZGVmYXVsdHMgYXJlIG1lYW50IHRvIGJlIGluaGVyaXRlZCBieSBzdWJjbGFzc2VzLlxuICovXG5fU2hhcGUuZGVmYXVsdFN0eWxlcyA9IHtcbiAgZmlsbDogXCJibGFja1wiLFxuICBzdHJva2U6IHZvaWQgMCxcbiAgc3Ryb2tlV2lkdGg6IDAsXG4gIGxpbmVEYXNoOiB2b2lkIDAsXG4gIGxpbmVEYXNoT2Zmc2V0OiAwLFxuICBsaW5lQ2FwOiB2b2lkIDAsXG4gIGxpbmVKb2luOiB2b2lkIDAsXG4gIG9wYWNpdHk6IDEsXG4gIGZpbGxTaGFkb3c6IHZvaWQgMCxcbiAgZGVmYXVsdENvbG9yUmFuZ2U6IFtcIiM1MDkwZGNcIiwgXCIjZWY1NDUyXCJdXG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgY2hhbmdlQ2I6IChzKSA9PiBzLm9uRmlsbENoYW5nZSgpIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IGNoYW5nZUNiOiAocykgPT4gcy5vblN0cm9rZUNoYW5nZSgpIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwibGluZUNhcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwibGluZUpvaW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcIm1pdGVyTGltaXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IGNvbnZlcnRvcjogKHYpID0+IGNsYW1wKDAsIHYsIDEpIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IGNoZWNrRGlydHlPbkFzc2lnbm1lbnQ6IHRydWUgfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwiZmlsbFNoYWRvd1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgY2hhbmdlQ2I6IChzKSA9PiBzLm9uRmlsbENoYW5nZSgpIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcImdyYWRpZW50RmlsbE9wdGlvbnNcIiwgMik7XG52YXIgU2hhcGUgPSBfU2hhcGU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL21hdHJpeC50c1xudmFyIElERU5USVRZX01BVFJJWF9FTEVNRU5UUyA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbnZhciBNYXRyaXggPSBjbGFzcyBfTWF0cml4IHtcbiAgZ2V0IGUoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmVsZW1lbnRzXTtcbiAgfVxuICBjb25zdHJ1Y3RvcihlbGVtZW50cyA9IElERU5USVRZX01BVFJJWF9FTEVNRU5UUykge1xuICAgIHRoaXMuZWxlbWVudHMgPSBbLi4uZWxlbWVudHNdO1xuICB9XG4gIHNldEVsZW1lbnRzKGVsZW1lbnRzKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgZVswXSA9IGVsZW1lbnRzWzBdO1xuICAgIGVbMV0gPSBlbGVtZW50c1sxXTtcbiAgICBlWzJdID0gZWxlbWVudHNbMl07XG4gICAgZVszXSA9IGVsZW1lbnRzWzNdO1xuICAgIGVbNF0gPSBlbGVtZW50c1s0XTtcbiAgICBlWzVdID0gZWxlbWVudHNbNV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0IGlkZW50aXR5KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHJldHVybiBpc051bWJlckVxdWFsKGVbMF0sIDEpICYmIGlzTnVtYmVyRXF1YWwoZVsxXSwgMCkgJiYgaXNOdW1iZXJFcXVhbChlWzJdLCAwKSAmJiBpc051bWJlckVxdWFsKGVbM10sIDEpICYmIGlzTnVtYmVyRXF1YWwoZVs0XSwgMCkgJiYgaXNOdW1iZXJFcXVhbChlWzVdLCAwKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgdGhlIEF4QiBtYXRyaXggbXVsdGlwbGljYXRpb24gYW5kIHNhdmVzIHRoZSByZXN1bHRcbiAgICogdG8gYENgLCBpZiBnaXZlbiwgb3IgdG8gYEFgIG90aGVyd2lzZS5cbiAgICovXG4gIEF4QihBLCBCLCBDMikge1xuICAgIGNvbnN0IGEgPSBBWzBdICogQlswXSArIEFbMl0gKiBCWzFdLCBiID0gQVsxXSAqIEJbMF0gKyBBWzNdICogQlsxXSwgYyA9IEFbMF0gKiBCWzJdICsgQVsyXSAqIEJbM10sIGQgPSBBWzFdICogQlsyXSArIEFbM10gKiBCWzNdLCBlID0gQVswXSAqIEJbNF0gKyBBWzJdICogQls1XSArIEFbNF0sIGYgPSBBWzFdICogQls0XSArIEFbM10gKiBCWzVdICsgQVs1XTtcbiAgICBDMiA9IEMyID8/IEE7XG4gICAgQzJbMF0gPSBhO1xuICAgIEMyWzFdID0gYjtcbiAgICBDMlsyXSA9IGM7XG4gICAgQzJbM10gPSBkO1xuICAgIEMyWzRdID0gZTtcbiAgICBDMls1XSA9IGY7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBgb3RoZXJgIG1hdHJpeCBnZXRzIHBvc3QtbXVsdGlwbGllZCB0byB0aGUgY3VycmVudCBtYXRyaXguXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbWF0cml4LlxuICAgKiBAcGFyYW0gb3RoZXJcbiAgICovXG4gIG11bHRpcGx5U2VsZihvdGhlcikge1xuICAgIHRoaXMuQXhCKHRoaXMuZWxlbWVudHMsIG90aGVyLmVsZW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVGhlIGBvdGhlcmAgbWF0cml4IGdldHMgcG9zdC1tdWx0aXBsaWVkIHRvIHRoZSBjdXJyZW50IG1hdHJpeC5cbiAgICogUmV0dXJucyBhIG5ldyBtYXRyaXguXG4gICAqIEBwYXJhbSBvdGhlclxuICAgKi9cbiAgbXVsdGlwbHkob3RoZXIpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IG5ldyBBcnJheSg2KTtcbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBfTWF0cml4KSB7XG4gICAgICB0aGlzLkF4Qih0aGlzLmVsZW1lbnRzLCBvdGhlci5lbGVtZW50cywgZWxlbWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLkF4Qih0aGlzLmVsZW1lbnRzLCBbb3RoZXIuYSwgb3RoZXIuYiwgb3RoZXIuYywgb3RoZXIuZCwgb3RoZXIuZSwgb3RoZXIuZl0sIGVsZW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfTWF0cml4KGVsZW1lbnRzKTtcbiAgfVxuICBwcmVNdWx0aXBseVNlbGYob3RoZXIpIHtcbiAgICB0aGlzLkF4QihvdGhlci5lbGVtZW50cywgdGhpcy5lbGVtZW50cywgdGhpcy5lbGVtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhpcyBtYXRyaXggYXMgYSBuZXcgbWF0cml4LlxuICAgKi9cbiAgaW52ZXJzZSgpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudHM7XG4gICAgbGV0IGEgPSBlbFswXSwgYiA9IGVsWzFdLCBjID0gZWxbMl0sIGQgPSBlbFszXTtcbiAgICBjb25zdCBlID0gZWxbNF0sIGYgPSBlbFs1XTtcbiAgICBjb25zdCByRCA9IDEgLyAoYSAqIGQgLSBiICogYyk7XG4gICAgYSAqPSByRDtcbiAgICBiICo9IHJEO1xuICAgIGMgKj0gckQ7XG4gICAgZCAqPSByRDtcbiAgICByZXR1cm4gbmV3IF9NYXRyaXgoW2QsIC1iLCAtYywgYSwgYyAqIGYgLSBkICogZSwgYiAqIGUgLSBhICogZl0pO1xuICB9XG4gIGludmVydFNlbGYoKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGxldCBhID0gZWxbMF0sIGIgPSBlbFsxXSwgYyA9IGVsWzJdLCBkID0gZWxbM107XG4gICAgY29uc3QgZSA9IGVsWzRdLCBmID0gZWxbNV07XG4gICAgY29uc3QgckQgPSAxIC8gKGEgKiBkIC0gYiAqIGMpO1xuICAgIGEgKj0gckQ7XG4gICAgYiAqPSByRDtcbiAgICBjICo9IHJEO1xuICAgIGQgKj0gckQ7XG4gICAgZWxbMF0gPSBkO1xuICAgIGVsWzFdID0gLWI7XG4gICAgZWxbMl0gPSAtYztcbiAgICBlbFszXSA9IGE7XG4gICAgZWxbNF0gPSBjICogZiAtIGQgKiBlO1xuICAgIGVsWzVdID0gYiAqIGUgLSBhICogZjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0cmFuc2Zvcm1Qb2ludCh4LCB5KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKiBlWzBdICsgeSAqIGVbMl0gKyBlWzRdLFxuICAgICAgeTogeCAqIGVbMV0gKyB5ICogZVszXSArIGVbNV1cbiAgICB9O1xuICB9XG4gIHRyYW5zZm9ybUJCb3goYmJveCwgdGFyZ2V0KSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGNvbnN0IHh4ID0gZWxbMF07XG4gICAgY29uc3QgeHkgPSBlbFsxXTtcbiAgICBjb25zdCB5eCA9IGVsWzJdO1xuICAgIGNvbnN0IHl5ID0gZWxbM107XG4gICAgY29uc3QgaF93ID0gYmJveC53aWR0aCAqIDAuNTtcbiAgICBjb25zdCBoX2ggPSBiYm94LmhlaWdodCAqIDAuNTtcbiAgICBjb25zdCBjeCA9IGJib3gueCArIGhfdztcbiAgICBjb25zdCBjeSA9IGJib3gueSArIGhfaDtcbiAgICBjb25zdCB3ID0gTWF0aC5hYnMoaF93ICogeHgpICsgTWF0aC5hYnMoaF9oICogeXgpO1xuICAgIGNvbnN0IGggPSBNYXRoLmFicyhoX3cgKiB4eSkgKyBNYXRoLmFicyhoX2ggKiB5eSk7XG4gICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBuZXcgQkJveCgwLCAwLCAwLCAwKSk7XG4gICAgdGFyZ2V0LnggPSBjeCAqIHh4ICsgY3kgKiB5eCArIGVsWzRdIC0gdztcbiAgICB0YXJnZXQueSA9IGN4ICogeHkgKyBjeSAqIHl5ICsgZWxbNV0gLSBoO1xuICAgIHRhcmdldC53aWR0aCA9IHcgKyB3O1xuICAgIHRhcmdldC5oZWlnaHQgPSBoICsgaDtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHRvQ29udGV4dChjdHgpIHtcbiAgICBpZiAodGhpcy5pZGVudGl0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICBjdHgudHJhbnNmb3JtKGVbMF0sIGVbMV0sIGVbMl0sIGVbM10sIGVbNF0sIGVbNV0pO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVUcmFuc2Zvcm1NYXRyaXgobWF0cml4LCBzY2FsaW5nWCwgc2NhbGluZ1ksIHJvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSwgb3B0cykge1xuICAgIGNvbnN0IHN4ID0gc2NhbGluZ1g7XG4gICAgY29uc3Qgc3kgPSBzY2FsaW5nWTtcbiAgICBsZXQgc2N4O1xuICAgIGxldCBzY3k7XG4gICAgaWYgKHN4ID09PSAxICYmIHN5ID09PSAxKSB7XG4gICAgICBzY3ggPSAwO1xuICAgICAgc2N5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2N4ID0gb3B0cz8uc2NhbGluZ0NlbnRlclggPz8gMDtcbiAgICAgIHNjeSA9IG9wdHM/LnNjYWxpbmdDZW50ZXJZID8/IDA7XG4gICAgfVxuICAgIGNvbnN0IHIgPSByb3RhdGlvbjtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhyKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihyKTtcbiAgICBsZXQgcmN4O1xuICAgIGxldCByY3k7XG4gICAgaWYgKHIgPT09IDApIHtcbiAgICAgIHJjeCA9IDA7XG4gICAgICByY3kgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByY3ggPSBvcHRzPy5yb3RhdGlvbkNlbnRlclggPz8gMDtcbiAgICAgIHJjeSA9IG9wdHM/LnJvdGF0aW9uQ2VudGVyWSA/PyAwO1xuICAgIH1cbiAgICBjb25zdCB0eCA9IHRyYW5zbGF0aW9uWDtcbiAgICBjb25zdCB0eSA9IHRyYW5zbGF0aW9uWTtcbiAgICBjb25zdCB0eDQgPSBzY3ggKiAoMSAtIHN4KSAtIHJjeDtcbiAgICBjb25zdCB0eTQgPSBzY3kgKiAoMSAtIHN5KSAtIHJjeTtcbiAgICBtYXRyaXguc2V0RWxlbWVudHMoW1xuICAgICAgY29zICogc3gsXG4gICAgICBzaW4gKiBzeCxcbiAgICAgIC1zaW4gKiBzeSxcbiAgICAgIGNvcyAqIHN5LFxuICAgICAgY29zICogdHg0IC0gc2luICogdHk0ICsgcmN4ICsgdHgsXG4gICAgICBzaW4gKiB0eDQgKyBjb3MgKiB0eTQgKyByY3kgKyB0eVxuICAgIF0pO1xuICAgIHJldHVybiBtYXRyaXg7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3RyYW5zZm9ybWFibGUudHNcbmZ1bmN0aW9uIGlzTWF0cml4VHJhbnNmb3JtKG5vZGUpIHtcbiAgcmV0dXJuIGlzTWF0cml4VHJhbnNmb3JtVHlwZShub2RlLmNvbnN0cnVjdG9yKTtcbn1cbnZhciBNQVRSSVhfVFJBTlNGT1JNX1RZUEUgPSBTeW1ib2woXCJpc01hdHJpeFRyYW5zZm9ybVwiKTtcbmZ1bmN0aW9uIGlzTWF0cml4VHJhbnNmb3JtVHlwZShjc3RyKSB7XG4gIHJldHVybiBjc3RyW01BVFJJWF9UUkFOU0ZPUk1fVFlQRV0gPT09IHRydWU7XG59XG5mdW5jdGlvbiBNYXRyaXhUcmFuc2Zvcm0oUGFyZW50KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IFBhcmVudE5vZGUgPSBQYXJlbnQ7XG4gIGlmIChpc01hdHJpeFRyYW5zZm9ybVR5cGUoUGFyZW50KSkge1xuICAgIHJldHVybiBQYXJlbnQ7XG4gIH1cbiAgY29uc3QgVFJBTlNGT1JNX01BVFJJWCA9IFN5bWJvbChcIm1hdHJpeF9jb21iaW5lZF90cmFuc2Zvcm1cIik7XG4gIGNsYXNzIE1hdHJpeFRyYW5zZm9ybUludGVybmFsIGV4dGVuZHMgUGFyZW50Tm9kZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgdGhpc1tfYl0gPSBuZXcgTWF0cml4KCk7XG4gICAgICB0aGlzLl9kaXJ0eVRyYW5zZm9ybSA9IHRydWU7XG4gICAgfVxuICAgIG1hcmtEaXJ0eVRyYW5zZm9ybSgpIHtcbiAgICAgIHRoaXMuX2RpcnR5VHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgIHN1cGVyLm1hcmtEaXJ0eSgpO1xuICAgIH1cbiAgICB1cGRhdGVNYXRyaXgoX21hdHJpeCkge1xuICAgIH1cbiAgICBjb21wdXRlVHJhbnNmb3JtTWF0cml4KCkge1xuICAgICAgaWYgKCF0aGlzLl9kaXJ0eVRyYW5zZm9ybSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpc1tUUkFOU0ZPUk1fTUFUUklYXS5zZXRFbGVtZW50cyhJREVOVElUWV9NQVRSSVhfRUxFTUVOVFMpO1xuICAgICAgdGhpcy51cGRhdGVNYXRyaXgodGhpc1tUUkFOU0ZPUk1fTUFUUklYXSk7XG4gICAgICB0aGlzLl9kaXJ0eVRyYW5zZm9ybSA9IGZhbHNlO1xuICAgIH1cbiAgICB0b1BhcmVudChiYm94KSB7XG4gICAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICAgIGlmICh0aGlzW1RSQU5TRk9STV9NQVRSSVhdLmlkZW50aXR5KVxuICAgICAgICByZXR1cm4gYmJveC5jbG9uZSgpO1xuICAgICAgcmV0dXJuIHRoaXNbVFJBTlNGT1JNX01BVFJJWF0udHJhbnNmb3JtQkJveChiYm94KTtcbiAgICB9XG4gICAgdG9QYXJlbnRQb2ludCh4LCB5KSB7XG4gICAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICAgIGlmICh0aGlzW1RSQU5TRk9STV9NQVRSSVhdLmlkZW50aXR5KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICByZXR1cm4gdGhpc1tUUkFOU0ZPUk1fTUFUUklYXS50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcbiAgICB9XG4gICAgZnJvbVBhcmVudChiYm94KSB7XG4gICAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICAgIGlmICh0aGlzW1RSQU5TRk9STV9NQVRSSVhdLmlkZW50aXR5KVxuICAgICAgICByZXR1cm4gYmJveC5jbG9uZSgpO1xuICAgICAgcmV0dXJuIHRoaXNbVFJBTlNGT1JNX01BVFJJWF0uaW52ZXJzZSgpLnRyYW5zZm9ybUJCb3goYmJveCk7XG4gICAgfVxuICAgIGZyb21QYXJlbnRQb2ludCh4LCB5KSB7XG4gICAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICAgIGlmICh0aGlzW1RSQU5TRk9STV9NQVRSSVhdLmlkZW50aXR5KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICByZXR1cm4gdGhpc1tUUkFOU0ZPUk1fTUFUUklYXS5pbnZlcnNlKCkudHJhbnNmb3JtUG9pbnQoeCwgeSk7XG4gICAgfVxuICAgIGNvbXB1dGVCQm94KCkge1xuICAgICAgY29uc3QgYmJveCA9IHN1cGVyLmNvbXB1dGVCQm94KCk7XG4gICAgICBpZiAoIWJib3gpXG4gICAgICAgIHJldHVybiBiYm94O1xuICAgICAgcmV0dXJuIHRoaXMudG9QYXJlbnQoYmJveCk7XG4gICAgfVxuICAgIGNvbXB1dGVCQm94V2l0aG91dFRyYW5zZm9ybXMoKSB7XG4gICAgICByZXR1cm4gc3VwZXIuY29tcHV0ZUJCb3goKTtcbiAgICB9XG4gICAgcGlja05vZGUoeCwgeSwgbG9jYWxDb29yZHMgPSBmYWxzZSkge1xuICAgICAgaWYgKCFsb2NhbENvb3Jkcykge1xuICAgICAgICAoeyB4LCB5IH0gPSB0aGlzLmZyb21QYXJlbnRQb2ludCh4LCB5KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIucGlja05vZGUoeCwgeSk7XG4gICAgfVxuICAgIHJlbmRlcihyZW5kZXJDdHgpIHtcbiAgICAgIHRoaXMuY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgY29uc3QgeyBjdHggfSA9IHJlbmRlckN0eDtcbiAgICAgIGNvbnN0IG1hdHJpeCA9IHRoaXNbVFJBTlNGT1JNX01BVFJJWF07XG4gICAgICBsZXQgcGVyZm9ybVJlc3RvcmUgPSBmYWxzZTtcbiAgICAgIGlmICghbWF0cml4LmlkZW50aXR5KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHBlcmZvcm1SZXN0b3JlID0gdHJ1ZTtcbiAgICAgICAgbWF0cml4LnRvQ29udGV4dChjdHgpO1xuICAgICAgfVxuICAgICAgc3VwZXIucmVuZGVyKHJlbmRlckN0eCk7XG4gICAgICBpZiAocGVyZm9ybVJlc3RvcmUpIHtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdG9TVkcoKSB7XG4gICAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICAgIGNvbnN0IHN2ZyA9IHN1cGVyLnRvU1ZHKCk7XG4gICAgICBjb25zdCBtYXRyaXggPSB0aGlzW1RSQU5TRk9STV9NQVRSSVhdO1xuICAgICAgaWYgKG1hdHJpeC5pZGVudGl0eSB8fCBzdmcgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICAgIGNvbnN0IGcgPSBjcmVhdGVTdmdFbGVtZW50KFwiZ1wiKTtcbiAgICAgIGcuYXBwZW5kKC4uLnN2Zy5lbGVtZW50cyk7XG4gICAgICBjb25zdCBbYSwgYiwgYywgZCwgZSwgZl0gPSBtYXRyaXguZTtcbiAgICAgIGcuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIGBtYXRyaXgoJHthfSAke2J9ICR7Y30gJHtkfSAke2V9ICR7Zn0pYCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbGVtZW50czogW2ddLFxuICAgICAgICBkZWZzOiBzdmcuZGVmc1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgX2EgPSBNQVRSSVhfVFJBTlNGT1JNX1RZUEUsIF9iID0gVFJBTlNGT1JNX01BVFJJWDtcbiAgTWF0cml4VHJhbnNmb3JtSW50ZXJuYWxbX2FdID0gdHJ1ZTtcbiAgcmV0dXJuIE1hdHJpeFRyYW5zZm9ybUludGVybmFsO1xufVxuZnVuY3Rpb24gUm90YXRhYmxlKFBhcmVudCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IFBhcmVudE5vZGUgPSBQYXJlbnQ7XG4gIGNvbnN0IFJPVEFUQUJMRV9NQVRSSVggPSBTeW1ib2woXCJtYXRyaXhfcm90YXRpb25cIik7XG4gIGNsYXNzIFJvdGF0YWJsZUludGVybmFsIGV4dGVuZHMgTWF0cml4VHJhbnNmb3JtKFBhcmVudE5vZGUpIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICB0aGlzW19hXSA9IG5ldyBNYXRyaXgoKTtcbiAgICAgIHRoaXMucm90YXRpb25DZW50ZXJYID0gbnVsbDtcbiAgICAgIHRoaXMucm90YXRpb25DZW50ZXJZID0gbnVsbDtcbiAgICAgIHRoaXMucm90YXRpb24gPSAwO1xuICAgIH1cbiAgICB1cGRhdGVNYXRyaXgobWF0cml4KSB7XG4gICAgICBzdXBlci51cGRhdGVNYXRyaXgobWF0cml4KTtcbiAgICAgIGNvbnN0IHsgcm90YXRpb24sIHJvdGF0aW9uQ2VudGVyWCwgcm90YXRpb25DZW50ZXJZIH0gPSB0aGlzO1xuICAgICAgaWYgKHJvdGF0aW9uID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBNYXRyaXgudXBkYXRlVHJhbnNmb3JtTWF0cml4KHRoaXNbUk9UQVRBQkxFX01BVFJJWF0sIDEsIDEsIHJvdGF0aW9uLCAwLCAwLCB7XG4gICAgICAgIHJvdGF0aW9uQ2VudGVyWCxcbiAgICAgICAgcm90YXRpb25DZW50ZXJZXG4gICAgICB9KTtcbiAgICAgIG1hdHJpeC5tdWx0aXBseVNlbGYodGhpc1tST1RBVEFCTEVfTUFUUklYXSk7XG4gICAgfVxuICB9XG4gIF9hID0gUk9UQVRBQkxFX01BVFJJWDtcbiAgX19kZWNvcmF0ZUNsYXNzKFtcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbiAgXSwgUm90YXRhYmxlSW50ZXJuYWwucHJvdG90eXBlLCBcInJvdGF0aW9uQ2VudGVyWFwiLCAyKTtcbiAgX19kZWNvcmF0ZUNsYXNzKFtcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbiAgXSwgUm90YXRhYmxlSW50ZXJuYWwucHJvdG90eXBlLCBcInJvdGF0aW9uQ2VudGVyWVwiLCAyKTtcbiAgX19kZWNvcmF0ZUNsYXNzKFtcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbiAgXSwgUm90YXRhYmxlSW50ZXJuYWwucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIDIpO1xuICByZXR1cm4gUm90YXRhYmxlSW50ZXJuYWw7XG59XG5mdW5jdGlvbiBTY2FsYWJsZShQYXJlbnQpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBQYXJlbnROb2RlID0gUGFyZW50O1xuICBjb25zdCBTQ0FMQUJMRV9NQVRSSVggPSBTeW1ib2woXCJtYXRyaXhfc2NhbGVcIik7XG4gIGNsYXNzIFNjYWxhYmxlSW50ZXJuYWwgZXh0ZW5kcyBNYXRyaXhUcmFuc2Zvcm0oUGFyZW50Tm9kZSkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgIHRoaXNbX2FdID0gbmV3IE1hdHJpeCgpO1xuICAgICAgdGhpcy5zY2FsaW5nWCA9IDE7XG4gICAgICB0aGlzLnNjYWxpbmdZID0gMTtcbiAgICAgIHRoaXMuc2NhbGluZ0NlbnRlclggPSBudWxsO1xuICAgICAgdGhpcy5zY2FsaW5nQ2VudGVyWSA9IG51bGw7XG4gICAgfVxuICAgIHVwZGF0ZU1hdHJpeChtYXRyaXgpIHtcbiAgICAgIHN1cGVyLnVwZGF0ZU1hdHJpeChtYXRyaXgpO1xuICAgICAgY29uc3QgeyBzY2FsaW5nWCwgc2NhbGluZ1ksIHNjYWxpbmdDZW50ZXJYLCBzY2FsaW5nQ2VudGVyWSB9ID0gdGhpcztcbiAgICAgIGlmIChzY2FsaW5nWCA9PT0gMSAmJiBzY2FsaW5nWSA9PT0gMSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgTWF0cml4LnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCh0aGlzW1NDQUxBQkxFX01BVFJJWF0sIHNjYWxpbmdYLCBzY2FsaW5nWSwgMCwgMCwgMCwge1xuICAgICAgICBzY2FsaW5nQ2VudGVyWCxcbiAgICAgICAgc2NhbGluZ0NlbnRlcllcbiAgICAgIH0pO1xuICAgICAgbWF0cml4Lm11bHRpcGx5U2VsZih0aGlzW1NDQUxBQkxFX01BVFJJWF0pO1xuICAgIH1cbiAgfVxuICBfYSA9IFNDQUxBQkxFX01BVFJJWDtcbiAgX19kZWNvcmF0ZUNsYXNzKFtcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbiAgXSwgU2NhbGFibGVJbnRlcm5hbC5wcm90b3R5cGUsIFwic2NhbGluZ1hcIiwgMik7XG4gIF9fZGVjb3JhdGVDbGFzcyhbXG4gICAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG4gIF0sIFNjYWxhYmxlSW50ZXJuYWwucHJvdG90eXBlLCBcInNjYWxpbmdZXCIsIDIpO1xuICBfX2RlY29yYXRlQ2xhc3MoW1xuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuICBdLCBTY2FsYWJsZUludGVybmFsLnByb3RvdHlwZSwgXCJzY2FsaW5nQ2VudGVyWFwiLCAyKTtcbiAgX19kZWNvcmF0ZUNsYXNzKFtcbiAgICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbiAgXSwgU2NhbGFibGVJbnRlcm5hbC5wcm90b3R5cGUsIFwic2NhbGluZ0NlbnRlcllcIiwgMik7XG4gIHJldHVybiBTY2FsYWJsZUludGVybmFsO1xufVxuZnVuY3Rpb24gVHJhbnNsYXRhYmxlKFBhcmVudCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IFBhcmVudE5vZGUgPSBQYXJlbnQ7XG4gIGNvbnN0IFRSQU5TTEFUQUJMRV9NQVRSSVggPSBTeW1ib2woXCJtYXRyaXhfdHJhbnNsYXRpb25cIik7XG4gIGNsYXNzIFRyYW5zbGF0YWJsZUludGVybmFsIGV4dGVuZHMgTWF0cml4VHJhbnNmb3JtKFBhcmVudE5vZGUpIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICB0aGlzW19hXSA9IG5ldyBNYXRyaXgoKTtcbiAgICAgIHRoaXMudHJhbnNsYXRpb25YID0gMDtcbiAgICAgIHRoaXMudHJhbnNsYXRpb25ZID0gMDtcbiAgICB9XG4gICAgdXBkYXRlTWF0cml4KG1hdHJpeCkge1xuICAgICAgc3VwZXIudXBkYXRlTWF0cml4KG1hdHJpeCk7XG4gICAgICBjb25zdCB7IHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0gPSB0aGlzO1xuICAgICAgaWYgKHRyYW5zbGF0aW9uWCA9PT0gMCAmJiB0cmFuc2xhdGlvblkgPT09IDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIE1hdHJpeC51cGRhdGVUcmFuc2Zvcm1NYXRyaXgodGhpc1tUUkFOU0xBVEFCTEVfTUFUUklYXSwgMSwgMSwgMCwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkpO1xuICAgICAgbWF0cml4Lm11bHRpcGx5U2VsZih0aGlzW1RSQU5TTEFUQUJMRV9NQVRSSVhdKTtcbiAgICB9XG4gIH1cbiAgX2EgPSBUUkFOU0xBVEFCTEVfTUFUUklYO1xuICBfX2RlY29yYXRlQ2xhc3MoW1xuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuICBdLCBUcmFuc2xhdGFibGVJbnRlcm5hbC5wcm90b3R5cGUsIFwidHJhbnNsYXRpb25YXCIsIDIpO1xuICBfX2RlY29yYXRlQ2xhc3MoW1xuICAgIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuICBdLCBUcmFuc2xhdGFibGVJbnRlcm5hbC5wcm90b3R5cGUsIFwidHJhbnNsYXRpb25ZXCIsIDIpO1xuICByZXR1cm4gVHJhbnNsYXRhYmxlSW50ZXJuYWw7XG59XG52YXIgVHJhbnNmb3JtYWJsZSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgQkJveCBmcm9tIGNhbnZhcyBjb29yZGluYXRlIHNwYWNlIGludG8gdGhlIGNvb3JkaW5hdGUgc3BhY2Ugb2YgdGhlIGdpdmVuIE5vZGUuXG4gICAqL1xuICBzdGF0aWMgZnJvbUNhbnZhcyhub2RlLCBiYm94KSB7XG4gICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgIGZvciAoY29uc3QgcGFyZW50IG9mIG5vZGUudHJhdmVyc2VVcCgpKSB7XG4gICAgICBpZiAoaXNNYXRyaXhUcmFuc2Zvcm0ocGFyZW50KSkge1xuICAgICAgICBwYXJlbnRzLnVuc2hpZnQocGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXJlbnQgb2YgcGFyZW50cykge1xuICAgICAgYmJveCA9IHBhcmVudC5mcm9tUGFyZW50KGJib3gpO1xuICAgIH1cbiAgICBpZiAoaXNNYXRyaXhUcmFuc2Zvcm0obm9kZSkpIHtcbiAgICAgIGJib3ggPSBub2RlLmZyb21QYXJlbnQoYmJveCk7XG4gICAgfVxuICAgIHJldHVybiBiYm94O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIE5vZGVzIEJCb3ggKG9yIGFuIGFyYml0cmFyeSBCQm94IGlmIHN1cHBsaWVkKSBmcm9tIGxvY2FsIE5vZGUgY29vcmRpbmF0ZSBzcGFjZVxuICAgKiBpbnRvIHRoZSBDYW52YXMgY29vcmRpbmF0ZSBzcGFjZS5cbiAgICovXG4gIHN0YXRpYyB0b0NhbnZhcyhub2RlLCBiYm94KSB7XG4gICAgaWYgKGJib3ggPT0gbnVsbCkge1xuICAgICAgYmJveCA9IG5vZGUuZ2V0QkJveCgpO1xuICAgIH0gZWxzZSBpZiAoaXNNYXRyaXhUcmFuc2Zvcm0obm9kZSkpIHtcbiAgICAgIGJib3ggPSBub2RlLnRvUGFyZW50KGJib3gpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHBhcmVudCBvZiBub2RlLnRyYXZlcnNlVXAoKSkge1xuICAgICAgaWYgKGlzTWF0cml4VHJhbnNmb3JtKHBhcmVudCkpIHtcbiAgICAgICAgYmJveCA9IHBhcmVudC50b1BhcmVudChiYm94KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJib3g7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgcG9pbnQgZnJvbSBjYW52YXMgY29vcmRpbmF0ZSBzcGFjZSBpbnRvIHRoZSBjb29yZGluYXRlIHNwYWNlIG9mIHRoZSBnaXZlbiBOb2RlLlxuICAgKi9cbiAgc3RhdGljIGZyb21DYW52YXNQb2ludChub2RlLCB4LCB5KSB7XG4gICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgIGZvciAoY29uc3QgcGFyZW50IG9mIG5vZGUudHJhdmVyc2VVcCgpKSB7XG4gICAgICBpZiAoaXNNYXRyaXhUcmFuc2Zvcm0ocGFyZW50KSkge1xuICAgICAgICBwYXJlbnRzLnVuc2hpZnQocGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXJlbnQgb2YgcGFyZW50cykge1xuICAgICAgKHsgeCwgeSB9ID0gcGFyZW50LmZyb21QYXJlbnRQb2ludCh4LCB5KSk7XG4gICAgfVxuICAgIGlmIChpc01hdHJpeFRyYW5zZm9ybShub2RlKSkge1xuICAgICAgKHsgeCwgeSB9ID0gbm9kZS5mcm9tUGFyZW50UG9pbnQoeCwgeSkpO1xuICAgIH1cbiAgICByZXR1cm4geyB4LCB5IH07XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgcG9pbnQgZnJvbSBhIE5vZGVzIGxvY2FsIGNvb3JkaW5hdGUgc3BhY2UgaW50byB0aGUgQ2FudmFzIGNvb3JkaW5hdGUgc3BhY2UuXG4gICAqL1xuICBzdGF0aWMgdG9DYW52YXNQb2ludChub2RlLCB4LCB5KSB7XG4gICAgaWYgKGlzTWF0cml4VHJhbnNmb3JtKG5vZGUpKSB7XG4gICAgICAoeyB4LCB5IH0gPSBub2RlLnRvUGFyZW50UG9pbnQoeCwgeSkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHBhcmVudCBvZiBub2RlLnRyYXZlcnNlVXAoKSkge1xuICAgICAgaWYgKGlzTWF0cml4VHJhbnNmb3JtKHBhcmVudCkpIHtcbiAgICAgICAgKHsgeCwgeSB9ID0gcGFyZW50LnRvUGFyZW50UG9pbnQoeCwgeSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB4LCB5IH07XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3pJbmRleC50c1xudmFyIGNtcCA9IChhLCBiKSA9PiBNYXRoLnNpZ24oYSAtIGIpO1xuZnVuY3Rpb24gY29tcGFyZVpJbmRleChhLCBiKSB7XG4gIGlmICh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgYiA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBjbXAoYSwgYik7XG4gIH1cbiAgY29uc3QgYUFycmF5ID0gdHlwZW9mIGEgPT09IFwibnVtYmVyXCIgPyBbYV0gOiBhO1xuICBjb25zdCBiQXJyYXkgPSB0eXBlb2YgYiA9PT0gXCJudW1iZXJcIiA/IFtiXSA6IGI7XG4gIGNvbnN0IGxlbmd0aDIgPSBNYXRoLm1pbihhQXJyYXkubGVuZ3RoLCBiQXJyYXkubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGgyOyBpICs9IDEpIHtcbiAgICBjb25zdCBkaWZmMiA9IGNtcChhQXJyYXlbaV0sIGJBcnJheVtpXSk7XG4gICAgaWYgKGRpZmYyICE9PSAwKVxuICAgICAgcmV0dXJuIGRpZmYyO1xuICB9XG4gIHJldHVybiBjbXAoYUFycmF5Lmxlbmd0aCwgYkFycmF5Lmxlbmd0aCk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2dyb3VwLnRzXG52YXIgc2hhcmVkT2Zmc2NyZWVuQ2FudmFzO1xudmFyIF9Hcm91cCA9IGNsYXNzIF9Hcm91cCBleHRlbmRzIE5vZGUge1xuICAvLyBvcHRpbWl6ZUZvckluZnJlcXVlbnRSZWRyYXdzOiB0cnVlXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcbiAgICB0aGlzLm9wYWNpdHkgPSAxO1xuICAgIHRoaXMucmVuZGVyVG9PZmZzY3JlZW5DYW52YXMgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGltaXplRm9ySW5mcmVxdWVudFJlZHJhd3MgPSBmYWxzZTtcbiAgICAvLyBVc2VkIHdoZW4gcmVuZGVyVG9PZmZzY3JlZW5DYW52YXM6IHRydWVcbiAgICB0aGlzLmxheWVyID0gdm9pZCAwO1xuICAgIC8vIG9wdGltaXplRm9ySW5mcmVxdWVudFJlZHJhd3M6IGZhbHNlXG4gICAgdGhpcy5pbWFnZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9sYXN0V2lkdGggPSBOYU47XG4gICAgdGhpcy5fbGFzdEhlaWdodCA9IE5hTjtcbiAgICB0aGlzLl9sYXN0RGV2aWNlUGl4ZWxSYXRpbyA9IE5hTjtcbiAgICB0aGlzLmlzQ29udGFpbmVyTm9kZSA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJUb09mZnNjcmVlbkNhbnZhcyA9IG9wdHM/LnJlbmRlclRvT2Zmc2NyZWVuQ2FudmFzID09PSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9Hcm91cDtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZUNoaWxkcmVuQkJveChub2Rlcywgc2tpcEludmlzaWJsZSA9IHRydWUpIHtcbiAgICByZXR1cm4gQkJveC5tZXJnZShOb2RlLmV4dHJhY3RCQm94ZXMobm9kZXMsIHNraXBJbnZpc2libGUpKTtcbiAgfVxuICBzdGF0aWMgY29tcGFyZUNoaWxkcmVuKGEsIGIpIHtcbiAgICByZXR1cm4gY29tcGFyZVpJbmRleChhLnpJbmRleCwgYi56SW5kZXgpIHx8IGEuc2VyaWFsTnVtYmVyIC0gYi5zZXJpYWxOdW1iZXI7XG4gIH1cbiAgLy8gV2UgY29uc2lkZXIgYSBncm91cCB0byBiZSBib3VuZGxlc3MsIHRodXMgYW55IHBvaW50IGJlbG9uZ3MgdG8gaXQuXG4gIGNvbnRhaW5zUG9pbnQoX3gsIF95KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgcmV0dXJuIF9Hcm91cC5jb21wdXRlQ2hpbGRyZW5CQm94KHRoaXMuY2hpbGRyZW4oKSk7XG4gIH1cbiAgY29tcHV0ZVNhZmVDbGlwcGluZ0JCb3gocGl4ZWxSYXRpbykge1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLmNvbXB1dGVCQm94KCk7XG4gICAgaWYgKCFiYm94LmlzRmluaXRlKCkpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHN0cm9rZVdpZHRoID0gMDtcbiAgICBjb25zdCBzdHJva2VNaXRlckFtb3VudCA9IDQ7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmRlc2NlbmRhbnRzKCkpIHtcbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFNoYXBlKSB7XG4gICAgICAgIHN0cm9rZVdpZHRoID0gTWF0aC5tYXgoc3Ryb2tlV2lkdGgsIGNoaWxkLnN0cm9rZVdpZHRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9IE1hdGgubWF4KFxuICAgICAgLy8gQWNjb3VudCBmb3IgYW50aS1hbGlhc2luZyBhcnRlZmFjdHNcbiAgICAgIDEsXG4gICAgICAvLyBBY2NvdW50IGZvciBzdHJva2VzIChpbmNsLiBtaXRlcnMpIC0gdGhpcyBtYXkgbm90IGJlIHRoZSBiZXN0IHBsYWNlIHRvIGluY2x1ZGUgdGhpc1xuICAgICAgc3Ryb2tlV2lkdGggLyAyICogc3Ryb2tlTWl0ZXJBbW91bnRcbiAgICApO1xuICAgIGNvbnN0IHsgeDogb3JpZ2luWCwgeTogb3JpZ2luWSB9ID0gVHJhbnNmb3JtYWJsZS50b0NhbnZhc1BvaW50KHRoaXMsIDAsIDApO1xuICAgIGNvbnN0IHggPSBhbGlnbkJlZm9yZShwaXhlbFJhdGlvLCBvcmlnaW5YICsgYmJveC54IC0gcGFkZGluZykgLSBvcmlnaW5YO1xuICAgIGNvbnN0IHkgPSBhbGlnbkJlZm9yZShwaXhlbFJhdGlvLCBvcmlnaW5ZICsgYmJveC55IC0gcGFkZGluZykgLSBvcmlnaW5ZO1xuICAgIGNvbnN0IHdpZHRoMiA9IE1hdGguY2VpbChiYm94LnggKyBiYm94LndpZHRoIC0geCArIHBhZGRpbmcpO1xuICAgIGNvbnN0IGhlaWdodDIgPSBNYXRoLmNlaWwoYmJveC55ICsgYmJveC5oZWlnaHQgLSB5ICsgcGFkZGluZyk7XG4gICAgcmV0dXJuIG5ldyBCQm94KHgsIHksIHdpZHRoMiwgaGVpZ2h0Mik7XG4gIH1cbiAgcHJlcGFyZVNoYXJlZENhbnZhcyh3aWR0aDIsIGhlaWdodDIsIHBpeGVsUmF0aW8pIHtcbiAgICBpZiAoc2hhcmVkT2Zmc2NyZWVuQ2FudmFzID09IG51bGwgfHwgc2hhcmVkT2Zmc2NyZWVuQ2FudmFzLnBpeGVsUmF0aW8gIT09IHBpeGVsUmF0aW8pIHtcbiAgICAgIHNoYXJlZE9mZnNjcmVlbkNhbnZhcyA9IG5ldyBIZHBpT2Zmc2NyZWVuQ2FudmFzKHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyLCBwaXhlbFJhdGlvIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaGFyZWRPZmZzY3JlZW5DYW52YXMucmVzaXplKHdpZHRoMiwgaGVpZ2h0MiwgcGl4ZWxSYXRpbyk7XG4gICAgfVxuICAgIHJldHVybiBzaGFyZWRPZmZzY3JlZW5DYW52YXM7XG4gIH1cbiAgaXNEaXJ0eShyZW5kZXJDdHgpIHtcbiAgICBjb25zdCB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiwgZGV2aWNlUGl4ZWxSYXRpbyB9ID0gcmVuZGVyQ3R4O1xuICAgIGNvbnN0IHsgZGlydHksIGRpcnR5WkluZGV4LCBsYXllciB9ID0gdGhpcztcbiAgICBjb25zdCBsYXllclJlc2l6ZWQgPSBsYXllciAhPSBudWxsICYmICh0aGlzLl9sYXN0V2lkdGggIT09IHdpZHRoMiB8fCB0aGlzLl9sYXN0SGVpZ2h0ICE9PSBoZWlnaHQyKTtcbiAgICBjb25zdCBwaXhlbFJhdGlvQ2hhbmdlZCA9IHRoaXMuX2xhc3REZXZpY2VQaXhlbFJhdGlvICE9PSBkZXZpY2VQaXhlbFJhdGlvO1xuICAgIHRoaXMuX2xhc3RXaWR0aCA9IHdpZHRoMjtcbiAgICB0aGlzLl9sYXN0SGVpZ2h0ID0gaGVpZ2h0MjtcbiAgICB0aGlzLl9sYXN0RGV2aWNlUGl4ZWxSYXRpbyA9IGRldmljZVBpeGVsUmF0aW87XG4gICAgaWYgKGRpcnR5IHx8IGRpcnR5WkluZGV4IHx8IGxheWVyUmVzaXplZCB8fCBwaXhlbFJhdGlvQ2hhbmdlZClcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbigpKSB7XG4gICAgICBpZiAoY2hpbGQuZGlydHkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcHJlUmVuZGVyKHJlbmRlckN0eCkge1xuICAgIGNvbnN0IGNvdW50cyA9IHN1cGVyLnByZVJlbmRlcihyZW5kZXJDdHgsIDApO1xuICAgIGNvdW50cy5ncm91cHMgKz0gMTtcbiAgICBjb3VudHMubm9uR3JvdXBzIC09IDE7XG4gICAgaWYgKHRoaXMucmVuZGVyVG9PZmZzY3JlZW5DYW52YXMgJiYgIXRoaXMub3B0aW1pemVGb3JJbmZyZXF1ZW50UmVkcmF3cyAmJiBjb3VudHMubm9uR3JvdXBzID4gMCAmJiB0aGlzLmdldFZpc2liaWxpdHkoKSkge1xuICAgICAgdGhpcy5sYXllciA/PyAodGhpcy5sYXllciA9IHRoaXMuX2xheWVyTWFuYWdlcj8uYWRkTGF5ZXIoeyBuYW1lOiB0aGlzLm5hbWUgfSkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sYXllciAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9sYXllck1hbmFnZXI/LnJlbW92ZUxheWVyKHRoaXMubGF5ZXIpO1xuICAgICAgdGhpcy5sYXllciA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50cztcbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyBsYXllciwgcmVuZGVyVG9PZmZzY3JlZW5DYW52YXMgfSA9IHRoaXM7XG4gICAgY29uc3QgY2hpbGRSZW5kZXJDdHggPSB7IC4uLnJlbmRlckN0eCB9O1xuICAgIGlmICghcmVuZGVyVG9PZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgIHRoaXMucmVuZGVySW5Db250ZXh0KGNoaWxkUmVuZGVyQ3R4KTtcbiAgICAgIHN1cGVyLnJlbmRlcihjaGlsZFJlbmRlckN0eCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY3R4LCBzdGF0cywgZGV2aWNlUGl4ZWxSYXRpbzogcGl4ZWxSYXRpbyB9ID0gcmVuZGVyQ3R4O1xuICAgIGxldCB7IGltYWdlIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLmlzRGlydHkocmVuZGVyQ3R4KSkge1xuICAgICAgaW1hZ2U/LmJpdG1hcC5jbG9zZSgpO1xuICAgICAgaW1hZ2UgPSB2b2lkIDA7XG4gICAgICBjb25zdCBiYm94ID0gbGF5ZXIgPyB2b2lkIDAgOiB0aGlzLmNvbXB1dGVTYWZlQ2xpcHBpbmdCQm94KHBpeGVsUmF0aW8pO1xuICAgICAgY29uc3QgcmVuZGVyT2Zmc2NyZWVuID0gKG9mZnNjcmVlbkNhbnZhcywgLi4udHJhbnNmb3JtKSA9PiB7XG4gICAgICAgIGNvbnN0IG9mZnNjcmVlbkN0eCA9IG9mZnNjcmVlbkNhbnZhcy5jb250ZXh0O1xuICAgICAgICBjaGlsZFJlbmRlckN0eC5jdHggPSBvZmZzY3JlZW5DdHg7XG4gICAgICAgIG9mZnNjcmVlbkNhbnZhcy5jbGVhcigpO1xuICAgICAgICBvZmZzY3JlZW5DdHguc2F2ZSgpO1xuICAgICAgICBvZmZzY3JlZW5DdHguc2V0VHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgICAgIG9mZnNjcmVlbkN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIHRoaXMucmVuZGVySW5Db250ZXh0KGNoaWxkUmVuZGVyQ3R4KTtcbiAgICAgICAgb2Zmc2NyZWVuQ3R4LnJlc3RvcmUoKTtcbiAgICAgICAgb2Zmc2NyZWVuQ3R4LnZlcmlmeURlcHRoWmVybz8uKCk7XG4gICAgICB9O1xuICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgIHJlbmRlck9mZnNjcmVlbihsYXllciwgY3R4LmdldFRyYW5zZm9ybSgpKTtcbiAgICAgIH0gZWxzZSBpZiAoYmJveCkge1xuICAgICAgICBjb25zdCB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gYmJveDtcbiAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5wcmVwYXJlU2hhcmVkQ2FudmFzKHdpZHRoMiwgaGVpZ2h0MiwgcGl4ZWxSYXRpbyk7XG4gICAgICAgIHJlbmRlck9mZnNjcmVlbihjYW52YXMsIHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIC14ICogcGl4ZWxSYXRpbywgLXkgKiBwaXhlbFJhdGlvKTtcbiAgICAgICAgaW1hZ2UgPSB7IGJpdG1hcDogY2FudmFzLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpLCB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kaXJ0eVpJbmRleCkge1xuICAgICAgICB0aGlzLnNvcnRDaGlsZHJlbihfR3JvdXAuY29tcGFyZUNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgIGlmIChzdGF0cylcbiAgICAgICAgc3RhdHMubGF5ZXJzUmVuZGVyZWQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5za2lwUmVuZGVyKGNoaWxkUmVuZGVyQ3R4KTtcbiAgICAgIGlmIChzdGF0cylcbiAgICAgICAgc3RhdHMubGF5ZXJzU2tpcHBlZCsrO1xuICAgIH1cbiAgICBjb25zdCB7IGdsb2JhbEFscGhhIH0gPSBjdHg7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gZ2xvYmFsQWxwaGEgKiB0aGlzLm9wYWNpdHk7XG4gICAgaWYgKGxheWVyKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gICAgICBsYXllci5kcmF3SW1hZ2UoY3R4KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSBlbHNlIGlmIChpbWFnZSkge1xuICAgICAgY29uc3QgeyBiaXRtYXAsIHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gaW1hZ2U7XG4gICAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgd2lkdGgyICogcGl4ZWxSYXRpbywgaGVpZ2h0MiAqIHBpeGVsUmF0aW8sIHgsIHksIHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgfVxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IGdsb2JhbEFscGhhO1xuICAgIHN1cGVyLnJlbmRlcihjaGlsZFJlbmRlckN0eCk7XG4gIH1cbiAgc2tpcFJlbmRlcihjaGlsZFJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgc3RhdHMgfSA9IGNoaWxkUmVuZGVyQ3R4O1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbigpKSB7XG4gICAgICBjaGlsZC5tYXJrQ2xlYW4oKTtcbiAgICAgIGlmIChzdGF0cykge1xuICAgICAgICBzdGF0cy5ub2Rlc1NraXBwZWQgKz0gdGhpcy5jaGlsZE5vZGVDb3VudHMuZ3JvdXBzICsgdGhpcy5jaGlsZE5vZGVDb3VudHMubm9uR3JvdXBzO1xuICAgICAgICBzdGF0cy5vcHNTa2lwcGVkICs9IHRoaXMuY2hpbGROb2RlQ291bnRzLmNvbXBsZXhpdHk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFwcGx5Q2xpcChjdHgsIGNsaXBSZWN0KSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IGNsaXBSZWN0O1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgucmVjdCh4LCB5LCB3aWR0aDIsIGhlaWdodDIpO1xuICAgIGN0eC5jbGlwKCk7XG4gIH1cbiAgcmVuZGVySW5Db250ZXh0KGNoaWxkUmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyBjdHgsIHN0YXRzIH0gPSBjaGlsZFJlbmRlckN0eDtcbiAgICBpZiAodGhpcy5kaXJ0eVpJbmRleCkge1xuICAgICAgdGhpcy5zb3J0Q2hpbGRyZW4oX0dyb3VwLmNvbXBhcmVDaGlsZHJlbik7XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4Lmdsb2JhbEFscGhhICo9IHRoaXMub3BhY2l0eTtcbiAgICBpZiAodGhpcy5jbGlwUmVjdCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmFwcGx5Q2xpcChjdHgsIHRoaXMuY2xpcFJlY3QpO1xuICAgICAgY2hpbGRSZW5kZXJDdHguY2xpcEJCb3ggPSBUcmFuc2Zvcm1hYmxlLnRvQ2FudmFzKHRoaXMsIHRoaXMuY2xpcFJlY3QpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4oKSkge1xuICAgICAgaWYgKCFjaGlsZC52aXNpYmxlKSB7XG4gICAgICAgIGNoaWxkLm1hcmtDbGVhbigpO1xuICAgICAgICBpZiAoc3RhdHMpIHtcbiAgICAgICAgICBzdGF0cy5ub2Rlc1NraXBwZWQgKz0gY2hpbGQuY2hpbGROb2RlQ291bnRzLm5vbkdyb3VwcyArIGNoaWxkLmNoaWxkTm9kZUNvdW50cy5ncm91cHM7XG4gICAgICAgICAgc3RhdHMub3BzU2tpcHBlZCArPSBjaGlsZC5jaGlsZE5vZGVDb3VudHMuY29tcGxleGl0eTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjaGlsZC5yZW5kZXIoY2hpbGRSZW5kZXJDdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtcyBiYm94IGdpdmVuIGluIHRoZSBjYW52YXMgY29vcmRpbmF0ZSBzcGFjZSB0byBiYm94IGluIHRoaXMgZ3JvdXAncyBjb29yZGluYXRlIHNwYWNlIGFuZFxuICAgKiBzZXRzIHRoaXMgZ3JvdXAncyBjbGlwUmVjdCB0byB0aGUgdHJhbnNmb3JtZWQgYmJveC5cbiAgICogQHBhcmFtIGJib3ggY2xpcFJlY3QgYmJveCBpbiB0aGUgY2FudmFzIGNvb3JkaW5hdGUgc3BhY2UuXG4gICAqL1xuICBzZXRDbGlwUmVjdChiYm94KSB7XG4gICAgdGhpcy5jbGlwUmVjdCA9IGJib3ggPyBUcmFuc2Zvcm1hYmxlLmZyb21DYW52YXModGhpcywgYmJveCkgOiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgY2xpcCByZWN0IHdpdGhpbiB0aGUgY2FudmFzIGNvb3JkaW5hdGUgc3BhY2UuXG4gICAqIEBwYXJhbSBiYm94IGNsaXBSZWN0IGJib3ggaW4gdGhlIGNhbnZhcyBjb29yZGluYXRlIHNwYWNlLlxuICAgKi9cbiAgc2V0Q2xpcFJlY3RDYW52YXNTcGFjZShiYm94KSB7XG4gICAgdGhpcy5jbGlwUmVjdCA9IGJib3g7XG4gIH1cbiAgX3NldExheWVyTWFuYWdlcihsYXllcnNNYW5hZ2VyKSB7XG4gICAgaWYgKHRoaXMubGF5ZXIpIHtcbiAgICAgIHRoaXMuX2xheWVyTWFuYWdlcj8ucmVtb3ZlTGF5ZXIodGhpcy5sYXllcik7XG4gICAgICB0aGlzLmxheWVyID0gdm9pZCAwO1xuICAgIH1cbiAgICBzdXBlci5fc2V0TGF5ZXJNYW5hZ2VyKGxheWVyc01hbmFnZXIpO1xuICB9XG4gIGdldFZpc2liaWxpdHkoKSB7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMudHJhdmVyc2VVcCh0cnVlKSkge1xuICAgICAgaWYgKCFub2RlLnZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0b1NWRygpIHtcbiAgICBpZiAoIXRoaXMudmlzaWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBkZWZzID0gW107XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4oKSkge1xuICAgICAgY29uc3Qgc3ZnID0gY2hpbGQudG9TVkcoKTtcbiAgICAgIGlmIChzdmcgIT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50cy5wdXNoKC4uLnN2Zy5lbGVtZW50cyk7XG4gICAgICAgIGlmIChzdmcuZGVmcyAhPSBudWxsKSB7XG4gICAgICAgICAgZGVmcy5wdXNoKC4uLnN2Zy5kZWZzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBlbGVtZW50cywgZGVmcyB9O1xuICB9XG59O1xuX0dyb3VwLmNsYXNzTmFtZSA9IFwiR3JvdXBcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgY29udmVydG9yOiAodikgPT4gY2xhbXAoMCwgdiwgMSkgfSlcbl0sIF9Hcm91cC5wcm90b3R5cGUsIFwib3BhY2l0eVwiLCAyKTtcbnZhciBHcm91cCA9IF9Hcm91cDtcbnZhciBTY2FsYWJsZUdyb3VwID0gY2xhc3MgZXh0ZW5kcyBTY2FsYWJsZShHcm91cCkge1xufTtcbnZhciBSb3RhdGFibGVHcm91cCA9IGNsYXNzIGV4dGVuZHMgUm90YXRhYmxlKEdyb3VwKSB7XG59O1xudmFyIFRyYW5zbGF0YWJsZUdyb3VwID0gY2xhc3MgZXh0ZW5kcyBUcmFuc2xhdGFibGUoR3JvdXApIHtcbn07XG52YXIgVHJhbnNmb3JtYWJsZUdyb3VwID0gY2xhc3MgZXh0ZW5kcyBSb3RhdGFibGUoVHJhbnNsYXRhYmxlKEdyb3VwKSkge1xufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9jYW52YXMudXRpbC50c1xuZnVuY3Rpb24gY3JlYXRlQ2FudmFzQ29udGV4dCh3aWR0aDIgPSAwLCBoZWlnaHQyID0gMCkge1xuICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aDIsIGhlaWdodDIpLmdldENvbnRleHQoXCIyZFwiKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9scnVDYWNoZS50c1xudmFyIExSVUNhY2hlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihtYXhDYWNoZVNpemUgPSA1KSB7XG4gICAgdGhpcy5tYXhDYWNoZVNpemUgPSBtYXhDYWNoZVNpemU7XG4gICAgdGhpcy5zdG9yZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0KGtleSkge1xuICAgIGlmICghdGhpcy5zdG9yZS5oYXMoa2V5KSlcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgaGl0ID0gdGhpcy5zdG9yZS5nZXQoa2V5KTtcbiAgICB0aGlzLnN0b3JlLmRlbGV0ZShrZXkpO1xuICAgIHRoaXMuc3RvcmUuc2V0KGtleSwgaGl0KTtcbiAgICByZXR1cm4gaGl0O1xuICB9XG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5oYXMoa2V5KTtcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuc3RvcmUuc2V0KGtleSwgdmFsdWUpO1xuICAgIGlmICh0aGlzLnN0b3JlLnNpemUgPiB0aGlzLm1heENhY2hlU2l6ZSkge1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLnN0b3JlLmtleXMoKTtcbiAgICAgIGxldCBldmljdENvdW50ID0gdGhpcy5zdG9yZS5zaXplIC0gdGhpcy5tYXhDYWNoZVNpemU7XG4gICAgICB3aGlsZSAoZXZpY3RDb3VudCA+IDApIHtcbiAgICAgICAgY29uc3QgZXZpY3RLZXlJdGVyYXRvciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKCFldmljdEtleUl0ZXJhdG9yLmRvbmUpIHtcbiAgICAgICAgICB0aGlzLnN0b3JlLmRlbGV0ZShldmljdEtleUl0ZXJhdG9yLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBldmljdENvdW50LS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLnN0b3JlLmNsZWFyKCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGV4dE1lYXN1cmVyLnRzXG52YXIgQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbCA9IGNsYXNzIHtcbiAgLy8gTWVhc3VyZXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHByb3ZpZGVkIHRleHQsIGhhbmRsaW5nIG11bHRpbGluZSBpZiBuZWVkZWQuXG4gIHN0YXRpYyBtZWFzdXJlVGV4dCh0ZXh0Miwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRleHRNZWFzdXJlciA9IHRoaXMuZ2V0TWVhc3VyZXIob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRleHRNZWFzdXJlci5tZWFzdXJlVGV4dCh0ZXh0Mik7XG4gIH1cbiAgc3RhdGljIG1lYXN1cmVMaW5lcyh0ZXh0Miwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRleHRNZWFzdXJlciA9IHRoaXMuZ2V0TWVhc3VyZXIob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRleHRNZWFzdXJlci5tZWFzdXJlTGluZXModGV4dDIpO1xuICB9XG4gIC8vIEdldHMgYSBUZXh0TWVhc3VyZXIgaW5zdGFuY2UsIGNvbmZpZ3VyaW5nIHRleHQgYWxpZ25tZW50IGFuZCBiYXNlbGluZSBpZiBwcm92aWRlZC5cbiAgc3RhdGljIGdldE1lYXN1cmVyKG9wdGlvbnMpIHtcbiAgICBjb25zdCBmb250MiA9IHR5cGVvZiBvcHRpb25zLmZvbnQgPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLmZvbnQgOiBUZXh0VXRpbHMudG9Gb250U3RyaW5nKG9wdGlvbnMuZm9udCk7XG4gICAgY29uc3Qga2V5ID0gYCR7Zm9udDJ9LSR7b3B0aW9ucy50ZXh0QWxpZ24gPz8gXCJzdGFydFwifS0ke29wdGlvbnMudGV4dEJhc2VsaW5lID8/IFwiYWxwaGFiZXRpY1wifWA7XG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VNYXAuZ2V0KGtleSkgPz8gdGhpcy5jcmVhdGVGb250TWVhc3VyZXIoZm9udDIsIG9wdGlvbnMsIGtleSk7XG4gIH1cbiAgLy8gQ3JlYXRlcyBvciByZXRyaWV2ZXMgYSBUZXh0TWVhc3VyZXIgaW5zdGFuY2UgZm9yIGEgc3BlY2lmaWMgZm9udC5cbiAgc3RhdGljIGNyZWF0ZUZvbnRNZWFzdXJlcihmb250Miwgb3B0aW9ucywga2V5KSB7XG4gICAgY29uc3QgY3R4ID0gY3JlYXRlQ2FudmFzQ29udGV4dCgpO1xuICAgIGN0eC5mb250ID0gZm9udDI7XG4gICAgY3R4LnRleHRBbGlnbiA9IG9wdGlvbnMudGV4dEFsaWduID8/IFwic3RhcnRcIjtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gb3B0aW9ucy50ZXh0QmFzZWxpbmUgPz8gXCJhbHBoYWJldGljXCI7XG4gICAgY29uc3QgbWVhc3VyZXIyID0gbmV3IENhY2hlZFRleHRNZWFzdXJlcihjdHgsIG9wdGlvbnMpO1xuICAgIHRoaXMuaW5zdGFuY2VNYXAuc2V0KGtleSwgbWVhc3VyZXIyKTtcbiAgICByZXR1cm4gbWVhc3VyZXIyO1xuICB9XG59O1xuQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5pbnN0YW5jZU1hcCA9IG5ldyBMUlVDYWNoZSgxMCk7XG52YXIgQ2FjaGVkVGV4dE1lYXN1cmVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjdHgsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAvLyBjYWNoZWQgdGV4dCBtZWFzdXJlbWVudHNcbiAgICB0aGlzLm1lYXN1cmVNYXAgPSBuZXcgTFJVQ2FjaGUoMTAwKTtcbiAgICBpZiAob3B0aW9ucy50ZXh0QWxpZ24pIHtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBvcHRpb25zLnRleHRBbGlnbjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudGV4dEJhc2VsaW5lKSB7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gb3B0aW9ucy50ZXh0QmFzZWxpbmU7XG4gICAgfVxuICAgIGN0eC5mb250ID0gdHlwZW9mIG9wdGlvbnMuZm9udCA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMuZm9udCA6IFRleHRVdGlscy50b0ZvbnRTdHJpbmcob3B0aW9ucy5mb250KTtcbiAgICB0aGlzLnRleHRNZWFzdXJlciA9IG5ldyBTaW1wbGVUZXh0TWVhc3VyZXIoXG4gICAgICAodCkgPT4gdGhpcy5jYWNoZWRDdHhNZWFzdXJlVGV4dCh0KSxcbiAgICAgIG9wdGlvbnMudGV4dEJhc2VsaW5lID8/IFwiYWxwaGFiZXRpY1wiXG4gICAgKTtcbiAgfVxuICB0ZXh0V2lkdGgodGV4dDIsIGVzdGltYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dE1lYXN1cmVyLnRleHRXaWR0aCh0ZXh0MiwgZXN0aW1hdGUpO1xuICB9XG4gIG1lYXN1cmVUZXh0KHRleHQyKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dE1lYXN1cmVyLm1lYXN1cmVUZXh0KHRleHQyKTtcbiAgfVxuICBtZWFzdXJlTGluZXModGV4dDIpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0TWVhc3VyZXIubWVhc3VyZUxpbmVzKHRleHQyKTtcbiAgfVxuICBjYWNoZWRDdHhNZWFzdXJlVGV4dCh0ZXh0Mikge1xuICAgIGlmICghdGhpcy5tZWFzdXJlTWFwLmhhcyh0ZXh0MikpIHtcbiAgICAgIGNvbnN0IHJhd1Jlc3VsdCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KHRleHQyKTtcbiAgICAgIHRoaXMubWVhc3VyZU1hcC5zZXQodGV4dDIsIHtcbiAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ6IHJhd1Jlc3VsdC5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCxcbiAgICAgICAgZW1IZWlnaHRBc2NlbnQ6IHJhd1Jlc3VsdC5lbUhlaWdodEFzY2VudCxcbiAgICAgICAgZW1IZWlnaHREZXNjZW50OiByYXdSZXN1bHQuZW1IZWlnaHREZXNjZW50LFxuICAgICAgICBhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ6IHJhd1Jlc3VsdC5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICAgIGFjdHVhbEJvdW5kaW5nQm94TGVmdDogcmF3UmVzdWx0LmFjdHVhbEJvdW5kaW5nQm94TGVmdCxcbiAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hSaWdodDogcmF3UmVzdWx0LmFjdHVhbEJvdW5kaW5nQm94UmlnaHQsXG4gICAgICAgIGFscGhhYmV0aWNCYXNlbGluZTogcmF3UmVzdWx0LmFscGhhYmV0aWNCYXNlbGluZSxcbiAgICAgICAgZm9udEJvdW5kaW5nQm94QXNjZW50OiByYXdSZXN1bHQuZm9udEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgICBmb250Qm91bmRpbmdCb3hEZXNjZW50OiByYXdSZXN1bHQuZm9udEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgICAgaGFuZ2luZ0Jhc2VsaW5lOiByYXdSZXN1bHQuaGFuZ2luZ0Jhc2VsaW5lLFxuICAgICAgICBpZGVvZ3JhcGhpY0Jhc2VsaW5lOiByYXdSZXN1bHQuaWRlb2dyYXBoaWNCYXNlbGluZSxcbiAgICAgICAgd2lkdGg6IHJhd1Jlc3VsdC53aWR0aFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lYXN1cmVNYXAuZ2V0KHRleHQyKTtcbiAgfVxufTtcbnZhciBUZXh0VXRpbHMgPSBjbGFzcyB7XG4gIHN0YXRpYyB0b0ZvbnRTdHJpbmcoeyBmb250U2l6ZSA9IDEwLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRGYW1pbHksIGxpbmVIZWlnaHQgfSkge1xuICAgIGxldCBmb250U3RyaW5nID0gXCJcIjtcbiAgICBpZiAoZm9udFN0eWxlKSB7XG4gICAgICBmb250U3RyaW5nICs9IGAke2ZvbnRTdHlsZX0gYDtcbiAgICB9XG4gICAgaWYgKGZvbnRXZWlnaHQpIHtcbiAgICAgIGZvbnRTdHJpbmcgKz0gYCR7Zm9udFdlaWdodH0gYDtcbiAgICB9XG4gICAgZm9udFN0cmluZyArPSBgJHtmb250U2l6ZX1weGA7XG4gICAgaWYgKGxpbmVIZWlnaHQpIHtcbiAgICAgIGZvbnRTdHJpbmcgKz0gYC8ke2xpbmVIZWlnaHR9cHhgO1xuICAgIH1cbiAgICBmb250U3RyaW5nICs9IGAgJHtmb250RmFtaWx5fWA7XG4gICAgcmV0dXJuIGZvbnRTdHJpbmcudHJpbSgpO1xuICB9XG4gIHN0YXRpYyBnZXRMaW5lSGVpZ2h0KGZvbnRTaXplKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbChmb250U2l6ZSAqIHRoaXMuZGVmYXVsdExpbmVIZWlnaHQpO1xuICB9XG4gIC8vIERldGVybWluZXMgdmVydGljYWwgb2Zmc2V0IG1vZGlmaWVyIGJhc2VkIG9uIHRleHQgYmFzZWxpbmUuXG4gIHN0YXRpYyBnZXRWZXJ0aWNhbE1vZGlmaWVyKHRleHRCYXNlbGluZSkge1xuICAgIHN3aXRjaCAodGV4dEJhc2VsaW5lKSB7XG4gICAgICBjYXNlIFwiaGFuZ2luZ1wiOlxuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGNhc2UgXCJtaWRkbGVcIjpcbiAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgIGNhc2UgXCJhbHBoYWJldGljXCI6XG4gICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICBjYXNlIFwiaWRlb2dyYXBoaWNcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxufTtcblRleHRVdGlscy5FbGxpcHNpc0NoYXIgPSBcIlxcdTIwMjZcIjtcbi8vIFJlcHJlc2VudGF0aW9uIGZvciB0ZXh0IGNsaXBwaW5nLlxuVGV4dFV0aWxzLmRlZmF1bHRMaW5lSGVpZ2h0ID0gMS4xNTtcbi8vIE5vcm1hbGx5IGJldHdlZW4gMS4xIGFuZCAxLjJcblRleHRVdGlscy5saW5lU3BsaXR0ZXIgPSAvXFxyP1xcbi9nO1xudmFyIFNpbXBsZVRleHRNZWFzdXJlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobWVhc3VyZVRleHRGbiwgdGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCIpIHtcbiAgICB0aGlzLm1lYXN1cmVUZXh0Rm4gPSBtZWFzdXJlVGV4dEZuO1xuICAgIHRoaXMudGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgIC8vIGxvY2FsIGNoYXJzIHdpZHRoIGNhY2hlIHBlciBUZXh0TWVhc3VyZXJcbiAgICB0aGlzLmNoYXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIC8vIE1lYXN1cmVzIG1ldHJpY3MgZm9yIGEgc2luZ2xlIGxpbmUgb2YgdGV4dC5cbiAgZ2V0TWV0cmljcyh0ZXh0Mikge1xuICAgIGNvbnN0IG0gPSB0aGlzLm1lYXN1cmVUZXh0Rm4odGV4dDIpO1xuICAgIG0uZm9udEJvdW5kaW5nQm94QXNjZW50ID8/IChtLmZvbnRCb3VuZGluZ0JveEFzY2VudCA9IG0uZW1IZWlnaHRBc2NlbnQpO1xuICAgIG0uZm9udEJvdW5kaW5nQm94RGVzY2VudCA/PyAobS5mb250Qm91bmRpbmdCb3hEZXNjZW50ID0gbS5lbUhlaWdodERlc2NlbnQpO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogbS53aWR0aCxcbiAgICAgIGhlaWdodDogbS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCArIG0uYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgbGluZUhlaWdodDogbS5mb250Qm91bmRpbmdCb3hBc2NlbnQgKyBtLmZvbnRCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICBvZmZzZXRUb3A6IG0uYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQsXG4gICAgICBvZmZzZXRMZWZ0OiBtLmFjdHVhbEJvdW5kaW5nQm94TGVmdFxuICAgIH07XG4gIH1cbiAgLy8gQ2FsY3VsYXRlcyBhZ2dyZWdhdGVkIG1ldHJpY3MgZm9yIG11bHRpbGluZSB0ZXh0LlxuICBnZXRNdWx0aWxpbmVNZXRyaWNzKGxpbmVzKSB7XG4gICAgbGV0IHdpZHRoMiA9IDA7XG4gICAgbGV0IGhlaWdodDIgPSAwO1xuICAgIGxldCBvZmZzZXRUb3AgPSAwO1xuICAgIGxldCBvZmZzZXRMZWZ0ID0gMDtcbiAgICBsZXQgYmFzZWxpbmVEaXN0YW5jZSA9IDA7XG4gICAgY29uc3QgdmVydGljYWxNb2RpZmllciA9IFRleHRVdGlscy5nZXRWZXJ0aWNhbE1vZGlmaWVyKHRoaXMudGV4dEJhc2VsaW5lKTtcbiAgICBjb25zdCBsaW5lTWV0cmljcyA9IFtdO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgbGVuZ3RoMiA9IGxpbmVzLmxlbmd0aDtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIGNvbnN0IG0gPSB0aGlzLm1lYXN1cmVUZXh0Rm4obGluZSk7XG4gICAgICBtLmZvbnRCb3VuZGluZ0JveEFzY2VudCA/PyAobS5mb250Qm91bmRpbmdCb3hBc2NlbnQgPSBtLmVtSGVpZ2h0QXNjZW50KTtcbiAgICAgIG0uZm9udEJvdW5kaW5nQm94RGVzY2VudCA/PyAobS5mb250Qm91bmRpbmdCb3hEZXNjZW50ID0gbS5lbUhlaWdodERlc2NlbnQpO1xuICAgICAgaWYgKHdpZHRoMiA8IG0ud2lkdGgpIHtcbiAgICAgICAgd2lkdGgyID0gbS53aWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXRMZWZ0IDwgbS5hY3R1YWxCb3VuZGluZ0JveExlZnQpIHtcbiAgICAgICAgb2Zmc2V0TGVmdCA9IG0uYWN0dWFsQm91bmRpbmdCb3hMZWZ0O1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIGhlaWdodDIgKz0gbS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcbiAgICAgICAgb2Zmc2V0VG9wICs9IG0uYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlbGluZURpc3RhbmNlICs9IG0uZm9udEJvdW5kaW5nQm94QXNjZW50O1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID09PSBsZW5ndGgyIC0gMSkge1xuICAgICAgICBoZWlnaHQyICs9IG0uYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZWxpbmVEaXN0YW5jZSArPSBtLmZvbnRCb3VuZGluZ0JveERlc2NlbnQ7XG4gICAgICB9XG4gICAgICBsaW5lTWV0cmljcy5wdXNoKHtcbiAgICAgICAgdGV4dDogbGluZSxcbiAgICAgICAgd2lkdGg6IG0ud2lkdGgsXG4gICAgICAgIGhlaWdodDogbS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCArIG0uYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgICBsaW5lSGVpZ2h0OiBtLmZvbnRCb3VuZGluZ0JveEFzY2VudCArIG0uZm9udEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgICAgb2Zmc2V0VG9wOiBtLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgICBvZmZzZXRMZWZ0OiBtLmFjdHVhbEJvdW5kaW5nQm94TGVmdFxuICAgICAgfSk7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgICBoZWlnaHQyICs9IGJhc2VsaW5lRGlzdGFuY2U7XG4gICAgb2Zmc2V0VG9wICs9IGJhc2VsaW5lRGlzdGFuY2UgKiB2ZXJ0aWNhbE1vZGlmaWVyO1xuICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0Miwgb2Zmc2V0VG9wLCBvZmZzZXRMZWZ0LCBsaW5lTWV0cmljcyB9O1xuICB9XG4gIHRleHRXaWR0aCh0ZXh0MiwgZXN0aW1hdGUpIHtcbiAgICBpZiAoZXN0aW1hdGUpIHtcbiAgICAgIGxldCBlc3RpbWF0ZWRXaWR0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVzdGltYXRlZFdpZHRoICs9IHRoaXMudGV4dFdpZHRoKHRleHQyLmNoYXJBdChpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXN0aW1hdGVkV2lkdGg7XG4gICAgfVxuICAgIGlmICh0ZXh0Mi5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZWFzdXJlVGV4dEZuKHRleHQyKS53aWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2hhck1hcC5nZXQodGV4dDIpID8/IHRoaXMuY2hhcldpZHRoKHRleHQyKTtcbiAgfVxuICBtZWFzdXJlVGV4dCh0ZXh0Mikge1xuICAgIHJldHVybiB0aGlzLmdldE1ldHJpY3ModGV4dDIpO1xuICB9XG4gIC8vIE1lYXN1cmVzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBwcm92aWRlZCB0ZXh0LCBoYW5kbGluZyBtdWx0aWxpbmUgaWYgbmVlZGVkLlxuICBtZWFzdXJlTGluZXModGV4dDIpIHtcbiAgICBjb25zdCBsaW5lcyA9IHR5cGVvZiB0ZXh0MiA9PT0gXCJzdHJpbmdcIiA/IHRleHQyLnNwbGl0KFRleHRVdGlscy5saW5lU3BsaXR0ZXIpIDogdGV4dDI7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TXVsdGlsaW5lTWV0cmljcyhsaW5lcyk7XG4gIH1cbiAgY2hhcldpZHRoKGNoYXIpIHtcbiAgICBjb25zdCB7IHdpZHRoOiB3aWR0aDIgfSA9IHRoaXMubWVhc3VyZVRleHRGbihjaGFyKTtcbiAgICB0aGlzLmNoYXJNYXAuc2V0KGNoYXIsIHdpZHRoMik7XG4gICAgcmV0dXJuIHdpZHRoMjtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvdGV4dC50c1xudmFyIF9UZXh0ID0gY2xhc3MgX1RleHQgZXh0ZW5kcyBTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICB0aGlzLnRleHQgPSB2b2lkIDA7XG4gICAgdGhpcy5mb250U2l6ZSA9IDEwO1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwic2Fucy1zZXJpZlwiO1xuICAgIHRoaXMudGV4dEFsaWduID0gX1RleHQuZGVmYXVsdFN0eWxlcy50ZXh0QWxpZ247XG4gICAgdGhpcy50ZXh0QmFzZWxpbmUgPSBfVGV4dC5kZWZhdWx0U3R5bGVzLnRleHRCYXNlbGluZTtcbiAgfVxuICBvblRleHRDaGFuZ2UoKSB7XG4gICAgdGhpcy5saW5lcyA9IHRoaXMudGV4dD8uc3BsaXQoXCJcXG5cIikubWFwKChzKSA9PiBzLnRyaW0oKSkgPz8gW107XG4gIH1cbiAgc3RhdGljIGNvbXB1dGVCQm94KGxpbmVzLCB4LCB5LCBvcHRzKSB7XG4gICAgY29uc3QgeyBvZmZzZXRUb3AsIG9mZnNldExlZnQsIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5tZWFzdXJlTGluZXMobGluZXMsIG9wdHMpO1xuICAgIHJldHVybiBuZXcgQkJveCh4IC0gb2Zmc2V0TGVmdCwgeSAtIG9mZnNldFRvcCwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBjb25zdCB7IHgsIHksIGxpbmVzLCB0ZXh0QmFzZWxpbmUsIHRleHRBbGlnbiB9ID0gdGhpcztcbiAgICByZXR1cm4gX1RleHQuY29tcHV0ZUJCb3gobGluZXMsIHgsIHksIHsgZm9udDogdGhpcywgdGV4dEJhc2VsaW5lLCB0ZXh0QWxpZ24gfSk7XG4gIH1cbiAgaXNQb2ludEluUGF0aCh4LCB5KSB7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgIHJldHVybiBiYm94ID8gYmJveC5jb250YWluc1BvaW50KHgsIHkpIDogZmFsc2U7XG4gIH1cbiAgcmVuZGVyKHJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgY3R4LCBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xuICAgIGlmICghdGhpcy5saW5lcy5sZW5ndGggfHwgIXRoaXMubGF5ZXJNYW5hZ2VyKSB7XG4gICAgICBpZiAoc3RhdHMpXG4gICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSAxO1xuICAgICAgcmV0dXJuIHN1cGVyLnJlbmRlcihyZW5kZXJDdHgpO1xuICAgIH1cbiAgICBjb25zdCB7IGZpbGwsIHN0cm9rZTogc3Ryb2tlMiwgc3Ryb2tlV2lkdGggfSA9IHRoaXM7XG4gICAgY29uc3QgeyBwaXhlbFJhdGlvIH0gPSB0aGlzLmxheWVyTWFuYWdlci5jYW52YXM7XG4gICAgY3R4LmZvbnQgPSBUZXh0VXRpbHMudG9Gb250U3RyaW5nKHRoaXMpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSB0aGlzLnRleHRBbGlnbjtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gdGhpcy50ZXh0QmFzZWxpbmU7XG4gICAgaWYgKGZpbGwpIHtcbiAgICAgIHRoaXMuYXBwbHlGaWxsKGN0eCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5ICogdGhpcy5maWxsT3BhY2l0eTtcbiAgICAgIGNvbnN0IHsgZmlsbFNoYWRvdyB9ID0gdGhpcztcbiAgICAgIGlmIChmaWxsU2hhZG93Py5lbmFibGVkKSB7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IGZpbGxTaGFkb3cuY29sb3I7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gZmlsbFNoYWRvdy54T2Zmc2V0ICogcGl4ZWxSYXRpbztcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSBmaWxsU2hhZG93LnlPZmZzZXQgKiBwaXhlbFJhdGlvO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IGZpbGxTaGFkb3cuYmx1ciAqIHBpeGVsUmF0aW87XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlckxpbmVzKChsaW5lLCB4LCB5KSA9PiBjdHguZmlsbFRleHQobGluZSwgeCwgeSkpO1xuICAgIH1cbiAgICBpZiAoc3Ryb2tlMiAmJiBzdHJva2VXaWR0aCkge1xuICAgICAgdGhpcy5hcHBseVN0cm9rZShjdHgpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0cm9rZVdpZHRoO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IHRoaXMub3BhY2l0eSAqIHRoaXMuc3Ryb2tlT3BhY2l0eTtcbiAgICAgIGNvbnN0IHsgbGluZURhc2gsIGxpbmVEYXNoT2Zmc2V0LCBsaW5lQ2FwLCBsaW5lSm9pbiB9ID0gdGhpcztcbiAgICAgIGlmIChsaW5lRGFzaCkge1xuICAgICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVEYXNoT2Zmc2V0KSB7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVDYXApIHtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSBsaW5lQ2FwO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVKb2luKSB7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IGxpbmVKb2luO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJMaW5lcygobGluZSwgeCwgeSkgPT4gY3R4LnN0cm9rZVRleHQobGluZSwgeCwgeSkpO1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgfVxuICByZW5kZXJMaW5lcyhyZW5kZXJDYWxsYmFjaykge1xuICAgIGNvbnN0IHsgbGluZXMsIHgsIHkgfSA9IHRoaXM7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodCA/PyBUZXh0VXRpbHMuZ2V0TGluZUhlaWdodCh0aGlzLmZvbnRTaXplKTtcbiAgICBsZXQgb2Zmc2V0WSA9IChsaW5lSGVpZ2h0IC0gbGluZUhlaWdodCAqIGxpbmVzLmxlbmd0aCkgKiBUZXh0VXRpbHMuZ2V0VmVydGljYWxNb2RpZmllcih0aGlzLnRleHRCYXNlbGluZSk7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICByZW5kZXJDYWxsYmFjayhsaW5lLCB4LCB5ICsgb2Zmc2V0WSk7XG4gICAgICBvZmZzZXRZICs9IGxpbmVIZWlnaHQ7XG4gICAgfVxuICB9XG4gIHNldEZvbnQocHJvcHMpIHtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBwcm9wcy5mb250RmFtaWx5O1xuICAgIHRoaXMuZm9udFNpemUgPSBwcm9wcy5mb250U2l6ZTtcbiAgICB0aGlzLmZvbnRTdHlsZSA9IHByb3BzLmZvbnRTdHlsZTtcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSBwcm9wcy5mb250V2VpZ2h0O1xuICB9XG4gIHNldEFsaWduKHByb3BzKSB7XG4gICAgdGhpcy50ZXh0QWxpZ24gPSBwcm9wcy50ZXh0QWxpZ247XG4gICAgdGhpcy50ZXh0QmFzZWxpbmUgPSBwcm9wcy50ZXh0QmFzZWxpbmU7XG4gIH1cbiAgdG9TVkcoKSB7XG4gICAgaWYgKCF0aGlzLnZpc2libGUgfHwgIXRoaXMudGV4dClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlbGVtZW50MiA9IGNyZWF0ZVN2Z0VsZW1lbnQoXCJ0ZXh0XCIpO1xuICAgIHRoaXMuYXBwbHlTdmdGaWxsQXR0cmlidXRlcyhlbGVtZW50Mik7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwiZm9udC1mYW1pbHlcIiwgdGhpcy5mb250RmFtaWx5Py5zcGxpdChcIixcIilbMF0gPz8gXCJcIik7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwiZm9udC1zaXplXCIsIFN0cmluZyh0aGlzLmZvbnRTaXplKSk7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwiZm9udC1zdHlsZVwiLCB0aGlzLmZvbnRTdHlsZSA/PyBcIlwiKTtcbiAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXCJmb250LXdlaWdodFwiLCBTdHJpbmcodGhpcy5mb250V2VpZ2h0ID8/IFwiXCIpKTtcbiAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcInRleHQtYW5jaG9yXCIsXG4gICAgICB7XG4gICAgICAgIGNlbnRlcjogXCJtaWRkbGVcIixcbiAgICAgICAgbGVmdDogXCJzdGFydFwiLFxuICAgICAgICByaWdodDogXCJlbmRcIixcbiAgICAgICAgc3RhcnQ6IFwic3RhcnRcIixcbiAgICAgICAgZW5kOiBcImVuZFwiXG4gICAgICB9W3RoaXMudGV4dEFsaWduID8/IFwic3RhcnRcIl1cbiAgICApO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYWxpZ25tZW50LWJhc2VsaW5lXCIsXG4gICAgICB7XG4gICAgICAgIGFscGhhYmV0aWM6IFwiYWxwaGFiZXRpY1wiLFxuICAgICAgICB0b3A6IFwidG9wXCIsXG4gICAgICAgIGJvdHRvbTogXCJib3R0b21cIixcbiAgICAgICAgaGFuZ2luZzogXCJoYW5naW5nXCIsXG4gICAgICAgIG1pZGRsZTogXCJtaWRkbGVcIixcbiAgICAgICAgaWRlb2dyYXBoaWM6IFwiaWRlb2dyYXBoaWNcIlxuICAgICAgfVt0aGlzLnRleHRCYXNlbGluZSA/PyBcImFscGhhYmV0aWNcIl1cbiAgICApO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcInhcIiwgU3RyaW5nKHRoaXMueCkpO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcInlcIiwgU3RyaW5nKHRoaXMueSkpO1xuICAgIGVsZW1lbnQyLnRleHRDb250ZW50ID0gdGhpcy50ZXh0ID8/IFwiXCI7XG4gICAgcmV0dXJuIHsgZWxlbWVudHM6IFtlbGVtZW50Ml0gfTtcbiAgfVxufTtcbl9UZXh0LmNsYXNzTmFtZSA9IFwiVGV4dFwiO1xuX1RleHQuZGVmYXVsdFN0eWxlcyA9IHtcbiAgLi4uU2hhcGUuZGVmYXVsdFN0eWxlcyxcbiAgdGV4dEFsaWduOiBcInN0YXJ0XCIsXG4gIGZvbnRTdHlsZTogdm9pZCAwLFxuICBmb250V2VpZ2h0OiB2b2lkIDAsXG4gIGZvbnRTaXplOiAxMCxcbiAgZm9udEZhbWlseTogXCJzYW5zLXNlcmlmXCIsXG4gIHRleHRCYXNlbGluZTogXCJhbHBoYWJldGljXCJcbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwieFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJ5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyBjaGFuZ2VDYjogKG8pID0+IG8ub25UZXh0Q2hhbmdlKCkgfSlcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJ0ZXh0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgX1RleHQucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgX1RleHQucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgX1RleHQucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwidGV4dEFsaWduXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgX1RleHQucHJvdG90eXBlLCBcInRleHRCYXNlbGluZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJsaW5lSGVpZ2h0XCIsIDIpO1xudmFyIFRleHQgPSBfVGV4dDtcbnZhciBSb3RhdGFibGVUZXh0ID0gY2xhc3MgZXh0ZW5kcyBSb3RhdGFibGUoVGV4dCkge1xufTtcbnZhciBUcmFuc2Zvcm1hYmxlVGV4dCA9IGNsYXNzIGV4dGVuZHMgUm90YXRhYmxlKFRyYW5zbGF0YWJsZShUZXh0KSkge1xufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9zdGF0ZU1hY2hpbmUudHNcbnZhciBkZWJ1Z0NvbG9yID0gXCJjb2xvcjogZ3JlZW5cIjtcbnZhciBkZWJ1Z1F1aWV0Q29sb3IgPSBcImNvbG9yOiBncmV5XCI7XG5mdW5jdGlvbiBTdGF0ZU1hY2hpbmVQcm9wZXJ0eSgpIHtcbiAgcmV0dXJuIGFkZE9ic2VydmVyVG9JbnN0YW5jZVByb3BlcnR5KCgpID0+IHtcbiAgfSk7XG59XG5mdW5jdGlvbiBhcHBseVByb3BlcnRpZXMocGFyZW50U3RhdGUsIGNoaWxkU3RhdGUpIHtcbiAgY29uc3QgY2hpbGRQcm9wZXJ0aWVzID0gbGlzdERlY29yYXRlZFByb3BlcnRpZXMoY2hpbGRTdGF0ZSk7XG4gIGlmIChjaGlsZFByb3BlcnRpZXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybjtcbiAgY29uc3QgcHJvcGVydGllcyA9IGV4dHJhY3REZWNvcmF0ZWRQcm9wZXJ0aWVzKHBhcmVudFN0YXRlKTtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBjaGlsZFByb3BlcnRpZXMpIHtcbiAgICBpZiAocHJvcGVydHkgaW4gcHJvcGVydGllcykge1xuICAgICAgY2hpbGRTdGF0ZVtwcm9wZXJ0eV0gPSBwcm9wZXJ0aWVzW3Byb3BlcnR5XTtcbiAgICB9XG4gIH1cbn1cbnZhciBBYnN0cmFjdFN0YXRlTWFjaGluZSA9IGNsYXNzIHtcbiAgdHJhbnNpdGlvblJvb3QoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnRyYW5zaXRpb25Sb290KGV2ZW50LCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKGV2ZW50LCBkYXRhKTtcbiAgICB9XG4gIH1cbn07XG52YXIgX1N0YXRlTWFjaGluZSA9IGNsYXNzIF9TdGF0ZU1hY2hpbmUgZXh0ZW5kcyBBYnN0cmFjdFN0YXRlTWFjaGluZSB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRTdGF0ZSwgc3RhdGVzLCBlbnRlckVhY2gpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0gZGVmYXVsdFN0YXRlO1xuICAgIHRoaXMuc3RhdGVzID0gc3RhdGVzO1xuICAgIHRoaXMuZW50ZXJFYWNoID0gZW50ZXJFYWNoO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJhbmltYXRpb25cIik7XG4gICAgdGhpcy5zdGF0ZSA9IGRlZmF1bHRTdGF0ZTtcbiAgICB0aGlzLmRlYnVnKGAlYyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSB8IGluaXQgLT4gJHtkZWZhdWx0U3RhdGV9YCwgZGVidWdDb2xvcik7XG4gIH1cbiAgLy8gVE9ETzogaGFuZGxlIGV2ZW50cyB3aGljaCBkbyBub3QgcmVxdWlyZSBkYXRhIHdpdGhvdXQgcmVxdWlyaW5nIGB1bmRlZmluZWRgIHRvIGJlIHBhc3NlZCBhcyBhcyBwYXJhbWV0ZXIsIHdoaWxlXG4gIC8vIGFsc28gc3RpbGwgcmVxdWlyaW5nIGRhdGEgdG8gYmUgcGFzc2VkIHRvIHRob3NlIGV2ZW50cyB3aGljaCBkbyByZXF1aXJlIGl0LlxuICB0cmFuc2l0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qgc2hvdWxkVHJhbnNpdGlvblNlbGYgPSB0aGlzLnRyYW5zaXRpb25DaGlsZChldmVudCwgZGF0YSk7XG4gICAgaWYgKCFzaG91bGRUcmFuc2l0aW9uU2VsZiB8fCB0aGlzLnN0YXRlID09PSBfU3RhdGVNYWNoaW5lLmNoaWxkIHx8IHRoaXMuc3RhdGUgPT09IF9TdGF0ZU1hY2hpbmUucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgY3VycmVudFN0YXRlQ29uZmlnID0gdGhpcy5zdGF0ZXNbdGhpcy5zdGF0ZV07XG4gICAgbGV0IGRlc3RpbmF0aW9uID0gY3VycmVudFN0YXRlQ29uZmlnW2V2ZW50XTtcbiAgICBjb25zdCBkZWJ1Z1ByZWZpeCA9IGAlYyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSB8ICR7dGhpcy5zdGF0ZX0gLT4gJHtldmVudH0gLT5gO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlc3RpbmF0aW9uKSkge1xuICAgICAgZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbi5maW5kKCh0cmFuc2l0aW9uKSA9PiB7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbi5ndWFyZClcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSB0cmFuc2l0aW9uLmd1YXJkKGRhdGEpO1xuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZyhgJHtkZWJ1Z1ByZWZpeH0gKGd1YXJkZWQpYCwgdHJhbnNpdGlvbi50YXJnZXQsIGRlYnVnUXVpZXRDb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdGluYXRpb24gPT09IFwib2JqZWN0XCIgJiYgIShkZXN0aW5hdGlvbiBpbnN0YW5jZW9mIF9TdGF0ZU1hY2hpbmUpICYmIGRlc3RpbmF0aW9uLmd1YXJkICYmICFkZXN0aW5hdGlvbi5ndWFyZChkYXRhKSkge1xuICAgICAgdGhpcy5kZWJ1ZyhgJHtkZWJ1Z1ByZWZpeH0gKGd1YXJkZWQpYCwgZGVzdGluYXRpb24udGFyZ2V0LCBkZWJ1Z1F1aWV0Q29sb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWRlc3RpbmF0aW9uKSB7XG4gICAgICB0aGlzLmRlYnVnKGAke2RlYnVnUHJlZml4fSAke3RoaXMuc3RhdGV9YCwgZGVidWdRdWlldENvbG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVzdGluYXRpb25TdGF0ZSA9IHRoaXMuZ2V0RGVzdGluYXRpb25TdGF0ZShkZXN0aW5hdGlvbik7XG4gICAgY29uc3QgZXhpdEZuID0gZGVzdGluYXRpb25TdGF0ZSA9PT0gdGhpcy5zdGF0ZSA/IHZvaWQgMCA6IGN1cnJlbnRTdGF0ZUNvbmZpZy5vbkV4aXQ7XG4gICAgdGhpcy5kZWJ1ZyhgJHtkZWJ1Z1ByZWZpeH0gJHtkZXN0aW5hdGlvblN0YXRlfWAsIGRlYnVnQ29sb3IpO1xuICAgIHRoaXMuc3RhdGUgPSBkZXN0aW5hdGlvblN0YXRlO1xuICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZGVzdGluYXRpb24oZGF0YSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdGluYXRpb24gPT09IFwib2JqZWN0XCIgJiYgIShkZXN0aW5hdGlvbiBpbnN0YW5jZW9mIF9TdGF0ZU1hY2hpbmUpKSB7XG4gICAgICBkZXN0aW5hdGlvbi5hY3Rpb24/LihkYXRhKTtcbiAgICB9XG4gICAgZXhpdEZuPy4oKTtcbiAgICB0aGlzLmVudGVyRWFjaD8uKGN1cnJlbnRTdGF0ZSwgZGVzdGluYXRpb25TdGF0ZSk7XG4gICAgaWYgKGRlc3RpbmF0aW9uU3RhdGUgIT09IGN1cnJlbnRTdGF0ZSAmJiBkZXN0aW5hdGlvblN0YXRlICE9PSBfU3RhdGVNYWNoaW5lLmNoaWxkICYmIGRlc3RpbmF0aW9uU3RhdGUgIT09IF9TdGF0ZU1hY2hpbmUucGFyZW50KSB7XG4gICAgICB0aGlzLnN0YXRlc1tkZXN0aW5hdGlvblN0YXRlXS5vbkVudGVyPy4oY3VycmVudFN0YXRlLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgdHJhbnNpdGlvbkFzeW5jKGV2ZW50LCBkYXRhKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24oZXZlbnQsIGRhdGEpO1xuICAgIH0sIDApO1xuICB9XG4gIGlzKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IF9TdGF0ZU1hY2hpbmUuY2hpbGQgJiYgdGhpcy5jaGlsZFN0YXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZFN0YXRlLmlzKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IHZhbHVlO1xuICB9XG4gIHJlc2V0SGllcmFyY2h5KCkge1xuICAgIHRoaXMuZGVidWcoXG4gICAgICBgJWMke3RoaXMuY29uc3RydWN0b3IubmFtZX0gfCAke3RoaXMuc3RhdGV9IC0+IFtyZXNldEhpZXJhcmNoeV0gLT4gJHt0aGlzLmRlZmF1bHRTdGF0ZX1gLFxuICAgICAgXCJjb2xvcjogZ3JlZW5cIlxuICAgICk7XG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuZGVmYXVsdFN0YXRlO1xuICB9XG4gIHRyYW5zaXRpb25DaGlsZChldmVudCwgZGF0YSkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBfU3RhdGVNYWNoaW5lLmNoaWxkIHx8ICF0aGlzLmNoaWxkU3RhdGUpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBhcHBseVByb3BlcnRpZXModGhpcywgdGhpcy5jaGlsZFN0YXRlKTtcbiAgICB0aGlzLmNoaWxkU3RhdGUudHJhbnNpdGlvbihldmVudCwgZGF0YSk7XG4gICAgaWYgKCF0aGlzLmNoaWxkU3RhdGUuaXMoX1N0YXRlTWFjaGluZS5wYXJlbnQpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgdGhpcy5kZWJ1ZyhgJWMke3RoaXMuY29uc3RydWN0b3IubmFtZX0gfCAke3RoaXMuc3RhdGV9IC0+ICR7ZXZlbnR9IC0+ICR7dGhpcy5kZWZhdWx0U3RhdGV9YCwgZGVidWdDb2xvcik7XG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuZGVmYXVsdFN0YXRlO1xuICAgIHRoaXMuc3RhdGVzW3RoaXMuc3RhdGVdLm9uRW50ZXI/LigpO1xuICAgIHRoaXMuY2hpbGRTdGF0ZS5yZXNldEhpZXJhcmNoeSgpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXREZXN0aW5hdGlvblN0YXRlKGRlc3RpbmF0aW9uKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzdGF0ZSA9IGRlc3RpbmF0aW9uO1xuICAgIH0gZWxzZSBpZiAoZGVzdGluYXRpb24gaW5zdGFuY2VvZiBfU3RhdGVNYWNoaW5lKSB7XG4gICAgICB0aGlzLmNoaWxkU3RhdGUgPSBkZXN0aW5hdGlvbjtcbiAgICAgIHRoaXMuY2hpbGRTdGF0ZS5wYXJlbnQgPSB0aGlzO1xuICAgICAgc3RhdGUgPSBfU3RhdGVNYWNoaW5lLmNoaWxkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3RpbmF0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoZGVzdGluYXRpb24udGFyZ2V0IGluc3RhbmNlb2YgX1N0YXRlTWFjaGluZSkge1xuICAgICAgICB0aGlzLmNoaWxkU3RhdGUgPSBkZXN0aW5hdGlvbi50YXJnZXQ7XG4gICAgICAgIHRoaXMuY2hpbGRTdGF0ZS5wYXJlbnQgPSB0aGlzO1xuICAgICAgICBzdGF0ZSA9IF9TdGF0ZU1hY2hpbmUuY2hpbGQ7XG4gICAgICB9IGVsc2UgaWYgKGRlc3RpbmF0aW9uLnRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgIHN0YXRlID0gZGVzdGluYXRpb24udGFyZ2V0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn07XG5fU3RhdGVNYWNoaW5lLmNoaWxkID0gXCJfX2NoaWxkXCI7XG5fU3RhdGVNYWNoaW5lLnBhcmVudCA9IFwiX19wYXJlbnRcIjtcbnZhciBTdGF0ZU1hY2hpbmUgPSBfU3RhdGVNYWNoaW5lO1xudmFyIFBhcmFsbGVsU3RhdGVNYWNoaW5lID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFN0YXRlTWFjaGluZSB7XG4gIGNvbnN0cnVjdG9yKC4uLnN0YXRlTWFjaGluZXMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc3RhdGVNYWNoaW5lcyA9IHN0YXRlTWFjaGluZXM7XG4gICAgZm9yIChjb25zdCBzdGF0ZU1hY2hpbmUgb2Ygc3RhdGVNYWNoaW5lcykge1xuICAgICAgc3RhdGVNYWNoaW5lLnBhcmVudCA9IHRoaXM7XG4gICAgfVxuICB9XG4gIHRyYW5zaXRpb24oZXZlbnQsIGRhdGEpIHtcbiAgICBmb3IgKGNvbnN0IHN0YXRlTWFjaGluZSBvZiB0aGlzLnN0YXRlTWFjaGluZXMpIHtcbiAgICAgIGFwcGx5UHJvcGVydGllcyh0aGlzLCBzdGF0ZU1hY2hpbmUpO1xuICAgICAgc3RhdGVNYWNoaW5lLnRyYW5zaXRpb24oZXZlbnQsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB0cmFuc2l0aW9uQXN5bmMoZXZlbnQsIGRhdGEpIHtcbiAgICBmb3IgKGNvbnN0IHN0YXRlTWFjaGluZSBvZiB0aGlzLnN0YXRlTWFjaGluZXMpIHtcbiAgICAgIGFwcGx5UHJvcGVydGllcyh0aGlzLCBzdGF0ZU1hY2hpbmUpO1xuICAgICAgc3RhdGVNYWNoaW5lLnRyYW5zaXRpb25Bc3luYyhldmVudCwgZGF0YSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3Byb3h5LnRzXG5mdW5jdGlvbiBQcm94eVByb3BlcnR5KHByb3h5UGF0aCwgY29uZmlnTWV0YWRhdGEpIHtcbiAgY29uc3QgcGF0aEFycmF5ID0gaXNBcnJheShwcm94eVBhdGgpID8gcHJveHlQYXRoIDogcHJveHlQYXRoLnNwbGl0KFwiLlwiKTtcbiAgaWYgKHBhdGhBcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBbcHJvcGVydHldID0gcGF0aEFycmF5O1xuICAgIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoXG4gICAgICAodGFyZ2V0LCBfLCB2YWx1ZSkgPT4gdGFyZ2V0W3Byb3BlcnR5XSA9IHZhbHVlLFxuICAgICAgKHRhcmdldCkgPT4gdGFyZ2V0W3Byb3BlcnR5XSxcbiAgICAgIGNvbmZpZ01ldGFkYXRhXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KFxuICAgICh0YXJnZXQsIF8sIHZhbHVlKSA9PiBzZXRQYXRoKHRhcmdldCwgcGF0aEFycmF5LCB2YWx1ZSksXG4gICAgKHRhcmdldCkgPT4gZ2V0UGF0aCh0YXJnZXQsIHBhdGhBcnJheSksXG4gICAgY29uZmlnTWV0YWRhdGFcbiAgKTtcbn1cbmZ1bmN0aW9uIFByb3h5T25Xcml0ZShwcm94eVByb3BlcnR5KSB7XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoKHRhcmdldCwgXywgdmFsdWUpID0+IHRhcmdldFtwcm94eVByb3BlcnR5XSA9IHZhbHVlKTtcbn1cbmZ1bmN0aW9uIFByb3h5UHJvcGVydHlPbldyaXRlKGNoaWxkTmFtZSwgY2hpbGRQcm9wZXJ0eSkge1xuICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KCh0YXJnZXQsIGtleSwgdmFsdWUpID0+IHRhcmdldFtjaGlsZE5hbWVdW2NoaWxkUHJvcGVydHkgPz8ga2V5XSA9IHZhbHVlKTtcbn1cbmZ1bmN0aW9uIEFjdGlvbk9uU2V0KG9wdHMpIHtcbiAgY29uc3QgeyBuZXdWYWx1ZTogbmV3VmFsdWVGbiwgb2xkVmFsdWU6IG9sZFZhbHVlRm4sIGNoYW5nZVZhbHVlOiBjaGFuZ2VWYWx1ZUZuIH0gPSBvcHRzO1xuICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KCh0YXJnZXQsIF8sIG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xuICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG9sZFZhbHVlRm4/LmNhbGwodGFyZ2V0LCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAobmV3VmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBuZXdWYWx1ZUZuPy5jYWxsKHRhcmdldCwgbmV3VmFsdWUpO1xuICAgICAgfVxuICAgICAgY2hhbmdlVmFsdWVGbj8uY2FsbCh0YXJnZXQsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBPYnNlcnZlQ2hhbmdlcyhvYnNlcnZlckZuKSB7XG4gIHJldHVybiBhZGRPYnNlcnZlclRvSW5zdGFuY2VQcm9wZXJ0eShvYnNlcnZlckZuKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90ZXh0V3JhcHBlci50c1xudmFyIFRleHRXcmFwcGVyID0gY2xhc3Mge1xuICBzdGF0aWMgd3JhcFRleHQodGV4dDIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwTGluZXModGV4dDIsIG9wdGlvbnMpLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgc3RhdGljIHdyYXBMaW5lcyh0ZXh0Miwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNsaXBwZWRSZXN1bHQgPSB0aGlzLnRleHRXcmFwKHRleHQyLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5vdmVyZmxvdyA9PT0gXCJoaWRlXCIgJiYgY2xpcHBlZFJlc3VsdC5zb21lKChsKSA9PiBsLmVuZHNXaXRoKFRleHRVdGlscy5FbGxpcHNpc0NoYXIpKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gY2xpcHBlZFJlc3VsdDtcbiAgfVxuICBzdGF0aWMgYXBwZW5kRWxsaXBzaXModGV4dDIpIHtcbiAgICByZXR1cm4gdGV4dDIucmVwbGFjZSgvWy4sXXsxLDV9JC8sIFwiXCIpICsgVGV4dFV0aWxzLkVsbGlwc2lzQ2hhcjtcbiAgfVxuICBzdGF0aWMgdHJ1bmNhdGVMaW5lKHRleHQyLCBtZWFzdXJlcjIsIG1heFdpZHRoLCBlbGxpcHNpc0ZvcmNlKSB7XG4gICAgY29uc3QgZWxsaXBzaXNXaWR0aCA9IG1lYXN1cmVyMi50ZXh0V2lkdGgoVGV4dFV0aWxzLkVsbGlwc2lzQ2hhcik7XG4gICAgbGV0IGVzdGltYXRlZFdpZHRoID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yICg7IGkgPCB0ZXh0Mi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhcldpZHRoID0gbWVhc3VyZXIyLnRleHRXaWR0aCh0ZXh0Mi5jaGFyQXQoaSkpO1xuICAgICAgaWYgKGVzdGltYXRlZFdpZHRoICsgY2hhcldpZHRoID4gbWF4V2lkdGgpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZXN0aW1hdGVkV2lkdGggKz0gY2hhcldpZHRoO1xuICAgIH1cbiAgICBpZiAodGV4dDIubGVuZ3RoID09PSBpICYmICghZWxsaXBzaXNGb3JjZSB8fCBlc3RpbWF0ZWRXaWR0aCArIGVsbGlwc2lzV2lkdGggPD0gbWF4V2lkdGgpKSB7XG4gICAgICByZXR1cm4gZWxsaXBzaXNGb3JjZSA/IHRleHQyICsgVGV4dFV0aWxzLkVsbGlwc2lzQ2hhciA6IHRleHQyO1xuICAgIH1cbiAgICB0ZXh0MiA9IHRleHQyLnNsaWNlKDAsIGkpLnRyaW1FbmQoKTtcbiAgICB3aGlsZSAodGV4dDIubGVuZ3RoICYmIG1lYXN1cmVyMi50ZXh0V2lkdGgodGV4dDIpICsgZWxsaXBzaXNXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICB0ZXh0MiA9IHRleHQyLnNsaWNlKDAsIC0xKS50cmltRW5kKCk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0MiArIFRleHRVdGlscy5FbGxpcHNpc0NoYXI7XG4gIH1cbiAgc3RhdGljIHRleHRXcmFwKHRleHQyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGluZXMgPSB0ZXh0Mi5zcGxpdChUZXh0VXRpbHMubGluZVNwbGl0dGVyKTtcbiAgICBjb25zdCBtZWFzdXJlcjIgPSBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLmdldE1lYXN1cmVyKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnRleHRXcmFwID09PSBcIm5ldmVyXCIpIHtcbiAgICAgIHJldHVybiBsaW5lcy5tYXAoKGxpbmUpID0+IHRoaXMudHJ1bmNhdGVMaW5lKGxpbmUudHJpbUVuZCgpLCBtZWFzdXJlcjIsIG9wdGlvbnMubWF4V2lkdGgpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3Qgd3JhcEh5cGhlbmF0ZSA9IG9wdGlvbnMudGV4dFdyYXAgPT09IFwiaHlwaGVuYXRlXCI7XG4gICAgY29uc3Qgd3JhcE9uU3BhY2UgPSBvcHRpb25zLnRleHRXcmFwID09IG51bGwgfHwgb3B0aW9ucy50ZXh0V3JhcCA9PT0gXCJvbi1zcGFjZVwiO1xuICAgIGZvciAoY29uc3QgdW50cmltbWVkTGluZSBvZiBsaW5lcykge1xuICAgICAgbGV0IGxpbmUgPSB1bnRyaW1tZWRMaW5lLnRyaW1FbmQoKTtcbiAgICAgIGlmIChsaW5lID09PSBcIlwiKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGxldCBlc3RpbWF0ZWRXaWR0aCA9IDA7XG4gICAgICBsZXQgbGFzdFNwYWNlSW5kZXggPSAwO1xuICAgICAgd2hpbGUgKGkgPCBsaW5lLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjaGFyID0gbGluZS5jaGFyQXQoaSk7XG4gICAgICAgIGVzdGltYXRlZFdpZHRoICs9IG1lYXN1cmVyMi50ZXh0V2lkdGgoY2hhcik7XG4gICAgICAgIGlmIChjaGFyID09PSBcIiBcIikge1xuICAgICAgICAgIGxhc3RTcGFjZUluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXN0aW1hdGVkV2lkdGggPiBvcHRpb25zLm1heFdpZHRoKSB7XG4gICAgICAgICAgaWYgKGkgPT09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjb25zdCBhY3R1YWxXaWR0aCA9IG1lYXN1cmVyMi50ZXh0V2lkdGgobGluZS5zbGljZSgwLCBpICsgMSkpO1xuICAgICAgICAgIGlmIChhY3R1YWxXaWR0aCA8PSBvcHRpb25zLm1heFdpZHRoKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZWRXaWR0aCA9IGFjdHVhbFdpZHRoO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsYXN0U3BhY2VJbmRleCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dFdvcmQgPSB0aGlzLmdldFdvcmRBdChsaW5lLCBsYXN0U3BhY2VJbmRleCArIDEpO1xuICAgICAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gbWVhc3VyZXIyLnRleHRXaWR0aChuZXh0V29yZCk7XG4gICAgICAgICAgICBpZiAodGV4dFdpZHRoIDw9IG9wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGluZS5zbGljZSgwLCBsYXN0U3BhY2VJbmRleCkudHJpbUVuZCgpKTtcbiAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UobGFzdFNwYWNlSW5kZXgpLnRyaW1TdGFydCgpO1xuICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgZXN0aW1hdGVkV2lkdGggPSAwO1xuICAgICAgICAgICAgICBsYXN0U3BhY2VJbmRleCA9IDA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3cmFwT25TcGFjZSAmJiB0ZXh0V2lkdGggPiBvcHRpb25zLm1heFdpZHRoKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICAgIGxpbmUuc2xpY2UoMCwgbGFzdFNwYWNlSW5kZXgpLnRyaW1FbmQoKSxcbiAgICAgICAgICAgICAgICB0aGlzLnRydW5jYXRlTGluZShcbiAgICAgICAgICAgICAgICAgIGxpbmUuc2xpY2UobGFzdFNwYWNlSW5kZXgpLnRyaW1TdGFydCgpLFxuICAgICAgICAgICAgICAgICAgbWVhc3VyZXIyLFxuICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tYXhXaWR0aCxcbiAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh3cmFwT25TcGFjZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy50cnVuY2F0ZUxpbmUobGluZSwgbWVhc3VyZXIyLCBvcHRpb25zLm1heFdpZHRoLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3cmFwT25TcGFjZSkge1xuICAgICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcG9zdGZpeCA9IHdyYXBIeXBoZW5hdGUgPyBcIi1cIiA6IFwiXCI7XG4gICAgICAgICAgbGV0IG5ld0xpbmUgPSBsaW5lLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgICAgICB3aGlsZSAobmV3TGluZS5sZW5ndGggJiYgbWVhc3VyZXIyLnRleHRXaWR0aChuZXdMaW5lICsgcG9zdGZpeCkgPiBvcHRpb25zLm1heFdpZHRoKSB7XG4gICAgICAgICAgICBuZXdMaW5lID0gbmV3TGluZS5zbGljZSgwLCAtMSkudHJpbUVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaChuZXdMaW5lICsgcG9zdGZpeCk7XG4gICAgICAgICAgaWYgKCFuZXdMaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UobmV3TGluZS5sZW5ndGgpLnRyaW1TdGFydCgpO1xuICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgICBlc3RpbWF0ZWRXaWR0aCA9IDA7XG4gICAgICAgICAgbGFzdFNwYWNlSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmF2b2lkT3JwaGFucyhyZXN1bHQsIG1lYXN1cmVyMiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY2xpcExpbmVzKHJlc3VsdCwgbWVhc3VyZXIyLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZ2V0V29yZEF0KHRleHQyLCBwb3NpdGlvbikge1xuICAgIGNvbnN0IG5leHRTcGFjZUluZGV4ID0gdGV4dDIuaW5kZXhPZihcIiBcIiwgcG9zaXRpb24pO1xuICAgIHJldHVybiBuZXh0U3BhY2VJbmRleCA9PT0gLTEgPyB0ZXh0Mi5zbGljZShwb3NpdGlvbikgOiB0ZXh0Mi5zbGljZShwb3NpdGlvbiwgbmV4dFNwYWNlSW5kZXgpO1xuICB9XG4gIHN0YXRpYyBjbGlwTGluZXMobGluZXMsIG1lYXN1cmVyMiwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5tYXhIZWlnaHQpIHtcbiAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG4gICAgY29uc3QgeyBoZWlnaHQ6IGhlaWdodDIsIGxpbmVNZXRyaWNzIH0gPSBtZWFzdXJlcjIubWVhc3VyZUxpbmVzKGxpbmVzKTtcbiAgICBpZiAoaGVpZ2h0MiA8PSBvcHRpb25zLm1heEhlaWdodCkge1xuICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgY3VtdWxhdGl2ZUhlaWdodCA9IDA7IGkgPCBsaW5lTWV0cmljcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeyBsaW5lSGVpZ2h0IH0gPSBsaW5lTWV0cmljc1tpXTtcbiAgICAgIGN1bXVsYXRpdmVIZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgIGlmIChjdW11bGF0aXZlSGVpZ2h0ID4gb3B0aW9ucy5tYXhIZWlnaHQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3ZlcmZsb3cgPT09IFwiaGlkZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaXBwZWRSZXN1bHRzID0gbGluZXMuc2xpY2UoMCwgaSB8fCAxKTtcbiAgICAgICAgY29uc3QgbGFzdExpbmUgPSBjbGlwcGVkUmVzdWx0cy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIGNsaXBwZWRSZXN1bHRzLmNvbmNhdCh0aGlzLnRydW5jYXRlTGluZShsYXN0TGluZSwgbWVhc3VyZXIyLCBvcHRpb25zLm1heFdpZHRoLCB0cnVlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuICBzdGF0aWMgYXZvaWRPcnBoYW5zKGxpbmVzLCBtZWFzdXJlcjIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5hdm9pZE9ycGhhbnMgPT09IGZhbHNlIHx8IGxpbmVzLmxlbmd0aCA8IDIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBsZW5ndGg6IGxlbmd0aDIgfSA9IGxpbmVzO1xuICAgIGNvbnN0IGxhc3RMaW5lID0gbGluZXNbbGVuZ3RoMiAtIDFdO1xuICAgIGNvbnN0IGJlZm9yZUxhc3QgPSBsaW5lc1tsZW5ndGgyIC0gMl07XG4gICAgaWYgKGJlZm9yZUxhc3QubGVuZ3RoIDwgbGFzdExpbmUubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGxhc3RTcGFjZUluZGV4ID0gYmVmb3JlTGFzdC5sYXN0SW5kZXhPZihcIiBcIik7XG4gICAgaWYgKGxhc3RTcGFjZUluZGV4ID09PSAtMSB8fCBsYXN0U3BhY2VJbmRleCA9PT0gYmVmb3JlTGFzdC5pbmRleE9mKFwiIFwiKSB8fCBsYXN0TGluZS5pbmNsdWRlcyhcIiBcIikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbGFzdFdvcmQgPSBiZWZvcmVMYXN0LnNsaWNlKGxhc3RTcGFjZUluZGV4ICsgMSk7XG4gICAgaWYgKG1lYXN1cmVyMi50ZXh0V2lkdGgobGFzdExpbmUgKyBsYXN0V29yZCkgPD0gb3B0aW9ucy5tYXhXaWR0aCkge1xuICAgICAgbGluZXNbbGVuZ3RoMiAtIDJdID0gYmVmb3JlTGFzdC5zbGljZSgwLCBsYXN0U3BhY2VJbmRleCk7XG4gICAgICBsaW5lc1tsZW5ndGgyIC0gMV0gPSBsYXN0V29yZCArIFwiIFwiICsgbGFzdExpbmU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jYXB0aW9uLnRzXG52YXIgQ2FwdGlvbiA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLm5vZGUgPSBuZXcgUm90YXRhYmxlVGV4dCh7IHpJbmRleDogMSB9KS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgIHBvaW50ZXJFdmVudHM6IDEgLyogTm9uZSAqL1xuICAgIH0pO1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICB0aGlzLmZvbnRTaXplID0gMTA7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJzYW5zLXNlcmlmXCI7XG4gICAgdGhpcy53cmFwcGluZyA9IFwiYWx3YXlzXCI7XG4gICAgdGhpcy5wYWRkaW5nID0gMDtcbiAgICB0aGlzLmxheW91dFN0eWxlID0gXCJibG9ja1wiO1xuICAgIHRoaXMudHJ1bmNhdGVkID0gZmFsc2U7XG4gIH1cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbihtb2R1bGVDdHgsIHdoZXJlKSB7XG4gICAgcmV0dXJuIG1vZHVsZUN0eC5sYXlvdXRNYW5hZ2VyLmFkZExpc3RlbmVyKFwibGF5b3V0OmNvbXBsZXRlXCIsICgpID0+IHRoaXMudXBkYXRlQTExeVRleHQobW9kdWxlQ3R4LCB3aGVyZSkpO1xuICB9XG4gIGNvbXB1dGVUZXh0V3JhcChjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0KSB7XG4gICAgY29uc3QgeyB0ZXh0OiB0ZXh0MiwgcGFkZGluZywgd3JhcHBpbmcgfSA9IHRoaXM7XG4gICAgY29uc3QgbWF4V2lkdGggPSBNYXRoLm1pbih0aGlzLm1heFdpZHRoID8/IEluZmluaXR5LCBjb250YWluZXJXaWR0aCkgLSBwYWRkaW5nICogMjtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSB0aGlzLm1heEhlaWdodCA/PyBjb250YWluZXJIZWlnaHQgLSBwYWRkaW5nICogMjtcbiAgICBpZiAoIWlzRmluaXRlKG1heFdpZHRoKSAmJiAhaXNGaW5pdGUobWF4SGVpZ2h0KSkge1xuICAgICAgdGhpcy5ub2RlLnRleHQgPSB0ZXh0MjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd3JhcHBlZFRleHQgPSBUZXh0V3JhcHBlci53cmFwVGV4dCh0ZXh0MiA/PyBcIlwiLCB7IG1heFdpZHRoLCBtYXhIZWlnaHQsIGZvbnQ6IHRoaXMsIHRleHRXcmFwOiB3cmFwcGluZyB9KTtcbiAgICB0aGlzLm5vZGUudGV4dCA9IHdyYXBwZWRUZXh0O1xuICAgIHRoaXMudHJ1bmNhdGVkID0gd3JhcHBlZFRleHQuaW5jbHVkZXMoVGV4dFV0aWxzLkVsbGlwc2lzQ2hhcik7XG4gIH1cbiAgdXBkYXRlQTExeVRleHQobW9kdWxlQ3R4LCB3aGVyZSkge1xuICAgIGNvbnN0IHsgcHJveHlJbnRlcmFjdGlvblNlcnZpY2UgfSA9IG1vZHVsZUN0eDtcbiAgICBpZiAodGhpcy5lbmFibGVkICYmIHRoaXMudGV4dCkge1xuICAgICAgY29uc3QgYmJveCA9IFRyYW5zZm9ybWFibGUudG9DYW52YXModGhpcy5ub2RlKTtcbiAgICAgIGlmIChiYm94KSB7XG4gICAgICAgIGNvbnN0IHsgaWQ6IGRvbU1hbmFnZXJJZCB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5wcm94eVRleHQgPz8gKHRoaXMucHJveHlUZXh0ID0gcHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlFbGVtZW50KHsgdHlwZTogXCJ0ZXh0XCIsIGRvbU1hbmFnZXJJZCwgd2hlcmUgfSkpO1xuICAgICAgICB0aGlzLnByb3h5VGV4dC50ZXh0Q29udGVudCA9IHRoaXMudGV4dDtcbiAgICAgICAgdGhpcy5wcm94eVRleHQuc2V0Qm91bmRzKGJib3gpO1xuICAgICAgICB0aGlzLnByb3h5VGV4dC5hZGRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCAoZXYpID0+IHRoaXMuaGFuZGxlTW91c2VNb3ZlKG1vZHVsZUN0eCwgZXYpKTtcbiAgICAgICAgdGhpcy5wcm94eVRleHQuYWRkTGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIChldikgPT4gdGhpcy5oYW5kbGVNb3VzZUxlYXZlKG1vZHVsZUN0eCwgZXYpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm94eVRleHQ/LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMucHJveHlUZXh0ID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBoYW5kbGVNb3VzZU1vdmUobW9kdWxlQ3R4LCBldmVudCkge1xuICAgIGlmIChldmVudCAhPSBudWxsICYmIHRoaXMuZW5hYmxlZCAmJiB0aGlzLm5vZGUudmlzaWJsZSAmJiB0aGlzLnRydW5jYXRlZCkge1xuICAgICAgY29uc3QgeyB4LCB5IH0gPSBUcmFuc2Zvcm1hYmxlLnRvQ2FudmFzKHRoaXMubm9kZSk7XG4gICAgICBjb25zdCBjYW52YXNYID0gZXZlbnQuc291cmNlRXZlbnQub2Zmc2V0WCArIHg7XG4gICAgICBjb25zdCBjYW52YXNZID0gZXZlbnQuc291cmNlRXZlbnQub2Zmc2V0WSArIHk7XG4gICAgICBjb25zdCBsYXN0UG9pbnRlckV2ZW50ID0geyB0eXBlOiBcInBvaW50ZXJtb3ZlXCIsIGNhbnZhc1gsIGNhbnZhc1kgfTtcbiAgICAgIG1vZHVsZUN0eC50b29sdGlwTWFuYWdlci51cGRhdGVUb29sdGlwKFxuICAgICAgICB0aGlzLmlkLFxuICAgICAgICB7IGNhbnZhc1gsIGNhbnZhc1ksIGxhc3RQb2ludGVyRXZlbnQsIHNob3dBcnJvdzogZmFsc2UgfSxcbiAgICAgICAgeyB0eXBlOiBcInN0cnVjdHVyZWRcIiwgdGl0bGU6IHRoaXMudGV4dCB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuICBoYW5kbGVNb3VzZUxlYXZlKG1vZHVsZUN0eCwgX2V2ZW50KSB7XG4gICAgbW9kdWxlQ3R4LnRvb2x0aXBNYW5hZ2VyLnJlbW92ZVRvb2x0aXAodGhpcy5pZCk7XG4gIH1cbn07XG5DYXB0aW9uLlNNQUxMX1BBRERJTkcgPSAxMDtcbkNhcHRpb24uTEFSR0VfUEFERElORyA9IDIwO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiLCBcInZpc2libGVcIilcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFRFWFRfQUxJR04sIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwidGV4dEFsaWduXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9TVFlMRSwgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1dFSUdIVCwgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORyksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIsIFwiZmlsbFwiKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcIm1heFdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJtYXhIZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShURVhUX1dSQVApXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJ3cmFwcGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJsYXlvdXRTdHlsZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY2hhcnRBeGlzRGlyZWN0aW9uLnRzXG52YXIgQ2hhcnRBeGlzRGlyZWN0aW9uID0gLyogQF9fUFVSRV9fICovICgoQ2hhcnRBeGlzRGlyZWN0aW9uMikgPT4ge1xuICBDaGFydEF4aXNEaXJlY3Rpb24yW1wiWFwiXSA9IFwieFwiO1xuICBDaGFydEF4aXNEaXJlY3Rpb24yW1wiWVwiXSA9IFwieVwiO1xuICByZXR1cm4gQ2hhcnRBeGlzRGlyZWN0aW9uMjtcbn0pKENoYXJ0QXhpc0RpcmVjdGlvbiB8fCB7fSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vZHVsZS9tb2R1bGVNYXAudHNcbnZhciBNb2R1bGVNYXAgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubW9kdWxlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICAqbW9kdWxlcygpIHtcbiAgICBmb3IgKGNvbnN0IG0gb2YgdGhpcy5tb2R1bGVNYXAudmFsdWVzKCkpIHtcbiAgICAgIHlpZWxkIG0ubW9kdWxlSW5zdGFuY2U7XG4gICAgfVxuICB9XG4gIGFkZE1vZHVsZShtb2R1bGUsIG1vZHVsZUZhY3RvcnkpIHtcbiAgICBpZiAodGhpcy5tb2R1bGVNYXAuaGFzKG1vZHVsZS5vcHRpb25zS2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBtb2R1bGUgYWxyZWFkeSBpbml0aWFsaXNlZDogJHttb2R1bGUub3B0aW9uc0tleX1gKTtcbiAgICB9XG4gICAgdGhpcy5tb2R1bGVNYXAuc2V0KG1vZHVsZS5vcHRpb25zS2V5LCB7IG1vZHVsZSwgbW9kdWxlSW5zdGFuY2U6IG1vZHVsZUZhY3RvcnkobW9kdWxlKSB9KTtcbiAgfVxuICByZW1vdmVNb2R1bGUobW9kdWxlKSB7XG4gICAgY29uc3QgbW9kdWxlS2V5ID0gaXNTdHJpbmcobW9kdWxlKSA/IG1vZHVsZSA6IG1vZHVsZS5vcHRpb25zS2V5O1xuICAgIHRoaXMubW9kdWxlTWFwLmdldChtb2R1bGVLZXkpPy5tb2R1bGVJbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgdGhpcy5tb2R1bGVNYXAuZGVsZXRlKG1vZHVsZUtleSk7XG4gIH1cbiAgZ2V0TW9kdWxlKG1vZHVsZSkge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZU1hcC5nZXQoaXNTdHJpbmcobW9kdWxlKSA/IG1vZHVsZSA6IG1vZHVsZS5vcHRpb25zS2V5KT8ubW9kdWxlSW5zdGFuY2U7XG4gIH1cbiAgaXNFbmFibGVkKG1vZHVsZSkge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZU1hcC5oYXMoaXNTdHJpbmcobW9kdWxlKSA/IG1vZHVsZSA6IG1vZHVsZS5vcHRpb25zS2V5KTtcbiAgfVxuICBtYXBNb2R1bGVzKGNhbGxiYWNrMikge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubW9kdWxlTWFwLnZhbHVlcygpLCAobSwgaSkgPT4gY2FsbGJhY2syKG0ubW9kdWxlSW5zdGFuY2UsIGkpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgbW9kdWxlS2V5IG9mIHRoaXMubW9kdWxlTWFwLmtleXMoKSkge1xuICAgICAgdGhpcy5tb2R1bGVNYXAuZ2V0KG1vZHVsZUtleSk/Lm1vZHVsZUluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5tb2R1bGVNYXAuY2xlYXIoKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9kYXRlLnRzXG5mdW5jdGlvbiBjb21wYXJlRGF0ZXMoYSwgYikge1xuICByZXR1cm4gYS52YWx1ZU9mKCkgLSBiLnZhbHVlT2YoKTtcbn1cbmZ1bmN0aW9uIGRlZHVwbGljYXRlU29ydGVkQXJyYXkodmFsdWVzKSB7XG4gIGxldCB2MCA9IE5hTjtcbiAgY29uc3Qgb3V0ID0gW107XG4gIGZvciAoY29uc3QgdiBvZiB2YWx1ZXMpIHtcbiAgICBjb25zdCB2MSA9IHYudmFsdWVPZigpO1xuICAgIGlmICh2MCAhPT0gdjEpXG4gICAgICBvdXQucHVzaCh2KTtcbiAgICB2MCA9IHYxO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBzb3J0QW5kVW5pcXVlRGF0ZXModmFsdWVzKSB7XG4gIGNvbnN0IHNvcnRlZFZhbHVlcyA9IHZhbHVlcy5zbGljZSgpLnNvcnQoY29tcGFyZURhdGVzKTtcbiAgcmV0dXJuIGRhdGVzU29ydE9yZGVyKHNvcnRlZFZhbHVlcykgPT0gbnVsbCA/IGRlZHVwbGljYXRlU29ydGVkQXJyYXkoc29ydGVkVmFsdWVzKSA6IHNvcnRlZFZhbHVlcztcbn1cbmZ1bmN0aW9uIGRhdGVzU29ydE9yZGVyKGQpIHtcbiAgaWYgKGQubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiAxO1xuICBjb25zdCBzaWduID0gTnVtYmVyKGRbZC5sZW5ndGggLSAxXSkgPiBOdW1iZXIoZFswXSkgPyAxIDogLTE7XG4gIGxldCB2MCA9IC1JbmZpbml0eSAqIHNpZ247XG4gIGZvciAoY29uc3QgdiBvZiBkKSB7XG4gICAgY29uc3QgdjEgPSB2LnZhbHVlT2YoKTtcbiAgICBpZiAoTWF0aC5zaWduKHYxIC0gdjApICE9PSBzaWduKVxuICAgICAgcmV0dXJuO1xuICAgIHYwID0gdjE7XG4gIH1cbiAgcmV0dXJuIHNpZ247XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvbnVtYmVyRm9ybWF0LnRzXG5mdW5jdGlvbiBwYXJzZUZvcm1hdChmb3JtYXQpIHtcbiAgbGV0IHByZWZpeDtcbiAgbGV0IHN1ZmZpeDtcbiAgY29uc3Qgc3Vycm91bmRlZCA9IHN1cnJvdW5kZWRSZWdFeC5leGVjKGZvcm1hdCk7XG4gIGlmIChzdXJyb3VuZGVkKSB7XG4gICAgWywgcHJlZml4LCBmb3JtYXQsIHN1ZmZpeF0gPSBzdXJyb3VuZGVkO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gZm9ybWF0UmVnRXguZXhlYyhmb3JtYXQpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbnVtYmVyIGZvcm1hdHRlciBpcyBpbnZhbGlkOiAke2Zvcm1hdH1gKTtcbiAgfVxuICBjb25zdCBbLCBmaWxsLCBhbGlnbjIsIHNpZ24sIHN5bWJvbCwgemVybywgd2lkdGgyLCBjb21tYSwgcHJlY2lzaW9uLCB0cmltLCB0eXBlXSA9IG1hdGNoO1xuICByZXR1cm4ge1xuICAgIGZpbGwsXG4gICAgYWxpZ246IGFsaWduMixcbiAgICBzaWduLFxuICAgIHN5bWJvbCxcbiAgICB6ZXJvLFxuICAgIHdpZHRoOiBwYXJzZUludCh3aWR0aDIpLFxuICAgIGNvbW1hLFxuICAgIHByZWNpc2lvbjogcGFyc2VJbnQocHJlY2lzaW9uKSxcbiAgICB0cmltOiBCb29sZWFuKHRyaW0pLFxuICAgIHR5cGUsXG4gICAgcHJlZml4LFxuICAgIHN1ZmZpeFxuICB9O1xufVxuZnVuY3Rpb24gbnVtYmVyRm9ybWF0KGZvcm1hdCkge1xuICBjb25zdCBvcHRpb25zID0gdHlwZW9mIGZvcm1hdCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlRm9ybWF0KGZvcm1hdCkgOiBmb3JtYXQ7XG4gIGNvbnN0IHsgZmlsbCwgYWxpZ246IGFsaWduMiwgc2lnbiA9IFwiLVwiLCBzeW1ib2wsIHplcm8sIHdpZHRoOiB3aWR0aDIsIGNvbW1hLCB0eXBlLCBwcmVmaXggPSBcIlwiLCBzdWZmaXggPSBcIlwiLCBwcmVjaXNpb24gfSA9IG9wdGlvbnM7XG4gIGxldCB7IHRyaW0gfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHByZWNpc2lvbklzTmFOID0gcHJlY2lzaW9uID09IG51bGwgfHwgaXNOYU4ocHJlY2lzaW9uKTtcbiAgbGV0IGZvcm1hdEJvZHk7XG4gIGlmICghdHlwZSkge1xuICAgIGZvcm1hdEJvZHkgPSBkZWNpbWFsVHlwZXNbXCJnXCJdO1xuICAgIHRyaW0gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHR5cGUgaW4gZGVjaW1hbFR5cGVzICYmIHR5cGUgaW4gaW50ZWdlclR5cGVzKSB7XG4gICAgZm9ybWF0Qm9keSA9IHByZWNpc2lvbklzTmFOID8gaW50ZWdlclR5cGVzW3R5cGVdIDogZGVjaW1hbFR5cGVzW3R5cGVdO1xuICB9IGVsc2UgaWYgKHR5cGUgaW4gZGVjaW1hbFR5cGVzKSB7XG4gICAgZm9ybWF0Qm9keSA9IGRlY2ltYWxUeXBlc1t0eXBlXTtcbiAgfSBlbHNlIGlmICh0eXBlIGluIGludGVnZXJUeXBlcykge1xuICAgIGZvcm1hdEJvZHkgPSBpbnRlZ2VyVHlwZXNbdHlwZV07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbnVtYmVyIGZvcm1hdHRlciB0eXBlIGlzIGludmFsaWQ6ICR7dHlwZX1gKTtcbiAgfVxuICBsZXQgZm9ybWF0dGVyUHJlY2lzaW9uO1xuICBpZiAocHJlY2lzaW9uID09IG51bGwgfHwgcHJlY2lzaW9uSXNOYU4pIHtcbiAgICBmb3JtYXR0ZXJQcmVjaXNpb24gPSB0eXBlID8gNiA6IDEyO1xuICB9IGVsc2Uge1xuICAgIGZvcm1hdHRlclByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgfVxuICByZXR1cm4gKG4pID0+IHtcbiAgICBsZXQgcmVzdWx0ID0gZm9ybWF0Qm9keShuLCBmb3JtYXR0ZXJQcmVjaXNpb24pO1xuICAgIGlmICh0cmltKSB7XG4gICAgICByZXN1bHQgPSByZW1vdmVUcmFpbGluZ1plcm9zKHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChjb21tYSkge1xuICAgICAgcmVzdWx0ID0gaW5zZXJ0U2VwYXJhdG9yKHJlc3VsdCwgY29tbWEpO1xuICAgIH1cbiAgICByZXN1bHQgPSBhZGRTaWduKG4sIHJlc3VsdCwgc2lnbik7XG4gICAgaWYgKHN5bWJvbCAmJiBzeW1ib2wgIT09IFwiI1wiKSB7XG4gICAgICByZXN1bHQgPSBgJHtzeW1ib2x9JHtyZXN1bHR9YDtcbiAgICB9XG4gICAgaWYgKHN5bWJvbCA9PT0gXCIjXCIgJiYgdHlwZSA9PT0gXCJ4XCIpIHtcbiAgICAgIHJlc3VsdCA9IGAweCR7cmVzdWx0fWA7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcInNcIikge1xuICAgICAgcmVzdWx0ID0gYCR7cmVzdWx0fSR7Z2V0U0lQcmVmaXgobil9YDtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiJVwiIHx8IHR5cGUgPT09IFwicFwiKSB7XG4gICAgICByZXN1bHQgPSBgJHtyZXN1bHR9JWA7XG4gICAgfVxuICAgIGlmICh3aWR0aDIgIT0gbnVsbCAmJiAhaXNOYU4od2lkdGgyKSkge1xuICAgICAgcmVzdWx0ID0gYWRkUGFkZGluZyhyZXN1bHQsIHdpZHRoMiwgZmlsbCA/PyB6ZXJvLCBhbGlnbjIpO1xuICAgIH1cbiAgICByZXN1bHQgPSBgJHtwcmVmaXh9JHtyZXN1bHR9JHtzdWZmaXh9YDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxudmFyIGZvcm1hdFJlZ0V4ID0gL14oPzooLik/KFs8Pj1eXSkpPyhbK1xcLSggXSk/KFsk4oKswqPCpeKCo+KCuSNdKT8oMCk/KFxcZCspPygsKT8oPzpcXC4oXFxkKykpPyh+KT8oWyVhLXpdKT8kL2k7XG52YXIgc3Vycm91bmRlZFJlZ0V4ID0gL14oKD86W14jXXwjW157XSkqKSN7KFtefV0rKX0oLiopJC87XG52YXIgaW50ZWdlclR5cGVzID0ge1xuICBiOiAobikgPT4gYWJzRmxvb3IobikudG9TdHJpbmcoMiksXG4gIGM6IChuKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKG4pLFxuICBkOiAobikgPT4gTWF0aC5yb3VuZChNYXRoLmFicyhuKSkudG9GaXhlZCgwKSxcbiAgbzogKG4pID0+IGFic0Zsb29yKG4pLnRvU3RyaW5nKDgpLFxuICB4OiAobikgPT4gYWJzRmxvb3IobikudG9TdHJpbmcoMTYpLFxuICBYOiAobikgPT4gaW50ZWdlclR5cGVzLngobikudG9VcHBlckNhc2UoKSxcbiAgbjogKG4pID0+IGludGVnZXJUeXBlcy5kKG4pLFxuICBcIiVcIjogKG4pID0+IGAke2Fic0Zsb29yKG4gKiAxMDApLnRvRml4ZWQoMCl9YFxufTtcbnZhciBkZWNpbWFsVHlwZXMgPSB7XG4gIGU6IChuLCBmKSA9PiBNYXRoLmFicyhuKS50b0V4cG9uZW50aWFsKGYpLFxuICBFOiAobiwgZikgPT4gZGVjaW1hbFR5cGVzLmUobiwgZikudG9VcHBlckNhc2UoKSxcbiAgZjogKG4sIGYpID0+IE1hdGguYWJzKG4pLnRvRml4ZWQoZiksXG4gIEY6IChuLCBmKSA9PiBkZWNpbWFsVHlwZXMuZihuLCBmKS50b1VwcGVyQ2FzZSgpLFxuICBnOiAobiwgZikgPT4ge1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICByZXR1cm4gXCIwXCI7XG4gICAgfVxuICAgIGNvbnN0IGEgPSBNYXRoLmFicyhuKTtcbiAgICBjb25zdCBwID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKGEpKTtcbiAgICBpZiAocCA+PSAtNCAmJiBwIDwgZikge1xuICAgICAgcmV0dXJuIGEudG9GaXhlZChmIC0gMSAtIHApO1xuICAgIH1cbiAgICByZXR1cm4gYS50b0V4cG9uZW50aWFsKGYgLSAxKTtcbiAgfSxcbiAgRzogKG4sIGYpID0+IGRlY2ltYWxUeXBlcy5nKG4sIGYpLnRvVXBwZXJDYXNlKCksXG4gIG46IChuLCBmKSA9PiBkZWNpbWFsVHlwZXMuZyhuLCBmKSxcbiAgcDogKG4sIGYpID0+IGRlY2ltYWxUeXBlcy5yKG4gKiAxMDAsIGYpLFxuICByOiAobiwgZikgPT4ge1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICByZXR1cm4gXCIwXCI7XG4gICAgfVxuICAgIGNvbnN0IGEgPSBNYXRoLmFicyhuKTtcbiAgICBjb25zdCBwID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKGEpKTtcbiAgICBjb25zdCBxID0gcCAtIChmIC0gMSk7XG4gICAgaWYgKHEgPD0gMCkge1xuICAgICAgcmV0dXJuIGEudG9GaXhlZCgtcSk7XG4gICAgfVxuICAgIGNvbnN0IHggPSAxMCAqKiBxO1xuICAgIHJldHVybiAoTWF0aC5yb3VuZChhIC8geCkgKiB4KS50b0ZpeGVkKCk7XG4gIH0sXG4gIHM6IChuLCBmKSA9PiB7XG4gICAgY29uc3QgcCA9IGdldFNJUHJlZml4UG93ZXIobik7XG4gICAgcmV0dXJuIGRlY2ltYWxUeXBlcy5yKG4gLyAxMCAqKiBwLCBmKTtcbiAgfSxcbiAgXCIlXCI6IChuLCBmKSA9PiBkZWNpbWFsVHlwZXMuZihuICogMTAwLCBmKVxufTtcbnZhciBtaW5TSVByZWZpeCA9IC0yNDtcbnZhciBtYXhTSVByZWZpeCA9IDI0O1xudmFyIHNpUHJlZml4ZXMgPSB7XG4gIFttaW5TSVByZWZpeF06IFwieVwiLFxuICBbLTIxXTogXCJ6XCIsXG4gIFstMThdOiBcImFcIixcbiAgWy0xNV06IFwiZlwiLFxuICBbLTEyXTogXCJwXCIsXG4gIFstOV06IFwiblwiLFxuICBbLTZdOiBcIlxceEI1XCIsXG4gIFstM106IFwibVwiLFxuICBbMF06IFwiXCIsXG4gIFszXTogXCJrXCIsXG4gIFs2XTogXCJNXCIsXG4gIFs5XTogXCJHXCIsXG4gIFsxMl06IFwiVFwiLFxuICBbMTVdOiBcIlBcIixcbiAgWzE4XTogXCJFXCIsXG4gIFsyMV06IFwiWlwiLFxuICBbbWF4U0lQcmVmaXhdOiBcIllcIlxufTtcbnZhciBtaW51c1NpZ24gPSBcIlxcdTIyMTJcIjtcbmZ1bmN0aW9uIGFic0Zsb29yKG4pIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xufVxuZnVuY3Rpb24gcmVtb3ZlVHJhaWxpbmdaZXJvcyhudW1TdHJpbmcpIHtcbiAgcmV0dXJuIG51bVN0cmluZy5yZXBsYWNlKC9cXC4wKyQvLCBcIlwiKS5yZXBsYWNlKC8oXFwuWzEtOV0pMCskLywgXCIkMVwiKTtcbn1cbmZ1bmN0aW9uIGluc2VydFNlcGFyYXRvcihudW1TdHJpbmcsIHNlcGFyYXRvcikge1xuICBsZXQgZG90SW5kZXggPSBudW1TdHJpbmcuaW5kZXhPZihcIi5cIik7XG4gIGlmIChkb3RJbmRleCA8IDApIHtcbiAgICBkb3RJbmRleCA9IG51bVN0cmluZy5sZW5ndGg7XG4gIH1cbiAgY29uc3QgaW50ZWdlckNoYXJzID0gbnVtU3RyaW5nLnN1YnN0cmluZygwLCBkb3RJbmRleCkuc3BsaXQoXCJcIik7XG4gIGNvbnN0IGZyYWN0aW9uYWxQYXJ0ID0gbnVtU3RyaW5nLnN1YnN0cmluZyhkb3RJbmRleCk7XG4gIGZvciAobGV0IGkgPSBpbnRlZ2VyQ2hhcnMubGVuZ3RoIC0gMzsgaSA+IDA7IGkgLT0gMykge1xuICAgIGludGVnZXJDaGFycy5zcGxpY2UoaSwgMCwgc2VwYXJhdG9yKTtcbiAgfVxuICByZXR1cm4gYCR7aW50ZWdlckNoYXJzLmpvaW4oXCJcIil9JHtmcmFjdGlvbmFsUGFydH1gO1xufVxuZnVuY3Rpb24gZ2V0U0lQcmVmaXgobikge1xuICByZXR1cm4gc2lQcmVmaXhlc1tnZXRTSVByZWZpeFBvd2VyKG4pXTtcbn1cbmZ1bmN0aW9uIGdldFNJUHJlZml4UG93ZXIobikge1xuICByZXR1cm4gY2xhbXAobWluU0lQcmVmaXgsIG4gPyBNYXRoLmZsb29yKE1hdGgubG9nMTAoTWF0aC5hYnMobikpIC8gMykgKiAzIDogMCwgbWF4U0lQcmVmaXgpO1xufVxuZnVuY3Rpb24gYWRkU2lnbihudW0sIG51bVN0cmluZywgc2lnblR5cGUgPSBcIlwiKSB7XG4gIGlmIChzaWduVHlwZSA9PT0gXCIoXCIpIHtcbiAgICByZXR1cm4gbnVtID49IDAgPyBudW1TdHJpbmcgOiBgKCR7bnVtU3RyaW5nfSlgO1xuICB9XG4gIGNvbnN0IHBsdXNTaWduID0gc2lnblR5cGUgPT09IFwiK1wiID8gXCIrXCIgOiBcIlwiO1xuICByZXR1cm4gYCR7bnVtID49IDAgPyBwbHVzU2lnbiA6IG1pbnVzU2lnbn0ke251bVN0cmluZ31gO1xufVxuZnVuY3Rpb24gYWRkUGFkZGluZyhudW1TdHJpbmcsIHdpZHRoMiwgZmlsbCA9IFwiIFwiLCBhbGlnbjIgPSBcIj5cIikge1xuICBsZXQgcmVzdWx0ID0gbnVtU3RyaW5nO1xuICBpZiAoYWxpZ24yID09PSBcIj5cIiB8fCAhYWxpZ24yKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnBhZFN0YXJ0KHdpZHRoMiwgZmlsbCk7XG4gIH0gZWxzZSBpZiAoYWxpZ24yID09PSBcIjxcIikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5wYWRFbmQod2lkdGgyLCBmaWxsKTtcbiAgfSBlbHNlIGlmIChhbGlnbjIgPT09IFwiXlwiKSB7XG4gICAgY29uc3QgcGFkV2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aDIgLSByZXN1bHQubGVuZ3RoKTtcbiAgICBjb25zdCBwYWRMZWZ0ID0gTWF0aC5jZWlsKHBhZFdpZHRoIC8gMik7XG4gICAgY29uc3QgcGFkUmlnaHQgPSBNYXRoLmZsb29yKHBhZFdpZHRoIC8gMik7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnBhZFN0YXJ0KHBhZExlZnQgKyByZXN1bHQubGVuZ3RoLCBmaWxsKTtcbiAgICByZXN1bHQgPSByZXN1bHQucGFkRW5kKHBhZFJpZ2h0ICsgcmVzdWx0Lmxlbmd0aCwgZmlsbCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aWNrcy50c1xudmFyIHRJbnRlcnZhbCA9ICh0aW1lSW50ZXJ2YWwsIGJhc2VEdXJhdGlvbiwgc3RlcCkgPT4gKHtcbiAgZHVyYXRpb246IGJhc2VEdXJhdGlvbiAqIHN0ZXAsXG4gIHRpbWVJbnRlcnZhbCxcbiAgc3RlcFxufSk7XG52YXIgVGlja0ludGVydmFscyA9IFtcbiAgdEludGVydmFsKHNlY29uZCwgZHVyYXRpb25TZWNvbmQsIDEpLFxuICB0SW50ZXJ2YWwoc2Vjb25kLCBkdXJhdGlvblNlY29uZCwgNSksXG4gIHRJbnRlcnZhbChzZWNvbmQsIGR1cmF0aW9uU2Vjb25kLCAxNSksXG4gIHRJbnRlcnZhbChzZWNvbmQsIGR1cmF0aW9uU2Vjb25kLCAzMCksXG4gIHRJbnRlcnZhbChtaW51dGUsIGR1cmF0aW9uTWludXRlLCAxKSxcbiAgdEludGVydmFsKG1pbnV0ZSwgZHVyYXRpb25NaW51dGUsIDUpLFxuICB0SW50ZXJ2YWwobWludXRlLCBkdXJhdGlvbk1pbnV0ZSwgMTUpLFxuICB0SW50ZXJ2YWwobWludXRlLCBkdXJhdGlvbk1pbnV0ZSwgMzApLFxuICB0SW50ZXJ2YWwoaG91ciwgZHVyYXRpb25Ib3VyLCAxKSxcbiAgdEludGVydmFsKGhvdXIsIGR1cmF0aW9uSG91ciwgMyksXG4gIHRJbnRlcnZhbChob3VyLCBkdXJhdGlvbkhvdXIsIDYpLFxuICB0SW50ZXJ2YWwoaG91ciwgZHVyYXRpb25Ib3VyLCAxMiksXG4gIHRJbnRlcnZhbChkYXksIGR1cmF0aW9uRGF5LCAxKSxcbiAgdEludGVydmFsKGRheSwgZHVyYXRpb25EYXksIDIpLFxuICB0SW50ZXJ2YWwoc3VuZGF5LCBkdXJhdGlvbldlZWssIDEpLFxuICB0SW50ZXJ2YWwoc3VuZGF5LCBkdXJhdGlvbldlZWssIDIpLFxuICB0SW50ZXJ2YWwoc3VuZGF5LCBkdXJhdGlvbldlZWssIDMpLFxuICB0SW50ZXJ2YWwobW9udGgsIGR1cmF0aW9uTW9udGgsIDEpLFxuICB0SW50ZXJ2YWwobW9udGgsIGR1cmF0aW9uTW9udGgsIDIpLFxuICB0SW50ZXJ2YWwobW9udGgsIGR1cmF0aW9uTW9udGgsIDMpLFxuICB0SW50ZXJ2YWwobW9udGgsIGR1cmF0aW9uTW9udGgsIDQpLFxuICB0SW50ZXJ2YWwobW9udGgsIGR1cmF0aW9uTW9udGgsIDYpLFxuICB0SW50ZXJ2YWwoeWVhciwgZHVyYXRpb25ZZWFyLCAxKVxuXTtcbnZhciBUaWNrTXVsdGlwbGllcnMgPSBbMSwgMiwgNSwgMTBdO1xuZnVuY3Rpb24gaXNDbG9zZVRvSW50ZWdlcihuLCBkZWx0YTMpIHtcbiAgcmV0dXJuIE1hdGguYWJzKE1hdGgucm91bmQobikgLSBuKSA8IGRlbHRhMztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRpY2tzKHN0YXJ0Miwgc3RvcCwgY291bnQsIG1pbkNvdW50LCBtYXhDb3VudCwgdmlzaWJsZVJhbmdlKSB7XG4gIGlmIChjb3VudCA8IDIpIHtcbiAgICByZXR1cm4gW3N0YXJ0Miwgc3RvcF07XG4gIH1cbiAgY29uc3Qgc3RlcCA9IHRpY2tTdGVwKHN0YXJ0Miwgc3RvcCwgY291bnQsIG1pbkNvdW50LCBtYXhDb3VudCk7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKHN0ZXApKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghaXNDbG9zZVRvSW50ZWdlcihzdGFydDIgLyBzdGVwLCAxZS0xMikpIHtcbiAgICBzdGFydDIgPSBNYXRoLmNlaWwoc3RhcnQyIC8gc3RlcCkgKiBzdGVwO1xuICB9XG4gIGlmICghaXNDbG9zZVRvSW50ZWdlcihzdG9wIC8gc3RlcCwgMWUtMTIpKSB7XG4gICAgc3RvcCA9IE1hdGguZmxvb3Ioc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgfVxuICBpZiAodmlzaWJsZVJhbmdlICE9IG51bGwgJiYgdmlzaWJsZVJhbmdlWzBdICE9PSAwICYmIHZpc2libGVSYW5nZVsxXSAhPT0gMSkge1xuICAgIGNvbnN0IHJhbmdlRXh0ZW50ID0gc3RvcCAtIHN0YXJ0MjtcbiAgICBjb25zdCBhZGp1c3RlZFN0YXJ0ID0gc3RhcnQyICsgcmFuZ2VFeHRlbnQgKiB2aXNpYmxlUmFuZ2VbMF07XG4gICAgY29uc3QgYWRqdXN0ZWRFbmQgPSBzdG9wIC0gcmFuZ2VFeHRlbnQgKiAoMSAtIHZpc2libGVSYW5nZVsxXSk7XG4gICAgcmV0dXJuIHJhbmdlKGFkanVzdGVkU3RhcnQgLSBhZGp1c3RlZFN0YXJ0ICUgc3RlcCwgYWRqdXN0ZWRFbmQgKyBhZGp1c3RlZEVuZCAlIHN0ZXAsIHN0ZXApO1xuICB9XG4gIHJldHVybiByYW5nZShzdGFydDIsIHN0b3AsIHN0ZXApO1xufVxuZnVuY3Rpb24gZ2V0VGlja0ludGVydmFsKHN0YXJ0Miwgc3RvcCwgY291bnQsIG1pbkNvdW50LCBtYXhDb3VudCwgdGFyZ2V0SW50ZXJ2YWwpIHtcbiAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0SW50ZXJ2YWwgPz8gTWF0aC5hYnMoc3RvcCAtIHN0YXJ0MikgLyBNYXRoLm1heChjb3VudCwgMSk7XG4gIGxldCBpID0gMDtcbiAgZm9yIChjb25zdCB0aWNrSW50ZXJ2YWwgb2YgVGlja0ludGVydmFscykge1xuICAgIGlmICh0YXJnZXQgPD0gdGlja0ludGVydmFsLmR1cmF0aW9uKVxuICAgICAgYnJlYWs7XG4gICAgaSsrO1xuICB9XG4gIGlmIChpID09PSAwKSB7XG4gICAgY29uc3Qgc3RlcDIgPSBNYXRoLm1heCh0aWNrU3RlcChzdGFydDIsIHN0b3AsIGNvdW50LCBtaW5Db3VudCwgbWF4Q291bnQpLCAxKTtcbiAgICByZXR1cm4gbWlsbGlzZWNvbmQuZXZlcnkoc3RlcDIpO1xuICB9IGVsc2UgaWYgKGkgPT09IFRpY2tJbnRlcnZhbHMubGVuZ3RoKSB7XG4gICAgY29uc3Qgc3RlcDIgPSB0YXJnZXRJbnRlcnZhbCA9PSBudWxsID8gdGlja1N0ZXAoc3RhcnQyIC8gZHVyYXRpb25ZZWFyLCBzdG9wIC8gZHVyYXRpb25ZZWFyLCBjb3VudCwgbWluQ291bnQsIG1heENvdW50KSA6IDE7XG4gICAgcmV0dXJuIHllYXIuZXZlcnkoc3RlcDIpO1xuICB9XG4gIGNvbnN0IGkwID0gVGlja0ludGVydmFsc1tpIC0gMV07XG4gIGNvbnN0IGkxID0gVGlja0ludGVydmFsc1tpXTtcbiAgY29uc3QgeyB0aW1lSW50ZXJ2YWwsIHN0ZXAgfSA9IHRhcmdldCAtIGkwLmR1cmF0aW9uIDwgaTEuZHVyYXRpb24gLSB0YXJnZXQgPyBpMCA6IGkxO1xuICByZXR1cm4gdGltZUludGVydmFsLmV2ZXJ5KHN0ZXApO1xufVxuZnVuY3Rpb24gdGlja1N0ZXAoc3RhcnQyLCBlbmQyLCBjb3VudCwgbWluQ291bnQgPSAwLCBtYXhDb3VudCA9IEluZmluaXR5KSB7XG4gIGlmIChzdGFydDIgPT09IGVuZDIpIHtcbiAgICByZXR1cm4gY2xhbXAoMSwgbWluQ291bnQsIG1heENvdW50KTtcbiAgfSBlbHNlIGlmIChjb3VudCA8IDEpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIGNvbnN0IGV4dGVudDIgPSBNYXRoLmFicyhlbmQyIC0gc3RhcnQyKTtcbiAgY29uc3Qgc3RlcCA9IDEwICoqIE1hdGguZmxvb3IoTWF0aC5sb2cxMChleHRlbnQyIC8gY291bnQpKTtcbiAgbGV0IG0gPSBOYU4sIG1pbkRpZmYgPSBJbmZpbml0eSwgaXNJbkJvdW5kcyA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IG11bHRpcGxpZXIgb2YgVGlja011bHRpcGxpZXJzKSB7XG4gICAgY29uc3QgYyA9IE1hdGguY2VpbChleHRlbnQyIC8gKG11bHRpcGxpZXIgKiBzdGVwKSk7XG4gICAgY29uc3QgdmFsaWRCb3VuZHMgPSBjID49IG1pbkNvdW50ICYmIGMgPD0gbWF4Q291bnQ7XG4gICAgaWYgKGlzSW5Cb3VuZHMgJiYgIXZhbGlkQm91bmRzKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgZGlmZkNvdW50ID0gTWF0aC5hYnMoYyAtIGNvdW50KTtcbiAgICBpZiAobWluRGlmZiA+IGRpZmZDb3VudCB8fCBpc0luQm91bmRzICE9PSB2YWxpZEJvdW5kcykge1xuICAgICAgaXNJbkJvdW5kcyB8fCAoaXNJbkJvdW5kcyA9IHZhbGlkQm91bmRzKTtcbiAgICAgIG1pbkRpZmYgPSBkaWZmQ291bnQ7XG4gICAgICBtID0gbXVsdGlwbGllcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG0gKiBzdGVwO1xufVxuZnVuY3Rpb24gZGVjaW1hbFBsYWNlcyhkZWNpbWFsKSB7XG4gIGZvciAobGV0IGkgPSBkZWNpbWFsLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgaWYgKGRlY2ltYWxbaV0gIT09IFwiMFwiKSB7XG4gICAgICByZXR1cm4gaSArIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gdGlja0Zvcm1hdCh0aWNrcywgZm9ybWF0KSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBwYXJzZUZvcm1hdChmb3JtYXQgPz8gXCIsZlwiKTtcbiAgaWYgKG9wdGlvbnMucHJlY2lzaW9uID09IG51bGwgfHwgaXNOYU4ob3B0aW9ucy5wcmVjaXNpb24pKSB7XG4gICAgaWYgKCFvcHRpb25zLnR5cGUgfHwgXCJlRUZnR25wcnNcIi5pbmNsdWRlcyhvcHRpb25zLnR5cGUpKSB7XG4gICAgICBvcHRpb25zLnByZWNpc2lvbiA9IE1hdGgubWF4KFxuICAgICAgICAuLi50aWNrcy5tYXAoKHgpID0+IHtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIGNvbnN0IFtpbnRlZ2VyLCBkZWNpbWFsXSA9IHgudG9FeHBvbmVudGlhbCgob3B0aW9ucy50eXBlID8gNiA6IDEyKSAtIDEpLnNwbGl0KC9bLmVdL2cpO1xuICAgICAgICAgIHJldHVybiAoaW50ZWdlciAhPT0gXCIxXCIgJiYgaW50ZWdlciAhPT0gXCItMVwiID8gMSA6IDApICsgZGVjaW1hbFBsYWNlcyhkZWNpbWFsKSArIDE7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoXCJmJVwiLmluY2x1ZGVzKG9wdGlvbnMudHlwZSkpIHtcbiAgICAgIG9wdGlvbnMucHJlY2lzaW9uID0gTWF0aC5tYXgoXG4gICAgICAgIC4uLnRpY2tzLm1hcCgoeCkgPT4ge1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpIHx8IHggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICBjb25zdCBsID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKE1hdGguYWJzKHgpKSk7XG4gICAgICAgICAgY29uc3QgZGlnaXRzID0gb3B0aW9ucy50eXBlID8gNiA6IDEyO1xuICAgICAgICAgIGNvbnN0IGRlY2ltYWwgPSB4LnRvRXhwb25lbnRpYWwoZGlnaXRzIC0gMSkuc3BsaXQoL1suZV0vZylbMV07XG4gICAgICAgICAgY29uc3QgZGVjaW1hbExlbmd0aCA9IGRlY2ltYWxQbGFjZXMoZGVjaW1hbCk7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGRlY2ltYWxMZW5ndGggLSBsKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZvcm1hdHRlciA9IG51bWJlckZvcm1hdChvcHRpb25zKTtcbiAgcmV0dXJuIChuKSA9PiBmb3JtYXR0ZXIoTnVtYmVyKG4pKTtcbn1cbmZ1bmN0aW9uIHJhbmdlKHN0YXJ0MiwgZW5kMiwgc3RlcCkge1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZShzdGVwKSB8fCBzdGVwIDw9IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgZiA9IDEwICoqIGNvdW50RnJhY3Rpb25EaWdpdHMoc3RlcCk7XG4gIGNvbnN0IGQwID0gTWF0aC5taW4oc3RhcnQyLCBlbmQyKTtcbiAgY29uc3QgZDEgPSBNYXRoLm1heChzdGFydDIsIGVuZDIpO1xuICBjb25zdCBvdXQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IDsgaSArPSAxKSB7XG4gICAgY29uc3QgcCA9IE1hdGgucm91bmQoKGQwICsgc3RlcCAqIGkpICogZikgLyBmO1xuICAgIGlmIChwID4gZDEpXG4gICAgICBicmVhaztcbiAgICBvdXQucHVzaChwKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gaXNEZW5zZUludGVydmFsKGNvdW50LCBhdmFpbGFibGVSYW5nZSkge1xuICBpZiAoY291bnQgPj0gYXZhaWxhYmxlUmFuZ2UpIHtcbiAgICBsb2dnZXJfZXhwb3J0cy53YXJuT25jZShcbiAgICAgIGB0aGUgY29uZmlndXJlZCBpbnRlcnZhbCByZXN1bHRzIGluIG1vcmUgdGhhbiAxIGl0ZW0gcGVyIHBpeGVsLCBpZ25vcmluZy4gU3VwcGx5IGEgbGFyZ2VyIGludGVydmFsIG9yIG9taXQgdGhpcyBjb25maWd1cmF0aW9uYFxuICAgICk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbmljZVRpY2tzRG9tYWluKHN0YXJ0MiwgZW5kMikge1xuICBjb25zdCBleHRlbnQyID0gTWF0aC5hYnMoZW5kMiAtIHN0YXJ0Mik7XG4gIGNvbnN0IHN0ZXAgPSAxMCAqKiBNYXRoLmZsb29yKE1hdGgubG9nMTAoZXh0ZW50MikpO1xuICBsZXQgbWluRXJyb3IgPSBJbmZpbml0eSwgdGlja3MgPSBbc3RhcnQyLCBlbmQyXTtcbiAgZm9yIChjb25zdCBtdWx0aXBsaWVyIG9mIFRpY2tNdWx0aXBsaWVycykge1xuICAgIGNvbnN0IG0gPSBtdWx0aXBsaWVyICogc3RlcDtcbiAgICBjb25zdCBkMCA9IE1hdGguZmxvb3Ioc3RhcnQyIC8gbSkgKiBtO1xuICAgIGNvbnN0IGQxID0gTWF0aC5jZWlsKGVuZDIgLyBtKSAqIG07XG4gICAgY29uc3QgZXJyb3IyID0gMSAtIGV4dGVudDIgLyBNYXRoLmFicyhkMSAtIGQwKTtcbiAgICBpZiAobWluRXJyb3IgPiBlcnJvcjIpIHtcbiAgICAgIG1pbkVycm9yID0gZXJyb3IyO1xuICAgICAgdGlja3MgPSBbZDAsIGQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuZnVuY3Rpb24gZXN0aW1hdGVUaWNrQ291bnQocmFuZ2VFeHRlbnQsIHpvb21FeHRlbnQsIG1pblNwYWNpbmcsIG1heFNwYWNpbmcsIGRlZmF1bHRUaWNrQ291bnQsIGRlZmF1bHRNaW5TcGFjaW5nKSB7XG4gIGRlZmF1bHRNaW5TcGFjaW5nID0gTWF0aC5tYXgoZGVmYXVsdE1pblNwYWNpbmcsIHJhbmdlRXh0ZW50IC8gKGRlZmF1bHRUaWNrQ291bnQgKyAxKSk7XG4gIGlmIChpc05hTihtaW5TcGFjaW5nKSkge1xuICAgIG1pblNwYWNpbmcgPSBkZWZhdWx0TWluU3BhY2luZztcbiAgfVxuICBpZiAoaXNOYU4obWF4U3BhY2luZykpIHtcbiAgICBtYXhTcGFjaW5nID0gcmFuZ2VFeHRlbnQ7XG4gIH1cbiAgaWYgKG1pblNwYWNpbmcgPiBtYXhTcGFjaW5nKSB7XG4gICAgaWYgKG1pblNwYWNpbmcgPT09IGRlZmF1bHRNaW5TcGFjaW5nKSB7XG4gICAgICBtaW5TcGFjaW5nID0gbWF4U3BhY2luZztcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4U3BhY2luZyA9IG1pblNwYWNpbmc7XG4gICAgfVxuICB9XG4gIGNvbnN0IG1heFRpY2tDb3VudCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmFuZ2VFeHRlbnQgLyAoem9vbUV4dGVudCAqIG1pblNwYWNpbmcpKSk7XG4gIGNvbnN0IG1pblRpY2tDb3VudCA9IE1hdGgubWluKG1heFRpY2tDb3VudCwgTWF0aC5jZWlsKHJhbmdlRXh0ZW50IC8gKHpvb21FeHRlbnQgKiBtYXhTcGFjaW5nKSkpO1xuICBjb25zdCB0aWNrQ291bnQgPSBjbGFtcChtaW5UaWNrQ291bnQsIE1hdGguZmxvb3IoZGVmYXVsdFRpY2tDb3VudCAvIHpvb21FeHRlbnQpLCBtYXhUaWNrQ291bnQpO1xuICByZXR1cm4geyBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCwgdGlja0NvdW50IH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL3RpbWVTY2FsZS50c1xudmFyIFRpbWVTY2FsZSA9IGNsYXNzIGV4dGVuZHMgQ29udGludW91c1NjYWxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoW10sIFswLCAxXSk7XG4gICAgdGhpcy50eXBlID0gXCJ0aW1lXCI7XG4gIH1cbiAgdG9Eb21haW4oZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShkKTtcbiAgfVxuICBjb252ZXJ0KHZhbHVlLCBjbGFtcDIpIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpKVxuICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHN1cGVyLmNvbnZlcnQodmFsdWUsIGNsYW1wMik7XG4gIH1cbiAgaW52ZXJ0KHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHN1cGVyLmludmVydCh2YWx1ZSkpO1xuICB9XG4gIG5pY2VEb21haW4odGlja3MsIGRvbWFpbiA9IHRoaXMuZG9tYWluKSB7XG4gICAgaWYgKGRvbWFpbi5sZW5ndGggPCAyKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IG1heEF0dGVtcHRzID0gNDtcbiAgICBsZXQgW2QwLCBkMV0gPSBkb21haW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhBdHRlbXB0czsgaSsrKSB7XG4gICAgICBjb25zdCBbbjAsIG4xXSA9IHVwZGF0ZU5pY2VEb21haW5JdGVyYXRpb24oZDAsIGQxLCB0aWNrcyk7XG4gICAgICBpZiAoZGF0ZVRvTnVtYmVyKGQwKSA9PT0gZGF0ZVRvTnVtYmVyKG4wKSAmJiBkYXRlVG9OdW1iZXIoZDEpID09PSBkYXRlVG9OdW1iZXIobjEpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZDAgPSBuMDtcbiAgICAgIGQxID0gbjE7XG4gICAgfVxuICAgIHJldHVybiBbZDAsIGQxXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB1bmlmb3JtbHktc3BhY2VkIGRhdGVzIHRoYXQgcmVwcmVzZW50IHRoZSBzY2FsZSdzIGRvbWFpbi5cbiAgICovXG4gIHRpY2tzKHBhcmFtcywgZG9tYWluID0gdGhpcy5kb21haW4sIHZpc2libGVSYW5nZSA9IFswLCAxXSkge1xuICAgIGNvbnN0IHsgbmljZSwgaW50ZXJ2YWwsIHRpY2tDb3VudCA9IENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0VGlja0NvdW50LCBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCB9ID0gcGFyYW1zO1xuICAgIGlmIChkb21haW4ubGVuZ3RoIDwgMilcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gZG9tYWluLm1hcChkYXRlVG9OdW1iZXIpO1xuICAgIGNvbnN0IHN0YXJ0MiA9IHRpbWVzdGFtcHNbMF07XG4gICAgY29uc3Qgc3RvcCA9IHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXTtcbiAgICBpZiAoaW50ZXJ2YWwgIT0gbnVsbCkge1xuICAgICAgY29uc3QgYXZhaWxhYmxlUmFuZ2UgPSB0aGlzLmdldFBpeGVsUmFuZ2UoKTtcbiAgICAgIHJldHVybiBnZXREYXRlVGlja3NGb3JJbnRlcnZhbCh7IHN0YXJ0OiBzdGFydDIsIHN0b3AsIGludGVydmFsLCBhdmFpbGFibGVSYW5nZSwgdmlzaWJsZVJhbmdlIH0pID8/IGdldERlZmF1bHREYXRlVGlja3MoeyBzdGFydDogc3RhcnQyLCBzdG9wLCB0aWNrQ291bnQsIG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50LCB2aXNpYmxlUmFuZ2UgfSk7XG4gICAgfSBlbHNlIGlmIChuaWNlICYmIHRpY2tDb3VudCA9PT0gMikge1xuICAgICAgcmV0dXJuIGRvbWFpbjtcbiAgICB9IGVsc2UgaWYgKG5pY2UgJiYgdGlja0NvdW50ID09PSAxKSB7XG4gICAgICByZXR1cm4gZG9tYWluLnNsaWNlKDAsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RGVmYXVsdERhdGVUaWNrcyh7IHN0YXJ0OiBzdGFydDIsIHN0b3AsIHRpY2tDb3VudCwgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQsIHZpc2libGVSYW5nZSB9KTtcbiAgfVxuICBfdGlja0Zvcm1hdHRlcih7IGRvbWFpbiwgdGlja3MsIHNwZWNpZmllciB9LCBmb3JtYXRPZmZzZXQpIHtcbiAgICByZXR1cm4gc3BlY2lmaWVyICE9IG51bGwgPyBidWlsZEZvcm1hdHRlcihzcGVjaWZpZXIpIDogZGVmYXVsdFRpbWVUaWNrRm9ybWF0KHRpY2tzLCBkb21haW4sIGZvcm1hdE9mZnNldCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSB0aW1lIGZvcm1hdCBmdW5jdGlvbiBzdWl0YWJsZSBmb3IgZGlzcGxheWluZyB0aWNrIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHRpY2tzIE9wdGlvbmFsIGFycmF5IG9mIHRpY2sgdmFsdWVzIGZvciBjdXN0b20gZm9ybWF0dGluZy5cbiAgICogQHBhcmFtIGRvbWFpbiBPcHRpb25hbCBhcnJheSByZXByZXNlbnRpbmcgdGhlIFttaW4sIG1heF0gdmFsdWVzIG9mIHRoZSB0aW1lIGF4aXMuXG4gICAqIEBwYXJhbSBzcGVjaWZpZXIgT3B0aW9uYWwgZm9ybWF0IHNwZWNpZmllciBzdHJpbmcgZm9yIGN1c3RvbSBkYXRlIGZvcm1hdHRpbmcgKGUuZy4sIGAlWWAsIGAlbWAsIGAlZGApLlxuICAgKiBAcGFyYW0gZm9ybWF0T2Zmc2V0IE9wdGlvbmFsIG51bWJlciBmb3IgYXBwbHlpbmcgYW4gb2Zmc2V0IHRvIHRoZSBmb3JtYXQgKGUuZy4sIHRpbWV6b25lIHNoaWZ0cykuXG4gICAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIGEgYERhdGVgIG9iamVjdCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBzcGVjaWZpZXIgb3IgZGVmYXVsdCBmb3JtYXQuXG4gICAqL1xuICB0aWNrRm9ybWF0dGVyKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLl90aWNrRm9ybWF0dGVyKHBhcmFtcyk7XG4gIH1cbiAgZGF0dW1Gb3JtYXR0ZXIocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpY2tGb3JtYXR0ZXIocGFyYW1zLCAxKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldERlZmF1bHREYXRlVGlja3Moe1xuICBzdGFydDogc3RhcnQyLFxuICBzdG9wLFxuICB0aWNrQ291bnQsXG4gIG1pblRpY2tDb3VudCxcbiAgbWF4VGlja0NvdW50LFxuICB2aXNpYmxlUmFuZ2Vcbn0pIHtcbiAgY29uc3QgdCA9IGdldFRpY2tJbnRlcnZhbChzdGFydDIsIHN0b3AsIHRpY2tDb3VudCwgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQpO1xuICByZXR1cm4gdCA/IHQucmFuZ2UobmV3IERhdGUoc3RhcnQyKSwgbmV3IERhdGUoc3RvcCksIHsgdmlzaWJsZVJhbmdlIH0pIDogW107XG59XG5mdW5jdGlvbiBnZXREYXRlVGlja3NGb3JJbnRlcnZhbCh7XG4gIHN0YXJ0OiBzdGFydDIsXG4gIHN0b3AsXG4gIGludGVydmFsLFxuICBhdmFpbGFibGVSYW5nZSxcbiAgdmlzaWJsZVJhbmdlXG59KSB7XG4gIGlmICghaW50ZXJ2YWwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKGludGVydmFsIGluc3RhbmNlb2YgVGltZUludGVydmFsKSB7XG4gICAgY29uc3QgdGlja3MyID0gaW50ZXJ2YWwucmFuZ2UobmV3IERhdGUoc3RhcnQyKSwgbmV3IERhdGUoc3RvcCksIHsgdmlzaWJsZVJhbmdlIH0pO1xuICAgIGlmIChpc0RlbnNlSW50ZXJ2YWwodGlja3MyLmxlbmd0aCwgYXZhaWxhYmxlUmFuZ2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aWNrczI7XG4gIH1cbiAgY29uc3QgYWJzSW50ZXJ2YWwgPSBNYXRoLmFicyhpbnRlcnZhbCk7XG4gIGlmIChpc0RlbnNlSW50ZXJ2YWwoTWF0aC5hYnMoc3RvcCAtIHN0YXJ0MikgLyBhYnNJbnRlcnZhbCwgYXZhaWxhYmxlUmFuZ2UpKVxuICAgIHJldHVybjtcbiAgY29uc3QgdGltZUludGVydmFsID0gVGlja0ludGVydmFscy5maW5kTGFzdCgodGlja0ludGVydmFsKSA9PiBhYnNJbnRlcnZhbCAlIHRpY2tJbnRlcnZhbC5kdXJhdGlvbiA9PT0gMCk7XG4gIGlmICh0aW1lSW50ZXJ2YWwpIHtcbiAgICBjb25zdCBpID0gdGltZUludGVydmFsLnRpbWVJbnRlcnZhbC5ldmVyeShhYnNJbnRlcnZhbCAvICh0aW1lSW50ZXJ2YWwuZHVyYXRpb24gLyB0aW1lSW50ZXJ2YWwuc3RlcCkpO1xuICAgIHJldHVybiBpLnJhbmdlKG5ldyBEYXRlKHN0YXJ0MiksIG5ldyBEYXRlKHN0b3ApLCB7IHZpc2libGVSYW5nZSB9KTtcbiAgfVxuICBsZXQgZGF0ZTIgPSBuZXcgRGF0ZShNYXRoLm1pbihzdGFydDIsIHN0b3ApKTtcbiAgY29uc3Qgc3RvcERhdGUgPSBuZXcgRGF0ZShNYXRoLm1heChzdGFydDIsIHN0b3ApKTtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgd2hpbGUgKGRhdGUyIDw9IHN0b3BEYXRlKSB7XG4gICAgdGlja3MucHVzaChkYXRlMik7XG4gICAgZGF0ZTIgPSBuZXcgRGF0ZShkYXRlMik7XG4gICAgZGF0ZTIuc2V0TWlsbGlzZWNvbmRzKGRhdGUyLmdldE1pbGxpc2Vjb25kcygpICsgYWJzSW50ZXJ2YWwpO1xuICB9XG4gIHJldHVybiB0aWNrcztcbn1cbmZ1bmN0aW9uIHVwZGF0ZU5pY2VEb21haW5JdGVyYXRpb24oZDAsIGQxLCB0aWNrcykge1xuICBjb25zdCB7IGludGVydmFsIH0gPSB0aWNrcztcbiAgY29uc3Qgc3RhcnQyID0gTWF0aC5taW4oZGF0ZVRvTnVtYmVyKGQwKSwgZGF0ZVRvTnVtYmVyKGQxKSk7XG4gIGNvbnN0IHN0b3AgPSBNYXRoLm1heChkYXRlVG9OdW1iZXIoZDApLCBkYXRlVG9OdW1iZXIoZDEpKTtcbiAgY29uc3QgaXNSZXZlcnNlZCA9IGQwID4gZDE7XG4gIGxldCBpO1xuICBpZiAoaW50ZXJ2YWwgaW5zdGFuY2VvZiBUaW1lSW50ZXJ2YWwpIHtcbiAgICBpID0gaW50ZXJ2YWw7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdGlja0NvdW50ID0gdHlwZW9mIGludGVydmFsID09PSBcIm51bWJlclwiID8gKHN0b3AgLSBzdGFydDIpIC8gTWF0aC5tYXgoaW50ZXJ2YWwsIDEpIDogdGlja3MudGlja0NvdW50ID8/IENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0VGlja0NvdW50O1xuICAgIGkgPSBnZXRUaWNrSW50ZXJ2YWwoc3RhcnQyLCBzdG9wLCB0aWNrQ291bnQsIHRpY2tzLm1pblRpY2tDb3VudCwgdGlja3MubWF4VGlja0NvdW50KTtcbiAgfVxuICBpZiAoaSkge1xuICAgIGNvbnN0IGludGVydmFsUmFuZ2UgPSBpLnJhbmdlKG5ldyBEYXRlKHN0YXJ0MiksIG5ldyBEYXRlKHN0b3ApLCB7IGV4dGVuZDogdHJ1ZSB9KTtcbiAgICBjb25zdCBkb21haW4gPSBpc1JldmVyc2VkID8gWy4uLmludGVydmFsUmFuZ2VdLnJldmVyc2UoKSA6IGludGVydmFsUmFuZ2U7XG4gICAgY29uc3QgbjAgPSBkb21haW5bMF07XG4gICAgY29uc3QgbjEgPSBkb21haW4uYXQoLTEpO1xuICAgIHJldHVybiBbbjAsIG4xXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2QwLCBkMV07XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NhbGUvb3JkaW5hbFRpbWVTY2FsZS50c1xudmFyIE9yZGluYWxUaW1lU2NhbGUgPSBjbGFzcyBfT3JkaW5hbFRpbWVTY2FsZSBleHRlbmRzIEJhbmRTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gXCJvcmRpbmFsLXRpbWVcIjtcbiAgICB0aGlzLl9kb21haW4gPSBbXTtcbiAgICB0aGlzLmlzUmV2ZXJzZWQgPSBmYWxzZTtcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfT3JkaW5hbFRpbWVTY2FsZTtcbiAgfVxuICBzZXQgZG9tYWluKGRvbWFpbikge1xuICAgIGlmIChkb21haW4gPT09IHRoaXMuX2RvbWFpbilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgIHRoaXMuX2RvbWFpbiA9IGRvbWFpbjtcbiAgICB0aGlzLmlzUmV2ZXJzZWQgPSBkb21haW4ubGVuZ3RoID4gMCAmJiBkb21haW5bMF0gPiBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuc29ydGVkVGltZXN0YW1wcyA9IHZvaWQgMDtcbiAgICB0aGlzLnByZWNvbXB1dGVkU3RlcHMgPSB2b2lkIDA7XG4gIH1cbiAgZ2V0IGRvbWFpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZG9tYWluO1xuICB9XG4gIHRvRG9tYWluKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgfVxuICBub3JtYWxpemVEb21haW5zKC4uLmRvbWFpbnMpIHtcbiAgICBjb25zdCBzb3J0ZWREb21haW5zID0gZG9tYWlucy5maWx0ZXIoKGRvbWFpbjIpID0+IGRvbWFpbjIubGVuZ3RoID4gMCkubWFwKChkb21haW4yKSA9PiB7XG4gICAgICBsZXQgc29ydE9yZGVyID0gZGF0ZXNTb3J0T3JkZXIoZG9tYWluMik7XG4gICAgICBpZiAoc29ydE9yZGVyID09IG51bGwpIHtcbiAgICAgICAgZG9tYWluMiA9IHNvcnRBbmRVbmlxdWVEYXRlcyhkb21haW4yLnNsaWNlKCkpO1xuICAgICAgICBzb3J0T3JkZXIgPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZG9tYWluOiBkb21haW4yLCBzb3J0T3JkZXIgfTtcbiAgICB9KTtcbiAgICBpZiAoc29ydGVkRG9tYWlucy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4geyBkb21haW46IFtdLCBhbmltYXRhYmxlOiBmYWxzZSB9O1xuICAgIGlmIChzb3J0ZWREb21haW5zLmxlbmd0aCA9PT0gMSlcbiAgICAgIHJldHVybiB7IGRvbWFpbjogc29ydGVkRG9tYWluc1swXS5kb21haW4sIGFuaW1hdGFibGU6IHRydWUgfTtcbiAgICBsZXQgZG9tYWluID0gc29ydGVkRG9tYWlucy5mbGF0TWFwKChzKSA9PiBzLmRvbWFpbik7XG4gICAgZG9tYWluID0gc29ydEFuZFVuaXF1ZURhdGVzKGRvbWFpbik7XG4gICAgaWYgKHNvcnRlZERvbWFpbnMuZXZlcnkoKHMpID0+IHMuc29ydE9yZGVyID09PSAtMSkpIHtcbiAgICAgIGRvbWFpbi5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiB7IGRvbWFpbiwgYW5pbWF0YWJsZTogdHJ1ZSB9O1xuICB9XG4gIHRpY2tzKHsgaW50ZXJ2YWwsIG1heFRpY2tDb3VudCB9LCBkb21haW4gPSB0aGlzLmRvbWFpbiwgdmlzaWJsZVJhbmdlID0gWzAsIDFdKSB7XG4gICAgaWYgKCFkb21haW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IHsgaXNSZXZlcnNlZCB9ID0gdGhpcztcbiAgICBpZiAoaW50ZXJ2YWwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGdldERlZmF1bHRUaWNrcyhkb21haW4sIG1heFRpY2tDb3VudCwgaXNSZXZlcnNlZCwgdmlzaWJsZVJhbmdlKTtcbiAgICB9XG4gICAgY29uc3QgW3QwLCB0MV0gPSBbZG9tYWluWzBdLnZhbHVlT2YoKSwgZG9tYWluLmF0KC0xKS52YWx1ZU9mKCldO1xuICAgIGNvbnN0IHN0YXJ0MiA9IE1hdGgubWluKHQwLCB0MSk7XG4gICAgY29uc3Qgc3RvcCA9IE1hdGgubWF4KHQwLCB0MSk7XG4gICAgY29uc3QgW3IwLCByMV0gPSB0aGlzLnJhbmdlO1xuICAgIGNvbnN0IGF2YWlsYWJsZVJhbmdlID0gTWF0aC5hYnMocjEgLSByMCk7XG4gICAgY29uc3QgdGlja3MgPSBnZXREYXRlVGlja3NGb3JJbnRlcnZhbCh7IHN0YXJ0OiBzdGFydDIsIHN0b3AsIGludGVydmFsLCBhdmFpbGFibGVSYW5nZSwgdmlzaWJsZVJhbmdlIH0pID8/IFtdO1xuICAgIGxldCBsYXN0SW5kZXggPSAtMTtcbiAgICByZXR1cm4gdGlja3MuZmlsdGVyKCh0aWNrKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuZmluZEludGVydmFsKHRpY2sudmFsdWVPZigpKTtcbiAgICAgIGNvbnN0IGR1cGxpY2F0ZWQgPSBpbmRleCA9PT0gbGFzdEluZGV4O1xuICAgICAgbGFzdEluZGV4ID0gaW5kZXg7XG4gICAgICByZXR1cm4gIWR1cGxpY2F0ZWQ7XG4gICAgfSk7XG4gIH1cbiAgZ2V0U29ydGVkVGltZXN0YW1wcygpIHtcbiAgICBsZXQgeyBzb3J0ZWRUaW1lc3RhbXBzIH0gPSB0aGlzO1xuICAgIGlmIChzb3J0ZWRUaW1lc3RhbXBzID09IG51bGwpIHtcbiAgICAgIHNvcnRlZFRpbWVzdGFtcHMgPSB0aGlzLmRvbWFpbi5tYXAoZGF0ZVRvTnVtYmVyKTtcbiAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZWQpXG4gICAgICAgIHNvcnRlZFRpbWVzdGFtcHMucmV2ZXJzZSgpO1xuICAgICAgdGhpcy5zb3J0ZWRUaW1lc3RhbXBzID0gc29ydGVkVGltZXN0YW1wcztcbiAgICB9XG4gICAgcmV0dXJuIHNvcnRlZFRpbWVzdGFtcHM7XG4gIH1cbiAgZ2V0UHJlY29tcHV0ZWRTdGVwcygpIHtcbiAgICBjb25zdCB7IGRvbWFpbiB9ID0gdGhpcztcbiAgICBsZXQgeyBwcmVjb21wdXRlZFN0ZXBzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNvbXB1dGVkU3RlcENvdW50ID0gZG9tYWluLmxlbmd0aCA8IDFlNCA/IGRvbWFpbi5sZW5ndGggOiBNYXRoLmNlaWwoZG9tYWluLmxlbmd0aCAvIDE2KTtcbiAgICBpZiAocHJlY29tcHV0ZWRTdGVwcyAhPSBudWxsIHx8IGNvbXB1dGVkU3RlcENvdW50IDw9IDEpXG4gICAgICByZXR1cm4gcHJlY29tcHV0ZWRTdGVwcztcbiAgICBjb25zdCBzb3J0ZWRUaW1lc3RhbXBzID0gdGhpcy5nZXRTb3J0ZWRUaW1lc3RhbXBzKCk7XG4gICAgcHJlY29tcHV0ZWRTdGVwcyA9IG5ldyBJbnQzMkFycmF5KGNvbXB1dGVkU3RlcENvdW50KTtcbiAgICBjb25zdCBkMCA9IHNvcnRlZFRpbWVzdGFtcHNbMF07XG4gICAgY29uc3QgZDEgPSBzb3J0ZWRUaW1lc3RhbXBzW3NvcnRlZFRpbWVzdGFtcHMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgZFJhbmdlID0gZDEgLSBkMDtcbiAgICBjb25zdCBsb3cgPSAwO1xuICAgIGNvbnN0IGhpZ2ggPSBzb3J0ZWRUaW1lc3RhbXBzLmxlbmd0aCAtIDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVjb21wdXRlZFN0ZXBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBwcmVjb21wdXRlZFN0ZXBzW2ldID0gdGhpcy5maW5kSW50ZXJ2YWxJblJhbmdlKGQwICsgaSAvIGNvbXB1dGVkU3RlcENvdW50ICogZFJhbmdlLCBsb3csIGhpZ2gpO1xuICAgIH1cbiAgICB0aGlzLnByZWNvbXB1dGVkU3RlcHMgPSBwcmVjb21wdXRlZFN0ZXBzO1xuICB9XG4gIGZpbmRJbnRlcnZhbEluUmFuZ2UodGFyZ2V0LCBsb3csIGhpZ2gpIHtcbiAgICBjb25zdCBzb3J0ZWRUaW1lc3RhbXBzID0gdGhpcy5nZXRTb3J0ZWRUaW1lc3RhbXBzKCk7XG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICBjb25zdCBtaWQgPSAobG93ICsgaGlnaCkgLyAyIHwgMDtcbiAgICAgIGlmIChzb3J0ZWRUaW1lc3RhbXBzW21pZF0gPT09IHRhcmdldCkge1xuICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRUaW1lc3RhbXBzW21pZF0gPCB0YXJnZXQpIHtcbiAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhpZ2ggPSBtaWQgLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9XG4gIGZpbmRJbnRlcnZhbCh0YXJnZXQpIHtcbiAgICBjb25zdCBwcmVjb21wdXRlZFN0ZXBzID0gdGhpcy5nZXRQcmVjb21wdXRlZFN0ZXBzKCk7XG4gICAgbGV0IGxvdztcbiAgICBsZXQgaGlnaDtcbiAgICBpZiAocHJlY29tcHV0ZWRTdGVwcyA9PSBudWxsKSB7XG4gICAgICBsb3cgPSAwO1xuICAgICAgaGlnaCA9IHRoaXMuZG9tYWluLmxlbmd0aCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNvcnRlZFRpbWVzdGFtcHMgPSB0aGlzLmdldFNvcnRlZFRpbWVzdGFtcHMoKTtcbiAgICAgIGNvbnN0IGQwID0gc29ydGVkVGltZXN0YW1wc1swXTtcbiAgICAgIGNvbnN0IGQxID0gc29ydGVkVGltZXN0YW1wc1tzb3J0ZWRUaW1lc3RhbXBzLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgaSA9IE1hdGgubWluKFxuICAgICAgICAodGFyZ2V0IC0gZDApIC8gKGQxIC0gZDApICogcHJlY29tcHV0ZWRTdGVwcy5sZW5ndGggfCAwLFxuICAgICAgICBwcmVjb21wdXRlZFN0ZXBzLmxlbmd0aCAtIDEgfCAwXG4gICAgICApO1xuICAgICAgbG93ID0gcHJlY29tcHV0ZWRTdGVwc1tpXTtcbiAgICAgIGhpZ2ggPSBpIDwgcHJlY29tcHV0ZWRTdGVwcy5sZW5ndGggLSAyID8gcHJlY29tcHV0ZWRTdGVwc1tpICsgMV0gOiBzb3J0ZWRUaW1lc3RhbXBzLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmRJbnRlcnZhbEluUmFuZ2UodGFyZ2V0LCBsb3csIGhpZ2gpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdGltZSBmb3JtYXQgZnVuY3Rpb24gc3VpdGFibGUgZm9yIGRpc3BsYXlpbmcgdGljayB2YWx1ZXMuXG4gICAqIEBwYXJhbSBzcGVjaWZpZXIgSWYgdGhlIHNwZWNpZmllciBzdHJpbmcgaXMgcHJvdmlkZWQsIHRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG9cbiAgICogdGhlIHtAbGluayBUaW1lTG9jYWxlT2JqZWN0LmZvcm1hdH0gbWV0aG9kLlxuICAgKiBJZiBubyBzcGVjaWZpZXIgaXMgcHJvdmlkZWQsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGRlZmF1bHQgdGltZSBmb3JtYXQgZnVuY3Rpb24uXG4gICAqL1xuICB0aWNrRm9ybWF0dGVyKHsgZG9tYWluLCB0aWNrcywgc3BlY2lmaWVyIH0pIHtcbiAgICByZXR1cm4gc3BlY2lmaWVyICE9IG51bGwgPyBidWlsZEZvcm1hdHRlcihzcGVjaWZpZXIpIDogZGVmYXVsdFRpbWVUaWNrRm9ybWF0KHRpY2tzLCBkb21haW4pO1xuICB9XG4gIGRhdHVtRm9ybWF0dGVyKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnRpY2tGb3JtYXR0ZXIocGFyYW1zKTtcbiAgfVxuICBpbnZlcnQocG9zaXRpb24sIG5lYXJlc3QgPSBmYWxzZSkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGNvbnN0IHsgZG9tYWluIH0gPSB0aGlzO1xuICAgIGlmIChuZWFyZXN0KSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW52ZXJ0TmVhcmVzdEluZGV4KHBvc2l0aW9uIC0gdGhpcy5iYW5kd2lkdGggLyAyKTtcbiAgICAgIHJldHVybiBpbmRleCAhPSBudWxsID8gZG9tYWluW2luZGV4XSA6IHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgY2xvc2VzdCA9IGZpbmRNaW5WYWx1ZSgwLCBkb21haW4ubGVuZ3RoIC0gMSwgKGkpID0+IHtcbiAgICAgIGNvbnN0IHAgPSB0aGlzLm9yZGluYWxSYW5nZShpKTtcbiAgICAgIHJldHVybiBwID49IHBvc2l0aW9uID8gZG9tYWluW2ldIDogdm9pZCAwO1xuICAgIH0pO1xuICAgIHJldHVybiBjbG9zZXN0ID8/IGRvbWFpblswXTtcbiAgfVxuICBnZXRJbmRleCh2YWx1ZSkge1xuICAgIGNvbnN0IHNvcnRlZFRpbWVzdGFtcHMgPSB0aGlzLmdldFNvcnRlZFRpbWVzdGFtcHMoKTtcbiAgICBjb25zdCBuID0gTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAobiA8IHNvcnRlZFRpbWVzdGFtcHNbMF0pIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGxldCBpID0gdGhpcy5maW5kSW50ZXJ2YWwobik7XG4gICAgaWYgKHRoaXMuaXNSZXZlcnNlZCkge1xuICAgICAgaSA9IHRoaXMuZG9tYWluLmxlbmd0aCAtIGkgLSAxO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldERlZmF1bHRUaWNrcyhkb21haW4sIG1heFRpY2tDb3VudCwgaXNSZXZlcnNlZCwgdmlzaWJsZVJhbmdlKSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGNvbnN0IHRpY2tFdmVyeSA9IE1hdGguY2VpbChkb21haW4ubGVuZ3RoIC8gbWF4VGlja0NvdW50KTtcbiAgY29uc3QgdGlja09mZnNldCA9IE1hdGguZmxvb3IodGlja0V2ZXJ5IC8gMik7XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBNYXRoLmZsb29yKHZpc2libGVSYW5nZVswXSAqIGRvbWFpbi5sZW5ndGgpO1xuICBjb25zdCBlbmRJbmRleCA9IE1hdGguY2VpbCh2aXNpYmxlUmFuZ2VbMV0gKiBkb21haW4ubGVuZ3RoKTtcbiAgZm9yIChsZXQgaW5kZXggPSBzdGFydEluZGV4OyBpbmRleCA8IGVuZEluZGV4OyBpbmRleCArPSAxKSB7XG4gICAgY29uc3QgdGlja0luZGV4ID0gaXNSZXZlcnNlZCA/IGRvbWFpbi5sZW5ndGggLSAxIC0gaW5kZXggOiBpbmRleDtcbiAgICBpZiAodGlja0V2ZXJ5IDw9IDAgfHwgKHRpY2tJbmRleCArIHRpY2tPZmZzZXQpICUgdGlja0V2ZXJ5ID09PSAwKSB7XG4gICAgICB0aWNrcy5wdXNoKGRvbWFpbltpbmRleF0pO1xuICAgIH1cbiAgfVxuICBpZiAoaXNSZXZlcnNlZCkge1xuICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NlbGVjdGlvbi50c1xudmFyIFNlbGVjdGlvbiA9IGNsYXNzIF9TZWxlY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJlbnROb2RlLCBjbGFzc09yRmFjdG9yeSwgYXV0b0NsZWFudXAgPSB0cnVlKSB7XG4gICAgdGhpcy5wYXJlbnROb2RlID0gcGFyZW50Tm9kZTtcbiAgICB0aGlzLmF1dG9DbGVhbnVwID0gYXV0b0NsZWFudXA7XG4gICAgdGhpcy5nYXJiYWdlQmluID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLl9ub2Rlc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fbm9kZXMgPSBbXTtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwic2NlbmVcIiwgXCJzY2VuZTpzZWxlY3Rpb25zXCIpO1xuICAgIHRoaXMubm9kZUZhY3RvcnkgPSBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbChOb2RlLCBjbGFzc09yRmFjdG9yeSkgPyAoKSA9PiBuZXcgY2xhc3NPckZhY3RvcnkoKSA6IGNsYXNzT3JGYWN0b3J5O1xuICB9XG4gIHN0YXRpYyBzZWxlY3QocGFyZW50LCBjbGFzc09yRmFjdG9yeSwgZ2FyYmFnZUNvbGxlY3Rpb24gPSB0cnVlKSB7XG4gICAgcmV0dXJuIG5ldyBfU2VsZWN0aW9uKHBhcmVudCwgY2xhc3NPckZhY3RvcnksIGdhcmJhZ2VDb2xsZWN0aW9uKTtcbiAgfVxuICBzdGF0aWMgc2VsZWN0QWxsKHBhcmVudCwgcHJlZGljYXRlKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IHRyYXZlcnNlID0gKG5vZGUpID0+IHtcbiAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKCkpIHtcbiAgICAgICAgdHJhdmVyc2UoY2hpbGQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdHJhdmVyc2UocGFyZW50KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBzdGF0aWMgc2VsZWN0QnlDbGFzcyhub2RlLCAuLi5DbGFzc2VzKSB7XG4gICAgcmV0dXJuIF9TZWxlY3Rpb24uc2VsZWN0QWxsKG5vZGUsIChuKSA9PiBDbGFzc2VzLnNvbWUoKEMyKSA9PiBuIGluc3RhbmNlb2YgQzIpKTtcbiAgfVxuICBzdGF0aWMgc2VsZWN0QnlUYWcobm9kZSwgdGFnKSB7XG4gICAgcmV0dXJuIF9TZWxlY3Rpb24uc2VsZWN0QWxsKG5vZGUsIChuKSA9PiBuLnRhZyA9PT0gdGFnKTtcbiAgfVxuICBjcmVhdGVOb2RlKGRhdHVtLCBpbml0aWFsaXplciwgaWR4KSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZUZhY3RvcnkoZGF0dW0pO1xuICAgIG5vZGUuZGF0dW0gPSBkYXR1bTtcbiAgICBpbml0aWFsaXplcj8uKG5vZGUpO1xuICAgIGlmIChpZHggPT0gbnVsbCkge1xuICAgICAgdGhpcy5fbm9kZXMucHVzaChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbm9kZXMuc3BsaWNlKGlkeCwgMCwgbm9kZSk7XG4gICAgfVxuICAgIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBkYXRhIGluIGEgc2VsZWN0aW9uLiBJZiBhbiBgZ2V0RGF0dW1JZCgpYCBmdW5jdGlvbiBpcyBwcm92aWRlZCwgbWFpbnRhaW4gYSBsaXN0IG9mIGlkcyByZWxhdGVkIHRvXG4gICAqIHRoZSBub2Rlcy4gT3RoZXJ3aXNlLCB0YWtlIHRoZSBtb3JlIGVmZmljaWVudCByb3V0ZSBvZiBzaW1wbHkgY3JlYXRpbmcgYW5kIGRlc3Ryb3lpbmcgbm9kZXMgYXQgdGhlIGVuZFxuICAgKiBvZiB0aGUgYXJyYXkuXG4gICAqL1xuICB1cGRhdGUoZGF0YSwgaW5pdGlhbGl6ZXIsIGdldERhdHVtSWQpIHtcbiAgICBpZiAodGhpcy5nYXJiYWdlQmluLnNpemUgPiAwKSB7XG4gICAgICB0aGlzLmRlYnVnKGBTZWxlY3Rpb24gLSB1cGRhdGUoKSBjYWxsZWQgd2l0aCBwZW5kaW5nIGdhcmJhZ2VgLCBkYXRhKTtcbiAgICB9XG4gICAgaWYgKGdldERhdHVtSWQpIHtcbiAgICAgIGNvbnN0IGRhdGFNYXAgPSBuZXcgTWFwKFxuICAgICAgICBkYXRhLm1hcCgoZGF0dW0sIGlkeCkgPT4gW2dldERhdHVtSWQoZGF0dW0pLCBbZGF0dW0sIGlkeF1dKVxuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3QgW25vZGUsIGRhdHVtSWRdIG9mIHRoaXMuX25vZGVzTWFwLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoZGF0YU1hcC5oYXMoZGF0dW1JZCkpIHtcbiAgICAgICAgICBjb25zdCBbbmV3RGF0dW1dID0gZGF0YU1hcC5nZXQoZGF0dW1JZCk7XG4gICAgICAgICAgbm9kZS5kYXR1bSA9IG5ld0RhdHVtO1xuICAgICAgICAgIHRoaXMuZ2FyYmFnZUJpbi5kZWxldGUobm9kZSk7XG4gICAgICAgICAgZGF0YU1hcC5kZWxldGUoZGF0dW1JZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5nYXJiYWdlQmluLmFkZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbZGF0dW1JZCwgW2RhdHVtLCBpZHhdXSBvZiBkYXRhTWFwLmVudHJpZXMoKSkge1xuICAgICAgICB0aGlzLl9ub2Rlc01hcC5zZXQodGhpcy5jcmVhdGVOb2RlKGRhdHVtLCBpbml0aWFsaXplciwgaWR4KSwgZGF0dW1JZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1heExlbmd0aCA9IE1hdGgubWF4KGRhdGEubGVuZ3RoLCB0aGlzLmRhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmdhcmJhZ2VCaW4uYWRkKHRoaXMuX25vZGVzW2ldKTtcbiAgICAgICAgfSBlbHNlIGlmIChpID49IHRoaXMuX25vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuY3JlYXRlTm9kZShkYXRhW2ldLCBpbml0aWFsaXplcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbm9kZXNbaV0uZGF0dW0gPSBkYXRhW2ldO1xuICAgICAgICAgIHRoaXMuZ2FyYmFnZUJpbi5kZWxldGUodGhpcy5fbm9kZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGF0YSA9IGRhdGEuc2xpY2UoKTtcbiAgICBpZiAodGhpcy5hdXRvQ2xlYW51cCkge1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuZ2FyYmFnZUJpbi5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fbm9kZXMgPSB0aGlzLl9ub2Rlcy5maWx0ZXIoKG5vZGUpID0+IHtcbiAgICAgIGlmICh0aGlzLmdhcmJhZ2VCaW4uaGFzKG5vZGUpKSB7XG4gICAgICAgIHRoaXMuX25vZGVzTWFwLmRlbGV0ZShub2RlKTtcbiAgICAgICAgdGhpcy5nYXJiYWdlQmluLmRlbGV0ZShub2RlKTtcbiAgICAgICAgbm9kZS5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMudXBkYXRlKFtdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpc0dhcmJhZ2Uobm9kZSkge1xuICAgIHJldHVybiB0aGlzLmdhcmJhZ2VCaW4uaGFzKG5vZGUpO1xuICB9XG4gIGVhY2goaXRlcmF0ZTIpIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuX25vZGVzLmVudHJpZXMoKSkge1xuICAgICAgaXRlcmF0ZTIoZW50cnlbMV0sIGVudHJ5WzFdLmRhdHVtLCBlbnRyeVswXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZXNbaW5kZXhdO1xuICAgICAgeWllbGQgeyBub2RlLCBkYXR1bTogbm9kZS5kYXR1bSwgaW5kZXggfTtcbiAgICB9XG4gIH1cbiAgc2VsZWN0KHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBfU2VsZWN0aW9uLnNlbGVjdEFsbCh0aGlzLnBhcmVudE5vZGUsIHByZWRpY2F0ZSk7XG4gIH1cbiAgc2VsZWN0QnlDbGFzcyhDbGFzcykge1xuICAgIHJldHVybiBfU2VsZWN0aW9uLnNlbGVjdEJ5Q2xhc3ModGhpcy5wYXJlbnROb2RlLCBDbGFzcyk7XG4gIH1cbiAgc2VsZWN0QnlUYWcodGFnKSB7XG4gICAgcmV0dXJuIF9TZWxlY3Rpb24uc2VsZWN0QnlUYWcodGhpcy5wYXJlbnROb2RlLCB0YWcpO1xuICB9XG4gIG5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9ub2RlcztcbiAgfVxuICBhdChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9ub2Rlcy5hdChpbmRleCk7XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXMubGVuZ3RoO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2Rpc3RhbmNlLnRzXG5mdW5jdGlvbiBwb2ludHNEaXN0YW5jZVNxdWFyZWQoeDEsIHkxLCB4MiwgeTIpIHtcbiAgY29uc3QgZHggPSB4MSAtIHgyO1xuICBjb25zdCBkeSA9IHkxIC0geTI7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbmZ1bmN0aW9uIGxpbmVEaXN0YW5jZVNxdWFyZWQoeCwgeSwgeDEsIHkxLCB4MiwgeTIsIGJlc3QpIHtcbiAgaWYgKHgxID09PSB4MiAmJiB5MSA9PT0geTIpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oYmVzdCwgcG9pbnRzRGlzdGFuY2VTcXVhcmVkKHgsIHksIHgxLCB5MSkpO1xuICB9XG4gIGNvbnN0IGR4ID0geDIgLSB4MTtcbiAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICBjb25zdCB0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKCh4IC0geDEpICogZHggKyAoeSAtIHkxKSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSkpKTtcbiAgY29uc3QgaXggPSB4MSArIHQgKiBkeDtcbiAgY29uc3QgaXkgPSB5MSArIHQgKiBkeTtcbiAgcmV0dXJuIE1hdGgubWluKGJlc3QsIHBvaW50c0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCBpeCwgaXkpKTtcbn1cbmZ1bmN0aW9uIGFyY0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCBjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNvdW50ZXJDbG9ja3dpc2UsIGJlc3QpIHtcbiAgaWYgKGNvdW50ZXJDbG9ja3dpc2UpIHtcbiAgICBbZW5kQW5nbGUsIHN0YXJ0QW5nbGVdID0gW3N0YXJ0QW5nbGUsIGVuZEFuZ2xlXTtcbiAgfVxuICBjb25zdCBhbmdsZTIgPSBNYXRoLmF0YW4yKHkgLSBjeSwgeCAtIGN4KTtcbiAgaWYgKCFpc0JldHdlZW5BbmdsZXMoYW5nbGUyLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICBjb25zdCBzdGFydFggPSBjeCArIE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmFkaXVzO1xuICAgIGNvbnN0IHN0YXJ0WSA9IGN5ICsgTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByYWRpdXM7XG4gICAgY29uc3QgZW5kWCA9IGN4ICsgTWF0aC5jb3Moc3RhcnRBbmdsZSkgKiByYWRpdXM7XG4gICAgY29uc3QgZW5kWSA9IGN5ICsgTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByYWRpdXM7XG4gICAgcmV0dXJuIE1hdGgubWluKGJlc3QsIHBvaW50c0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCBzdGFydFgsIHN0YXJ0WSksIHBvaW50c0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCBlbmRYLCBlbmRZKSk7XG4gIH1cbiAgY29uc3QgZGlzdFRvQXJjID0gcmFkaXVzIC0gTWF0aC5zcXJ0KHBvaW50c0Rpc3RhbmNlU3F1YXJlZCh4LCB5LCBjeCwgY3kpKTtcbiAgcmV0dXJuIE1hdGgubWluKGJlc3QsIGRpc3RUb0FyYyAqIGRpc3RUb0FyYyk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL2xpbmUudHNcbnZhciBMaW5lID0gY2xhc3MgZXh0ZW5kcyBTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKG9wdHMpO1xuICAgIHRoaXMueDEgPSAwO1xuICAgIHRoaXMueTEgPSAwO1xuICAgIHRoaXMueDIgPSAwO1xuICAgIHRoaXMueTIgPSAwO1xuICAgIHRoaXMucmVzdG9yZU93blN0eWxlcygpO1xuICB9XG4gIHNldCB4KHZhbHVlKSB7XG4gICAgdGhpcy54MSA9IHZhbHVlO1xuICAgIHRoaXMueDIgPSB2YWx1ZTtcbiAgfVxuICBzZXQgeSh2YWx1ZSkge1xuICAgIHRoaXMueTEgPSB2YWx1ZTtcbiAgICB0aGlzLnkyID0gdmFsdWU7XG4gIH1cbiAgZ2V0IG1pZFBvaW50KCkge1xuICAgIHJldHVybiB7IHg6ICh0aGlzLngxICsgdGhpcy54MikgLyAyLCB5OiAodGhpcy55MSArIHRoaXMueTIpIC8gMiB9O1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIHJldHVybiBuZXcgQkJveChcbiAgICAgIE1hdGgubWluKHRoaXMueDEsIHRoaXMueDIpLFxuICAgICAgTWF0aC5taW4odGhpcy55MSwgdGhpcy55MiksXG4gICAgICBNYXRoLmFicyh0aGlzLngyIC0gdGhpcy54MSksXG4gICAgICBNYXRoLmFicyh0aGlzLnkyIC0gdGhpcy55MSlcbiAgICApO1xuICB9XG4gIGlzUG9pbnRJblBhdGgoeCwgeSkge1xuICAgIGlmICh0aGlzLngxID09PSB0aGlzLngyIHx8IHRoaXMueTEgPT09IHRoaXMueTIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJCb3goKS5jbG9uZSgpLmdyb3codGhpcy5zdHJva2VXaWR0aCAvIDIpLmNvbnRhaW5zUG9pbnQoeCwgeSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkaXN0YW5jZVNxdWFyZWQocHgsIHB5KSB7XG4gICAgY29uc3QgeyB4MSwgeTEsIHgyLCB5MiB9ID0gdGhpcztcbiAgICByZXR1cm4gbGluZURpc3RhbmNlU3F1YXJlZChweCwgcHksIHgxLCB5MSwgeDIsIHkyLCBJbmZpbml0eSk7XG4gIH1cbiAgcmVuZGVyKHJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgY3R4LCBkZXZpY2VQaXhlbFJhdGlvIH0gPSByZW5kZXJDdHg7XG4gICAgbGV0IHsgeDEsIHkxLCB4MiwgeTIgfSA9IHRoaXM7XG4gICAgaWYgKHgxID09PSB4Mikge1xuICAgICAgY29uc3QgeyBzdHJva2VXaWR0aCB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHggPSBNYXRoLnJvdW5kKHgxICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgTWF0aC50cnVuYyhzdHJva2VXaWR0aCAqIGRldmljZVBpeGVsUmF0aW8pICUgMiAvIChkZXZpY2VQaXhlbFJhdGlvICogMik7XG4gICAgICB4MSA9IHg7XG4gICAgICB4MiA9IHg7XG4gICAgfSBlbHNlIGlmICh5MSA9PT0geTIpIHtcbiAgICAgIGNvbnN0IHsgc3Ryb2tlV2lkdGggfSA9IHRoaXM7XG4gICAgICBjb25zdCB5ID0gTWF0aC5yb3VuZCh5MSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIE1hdGgudHJ1bmMoc3Ryb2tlV2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvKSAlIDIgLyAoZGV2aWNlUGl4ZWxSYXRpbyAqIDIpO1xuICAgICAgeTEgPSB5O1xuICAgICAgeTIgPSB5O1xuICAgIH1cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICB0aGlzLmZpbGxTdHJva2UoY3R4KTtcbiAgICB0aGlzLmZpbGxTaGFkb3c/Lm1hcmtDbGVhbigpO1xuICAgIHN1cGVyLnJlbmRlcihyZW5kZXJDdHgpO1xuICB9XG4gIHRvU1ZHKCkge1xuICAgIGlmICghdGhpcy52aXNpYmxlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGVsZW1lbnQyID0gY3JlYXRlU3ZnRWxlbWVudChcImxpbmVcIik7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwieDFcIiwgU3RyaW5nKHRoaXMueDEpKTtcbiAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXCJ5MVwiLCBTdHJpbmcodGhpcy55MSkpO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcIngyXCIsIFN0cmluZyh0aGlzLngyKSk7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwieTJcIiwgU3RyaW5nKHRoaXMueTIpKTtcbiAgICB0aGlzLmFwcGx5U3ZnU3Ryb2tlQXR0cmlidXRlcyhlbGVtZW50Mik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRzOiBbZWxlbWVudDJdXG4gICAgfTtcbiAgfVxufTtcbkxpbmUuY2xhc3NOYW1lID0gXCJMaW5lXCI7XG5MaW5lLmRlZmF1bHRTdHlsZXMgPSB7IC4uLlNoYXBlLmRlZmF1bHRTdHlsZXMsIGZpbGw6IHZvaWQgMCwgc3Ryb2tlV2lkdGg6IDEgfTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIExpbmUucHJvdG90eXBlLCBcIngxXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgTGluZS5wcm90b3R5cGUsIFwieTFcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBMaW5lLnByb3RvdHlwZSwgXCJ4MlwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIExpbmUucHJvdG90eXBlLCBcInkyXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2Zvcm1hdC51dGlsLnRzXG52YXIgZGVmYXVsdE51bWJlckZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChcImVuLVVTXCIsIHsgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyLCB1c2VHcm91cGluZzogZmFsc2UgfSk7XG52YXIgcGVyY2VudEZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChcImVuLVVTXCIsIHsgc3R5bGU6IFwicGVyY2VudFwiIH0pO1xuZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWUsIG1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IDIpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIodmFsdWUsIG1heGltdW1GcmFjdGlvbkRpZ2l0cyk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSA/PyBcIlwiKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFBlcmNlbnQodmFsdWUpIHtcbiAgcmV0dXJuIHBlcmNlbnRGb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcih2YWx1ZSwgbWF4aW11bUZyYWN0aW9uRGlnaXRzKSB7XG4gIGlmIChtYXhpbXVtRnJhY3Rpb25EaWdpdHMgPT09IDIpIHtcbiAgICByZXR1cm4gZGVmYXVsdE51bWJlckZvcm1hdHRlci5mb3JtYXQodmFsdWUpO1xuICB9XG4gIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoXCJlbi1VU1wiLCB7IG1heGltdW1GcmFjdGlvbkRpZ2l0cywgdXNlR3JvdXBpbmc6IGZhbHNlIH0pLmZvcm1hdCh2YWx1ZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL3JhbmdlLnRzXG52YXIgUmFuZ2UgPSBjbGFzcyBleHRlbmRzIFNoYXBlIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cyk7XG4gICAgdGhpcy54MSA9IDA7XG4gICAgdGhpcy55MSA9IDA7XG4gICAgdGhpcy54MiA9IDA7XG4gICAgdGhpcy55MiA9IDA7XG4gICAgdGhpcy5zdGFydExpbmUgPSBmYWxzZTtcbiAgICB0aGlzLmVuZExpbmUgPSBmYWxzZTtcbiAgICB0aGlzLmlzUmFuZ2UgPSBmYWxzZTtcbiAgICB0aGlzLnJlc3RvcmVPd25TdHlsZXMoKTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICByZXR1cm4gbmV3IEJCb3godGhpcy54MSwgdGhpcy55MSwgdGhpcy54MiAtIHRoaXMueDEsIHRoaXMueTIgLSB0aGlzLnkxKTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKF94LCBfeSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHJlbmRlckN0eDtcbiAgICBsZXQgeyB4MSwgeTEsIHgyLCB5MiB9ID0gdGhpcztcbiAgICB4MSA9IHRoaXMuYWxpZ24oeDEpO1xuICAgIHkxID0gdGhpcy5hbGlnbih5MSk7XG4gICAgeDIgPSB0aGlzLmFsaWduKHgyKTtcbiAgICB5MiA9IHRoaXMuYWxpZ24oeTIpO1xuICAgIGNvbnN0IHsgZmlsbCwgb3BhY2l0eSwgaXNSYW5nZSB9ID0gdGhpcztcbiAgICBjb25zdCBmaWxsQWN0aXZlID0gISEoaXNSYW5nZSAmJiBmaWxsKTtcbiAgICBpZiAoZmlsbEFjdGl2ZSkge1xuICAgICAgY29uc3QgeyBmaWxsT3BhY2l0eSB9ID0gdGhpcztcbiAgICAgIHRoaXMuYXBwbHlGaWxsKGN0eCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5ICogZmlsbE9wYWNpdHk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgICBjdHgubGluZVRvKHgyLCB5MSk7XG4gICAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgICBjdHgubGluZVRvKHgxLCB5Mik7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBjb25zdCB7IHN0cm9rZTogc3Ryb2tlMiwgc3Ryb2tlV2lkdGgsIHN0YXJ0TGluZSwgZW5kTGluZSB9ID0gdGhpcztcbiAgICBjb25zdCBzdHJva2VBY3RpdmUgPSAhISgoc3RhcnRMaW5lIHx8IGVuZExpbmUpICYmIHN0cm9rZTIgJiYgc3Ryb2tlV2lkdGgpO1xuICAgIGlmIChzdHJva2VBY3RpdmUpIHtcbiAgICAgIGNvbnN0IHsgc3Ryb2tlT3BhY2l0eSwgbGluZURhc2gsIGxpbmVEYXNoT2Zmc2V0LCBsaW5lQ2FwLCBsaW5lSm9pbiB9ID0gdGhpcztcbiAgICAgIHRoaXMuYXBwbHlTdHJva2UoY3R4KTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHkgKiBzdHJva2VPcGFjaXR5O1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0cm9rZVdpZHRoO1xuICAgICAgaWYgKGxpbmVEYXNoKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChsaW5lRGFzaCk7XG4gICAgICB9XG4gICAgICBpZiAobGluZURhc2hPZmZzZXQpIHtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAobGluZUNhcCkge1xuICAgICAgICBjdHgubGluZUNhcCA9IGxpbmVDYXA7XG4gICAgICB9XG4gICAgICBpZiAobGluZUpvaW4pIHtcbiAgICAgICAgY3R4LmxpbmVKb2luID0gbGluZUpvaW47XG4gICAgICB9XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBpZiAoc3RhcnRMaW5lKSB7XG4gICAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4MiwgeTEpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZExpbmUpIHtcbiAgICAgICAgY3R4Lm1vdmVUbyh4MiwgeTIpO1xuICAgICAgICBjdHgubGluZVRvKHgxLCB5Mik7XG4gICAgICB9XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIHRoaXMuZmlsbFNoYWRvdz8ubWFya0NsZWFuKCk7XG4gICAgc3VwZXIucmVuZGVyKHJlbmRlckN0eCk7XG4gIH1cbn07XG5SYW5nZS5jbGFzc05hbWUgPSBcIlJhbmdlXCI7XG5SYW5nZS5kZWZhdWx0U3R5bGVzID0ge1xuICAuLi5TaGFwZS5kZWZhdWx0U3R5bGVzLFxuICBzdHJva2VXaWR0aDogMVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJ4MVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJ5MVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJ4MlwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJ5MlwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJzdGFydExpbmVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBSYW5nZS5wcm90b3R5cGUsIFwiZW5kTGluZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJpc1JhbmdlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sYWJlbC50c1xudmFyIExhYmVsID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmZvbnRTaXplID0gMTI7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJWZXJkYW5hLCBzYW5zLXNlcmlmXCI7XG4gIH1cbiAgZ2V0Rm9udCgpIHtcbiAgICByZXR1cm4gVGV4dFV0aWxzLnRvRm9udFN0cmluZyh0aGlzKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBMYWJlbC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGFiZWwucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9TVFlMRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGFiZWwucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfV0VJR0hULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMYWJlbC5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExhYmVsLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIExhYmVsLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExhYmVsLnByb3RvdHlwZSwgXCJmb3JtYXR0ZXJcIiwgMik7XG5mdW5jdGlvbiBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKG9wdHMpIHtcbiAgY29uc3QgeyBwYXJhbGxlbEZsaXBSb3RhdGlvbiA9IDAsIHJlZ3VsYXJGbGlwUm90YXRpb24gPSAwIH0gPSBvcHRzO1xuICBjb25zdCBjb25maWd1cmVkUm90YXRpb24gPSBvcHRzLnJvdGF0aW9uID8gbm9ybWFsaXplQW5nbGUzNjAodG9SYWRpYW5zKG9wdHMucm90YXRpb24pKSA6IDA7XG4gIGNvbnN0IHBhcmFsbGVsRmxpcEZsYWcgPSAhY29uZmlndXJlZFJvdGF0aW9uICYmIHBhcmFsbGVsRmxpcFJvdGF0aW9uID49IDAgJiYgcGFyYWxsZWxGbGlwUm90YXRpb24gPD0gTWF0aC5QSSA/IC0xIDogMTtcbiAgY29uc3QgcmVndWxhckZsaXBGbGFnID0gIWNvbmZpZ3VyZWRSb3RhdGlvbiAmJiByZWd1bGFyRmxpcFJvdGF0aW9uID49IDAgJiYgcmVndWxhckZsaXBSb3RhdGlvbiA8PSBNYXRoLlBJID8gLTEgOiAxO1xuICBsZXQgZGVmYXVsdFJvdGF0aW9uID0gMDtcbiAgaWYgKG9wdHMucGFyYWxsZWwpIHtcbiAgICBkZWZhdWx0Um90YXRpb24gPSBwYXJhbGxlbEZsaXBGbGFnICogTWF0aC5QSSAvIDI7XG4gIH0gZWxzZSBpZiAocmVndWxhckZsaXBGbGFnID09PSAtMSkge1xuICAgIGRlZmF1bHRSb3RhdGlvbiA9IE1hdGguUEk7XG4gIH1cbiAgcmV0dXJuIHsgY29uZmlndXJlZFJvdGF0aW9uLCBkZWZhdWx0Um90YXRpb24sIHBhcmFsbGVsRmxpcEZsYWcsIHJlZ3VsYXJGbGlwRmxhZyB9O1xufVxuZnVuY3Rpb24gZ2V0TGFiZWxTcGFjaW5nKG1pblNwYWNpbmcsIHJvdGF0ZWQpIHtcbiAgaWYgKCFpc05hTihtaW5TcGFjaW5nKSkge1xuICAgIHJldHVybiBtaW5TcGFjaW5nO1xuICB9XG4gIHJldHVybiByb3RhdGVkID8gMCA6IDEwO1xufVxuZnVuY3Rpb24gZ2V0VGV4dEJhc2VsaW5lKHBhcmFsbGVsLCBsYWJlbFJvdGF0aW9uLCBzaWRlRmxhZywgcGFyYWxsZWxGbGlwRmxhZykge1xuICBpZiAocGFyYWxsZWwgJiYgIWxhYmVsUm90YXRpb24pIHtcbiAgICByZXR1cm4gc2lkZUZsYWcgKiBwYXJhbGxlbEZsaXBGbGFnID09PSAtMSA/IFwiaGFuZ2luZ1wiIDogXCJib3R0b21cIjtcbiAgfVxuICByZXR1cm4gXCJtaWRkbGVcIjtcbn1cbmZ1bmN0aW9uIGdldFRleHRBbGlnbihwYXJhbGxlbCwgbGFiZWxSb3RhdGlvbiwgbGFiZWxBdXRvUm90YXRpb24sIHNpZGVGbGFnLCByZWd1bGFyRmxpcEZsYWcpIHtcbiAgY29uc3QgbGFiZWxSb3RhdGVkID0gbGFiZWxSb3RhdGlvbiA+IDAgJiYgbGFiZWxSb3RhdGlvbiA8PSBNYXRoLlBJO1xuICBjb25zdCBsYWJlbEF1dG9Sb3RhdGVkID0gbGFiZWxBdXRvUm90YXRpb24gPiAwICYmIGxhYmVsQXV0b1JvdGF0aW9uIDw9IE1hdGguUEk7XG4gIGNvbnN0IGFsaWduRmxhZyA9IGxhYmVsUm90YXRlZCB8fCBsYWJlbEF1dG9Sb3RhdGVkID8gLTEgOiAxO1xuICBpZiAocGFyYWxsZWwpIHtcbiAgICBpZiAobGFiZWxSb3RhdGlvbiB8fCBsYWJlbEF1dG9Sb3RhdGlvbikge1xuICAgICAgaWYgKHNpZGVGbGFnICogYWxpZ25GbGFnID09PSAtMSkge1xuICAgICAgICByZXR1cm4gXCJlbmRcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiY2VudGVyXCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNpZGVGbGFnICogcmVndWxhckZsaXBGbGFnID09PSAtMSkge1xuICAgIHJldHVybiBcImVuZFwiO1xuICB9XG4gIHJldHVybiBcInN0YXJ0XCI7XG59XG5mdW5jdGlvbiBjcmVhdGVMYWJlbERhdGEodGlja0RhdGEsIGxhYmVsWCwgbGFiZWxNYXRyaXgsIHRleHRNZWFzdXJlcikge1xuICBjb25zdCBsYWJlbERhdGEgPSBbXTtcbiAgZm9yIChjb25zdCB7IHRpY2tMYWJlbDogdGV4dDIsIHRyYW5zbGF0aW9uWSB9IG9mIHRpY2tEYXRhKSB7XG4gICAgaWYgKCF0ZXh0MilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSB0ZXh0TWVhc3VyZXIubWVhc3VyZUxpbmVzKHRleHQyKTtcbiAgICBjb25zdCBiYm94ID0gbmV3IEJCb3gobGFiZWxYLCB0cmFuc2xhdGlvblksIHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgY29uc3QgdHJhbnNsYXRlZEJCb3ggPSBuZXcgQkJveChsYWJlbFgsIHRyYW5zbGF0aW9uWSwgMCwgMCk7XG4gICAgbGFiZWxNYXRyaXgudHJhbnNmb3JtQkJveCh0cmFuc2xhdGVkQkJveCwgYmJveCk7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBiYm94O1xuICAgIGxhYmVsRGF0YS5wdXNoKHtcbiAgICAgIHBvaW50OiB7IHgsIHkgfSxcbiAgICAgIGxhYmVsOiB7IHRleHQ6IHRleHQyLCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBsYWJlbERhdGE7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdmFsdWUudHNcbmZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd24odmFsdWUsIFwidG9TdHJpbmdcIikgJiYgaXNTdHJpbmcodmFsdWUudG9TdHJpbmcoKSk7XG59XG5mdW5jdGlvbiBpc051bWJlck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duKHZhbHVlLCBcInZhbHVlT2ZcIikgJiYgaXNGaW5pdGVOdW1iZXIodmFsdWUudmFsdWVPZigpKTtcbn1cbmZ1bmN0aW9uIGlzQ29udGludW91cyh2YWx1ZSkge1xuICByZXR1cm4gaXNGaW5pdGVOdW1iZXIodmFsdWUpIHx8IGlzVmFsaWREYXRlKHZhbHVlKSB8fCBpc051bWJlck9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBjaGVja0RhdHVtKHZhbHVlLCBpc0NvbnRpbnVvdXNTY2FsZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAoIWlzQ29udGludW91c1NjYWxlIHx8IGlzQ29udGludW91cyh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtSW50ZWdyYXRlZENhdGVnb3J5VmFsdWUodmFsdWUpIHtcbiAgaWYgKGlzU3RyaW5nT2JqZWN0KHZhbHVlKSAmJiBPYmplY3QuaGFzT3duKHZhbHVlLCBcImlkXCIpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmlkO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY3Jvc3NsaW5lL2Nyb3NzTGluZS50c1xudmFyIE1BVENISU5HX0NST1NTTElORV9UWVBFID0gKHByb3BlcnR5KSA9PiB7XG4gIHJldHVybiBwcm9wZXJ0eSA9PT0gXCJ2YWx1ZVwiID8gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICAgKF8sIGN0eCkgPT4gY3R4LnRhcmdldFtcInR5cGVcIl0gPT09IFwibGluZVwiLFxuICAgIChjdHgpID0+IGN0eC50YXJnZXRbXCJ0eXBlXCJdID09PSBcInJhbmdlXCIgPyBgY3Jvc3NMaW5lIHR5cGUgJ3JhbmdlJyB0byBoYXZlIGEgJ3JhbmdlJyBwcm9wZXJ0eSBpbnN0ZWFkIG9mICd2YWx1ZSdgIDogYGNyb3NzTGluZSBwcm9wZXJ0eSAndHlwZScgdG8gYmUgJ2xpbmUnYFxuICApIDogcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICAgKF8sIGN0eCkgPT4gY3R4LnRhcmdldFtcInR5cGVcIl0gPT09IFwicmFuZ2VcIixcbiAgICAoY3R4KSA9PiBjdHgudGFyZ2V0LnR5cGUgPT09IFwibGluZVwiID8gYGNyb3NzTGluZSB0eXBlICdsaW5lJyB0byBoYXZlIGEgJ3ZhbHVlJyBwcm9wZXJ0eSBpbnN0ZWFkIG9mICdyYW5nZSdgIDogYGNyb3NzTGluZSBwcm9wZXJ0eSAndHlwZScgdG8gYmUgJ3JhbmdlJ2BcbiAgKTtcbn07XG52YXIgdmFsaWRhdGVDcm9zc0xpbmVWYWx1ZXMgPSAodHlwZSwgdmFsdWUsIHJhbmdlMywgc2NhbGUyLCB2aXNpYmlsaXR5Q2hlY2spID0+IHtcbiAgY29uc3QgbGluZUNyb3NzTGluZSA9IHR5cGUgPT09IFwibGluZVwiICYmIHZhbHVlICE9PSB2b2lkIDA7XG4gIGNvbnN0IHJhbmdlQ3Jvc3NMaW5lID0gdHlwZSA9PT0gXCJyYW5nZVwiICYmIHJhbmdlMyAhPT0gdm9pZCAwO1xuICBpZiAoIWxpbmVDcm9zc0xpbmUgJiYgIXJhbmdlQ3Jvc3NMaW5lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgW3N0YXJ0MiwgZW5kMl0gPSByYW5nZTMgPz8gW3ZhbHVlLCB2b2lkIDBdO1xuICBjb25zdCBpc0NvbnRpbnVvdXMyID0gQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikgfHwgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpO1xuICBjb25zdCB2YWxpZFN0YXJ0ID0gY2hlY2tEYXR1bShzdGFydDIsIGlzQ29udGludW91czIpICYmICFpc05hTihzY2FsZTIuY29udmVydChzdGFydDIpKTtcbiAgY29uc3QgdmFsaWRFbmQgPSBjaGVja0RhdHVtKGVuZDIsIGlzQ29udGludW91czIpICYmICFpc05hTihzY2FsZTIuY29udmVydChlbmQyKSk7XG4gIGlmIChsaW5lQ3Jvc3NMaW5lICYmIHZhbGlkU3RhcnQgfHwgcmFuZ2VDcm9zc0xpbmUgJiYgdmFsaWRTdGFydCAmJiB2YWxpZEVuZCkge1xuICAgIHJldHVybiB2aXNpYmlsaXR5Q2hlY2s/LigpID8/IHRydWU7XG4gIH1cbiAgY29uc3QgbWVzc2FnZSA9IFtgRXhwZWN0aW5nIGNyb3NzTGluZWBdO1xuICBpZiAocmFuZ2VDcm9zc0xpbmUpIHtcbiAgICBpZiAoIXZhbGlkU3RhcnQpIHtcbiAgICAgIG1lc3NhZ2UucHVzaChgcmFuZ2Ugc3RhcnQgJHtzdHJpbmdpZnlWYWx1ZShzdGFydDIpfWApO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkRW5kKSB7XG4gICAgICBtZXNzYWdlLnB1c2goYCR7dmFsaWRTdGFydCA/IFwiXCIgOiBcImFuZCBcIn1yYW5nZSBlbmQgJHtzdHJpbmdpZnlWYWx1ZShlbmQyKX1gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZS5wdXNoKGB2YWx1ZSAke3N0cmluZ2lmeVZhbHVlKHN0YXJ0Mil9YCk7XG4gIH1cbiAgbWVzc2FnZS5wdXNoKGB0byBtYXRjaCB0aGUgYXhpcyBzY2FsZSBkb21haW4uYCk7XG4gIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKG1lc3NhZ2Uuam9pbihcIiBcIikpO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jcm9zc2xpbmUvY3Jvc3NMaW5lTGFiZWxQb3NpdGlvbi50c1xudmFyIGhvcml6b250YWxDcm9zc2xpbmVUcmFuc2xhdGlvbkRpcmVjdGlvbnMgPSB7XG4gIHRvcDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgYm90dG9tOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGxlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIHJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIFwidG9wLWxlZnRcIjogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgXCJ0b3AtcmlnaHRcIjogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIFwiYm90dG9tLWxlZnRcIjogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBcImJvdHRvbS1yaWdodFwiOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBpbnNpZGU6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgXCJpbnNpZGUtbGVmdFwiOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIFwiaW5zaWRlLXJpZ2h0XCI6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIFwiaW5zaWRlLXRvcFwiOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIFwiaW5zaWRlLWJvdHRvbVwiOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxuICBcImluc2lkZS10b3AtbGVmdFwiOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIFwiaW5zaWRlLWJvdHRvbS1sZWZ0XCI6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIFwiaW5zaWRlLXRvcC1yaWdodFwiOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBcImluc2lkZS1ib3R0b20tcmlnaHRcIjogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH1cbn07XG52YXIgdmVydGljYWxDcm9zc0xpbmVUcmFuc2xhdGlvbkRpcmVjdGlvbnMgPSB7XG4gIHRvcDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICBib3R0b206IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIGxlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIHJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIFwidG9wLWxlZnRcIjogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIFwidG9wLXJpZ2h0XCI6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIFwiYm90dG9tLWxlZnRcIjogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgXCJib3R0b20tcmlnaHRcIjogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBpbnNpZGU6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgXCJpbnNpZGUtbGVmdFwiOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIFwiaW5zaWRlLXJpZ2h0XCI6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIFwiaW5zaWRlLXRvcFwiOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICBcImluc2lkZS1ib3R0b21cIjogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICBcImluc2lkZS10b3AtbGVmdFwiOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBcImluc2lkZS1ib3R0b20tbGVmdFwiOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIFwiaW5zaWRlLXRvcC1yaWdodFwiOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgXCJpbnNpZGUtYm90dG9tLXJpZ2h0XCI6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH1cbn07XG5mdW5jdGlvbiBjYWxjdWxhdGVMYWJlbFRyYW5zbGF0aW9uKHtcbiAgeURpcmVjdGlvbixcbiAgcGFkZGluZyA9IDAsXG4gIHBvc2l0aW9uID0gXCJ0b3BcIixcbiAgYmJveFxufSkge1xuICBjb25zdCBjcm9zc0xpbmVUcmFuc2xhdGlvbkRpcmVjdGlvbnMgPSB5RGlyZWN0aW9uID8gaG9yaXpvbnRhbENyb3NzbGluZVRyYW5zbGF0aW9uRGlyZWN0aW9ucyA6IHZlcnRpY2FsQ3Jvc3NMaW5lVHJhbnNsYXRpb25EaXJlY3Rpb25zO1xuICBjb25zdCB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbiwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uIH0gPSBjcm9zc0xpbmVUcmFuc2xhdGlvbkRpcmVjdGlvbnNbcG9zaXRpb25dO1xuICBjb25zdCB4VHJhbnNsYXRpb24gPSB4VHJhbnNsYXRpb25EaXJlY3Rpb24gKiAocGFkZGluZyArIGJib3gud2lkdGggLyAyKTtcbiAgY29uc3QgeVRyYW5zbGF0aW9uID0geVRyYW5zbGF0aW9uRGlyZWN0aW9uICogKHBhZGRpbmcgKyBiYm94LmhlaWdodCAvIDIpO1xuICByZXR1cm4ge1xuICAgIHhUcmFuc2xhdGlvbixcbiAgICB5VHJhbnNsYXRpb25cbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUxhYmVsQ2hhcnRQYWRkaW5nKHtcbiAgeURpcmVjdGlvbixcbiAgYmJveCxcbiAgcGFkZGluZyA9IDAsXG4gIHBvc2l0aW9uID0gXCJ0b3BcIlxufSkge1xuICBjb25zdCBjaGFydFBhZGRpbmcgPSB7fTtcbiAgaWYgKHBvc2l0aW9uLnN0YXJ0c1dpdGgoXCJpbnNpZGVcIikpXG4gICAgcmV0dXJuIGNoYXJ0UGFkZGluZztcbiAgaWYgKHBvc2l0aW9uID09PSBcInRvcFwiICYmICF5RGlyZWN0aW9uKSB7XG4gICAgY2hhcnRQYWRkaW5nLnRvcCA9IHBhZGRpbmcgKyBiYm94LmhlaWdodDtcbiAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gXCJib3R0b21cIiAmJiAheURpcmVjdGlvbikge1xuICAgIGNoYXJ0UGFkZGluZy5ib3R0b20gPSBwYWRkaW5nICsgYmJveC5oZWlnaHQ7XG4gIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwibGVmdFwiICYmIHlEaXJlY3Rpb24pIHtcbiAgICBjaGFydFBhZGRpbmcubGVmdCA9IHBhZGRpbmcgKyBiYm94LndpZHRoO1xuICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBcInJpZ2h0XCIgJiYgeURpcmVjdGlvbikge1xuICAgIGNoYXJ0UGFkZGluZy5yaWdodCA9IHBhZGRpbmcgKyBiYm94LndpZHRoO1xuICB9XG4gIHJldHVybiBjaGFydFBhZGRpbmc7XG59XG52YXIgUE9TSVRJT05fVE9QX0NPT1JESU5BVEVTID0gKHsgZGlyZWN0aW9uLCB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xuICBpZiAoZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovKSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCAvIDIsIHk6IHlTdGFydCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhFbmQsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogKHlTdGFydCArIHlFbmQpIC8gMiB9O1xuICB9XG59O1xudmFyIFBPU0lUSU9OX0xFRlRfQ09PUkRJTkFURVMgPSAoeyBkaXJlY3Rpb24sIHhTdGFydCwgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLykge1xuICAgIHJldHVybiB7IHg6IHhTdGFydCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiAoeVN0YXJ0ICsgeUVuZCkgLyAyIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCAvIDIsIHk6IHlTdGFydCB9O1xuICB9XG59O1xudmFyIFBPU0lUSU9OX1JJR0hUX0NPT1JESU5BVEVTID0gKHsgZGlyZWN0aW9uLCB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xuICBpZiAoZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovKSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiAoeVN0YXJ0ICsgeUVuZCkgLyAyIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCAvIDIsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogeUVuZCB9O1xuICB9XG59O1xudmFyIFBPU0lUSU9OX0JPVFRPTV9DT09SRElOQVRFUyA9ICh7IGRpcmVjdGlvbiwgeFN0YXJ0LCB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xuICBpZiAoZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovKSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCAvIDIsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogeUVuZCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhTdGFydCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiAoeVN0YXJ0ICsgeUVuZCkgLyAyIH07XG4gIH1cbn07XG52YXIgUE9TSVRJT05fSU5TSURFX0NPT1JESU5BVEVTID0gKHsgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgcmV0dXJuIHsgeDogeEVuZCAvIDIsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogKHlTdGFydCArIHlFbmQpIC8gMiB9O1xufTtcbnZhciBQT1NJVElPTl9UT1BfTEVGVF9DT09SRElOQVRFUyA9ICh7IGRpcmVjdGlvbiwgeFN0YXJ0LCB4RW5kLCB5U3RhcnQgfSkgPT4ge1xuICBpZiAoZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovKSB7XG4gICAgcmV0dXJuIHsgeDogeFN0YXJ0IC8gMiwgeTogeVN0YXJ0IH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCwgeTogeVN0YXJ0IH07XG4gIH1cbn07XG52YXIgUE9TSVRJT05fQk9UVE9NX0xFRlRfQ09PUkRJTkFURVMgPSAoeyBkaXJlY3Rpb24sIHhTdGFydCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLykge1xuICAgIHJldHVybiB7IHg6IHhTdGFydCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiB5RW5kIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgeDogeFN0YXJ0LCB5OiB5U3RhcnQgfTtcbiAgfVxufTtcbnZhciBQT1NJVElPTl9UT1BfUklHSFRfQ09PUkRJTkFURVMgPSAoeyBkaXJlY3Rpb24sIHhFbmQsIHlTdGFydCwgeUVuZCB9KSA9PiB7XG4gIGlmIChkaXJlY3Rpb24gPT09IFwieVwiIC8qIFkgKi8pIHtcbiAgICByZXR1cm4geyB4OiB4RW5kLCB5OiB5U3RhcnQgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB4OiB4RW5kLCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6IHlFbmQgfTtcbiAgfVxufTtcbnZhciBQT1NJVElPTl9CT1RUT01fUklHSFRfQ09PUkRJTkFURVMgPSAoeyBkaXJlY3Rpb24sIHhTdGFydCwgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLykge1xuICAgIHJldHVybiB7IHg6IHhFbmQsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogeUVuZCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhTdGFydCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiB5RW5kIH07XG4gIH1cbn07XG52YXIgbGFiZWxEaXJlY3Rpb25IYW5kbGluZyA9IHtcbiAgdG9wOiB7IGM6IFBPU0lUSU9OX1RPUF9DT09SRElOQVRFUyB9LFxuICBib3R0b206IHsgYzogUE9TSVRJT05fQk9UVE9NX0NPT1JESU5BVEVTIH0sXG4gIGxlZnQ6IHsgYzogUE9TSVRJT05fTEVGVF9DT09SRElOQVRFUyB9LFxuICByaWdodDogeyBjOiBQT1NJVElPTl9SSUdIVF9DT09SRElOQVRFUyB9LFxuICBcInRvcC1sZWZ0XCI6IHsgYzogUE9TSVRJT05fVE9QX0xFRlRfQ09PUkRJTkFURVMgfSxcbiAgXCJ0b3AtcmlnaHRcIjogeyBjOiBQT1NJVElPTl9UT1BfUklHSFRfQ09PUkRJTkFURVMgfSxcbiAgXCJib3R0b20tbGVmdFwiOiB7IGM6IFBPU0lUSU9OX0JPVFRPTV9MRUZUX0NPT1JESU5BVEVTIH0sXG4gIFwiYm90dG9tLXJpZ2h0XCI6IHsgYzogUE9TSVRJT05fQk9UVE9NX1JJR0hUX0NPT1JESU5BVEVTIH0sXG4gIGluc2lkZTogeyBjOiBQT1NJVElPTl9JTlNJREVfQ09PUkRJTkFURVMgfSxcbiAgXCJpbnNpZGUtbGVmdFwiOiB7IGM6IFBPU0lUSU9OX0xFRlRfQ09PUkRJTkFURVMgfSxcbiAgXCJpbnNpZGUtcmlnaHRcIjogeyBjOiBQT1NJVElPTl9SSUdIVF9DT09SRElOQVRFUyB9LFxuICBcImluc2lkZS10b3BcIjogeyBjOiBQT1NJVElPTl9UT1BfQ09PUkRJTkFURVMgfSxcbiAgXCJpbnNpZGUtYm90dG9tXCI6IHsgYzogUE9TSVRJT05fQk9UVE9NX0NPT1JESU5BVEVTIH0sXG4gIFwiaW5zaWRlLXRvcC1sZWZ0XCI6IHsgYzogUE9TSVRJT05fVE9QX0xFRlRfQ09PUkRJTkFURVMgfSxcbiAgXCJpbnNpZGUtYm90dG9tLWxlZnRcIjogeyBjOiBQT1NJVElPTl9CT1RUT01fTEVGVF9DT09SRElOQVRFUyB9LFxuICBcImluc2lkZS10b3AtcmlnaHRcIjogeyBjOiBQT1NJVElPTl9UT1BfUklHSFRfQ09PUkRJTkFURVMgfSxcbiAgXCJpbnNpZGUtYm90dG9tLXJpZ2h0XCI6IHsgYzogUE9TSVRJT05fQk9UVE9NX1JJR0hUX0NPT1JESU5BVEVTIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2Nyb3NzbGluZS9jYXJ0ZXNpYW5Dcm9zc0xpbmUudHNcbnZhciBDUk9TU0xJTkVfTEFCRUxfUE9TSVRJT04gPSBVTklPTihcbiAgW1xuICAgIFwidG9wXCIsXG4gICAgXCJsZWZ0XCIsXG4gICAgXCJyaWdodFwiLFxuICAgIFwiYm90dG9tXCIsXG4gICAgXCJ0b3AtbGVmdFwiLFxuICAgIFwidG9wLXJpZ2h0XCIsXG4gICAgXCJib3R0b20tbGVmdFwiLFxuICAgIFwiYm90dG9tLXJpZ2h0XCIsXG4gICAgXCJpbnNpZGVcIixcbiAgICBcImluc2lkZS1sZWZ0XCIsXG4gICAgXCJpbnNpZGUtcmlnaHRcIixcbiAgICBcImluc2lkZS10b3BcIixcbiAgICBcImluc2lkZS1ib3R0b21cIixcbiAgICBcImluc2lkZS10b3AtbGVmdFwiLFxuICAgIFwiaW5zaWRlLWJvdHRvbS1sZWZ0XCIsXG4gICAgXCJpbnNpZGUtdG9wLXJpZ2h0XCIsXG4gICAgXCJpbnNpZGUtYm90dG9tLXJpZ2h0XCJcbiAgXSxcbiAgXCJjcm9zc0xpbmUgbGFiZWwgcG9zaXRpb25cIlxuKTtcbnZhciBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZm9udFNpemUgPSAxNDtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBcIlZlcmRhbmEsIHNhbnMtc2VyaWZcIjtcbiAgICB0aGlzLnBhZGRpbmcgPSA1O1xuICAgIHRoaXMuY29sb3IgPSBcInJnYmEoODcsIDg3LCA4NywgMSlcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfU1RZTEUsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1dFSUdIVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwiZm9udFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDUk9TU0xJTkVfTEFCRUxfUE9TSVRJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcInBhcmFsbGVsXCIsIDIpO1xudmFyIENhcnRlc2lhbkNyb3NzTGluZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IENhcnRlc2lhbkNyb3NzTGluZUxhYmVsKCk7XG4gICAgdGhpcy5zY2FsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNsaXBwZWRSYW5nZSA9IFstSW5maW5pdHksIEluZmluaXR5XTtcbiAgICB0aGlzLmdyaWRMZW5ndGggPSAwO1xuICAgIHRoaXMuc2lkZUZsYWcgPSAtMTtcbiAgICB0aGlzLnBhcmFsbGVsRmxpcFJvdGF0aW9uID0gMDtcbiAgICB0aGlzLnJlZ3VsYXJGbGlwUm90YXRpb24gPSAwO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gXCJ4XCIgLyogWCAqLztcbiAgICB0aGlzLnJhbmdlR3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiB0aGlzLmlkIH0pO1xuICAgIHRoaXMubGluZUdyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogdGhpcy5pZCB9KTtcbiAgICB0aGlzLmxhYmVsR3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiB0aGlzLmlkIH0pO1xuICAgIHRoaXMuY3Jvc3NMaW5lUmFuZ2UgPSBuZXcgUmFuZ2UoKTtcbiAgICB0aGlzLmNyb3NzTGluZUxhYmVsID0gbmV3IFRyYW5zZm9ybWFibGVUZXh0KCk7XG4gICAgdGhpcy5sYWJlbFBvaW50ID0gdm9pZCAwO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMuc3RhcnRMaW5lID0gZmFsc2U7XG4gICAgdGhpcy5lbmRMaW5lID0gZmFsc2U7XG4gICAgdGhpcy5pc1JhbmdlID0gZmFsc2U7XG4gICAgdGhpcy5faXNSYW5nZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxpbmVHcm91cC5hcHBlbmQodGhpcy5jcm9zc0xpbmVSYW5nZSk7XG4gICAgdGhpcy5sYWJlbEdyb3VwLmFwcGVuZCh0aGlzLmNyb3NzTGluZUxhYmVsKTtcbiAgICB0aGlzLmNyb3NzTGluZVJhbmdlLnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gIH1cbiAgdXBkYXRlKHZpc2libGUpIHtcbiAgICBjb25zdCB7IGVuYWJsZWQsIGRhdGEsIHR5cGUsIHZhbHVlLCByYW5nZTogcmFuZ2UzLCBzY2FsZTogc2NhbGUyIH0gPSB0aGlzO1xuICAgIGlmICghdHlwZSB8fCAhc2NhbGUyIHx8ICFlbmFibGVkIHx8ICF2aXNpYmxlIHx8ICF2YWxpZGF0ZUNyb3NzTGluZVZhbHVlcyh0eXBlLCB2YWx1ZSwgcmFuZ2UzLCBzY2FsZTIpIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnJhbmdlR3JvdXAudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5saW5lR3JvdXAudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5sYWJlbEdyb3VwLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yYW5nZUdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIHRoaXMubGluZUdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIHRoaXMubGFiZWxHcm91cC52aXNpYmxlID0gdmlzaWJsZTtcbiAgICB0aGlzLnVwZGF0ZU5vZGVzKCk7XG4gICAgY29uc3QgeyBpc1JhbmdlIH0gPSB0aGlzO1xuICAgIGlmIChpc1JhbmdlICE9PSB0aGlzLl9pc1JhbmdlKSB7XG4gICAgICBpZiAoaXNSYW5nZSkge1xuICAgICAgICB0aGlzLnJhbmdlR3JvdXAuYXBwZW5kQ2hpbGQodGhpcy5jcm9zc0xpbmVSYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxpbmVHcm91cC5hcHBlbmRDaGlsZCh0aGlzLmNyb3NzTGluZVJhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faXNSYW5nZSA9IGlzUmFuZ2U7XG4gIH1cbiAgY2FsY3VsYXRlTGF5b3V0KHZpc2libGUsIHJldmVyc2VkQXhpcykge1xuICAgIGlmICghdmlzaWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBzY2FsZTogc2NhbGUyLFxuICAgICAgZ3JpZExlbmd0aCxcbiAgICAgIHNpZGVGbGFnLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgbGFiZWw6IHsgcG9zaXRpb24gPSBcInRvcFwiIH0sXG4gICAgICBjbGlwcGVkUmFuZ2UsXG4gICAgICBzdHJva2VXaWR0aCA9IDBcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICBpZiAoIXNjYWxlMilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBiYW5kd2lkdGggPSBzY2FsZTIuYmFuZHdpZHRoID8/IDA7XG4gICAgY29uc3Qgc3RlcCA9IHNjYWxlMi5zdGVwID8/IDA7XG4gICAgY29uc3QgcGFkZGluZyA9IChyZXZlcnNlZEF4aXMgPyAtMSA6IDEpICogKHNjYWxlMiBpbnN0YW5jZW9mIEJhbmRTY2FsZSA/IChzdGVwIC0gYmFuZHdpZHRoKSAvIDIgOiAwKTtcbiAgICBjb25zdCBbeFN0YXJ0LCB4RW5kXSA9IFswLCBzaWRlRmxhZyAqIGdyaWRMZW5ndGhdO1xuICAgIGxldCBbeVN0YXJ0LCB5RW5kXSA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICBjb25zdCBvcmRpbmFsVGltZVNjYWxlUGFkZGluZyA9IHlFbmQgPT09IHZvaWQgMCAmJiBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMikgPyBiYW5kd2lkdGggLyAyICsgcGFkZGluZyA6IDA7XG4gICAgbGV0IFtjbGFtcGVkWVN0YXJ0LCBjbGFtcGVkWUVuZF0gPSBbXG4gICAgICBOdW1iZXIoc2NhbGUyLmNvbnZlcnQoeVN0YXJ0LCB0cnVlKSkgLSBwYWRkaW5nICsgb3JkaW5hbFRpbWVTY2FsZVBhZGRpbmcsXG4gICAgICBzY2FsZTIuY29udmVydCh5RW5kLCB0cnVlKSArIGJhbmR3aWR0aCArIHBhZGRpbmdcbiAgICBdO1xuICAgIGNsYW1wZWRZU3RhcnQgPSBjbGFtcEFycmF5KGNsYW1wZWRZU3RhcnQsIGNsaXBwZWRSYW5nZSk7XG4gICAgY2xhbXBlZFlFbmQgPSBjbGFtcEFycmF5KGNsYW1wZWRZRW5kLCBjbGlwcGVkUmFuZ2UpO1xuICAgIFt5U3RhcnQsIHlFbmRdID0gW051bWJlcihzY2FsZTIuY29udmVydCh5U3RhcnQpKSArIG9yZGluYWxUaW1lU2NhbGVQYWRkaW5nLCBzY2FsZTIuY29udmVydCh5RW5kKSArIGJhbmR3aWR0aF07XG4gICAgY29uc3QgdmFsaWRSYW5nZSA9ICh5U3RhcnQgPT09IGNsYW1wZWRZU3RhcnQgfHwgeUVuZCA9PT0gY2xhbXBlZFlFbmQgfHwgY2xhbXBlZFlTdGFydCAhPT0gY2xhbXBlZFlFbmQpICYmIE1hdGguYWJzKGNsYW1wZWRZRW5kIC0gY2xhbXBlZFlTdGFydCkgPiAwO1xuICAgIGlmICh2YWxpZFJhbmdlICYmIGNsYW1wZWRZU3RhcnQgPiBjbGFtcGVkWUVuZCkge1xuICAgICAgW2NsYW1wZWRZU3RhcnQsIGNsYW1wZWRZRW5kXSA9IFtjbGFtcGVkWUVuZCwgY2xhbXBlZFlTdGFydF07XG4gICAgICBbeVN0YXJ0LCB5RW5kXSA9IFt5RW5kLCB5U3RhcnRdO1xuICAgIH1cbiAgICBpZiAoeVN0YXJ0IC0gcGFkZGluZyA+PSBjbGFtcGVkWVN0YXJ0KVxuICAgICAgeVN0YXJ0IC09IHBhZGRpbmc7XG4gICAgaWYgKHlFbmQgKyBwYWRkaW5nIDw9IGNsYW1wZWRZRW5kKVxuICAgICAgeUVuZCArPSBwYWRkaW5nO1xuICAgIHRoaXMuaXNSYW5nZSA9IHZhbGlkUmFuZ2U7XG4gICAgdGhpcy5zdGFydExpbmUgPSBzdHJva2VXaWR0aCA+IDAgJiYgeVN0YXJ0ID49IGNsYW1wZWRZU3RhcnQgJiYgeVN0YXJ0IDw9IGNsYW1wZWRZU3RhcnQgKyBwYWRkaW5nO1xuICAgIHRoaXMuZW5kTGluZSA9IHN0cm9rZVdpZHRoID4gMCAmJiB5RW5kID49IGNsYW1wZWRZRW5kIC0gYmFuZHdpZHRoIC0gcGFkZGluZyAmJiB5RW5kIDw9IGNsYW1wZWRZRW5kO1xuICAgIGlmICghdmFsaWRSYW5nZSAmJiAhdGhpcy5zdGFydExpbmUgJiYgIXRoaXMuZW5kTGluZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmRhdGEgPSBbY2xhbXBlZFlTdGFydCwgY2xhbXBlZFlFbmRdO1xuICAgIGlmICghdGhpcy5sYWJlbC5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgYyA9IFBPU0lUSU9OX1RPUF9DT09SRElOQVRFUyB9ID0gbGFiZWxEaXJlY3Rpb25IYW5kbGluZ1twb3NpdGlvbl0gPz8ge307XG4gICAgY29uc3QgeyB4OiBsYWJlbFgsIHk6IGxhYmVsWSB9ID0gYyh7XG4gICAgICBkaXJlY3Rpb24sXG4gICAgICB4U3RhcnQsXG4gICAgICB4RW5kLFxuICAgICAgeVN0YXJ0OiBjbGFtcGVkWVN0YXJ0LFxuICAgICAgeUVuZDogY2xhbXBlZFlFbmRcbiAgICB9KTtcbiAgICB0aGlzLmxhYmVsUG9pbnQgPSB7XG4gICAgICB4OiBsYWJlbFgsXG4gICAgICB5OiBsYWJlbFlcbiAgICB9O1xuICB9XG4gIHVwZGF0ZU5vZGVzKCkge1xuICAgIHRoaXMudXBkYXRlUmFuZ2VOb2RlKCk7XG4gICAgaWYgKHRoaXMubGFiZWwuZW5hYmxlZCkge1xuICAgICAgdGhpcy51cGRhdGVMYWJlbCgpO1xuICAgICAgdGhpcy5wb3NpdGlvbkxhYmVsKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVJhbmdlTm9kZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjcm9zc0xpbmVSYW5nZSxcbiAgICAgIHNpZGVGbGFnLFxuICAgICAgZ3JpZExlbmd0aCxcbiAgICAgIGRhdGEsXG4gICAgICBzdGFydExpbmUsXG4gICAgICBlbmRMaW5lLFxuICAgICAgaXNSYW5nZSxcbiAgICAgIGZpbGwsXG4gICAgICBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZTogc3Ryb2tlMixcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgbGluZURhc2hcbiAgICB9ID0gdGhpcztcbiAgICBjcm9zc0xpbmVSYW5nZS54MSA9IDA7XG4gICAgY3Jvc3NMaW5lUmFuZ2UueDIgPSBzaWRlRmxhZyAqIGdyaWRMZW5ndGg7XG4gICAgY3Jvc3NMaW5lUmFuZ2UueTEgPSBkYXRhWzBdO1xuICAgIGNyb3NzTGluZVJhbmdlLnkyID0gZGF0YVsxXTtcbiAgICBjcm9zc0xpbmVSYW5nZS5zdGFydExpbmUgPSBzdGFydExpbmU7XG4gICAgY3Jvc3NMaW5lUmFuZ2UuZW5kTGluZSA9IGVuZExpbmU7XG4gICAgY3Jvc3NMaW5lUmFuZ2UuaXNSYW5nZSA9IGlzUmFuZ2U7XG4gICAgY3Jvc3NMaW5lUmFuZ2UuZmlsbCA9IGZpbGw7XG4gICAgY3Jvc3NMaW5lUmFuZ2UuZmlsbE9wYWNpdHkgPSBmaWxsT3BhY2l0eSA/PyAxO1xuICAgIGNyb3NzTGluZVJhbmdlLnN0cm9rZSA9IHN0cm9rZTI7XG4gICAgY3Jvc3NMaW5lUmFuZ2Uuc3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aCA/PyAxO1xuICAgIGNyb3NzTGluZVJhbmdlLnN0cm9rZU9wYWNpdHkgPSB0aGlzLnN0cm9rZU9wYWNpdHkgPz8gMTtcbiAgICBjcm9zc0xpbmVSYW5nZS5saW5lRGFzaCA9IGxpbmVEYXNoO1xuICB9XG4gIHVwZGF0ZUxhYmVsKCkge1xuICAgIGNvbnN0IHsgY3Jvc3NMaW5lTGFiZWwsIGxhYmVsIH0gPSB0aGlzO1xuICAgIGlmICghbGFiZWwudGV4dClcbiAgICAgIHJldHVybjtcbiAgICBjcm9zc0xpbmVMYWJlbC5mb250U3R5bGUgPSBsYWJlbC5mb250U3R5bGU7XG4gICAgY3Jvc3NMaW5lTGFiZWwuZm9udFdlaWdodCA9IGxhYmVsLmZvbnRXZWlnaHQ7XG4gICAgY3Jvc3NMaW5lTGFiZWwuZm9udFNpemUgPSBsYWJlbC5mb250U2l6ZTtcbiAgICBjcm9zc0xpbmVMYWJlbC5mb250RmFtaWx5ID0gbGFiZWwuZm9udEZhbWlseTtcbiAgICBjcm9zc0xpbmVMYWJlbC5maWxsID0gbGFiZWwuY29sb3I7XG4gICAgY3Jvc3NMaW5lTGFiZWwudGV4dCA9IGxhYmVsLnRleHQ7XG4gIH1cbiAgcG9zaXRpb25MYWJlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjcm9zc0xpbmVMYWJlbCxcbiAgICAgIGxhYmVsUG9pbnQ6IHsgeCA9IHZvaWQgMCwgeSA9IHZvaWQgMCB9ID0ge30sXG4gICAgICBsYWJlbDogeyBwYXJhbGxlbCwgcm90YXRpb24sIHBvc2l0aW9uID0gXCJ0b3BcIiwgcGFkZGluZyA9IDAgfSxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHBhcmFsbGVsRmxpcFJvdGF0aW9uLFxuICAgICAgcmVndWxhckZsaXBSb3RhdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIGlmICh4ID09PSB2b2lkIDAgfHwgeSA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgZGVmYXVsdFJvdGF0aW9uLCBjb25maWd1cmVkUm90YXRpb24gfSA9IGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oe1xuICAgICAgcm90YXRpb24sXG4gICAgICBwYXJhbGxlbCxcbiAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb24sXG4gICAgICBwYXJhbGxlbEZsaXBSb3RhdGlvblxuICAgIH0pO1xuICAgIGNyb3NzTGluZUxhYmVsLnJvdGF0aW9uID0gZGVmYXVsdFJvdGF0aW9uICsgY29uZmlndXJlZFJvdGF0aW9uO1xuICAgIGNyb3NzTGluZUxhYmVsLnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgY3Jvc3NMaW5lTGFiZWwudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICBjb25zdCBiYm94ID0gY3Jvc3NMaW5lTGFiZWwuZ2V0QkJveCgpO1xuICAgIGlmICghYmJveClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB5RGlyZWN0aW9uID0gZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovO1xuICAgIGNvbnN0IHsgeFRyYW5zbGF0aW9uLCB5VHJhbnNsYXRpb24gfSA9IGNhbGN1bGF0ZUxhYmVsVHJhbnNsYXRpb24oe1xuICAgICAgeURpcmVjdGlvbixcbiAgICAgIHBhZGRpbmcsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIGJib3hcbiAgICB9KTtcbiAgICBjcm9zc0xpbmVMYWJlbC50cmFuc2xhdGlvblggPSB4ICsgeFRyYW5zbGF0aW9uO1xuICAgIGNyb3NzTGluZUxhYmVsLnRyYW5zbGF0aW9uWSA9IHkgKyB5VHJhbnNsYXRpb247XG4gIH1cbiAgZ2V0UmFuZ2UoKSB7XG4gICAgY29uc3QgeyB2YWx1ZSwgcmFuZ2U6IHJhbmdlMywgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICBjb25zdCBpc0NvbnRpbnVvdXMyID0gQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikgfHwgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpO1xuICAgIGNvbnN0IHN0YXJ0MiA9IHJhbmdlMz8uWzBdID8/IHZhbHVlO1xuICAgIGxldCBlbmQyID0gcmFuZ2UzPy5bMV07XG4gICAgaWYgKCFpc0NvbnRpbnVvdXMyICYmIGVuZDIgPT09IHZvaWQgMCkge1xuICAgICAgZW5kMiA9IHN0YXJ0MjtcbiAgICB9XG4gICAgaWYgKGlzQ29udGludW91czIgJiYgc3RhcnQyID09PSBlbmQyKSB7XG4gICAgICBlbmQyID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gW3N0YXJ0MiwgZW5kMl07XG4gIH1cbiAgY29tcHV0ZUxhYmVsQkJveCgpIHtcbiAgICBjb25zdCB7IGxhYmVsIH0gPSB0aGlzO1xuICAgIGlmICghbGFiZWwuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ZW1wVGV4dCA9IG5ldyBUcmFuc2Zvcm1hYmxlVGV4dCgpO1xuICAgIHRlbXBUZXh0LmZvbnRGYW1pbHkgPSBsYWJlbC5mb250RmFtaWx5O1xuICAgIHRlbXBUZXh0LmZvbnRTaXplID0gbGFiZWwuZm9udFNpemU7XG4gICAgdGVtcFRleHQuZm9udFN0eWxlID0gbGFiZWwuZm9udFN0eWxlO1xuICAgIHRlbXBUZXh0LmZvbnRXZWlnaHQgPSBsYWJlbC5mb250V2VpZ2h0O1xuICAgIHRlbXBUZXh0LnRleHQgPSBsYWJlbC50ZXh0O1xuICAgIGNvbnN0IHtcbiAgICAgIGxhYmVsUG9pbnQ6IHsgeCA9IHZvaWQgMCwgeSA9IHZvaWQgMCB9ID0ge30sXG4gICAgICBsYWJlbDogeyBwYXJhbGxlbCwgcm90YXRpb24sIHBvc2l0aW9uID0gXCJ0b3BcIiwgcGFkZGluZyA9IDAgfSxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHBhcmFsbGVsRmxpcFJvdGF0aW9uLFxuICAgICAgcmVndWxhckZsaXBSb3RhdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIGlmICh4ID09PSB2b2lkIDAgfHwgeSA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgY29uZmlndXJlZFJvdGF0aW9uIH0gPSBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKHtcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgcGFyYWxsZWwsXG4gICAgICByZWd1bGFyRmxpcFJvdGF0aW9uLFxuICAgICAgcGFyYWxsZWxGbGlwUm90YXRpb25cbiAgICB9KTtcbiAgICB0ZW1wVGV4dC5yb3RhdGlvbiA9IGNvbmZpZ3VyZWRSb3RhdGlvbjtcbiAgICB0ZW1wVGV4dC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgIHRlbXBUZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgY29uc3QgYmJveCA9IHRlbXBUZXh0LmdldEJCb3goKTtcbiAgICBpZiAoIWJib3gpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeURpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLztcbiAgICBjb25zdCB7IHhUcmFuc2xhdGlvbiwgeVRyYW5zbGF0aW9uIH0gPSBjYWxjdWxhdGVMYWJlbFRyYW5zbGF0aW9uKHtcbiAgICAgIHlEaXJlY3Rpb24sXG4gICAgICBwYWRkaW5nLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBiYm94XG4gICAgfSk7XG4gICAgdGVtcFRleHQueCA9IHggKyB4VHJhbnNsYXRpb247XG4gICAgdGVtcFRleHQueSA9IHkgKyB5VHJhbnNsYXRpb247XG4gICAgcmV0dXJuIHRlbXBUZXh0LmdldEJCb3goKTtcbiAgfVxuICBjYWxjdWxhdGVQYWRkaW5nKHBhZGRpbmcpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc1JhbmdlLFxuICAgICAgc3RhcnRMaW5lLFxuICAgICAgZW5kTGluZSxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIGxhYmVsOiB7IHBhZGRpbmc6IGxhYmVsUGFkZGluZyA9IDAsIHBvc2l0aW9uID0gXCJ0b3BcIiB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFpc1JhbmdlICYmICFzdGFydExpbmUgJiYgIWVuZExpbmUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY3Jvc3NMaW5lTGFiZWxCQm94ID0gdGhpcy5jb21wdXRlTGFiZWxCQm94KCk7XG4gICAgaWYgKGNyb3NzTGluZUxhYmVsQkJveD8ueCA9PSBudWxsIHx8IGNyb3NzTGluZUxhYmVsQkJveD8ueSA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNoYXJ0UGFkZGluZyA9IGNhbGN1bGF0ZUxhYmVsQ2hhcnRQYWRkaW5nKHtcbiAgICAgIHlEaXJlY3Rpb246IGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLyxcbiAgICAgIHBhZGRpbmc6IGxhYmVsUGFkZGluZyxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgYmJveDogY3Jvc3NMaW5lTGFiZWxCQm94XG4gICAgfSk7XG4gICAgcGFkZGluZy5sZWZ0ID0gTWF0aC5tYXgocGFkZGluZy5sZWZ0ID8/IDAsIGNoYXJ0UGFkZGluZy5sZWZ0ID8/IDApO1xuICAgIHBhZGRpbmcucmlnaHQgPSBNYXRoLm1heChwYWRkaW5nLnJpZ2h0ID8/IDAsIGNoYXJ0UGFkZGluZy5yaWdodCA/PyAwKTtcbiAgICBwYWRkaW5nLnRvcCA9IE1hdGgubWF4KHBhZGRpbmcudG9wID8/IDAsIGNoYXJ0UGFkZGluZy50b3AgPz8gMCk7XG4gICAgcGFkZGluZy5ib3R0b20gPSBNYXRoLm1heChwYWRkaW5nLmJvdHRvbSA/PyAwLCBjaGFydFBhZGRpbmcuYm90dG9tID8/IDApO1xuICB9XG59O1xuQ2FydGVzaWFuQ3Jvc3NMaW5lLmNsYXNzTmFtZSA9IFwiQ3Jvc3NMaW5lXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShVTklPTihbXCJyYW5nZVwiLCBcImxpbmVcIl0sIFwiYSBjcm9zc0xpbmUgdHlwZVwiKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJ0eXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKE1BVENISU5HX0NST1NTTElORV9UWVBFKFwicmFuZ2VcIiksIEFSUkFZLnJlc3RyaWN0KHsgbGVuZ3RoOiAyIH0pKSwge1xuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcInJhbmdlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTUFUQ0hJTkdfQ1JPU1NMSU5FX1RZUEUoXCJ2YWx1ZVwiKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExJTkVfREFTSCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIENhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3pJbmRleE1hcC50c1xudmFyIFpJbmRleE1hcCA9IC8qIEBfX1BVUkVfXyAqLyAoKFpJbmRleE1hcDIpID0+IHtcbiAgWkluZGV4TWFwMltaSW5kZXhNYXAyW1wiQ0hBUlRfQkFDS0dST1VORFwiXSA9IDBdID0gXCJDSEFSVF9CQUNLR1JPVU5EXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIkFYSVNfR1JJRFwiXSA9IDFdID0gXCJBWElTX0dSSURcIjtcbiAgWkluZGV4TWFwMltaSW5kZXhNYXAyW1wiQVhJU1wiXSA9IDJdID0gXCJBWElTXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIlpPT01fU0VMRUNUSU9OXCJdID0gM10gPSBcIlpPT01fU0VMRUNUSU9OXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIlNFUklFU19DUk9TU0xJTkVfUkFOR0VcIl0gPSA0XSA9IFwiU0VSSUVTX0NST1NTTElORV9SQU5HRVwiO1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJTRVJJRVNfTEFZRVJcIl0gPSA1XSA9IFwiU0VSSUVTX0xBWUVSXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIkFYSVNfRk9SRUdST1VORFwiXSA9IDZdID0gXCJBWElTX0ZPUkVHUk9VTkRcIjtcbiAgWkluZGV4TWFwMltaSW5kZXhNYXAyW1wiU0VSSUVTX0NST1NTSEFJUlwiXSA9IDddID0gXCJTRVJJRVNfQ1JPU1NIQUlSXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIlNFUklFU19DUk9TU0xJTkVfTElORVwiXSA9IDhdID0gXCJTRVJJRVNfQ1JPU1NMSU5FX0xJTkVcIjtcbiAgWkluZGV4TWFwMltaSW5kZXhNYXAyW1wiU0VSSUVTX0FOTk9UQVRJT05cIl0gPSA5XSA9IFwiU0VSSUVTX0FOTk9UQVRJT05cIjtcbiAgWkluZGV4TWFwMltaSW5kZXhNYXAyW1wiQ0hBUlRfQU5OT1RBVElPTlwiXSA9IDEwXSA9IFwiQ0hBUlRfQU5OT1RBVElPTlwiO1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJDSEFSVF9BTk5PVEFUSU9OX0ZPQ1VTRURcIl0gPSAxMV0gPSBcIkNIQVJUX0FOTk9UQVRJT05fRk9DVVNFRFwiO1xuICBaSW5kZXhNYXAyW1pJbmRleE1hcDJbXCJTVEFUVVNfQkFSXCJdID0gMTJdID0gXCJTVEFUVVNfQkFSXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIlNFUklFU19MQUJFTFwiXSA9IDEzXSA9IFwiU0VSSUVTX0xBQkVMXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIkxFR0VORFwiXSA9IDE0XSA9IFwiTEVHRU5EXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIk5BVklHQVRPUlwiXSA9IDE1XSA9IFwiTkFWSUdBVE9SXCI7XG4gIFpJbmRleE1hcDJbWkluZGV4TWFwMltcIkZPUkVHUk9VTkRcIl0gPSAxNl0gPSBcIkZPUkVHUk9VTkRcIjtcbiAgcmV0dXJuIFpJbmRleE1hcDI7XG59KShaSW5kZXhNYXAgfHwge30pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNHcmlkTGluZS50c1xudmFyIEdSSURfU1RZTEVfS0VZUyA9IFtcInN0cm9rZVwiLCBcImxpbmVEYXNoXCJdO1xudmFyIEdSSURfU1RZTEUgPSBBUlJBWV9PRihcbiAgKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgT2JqZWN0LmtleXModmFsdWUpLmV2ZXJ5KChrZXkpID0+IEdSSURfU1RZTEVfS0VZUy5pbmNsdWRlcyhrZXkpKSxcbiAgXCJvYmplY3RzIHdpdGggZ3JpZGxpbmUgc3R5bGUgcHJvcGVydGllcyBzdWNoIGFzICdzdHJva2UnIG9yICdsaW5lRGFzaCdcIlxuKTtcbnZhciBBeGlzR3JpZExpbmUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy53aWR0aCA9IDE7XG4gICAgdGhpcy5zdHlsZSA9IFtcbiAgICAgIHtcbiAgICAgICAgc3Ryb2tlOiB2b2lkIDAsXG4gICAgICAgIGxpbmVEYXNoOiBbXVxuICAgICAgfVxuICAgIF07XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQXhpc0dyaWRMaW5lLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQXhpc0dyaWRMaW5lLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEdSSURfU1RZTEUpXG5dLCBBeGlzR3JpZExpbmUucHJvdG90eXBlLCBcInN0eWxlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2RlZmF1bHQudHNcbmZ1bmN0aW9uIERlZmF1bHQoZGVmYXVsdFZhbHVlLCByZXBsYWNlcyA9IFt2b2lkIDBdKSB7XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoKF8sIF9fLCB2KSA9PiB7XG4gICAgaWYgKHJlcGxhY2VzLmluY2x1ZGVzKHYpKSB7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlKHYpIDogZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc0ludGVydmFsLnRzXG52YXIgVElDS19JTlRFUlZBTCA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAodmFsdWUpID0+IGlzRmluaXRlTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSA+IDAgfHwgdmFsdWUgaW5zdGFuY2VvZiBUaW1lSW50ZXJ2YWwsXG4gIGBhIG5vbi16ZXJvIHBvc2l0aXZlIE51bWJlciB2YWx1ZSBvciwgZm9yIGEgdGltZSBheGlzLCBhIFRpbWUgSW50ZXJ2YWwgc3VjaCBhcyAnYWdDaGFydHMudGltZS5tb250aCdgXG4pO1xudmFyIEF4aXNJbnRlcnZhbCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubWluU3BhY2luZyA9IE5hTjtcbiAgICB0aGlzLm1heFNwYWNpbmcgPSBOYU47XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShUSUNLX0lOVEVSVkFMLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzSW50ZXJ2YWwucHJvdG90eXBlLCBcInN0ZXBcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShBUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0ludGVydmFsLnByb3RvdHlwZSwgXCJ2YWx1ZXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShNSU5fU1BBQ0lORyksXG4gIERlZmF1bHQoTmFOKVxuXSwgQXhpc0ludGVydmFsLnByb3RvdHlwZSwgXCJtaW5TcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTUFYX1NQQUNJTkcpLFxuICBEZWZhdWx0KE5hTilcbl0sIEF4aXNJbnRlcnZhbC5wcm90b3R5cGUsIFwibWF4U3BhY2luZ1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzTGFiZWwudHNcbnZhciBBeGlzTGFiZWwgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuZm9udFNpemUgPSAxMjtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBcIlZlcmRhbmEsIHNhbnMtc2VyaWZcIjtcbiAgICB0aGlzLnNwYWNpbmcgPSA1O1xuICAgIHRoaXMubWluU3BhY2luZyA9IE5hTjtcbiAgICB0aGlzLmNvbG9yID0gXCIjNTc1NzU3XCI7XG4gICAgdGhpcy5hdm9pZENvbGxpc2lvbnMgPSB0cnVlO1xuICAgIHRoaXMubWlycm9yZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmFsbGVsID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzaWRlIG9mIHRoZSBheGlzIGxpbmUgdG8gcG9zaXRpb24gdGhlIGxhYmVscyBvbi5cbiAgICogLTEgPSBsZWZ0IChkZWZhdWx0KVxuICAgKiAxID0gcmlnaHRcbiAgICovXG4gIGdldFNpZGVGbGFnKCkge1xuICAgIHJldHVybiB0aGlzLm1pcnJvcmVkID8gMSA6IC0xO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfU1RZTEUsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9XRUlHSFQsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUi5yZXN0cmljdCh7IG1pbjogMSB9KSlcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiZm9udFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVJfT1JfTkFOKSxcbiAgRGVmYXVsdChOYU4pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcIm1pblNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJhdm9pZENvbGxpc2lvbnNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJtaXJyb3JlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcInBhcmFsbGVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiaXRlbVN0eWxlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImZvcm1hdHRlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc0xpbmUudHNcbnZhciBBeGlzTGluZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLndpZHRoID0gMTtcbiAgICB0aGlzLnN0cm9rZSA9IHZvaWQgMDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBeGlzTGluZS5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEF4aXNMaW5lLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0xpbmUucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzVGljay50c1xudmFyIEF4aXNUaWNrID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLndpZHRoID0gMTtcbiAgICB0aGlzLnNpemUgPSA2O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEF4aXNUaWNrLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQXhpc1RpY2sucHJvdG90eXBlLCBcIndpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQXhpc1RpY2sucHJvdG90eXBlLCBcInNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNUaWNrLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc1RpdGxlLnRzXG52YXIgQXhpc1RpdGxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jYXB0aW9uID0gbmV3IENhcHRpb24oKTtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNwYWNpbmcgPSBDYXB0aW9uLlNNQUxMX1BBRERJTkc7XG4gICAgdGhpcy5mb250U2l6ZSA9IDEwO1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwic2Fucy1zZXJpZlwiO1xuICAgIHRoaXMud3JhcHBpbmcgPSBcImFsd2F5c1wiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEF4aXNUaXRsZS5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1NUWUxFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfV0VJR0hULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVEVYVF9XUkFQKVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJ3cmFwcGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImZvcm1hdHRlclwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzVXRpbC50c1xudmFyIE5pY2VNb2RlID0gLyogQF9fUFVSRV9fICovICgoTmljZU1vZGUyKSA9PiB7XG4gIE5pY2VNb2RlMltOaWNlTW9kZTJbXCJUaWNrQW5kRG9tYWluXCJdID0gMF0gPSBcIlRpY2tBbmREb21haW5cIjtcbiAgTmljZU1vZGUyW05pY2VNb2RlMltcIlRpY2tzT25seVwiXSA9IDFdID0gXCJUaWNrc09ubHlcIjtcbiAgTmljZU1vZGUyW05pY2VNb2RlMltcIk9mZlwiXSA9IDJdID0gXCJPZmZcIjtcbiAgcmV0dXJuIE5pY2VNb2RlMjtcbn0pKE5pY2VNb2RlIHx8IHt9KTtcbmZ1bmN0aW9uIHByZXBhcmVBeGlzQW5pbWF0aW9uQ29udGV4dChheGlzKSB7XG4gIGNvbnN0IFtyZXF1ZXN0ZWRSYW5nZU1pbiwgcmVxdWVzdGVkUmFuZ2VNYXhdID0gZmluZE1pbk1heChheGlzLnJhbmdlKTtcbiAgY29uc3QgbWluID0gTWF0aC5mbG9vcihyZXF1ZXN0ZWRSYW5nZU1pbik7XG4gIGNvbnN0IG1heCA9IE1hdGguY2VpbChyZXF1ZXN0ZWRSYW5nZU1heCk7XG4gIHJldHVybiB7IG1pbiwgbWF4LCB2aXNpYmxlOiBtaW4gIT09IG1heCB9O1xufVxudmFyIGZ1bGxDaXJjbGUgPSBNYXRoLlBJICogMjtcbnZhciBoYWxmQ2lyY2xlID0gZnVsbENpcmNsZSAvIDI7XG5mdW5jdGlvbiBub3JtYWxpc2VFbmRSb3RhdGlvbihzdGFydDIsIGVuZDIpIHtcbiAgY29uc3QgZGlyZWN0RGlzdGFuY2UgPSBNYXRoLmFicyhlbmQyIC0gc3RhcnQyKTtcbiAgaWYgKGRpcmVjdERpc3RhbmNlIDwgaGFsZkNpcmNsZSkge1xuICAgIHJldHVybiBlbmQyO1xuICB9IGVsc2UgaWYgKHN0YXJ0MiA+IGVuZDIpIHtcbiAgICByZXR1cm4gZW5kMiArIGZ1bGxDaXJjbGU7XG4gIH1cbiAgcmV0dXJuIGVuZDIgLSBmdWxsQ2lyY2xlO1xufVxuZnVuY3Rpb24gcHJlcGFyZUF4aXNBbmltYXRpb25GdW5jdGlvbnMoY3R4KSB7XG4gIGNvbnN0IG91dE9mQm91bmRzID0gKHksIHJhbmdlMykgPT4ge1xuICAgIGNvbnN0IFttaW4gPSBjdHgubWluLCBtYXggPSBjdHgubWF4XSA9IGZpbmRNaW5NYXgocmFuZ2UzID8/IFtdKTtcbiAgICByZXR1cm4geSA8IG1pbiB8fCB5ID4gbWF4O1xuICB9O1xuICBjb25zdCB0aWNrID0ge1xuICAgIGZyb21Gbihub2RlLCBkYXR1bSwgc3RhdHVzKSB7XG4gICAgICBsZXQgeSA9IG5vZGUueTEgKyBub2RlLnRyYW5zbGF0aW9uWTtcbiAgICAgIGxldCBvcGFjaXR5ID0gbm9kZS5vcGFjaXR5O1xuICAgICAgaWYgKHN0YXR1cyA9PT0gXCJhZGRlZFwiIHx8IG91dE9mQm91bmRzKG5vZGUuZGF0dW0udHJhbnNsYXRpb25ZLCBub2RlLmRhdHVtLnJhbmdlKSkge1xuICAgICAgICB5ID0gZGF0dW0udHJhbnNsYXRpb25ZO1xuICAgICAgICBvcGFjaXR5ID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHk6IDAsIHRyYW5zbGF0aW9uWTogeSwgb3BhY2l0eSwgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbc3RhdHVzXSB9O1xuICAgIH0sXG4gICAgdG9Gbihfbm9kZSwgZGF0dW0sIHN0YXR1cykge1xuICAgICAgY29uc3QgeSA9IGRhdHVtLnRyYW5zbGF0aW9uWTtcbiAgICAgIGxldCBvcGFjaXR5ID0gMTtcbiAgICAgIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiKSB7XG4gICAgICAgIG9wYWNpdHkgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeTogMCxcbiAgICAgICAgdHJhbnNsYXRpb25ZOiB5LFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBmaW5pc2g6IHtcbiAgICAgICAgICAvLyBTZXQgZXhwbGljaXQgeSBhZnRlciBhbmltYXRpb24gc28gaXQncyBwaXhlbCBhbGlnbmVkXG4gICAgICAgICAgeSxcbiAgICAgICAgICB0cmFuc2xhdGlvblk6IDBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGFwcGx5Rm4obm9kZSwgcHJvcHMpIHtcbiAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhwcm9wcyk7XG4gICAgICBub2RlLnZpc2libGUgPSAhb3V0T2ZCb3VuZHMobm9kZS55KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGxhYmVsID0ge1xuICAgIGZyb21Gbihub2RlLCBuZXdEYXR1bSwgc3RhdHVzKSB7XG4gICAgICBjb25zdCBkYXR1bSA9IG5vZGUucHJldmlvdXNEYXR1bSA/PyBuZXdEYXR1bTtcbiAgICAgIGNvbnN0IHggPSBkYXR1bS54O1xuICAgICAgY29uc3QgeSA9IGRhdHVtLnk7XG4gICAgICBjb25zdCByb3RhdGlvbkNlbnRlclggPSBkYXR1bS5yb3RhdGlvbkNlbnRlclg7XG4gICAgICBsZXQgdHJhbnNsYXRpb25ZID0gTWF0aC5yb3VuZChub2RlLnRyYW5zbGF0aW9uWSk7XG4gICAgICBsZXQgcm90YXRpb24gPSBkYXR1bS5yb3RhdGlvbjtcbiAgICAgIGxldCBvcGFjaXR5ID0gbm9kZS5vcGFjaXR5O1xuICAgICAgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgfHwgb3V0T2ZCb3VuZHMoZGF0dW0ueSwgZGF0dW0ucmFuZ2UpKSB7XG4gICAgICAgIHJvdGF0aW9uID0gbmV3RGF0dW0ucm90YXRpb247XG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJhZGRlZFwiIHx8IG91dE9mQm91bmRzKG5vZGUuZGF0dW0ueSwgbm9kZS5kYXR1bS5yYW5nZSkpIHtcbiAgICAgICAgdHJhbnNsYXRpb25ZID0gTWF0aC5yb3VuZChkYXR1bS50cmFuc2xhdGlvblkpO1xuICAgICAgICBvcGFjaXR5ID0gMDtcbiAgICAgICAgcm90YXRpb24gPSBuZXdEYXR1bS5yb3RhdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHJvdGF0aW9uQ2VudGVyWCxcbiAgICAgICAgdHJhbnNsYXRpb25ZLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbc3RhdHVzXVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRvRm4obm9kZSwgZGF0dW0sIHN0YXR1cykge1xuICAgICAgY29uc3QgeCA9IGRhdHVtLng7XG4gICAgICBjb25zdCB5ID0gZGF0dW0ueTtcbiAgICAgIGNvbnN0IHJvdGF0aW9uQ2VudGVyWCA9IGRhdHVtLnJvdGF0aW9uQ2VudGVyWDtcbiAgICAgIGNvbnN0IHRyYW5zbGF0aW9uWSA9IE1hdGgucm91bmQoZGF0dW0udHJhbnNsYXRpb25ZKTtcbiAgICAgIGxldCByb3RhdGlvbiA9IDA7XG4gICAgICBsZXQgb3BhY2l0eSA9IDE7XG4gICAgICBpZiAoc3RhdHVzID09PSBcImFkZGVkXCIpIHtcbiAgICAgICAgcm90YXRpb24gPSBkYXR1bS5yb3RhdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIikge1xuICAgICAgICBvcGFjaXR5ID0gMDtcbiAgICAgICAgcm90YXRpb24gPSBkYXR1bS5yb3RhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdGF0aW9uID0gbm9ybWFsaXNlRW5kUm90YXRpb24obm9kZS5wcmV2aW91c0RhdHVtPy5yb3RhdGlvbiA/PyBkYXR1bS5yb3RhdGlvbiwgZGF0dW0ucm90YXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgeCwgeSwgcm90YXRpb25DZW50ZXJYLCB0cmFuc2xhdGlvblksIHJvdGF0aW9uLCBvcGFjaXR5LCBmaW5pc2g6IHsgcm90YXRpb246IGRhdHVtLnJvdGF0aW9uIH0gfTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGxpbmUgPSB7XG4gICAgZnJvbUZuKG5vZGUsIGRhdHVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5ub2RlLnByZXZpb3VzRGF0dW0gPz8gZGF0dW0sXG4gICAgICAgIHBoYXNlOiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW1widXBkYXRlZFwiXVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRvRm4oX25vZGUsIGRhdHVtKSB7XG4gICAgICByZXR1cm4geyAuLi5kYXR1bSB9O1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ3JvdXAgPSB7XG4gICAgZnJvbUZuKG5vZGUsIF9kYXR1bSkge1xuICAgICAgY29uc3QgeyByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSA9IG5vZGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgdHJhbnNsYXRpb25YLFxuICAgICAgICB0cmFuc2xhdGlvblksXG4gICAgICAgIHBoYXNlOiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW1widXBkYXRlZFwiXVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRvRm4oX25vZGUsIGRhdHVtKSB7XG4gICAgICBjb25zdCB7IHJvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSB9ID0gZGF0dW07XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgdHJhbnNsYXRpb25YLFxuICAgICAgICB0cmFuc2xhdGlvbllcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4geyB0aWNrLCBsaW5lLCBsYWJlbCwgZ3JvdXAgfTtcbn1cbmZ1bmN0aW9uIHJlc2V0QXhpc0dyb3VwRm4oKSB7XG4gIHJldHVybiAoX25vZGUsIGRhdHVtKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdGF0aW9uOiBkYXR1bS5yb3RhdGlvbixcbiAgICAgIHJvdGF0aW9uQ2VudGVyWDogZGF0dW0ucm90YXRpb25DZW50ZXJYLFxuICAgICAgcm90YXRpb25DZW50ZXJZOiBkYXR1bS5yb3RhdGlvbkNlbnRlclksXG4gICAgICB0cmFuc2xhdGlvblg6IGRhdHVtLnRyYW5zbGF0aW9uWCxcbiAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0udHJhbnNsYXRpb25ZXG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc2V0QXhpc1NlbGVjdGlvbkZuKGN0eCkge1xuICBjb25zdCB7IHZpc2libGU6IHJhbmdlVmlzaWJsZSwgbWluLCBtYXggfSA9IGN0eDtcbiAgcmV0dXJuIChfbm9kZSwgZGF0dW0pID0+IHtcbiAgICBjb25zdCB5ID0gZGF0dW0udHJhbnNsYXRpb25ZO1xuICAgIGNvbnN0IHZpc2libGUgPSByYW5nZVZpc2libGUgJiYgeSA+PSBtaW4gJiYgeSA8PSBtYXg7XG4gICAgcmV0dXJuIHtcbiAgICAgIHksXG4gICAgICB0cmFuc2xhdGlvblk6IDAsXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgdmlzaWJsZVxuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiByZXNldEF4aXNMYWJlbFNlbGVjdGlvbkZuKCkge1xuICByZXR1cm4gKF9ub2RlLCBkYXR1bSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBkYXR1bS54LFxuICAgICAgeTogZGF0dW0ueSxcbiAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0udHJhbnNsYXRpb25ZLFxuICAgICAgcm90YXRpb246IGRhdHVtLnJvdGF0aW9uLFxuICAgICAgcm90YXRpb25DZW50ZXJYOiBkYXR1bS5yb3RhdGlvbkNlbnRlclhcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gcmVzZXRBeGlzTGluZVNlbGVjdGlvbkZuKCkge1xuICByZXR1cm4gKF9ub2RlLCBkYXR1bSkgPT4ge1xuICAgIHJldHVybiB7IC4uLmRhdHVtIH07XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpcy50c1xudmFyIFRyYW5zbGF0YWJsZUxpbmUgPSBjbGFzcyBleHRlbmRzIFRyYW5zbGF0YWJsZShMaW5lKSB7XG59O1xudmFyIEF4aXNHcm91cFpJbmRleE1hcCA9IC8qIEBfX1BVUkVfXyAqLyAoKEF4aXNHcm91cFpJbmRleE1hcDIpID0+IHtcbiAgQXhpc0dyb3VwWkluZGV4TWFwMltBeGlzR3JvdXBaSW5kZXhNYXAyW1wiVGlja0xpbmVzXCJdID0gMF0gPSBcIlRpY2tMaW5lc1wiO1xuICBBeGlzR3JvdXBaSW5kZXhNYXAyW0F4aXNHcm91cFpJbmRleE1hcDJbXCJBeGlzTGluZVwiXSA9IDFdID0gXCJBeGlzTGluZVwiO1xuICBBeGlzR3JvdXBaSW5kZXhNYXAyW0F4aXNHcm91cFpJbmRleE1hcDJbXCJUaWNrTGFiZWxzXCJdID0gMl0gPSBcIlRpY2tMYWJlbHNcIjtcbiAgcmV0dXJuIEF4aXNHcm91cFpJbmRleE1hcDI7XG59KShBeGlzR3JvdXBaSW5kZXhNYXAgfHwge30pO1xudmFyIF9BeGlzID0gY2xhc3MgX0F4aXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgsIHNjYWxlMikge1xuICAgIHRoaXMubW9kdWxlQ3R4ID0gbW9kdWxlQ3R4O1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTI7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMubmljZSA9IHRydWU7XG4gICAgdGhpcy5yZXZlcnNlID0gZmFsc2U7XG4gICAgdGhpcy5rZXlzID0gW107XG4gICAgdGhpcy5pbnRlcnZhbCA9IG5ldyBBeGlzSW50ZXJ2YWwoKTtcbiAgICB0aGlzLmRhdGFEb21haW4gPSB7IGRvbWFpbjogW10sIGNsaXBwZWQ6IGZhbHNlIH07XG4gICAgdGhpcy5sYXlvdXRDb25zdHJhaW50cyA9IHtcbiAgICAgIHN0YWNrZWQ6IHRydWUsXG4gICAgICBhbGlnbjogXCJzdGFydFwiLFxuICAgICAgd2lkdGg6IDEwMCxcbiAgICAgIHVuaXQ6IFwicGVyY2VudFwiXG4gICAgfTtcbiAgICB0aGlzLmJvdW5kU2VyaWVzID0gW107XG4gICAgdGhpcy5pbmNsdWRlSW52aXNpYmxlRG9tYWlucyA9IGZhbHNlO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25FbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmF4aXNHcm91cCA9IG5ldyBUcmFuc2Zvcm1hYmxlR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1heGlzYCB9KTtcbiAgICAvLyBPcmRlciBpcyBpbXBvcnRhbnQgdG8gYXBwbHkgdGhlIGNvcnJlY3Qgei1pbmRleC5cbiAgICB0aGlzLnRpY2tMaW5lR3JvdXAgPSB0aGlzLmF4aXNHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LUF4aXMtdGljay1saW5lc2AsIHpJbmRleDogMCAvKiBUaWNrTGluZXMgKi8gfSlcbiAgICApO1xuICAgIHRoaXMudGlja0xhYmVsR3JvdXAgPSB0aGlzLmF4aXNHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LUF4aXMtdGljay1sYWJlbHNgLCB6SW5kZXg6IDIgLyogVGlja0xhYmVscyAqLyB9KVxuICAgICk7XG4gICAgdGhpcy5sYWJlbEdyb3VwID0gbmV3IEdyb3VwKHtcbiAgICAgIG5hbWU6IGAke3RoaXMuaWR9LUxhYmVsc2AsXG4gICAgICB6SW5kZXg6IDkgLyogU0VSSUVTX0FOTk9UQVRJT04gKi9cbiAgICB9KTtcbiAgICB0aGlzLmdyaWRHcm91cCA9IG5ldyBUcmFuc2Zvcm1hYmxlR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1BeGlzLWdyaWRgLCB6SW5kZXg6IDEgLyogQVhJU19HUklEICovIH0pO1xuICAgIHRoaXMuZ3JpZExpbmVHcm91cCA9IHRoaXMuZ3JpZEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LWdyaWRMaW5lc2AgfSkpO1xuICAgIHRoaXMuY3Jvc3NMaW5lUmFuZ2VHcm91cCA9IG5ldyBUcmFuc2Zvcm1hYmxlR3JvdXAoe1xuICAgICAgbmFtZTogYCR7dGhpcy5pZH0tQ3Jvc3NMaW5lcy1SYW5nZWAsXG4gICAgICB6SW5kZXg6IDQgLyogU0VSSUVTX0NST1NTTElORV9SQU5HRSAqL1xuICAgIH0pO1xuICAgIHRoaXMuY3Jvc3NMaW5lTGluZUdyb3VwID0gbmV3IFRyYW5zZm9ybWFibGVHcm91cCh7XG4gICAgICBuYW1lOiBgJHt0aGlzLmlkfS1Dcm9zc0xpbmVzLUxpbmVgLFxuICAgICAgekluZGV4OiA4IC8qIFNFUklFU19DUk9TU0xJTkVfTElORSAqL1xuICAgIH0pO1xuICAgIHRoaXMuY3Jvc3NMaW5lTGFiZWxHcm91cCA9IG5ldyBUcmFuc2Zvcm1hYmxlR3JvdXAoe1xuICAgICAgbmFtZTogYCR7dGhpcy5pZH0tQ3Jvc3NMaW5lcy1MYWJlbGAsXG4gICAgICB6SW5kZXg6IDEzIC8qIFNFUklFU19MQUJFTCAqL1xuICAgIH0pO1xuICAgIHRoaXMudGlja0xpbmVHcm91cFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLnRpY2tMaW5lR3JvdXAsXG4gICAgICBUcmFuc2xhdGFibGVMaW5lLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHRoaXMudGlja0xhYmVsR3JvdXBTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy50aWNrTGFiZWxHcm91cCxcbiAgICAgIFRyYW5zZm9ybWFibGVUZXh0LFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHRoaXMuZ3JpZExpbmVHcm91cFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLmdyaWRMaW5lR3JvdXAsXG4gICAgICBUcmFuc2xhdGFibGVMaW5lLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHRoaXMuX2Nyb3NzTGluZXMgPSBbXTtcbiAgICB0aGlzLmxpbmUgPSBuZXcgQXhpc0xpbmUoKTtcbiAgICB0aGlzLnRpY2sgPSBuZXcgQXhpc1RpY2soKTtcbiAgICB0aGlzLmdyaWRMaW5lID0gbmV3IEF4aXNHcmlkTGluZSgpO1xuICAgIHRoaXMubGFiZWwgPSB0aGlzLmNyZWF0ZUxhYmVsKCk7XG4gICAgdGhpcy5kZWZhdWx0VGlja01pblNwYWNpbmcgPSBfQXhpcy5kZWZhdWx0VGlja01pblNwYWNpbmc7XG4gICAgdGhpcy50cmFuc2xhdGlvbiA9IHsgeDogMCwgeTogMCB9O1xuICAgIHRoaXMucm90YXRpb24gPSAwO1xuICAgIC8vIGF4aXMgcm90YXRpb24gYW5nbGUgaW4gZGVncmVlc1xuICAgIHRoaXMubGF5b3V0ID0ge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZnJhY3Rpb25EaWdpdHM6IDAsXG4gICAgICAgIHNwYWNpbmc6IHRoaXMubGFiZWwuc3BhY2luZyxcbiAgICAgICAgZm9ybWF0OiB0aGlzLmxhYmVsLmZvcm1hdFxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5heGlzQ29udGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLmxhYmVsRm9ybWF0dGVyID0gdm9pZCAwO1xuICAgIHRoaXMuZGF0dW1Gb3JtYXR0ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zY2FsZUZvcm1hdHRlclBhcmFtcyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLnJhbmdlID0gWzAsIDFdO1xuICAgIHRoaXMudmlzaWJsZVJhbmdlID0gWzAsIDFdO1xuICAgIHRoaXMudGl0bGUgPSBuZXcgQXhpc1RpdGxlKCk7XG4gICAgdGhpcy5ncmlkTGVuZ3RoID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZ3JpZCB0aWNrcyBhbmQgdGhlIGF4aXMgdGlja3MuXG4gICAgICovXG4gICAgdGhpcy5ncmlkUGFkZGluZyA9IDA7XG4gICAgLyoqXG4gICAgICogSXMgdXNlZCB0byBhdm9pZCBjb2xsaXNpb25zIGJldHdlZW4gYXhpcyBsYWJlbHMgYW5kIHNlcmllcy5cbiAgICAgKi9cbiAgICB0aGlzLnNlcmllc0FyZWFQYWRkaW5nID0gMDtcbiAgICB0aGlzLmFuaW1hdGFibGUgPSB0cnVlO1xuICAgIHRoaXMuX3NjYWxlTmljZURvbWFpbklucHV0RG9tYWluID0gdm9pZCAwO1xuICAgIHRoaXMuX3NjYWxlTmljZURvbWFpblJhbmdlRXh0ZW50ID0gTmFOO1xuICAgIHRoaXMubW9kdWxlTWFwID0gbmV3IE1vZHVsZU1hcCgpO1xuICAgIHRoaXMucmFuZ2UgPSB0aGlzLnNjYWxlLnJhbmdlLnNsaWNlKCk7XG4gICAgdGhpcy5jcm9zc0xpbmVzLmZvckVhY2goKGNyb3NzTGluZSkgPT4gdGhpcy5pbml0Q3Jvc3NMaW5lKGNyb3NzTGluZSkpO1xuICB9XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnR5cGUgPz8gXCJcIjtcbiAgfVxuICBnZXQgbGFiZWxOb2RlcygpIHtcbiAgICByZXR1cm4gdGhpcy50aWNrTGFiZWxHcm91cFNlbGVjdGlvbi5ub2RlcygpO1xuICB9XG4gIHNldCBjcm9zc0xpbmVzKHZhbHVlKSB7XG4gICAgY29uc3QgeyBDcm9zc0xpbmVDb25zdHJ1Y3RvciB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICB0aGlzLl9jcm9zc0xpbmVzLmZvckVhY2goKGNyb3NzTGluZSkgPT4gdGhpcy5kZXRhY2hDcm9zc0xpbmUoY3Jvc3NMaW5lKSk7XG4gICAgdGhpcy5fY3Jvc3NMaW5lcyA9IHZhbHVlLm1hcCgoY3Jvc3NMaW5lKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBDcm9zc0xpbmVDb25zdHJ1Y3RvcigpO1xuICAgICAgaW5zdGFuY2Uuc2V0KGNyb3NzTGluZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSk7XG4gICAgdGhpcy5fY3Jvc3NMaW5lcy5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHtcbiAgICAgIHRoaXMuYXR0YWNoQ3Jvc3NMaW5lKGNyb3NzTGluZSk7XG4gICAgICB0aGlzLmluaXRDcm9zc0xpbmUoY3Jvc3NMaW5lKTtcbiAgICB9KTtcbiAgfVxuICBnZXQgY3Jvc3NMaW5lcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY3Jvc3NMaW5lcztcbiAgfVxuICByZXNldEFuaW1hdGlvbihfcGhhc2UpIHtcbiAgfVxuICBhdHRhY2hDcm9zc0xpbmUoY3Jvc3NMaW5lKSB7XG4gICAgdGhpcy5jcm9zc0xpbmVSYW5nZUdyb3VwLmFwcGVuZENoaWxkKGNyb3NzTGluZS5yYW5nZUdyb3VwKTtcbiAgICB0aGlzLmNyb3NzTGluZUxpbmVHcm91cC5hcHBlbmRDaGlsZChjcm9zc0xpbmUubGluZUdyb3VwKTtcbiAgICB0aGlzLmNyb3NzTGluZUxhYmVsR3JvdXAuYXBwZW5kQ2hpbGQoY3Jvc3NMaW5lLmxhYmVsR3JvdXApO1xuICB9XG4gIGRldGFjaENyb3NzTGluZShjcm9zc0xpbmUpIHtcbiAgICB0aGlzLmNyb3NzTGluZVJhbmdlR3JvdXAucmVtb3ZlQ2hpbGQoY3Jvc3NMaW5lLnJhbmdlR3JvdXApO1xuICAgIHRoaXMuY3Jvc3NMaW5lTGluZUdyb3VwLnJlbW92ZUNoaWxkKGNyb3NzTGluZS5saW5lR3JvdXApO1xuICAgIHRoaXMuY3Jvc3NMaW5lTGFiZWxHcm91cC5yZW1vdmVDaGlsZChjcm9zc0xpbmUubGFiZWxHcm91cCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm1vZHVsZU1hcC5kZXN0cm95KCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGYpID0+IGYoKSk7XG4gIH1cbiAgdXBkYXRlU2NhbGUoKSB7XG4gICAgY29uc3QgeyByYW5nZTogcnIsIHZpc2libGVSYW5nZTogdnIsIHNjYWxlOiBzY2FsZTIgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3BhbiA9IChyclsxXSAtIHJyWzBdKSAvICh2clsxXSAtIHZyWzBdKTtcbiAgICBjb25zdCBzaGlmdCA9IHNwYW4gKiB2clswXTtcbiAgICBjb25zdCBzdGFydDIgPSByclswXSAtIHNoaWZ0O1xuICAgIHNjYWxlMi5yYW5nZSA9IFtzdGFydDIsIHN0YXJ0MiArIHNwYW5dO1xuICAgIHRoaXMuY3Jvc3NMaW5lcy5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHtcbiAgICAgIGNyb3NzTGluZS5jbGlwcGVkUmFuZ2UgPSBbcnJbMF0sIHJyWzFdXTtcbiAgICB9KTtcbiAgfVxuICBzZXRDcm9zc0xpbmVzVmlzaWJsZSh2aXNpYmxlKSB7XG4gICAgdGhpcy5jcm9zc0xpbmVSYW5nZUdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIHRoaXMuY3Jvc3NMaW5lTGluZUdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIHRoaXMuY3Jvc3NMaW5lTGFiZWxHcm91cC52aXNpYmxlID0gdmlzaWJsZTtcbiAgfVxuICBhdHRhY2hBeGlzKGdyb3Vwcykge1xuICAgIGdyb3Vwcy5ncmlkTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmdyaWRHcm91cCk7XG4gICAgZ3JvdXBzLmF4aXNOb2RlLmFwcGVuZENoaWxkKHRoaXMuYXhpc0dyb3VwKTtcbiAgICBncm91cHMubGFiZWxOb2RlLmFwcGVuZENoaWxkKHRoaXMubGFiZWxHcm91cCk7XG4gICAgZ3JvdXBzLmNyb3NzTGluZVJhbmdlTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNyb3NzTGluZVJhbmdlR3JvdXApO1xuICAgIGdyb3Vwcy5jcm9zc0xpbmVMaW5lTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNyb3NzTGluZUxpbmVHcm91cCk7XG4gICAgZ3JvdXBzLmNyb3NzTGluZUxhYmVsTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNyb3NzTGluZUxhYmVsR3JvdXApO1xuICB9XG4gIGRldGFjaEF4aXMoZ3JvdXBzKSB7XG4gICAgZ3JvdXBzLmdyaWROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZ3JpZEdyb3VwKTtcbiAgICBncm91cHMuYXhpc05vZGUucmVtb3ZlQ2hpbGQodGhpcy5heGlzR3JvdXApO1xuICAgIGdyb3Vwcy5sYWJlbE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5sYWJlbEdyb3VwKTtcbiAgICBncm91cHMuY3Jvc3NMaW5lUmFuZ2VOb2RlLnJlbW92ZUNoaWxkKHRoaXMuY3Jvc3NMaW5lUmFuZ2VHcm91cCk7XG4gICAgZ3JvdXBzLmNyb3NzTGluZUxpbmVOb2RlLnJlbW92ZUNoaWxkKHRoaXMuY3Jvc3NMaW5lTGluZUdyb3VwKTtcbiAgICBncm91cHMuY3Jvc3NMaW5lTGFiZWxOb2RlLnJlbW92ZUNoaWxkKHRoaXMuY3Jvc3NMaW5lTGFiZWxHcm91cCk7XG4gIH1cbiAgYXR0YWNoTGFiZWwoYXhpc0xhYmVsTm9kZSkge1xuICAgIHRoaXMubGFiZWxHcm91cC5hcHBlbmQoYXhpc0xhYmVsTm9kZSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIHBvaW50IG9yIGFuIG9iamVjdCBpcyBpbiByYW5nZS5cbiAgICogQHBhcmFtIHZhbHVlIEEgcG9pbnQgKG9yIG9iamVjdCdzIHN0YXJ0aW5nIHBvaW50KS5cbiAgICogQHBhcmFtIHRvbGVyYW5jZSBFeHBhbmRzIHRoZSByYW5nZSBvbiBib3RoIGVuZHMgYnkgdGhpcyBhbW91bnQuXG4gICAqL1xuICBpblJhbmdlKHZhbHVlLCB0b2xlcmFuY2UgPSAwKSB7XG4gICAgY29uc3QgW21pbiwgbWF4XSA9IGZpbmRNaW5NYXgodGhpcy5yYW5nZSk7XG4gICAgcmV0dXJuIHZhbHVlID49IG1pbiAtIHRvbGVyYW5jZSAmJiB2YWx1ZSA8PSBtYXggKyB0b2xlcmFuY2U7XG4gIH1cbiAgZGVmYXVsdERhdHVtRm9ybWF0dGVyKGRhdHVtLCBmcmFjdGlvbkRpZ2l0cykge1xuICAgIHJldHVybiBmb3JtYXRWYWx1ZShkYXR1bSwgZnJhY3Rpb25EaWdpdHMgKyAxKTtcbiAgfVxuICBkZWZhdWx0TGFiZWxGb3JtYXR0ZXIoZGF0dW0sIGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgcmV0dXJuIGZvcm1hdFZhbHVlKGRhdHVtLCBmcmFjdGlvbkRpZ2l0cyk7XG4gIH1cbiAgb25HcmlkTGVuZ3RoQ2hhbmdlKHZhbHVlLCBwcmV2VmFsdWUpIHtcbiAgICBpZiAocHJldlZhbHVlIF4gdmFsdWUpIHtcbiAgICAgIHRoaXMub25HcmlkVmlzaWJpbGl0eUNoYW5nZSgpO1xuICAgIH1cbiAgICB0aGlzLmNyb3NzTGluZXMuZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB0aGlzLmluaXRDcm9zc0xpbmUoY3Jvc3NMaW5lKSk7XG4gIH1cbiAgb25HcmlkVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICB0aGlzLmdyaWRMaW5lR3JvdXBTZWxlY3Rpb24uY2xlYXIoKTtcbiAgfVxuICBjcmVhdGVMYWJlbCgpIHtcbiAgICByZXR1cm4gbmV3IEF4aXNMYWJlbCgpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzL3JlbW92ZXMvdXBkYXRlcyB0aGUgc2NlbmUgZ3JhcGggbm9kZXMgdGhhdCBjb25zdGl0dXRlIHRoZSBheGlzLlxuICAgKi9cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbnMoKTtcbiAgICB0aGlzLnRpY2tMaW5lR3JvdXAudmlzaWJsZSA9IHRoaXMudGljay5lbmFibGVkO1xuICAgIHRoaXMuZ3JpZExpbmVHcm91cC52aXNpYmxlID0gdGhpcy5ncmlkTGluZS5lbmFibGVkO1xuICAgIHRoaXMudGlja0xhYmVsR3JvdXAudmlzaWJsZSA9IHRoaXMubGFiZWwuZW5hYmxlZDtcbiAgICB0aGlzLnVwZGF0ZUxhYmVscygpO1xuICAgIHRoaXMudXBkYXRlR3JpZExpbmVzKCk7XG4gICAgdGhpcy51cGRhdGVUaWNrTGluZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUNyb3NzTGluZXMoKTtcbiAgfVxuICBnZXRBeGlzTGluZUNvb3JkaW5hdGVzKCkge1xuICAgIGNvbnN0IFttaW4sIG1heF0gPSBmaW5kTWluTWF4KHRoaXMucmFuZ2UpO1xuICAgIHJldHVybiB7IHg6IDAsIHkxOiBtaW4sIHkyOiBtYXggfTtcbiAgfVxuICBnZXRMYWJlbFN0eWxlcyhwYXJhbXMsIGFkZGl0aW9uYWxTdHlsZXMpIHtcbiAgICBjb25zdCB7IGxhYmVsIH0gPSB0aGlzO1xuICAgIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHtcbiAgICAgIGNvbG9yOiBsYWJlbC5jb2xvcixcbiAgICAgIHNwYWNpbmc6IGxhYmVsLnNwYWNpbmcsXG4gICAgICBmb250RmFtaWx5OiBsYWJlbC5mb250RmFtaWx5LFxuICAgICAgZm9udFNpemU6IGxhYmVsLmZvbnRTaXplLFxuICAgICAgZm9udFN0eWxlOiBsYWJlbC5mb250U3R5bGUsXG4gICAgICBmb250V2VpZ2h0OiBsYWJlbC5mb250V2VpZ2h0XG4gICAgfTtcbiAgICBsZXQgc3R5bGVyT3V0cHV0O1xuICAgIGlmIChsYWJlbC5pdGVtU3R5bGVyKSB7XG4gICAgICBzdHlsZXJPdXRwdXQgPSB0aGlzLm1vZHVsZUN0eC5jYWxsYmFja0NhY2hlLmNhbGwobGFiZWwuaXRlbVN0eWxlciwge1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIC4uLmRlZmF1bHRTdHlsZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbG9yOiBmaWxsLFxuICAgICAgZm9udEZhbWlseSxcbiAgICAgIGZvbnRTaXplLFxuICAgICAgZm9udFN0eWxlLFxuICAgICAgZm9udFdlaWdodCxcbiAgICAgIHNwYWNpbmdcbiAgICB9ID0gbWVyZ2VEZWZhdWx0cyhzdHlsZXJPdXRwdXQsIGFkZGl0aW9uYWxTdHlsZXMsIGRlZmF1bHRTdHlsZSk7XG4gICAgcmV0dXJuIHsgZmlsbCwgZm9udEZhbWlseSwgZm9udFNpemUsIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgc3BhY2luZyB9O1xuICB9XG4gIGdldFRpY2tTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnRpY2suZW5hYmxlZCA/IHRoaXMudGljay5zaXplIDogMDtcbiAgfVxuICBzZXRUaXRsZVByb3BzKGNhcHRpb24sIHBhcmFtcykge1xuICAgIGNvbnN0IHsgdGl0bGUgfSA9IHRoaXM7XG4gICAgaWYgKCF0aXRsZS5lbmFibGVkKSB7XG4gICAgICBjYXB0aW9uLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGNhcHRpb24ubm9kZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhcHRpb24uZW5hYmxlZCA9IHRydWU7XG4gICAgY2FwdGlvbi5jb2xvciA9IHRpdGxlLmNvbG9yO1xuICAgIGNhcHRpb24uZm9udEZhbWlseSA9IHRpdGxlLmZvbnRGYW1pbHk7XG4gICAgY2FwdGlvbi5mb250U2l6ZSA9IHRpdGxlLmZvbnRTaXplO1xuICAgIGNhcHRpb24uZm9udFN0eWxlID0gdGl0bGUuZm9udFN0eWxlO1xuICAgIGNhcHRpb24uZm9udFdlaWdodCA9IHRpdGxlLmZvbnRXZWlnaHQ7XG4gICAgY2FwdGlvbi53cmFwcGluZyA9IHRpdGxlLndyYXBwaW5nO1xuICAgIGNvbnN0IHRpdGxlTm9kZSA9IGNhcHRpb24ubm9kZTtcbiAgICBjb25zdCBwYWRkaW5nID0gKHRpdGxlLnNwYWNpbmcgPz8gMCkgKyBwYXJhbXMuc3BhY2luZztcbiAgICBjb25zdCBzaWRlRmxhZyA9IHRoaXMubGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICBjb25zdCBwYXJhbGxlbEZsaXBSb3RhdGlvbiA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IHRpdGxlUm90YXRpb25GbGFnID0gc2lkZUZsYWcgPT09IC0xICYmIHBhcmFsbGVsRmxpcFJvdGF0aW9uID4gTWF0aC5QSSAmJiBwYXJhbGxlbEZsaXBSb3RhdGlvbiA8IE1hdGguUEkgKiAyID8gLTEgOiAxO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdGl0bGVSb3RhdGlvbkZsYWcgKiBzaWRlRmxhZyAqIE1hdGguUEkgLyAyO1xuICAgIGNvbnN0IHRleHRCYXNlbGluZSA9IHRpdGxlUm90YXRpb25GbGFnID09PSAxID8gXCJib3R0b21cIiA6IFwidG9wXCI7XG4gICAgY29uc3QgeyByYW5nZTogcmFuZ2UzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKHRpdGxlUm90YXRpb25GbGFnICogc2lkZUZsYWcgKiAocmFuZ2UzWzBdICsgcmFuZ2UzWzFdKSAvIDIpO1xuICAgIGNvbnN0IHkgPSBzaWRlRmxhZyA9PT0gLTEgPyBNYXRoLmZsb29yKHRpdGxlUm90YXRpb25GbGFnICogLXBhZGRpbmcpIDogTWF0aC5mbG9vcigtcGFkZGluZyk7XG4gICAgY29uc3QgeyBjYWxsYmFja0NhY2hlIH0gPSB0aGlzLm1vZHVsZUN0eDtcbiAgICBjb25zdCB7IGZvcm1hdHRlciA9IChwKSA9PiBwLmRlZmF1bHRWYWx1ZSB9ID0gdGl0bGU7XG4gICAgY29uc3QgdGV4dDIgPSBjYWxsYmFja0NhY2hlLmNhbGwoZm9ybWF0dGVyLCB0aGlzLmdldFRpdGxlRm9ybWF0dGVyUGFyYW1zKCkpO1xuICAgIGNhcHRpb24udGV4dCA9IHRleHQyO1xuICAgIHRpdGxlTm9kZS5zZXRQcm9wZXJ0aWVzKHsgdmlzaWJsZTogdHJ1ZSwgdGV4dDogdGV4dDIsIHRleHRCYXNlbGluZSwgeCwgeSwgcm90YXRpb24gfSk7XG4gIH1cbiAgcHJvY2Vzc0RhdGEoKSB7XG4gICAgY29uc3QgeyBpbmNsdWRlSW52aXNpYmxlRG9tYWlucywgYm91bmRTZXJpZXMsIGRpcmVjdGlvbiB9ID0gdGhpcztcbiAgICBjb25zdCB2aXNpYmxlU2VyaWVzID0gaW5jbHVkZUludmlzaWJsZURvbWFpbnMgPyBib3VuZFNlcmllcyA6IGJvdW5kU2VyaWVzLmZpbHRlcigocykgPT4gcy5pc0VuYWJsZWQoKSk7XG4gICAgY29uc3QgZG9tYWlucyA9IHZpc2libGVTZXJpZXMubWFwKChzZXJpZXMpID0+IHNlcmllcy5nZXREb21haW4oZGlyZWN0aW9uKSk7XG4gICAgdGhpcy5zZXREb21haW5zKC4uLmRvbWFpbnMpO1xuICB9XG4gIHNldERvbWFpbnMoLi4uZG9tYWlucykge1xuICAgIGxldCBkb21haW47XG4gICAgbGV0IGFuaW1hdGFibGU7XG4gICAgaWYgKGRvbWFpbnMubGVuZ3RoID4gMCkge1xuICAgICAgKHsgZG9tYWluLCBhbmltYXRhYmxlIH0gPSB0aGlzLnNjYWxlLm5vcm1hbGl6ZURvbWFpbnMoLi4uZG9tYWlucykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb21haW4gPSBbXTtcbiAgICAgIGFuaW1hdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmRhdGFEb21haW4gPSB0aGlzLm5vcm1hbGlzZURhdGFEb21haW4oZG9tYWluKTtcbiAgICBpZiAodGhpcy5yZXZlcnNlKSB7XG4gICAgICB0aGlzLmRhdGFEb21haW4uZG9tYWluLnJldmVyc2UoKTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRhYmxlID0gYW5pbWF0YWJsZTtcbiAgfVxuICBjYWxjdWxhdGVMYXlvdXQoaW5pdGlhbFByaW1hcnlUaWNrQ291bnQpIHtcbiAgICBjb25zdCB7IHNjYWxlOiBzY2FsZTIsIGxhYmVsLCB2aXNpYmxlUmFuZ2UsIG5pY2UgfSA9IHRoaXM7XG4gICAgdGhpcy51cGRhdGVTY2FsZSgpO1xuICAgIGNvbnN0IHJhbmdlRXh0ZW50ID0gZmluZFJhbmdlRXh0ZW50KHRoaXMucmFuZ2UpO1xuICAgIGNvbnN0IGRvbWFpbiA9IHRoaXMuZGF0YURvbWFpbi5kb21haW47XG4gICAgbGV0IHRpY2tMYXlvdXREb21haW47XG4gICAgaWYgKHZpc2libGVSYW5nZVswXSA9PT0gMCAmJiB2aXNpYmxlUmFuZ2VbMV0gPT09IDEpIHtcbiAgICAgIHRpY2tMYXlvdXREb21haW4gPSB2b2lkIDA7XG4gICAgfSBlbHNlIGlmICghbmljZSkge1xuICAgICAgdGlja0xheW91dERvbWFpbiA9IGRvbWFpbjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NjYWxlTmljZURvbWFpbklucHV0RG9tYWluID09PSBkb21haW4gJiYgdGhpcy5fc2NhbGVOaWNlRG9tYWluUmFuZ2VFeHRlbnQgPT09IHJhbmdlRXh0ZW50KSB7XG4gICAgICB0aWNrTGF5b3V0RG9tYWluID0gdGhpcy5zY2FsZS5kb21haW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tMYXlvdXREb21haW4gPSB0aGlzLmNhbGN1bGF0ZVRpY2tMYXlvdXQoZG9tYWluLCAwIC8qIFRpY2tBbmREb21haW4gKi8sIFswLCAxXSkubmljZURvbWFpbjtcbiAgICB9XG4gICAgbGV0IG5pY2VNb2RlO1xuICAgIGlmICghbmljZSkge1xuICAgICAgbmljZU1vZGUgPSAyIC8qIE9mZiAqLztcbiAgICB9IGVsc2UgaWYgKHRpY2tMYXlvdXREb21haW4gPT0gbnVsbCkge1xuICAgICAgbmljZU1vZGUgPSAwIC8qIFRpY2tBbmREb21haW4gKi87XG4gICAgfSBlbHNlIHtcbiAgICAgIG5pY2VNb2RlID0gMSAvKiBUaWNrc09ubHkgKi87XG4gICAgfVxuICAgIGNvbnN0IHsgbmljZURvbWFpbiwgcHJpbWFyeVRpY2tDb3VudCwgdGlja3MsIHRpY2tEb21haW4sIGZyYWN0aW9uRGlnaXRzLCBiYm94IH0gPSB0aGlzLmNhbGN1bGF0ZVRpY2tMYXlvdXQoXG4gICAgICB0aWNrTGF5b3V0RG9tYWluID8/IGRvbWFpbixcbiAgICAgIG5pY2VNb2RlLFxuICAgICAgdmlzaWJsZVJhbmdlLFxuICAgICAgaW5pdGlhbFByaW1hcnlUaWNrQ291bnRcbiAgICApO1xuICAgIHRoaXMuc2NhbGUuZG9tYWluID0gbmljZURvbWFpbjtcbiAgICB0aGlzLl9zY2FsZU5pY2VEb21haW5JbnB1dERvbWFpbiA9IG5pY2UgPyBkb21haW4gOiB2b2lkIDA7XG4gICAgdGhpcy5fc2NhbGVOaWNlRG9tYWluUmFuZ2VFeHRlbnQgPSBuaWNlID8gcmFuZ2VFeHRlbnQgOiBOYU47XG4gICAgY29uc3Qgc3BlY2lmaWVyID0gbGFiZWwuZm9ybWF0O1xuICAgIHRoaXMubGFiZWxGb3JtYXR0ZXIgPSBzY2FsZTIudGlja0Zvcm1hdHRlcih7IGRvbWFpbjogdGlja0RvbWFpbiwgc3BlY2lmaWVyLCB0aWNrcywgZnJhY3Rpb25EaWdpdHMgfSkgPz8gKCh2YWx1ZSkgPT4gdGhpcy5kZWZhdWx0TGFiZWxGb3JtYXR0ZXIodmFsdWUsIGZyYWN0aW9uRGlnaXRzKSk7XG4gICAgdGhpcy5kYXR1bUZvcm1hdHRlciA9IHNjYWxlMi5kYXR1bUZvcm1hdHRlcih7IGRvbWFpbjogdGlja0RvbWFpbiwgc3BlY2lmaWVyLCB0aWNrcywgZnJhY3Rpb25EaWdpdHMgfSkgPz8gKCh2YWx1ZSkgPT4gdGhpcy5kZWZhdWx0RGF0dW1Gb3JtYXR0ZXIodmFsdWUsIGZyYWN0aW9uRGlnaXRzKSk7XG4gICAgdGhpcy5zY2FsZUZvcm1hdHRlclBhcmFtcyA9IHsgZG9tYWluOiB0aWNrRG9tYWluLCB0aWNrcywgZnJhY3Rpb25EaWdpdHMgfTtcbiAgICB0aGlzLmxheW91dC5sYWJlbCA9IHtcbiAgICAgIGZyYWN0aW9uRGlnaXRzLFxuICAgICAgc3BhY2luZzogdGhpcy5sYWJlbC5zcGFjaW5nLFxuICAgICAgZm9ybWF0OiB0aGlzLmxhYmVsLmZvcm1hdFxuICAgIH07XG4gICAgY29uc3Qgc2lkZUZsYWcgPSBsYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIGNvbnN0IGFueVNlcmllc0FjdGl2ZSA9IHRoaXMuaXNBbnlTZXJpZXNBY3RpdmUoKTtcbiAgICBjb25zdCB7IHJvdGF0aW9uLCBwYXJhbGxlbEZsaXBSb3RhdGlvbiwgcmVndWxhckZsaXBSb3RhdGlvbiB9ID0gdGhpcy5jYWxjdWxhdGVSb3RhdGlvbnMoKTtcbiAgICB0aGlzLmNyb3NzTGluZXMuZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjcm9zc0xpbmUuc2lkZUZsYWcgPSAtc2lkZUZsYWc7XG4gICAgICBjcm9zc0xpbmUuZGlyZWN0aW9uID0gcm90YXRpb24gPT09IC1NYXRoLlBJIC8gMiA/IFwieFwiIC8qIFggKi8gOiBcInlcIiAvKiBZICovO1xuICAgICAgaWYgKGNyb3NzTGluZSBpbnN0YW5jZW9mIENhcnRlc2lhbkNyb3NzTGluZSkge1xuICAgICAgICAoX2EgPSBjcm9zc0xpbmUubGFiZWwpLnBhcmFsbGVsID8/IChfYS5wYXJhbGxlbCA9IGxhYmVsLnBhcmFsbGVsKTtcbiAgICAgIH1cbiAgICAgIGNyb3NzTGluZS5wYXJhbGxlbEZsaXBSb3RhdGlvbiA9IHBhcmFsbGVsRmxpcFJvdGF0aW9uO1xuICAgICAgY3Jvc3NMaW5lLnJlZ3VsYXJGbGlwUm90YXRpb24gPSByZWd1bGFyRmxpcFJvdGF0aW9uO1xuICAgICAgY3Jvc3NMaW5lLmNhbGN1bGF0ZUxheW91dD8uKGFueVNlcmllc0FjdGl2ZSwgdGhpcy5yZXZlcnNlKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyBwcmltYXJ5VGlja0NvdW50LCBiYm94IH07XG4gIH1cbiAgZ2V0VHJhbnNmb3JtQm94KGJib3gpIHtcbiAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgY29uc3QgeyByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSA9IHRoaXMuZ2V0QXhpc1RyYW5zZm9ybSgpO1xuICAgIE1hdHJpeC51cGRhdGVUcmFuc2Zvcm1NYXRyaXgobWF0cml4LCAxLCAxLCByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkpO1xuICAgIHJldHVybiBtYXRyaXgudHJhbnNmb3JtQkJveChiYm94KTtcbiAgfVxuICBjYWxjdWxhdGVSb3RhdGlvbnMoKSB7XG4gICAgY29uc3Qgcm90YXRpb24gPSB0b1JhZGlhbnModGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgcGFyYWxsZWxGbGlwUm90YXRpb24gPSBub3JtYWxpemVBbmdsZTM2MChyb3RhdGlvbik7XG4gICAgY29uc3QgcmVndWxhckZsaXBSb3RhdGlvbiA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHJvdGF0aW9uIC0gTWF0aC5QSSAvIDIpO1xuICAgIHJldHVybiB7IHJvdGF0aW9uLCBwYXJhbGxlbEZsaXBSb3RhdGlvbiwgcmVndWxhckZsaXBSb3RhdGlvbiB9O1xuICB9XG4gIHVwZGF0ZUNyb3NzTGluZXMoKSB7XG4gICAgY29uc3QgYW55U2VyaWVzQWN0aXZlID0gdGhpcy5pc0FueVNlcmllc0FjdGl2ZSgpO1xuICAgIHRoaXMuY3Jvc3NMaW5lcy5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHtcbiAgICAgIGNyb3NzTGluZS51cGRhdGUoYW55U2VyaWVzQWN0aXZlKTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVUaWNrTGluZXMoKSB7XG4gICAgY29uc3QgeyB0aWNrLCBsYWJlbCB9ID0gdGhpcztcbiAgICBjb25zdCBzaWRlRmxhZyA9IGxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgdGhpcy50aWNrTGluZUdyb3VwU2VsZWN0aW9uLmVhY2goKGxpbmUsIGRhdHVtKSA9PiB7XG4gICAgICBsaW5lLnN0cm9rZVdpZHRoID0gZGF0dW0udGlja1dpZHRoID8/IHRpY2sud2lkdGg7XG4gICAgICBsaW5lLnN0cm9rZSA9IGRhdHVtLnRpY2tTdHJva2UgPz8gdGljay5zdHJva2U7XG4gICAgICBsaW5lLngxID0gc2lkZUZsYWcgKiAoZGF0dW0udGlja1NpemUgPz8gdGhpcy5nZXRUaWNrU2l6ZSgpKTtcbiAgICAgIGxpbmUueDIgPSAwO1xuICAgIH0pO1xuICB9XG4gIGdldEF4aXNUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdGF0aW9uOiB0b1JhZGlhbnModGhpcy5yb3RhdGlvbiksXG4gICAgICB0cmFuc2xhdGlvblg6IE1hdGguZmxvb3IodGhpcy50cmFuc2xhdGlvbi54KSxcbiAgICAgIHRyYW5zbGF0aW9uWTogTWF0aC5mbG9vcih0aGlzLnRyYW5zbGF0aW9uLnkpXG4gICAgfTtcbiAgfVxuICB1cGRhdGVQb3NpdGlvbigpIHtcbiAgICBjb25zdCB7IGNyb3NzTGluZVJhbmdlR3JvdXAsIGNyb3NzTGluZUxpbmVHcm91cCwgY3Jvc3NMaW5lTGFiZWxHcm91cCwgZ3JpZEdyb3VwLCB0cmFuc2xhdGlvbiB9ID0gdGhpcztcbiAgICBjb25zdCB7IHJvdGF0aW9uIH0gPSB0aGlzLmNhbGN1bGF0ZVJvdGF0aW9ucygpO1xuICAgIGNvbnN0IHRyYW5zbGF0aW9uWCA9IE1hdGguZmxvb3IodHJhbnNsYXRpb24ueCk7XG4gICAgY29uc3QgdHJhbnNsYXRpb25ZID0gTWF0aC5mbG9vcih0cmFuc2xhdGlvbi55KTtcbiAgICBjcm9zc0xpbmVSYW5nZUdyb3VwLnNldFByb3BlcnRpZXMoeyByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSk7XG4gICAgY3Jvc3NMaW5lTGluZUdyb3VwLnNldFByb3BlcnRpZXMoeyByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSk7XG4gICAgY3Jvc3NMaW5lTGFiZWxHcm91cC5zZXRQcm9wZXJ0aWVzKHsgcm90YXRpb24sIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0pO1xuICAgIGdyaWRHcm91cC5zZXRQcm9wZXJ0aWVzKHsgcm90YXRpb24sIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0pO1xuICB9XG4gIHVwZGF0ZUdyaWRMaW5lcygpIHtcbiAgICBjb25zdCBzaWRlRmxhZyA9IHRoaXMubGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICBjb25zdCB7XG4gICAgICBncmlkTGluZTogeyBzdHlsZSwgd2lkdGg6IHdpZHRoMiB9LFxuICAgICAgZ3JpZFBhZGRpbmcsXG4gICAgICBncmlkTGVuZ3RoXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGdyaWRMZW5ndGggPT09IDAgfHwgc3R5bGUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ3JpZExpbmVHcm91cFNlbGVjdGlvbi5lYWNoKChsaW5lLCBfLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgeyBzdHJva2U6IHN0cm9rZTIsIGxpbmVEYXNoIH0gPSBzdHlsZVtpbmRleCAlIHN0eWxlLmxlbmd0aF07XG4gICAgICBsaW5lLnNldFByb3BlcnRpZXMoe1xuICAgICAgICB4MTogZ3JpZFBhZGRpbmcsXG4gICAgICAgIHgyOiAtc2lkZUZsYWcgKiBncmlkTGVuZ3RoICsgZ3JpZFBhZGRpbmcsXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlMixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHdpZHRoMixcbiAgICAgICAgbGluZURhc2hcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8vIEZvciBmb3JtYXR0aW5nIChuaWNlIHJvdW5kZWQpIHRpY2sgdmFsdWVzLlxuICBmb3JtYXRUaWNrKHZhbHVlLCBpbmRleCwgZnJhY3Rpb25EaWdpdHMsIGRlZmF1bHRGb3JtYXR0ZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBsYWJlbEZvcm1hdHRlcixcbiAgICAgIGxhYmVsOiB7IGZvcm1hdHRlciB9LFxuICAgICAgbW9kdWxlQ3R4OiB7IGNhbGxiYWNrQ2FjaGUgfVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgcmVzdWx0ID0gY2FsbGJhY2tDYWNoZS5jYWxsKGZvcm1hdHRlciwgeyB2YWx1ZSwgaW5kZXgsIGZyYWN0aW9uRGlnaXRzIH0pO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdEZvcm1hdHRlcikge1xuICAgICAgcmVzdWx0ID0gZGVmYXVsdEZvcm1hdHRlcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChsYWJlbEZvcm1hdHRlcikge1xuICAgICAgcmVzdWx0ID0gbGFiZWxGb3JtYXR0ZXIodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKHJlc3VsdCA/PyB2YWx1ZSk7XG4gIH1cbiAgLy8gRm9yIGZvcm1hdHRpbmcgYXJiaXRyYXJ5IHZhbHVlcyBiZXR3ZWVuIHRoZSB0aWNrcy5cbiAgZm9ybWF0RGF0dW0odmFsdWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBsYWJlbDogeyBmb3JtYXR0ZXIgfSxcbiAgICAgIG1vZHVsZUN0eDogeyBjYWxsYmFja0NhY2hlIH0sXG4gICAgICBkYXR1bUZvcm1hdHRlcjogdmFsdWVGb3JtYXR0ZXIgPSB0aGlzLmxhYmVsRm9ybWF0dGVyXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICByZXN1bHQgPSBjYWxsYmFja0NhY2hlLmNhbGwoZm9ybWF0dGVyLCB7IHZhbHVlLCBpbmRleDogTmFOIH0pO1xuICAgIH0gZWxzZSBpZiAodmFsdWVGb3JtYXR0ZXIpIHtcbiAgICAgIHJlc3VsdCA9IGNhbGxiYWNrQ2FjaGUuY2FsbCh2YWx1ZUZvcm1hdHRlciwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJlc3VsdCA9IHZhbHVlLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIC0gXCIpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKHJlc3VsdCA/PyB2YWx1ZSk7XG4gIH1cbiAgZ2V0U2NhbGVWYWx1ZUZvcm1hdHRlcihmb3JtYXQpIHtcbiAgICBjb25zdCB7IHNjYWxlRm9ybWF0dGVyUGFyYW1zIH0gPSB0aGlzO1xuICAgIGxldCBmb3JtYXR0ZXI7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChmb3JtYXQgIT0gbnVsbCAmJiBzY2FsZUZvcm1hdHRlclBhcmFtcyAhPSBudWxsKSB7XG4gICAgICAgIGZvcm1hdHRlciA9IHRoaXMuc2NhbGUudGlja0Zvcm1hdHRlcih7IC4uLnNjYWxlRm9ybWF0dGVyUGFyYW1zLCBzcGVjaWZpZXI6IGZvcm1hdCB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKGB0aGUgZm9ybWF0IHN0cmluZyAke2Zvcm1hdH0gaXMgaW52YWxpZCwgaWdub3JpbmcuYCk7XG4gICAgfVxuICAgIGZvcm1hdHRlciA/PyAoZm9ybWF0dGVyID0gKHZhbHVlKSA9PiB0aGlzLmZvcm1hdERhdHVtKHZhbHVlKSk7XG4gICAgcmV0dXJuIGZvcm1hdHRlcjtcbiAgfVxuICBnZXRCQm94KCkge1xuICAgIHJldHVybiB0aGlzLmF4aXNHcm91cC5nZXRCQm94KCk7XG4gIH1cbiAgaW5pdENyb3NzTGluZShjcm9zc0xpbmUpIHtcbiAgICBjcm9zc0xpbmUuc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgIGNyb3NzTGluZS5ncmlkTGVuZ3RoID0gdGhpcy5ncmlkTGVuZ3RoO1xuICB9XG4gIGlzQW55U2VyaWVzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmJvdW5kU2VyaWVzLnNvbWUoKHMpID0+IHRoaXMuaW5jbHVkZUludmlzaWJsZURvbWFpbnMgfHwgcy5pc0VuYWJsZWQoKSk7XG4gIH1cbiAgY2xpcFRpY2tMaW5lcyh4LCB5LCB3aWR0aDIsIGhlaWdodDIpIHtcbiAgICB0aGlzLnRpY2tMaW5lR3JvdXAuc2V0Q2xpcFJlY3QobmV3IEJCb3goeCwgeSwgd2lkdGgyLCBoZWlnaHQyKSk7XG4gIH1cbiAgY2xpcEdyaWQoeCwgeSwgd2lkdGgyLCBoZWlnaHQyKSB7XG4gICAgdGhpcy5ncmlkR3JvdXAuc2V0Q2xpcFJlY3QobmV3IEJCb3goeCwgeSwgd2lkdGgyLCBoZWlnaHQyKSk7XG4gIH1cbiAgZ2V0VGl0bGVGb3JtYXR0ZXJQYXJhbXMoKSB7XG4gICAgY29uc3QgeyBkaXJlY3Rpb24gfSA9IHRoaXM7XG4gICAgY29uc3QgYm91bmRTZXJpZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNlcmllcyBvZiB0aGlzLmJvdW5kU2VyaWVzKSB7XG4gICAgICBjb25zdCBrZXlzID0gc2VyaWVzLmdldEtleXMoZGlyZWN0aW9uKTtcbiAgICAgIGNvbnN0IG5hbWVzID0gc2VyaWVzLmdldE5hbWVzKGRpcmVjdGlvbik7XG4gICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBrZXlzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgYm91bmRTZXJpZXMucHVzaCh7IGtleToga2V5c1tpZHhdLCBuYW1lOiBuYW1lc1tpZHhdIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkaXJlY3Rpb24sIGJvdW5kU2VyaWVzLCBkZWZhdWx0VmFsdWU6IHRoaXMudGl0bGU/LnRleHQgfTtcbiAgfVxuICBub3JtYWxpc2VEYXRhRG9tYWluKGQpIHtcbiAgICByZXR1cm4geyBkb21haW46IFsuLi5kXSwgY2xpcHBlZDogZmFsc2UgfTtcbiAgfVxuICBnZXRMYXlvdXRTdGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICByZWN0OiB0aGlzLmdldEJCb3goKSxcbiAgICAgIGdyaWRQYWRkaW5nOiB0aGlzLmdyaWRQYWRkaW5nLFxuICAgICAgc2VyaWVzQXJlYVBhZGRpbmc6IHRoaXMuc2VyaWVzQXJlYVBhZGRpbmcsXG4gICAgICB0aWNrU2l6ZTogdGhpcy5nZXRUaWNrU2l6ZSgpLFxuICAgICAgZGlyZWN0aW9uOiB0aGlzLmRpcmVjdGlvbixcbiAgICAgIGRvbWFpbjogdGhpcy5kYXRhRG9tYWluLmRvbWFpbixcbiAgICAgIHNjYWxlOiB0aGlzLnNjYWxlLFxuICAgICAgLi4udGhpcy5sYXlvdXRcbiAgICB9O1xuICB9XG4gIGdldE1vZHVsZU1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVNYXA7XG4gIH1cbiAgY3JlYXRlTW9kdWxlQ29udGV4dCgpIHtcbiAgICB0aGlzLmF4aXNDb250ZXh0ID8/ICh0aGlzLmF4aXNDb250ZXh0ID0gdGhpcy5jcmVhdGVBeGlzQ29udGV4dCgpKTtcbiAgICByZXR1cm4geyAuLi50aGlzLm1vZHVsZUN0eCwgcGFyZW50OiB0aGlzLmF4aXNDb250ZXh0IH07XG4gIH1cbiAgY3JlYXRlQXhpc0NvbnRleHQoKSB7XG4gICAgY29uc3QgeyBzY2FsZTogc2NhbGUyIH0gPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICBheGlzSWQ6IHRoaXMuaWQsXG4gICAgICBzY2FsZTogdGhpcy5zY2FsZSxcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24sXG4gICAgICBjb250aW51b3VzOiBDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSB8fCBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMiksXG4gICAgICBnZXRDYW52YXNCb3VuZHM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIFRyYW5zZm9ybWFibGUudG9DYW52YXModGhpcy5heGlzR3JvdXApO1xuICAgICAgfSxcbiAgICAgIHNlcmllc0tleVByb3BlcnRpZXM6ICgpID0+IHRoaXMuYm91bmRTZXJpZXMucmVkdWNlKChrZXlzLCBzZXJpZXMpID0+IHtcbiAgICAgICAgY29uc3Qgc2VyaWVzS2V5cyA9IHNlcmllcy5nZXRLZXlQcm9wZXJ0aWVzKHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgICAgc2VyaWVzS2V5cy5mb3JFYWNoKChrZXkpID0+IGtleXMuYWRkKGtleSkpO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpLFxuICAgICAgc2VyaWVzSWRzOiAoKSA9PiB0aGlzLmJvdW5kU2VyaWVzLm1hcCgoc2VyaWVzKSA9PiBzZXJpZXMuaWQpLFxuICAgICAgc2NhbGVWYWx1ZUZvcm1hdHRlcjogKHNwZWNpZmllcikgPT4gdGhpcy5nZXRTY2FsZVZhbHVlRm9ybWF0dGVyKHNwZWNpZmllciksXG4gICAgICBzY2FsZUludmVydDogKHZhbCkgPT4gc2NhbGUyLmludmVydCh2YWwsIHRydWUpLFxuICAgICAgc2NhbGVJbnZlcnROZWFyZXN0OiAodmFsKSA9PiBzY2FsZTIuaW52ZXJ0KHZhbCwgdHJ1ZSksXG4gICAgICBhdHRhY2hMYWJlbDogKG5vZGUpID0+IHRoaXMuYXR0YWNoTGFiZWwobm9kZSksXG4gICAgICBpblJhbmdlOiAoeCwgdG9sZXJhbmNlKSA9PiB0aGlzLmluUmFuZ2UoeCwgdG9sZXJhbmNlKVxuICAgIH07XG4gIH1cbiAgaXNSZXZlcnNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlO1xuICB9XG59O1xuX0F4aXMuZGVmYXVsdFRpY2tNaW5TcGFjaW5nID0gNTA7XG5fQXhpcy5Dcm9zc0xpbmVDb25zdHJ1Y3RvciA9IENhcnRlc2lhbkNyb3NzTGluZTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBfQXhpcy5wcm90b3R5cGUsIFwibmljZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBfQXhpcy5wcm90b3R5cGUsIFwicmV2ZXJzZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklOR19BUlJBWSlcbl0sIF9BeGlzLnByb3RvdHlwZSwgXCJrZXlzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgX0F4aXMucHJvdG90eXBlLCBcImludGVydmFsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgX0F4aXMucHJvdG90eXBlLCBcInRpdGxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCwgdmFsdWUsIG9sZFZhbHVlKSA9PiB0YXJnZXQub25HcmlkTGVuZ3RoQ2hhbmdlKHZhbHVlLCBvbGRWYWx1ZSkpXG5dLCBfQXhpcy5wcm90b3R5cGUsIFwiZ3JpZExlbmd0aFwiLCAyKTtcbnZhciBBeGlzID0gX0F4aXM7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3V0aWwvbGFiZWxQbGFjZW1lbnQudHNcbmZ1bmN0aW9uIGNpcmNsZVJlY3RPdmVybGFwKGMsIHVuaXRDZW50ZXIsIHgsIHksIHcsIGgpIHtcbiAgaWYgKGMuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgY3ggPSBjLng7XG4gIGxldCBjeSA9IGMueTtcbiAgaWYgKHVuaXRDZW50ZXIgIT0gbnVsbCkge1xuICAgIGN4IC09ICh1bml0Q2VudGVyLnggLSAwLjUpICogYy5zaXplO1xuICAgIGN5IC09ICh1bml0Q2VudGVyLnkgLSAwLjUpICogYy5zaXplO1xuICB9XG4gIGxldCBlZGdlWCA9IGN4O1xuICBpZiAoY3ggPCB4KSB7XG4gICAgZWRnZVggPSB4O1xuICB9IGVsc2UgaWYgKGN4ID4geCArIHcpIHtcbiAgICBlZGdlWCA9IHggKyB3O1xuICB9XG4gIGxldCBlZGdlWSA9IGN5O1xuICBpZiAoY3kgPCB5KSB7XG4gICAgZWRnZVkgPSB5O1xuICB9IGVsc2UgaWYgKGN5ID4geSArIGgpIHtcbiAgICBlZGdlWSA9IHkgKyBoO1xuICB9XG4gIGNvbnN0IGR4ID0gY3ggLSBlZGdlWDtcbiAgY29uc3QgZHkgPSBjeSAtIGVkZ2VZO1xuICBjb25zdCBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgcmV0dXJuIGQgPD0gYy5zaXplICogMC41O1xufVxuZnVuY3Rpb24gcmVjdFJlY3RPdmVybGFwKHIxLCB4MiwgeTIsIHcyLCBoMikge1xuICBjb25zdCB4T3ZlcmxhcCA9IHIxLnggKyByMS53aWR0aCA+IHgyICYmIHIxLnggPCB4MiArIHcyO1xuICBjb25zdCB5T3ZlcmxhcCA9IHIxLnkgKyByMS5oZWlnaHQgPiB5MiAmJiByMS55IDwgeTIgKyBoMjtcbiAgcmV0dXJuIHhPdmVybGFwICYmIHlPdmVybGFwO1xufVxuZnVuY3Rpb24gcmVjdENvbnRhaW5zUmVjdChyMSwgcjJ4LCByMnksIHIydywgcjJoKSB7XG4gIHJldHVybiByMnggKyByMncgPCByMS54ICsgcjEud2lkdGggJiYgcjJ4ID4gcjEueCAmJiByMnkgPiByMS55ICYmIHIyeSArIHIyaCA8IHIxLnkgKyByMS5oZWlnaHQ7XG59XG5mdW5jdGlvbiBpc1BvaW50TGFiZWxEYXR1bSh4KSB7XG4gIHJldHVybiB4ICE9IG51bGwgJiYgdHlwZW9mIHgucG9pbnQgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHgubGFiZWwgPT09IFwib2JqZWN0XCI7XG59XG52YXIgbGFiZWxQbGFjZW1lbnRzID0ge1xuICB0b3A6IHsgeDogMCwgeTogLTEgfSxcbiAgYm90dG9tOiB7IHg6IDAsIHk6IDEgfSxcbiAgbGVmdDogeyB4OiAtMSwgeTogMCB9LFxuICByaWdodDogeyB4OiAxLCB5OiAwIH0sXG4gIFwidG9wLWxlZnRcIjogeyB4OiAtMSwgeTogLTEgfSxcbiAgXCJ0b3AtcmlnaHRcIjogeyB4OiAxLCB5OiAtMSB9LFxuICBcImJvdHRvbS1sZWZ0XCI6IHsgeDogLTEsIHk6IDEgfSxcbiAgXCJib3R0b20tcmlnaHRcIjogeyB4OiAxLCB5OiAxIH1cbn07XG5mdW5jdGlvbiBwbGFjZUxhYmVscyhkYXRhLCBib3VuZHMsIHBhZGRpbmcgPSA1KSB7XG4gIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHByZXZpb3VzUmVzdWx0cyA9IFtdO1xuICBjb25zdCBzb3J0ZWREYXRhQ2xvbmUgPSBuZXcgTWFwKFxuICAgIFsuLi5kYXRhLmVudHJpZXMoKV0ubWFwKChbaywgZF0pID0+IFtrLCBkLnRvU29ydGVkKChhLCBiKSA9PiBiLnBvaW50LnNpemUgLSBhLnBvaW50LnNpemUpXSlcbiAgKTtcbiAgY29uc3QgZGF0YVZhbHVlcyA9IFsuLi5zb3J0ZWREYXRhQ2xvbmUudmFsdWVzKCldLmZsYXQoKTtcbiAgZm9yIChjb25zdCBbc2VyaWVzSWQsIGRhdHVtc10gb2Ygc29ydGVkRGF0YUNsb25lLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IGxhYmVscyA9IFtdO1xuICAgIGlmICghZGF0dW1zWzBdPy5sYWJlbClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGZvciAobGV0IGluZGV4ID0gMCwgbG4gPSBkYXR1bXMubGVuZ3RoOyBpbmRleCA8IGxuOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBkID0gZGF0dW1zW2luZGV4XTtcbiAgICAgIGNvbnN0IHsgcG9pbnQsIGxhYmVsLCBhbmNob3IgfSA9IGQ7XG4gICAgICBjb25zdCB7IHRleHQ6IHRleHQyLCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IGxhYmVsO1xuICAgICAgY29uc3QgciA9IHBvaW50LnNpemUgKiAwLjU7XG4gICAgICBsZXQgZHggPSAwO1xuICAgICAgbGV0IGR5ID0gMDtcbiAgICAgIGlmIChyID4gMCAmJiBkLnBsYWNlbWVudCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHBsYWNlbWVudCA9IGxhYmVsUGxhY2VtZW50c1tkLnBsYWNlbWVudF07XG4gICAgICAgIGR4ID0gKHdpZHRoMiAqIDAuNSArIHIgKyBwYWRkaW5nKSAqIHBsYWNlbWVudC54O1xuICAgICAgICBkeSA9IChoZWlnaHQyICogMC41ICsgciArIHBhZGRpbmcpICogcGxhY2VtZW50Lnk7XG4gICAgICB9XG4gICAgICBjb25zdCB4ID0gcG9pbnQueCAtIHdpZHRoMiAqIDAuNSArIGR4IC0gKChhbmNob3I/LnggPz8gMC41KSAtIDAuNSkgKiBwb2ludC5zaXplO1xuICAgICAgY29uc3QgeSA9IHBvaW50LnkgLSBoZWlnaHQyICogMC41ICsgZHkgLSAoKGFuY2hvcj8ueSA/PyAwLjUpIC0gMC41KSAqIHBvaW50LnNpemU7XG4gICAgICBjb25zdCB3aXRoaW5Cb3VuZHMgPSAhYm91bmRzIHx8IHJlY3RDb250YWluc1JlY3QoYm91bmRzLCB4LCB5LCB3aWR0aDIsIGhlaWdodDIpO1xuICAgICAgaWYgKCF3aXRoaW5Cb3VuZHMpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3Qgb3ZlcmxhcFBvaW50cyA9IGRhdGFWYWx1ZXMuc29tZShcbiAgICAgICAgKGRhdGFEYXR1bSkgPT4gY2lyY2xlUmVjdE92ZXJsYXAoZGF0YURhdHVtLnBvaW50LCBkYXRhRGF0dW0uYW5jaG9yLCB4LCB5LCB3aWR0aDIsIGhlaWdodDIpXG4gICAgICApO1xuICAgICAgaWYgKG92ZXJsYXBQb2ludHMpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3Qgb3ZlcmxhcExhYmVscyA9IHByZXZpb3VzUmVzdWx0cy5zb21lKChwcikgPT4gcmVjdFJlY3RPdmVybGFwKHByLCB4LCB5LCB3aWR0aDIsIGhlaWdodDIpKTtcbiAgICAgIGlmIChvdmVybGFwTGFiZWxzKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHJlc3VsdERhdHVtID0geyBpbmRleCwgdGV4dDogdGV4dDIsIHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiwgZGF0dW06IGQgfTtcbiAgICAgIGxhYmVscy5wdXNoKHJlc3VsdERhdHVtKTtcbiAgICAgIHByZXZpb3VzUmVzdWx0cy5wdXNoKHJlc3VsdERhdHVtKTtcbiAgICB9XG4gICAgcmVzdWx0LnNldChzZXJpZXNJZCwgbGFiZWxzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXhpc0xhYmVsc092ZXJsYXAoZGF0YSwgcGFkZGluZyA9IDApIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBkYXRhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGRhdHVtID0gZGF0YVtpbmRleF07XG4gICAgY29uc3Qge1xuICAgICAgcG9pbnQ6IHsgeCwgeSB9LFxuICAgICAgbGFiZWw6IHsgdGV4dDogdGV4dDIgfVxuICAgIH0gPSBkYXR1bTtcbiAgICBsZXQgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IGRhdHVtLmxhYmVsO1xuICAgIHdpZHRoMiArPSBwYWRkaW5nO1xuICAgIGhlaWdodDIgKz0gcGFkZGluZztcbiAgICBpZiAocmVzdWx0LnNvbWUoKGwpID0+IHJlY3RSZWN0T3ZlcmxhcChsLCB4LCB5LCB3aWR0aDIsIGhlaWdodDIpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHsgaW5kZXgsIHRleHQ6IHRleHQyLCB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIGRhdHVtIH0pO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9zZWNvbmRhcnlBeGlzVGlja3MudHNcbmZ1bmN0aW9uIGNhbGN1bGF0ZU5pY2VTZWNvbmRhcnlBeGlzKGRvbWFpbiwgcHJpbWFyeVRpY2tDb3VudCwgcmV2ZXJzZSkge1xuICBsZXQgW3N0YXJ0Miwgc3RvcF0gPSBmaW5kTWluTWF4KGRvbWFpbik7XG4gIHN0YXJ0MiA9IGNhbGN1bGF0ZU5pY2VTdGFydChNYXRoLmZsb29yKHN0YXJ0MiksIHN0b3AsIHByaW1hcnlUaWNrQ291bnQpO1xuICBjb25zdCBzdGVwID0gZ2V0VGlja1N0ZXAoc3RhcnQyLCBzdG9wLCBwcmltYXJ5VGlja0NvdW50KTtcbiAgY29uc3Qgc2VnbWVudHMgPSBwcmltYXJ5VGlja0NvdW50IC0gMTtcbiAgc3RvcCA9IHN0YXJ0MiArIHNlZ21lbnRzICogc3RlcDtcbiAgY29uc3QgZCA9IHJldmVyc2UgPyBbc3RvcCwgc3RhcnQyXSA6IFtzdGFydDIsIHN0b3BdO1xuICBjb25zdCB0aWNrcyA9IGdldFRpY2tzKHN0YXJ0Miwgc3RlcCwgcHJpbWFyeVRpY2tDb3VudCk7XG4gIHJldHVybiB7IGRvbWFpbjogZCwgdGlja3MgfTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZU5pY2VTdGFydChhLCBiLCBjb3VudCkge1xuICBjb25zdCByYXdTdGVwID0gTWF0aC5hYnMoYiAtIGEpIC8gKGNvdW50IC0gMSk7XG4gIGNvbnN0IG9yZGVyID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKHJhd1N0ZXApKTtcbiAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5wb3coMTAsIG9yZGVyKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoYSAvIG1hZ25pdHVkZSkgKiBtYWduaXR1ZGU7XG59XG5mdW5jdGlvbiBnZXRUaWNrcyhzdGFydDIsIHN0ZXAsIGNvdW50KSB7XG4gIGNvbnN0IHN0ZXBQb3dlciA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChzdGVwKSk7XG4gIGNvbnN0IGZyYWN0aW9uRGlnaXRzID0gc3RlcCA+IDAgJiYgc3RlcCA8IDEgPyBNYXRoLmFicyhzdGVwUG93ZXIpIDogMDtcbiAgY29uc3QgZiA9IE1hdGgucG93KDEwLCBmcmFjdGlvbkRpZ2l0cyk7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIGNvbnN0IHRpY2sgPSBzdGFydDIgKyBzdGVwICogaTtcbiAgICB0aWNrc1tpXSA9IE1hdGgucm91bmQodGljayAqIGYpIC8gZjtcbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5mdW5jdGlvbiBnZXRUaWNrU3RlcChzdGFydDIsIHN0b3AsIGNvdW50KSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gY291bnQgLSAxO1xuICBjb25zdCByYXdTdGVwID0gKHN0b3AgLSBzdGFydDIpIC8gc2VnbWVudHM7XG4gIHJldHVybiBjYWxjdWxhdGVOZXh0TmljZVN0ZXAocmF3U3RlcCk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVOZXh0TmljZVN0ZXAocmF3U3RlcCkge1xuICBjb25zdCBvcmRlciA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChyYXdTdGVwKSk7XG4gIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGgucG93KDEwLCBvcmRlcik7XG4gIGNvbnN0IHN0ZXAgPSByYXdTdGVwIC8gbWFnbml0dWRlICogMTA7XG4gIGlmIChzdGVwID4gMCAmJiBzdGVwIDw9IDEpIHtcbiAgICByZXR1cm4gbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgaWYgKHN0ZXAgPiAxICYmIHN0ZXAgPD0gMikge1xuICAgIHJldHVybiAyICogbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgaWYgKHN0ZXAgPiAxICYmIHN0ZXAgPD0gNSkge1xuICAgIHJldHVybiA1ICogbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgaWYgKHN0ZXAgPiA1ICYmIHN0ZXAgPD0gMTApIHtcbiAgICByZXR1cm4gMTAgKiBtYWduaXR1ZGUgLyAxMDtcbiAgfVxuICBpZiAoc3RlcCA+IDEwICYmIHN0ZXAgPD0gMjApIHtcbiAgICByZXR1cm4gMjAgKiBtYWduaXR1ZGUgLyAxMDtcbiAgfVxuICBpZiAoc3RlcCA+IDIwICYmIHN0ZXAgPD0gNDApIHtcbiAgICByZXR1cm4gNDAgKiBtYWduaXR1ZGUgLyAxMDtcbiAgfVxuICBpZiAoc3RlcCA+IDQwICYmIHN0ZXAgPD0gNTApIHtcbiAgICByZXR1cm4gNTAgKiBtYWduaXR1ZGUgLyAxMDtcbiAgfVxuICBpZiAoc3RlcCA+IDUwICYmIHN0ZXAgPD0gMTAwKSB7XG4gICAgcmV0dXJuIDEwMCAqIG1hZ25pdHVkZSAvIDEwO1xuICB9XG4gIHJldHVybiBzdGVwO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RlbXBVdGlscy50c1xuZnVuY3Rpb24gY3JlYXRlSWRzR2VuZXJhdG9yKCkge1xuICBjb25zdCBpZHNDb3VudGVyID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgcmV0dXJuIChuYW1lKSA9PiB7XG4gICAgY29uc3QgY291bnRlciA9IGlkc0NvdW50ZXIuZ2V0KG5hbWUpO1xuICAgIGlmIChjb3VudGVyKSB7XG4gICAgICBpZHNDb3VudGVyLnNldChuYW1lLCBjb3VudGVyICsgMSk7XG4gICAgICByZXR1cm4gYCR7bmFtZX1fJHtjb3VudGVyfWA7XG4gICAgfVxuICAgIGlkc0NvdW50ZXIuc2V0KG5hbWUsIDEpO1xuICAgIHJldHVybiBuYW1lO1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNUaWNrR2VuZXJhdG9yLnRzXG52YXIgQXhpc1RpY2tHZW5lcmF0b3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGF4aXMpIHtcbiAgICB0aGlzLmF4aXMgPSBheGlzO1xuICB9XG4gIGVzdGltYXRlVGlja0NvdW50KHZpc2libGVSYW5nZSwgbWluU3BhY2luZywgbWF4U3BhY2luZykge1xuICAgIHJldHVybiBlc3RpbWF0ZVRpY2tDb3VudChcbiAgICAgIGZpbmRSYW5nZUV4dGVudCh0aGlzLmF4aXMucmFuZ2UpLFxuICAgICAgZmluZFJhbmdlRXh0ZW50KHZpc2libGVSYW5nZSksXG4gICAgICBtaW5TcGFjaW5nLFxuICAgICAgbWF4U3BhY2luZyxcbiAgICAgIENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0VGlja0NvdW50LFxuICAgICAgdGhpcy5heGlzLmRlZmF1bHRUaWNrTWluU3BhY2luZ1xuICAgICk7XG4gIH1cbiAgZmlsdGVyVGlja3ModGlja3MsIHRpY2tDb3VudCkge1xuICAgIGNvbnN0IHsgbWluU3BhY2luZywgbWF4U3BhY2luZyB9ID0gdGhpcy5heGlzLmludGVydmFsO1xuICAgIGNvbnN0IHRpY2tTcGFjaW5nID0gIWlzTmFOKG1pblNwYWNpbmcpIHx8ICFpc05hTihtYXhTcGFjaW5nKTtcbiAgICBjb25zdCBrZWVwRXZlcnkgPSB0aWNrU3BhY2luZyA/IE1hdGguY2VpbCh0aWNrcy5sZW5ndGggLyB0aWNrQ291bnQpIDogMjtcbiAgICBjb25zdCBvZmZzZXQ0ID0gdGlja3MubGVuZ3RoICUga2VlcEV2ZXJ5ID8gLTEgOiAwO1xuICAgIHJldHVybiB0aWNrcy5maWx0ZXIoKF8sIGkpID0+IChpICsgb2Zmc2V0NCkgJSBrZWVwRXZlcnkgPT09IDApO1xuICB9XG4gIGdlbmVyYXRlVGlja3Moe1xuICAgIGRvbWFpbixcbiAgICBwcmltYXJ5VGlja0NvdW50LFxuICAgIHZpc2libGVSYW5nZSxcbiAgICBuaWNlTW9kZSxcbiAgICBwYXJhbGxlbEZsaXBSb3RhdGlvbixcbiAgICByZWd1bGFyRmxpcFJvdGF0aW9uLFxuICAgIGxhYmVsWCxcbiAgICBzaWRlRmxhZ1xuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgc2NhbGU6IHNjYWxlMixcbiAgICAgIGxhYmVsLFxuICAgICAgaW50ZXJ2YWw6IHsgbWluU3BhY2luZywgbWF4U3BhY2luZyB9XG4gICAgfSA9IHRoaXMuYXhpcztcbiAgICBjb25zdCB7IHBhcmFsbGVsLCByb3RhdGlvbiwgZm9udEZhbWlseSwgZm9udFNpemUsIGZvbnRTdHlsZSwgZm9udFdlaWdodCB9ID0gbGFiZWw7XG4gICAgY29uc3Qgc2Vjb25kYXJ5QXhpcyA9IHByaW1hcnlUaWNrQ291bnQgIT09IHZvaWQgMDtcbiAgICBjb25zdCB7IGRlZmF1bHRSb3RhdGlvbiwgY29uZmlndXJlZFJvdGF0aW9uLCBwYXJhbGxlbEZsaXBGbGFnLCByZWd1bGFyRmxpcEZsYWcgfSA9IGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oe1xuICAgICAgcm90YXRpb24sXG4gICAgICBwYXJhbGxlbCxcbiAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb24sXG4gICAgICBwYXJhbGxlbEZsaXBSb3RhdGlvblxuICAgIH0pO1xuICAgIGNvbnN0IGluaXRpYWxSb3RhdGlvbiA9IGNvbmZpZ3VyZWRSb3RhdGlvbiArIGRlZmF1bHRSb3RhdGlvbjtcbiAgICBjb25zdCBsYWJlbE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICBjb25zdCB7IG1heFRpY2tDb3VudCB9ID0gdGhpcy5lc3RpbWF0ZVRpY2tDb3VudCh2aXNpYmxlUmFuZ2UsIG1pblNwYWNpbmcsIG1heFNwYWNpbmcpO1xuICAgIGNvbnN0IGNvbnRpbnVvdXMgPSBDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSB8fCBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMik7XG4gICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9ICFjb250aW51b3VzIHx8IGlzTmFOKG1heFRpY2tDb3VudCkgPyAxMCA6IG1heFRpY2tDb3VudDtcbiAgICBsZXQgdGV4dEFsaWduID0gZ2V0VGV4dEFsaWduKHBhcmFsbGVsLCBjb25maWd1cmVkUm90YXRpb24sIDAsIHNpZGVGbGFnLCByZWd1bGFyRmxpcEZsYWcpO1xuICAgIGNvbnN0IHRleHRCYXNlbGluZSA9IGdldFRleHRCYXNlbGluZShwYXJhbGxlbCwgY29uZmlndXJlZFJvdGF0aW9uLCBzaWRlRmxhZywgcGFyYWxsZWxGbGlwRmxhZyk7XG4gICAgY29uc3QgZm9udDIgPSBUZXh0VXRpbHMudG9Gb250U3RyaW5nKHsgZm9udEZhbWlseSwgZm9udFNpemUsIGZvbnRTdHlsZSwgZm9udFdlaWdodCB9KTtcbiAgICBjb25zdCB0ZXh0TWVhc3VyZXIgPSBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLmdldE1lYXN1cmVyKHsgZm9udDogZm9udDIgfSk7XG4gICAgY29uc3QgdGV4dFByb3BzID0ge1xuICAgICAgZm9udEZhbWlseSxcbiAgICAgIGZvbnRTaXplLFxuICAgICAgZm9udFN0eWxlLFxuICAgICAgZm9udFdlaWdodCxcbiAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgIHRleHRBbGlnblxuICAgIH07XG4gICAgY29uc3QgY2hlY2tMYWJlbE92ZXJsYXAgPSBsYWJlbC5lbmFibGVkICYmIGxhYmVsLmF2b2lkQ29sbGlzaW9ucztcbiAgICBjb25zdCBnZXRMYWJlbE92ZXJsYXAgPSAoeyB0aWNrcyB9LCBpdGVyYXRpb25Sb3RhdGlvbikgPT4ge1xuICAgICAgaWYgKCFjaGVja0xhYmVsT3ZlcmxhcClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgY29uc3Qgcm90YXRlZCA9IGNvbmZpZ3VyZWRSb3RhdGlvbiAhPT0gMCB8fCBpdGVyYXRpb25Sb3RhdGlvbiAhPT0gMDtcbiAgICAgIGNvbnN0IGxhYmVsUm90YXRpb24gPSBpbml0aWFsUm90YXRpb24gKyBpdGVyYXRpb25Sb3RhdGlvbjtcbiAgICAgIGNvbnN0IGxhYmVsU3BhY2luZyA9IGdldExhYmVsU3BhY2luZyhsYWJlbC5taW5TcGFjaW5nLCByb3RhdGVkKTtcbiAgICAgIE1hdHJpeC51cGRhdGVUcmFuc2Zvcm1NYXRyaXgobGFiZWxNYXRyaXgsIDEsIDEsIGxhYmVsUm90YXRpb24sIDAsIDApO1xuICAgICAgY29uc3QgbGFiZWxEYXRhID0gY3JlYXRlTGFiZWxEYXRhKHRpY2tzLCBsYWJlbFgsIGxhYmVsTWF0cml4LCB0ZXh0TWVhc3VyZXIpO1xuICAgICAgcmV0dXJuIGF4aXNMYWJlbHNPdmVybGFwKGxhYmVsRGF0YSwgbGFiZWxTcGFjaW5nKTtcbiAgICB9O1xuICAgIGxldCB0aWNrRGF0YSA9IHtcbiAgICAgIHRpY2tEb21haW46IFtdLFxuICAgICAgdGlja3M6IFtdLFxuICAgICAgcmF3VGlja3M6IFtdLFxuICAgICAgZnJhY3Rpb25EaWdpdHM6IDAsXG4gICAgICBuaWNlRG9tYWluOiB2b2lkIDBcbiAgICB9O1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgbGV0IGF1dG9Sb3RhdGlvbiA9IDA7XG4gICAgbGV0IGxhYmVsT3ZlcmxhcCA9IHRydWU7XG4gICAgbGV0IHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIHdoaWxlICghdGVybWluYXRlICYmIGxhYmVsT3ZlcmxhcCAmJiBpbmRleCA8PSBtYXhJdGVyYXRpb25zKSB7XG4gICAgICBhdXRvUm90YXRpb24gPSAwO1xuICAgICAgZm9yIChjb25zdCBzdHJhdGVneSBvZiB0aGlzLmdldFRpY2tTdHJhdGVnaWVzKHsgZG9tYWluLCBuaWNlTW9kZSwgc2Vjb25kYXJ5QXhpcywgaW5kZXggfSkpIHtcbiAgICAgICAgKHsgdGlja0RhdGEsIGluZGV4LCBhdXRvUm90YXRpb24sIHRlcm1pbmF0ZSB9ID0gc3RyYXRlZ3koe1xuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHRpY2tEYXRhLFxuICAgICAgICAgIHRleHRQcm9wcyxcbiAgICAgICAgICB0ZXJtaW5hdGUsXG4gICAgICAgICAgcHJpbWFyeVRpY2tDb3VudCxcbiAgICAgICAgICB2aXNpYmxlUmFuZ2UsXG4gICAgICAgICAgLy8gTGF6aWx5IGdlbmVyYXRlIGFzIG9ubHkgb25lIHN0cmF0ZWd5IGFjdHVhbGx5IHVzZXMgdGhpcywgYW5kIGl0J3MgZXhwZW5zaXZlIHRvIGNvbXB1dGVcbiAgICAgICAgICBnZXQgbGFiZWxPdmVybGFwKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldExhYmVsT3ZlcmxhcCh0aWNrRGF0YSwgYXV0b1JvdGF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGxhYmVsT3ZlcmxhcCA9IGdldExhYmVsT3ZlcmxhcCh0aWNrRGF0YSwgYXV0b1JvdGF0aW9uKTtcbiAgICB9XG4gICAgdGV4dEFsaWduID0gZ2V0VGV4dEFsaWduKHBhcmFsbGVsLCBjb25maWd1cmVkUm90YXRpb24sIGF1dG9Sb3RhdGlvbiwgc2lkZUZsYWcsIHJlZ3VsYXJGbGlwRmxhZyk7XG4gICAgY29uc3QgY29tYmluZWRSb3RhdGlvbiA9IGRlZmF1bHRSb3RhdGlvbiArIGNvbmZpZ3VyZWRSb3RhdGlvbiArIGF1dG9Sb3RhdGlvbjtcbiAgICBpZiAoIXNlY29uZGFyeUF4aXMgJiYgdGlja0RhdGEucmF3VGlja3MubGVuZ3RoID4gMCkge1xuICAgICAgcHJpbWFyeVRpY2tDb3VudCA9IHRpY2tEYXRhLnJhd1RpY2tzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGlja0RhdGEsIHByaW1hcnlUaWNrQ291bnQsIGNvbWJpbmVkUm90YXRpb24sIHRleHRCYXNlbGluZSwgdGV4dEFsaWduIH07XG4gIH1cbiAgZ2V0VGlja1N0cmF0ZWdpZXMoe1xuICAgIGRvbWFpbixcbiAgICBuaWNlTW9kZSxcbiAgICBpbmRleDogaXRlcmF0aW9uLFxuICAgIHNlY29uZGFyeUF4aXNcbiAgfSkge1xuICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiwgbGFiZWwsIGludGVydmFsIH0gPSB0aGlzLmF4aXM7XG4gICAgY29uc3QgeyBtaW5TcGFjaW5nIH0gPSBpbnRlcnZhbDtcbiAgICBjb25zdCBjb250aW51b3VzID0gQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikgfHwgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpO1xuICAgIGNvbnN0IGF2b2lkTGFiZWxDb2xsaXNpb25zID0gbGFiZWwuZW5hYmxlZCAmJiBsYWJlbC5hdm9pZENvbGxpc2lvbnM7XG4gICAgY29uc3QgZmlsdGVyVGlja3MgPSAhY29udGludW91cyAmJiBpdGVyYXRpb24gIT09IDAgJiYgYXZvaWRMYWJlbENvbGxpc2lvbnM7XG4gICAgY29uc3QgYXV0b1JvdGF0ZSA9IGxhYmVsLmF1dG9Sb3RhdGUgPT09IHRydWUgJiYgbGFiZWwucm90YXRpb24gPT09IHZvaWQgMDtcbiAgICBjb25zdCBzdHJhdGVnaWVzID0gW107XG4gICAgbGV0IHRpY2tHZW5lcmF0aW9uVHlwZTtcbiAgICBpZiAoaW50ZXJ2YWwudmFsdWVzKSB7XG4gICAgICB0aWNrR2VuZXJhdGlvblR5cGUgPSAzIC8qIFZBTFVFUyAqLztcbiAgICB9IGVsc2UgaWYgKHNlY29uZGFyeUF4aXMpIHtcbiAgICAgIHRpY2tHZW5lcmF0aW9uVHlwZSA9IDEgLyogQ1JFQVRFX1NFQ09OREFSWSAqLztcbiAgICB9IGVsc2UgaWYgKGZpbHRlclRpY2tzKSB7XG4gICAgICB0aWNrR2VuZXJhdGlvblR5cGUgPSAyIC8qIEZJTFRFUiAqLztcbiAgICB9IGVsc2Uge1xuICAgICAgdGlja0dlbmVyYXRpb25UeXBlID0gMCAvKiBDUkVBVEUgKi87XG4gICAgfVxuICAgIGNvbnN0IHRpY2tHZW5lcmF0aW9uU3RyYXRlZ3kgPSAoe1xuICAgICAgaW5kZXgsXG4gICAgICB0aWNrRGF0YSxcbiAgICAgIHByaW1hcnlUaWNrQ291bnQsXG4gICAgICB2aXNpYmxlUmFuZ2UsXG4gICAgICB0ZXJtaW5hdGVcbiAgICB9KSA9PiB0aGlzLmNyZWF0ZVRpY2tEYXRhKFxuICAgICAgZG9tYWluLFxuICAgICAgbmljZU1vZGUsXG4gICAgICB2aXNpYmxlUmFuZ2UsXG4gICAgICBwcmltYXJ5VGlja0NvdW50LFxuICAgICAgdGlja0dlbmVyYXRpb25UeXBlLFxuICAgICAgaW5kZXgsXG4gICAgICB0aWNrRGF0YSxcbiAgICAgIHRlcm1pbmF0ZVxuICAgICk7XG4gICAgc3RyYXRlZ2llcy5wdXNoKHRpY2tHZW5lcmF0aW9uU3RyYXRlZ3kpO1xuICAgIGlmICghY29udGludW91cyAmJiAhaXNOYU4obWluU3BhY2luZykpIHtcbiAgICAgIGNvbnN0IHRpY2tGaWx0ZXJTdHJhdGVneSA9ICh7XG4gICAgICAgIGluZGV4LFxuICAgICAgICB0aWNrRGF0YSxcbiAgICAgICAgcHJpbWFyeVRpY2tDb3VudCxcbiAgICAgICAgdmlzaWJsZVJhbmdlLFxuICAgICAgICB0ZXJtaW5hdGVcbiAgICAgIH0pID0+IHRoaXMuY3JlYXRlVGlja0RhdGEoXG4gICAgICAgIGRvbWFpbixcbiAgICAgICAgbmljZU1vZGUsXG4gICAgICAgIHZpc2libGVSYW5nZSxcbiAgICAgICAgcHJpbWFyeVRpY2tDb3VudCxcbiAgICAgICAgMiAvKiBGSUxURVIgKi8sXG4gICAgICAgIGluZGV4LFxuICAgICAgICB0aWNrRGF0YSxcbiAgICAgICAgdGVybWluYXRlXG4gICAgICApO1xuICAgICAgc3RyYXRlZ2llcy5wdXNoKHRpY2tGaWx0ZXJTdHJhdGVneSk7XG4gICAgfVxuICAgIGlmIChhdm9pZExhYmVsQ29sbGlzaW9ucyAmJiBhdXRvUm90YXRlKSB7XG4gICAgICBjb25zdCBhdXRvUm90YXRlU3RyYXRlZ3kgPSAoeyBpbmRleCwgdGlja0RhdGEsIGxhYmVsT3ZlcmxhcCwgdGVybWluYXRlIH0pID0+ICh7XG4gICAgICAgIGluZGV4LFxuICAgICAgICB0aWNrRGF0YSxcbiAgICAgICAgYXV0b1JvdGF0aW9uOiBsYWJlbE92ZXJsYXAgPyBub3JtYWxpemVBbmdsZTM2MCh0b1JhZGlhbnMobGFiZWwuYXV0b1JvdGF0ZUFuZ2xlID8/IDApKSA6IDAsXG4gICAgICAgIHRlcm1pbmF0ZVxuICAgICAgfSk7XG4gICAgICBzdHJhdGVnaWVzLnB1c2goYXV0b1JvdGF0ZVN0cmF0ZWd5KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmF0ZWdpZXM7XG4gIH1cbiAgY3JlYXRlVGlja0RhdGEoZG9tYWluLCBuaWNlTW9kZSwgdmlzaWJsZVJhbmdlLCBwcmltYXJ5VGlja0NvdW50LCB0aWNrR2VuZXJhdGlvblR5cGUsIGluZGV4LCB0aWNrRGF0YSwgdGVybWluYXRlKSB7XG4gICAgY29uc3QgeyBzY2FsZTogc2NhbGUyLCBpbnRlcnZhbCB9ID0gdGhpcy5heGlzO1xuICAgIGNvbnN0IHsgc3RlcCwgdmFsdWVzLCBtaW5TcGFjaW5nLCBtYXhTcGFjaW5nIH0gPSBpbnRlcnZhbDtcbiAgICBjb25zdCB7IG1heFRpY2tDb3VudCwgbWluVGlja0NvdW50LCB0aWNrQ291bnQgfSA9IHRoaXMuZXN0aW1hdGVUaWNrQ291bnQodmlzaWJsZVJhbmdlLCBtaW5TcGFjaW5nLCBtYXhTcGFjaW5nKTtcbiAgICBjb25zdCBjb250aW51b3VzID0gQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikgfHwgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpO1xuICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSAhY29udGludW91cyB8fCBpc05hTihtYXhUaWNrQ291bnQpID8gMTAgOiBtYXhUaWNrQ291bnQ7XG4gICAgY29uc3QgY291bnRUaWNrcyA9IChpKSA9PiBjb250aW51b3VzID8gTWF0aC5tYXgodGlja0NvdW50IC0gaSwgbWluVGlja0NvdW50KSA6IG1heFRpY2tDb3VudDtcbiAgICBjb25zdCByZWdlbmVyYXRlVGlja3MgPSBzdGVwID09IG51bGwgJiYgdmFsdWVzID09IG51bGwgJiYgY291bnRUaWNrcyhpbmRleCkgPiBtaW5UaWNrQ291bnQgJiYgKGNvbnRpbnVvdXMgfHwgdGlja0dlbmVyYXRpb25UeXBlID09PSAyIC8qIEZJTFRFUiAqLyk7XG4gICAgd2hpbGUgKGluZGV4IDw9IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzVGlja3MgPSB0aWNrRGF0YS5yYXdUaWNrcztcbiAgICAgIHRpY2tEYXRhID0gdGhpcy5nZXRUaWNrcyh7XG4gICAgICAgIGRvbWFpbixcbiAgICAgICAgbmljZU1vZGUsXG4gICAgICAgIHZpc2libGVSYW5nZSxcbiAgICAgICAgdGlja0dlbmVyYXRpb25UeXBlLFxuICAgICAgICBwcmV2aW91c1RpY2tzLFxuICAgICAgICBtaW5UaWNrQ291bnQsXG4gICAgICAgIG1heFRpY2tDb3VudCxcbiAgICAgICAgcHJpbWFyeVRpY2tDb3VudCxcbiAgICAgICAgdGlja0NvdW50OiBjb3VudFRpY2tzKGluZGV4KVxuICAgICAgfSk7XG4gICAgICBpbmRleCsrO1xuICAgICAgaWYgKCFyZWdlbmVyYXRlVGlja3MgfHwgIWFycmF5c0VxdWFsKHRpY2tEYXRhLnJhd1RpY2tzLCBwcmV2aW91c1RpY2tzKSlcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRlcm1pbmF0ZSB8fCAodGVybWluYXRlID0gc3RlcCAhPSBudWxsIHx8IHZhbHVlcyAhPSBudWxsKTtcbiAgICByZXR1cm4geyB0aWNrRGF0YSwgaW5kZXgsIGF1dG9Sb3RhdGlvbjogMCwgdGVybWluYXRlIH07XG4gIH1cbiAgZ2V0VGlja3Moe1xuICAgIGRvbWFpbixcbiAgICBuaWNlTW9kZSxcbiAgICB2aXNpYmxlUmFuZ2UsXG4gICAgdGlja0dlbmVyYXRpb25UeXBlLFxuICAgIHByZXZpb3VzVGlja3MsXG4gICAgdGlja0NvdW50LFxuICAgIG1pblRpY2tDb3VudCxcbiAgICBtYXhUaWNrQ291bnQsXG4gICAgcHJpbWFyeVRpY2tDb3VudFxuICB9KSB7XG4gICAgY29uc3QgeyBheGlzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbGFiZWwsIHJhbmdlOiByYW5nZTMsIHNjYWxlOiBzY2FsZTIsIGludGVydmFsIH0gPSBheGlzO1xuICAgIGNvbnN0IGlkR2VuZXJhdG9yID0gY3JlYXRlSWRzR2VuZXJhdG9yKCk7XG4gICAgY29uc3QgZG9tYWluUGFyYW1zID0ge1xuICAgICAgbmljZTogbmljZU1vZGUgPT09IDAgLyogVGlja0FuZERvbWFpbiAqLyxcbiAgICAgIGludGVydmFsOiBpbnRlcnZhbC5zdGVwLFxuICAgICAgdGlja0NvdW50LFxuICAgICAgbWluVGlja0NvdW50LFxuICAgICAgbWF4VGlja0NvdW50XG4gICAgfTtcbiAgICBjb25zdCB0aWNrUGFyYW1zID0ge1xuICAgICAgLi4uZG9tYWluUGFyYW1zLFxuICAgICAgbmljZTogbmljZU1vZGUgPT09IDAgLyogVGlja0FuZERvbWFpbiAqLyB8fCBuaWNlTW9kZSA9PT0gMSAvKiBUaWNrc09ubHkgKi9cbiAgICB9O1xuICAgIGxldCBuaWNlRG9tYWluID0gbmljZU1vZGUgPT09IDAgLyogVGlja0FuZERvbWFpbiAqLyA/IHNjYWxlMi5uaWNlRG9tYWluKGRvbWFpblBhcmFtcywgZG9tYWluKSA6IGRvbWFpbjtcbiAgICBsZXQgdGlja0RvbWFpbiA9IG5pY2VEb21haW47XG4gICAgbGV0IHJhd1RpY2tzO1xuICAgIHN3aXRjaCAodGlja0dlbmVyYXRpb25UeXBlKSB7XG4gICAgICBjYXNlIDMgLyogVkFMVUVTICovOlxuICAgICAgICB0aWNrRG9tYWluID0gaW50ZXJ2YWwudmFsdWVzO1xuICAgICAgICByYXdUaWNrcyA9IGludGVydmFsLnZhbHVlcztcbiAgICAgICAgaWYgKENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZTIpKSB7XG4gICAgICAgICAgY29uc3QgW2QwLCBkMV0gPSBmaW5kTWluTWF4KG5pY2VEb21haW4ubWFwKE51bWJlcikpO1xuICAgICAgICAgIHJhd1RpY2tzID0gcmF3VGlja3MuZmlsdGVyKCh2YWx1ZSkgPT4gTnVtYmVyKHZhbHVlKSA+PSBkMCAmJiBOdW1iZXIodmFsdWUpIDw9IGQxKS5zb3J0KChhLCBiKSA9PiBOdW1iZXIoYSkgLSBOdW1iZXIoYikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxIC8qIENSRUFURV9TRUNPTkRBUlkgKi86XG4gICAgICAgIGlmIChDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSkge1xuICAgICAgICAgIGNvbnN0IHNlY29uZGFyeUF4aXNUaWNrcyA9IGNhbGN1bGF0ZU5pY2VTZWNvbmRhcnlBeGlzKFxuICAgICAgICAgICAgZG9tYWluLm1hcChOdW1iZXIpLFxuICAgICAgICAgICAgcHJpbWFyeVRpY2tDb3VudCA/PyAwLFxuICAgICAgICAgICAgYXhpcy5yZXZlcnNlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByYXdUaWNrcyA9IHNlY29uZGFyeUF4aXNUaWNrcy50aWNrcztcbiAgICAgICAgICBuaWNlRG9tYWluID0gc2Vjb25kYXJ5QXhpc1RpY2tzLmRvbWFpbi5tYXAoKGQpID0+IHNjYWxlMi50b0RvbWFpbihkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmF3VGlja3MgPSBzY2FsZTIudGlja3ModGlja1BhcmFtcywgbmljZURvbWFpbiwgdmlzaWJsZVJhbmdlKSA/PyBbXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMiAvKiBGSUxURVIgKi86XG4gICAgICAgIHJhd1RpY2tzID0gdGhpcy5maWx0ZXJUaWNrcyhwcmV2aW91c1RpY2tzLCB0aWNrQ291bnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJhd1RpY2tzID0gc2NhbGUyLnRpY2tzKHRpY2tQYXJhbXMsIG5pY2VEb21haW4sIHZpc2libGVSYW5nZSkgPz8gW107XG4gICAgfVxuICAgIGNvbnN0IGZyYWN0aW9uRGlnaXRzID0gcmF3VGlja3MucmVkdWNlKFxuICAgICAgKG1heCwgdGljaykgPT4gTWF0aC5tYXgobWF4LCB0eXBlb2YgdGljayA9PT0gXCJudW1iZXJcIiA/IGNvdW50RnJhY3Rpb25EaWdpdHModGljaykgOiAwKSxcbiAgICAgIDBcbiAgICApO1xuICAgIGNvbnN0IGZvcm1hdFBhcmFtcyA9IHtcbiAgICAgIGRvbWFpbjogdGlja0RvbWFpbixcbiAgICAgIHRpY2tzOiByYXdUaWNrcyxcbiAgICAgIGZyYWN0aW9uRGlnaXRzLFxuICAgICAgc3BlY2lmaWVyOiBsYWJlbC5mb3JtYXRcbiAgICB9O1xuICAgIGNvbnN0IGxhYmVsRm9ybWF0dGVyID0gc2NhbGUyLnRpY2tGb3JtYXR0ZXIoZm9ybWF0UGFyYW1zKTtcbiAgICBjb25zdCBzY2FsZURvbWFpbiA9IHNjYWxlMi5kb21haW47XG4gICAgc2NhbGUyLmRvbWFpbiA9IG5pY2VEb21haW47XG4gICAgY29uc3QgaGFsZkJhbmR3aWR0aCA9IChzY2FsZTIuYmFuZHdpZHRoID8/IDApIC8gMjtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3VGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRpY2sgPSByYXdUaWNrc1tpXTtcbiAgICAgIGNvbnN0IHRyYW5zbGF0aW9uWSA9IHNjYWxlMi5jb252ZXJ0KHRpY2spICsgaGFsZkJhbmR3aWR0aDtcbiAgICAgIGlmIChyYW5nZTMubGVuZ3RoID4gMCAmJiAhYXhpcy5pblJhbmdlKHRyYW5zbGF0aW9uWSwgMWUtMykpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdGlja0xhYmVsID0gbGFiZWwuZW5hYmxlZCA/IGF4aXMuZm9ybWF0VGljayh0aWNrLCBpLCBmcmFjdGlvbkRpZ2l0cywgbGFiZWxGb3JtYXR0ZXIpIDogXCJcIjtcbiAgICAgIHRpY2tzLnB1c2goeyB0aWNrLCB0aWNrSWQ6IGlkR2VuZXJhdG9yKHRpY2tMYWJlbCksIHRpY2tMYWJlbCwgdHJhbnNsYXRpb25ZOiBNYXRoLmZsb29yKHRyYW5zbGF0aW9uWSkgfSk7XG4gICAgfVxuICAgIHNjYWxlMi5kb21haW4gPSBzY2FsZURvbWFpbjtcbiAgICByZXR1cm4ge1xuICAgICAgdGlja0RvbWFpbixcbiAgICAgIHJhd1RpY2tzLFxuICAgICAgZnJhY3Rpb25EaWdpdHMsXG4gICAgICB0aWNrcyxcbiAgICAgIG5pY2VEb21haW5cbiAgICB9O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2NhcnRlc2lhbkF4aXNMYWJlbC50c1xudmFyIENhcnRlc2lhbkF4aXNMYWJlbCA9IGNsYXNzIGV4dGVuZHMgQXhpc0xhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmF1dG9Sb3RhdGVBbmdsZSA9IDMzNTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkF4aXNMYWJlbC5wcm90b3R5cGUsIFwiYXV0b1JvdGF0ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIENhcnRlc2lhbkF4aXNMYWJlbC5wcm90b3R5cGUsIFwiYXV0b1JvdGF0ZUFuZ2xlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2NhcnRlc2lhbkF4aXMudHNcbnZhciBfQ2FydGVzaWFuQXhpcyA9IGNsYXNzIF9DYXJ0ZXNpYW5BeGlzIGV4dGVuZHMgQXhpcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCwgc2NhbGUyKSB7XG4gICAgc3VwZXIobW9kdWxlQ3R4LCBzY2FsZTIpO1xuICAgIHRoaXMubGluZU5vZGUgPSB0aGlzLmF4aXNHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBUcmFuc2xhdGFibGVMaW5lKHtcbiAgICAgICAgbmFtZTogYCR7dGhpcy5pZH0tQXhpcy1saW5lYCxcbiAgICAgICAgekluZGV4OiAxIC8qIEF4aXNMaW5lICovXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy50ZW1wVGV4dCA9IG5ldyBUcmFuc2Zvcm1hYmxlVGV4dCgpO1xuICAgIHRoaXMudGVtcENhcHRpb24gPSBuZXcgQ2FwdGlvbigpO1xuICAgIHRoaXMudGlja0dlbmVyYXRvciA9IG5ldyBBeGlzVGlja0dlbmVyYXRvcih0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZFRpY2tzID0gdm9pZCAwO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlciA9IG1vZHVsZUN0eC5hbmltYXRpb25NYW5hZ2VyO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBuZXcgU3RhdGVNYWNoaW5lKFwiZW1wdHlcIiwge1xuICAgICAgZW1wdHk6IHtcbiAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgICAgYWN0aW9uOiAoKSA9PiB0aGlzLnJlc2V0U2VsZWN0aW9uTm9kZXMoKVxuICAgICAgICB9LFxuICAgICAgICByZXNldDogXCJlbXB0eVwiXG4gICAgICB9LFxuICAgICAgcmVhZHk6IHtcbiAgICAgICAgdXBkYXRlOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlVcGRhdGUoZGF0YSksXG4gICAgICAgIHJlc2l6ZTogKCkgPT4gdGhpcy5yZXNldFNlbGVjdGlvbk5vZGVzKCksXG4gICAgICAgIHJlc2V0OiBcImVtcHR5XCJcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmF4aXNHcm91cC5hcHBlbmRDaGlsZCh0aGlzLnRpdGxlLmNhcHRpb24ubm9kZSk7XG4gICAgbGV0IHByZXZpb3VzU2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIG1vZHVsZUN0eC5sYXlvdXRNYW5hZ2VyLmFkZExpc3RlbmVyKFwibGF5b3V0OmNvbXBsZXRlXCIsIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBbZS5jaGFydC53aWR0aCwgZS5jaGFydC5oZWlnaHRdO1xuICAgICAgICBpZiAocHJldmlvdXNTaXplICE9IG51bGwgJiYgIWFycmF5c0VxdWFsKHNpemUsIHByZXZpb3VzU2l6ZSkpIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJyZXNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNTaXplID0gc2l6ZTtcbiAgICAgIH0pLFxuICAgICAgdGhpcy50aXRsZS5jYXB0aW9uLnJlZ2lzdGVySW50ZXJhY3Rpb24odGhpcy5tb2R1bGVDdHgsIFwiYWZ0ZXJlbmRcIilcbiAgICApO1xuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9DYXJ0ZXNpYW5BeGlzO1xuICB9XG4gIHJlc2V0QW5pbWF0aW9uKHBoYXNlKSB7XG4gICAgaWYgKHBoYXNlID09PSBcImluaXRpYWxcIikge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwicmVzZXRcIik7XG4gICAgfVxuICB9XG4gIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IFwidG9wXCIgfHwgdGhpcy5wb3NpdGlvbiA9PT0gXCJib3R0b21cIiA/IFwieFwiIC8qIFggKi8gOiBcInlcIiAvKiBZICovO1xuICB9XG4gIGNyZWF0ZUF4aXNDb250ZXh0KCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmNyZWF0ZUF4aXNDb250ZXh0KCksIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uIH07XG4gIH1cbiAgY3JlYXRlTGFiZWwoKSB7XG4gICAgcmV0dXJuIG5ldyBDYXJ0ZXNpYW5BeGlzTGFiZWwoKTtcbiAgfVxuICB1cGRhdGVEaXJlY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLnBvc2l0aW9uKSB7XG4gICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIHRoaXMucm90YXRpb24gPSAtOTA7XG4gICAgICAgIHRoaXMubGFiZWwubWlycm9yZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhYmVsLnBhcmFsbGVsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMubGFiZWwubWlycm9yZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhYmVsLnBhcmFsbGVsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gLTkwO1xuICAgICAgICB0aGlzLmxhYmVsLm1pcnJvcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFiZWwucGFyYWxsZWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xuICAgICAgICB0aGlzLmxhYmVsLm1pcnJvcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFiZWwucGFyYWxsZWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLmF4aXNDb250ZXh0KSB7XG4gICAgICB0aGlzLmF4aXNDb250ZXh0LnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgIHRoaXMuYXhpc0NvbnRleHQuZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb247XG4gICAgfVxuICB9XG4gIGNhbGN1bGF0ZUxheW91dChwcmltYXJ5VGlja0NvdW50KSB7XG4gICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTtcbiAgICByZXR1cm4gc3VwZXIuY2FsY3VsYXRlTGF5b3V0KHByaW1hcnlUaWNrQ291bnQpO1xuICB9XG4gIGNhbGN1bGF0ZVRpY2tMYXlvdXQoZG9tYWluLCBuaWNlTW9kZSwgdmlzaWJsZVJhbmdlLCBpbml0aWFsUHJpbWFyeVRpY2tDb3VudCkge1xuICAgIGNvbnN0IHNpZGVGbGFnID0gdGhpcy5sYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIGNvbnN0IHsgcGFyYWxsZWxGbGlwUm90YXRpb24sIHJlZ3VsYXJGbGlwUm90YXRpb24gfSA9IHRoaXMuY2FsY3VsYXRlUm90YXRpb25zKCk7XG4gICAgY29uc3QgbGFiZWxYID0gc2lkZUZsYWcgKiAodGhpcy5nZXRUaWNrU2l6ZSgpICsgdGhpcy5sYWJlbC5zcGFjaW5nICsgdGhpcy5zZXJpZXNBcmVhUGFkZGluZyk7XG4gICAgY29uc3QgdGlja0dlbmVyYXRpb25SZXN1bHQgPSB0aGlzLnRpY2tHZW5lcmF0b3IuZ2VuZXJhdGVUaWNrcyh7XG4gICAgICBkb21haW4sXG4gICAgICBuaWNlTW9kZSxcbiAgICAgIHZpc2libGVSYW5nZSxcbiAgICAgIHByaW1hcnlUaWNrQ291bnQ6IGluaXRpYWxQcmltYXJ5VGlja0NvdW50LFxuICAgICAgcGFyYWxsZWxGbGlwUm90YXRpb24sXG4gICAgICByZWd1bGFyRmxpcFJvdGF0aW9uLFxuICAgICAgbGFiZWxYLFxuICAgICAgc2lkZUZsYWdcbiAgICB9KTtcbiAgICBjb25zdCB7IHRpY2tEYXRhLCBwcmltYXJ5VGlja0NvdW50ID0gaW5pdGlhbFByaW1hcnlUaWNrQ291bnQgfSA9IHRpY2tHZW5lcmF0aW9uUmVzdWx0O1xuICAgIGNvbnN0IHsgdGlja3MsIHRpY2tEb21haW4sIHJhd1RpY2tzLCBmcmFjdGlvbkRpZ2l0cywgbmljZURvbWFpbiA9IGRvbWFpbiB9ID0gdGlja0RhdGE7XG4gICAgY29uc3QgbGFiZWxzID0gdGlja3MubWFwKChkKSA9PiB0aGlzLmdldFRpY2tMYWJlbFByb3BzKGQsIHRpY2tHZW5lcmF0aW9uUmVzdWx0KSk7XG4gICAgY29uc3QgYmJveCA9IHRoaXMudGlja0JCb3godGlja3MsIGxhYmVscyk7XG4gICAgdGhpcy5nZW5lcmF0ZWRUaWNrcyA9IHsgdGlja3MsIGxhYmVscyB9O1xuICAgIHJldHVybiB7IHRpY2tzOiByYXdUaWNrcywgdGlja0RvbWFpbiwgbmljZURvbWFpbiwgcHJpbWFyeVRpY2tDb3VudCwgZnJhY3Rpb25EaWdpdHMsIGJib3ggfTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTtcbiAgICBjb25zdCBwcmV2aW91c1RpY2tzSWRzID0gQXJyYXkuZnJvbSh0aGlzLnRpY2tMYWJlbEdyb3VwU2VsZWN0aW9uLm5vZGVzKCksIChub2RlKSA9PiBub2RlLmRhdHVtLnRpY2tJZCk7XG4gICAgc3VwZXIudXBkYXRlKCk7XG4gICAgaWYgKCF0aGlzLmFuaW1hdGFibGUpIHtcbiAgICAgIHRoaXMubW9kdWxlQ3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZW5lcmF0ZWRUaWNrcykge1xuICAgICAgY29uc3QgeyB0aWNrcyB9ID0gdGhpcy5nZW5lcmF0ZWRUaWNrcztcbiAgICAgIGlmICh0aGlzLmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCkpIHtcbiAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvbk5vZGVzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0aWNrSWRzID0gdGlja3MubWFwKChkYXR1bSkgPT4gZGF0dW0udGlja0lkKTtcbiAgICAgICAgY29uc3QgZGlmZjIgPSBkaWZmQXJyYXlzKHByZXZpb3VzVGlja3NJZHMsIHRpY2tJZHMpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVcIiwgZGlmZjIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IGVuYWJsZWQsIHN0cm9rZTogc3Ryb2tlMiwgd2lkdGg6IHdpZHRoMiB9ID0gdGhpcy5saW5lO1xuICAgIHRoaXMubGluZU5vZGUuc2V0UHJvcGVydGllcyh7IHN0cm9rZTogc3Ryb2tlMiwgc3Ryb2tlV2lkdGg6IGVuYWJsZWQgPyB3aWR0aDIgOiAwIH0pO1xuICAgIHRoaXMudXBkYXRlVGl0bGUoIXRoaXMuZ2VuZXJhdGVkVGlja3M/LnRpY2tzLmxlbmd0aCk7XG4gIH1cbiAgdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgc3VwZXIudXBkYXRlUG9zaXRpb24oKTtcbiAgICB0aGlzLmF4aXNHcm91cC5kYXR1bSA9IHRoaXMuZ2V0QXhpc1RyYW5zZm9ybSgpO1xuICB9XG4gIHRpY2tCQm94KHRpY2tzLCBsYWJlbHMpIHtcbiAgICBjb25zdCBzaWRlRmxhZyA9IHRoaXMubGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIGNvbnN0IHsgeCwgeTEsIHkyIH0gPSB0aGlzLmdldEF4aXNMaW5lQ29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBsaW5lQm94ID0gbmV3IEJCb3goXG4gICAgICB4ICsgTWF0aC5taW4oc2lkZUZsYWcgKiB0aGlzLnNlcmllc0FyZWFQYWRkaW5nLCAwKSxcbiAgICAgIHkxLFxuICAgICAgdGhpcy5zZXJpZXNBcmVhUGFkZGluZyxcbiAgICAgIHkyIC0geTFcbiAgICApO1xuICAgIGJveGVzLnB1c2gobGluZUJveCk7XG4gICAgaWYgKHRoaXMudGljay5lbmFibGVkKSB7XG4gICAgICBmb3IgKGNvbnN0IGRhdHVtIG9mIHRpY2tzKSB7XG4gICAgICAgIGNvbnN0IHsgeDEsIHgyLCB5IH0gPSB0aGlzLmdldFRpY2tMaW5lQ29vcmRpbmF0ZXMoZGF0dW0pO1xuICAgICAgICBjb25zdCB0aWNrTGluZUJveCA9IG5ldyBCQm94KHgxLCB5LCB4MiAtIHgxLCAwKTtcbiAgICAgICAgYm94ZXMucHVzaCh0aWNrTGluZUJveCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgdGVtcFRleHQgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMubGFiZWwuZW5hYmxlZCkge1xuICAgICAgZm9yIChjb25zdCBkYXR1bSBvZiBsYWJlbHMpIHtcbiAgICAgICAgaWYgKCFkYXR1bS52aXNpYmxlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB0ZW1wVGV4dC5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAuLi5kYXR1bSxcbiAgICAgICAgICB0cmFuc2xhdGlvblk6IE1hdGgucm91bmQoZGF0dW0udHJhbnNsYXRpb25ZKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYm94ID0gdGVtcFRleHQuZ2V0QkJveCgpO1xuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgYm94ZXMucHVzaChib3gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnRpdGxlPy5lbmFibGVkKSB7XG4gICAgICBjb25zdCBzcGFjaW5nID0gQkJveC5tZXJnZShib3hlcykud2lkdGg7XG4gICAgICB0aGlzLnNldFRpdGxlUHJvcHModGhpcy50ZW1wQ2FwdGlvbiwgeyBzcGFjaW5nIH0pO1xuICAgICAgY29uc3QgdGl0bGVCb3ggPSB0aGlzLnRlbXBDYXB0aW9uLm5vZGUuZ2V0QkJveCgpO1xuICAgICAgaWYgKHRpdGxlQm94KSB7XG4gICAgICAgIGJveGVzLnB1c2godGl0bGVCb3gpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBiYm94ID0gQkJveC5tZXJnZShib3hlcyk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNmb3JtQm94KGJib3gpO1xuICB9XG4gIGdldFRpY2tMYWJlbFByb3BzKGRhdHVtLCB0aWNrR2VuZXJhdGlvblJlc3VsdCkge1xuICAgIGNvbnN0IHsgY29tYmluZWRSb3RhdGlvbiwgdGV4dEJhc2VsaW5lLCB0ZXh0QWxpZ24gfSA9IHRpY2tHZW5lcmF0aW9uUmVzdWx0O1xuICAgIGNvbnN0IHsgcmFuZ2U6IHJhbmdlMyB9ID0gdGhpcy5zY2FsZTtcbiAgICBjb25zdCB0ZXh0MiA9IGRhdHVtLnRpY2tMYWJlbDtcbiAgICBjb25zdCBzaWRlRmxhZyA9IHRoaXMubGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICBjb25zdCBsYWJlbFggPSBzaWRlRmxhZyAqICh0aGlzLmdldFRpY2tTaXplKCkgKyB0aGlzLmxhYmVsLnNwYWNpbmcgKyB0aGlzLnNlcmllc0FyZWFQYWRkaW5nKTtcbiAgICBjb25zdCB2aXNpYmxlID0gdGV4dDIgIT09IFwiXCIgJiYgdGV4dDIgIT0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5nZXRMYWJlbFN0eWxlcyh7IHZhbHVlOiBkYXR1bS50aWNrTGFiZWwgfSksXG4gICAgICB0aWNrSWQ6IGRhdHVtLnRpY2tJZCxcbiAgICAgIHJvdGF0aW9uOiBjb21iaW5lZFJvdGF0aW9uLFxuICAgICAgcm90YXRpb25DZW50ZXJYOiBsYWJlbFgsXG4gICAgICB0cmFuc2xhdGlvblk6IGRhdHVtLnRyYW5zbGF0aW9uWSxcbiAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgdGV4dEFsaWduLFxuICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgdmlzaWJsZSxcbiAgICAgIHg6IGxhYmVsWCxcbiAgICAgIHk6IDAsXG4gICAgICByYW5nZTogcmFuZ2UzXG4gICAgfTtcbiAgfVxuICBnZXRUaWNrTGluZUNvb3JkaW5hdGVzKGRhdHVtKSB7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSB0aGlzLmxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgY29uc3QgeCA9IHNpZGVGbGFnICogdGhpcy5nZXRUaWNrU2l6ZSgpO1xuICAgIGNvbnN0IHgxID0gTWF0aC5taW4oMCwgeCk7XG4gICAgY29uc3QgeDIgPSB4MSArIE1hdGguYWJzKHgpO1xuICAgIGNvbnN0IHkgPSBkYXR1bS50cmFuc2xhdGlvblk7XG4gICAgcmV0dXJuIHsgeDEsIHgyLCB5IH07XG4gIH1cbiAgdXBkYXRlU2VsZWN0aW9ucygpIHtcbiAgICBpZiAoIXRoaXMuZ2VuZXJhdGVkVGlja3MpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbGluZURhdGEgPSB0aGlzLmdldEF4aXNMaW5lQ29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCB7IHRpY2tzLCBsYWJlbHMgfSA9IHRoaXMuZ2VuZXJhdGVkVGlja3M7XG4gICAgY29uc3QgZ2V0RGF0dW1JZCA9IChkYXR1bSkgPT4gZGF0dW0udGlja0lkO1xuICAgIHRoaXMubGluZU5vZGUuZGF0dW0gPSBsaW5lRGF0YTtcbiAgICB0aGlzLmdyaWRMaW5lR3JvdXBTZWxlY3Rpb24udXBkYXRlKHRoaXMuZ3JpZExlbmd0aCA/IHRpY2tzIDogW10sIHZvaWQgMCwgZ2V0RGF0dW1JZCk7XG4gICAgdGhpcy50aWNrTGluZUdyb3VwU2VsZWN0aW9uLnVwZGF0ZSh0aWNrcywgdm9pZCAwLCBnZXREYXR1bUlkKTtcbiAgICB0aGlzLnRpY2tMYWJlbEdyb3VwU2VsZWN0aW9uLnVwZGF0ZShsYWJlbHMsIHZvaWQgMCwgZ2V0RGF0dW1JZCk7XG4gIH1cbiAgdXBkYXRlVGl0bGUobm9WaXNpYmxlVGlja3MsIHNwYWNpbmcpIHtcbiAgICBjb25zdCB7IHRpdGxlLCB0aWNrTGluZUdyb3VwLCB0aWNrTGFiZWxHcm91cCwgbGluZU5vZGUgfSA9IHRoaXM7XG4gICAgaWYgKHRpdGxlLmVuYWJsZWQgJiYgIW5vVmlzaWJsZVRpY2tzICYmIHNwYWNpbmcgPT0gbnVsbCkge1xuICAgICAgY29uc3QgdGlja0JCb3ggPSBHcm91cC5jb21wdXRlQ2hpbGRyZW5CQm94KFt0aWNrTGluZUdyb3VwLCB0aWNrTGFiZWxHcm91cCwgbGluZU5vZGVdKTtcbiAgICAgIHNwYWNpbmcgPSB0aWNrQkJveC53aWR0aCArICh0aWNrTGFiZWxHcm91cC52aXNpYmxlID8gMCA6IHRoaXMuc2VyaWVzQXJlYVBhZGRpbmcpO1xuICAgIH1cbiAgICBzcGFjaW5nID8/IChzcGFjaW5nID0gMCk7XG4gICAgdGhpcy5zZXRUaXRsZVByb3BzKHRpdGxlLmNhcHRpb24sIHsgc3BhY2luZyB9KTtcbiAgfVxuICB1cGRhdGVMYWJlbHMoKSB7XG4gICAgaWYgKCF0aGlzLmxhYmVsLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy50aWNrTGFiZWxHcm91cFNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSkgPT4ge1xuICAgICAgbm9kZS5maWxsID0gZGF0dW0uZmlsbDtcbiAgICAgIG5vZGUuZm9udEZhbWlseSA9IGRhdHVtLmZvbnRGYW1pbHk7XG4gICAgICBub2RlLmZvbnRTaXplID0gZGF0dW0uZm9udFNpemU7XG4gICAgICBub2RlLmZvbnRTdHlsZSA9IGRhdHVtLmZvbnRTdHlsZTtcbiAgICAgIG5vZGUuZm9udFdlaWdodCA9IGRhdHVtLmZvbnRXZWlnaHQ7XG4gICAgICBub2RlLnRleHQgPSBkYXR1bS50ZXh0O1xuICAgICAgbm9kZS50ZXh0QmFzZWxpbmUgPSBkYXR1bS50ZXh0QmFzZWxpbmU7XG4gICAgICBub2RlLnRleHRBbGlnbiA9IGRhdHVtLnRleHRBbGlnbiA/PyBcImNlbnRlclwiO1xuICAgIH0pO1xuICB9XG4gIGFuaW1hdGVSZWFkeVVwZGF0ZShkaWZmMikge1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5tb2R1bGVDdHg7XG4gICAgY29uc3Qgc2VsZWN0aW9uQ3R4ID0gcHJlcGFyZUF4aXNBbmltYXRpb25Db250ZXh0KHRoaXMpO1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVBeGlzQW5pbWF0aW9uRnVuY3Rpb25zKHNlbGVjdGlvbkN0eCk7XG4gICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsIFwiYXhpcy1ncm91cFwiLCBhbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5heGlzR3JvdXBdLCBmbnMuZ3JvdXApO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBcImxpbmVcIiwgYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMubGluZU5vZGVdLCBmbnMubGluZSk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibGluZS1wYXRoc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFt0aGlzLmdyaWRMaW5lR3JvdXBTZWxlY3Rpb24sIHRoaXMudGlja0xpbmVHcm91cFNlbGVjdGlvbl0sXG4gICAgICBmbnMudGljayxcbiAgICAgIChfLCBkKSA9PiBkLnRpY2tJZCxcbiAgICAgIGRpZmYyXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJ0aWNrLWxhYmVsc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFt0aGlzLnRpY2tMYWJlbEdyb3VwU2VsZWN0aW9uXSxcbiAgICAgIGZucy5sYWJlbCxcbiAgICAgIChfLCBkKSA9PiBkLnRpY2tJZCxcbiAgICAgIGRpZmYyXG4gICAgKTtcbiAgfVxuICByZXNldFNlbGVjdGlvbk5vZGVzKCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbkN0eCA9IHByZXBhcmVBeGlzQW5pbWF0aW9uQ29udGV4dCh0aGlzKTtcbiAgICByZXNldE1vdGlvbihbdGhpcy5heGlzR3JvdXBdLCByZXNldEF4aXNHcm91cEZuKCkpO1xuICAgIHJlc2V0TW90aW9uKFt0aGlzLmdyaWRMaW5lR3JvdXBTZWxlY3Rpb24sIHRoaXMudGlja0xpbmVHcm91cFNlbGVjdGlvbl0sIHJlc2V0QXhpc1NlbGVjdGlvbkZuKHNlbGVjdGlvbkN0eCkpO1xuICAgIHJlc2V0TW90aW9uKFt0aGlzLnRpY2tMYWJlbEdyb3VwU2VsZWN0aW9uXSwgcmVzZXRBeGlzTGFiZWxTZWxlY3Rpb25GbigpKTtcbiAgICByZXNldE1vdGlvbihbdGhpcy5saW5lTm9kZV0sIHJlc2V0QXhpc0xpbmVTZWxlY3Rpb25GbigpKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgX0NhcnRlc2lhbkF4aXMucHJvdG90eXBlLCBcInRoaWNrbmVzc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSU9OKVxuXSwgX0NhcnRlc2lhbkF4aXMucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIDIpO1xudmFyIENhcnRlc2lhbkF4aXMgPSBfQ2FydGVzaWFuQXhpcztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9jYXRlZ29yeUF4aXMudHNcbnZhciBfQ2F0ZWdvcnlBeGlzID0gY2xhc3MgX0NhdGVnb3J5QXhpcyBleHRlbmRzIENhcnRlc2lhbkF4aXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgsIHNjYWxlMiA9IG5ldyBDYXRlZ29yeVNjYWxlKCkpIHtcbiAgICBzdXBlcihtb2R1bGVDdHgsIHNjYWxlMik7XG4gICAgdGhpcy5ncm91cFBhZGRpbmdJbm5lciA9IDAuMTtcbiAgICB0aGlzLmluY2x1ZGVJbnZpc2libGVEb21haW5zID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfQ2F0ZWdvcnlBeGlzO1xuICB9XG4gIG5vcm1hbGlzZURhdGFEb21haW4oZG9tYWluKSB7XG4gICAgcmV0dXJuIHsgZG9tYWluLCBjbGlwcGVkOiBmYWxzZSB9O1xuICB9XG4gIHVwZGF0ZVNjYWxlKCkge1xuICAgIHN1cGVyLnVwZGF0ZVNjYWxlKCk7XG4gICAgbGV0IHsgcGFkZGluZ0lubmVyLCBwYWRkaW5nT3V0ZXIgfSA9IHRoaXM7XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcihwYWRkaW5nSW5uZXIpIHx8ICFpc0Zpbml0ZU51bWJlcihwYWRkaW5nT3V0ZXIpKSB7XG4gICAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5yZWR1Y2VCYW5kU2NhbGVQYWRkaW5nKCk7XG4gICAgICBwYWRkaW5nSW5uZXIgPz8gKHBhZGRpbmdJbm5lciA9IHBhZGRpbmcuaW5uZXIpO1xuICAgICAgcGFkZGluZ091dGVyID8/IChwYWRkaW5nT3V0ZXIgPSBwYWRkaW5nLm91dGVyKTtcbiAgICB9XG4gICAgdGhpcy5zY2FsZS5wYWRkaW5nSW5uZXIgPSBwYWRkaW5nSW5uZXIgPz8gMDtcbiAgICB0aGlzLnNjYWxlLnBhZGRpbmdPdXRlciA9IHBhZGRpbmdPdXRlciA/PyAwO1xuICB9XG4gIHJlZHVjZUJhbmRTY2FsZVBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRTZXJpZXMucmVkdWNlKFxuICAgICAgKHJlc3VsdCwgc2VyaWVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSBzZXJpZXMuZ2V0QmFuZFNjYWxlUGFkZGluZz8uKCk7XG4gICAgICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pbm5lciA+IHBhZGRpbmcuaW5uZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5pbm5lciA9IHBhZGRpbmcuaW5uZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQub3V0ZXIgPCBwYWRkaW5nLm91dGVyKSB7XG4gICAgICAgICAgICByZXN1bHQub3V0ZXIgPSBwYWRkaW5nLm91dGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHsgaW5uZXI6IEluZmluaXR5LCBvdXRlcjogLUluZmluaXR5IH1cbiAgICApO1xuICB9XG59O1xuX0NhdGVnb3J5QXhpcy5jbGFzc05hbWUgPSBcIkNhdGVnb3J5QXhpc1wiO1xuX0NhdGVnb3J5QXhpcy50eXBlID0gXCJjYXRlZ29yeVwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBfQ2F0ZWdvcnlBeGlzLnByb3RvdHlwZSwgXCJncm91cFBhZGRpbmdJbm5lclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2F0ZWdvcnlBeGlzLnByb3RvdHlwZSwgXCJwYWRkaW5nSW5uZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgX0NhdGVnb3J5QXhpcy5wcm90b3R5cGUsIFwicGFkZGluZ091dGVyXCIsIDIpO1xudmFyIENhdGVnb3J5QXhpcyA9IF9DYXRlZ29yeUF4aXM7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vZHVsZS9tb2R1bGUudHNcbnZhciBCYXNlTW9kdWxlSW5zdGFuY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBkZXN0cm95Rm4gb2YgdGhpcy5kZXN0cm95Rm5zKSB7XG4gICAgICBkZXN0cm95Rm4oKTtcbiAgICB9XG4gIH1cbn07XG52YXIgTW9kdWxlUmVnaXN0cnkyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1vZHVsZXMgPSBbXTtcbiAgICB0aGlzLmRlcGVuZGVuY2llcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5tb2R1bGVzQnlPcHRpb25LZXkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIHJlZ2lzdGVyKC4uLm1vZHVsZXMpIHtcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVzKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyRGVwZW5kZW5jaWVzKG1vZHVsZSk7XG4gICAgICBjb25zdCBvdGhlck1vZHVsZSA9IHRoaXMubW9kdWxlcy5maW5kKFxuICAgICAgICAob3RoZXIpID0+IG1vZHVsZS50eXBlID09PSBvdGhlci50eXBlICYmIChcIm9wdGlvbnNLZXlcIiBpbiBtb2R1bGUgJiYgXCJvcHRpb25zS2V5XCIgaW4gb3RoZXIgPyBtb2R1bGUub3B0aW9uc0tleSA9PT0gb3RoZXIub3B0aW9uc0tleSA6IHRydWUpICYmIG1vZHVsZS5pZGVudGlmaWVyID09PSBvdGhlci5pZGVudGlmaWVyXG4gICAgICApO1xuICAgICAgaWYgKG90aGVyTW9kdWxlKSB7XG4gICAgICAgIGlmIChtb2R1bGUucGFja2FnZVR5cGUgPT09IFwiZW50ZXJwcmlzZVwiICYmIG90aGVyTW9kdWxlLnBhY2thZ2VUeXBlID09PSBcImNvbW11bml0eVwiKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm1vZHVsZXMuaW5kZXhPZihvdGhlck1vZHVsZSk7XG4gICAgICAgICAgdGhpcy5tb2R1bGVzLnNwbGljZShpbmRleCwgMSwgbW9kdWxlKTtcbiAgICAgICAgICBpZiAoXCJvcHRpb25zS2V5XCIgaW4gbW9kdWxlKSB7XG4gICAgICAgICAgICB0aGlzLm1vZHVsZXNCeU9wdGlvbktleS5zZXQobW9kdWxlLm9wdGlvbnNLZXksIG1vZHVsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1vZHVsZXMucHVzaChtb2R1bGUpO1xuICAgICAgICBpZiAoXCJvcHRpb25zS2V5XCIgaW4gbW9kdWxlKSB7XG4gICAgICAgICAgdGhpcy5tb2R1bGVzQnlPcHRpb25LZXkuc2V0KG1vZHVsZS5vcHRpb25zS2V5LCBtb2R1bGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhc0VudGVycHJpc2VNb2R1bGVzKCkge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZXMuc29tZSgobSkgPT4gbS5wYWNrYWdlVHlwZSA9PT0gXCJlbnRlcnByaXNlXCIpO1xuICB9XG4gICpieVR5cGUoLi4udHlwZXMpIHtcbiAgICBjb25zdCB5aWVsZGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBtb2R1bGVzQnlUeXBlID0gdGhpcy5tb2R1bGVzLmZpbHRlcigobW9kdWxlKSA9PiB0eXBlcy5pbmNsdWRlcyhtb2R1bGUudHlwZSkpO1xuICAgIGNvbnN0IGNhbGN1bGF0ZURlcGVuZGVuY2llcyA9IChtb2R1bGUpID0+IHtcbiAgICAgIGNvbnN0IGRlcHMgPSB0aGlzLmRlcGVuZGVuY2llcy5nZXQobW9kdWxlKTtcbiAgICAgIHJldHVybiBkZXBzPy5mbGF0TWFwKGNhbGN1bGF0ZURlcGVuZGVuY2llcykuY29uY2F0KGRlcHMpID8/IFtdO1xuICAgIH07XG4gICAgY29uc3QgdW5yZXNvbHZhYmxlID0gW107XG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlc0J5VHlwZSkge1xuICAgICAgY29uc3QgdW5pcXVlS2V5ID0gXCJvcHRpb25zS2V5XCIgaW4gbW9kdWxlID8gbW9kdWxlLm9wdGlvbnNLZXkgOiBtb2R1bGUuY29udGV4dEtleTtcbiAgICAgIGlmICh5aWVsZGVkLmhhcyh1bmlxdWVLZXkpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGZvciAoY29uc3QgZGVwZW5kZW5jeSBvZiBjYWxjdWxhdGVEZXBlbmRlbmNpZXModW5pcXVlS2V5KSkge1xuICAgICAgICBpZiAoeWllbGRlZC5oYXMoZGVwZW5kZW5jeSkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGRlcGVuZGVuY3lNb2R1bGUgPSB0aGlzLm1vZHVsZXNCeU9wdGlvbktleS5nZXQoZGVwZW5kZW5jeSk7XG4gICAgICAgIGlmICghZGVwZW5kZW5jeU1vZHVsZSkge1xuICAgICAgICAgIHVucmVzb2x2YWJsZS5wdXNoKGRlcGVuZGVuY3kpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdHlwZXMuaW5jbHVkZXMoZGVwZW5kZW5jeU1vZHVsZS50eXBlKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgeWllbGQgZGVwZW5kZW5jeU1vZHVsZTtcbiAgICAgICAgeWllbGRlZC5hZGQoZGVwZW5kZW5jeSk7XG4gICAgICB9XG4gICAgICB5aWVsZCBtb2R1bGU7XG4gICAgICB5aWVsZGVkLmFkZCh1bmlxdWVLZXkpO1xuICAgIH1cbiAgICBpZiAodW5yZXNvbHZhYmxlLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHJlc29sdmUgbW9kdWxlIGRlcGVuZGVuY2llczogJHt1bnJlc29sdmFibGV9YCk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyRGVwZW5kZW5jaWVzKG1vZHVsZSkge1xuICAgIGlmIChtb2R1bGUuZGVwZW5kZW5jaWVzID09IG51bGwgfHwgbW9kdWxlLmRlcGVuZGVuY2llcy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdW5pcXVlS2V5ID0gXCJvcHRpb25zS2V5XCIgaW4gbW9kdWxlID8gbW9kdWxlLm9wdGlvbnNLZXkgOiBtb2R1bGUuY29udGV4dEtleTtcbiAgICB0aGlzLmRlcGVuZGVuY2llcy5zZXQodW5pcXVlS2V5LCBtb2R1bGUuZGVwZW5kZW5jaWVzKTtcbiAgfVxufTtcbnZhciBtb2R1bGVSZWdpc3RyeSA9IG5ldyBNb2R1bGVSZWdpc3RyeTIoKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9hc3luYy50c1xudmFyIEFzeW5jQXdhaXRRdWV1ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICB9XG4gIGF3YWl0KHRpbWVvdXQgPSA1MCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3Qgc3VjY2Vzc0ZuID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XG4gICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdGltZW91dEZuID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBxdWV1ZUluZGV4ID0gdGhpcy5xdWV1ZS5pbmRleE9mKHN1Y2Nlc3NGbik7XG4gICAgICAgIGlmIChxdWV1ZUluZGV4IDwgMClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucXVldWUuc3BsaWNlKHF1ZXVlSW5kZXgsIDEpO1xuICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCh0aW1lb3V0Rm4sIHRpbWVvdXQpO1xuICAgICAgdGhpcy5xdWV1ZS5wdXNoKHN1Y2Nlc3NGbik7XG4gICAgfSk7XG4gIH1cbiAgbm90aWZ5KCkge1xuICAgIHRoaXMucXVldWUuc3BsaWNlKDApLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHBhdXNlKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDApO1xuICB9KTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9kb20udHNcbmZ1bmN0aW9uIHNldEVsZW1lbnRCQm94KGVsZW1lbnQyLCBiYm94KSB7XG4gIGlmICghZWxlbWVudDIpXG4gICAgcmV0dXJuO1xuICBiYm94ID0gQkJveFZhbHVlcy5ub3JtYWxpemUoYmJveCk7XG4gIGlmIChiYm94LndpZHRoID09IG51bGwpIHtcbiAgICBlbGVtZW50Mi5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcIndpZHRoXCIpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQyLnN0eWxlLndpZHRoID0gYCR7YmJveC53aWR0aH1weGA7XG4gIH1cbiAgaWYgKGJib3guaGVpZ2h0ID09IG51bGwpIHtcbiAgICBlbGVtZW50Mi5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImhlaWdodFwiKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50Mi5zdHlsZS5oZWlnaHQgPSBgJHtiYm94LmhlaWdodH1weGA7XG4gIH1cbiAgaWYgKGJib3gueCA9PSBudWxsKSB7XG4gICAgZWxlbWVudDIuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJsZWZ0XCIpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQyLnN0eWxlLmxlZnQgPSBgJHtiYm94Lnh9cHhgO1xuICB9XG4gIGlmIChiYm94LnkgPT0gbnVsbCkge1xuICAgIGVsZW1lbnQyLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwidG9wXCIpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQyLnN0eWxlLnRvcCA9IGAke2Jib3gueX1weGA7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRCQm94KGVsZW1lbnQyKSB7XG4gIGNvbnN0IHdpZHRoMiA9IHBhcnNlRmxvYXQoZWxlbWVudDIuc3R5bGUud2lkdGgpIHx8IGVsZW1lbnQyLm9mZnNldFdpZHRoO1xuICBjb25zdCBoZWlnaHQyID0gcGFyc2VGbG9hdChlbGVtZW50Mi5zdHlsZS5oZWlnaHQpIHx8IGVsZW1lbnQyLm9mZnNldEhlaWdodDtcbiAgY29uc3QgeCA9IHBhcnNlRmxvYXQoZWxlbWVudDIuc3R5bGUubGVmdCkgfHwgZWxlbWVudDIub2Zmc2V0TGVmdDtcbiAgY29uc3QgeSA9IHBhcnNlRmxvYXQoZWxlbWVudDIuc3R5bGUudG9wKSB8fCBlbGVtZW50Mi5vZmZzZXRUb3A7XG4gIHJldHVybiB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9O1xufVxuZnVuY3Rpb24gZm9jdXNDdXJzb3JBdEVuZChlbGVtZW50Mikge1xuICBlbGVtZW50Mi5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gIGlmIChlbGVtZW50Mi5sYXN0Q2hpbGQ/LnRleHRDb250ZW50ID09IG51bGwpXG4gICAgcmV0dXJuO1xuICBjb25zdCByYW5nZTMgPSBnZXREb2N1bWVudCgpLmNyZWF0ZVJhbmdlKCk7XG4gIHJhbmdlMy5zZXRTdGFydChlbGVtZW50Mi5sYXN0Q2hpbGQsIGVsZW1lbnQyLmxhc3RDaGlsZC50ZXh0Q29udGVudC5sZW5ndGgpO1xuICByYW5nZTMuc2V0RW5kKGVsZW1lbnQyLmxhc3RDaGlsZCwgZWxlbWVudDIubGFzdENoaWxkLnRleHRDb250ZW50Lmxlbmd0aCk7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGdldFdpbmRvdygpLmdldFNlbGVjdGlvbigpO1xuICBzZWxlY3Rpb24/LnJlbW92ZUFsbFJhbmdlcygpO1xuICBzZWxlY3Rpb24/LmFkZFJhbmdlKHJhbmdlMyk7XG59XG52YXIgX2lkID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRJZChsYWJlbCkge1xuICByZXR1cm4gYCR7bGFiZWwgPz8gXCJhZy1jaGFydHMtZWxlbWVudFwifS0ke19pZCsrfWA7XG59XG5mdW5jdGlvbiBpc0lucHV0UGVuZGluZygpIHtcbiAgY29uc3QgbmF2aWdhdG9yID0gZ2V0V2luZG93KFwibmF2aWdhdG9yXCIpO1xuICBpZiAoXCJzY2hlZHVsaW5nXCIgaW4gbmF2aWdhdG9yKSB7XG4gICAgY29uc3Qgc2NoZWR1bGluZyA9IG5hdmlnYXRvci5zY2hlZHVsaW5nO1xuICAgIGlmIChcImlzSW5wdXRQZW5kaW5nXCIgaW4gc2NoZWR1bGluZykge1xuICAgICAgcmV0dXJuIHNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcoeyBpbmNsdWRlQ29udGludW91czogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0SWNvbkNsYXNzTmFtZXMoaWNvbikge1xuICByZXR1cm4gYGFnLWNoYXJ0cy1pY29uIGFnLWNoYXJ0cy1pY29uLSR7aWNvbn1gO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2pzb24udHNcbnZhciBDTEFTU19JTlNUQU5DRV9UWVBFID0gXCJjbGFzcy1pbnN0YW5jZVwiO1xuZnVuY3Rpb24ganNvbkRpZmYoc291cmNlLCB0YXJnZXQsIHNraXApIHtcbiAgaWYgKGlzQXJyYXkodGFyZ2V0KSkge1xuICAgIGlmICghaXNBcnJheShzb3VyY2UpIHx8IHNvdXJjZS5sZW5ndGggIT09IHRhcmdldC5sZW5ndGggfHwgdGFyZ2V0LnNvbWUoKHYsIGkpID0+IGpzb25EaWZmKHNvdXJjZVtpXSwgdikgIT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0KSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBjb25zdCBhbGxLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAgICAgLi4uT2JqZWN0LmtleXMoc291cmNlKSxcbiAgICAgIC4uLk9iamVjdC5rZXlzKHRhcmdldClcbiAgICBdKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBhbGxLZXlzKSB7XG4gICAgICBpZiAoc291cmNlW2tleV0gPT09IHRhcmdldFtrZXldIHx8IHNraXA/LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVtrZXldID09PSB0eXBlb2YgdGFyZ2V0W2tleV0pIHtcbiAgICAgICAgY29uc3QgZGlmZjIgPSBqc29uRGlmZihzb3VyY2Vba2V5XSwgdGFyZ2V0W2tleV0pO1xuICAgICAgICBpZiAoZGlmZjIgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IGRpZmYyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRba2V5XSA9IHRhcmdldFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGggPyByZXN1bHQgOiBudWxsO1xuICB9IGVsc2UgaWYgKHNvdXJjZSAhPT0gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGpzb25Qcm9wZXJ0eUNvbXBhcmUoc291cmNlLCB0YXJnZXQpIHtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc291cmNlKSkge1xuICAgIGlmIChzb3VyY2Vba2V5XSA9PT0gdGFyZ2V0Py5ba2V5XSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlZXBDbG9uZShzb3VyY2UsIHNoYWxsb3cpIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2UubWFwKChpdGVtKSA9PiBkZWVwQ2xvbmUoaXRlbSwgc2hhbGxvdykpO1xuICB9XG4gIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICByZXR1cm4gY2xvbmVQbGFpbk9iamVjdChzb3VyY2UsIHNoYWxsb3cpO1xuICB9XG4gIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBNYXApIHtcbiAgICByZXR1cm4gbmV3IE1hcChkZWVwQ2xvbmUoQXJyYXkuZnJvbShzb3VyY2UpKSk7XG4gIH1cbiAgcmV0dXJuIHNoYWxsb3dDbG9uZShzb3VyY2UpO1xufVxuZnVuY3Rpb24gY2xvbmVQbGFpbk9iamVjdChzb3VyY2UsIHNoYWxsb3cpIHtcbiAgY29uc3QgdGFyZ2V0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNvdXJjZSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHNoYWxsb3c/LmhhcyhrZXkpID8gc2hhbGxvd0Nsb25lKHNvdXJjZVtrZXldKSA6IGRlZXBDbG9uZShzb3VyY2Vba2V5XSwgc2hhbGxvdyk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dDbG9uZShzb3VyY2UpIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoMCk7XG4gIH1cbiAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgIHJldHVybiB7IC4uLnNvdXJjZSB9O1xuICB9XG4gIGlmIChpc0RhdGUoc291cmNlKSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShzb3VyY2UpO1xuICB9XG4gIGlmIChpc1JlZ0V4cChzb3VyY2UpKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc291cmNlLnNvdXJjZSwgc291cmNlLmZsYWdzKTtcbiAgfVxuICByZXR1cm4gc291cmNlO1xufVxuZnVuY3Rpb24ganNvbldhbGsoanNvbiwgdmlzaXQsIHNraXAsIHBhcmFsbGVsSnNvbiwgY3R4LCBhY2MpIHtcbiAgaWYgKGlzQXJyYXkoanNvbikpIHtcbiAgICBhY2MgPSB2aXNpdChqc29uLCBwYXJhbGxlbEpzb24sIGN0eCwgYWNjKTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBqc29uKSB7XG4gICAgICBhY2MgPSBqc29uV2Fsayhub2RlLCB2aXNpdCwgc2tpcCwgcGFyYWxsZWxKc29uPy5baW5kZXhdLCBjdHgsIGFjYyk7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGpzb24pKSB7XG4gICAgYWNjID0gdmlzaXQoanNvbiwgcGFyYWxsZWxKc29uLCBjdHgsIGFjYyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoanNvbikpIHtcbiAgICAgIGlmIChza2lwPy5oYXMoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0ganNvbltrZXldO1xuICAgICAgYWNjID0ganNvbldhbGsodmFsdWUsIHZpc2l0LCBza2lwLCBwYXJhbGxlbEpzb24/LltrZXldLCBjdHgsIGFjYyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhY2M7XG59XG5mdW5jdGlvbiBqc29uQXBwbHkodGFyZ2V0LCBzb3VyY2UsIHBhcmFtcyA9IHt9KSB7XG4gIGNvbnN0IHsgcGF0aCwgbWF0Y2hlclBhdGggPSBwYXRoPy5yZXBsYWNlKC8oXFxbWzAtOStdK10pL2ksIFwiW11cIiksIHNraXAgPSBbXSB9ID0gcGFyYW1zO1xuICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIHRhcmdldCBpcyB1bmluaXRpYWxpc2VkOiAke3BhdGggPz8gXCI8cm9vdD5cIn1gKTtcbiAgfVxuICBpZiAoc291cmNlID09IG51bGwpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmIChpc1Byb3BlcnRpZXModGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQuc2V0KHNvdXJjZSk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0QW55ID0gdGFyZ2V0O1xuICBjb25zdCB0YXJnZXRUeXBlID0gY2xhc3NpZnkodGFyZ2V0KTtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBPYmplY3Qua2V5cyhzb3VyY2UpKSB7XG4gICAgaWYgKFNLSVBfSlNfQlVJTFRJTlMuaGFzKHByb3BlcnR5KSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IHByb3BlcnR5TWF0Y2hlclBhdGggPSBgJHttYXRjaGVyUGF0aCA/IG1hdGNoZXJQYXRoICsgXCIuXCIgOiBcIlwifSR7cHJvcGVydHl9YDtcbiAgICBpZiAoc2tpcC5pbmNsdWRlcyhwcm9wZXJ0eU1hdGNoZXJQYXRoKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICBjb25zdCBwcm9wZXJ0eVBhdGggPSBgJHtwYXRoID8gcGF0aCArIFwiLlwiIDogXCJcIn0ke3Byb3BlcnR5fWA7XG4gICAgY29uc3QgdGFyZ2V0Q2xhc3MgPSB0YXJnZXRBbnkuY29uc3RydWN0b3I7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGFyZ2V0QW55W3Byb3BlcnR5XTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlVHlwZSA9IGNsYXNzaWZ5KGN1cnJlbnRWYWx1ZSk7XG4gICAgICBjb25zdCBuZXdWYWx1ZVR5cGUgPSBjbGFzc2lmeShuZXdWYWx1ZSk7XG4gICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gQ0xBU1NfSU5TVEFOQ0VfVFlQRSAmJiAhKHByb3BlcnR5IGluIHRhcmdldCkpIHtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm4oYHVuYWJsZSB0byBzZXQgWyR7cHJvcGVydHlQYXRofV0gaW4gJHt0YXJnZXRDbGFzcz8ubmFtZX0gLSBwcm9wZXJ0eSBpcyB1bmtub3duYCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRWYWx1ZVR5cGUgIT0gbnVsbCAmJiBuZXdWYWx1ZVR5cGUgIT0gbnVsbCAmJiBuZXdWYWx1ZVR5cGUgIT09IGN1cnJlbnRWYWx1ZVR5cGUgJiYgKGN1cnJlbnRWYWx1ZVR5cGUgIT09IENMQVNTX0lOU1RBTkNFX1RZUEUgfHwgbmV3VmFsdWVUeXBlICE9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICBsb2dnZXJfZXhwb3J0cy53YXJuKFxuICAgICAgICAgIGB1bmFibGUgdG8gc2V0IFske3Byb3BlcnR5UGF0aH1dIGluICR7dGFyZ2V0Q2xhc3M/Lm5hbWV9IC0gY2FuJ3QgYXBwbHkgdHlwZSBvZiBbJHtuZXdWYWx1ZVR5cGV9XSwgYWxsb3dlZCB0eXBlcyBhcmU6IFske2N1cnJlbnRWYWx1ZVR5cGV9XWBcbiAgICAgICAgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNQcm9wZXJ0aWVzKGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgdGFyZ2V0QW55W3Byb3BlcnR5XS5zZXQobmV3VmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChuZXdWYWx1ZVR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgbG9nZ2VyX2V4cG9ydHMud2FybihgdW5hYmxlIHRvIHNldCBbJHtwcm9wZXJ0eVBhdGh9XSBpbiAke3RhcmdldENsYXNzPy5uYW1lfSAtIHByb3BlcnR5IGlzIHVua25vd25gKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBqc29uQXBwbHkoY3VycmVudFZhbHVlLCBuZXdWYWx1ZSwge1xuICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICBwYXRoOiBwcm9wZXJ0eVBhdGgsXG4gICAgICAgICAgbWF0Y2hlclBhdGg6IHByb3BlcnR5TWF0Y2hlclBhdGhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRBbnlbcHJvcGVydHldID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICBsb2dnZXJfZXhwb3J0cy53YXJuKGB1bmFibGUgdG8gc2V0IFske3Byb3BlcnR5UGF0aH1dIGluIFske3RhcmdldENsYXNzPy5uYW1lfV07IG5lc3RlZCBlcnJvciBpczogJHtlcnJvcjIubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGNsYXNzaWZ5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzSHRtbEVsZW1lbnQodmFsdWUpIHx8IGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJwcmltaXRpdmVcIjtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJhcnJheVwiO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyBcIm9iamVjdFwiIDogQ0xBU1NfSU5TVEFOQ0VfVFlQRTtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICB9XG4gIHJldHVybiBcInByaW1pdGl2ZVwiO1xufVxuZnVuY3Rpb24ganNvblJlc29sdmVPcGVyYXRpb25zKHNvdXJjZSwgcGFyYW1zLCBza2lwKSB7XG4gIHJldHVybiBqc29uUmVzb2x2ZUlubmVyKHNvdXJjZSwgcGFyYW1zLCBzb3VyY2UsIHNraXApO1xufVxuZnVuY3Rpb24ganNvblJlc29sdmVJbm5lcihqc29uLCBwYXJhbXMsIHNvdXJjZSwgc2tpcCwgcGF0aCA9IFtdLCBtb2RpZmllZFBhdGhzID0ge30pIHtcbiAgaWYgKGlzQXJyYXkoanNvbikpIHtcbiAgICBqc29uUmVzb2x2ZVZpc2l0b3IoanNvbiwgcGFyYW1zLCBzb3VyY2UsIHBhdGgsIG1vZGlmaWVkUGF0aHMpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIGpzb24pIHtcbiAgICAgIGpzb25SZXNvbHZlSW5uZXIobm9kZSwgcGFyYW1zLCBzb3VyY2UsIHNraXAsIFsuLi5wYXRoLCBgJHtpbmRleH1gXSwgbW9kaWZpZWRQYXRocyk7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGpzb24pKSB7XG4gICAganNvblJlc29sdmVWaXNpdG9yKGpzb24sIHBhcmFtcywgc291cmNlLCBwYXRoLCBtb2RpZmllZFBhdGhzKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhqc29uKSkge1xuICAgICAgaWYgKHNraXA/LmhhcyhrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBqc29uW2tleV07XG4gICAgICBqc29uUmVzb2x2ZUlubmVyKHZhbHVlLCBwYXJhbXMsIHNvdXJjZSwgc2tpcCwgWy4uLnBhdGgsIGtleV0sIG1vZGlmaWVkUGF0aHMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRQYXRocztcbn1cbmZ1bmN0aW9uIGpzb25SZXNvbHZlVmlzaXRvcihub2RlLCBwYXJhbXMsIHNvdXJjZSwgcGF0aCwgbW9kaWZpZWRQYXRocykge1xuICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZVtpXSA9IGpzb25SZXNvbHZlVmlzaXRvclZhbHVlKG5vZGVbaV0sIHBhcmFtcywgc291cmNlLCBbLi4ucGF0aCwgYCR7aX1gXSwgbW9kaWZpZWRQYXRocyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhub2RlKSkge1xuICAgICAgbm9kZVtuYW1lXSA9IGpzb25SZXNvbHZlVmlzaXRvclZhbHVlKHZhbHVlLCBwYXJhbXMsIHNvdXJjZSwgWy4uLnBhdGgsIG5hbWVdLCBtb2RpZmllZFBhdGhzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGpzb25SZXNvbHZlVmlzaXRvclZhbHVlKHZhbHVlLCBwYXJhbXMsIHNvdXJjZSwgcGF0aCwgbW9kaWZpZWRQYXRocykge1xuICBjb25zdCB7IG9wZXJhdGlvbiwgdmFsdWVzIH0gPSBnZXRPcGVyYXRpb24odmFsdWUpO1xuICBpZiAoIW9wZXJhdGlvbilcbiAgICByZXR1cm4gdmFsdWU7XG4gIG1vZGlmaWVkUGF0aHNbcGF0aC5qb2luKFwiLlwiKV0gPSB2YWx1ZTtcbiAgcmV0dXJuIHJlc29sdmVPcGVyYXRpb24ob3BlcmF0aW9uLCB2YWx1ZXMsIHBhcmFtcywgc291cmNlLCBwYXRoLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbn1cbnZhciBPcGVyYXRpb24gPSAvKiBAX19QVVJFX18gKi8gKChPcGVyYXRpb24yKSA9PiB7XG4gIE9wZXJhdGlvbjJbXCJSZWZcIl0gPSBcIiRyZWZcIjtcbiAgT3BlcmF0aW9uMltcIlBhdGhcIl0gPSBcIiRwYXRoXCI7XG4gIE9wZXJhdGlvbjJbXCJJZlwiXSA9IFwiJGlmXCI7XG4gIE9wZXJhdGlvbjJbXCJFcVwiXSA9IFwiJGVxXCI7XG4gIE9wZXJhdGlvbjJbXCJOb3RcIl0gPSBcIiRub3RcIjtcbiAgT3BlcmF0aW9uMltcIk9yXCJdID0gXCIkb3JcIjtcbiAgT3BlcmF0aW9uMltcIkFuZFwiXSA9IFwiJGFuZFwiO1xuICBPcGVyYXRpb24yW1wiTXVsXCJdID0gXCIkbXVsXCI7XG4gIE9wZXJhdGlvbjJbXCJSb3VuZFwiXSA9IFwiJHJvdW5kXCI7XG4gIE9wZXJhdGlvbjJbXCJSZW1cIl0gPSBcIiRyZW1cIjtcbiAgT3BlcmF0aW9uMltcIk1peFwiXSA9IFwiJG1peFwiO1xuICBPcGVyYXRpb24yW1wiRm9yZWdyb3VuZEJhY2tncm91bmRNaXhcIl0gPSBcIiRmb3JlZ3JvdW5kQmFja2dyb3VuZE1peFwiO1xuICBPcGVyYXRpb24yW1wiRm9yZWdyb3VuZEJhY2tncm91bmRBY2NlbnRNaXhcIl0gPSBcIiRmb3JlZ3JvdW5kQmFja2dyb3VuZEFjY2VudE1peFwiO1xuICByZXR1cm4gT3BlcmF0aW9uMjtcbn0pKE9wZXJhdGlvbiB8fCB7fSk7XG52YXIgb3BlcmF0aW9uS2V5cyA9IG5ldyBTZXQoT2JqZWN0LnZhbHVlcyhPcGVyYXRpb24pKTtcbmZ1bmN0aW9uIGdldE9wZXJhdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKVxuICAgIHJldHVybiB7fTtcbiAgY29uc3QgW29wZXJhdGlvbiwgLi4ub3RoZXJLZXlzXSA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgaWYgKG90aGVyS2V5cy5sZW5ndGggIT09IDAgfHwgIW9wZXJhdGlvbktleXMuaGFzKG9wZXJhdGlvbikpXG4gICAgcmV0dXJuIHt9O1xuICByZXR1cm4geyBvcGVyYXRpb24sIHZhbHVlczogdmFsdWVbb3BlcmF0aW9uXSB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZU9wZXJhdGlvbihvcGVyYXRpb24sIHZhbHVlLCBwYXJhbXMsIHNvdXJjZSwgcGF0aCwgcmVmZXJlbmNlZFBhcmFtcykge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLm1hcCgodikgPT4ge1xuICAgICAgY29uc3QgeyBvcGVyYXRpb246IG5lc3RlZE9wZXJhdGlvbiwgdmFsdWVzIH0gPSBnZXRPcGVyYXRpb24odik7XG4gICAgICBpZiAoIW5lc3RlZE9wZXJhdGlvbilcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICByZXR1cm4gcmVzb2x2ZU9wZXJhdGlvbihuZXN0ZWRPcGVyYXRpb24sIHZhbHVlcywgcGFyYW1zLCBzb3VyY2UsIHBhdGgsIHJlZmVyZW5jZWRQYXJhbXMpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBvcGVyYXRpb25zW29wZXJhdGlvbl0odmFsdWUsIHBhcmFtcywgc291cmNlLCBwYXRoLCByZWZlcmVuY2VkUGFyYW1zKTtcbn1cbmZ1bmN0aW9uIGlzUmF0aW8odmFsdWUpIHtcbiAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDE7XG59XG52YXIgb3BlcmF0aW9ucyA9IHtcbiAgJHJlZjogKGtleSwgcGFyYW1zLCBzb3VyY2UsIHBhdGgsIHJlZmVyZW5jZWRQYXJhbXMpID0+IHtcbiAgICBpZiAoaXNTdHJpbmcoa2V5KSAmJiBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICBjb25zdCB7IG9wZXJhdGlvbiwgdmFsdWVzIH0gPSBnZXRPcGVyYXRpb24ocGFyYW1zW2tleV0pO1xuICAgICAgaWYgKG9wZXJhdGlvbiAhPT0gXCIkcmVmXCIgLyogUmVmICovKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXNba2V5XTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWZlcmVuY2VkUGFyYW1zPy5oYXModmFsdWVzKSkge1xuICAgICAgICBsb2dnZXJfZXhwb3J0cy53YXJuT25jZShcbiAgICAgICAgICBgXFxgJHJlZlxcYCBqc29uIG9wZXJhdGlvbiBmYWlsZWQgb24gWyR7U3RyaW5nKGtleSl9XSBhdCBbJHtwYXRoLmpvaW4oXCIuXCIpfV0sIGNpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3RlZCB3aXRoIFske1suLi5yZWZlcmVuY2VkUGFyYW1zXS5qb2luKFwiLCBcIil9XS5gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlZmVyZW5jZWRQYXJhbXM/LmFkZCh2YWx1ZXMpO1xuICAgICAgcmV0dXJuIG9wZXJhdGlvbnMuJHJlZih2YWx1ZXMsIHBhcmFtcywgc291cmNlLCBwYXRoLCByZWZlcmVuY2VkUGFyYW1zKTtcbiAgICB9XG4gICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoXG4gICAgICBgXFxgJHJlZlxcYCBqc29uIG9wZXJhdGlvbiBmYWlsZWQgb24gWyR7U3RyaW5nKGtleSl9XSBhdCBbJHtwYXRoLmpvaW4oXCIuXCIpfV0sIGV4cGVjdGluZyBvbmUgb2YgWyR7T2JqZWN0LmtleXMocGFyYW1zKS5qb2luKFwiLCBcIil9XS5gXG4gICAgKTtcbiAgfSxcbiAgJHBhdGg6IChyZWxhdGl2ZVBhdGgsIF9wYXJhbXMsIHNvdXJjZSwgY3VycmVudFBhdGgpID0+IHtcbiAgICBpZiAoIWlzU3RyaW5nKHJlbGF0aXZlUGF0aCkpIHtcbiAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKFxuICAgICAgICBgXFxgJHBhdGhcXGAganNvbiBvcGVyYXRpb24gZmFpbGVkIG9uIFske1N0cmluZyhyZWxhdGl2ZVBhdGgpfV0gYXQgWyR7Y3VycmVudFBhdGguam9pbihcIi5cIil9XSwgZXhwZWN0aW5nIGEgc3RyaW5nLmBcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbGF0aXZlUGF0aFBhcnRzID0gcmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKTtcbiAgICBjb25zdCByZXNvbHZlZFBhdGggPSBbLi4uY3VycmVudFBhdGhdO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiByZWxhdGl2ZVBhdGhQYXJ0cykge1xuICAgICAgaWYgKHBhcnQgPT09IFwiLi5cIikge1xuICAgICAgICByZXNvbHZlZFBhdGgucG9wKCk7XG4gICAgICAgIHJlc29sdmVkUGF0aC5wb3AoKTtcbiAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gXCIuXCIpIHtcbiAgICAgICAgcmVzb2x2ZWRQYXRoLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZWRQYXRoLnB1c2gocGFydCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCByZXNvbHZlZFZhbHVlID0gc291cmNlO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiByZXNvbHZlZFBhdGgpIHtcbiAgICAgIGlmICghKHBhcnQgaW4gcmVzb2x2ZWRWYWx1ZSkpIHtcbiAgICAgICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoXG4gICAgICAgICAgYFxcYCRwYXRoXFxgIGpzb24gb3BlcmF0aW9uIGZhaWxlZCBvbiBbJHtTdHJpbmcocmVsYXRpdmVQYXRoKX1dIGF0IFske2N1cnJlbnRQYXRoLmpvaW4oXCIuXCIpfV0sIGNvdWxkIG5vdCBmaW5kIHBhdGggaW4gb2JqZWN0LmBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZWRWYWx1ZSA9IHJlc29sdmVkVmFsdWVbcGFydF07XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlZFZhbHVlO1xuICB9LFxuICAkaWY6IChbY29uZGl0aW9uLCB0aGVuVmFsdWUsIGVsc2VWYWx1ZV0pID0+IGNvbmRpdGlvbiA/IHRoZW5WYWx1ZSA6IGVsc2VWYWx1ZSxcbiAgJGVxOiAoW2EsIGJdKSA9PiBhID09PSBiLFxuICAkbm90OiAoW2EsIGJdKSA9PiBhICE9PSBiLFxuICAkb3I6IChbYSwgYl0pID0+IGEgfHwgYixcbiAgJGFuZDogKFthLCBiXSkgPT4gYSAmJiBiLFxuICAkbXVsOiAoW2EsIGJdLCBfcGFyYW1zLCBfc291cmNlLCBwYXRoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBhID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBiID09PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIGEgKiBiO1xuICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKFxuICAgICAgYFxcYCRtdWxcXGAganNvbiBvcGVyYXRpb24gZmFpbGVkIG9uIFske1N0cmluZyhhKX1dIGFuZCBbJHtTdHJpbmcoYil9XSBhdCBbJHtwYXRoLmpvaW4oXCIuXCIpfV0sIGV4cGVjdGluZyB0d28gbnVtYmVycy5gXG4gICAgKTtcbiAgfSxcbiAgJHJvdW5kOiAoW2FdLCBfcGFyYW1zLCBfc291cmNlLCBwYXRoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBhID09PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIE1hdGgucm91bmQoYSk7XG4gICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoXG4gICAgICBgXFxgJHJvdW5kXFxgIGpzb24gb3BlcmF0aW9uIGZhaWxlZCBvbiBbJHtTdHJpbmcoYSl9XSBhdCBbJHtwYXRoLmpvaW4oXCIuXCIpfV0sIGV4cGVjdGluZyBhIG51bWJlci5gXG4gICAgKTtcbiAgfSxcbiAgJHJlbTogKFthXSwgcGFyYW1zKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBhID09PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIE1hdGgucm91bmQoYSAqIHBhcmFtcy5mb250U2l6ZSk7XG4gIH0sXG4gICRtaXg6IChbYSwgYiwgY10sIF9wYXJhbXMsIF9zb3VyY2UsIHBhdGgpID0+IHtcbiAgICBpZiAodHlwZW9mIGEgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGIgPT09IFwic3RyaW5nXCIgJiYgaXNSYXRpbyhjKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIENvbG9yLm1peChDb2xvci5mcm9tU3RyaW5nKGEpLCBDb2xvci5mcm9tU3RyaW5nKGIpLCBjKS50b1N0cmluZygpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKFxuICAgICAgYFxcYCRtaXhcXGAganNvbiBvcGVyYXRpb24gZmFpbGVkIG9uIFske1N0cmluZyhhKX0sICR7U3RyaW5nKGIpfSwgJHtTdHJpbmcoYyl9XSBhdCBbJHtwYXRoLmpvaW4oXCIuXCIpfV0sIGV4cGVjdGluZyB0d28gY29sb3JzIGFuZCBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuYFxuICAgICk7XG4gIH0sXG4gICRmb3JlZ3JvdW5kQmFja2dyb3VuZE1peDogKFthXSwgcGFyYW1zLCBfc291cmNlLCBwYXRoKSA9PiB7XG4gICAgaWYgKGlzUmF0aW8oYSkpIHtcbiAgICAgIHJldHVybiBDb2xvci5taXgoXG4gICAgICAgIENvbG9yLmZyb21TdHJpbmcocGFyYW1zLmZvcmVncm91bmRDb2xvciksXG4gICAgICAgIENvbG9yLmZyb21TdHJpbmcocGFyYW1zLmJhY2tncm91bmRDb2xvciksXG4gICAgICAgIGFcbiAgICAgICkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoXG4gICAgICBgXFxgJGZvcmVncm91bmRCYWNrZ3JvdW5kTWl4XFxgIGpzb24gb3BlcmF0aW9uIGZhaWxlZCBvbiBbJHtTdHJpbmcoYSl9fX1dIGF0IFske3BhdGguam9pbihcIi5cIil9XSwgZXhwZWN0aW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS5gXG4gICAgKTtcbiAgfSxcbiAgJGZvcmVncm91bmRCYWNrZ3JvdW5kQWNjZW50TWl4OiAoW2JhY2tncm91bmQsIGFjY2VudF0sIHBhcmFtcywgX3NvdXJjZSwgcGF0aCkgPT4ge1xuICAgIGlmIChpc1JhdGlvKGJhY2tncm91bmQpICYmIGlzUmF0aW8oYWNjZW50KSkge1xuICAgICAgcmV0dXJuIENvbG9yLm1peChcbiAgICAgICAgQ29sb3IubWl4KFxuICAgICAgICAgIENvbG9yLmZyb21TdHJpbmcocGFyYW1zLmZvcmVncm91bmRDb2xvciksXG4gICAgICAgICAgQ29sb3IuZnJvbVN0cmluZyhwYXJhbXMuYmFja2dyb3VuZENvbG9yKSxcbiAgICAgICAgICBiYWNrZ3JvdW5kXG4gICAgICAgICksXG4gICAgICAgIENvbG9yLmZyb21TdHJpbmcocGFyYW1zLmFjY2VudENvbG9yKSxcbiAgICAgICAgYWNjZW50XG4gICAgICApLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKFxuICAgICAgYFxcYCRmb3JlZ3JvdW5kQmFja2dyb3VuZEFjY2VudE1peFxcYCBqc29uIG9wZXJhdGlvbiBmYWlsZWQgb24gWyR7U3RyaW5nKGJhY2tncm91bmQpfSwgJHtTdHJpbmcoYWNjZW50KX19XSBhdCBbJHtwYXRoLmpvaW4oXCIuXCIpfV0sIGV4cGVjdGluZyB0d28gbnVtYmVycyBiZXR3ZWVuIDAgYW5kIDEuYFxuICAgICk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvbXV0ZXgudHNcbnZhciBNdXRleCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5hdmFpbGFibGUgPSB0cnVlO1xuICAgIHRoaXMuYWNxdWlyZVF1ZXVlID0gW107XG4gIH1cbiAgYWNxdWlyZShjYikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5hY3F1aXJlUXVldWUucHVzaChbY2IsIHJlc29sdmVdKTtcbiAgICAgIGlmICh0aGlzLmF2YWlsYWJsZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV4dCgpLmNhdGNoKChlKSA9PiBsb2dnZXJfZXhwb3J0cy5lcnJvck9uY2UoZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGFjcXVpcmVJbW1lZGlhdGVseShjYikge1xuICAgIGlmICghdGhpcy5hdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5hY3F1aXJlKGNiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBhc3luYyB3YWl0Rm9yQ2xlYXJBY3F1aXJlUXVldWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWNxdWlyZSgoKSA9PiBQcm9taXNlLnJlc29sdmUodm9pZCAwKSk7XG4gIH1cbiAgYXN5bmMgZGlzcGF0Y2hOZXh0KCkge1xuICAgIHRoaXMuYXZhaWxhYmxlID0gZmFsc2U7XG4gICAgbGV0IFtuZXh0LCBkb25lXSA9IHRoaXMuYWNxdWlyZVF1ZXVlLnNoaWZ0KCkgPz8gW107XG4gICAgd2hpbGUgKG5leHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG5leHQoKTtcbiAgICAgICAgZG9uZT8uKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgbG9nZ2VyX2V4cG9ydHMuZXJyb3IoXCJtdXRleCBjYWxsYmFjayBlcnJvclwiLCBlcnJvcjIpO1xuICAgICAgICBkb25lPy4oKTtcbiAgICAgIH1cbiAgICAgIFtuZXh0LCBkb25lXSA9IHRoaXMuYWNxdWlyZVF1ZXVlLnNoaWZ0KCkgPz8gW107XG4gICAgfVxuICAgIHRoaXMuYXZhaWxhYmxlID0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9vYnNlcnZhYmxlLnRzXG52YXIgT2JzZXJ2YWJsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBsaXN0ZW5lciBtdXN0IGJlIGEgRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50VHlwZUxpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KGV2ZW50VHlwZSk7XG4gICAgaWYgKGV2ZW50VHlwZUxpc3RlbmVycykge1xuICAgICAgZXZlbnRUeXBlTGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuc2V0KGV2ZW50VHlwZSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW2xpc3RlbmVyXSkpO1xuICAgIH1cbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5nZXQodHlwZSk/LmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgaWYgKHRoaXMuZXZlbnRMaXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5kZWxldGUodHlwZSk7XG4gICAgfVxuICB9XG4gIGhhc0V2ZW50TGlzdGVuZXIodHlwZSkge1xuICAgIHJldHVybiB0aGlzLmV2ZW50TGlzdGVuZXJzLmhhcyh0eXBlKTtcbiAgfVxuICBjbGVhckV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxuICBmaXJlRXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChldmVudC50eXBlKT8uZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKGV2ZW50KSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvcGFkZGluZy50c1xudmFyIFBhZGRpbmcgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IodG9wID0gMCwgcmlnaHQgPSB0b3AsIGJvdHRvbSA9IHRvcCwgbGVmdCA9IHJpZ2h0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgdGhpcy5ib3R0b20gPSBib3R0b207XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBhZGRpbmcucHJvdG90eXBlLCBcInRvcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBhZGRpbmcucHJvdG90eXBlLCBcInJpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFkZGluZy5wcm90b3R5cGUsIFwiYm90dG9tXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFkZGluZy5wcm90b3R5cGUsIFwibGVmdFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9yZW5kZXIudHNcbmZ1bmN0aW9uIGRlYm91bmNlZEFuaW1hdGlvbkZyYW1lKGNiKSB7XG4gIHJldHVybiBidWlsZFNjaGVkdWxlcigoaW5uZXJDYiwgX2RlbGF5TXMpID0+IGdldFdpbmRvdygpLnJlcXVlc3RBbmltYXRpb25GcmFtZShpbm5lckNiKSwgY2IpO1xufVxuZnVuY3Rpb24gZGVib3VuY2VkQ2FsbGJhY2soY2IpIHtcbiAgcmV0dXJuIGJ1aWxkU2NoZWR1bGVyKChpbm5lckNiLCBkZWxheU1zID0gMCkgPT4ge1xuICAgIGlmIChkZWxheU1zID09PSAwKSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzayhpbm5lckNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChpbm5lckNiLCBkZWxheU1zKTtcbiAgICB9XG4gIH0sIGNiKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkU2NoZWR1bGVyKHNjaGVkdWxlRm4sIGNiKSB7XG4gIGxldCBzY2hlZHVsZUNvdW50ID0gMDtcbiAgbGV0IHByb21pc2VSdW5uaW5nID0gZmFsc2U7XG4gIGxldCBhd2FpdGluZ1Byb21pc2U7XG4gIGxldCBhd2FpdGluZ0RvbmU7XG4gIGNvbnN0IGJ1c3kgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHByb21pc2VSdW5uaW5nO1xuICB9O1xuICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgIHByb21pc2VSdW5uaW5nID0gZmFsc2U7XG4gICAgYXdhaXRpbmdEb25lPy4oKTtcbiAgICBhd2FpdGluZ0RvbmUgPSB2b2lkIDA7XG4gICAgYXdhaXRpbmdQcm9taXNlID0gdm9pZCAwO1xuICAgIGlmIChzY2hlZHVsZUNvdW50ID4gMCkge1xuICAgICAgc2NoZWR1bGVGbihzY2hlZHVsZUNiKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNjaGVkdWxlQ2IgPSAoKSA9PiB7XG4gICAgY29uc3QgY291bnQgPSBzY2hlZHVsZUNvdW50O1xuICAgIHNjaGVkdWxlQ291bnQgPSAwO1xuICAgIHByb21pc2VSdW5uaW5nID0gdHJ1ZTtcbiAgICBjb25zdCBtYXliZVByb21pc2UgPSBjYih7IGNvdW50IH0pO1xuICAgIGlmICghbWF5YmVQcm9taXNlKSB7XG4gICAgICBkb25lKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1heWJlUHJvbWlzZS50aGVuKGRvbmUsIGRvbmUpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHNjaGVkdWxlKGRlbGF5TXMpIHtcbiAgICAgIGlmIChzY2hlZHVsZUNvdW50ID09PSAwICYmICFidXN5KCkpIHtcbiAgICAgICAgc2NoZWR1bGVGbihzY2hlZHVsZUNiLCBkZWxheU1zKTtcbiAgICAgIH1cbiAgICAgIHNjaGVkdWxlQ291bnQrKztcbiAgICB9LFxuICAgIGFzeW5jIGF3YWl0KCkge1xuICAgICAgaWYgKCFidXN5KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGF3YWl0aW5nUHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgIGF3YWl0aW5nUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgYXdhaXRpbmdEb25lID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYnVzeSgpKSB7XG4gICAgICAgIGF3YWl0IGF3YWl0aW5nUHJvbWlzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvYXR0cmlidXRlVXRpbC50c1xuZnVuY3Rpb24gYm9vbGVhblBhcnNlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IFwidHJ1ZVwiO1xufVxuZnVuY3Rpb24gbnVtYmVyUGFyc2VyKHZhbHVlKSB7XG4gIHJldHVybiBOdW1iZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gc3RyaW5nUGFyc2VyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cbnZhciBBdHRyaWJ1dGVUeXBlUGFyc2VycyA9IHtcbiAgcm9sZTogc3RyaW5nUGFyc2VyLFxuICBcImFyaWEtY2hlY2tlZFwiOiBib29sZWFuUGFyc2VyLFxuICBcImFyaWEtY29udHJvbHNcIjogc3RyaW5nUGFyc2VyLFxuICBcImFyaWEtZGVzY3JpYmVkYnlcIjogc3RyaW5nUGFyc2VyLFxuICBcImFyaWEtZGlzYWJsZWRcIjogYm9vbGVhblBhcnNlcixcbiAgXCJhcmlhLWV4cGFuZGVkXCI6IGJvb2xlYW5QYXJzZXIsXG4gIFwiYXJpYS1oYXNwb3B1cFwiOiBib29sZWFuUGFyc2VyLFxuICBcImFyaWEtaGlkZGVuXCI6IGJvb2xlYW5QYXJzZXIsXG4gIFwiYXJpYS1sYWJlbFwiOiBzdHJpbmdQYXJzZXIsXG4gIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHN0cmluZ1BhcnNlcixcbiAgXCJhcmlhLWxpdmVcIjogc3RyaW5nUGFyc2VyLFxuICBcImFyaWEtb3JpZW50YXRpb25cIjogc3RyaW5nUGFyc2VyLFxuICBcImFyaWEtc2VsZWN0ZWRcIjogYm9vbGVhblBhcnNlcixcbiAgXCJkYXRhLXByZXZlbnRkZWZhdWx0XCI6IGJvb2xlYW5QYXJzZXIsXG4gIGNsYXNzOiBzdHJpbmdQYXJzZXIsXG4gIGlkOiBzdHJpbmdQYXJzZXIsXG4gIHRhYmluZGV4OiBudW1iZXJQYXJzZXIsXG4gIHRpdGxlOiBzdHJpbmdQYXJzZXIsXG4gIHBsYWNlaG9sZGVyOiBzdHJpbmdQYXJzZXJcbn07XG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUoZSwgcXVhbGlmaWVkTmFtZSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT09IFwiXCIpIHtcbiAgICBlPy5yZW1vdmVBdHRyaWJ1dGUocXVhbGlmaWVkTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgZT8uc2V0QXR0cmlidXRlKHF1YWxpZmllZE5hbWUsIHZhbHVlLnRvU3RyaW5nKCkpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGUsIGF0dHJzKSB7XG4gIGlmIChhdHRycyA9PSBudWxsKVxuICAgIHJldHVybjtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXR0cnMpKSB7XG4gICAgaWYgKGtleSA9PT0gXCJjbGFzc1wiKVxuICAgICAgY29udGludWU7XG4gICAgc2V0QXR0cmlidXRlKGUsIGtleSwgdmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGUoZSwgcXVhbGlmaWVkTmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICghKGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgdmFsdWUgPSBlLmdldEF0dHJpYnV0ZShxdWFsaWZpZWROYW1lKTtcbiAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gIHJldHVybiBBdHRyaWJ1dGVUeXBlUGFyc2Vyc1txdWFsaWZpZWROYW1lXT8uKHZhbHVlKSA/PyB2b2lkIDA7XG59XG5mdW5jdGlvbiBzZXRFbGVtZW50U3R5bGUoZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gIGlmIChlID09IG51bGwpXG4gICAgcmV0dXJuO1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIGUuc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkpO1xuICB9IGVsc2Uge1xuICAgIGUuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlLnRvU3RyaW5nKCkpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRFbGVtZW50U3R5bGVzKGUsIHN0eWxlcykge1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzdHlsZXMpKSB7XG4gICAgc2V0RWxlbWVudFN0eWxlKGUsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3dpZGdldC93aWRnZXRFdmVudHMudHNcbnZhciBXSURHRVRfSFRNTF9FVkVOVFMgPSBbXG4gIFwiYmx1clwiLFxuICBcImNoYW5nZVwiLFxuICBcImNvbnRleHRtZW51XCIsXG4gIFwiZm9jdXNcIixcbiAgXCJrZXlkb3duXCIsXG4gIFwia2V5dXBcIixcbiAgXCJjbGlja1wiLFxuICBcImRibGNsaWNrXCIsXG4gIFwibW91c2VlbnRlclwiLFxuICBcIm1vdXNlbW92ZVwiLFxuICBcIm1vdXNlbGVhdmVcIixcbiAgXCJ3aGVlbFwiLFxuICBcInRvdWNoc3RhcnRcIixcbiAgXCJ0b3VjaG1vdmVcIixcbiAgXCJ0b3VjaGVuZFwiLFxuICBcInRvdWNoY2FuY2VsXCJcbl07XG5mdW5jdGlvbiBhbGxvY01vdXNlRXZlbnQodHlwZSwgc291cmNlRXZlbnQsIGN1cnJlbnQpIHtcbiAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZLCBjbGllbnRYLCBjbGllbnRZIH0gPSBzb3VyY2VFdmVudDtcbiAgY29uc3QgeyBjdXJyZW50WCwgY3VycmVudFkgfSA9IFdpZGdldEV2ZW50VXRpbC5jYWxjQ3VycmVudFhZKGN1cnJlbnQsIHNvdXJjZUV2ZW50KTtcbiAgcmV0dXJuIHsgdHlwZSwgb2Zmc2V0WCwgb2Zmc2V0WSwgY2xpZW50WCwgY2xpZW50WSwgY3VycmVudFgsIGN1cnJlbnRZLCBzb3VyY2VFdmVudCB9O1xufVxuZnVuY3Rpb24gYWxsb2NUb3VjaEV2ZW50KHR5cGUsIHNvdXJjZUV2ZW50LCBfY3VycmVudCkge1xuICByZXR1cm4geyB0eXBlLCBzb3VyY2VFdmVudCB9O1xufVxudmFyIFdpZGdldEFsbG9jYXRvcnMgPSB7XG4gIGJsdXI6IChzb3VyY2VFdmVudCkgPT4ge1xuICAgIHJldHVybiB7IHR5cGU6IFwiYmx1clwiLCBzb3VyY2VFdmVudCB9O1xuICB9LFxuICBjaGFuZ2U6IChzb3VyY2VFdmVudCkgPT4ge1xuICAgIHJldHVybiB7IHR5cGU6IFwiY2hhbmdlXCIsIHNvdXJjZUV2ZW50IH07XG4gIH0sXG4gIGNvbnRleHRtZW51OiAoc291cmNlRXZlbnQsIGN1cnJlbnQpID0+IHtcbiAgICByZXR1cm4gYWxsb2NNb3VzZUV2ZW50KFwiY29udGV4dG1lbnVcIiwgc291cmNlRXZlbnQsIGN1cnJlbnQpO1xuICB9LFxuICBmb2N1czogKHNvdXJjZUV2ZW50KSA9PiB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJmb2N1c1wiLCBzb3VyY2VFdmVudCB9O1xuICB9LFxuICBrZXlkb3duOiAoc291cmNlRXZlbnQpID0+IHtcbiAgICByZXR1cm4geyB0eXBlOiBcImtleWRvd25cIiwgc291cmNlRXZlbnQgfTtcbiAgfSxcbiAga2V5dXA6IChzb3VyY2VFdmVudCkgPT4ge1xuICAgIHJldHVybiB7IHR5cGU6IFwia2V5dXBcIiwgc291cmNlRXZlbnQgfTtcbiAgfSxcbiAgY2xpY2s6IChzb3VyY2VFdmVudCwgY3VycmVudCkgPT4ge1xuICAgIHJldHVybiBhbGxvY01vdXNlRXZlbnQoXCJjbGlja1wiLCBzb3VyY2VFdmVudCwgY3VycmVudCk7XG4gIH0sXG4gIGRibGNsaWNrOiAoc291cmNlRXZlbnQsIGN1cnJlbnQpID0+IHtcbiAgICByZXR1cm4gYWxsb2NNb3VzZUV2ZW50KFwiZGJsY2xpY2tcIiwgc291cmNlRXZlbnQsIGN1cnJlbnQpO1xuICB9LFxuICBtb3VzZWVudGVyOiAoc291cmNlRXZlbnQsIGN1cnJlbnQpID0+IHtcbiAgICByZXR1cm4gYWxsb2NNb3VzZUV2ZW50KFwibW91c2VlbnRlclwiLCBzb3VyY2VFdmVudCwgY3VycmVudCk7XG4gIH0sXG4gIG1vdXNlbW92ZTogKHNvdXJjZUV2ZW50LCBjdXJyZW50KSA9PiB7XG4gICAgcmV0dXJuIGFsbG9jTW91c2VFdmVudChcIm1vdXNlbW92ZVwiLCBzb3VyY2VFdmVudCwgY3VycmVudCk7XG4gIH0sXG4gIG1vdXNlbGVhdmU6IChzb3VyY2VFdmVudCwgY3VycmVudCkgPT4ge1xuICAgIHJldHVybiBhbGxvY01vdXNlRXZlbnQoXCJtb3VzZWxlYXZlXCIsIHNvdXJjZUV2ZW50LCBjdXJyZW50KTtcbiAgfSxcbiAgd2hlZWw6IChzb3VyY2VFdmVudCkgPT4ge1xuICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSwgY2xpZW50WCwgY2xpZW50WSB9ID0gc291cmNlRXZlbnQ7XG4gICAgY29uc3QgZmFjdG9yID0gc291cmNlRXZlbnQuZGVsdGFNb2RlID09PSAwID8gMC4wMSA6IDE7XG4gICAgY29uc3QgZGVsdGFYID0gc291cmNlRXZlbnQuZGVsdGFYICogZmFjdG9yO1xuICAgIGNvbnN0IGRlbHRhWSA9IHNvdXJjZUV2ZW50LmRlbHRhWSAqIGZhY3RvcjtcbiAgICByZXR1cm4geyB0eXBlOiBcIndoZWVsXCIsIG9mZnNldFgsIG9mZnNldFksIGNsaWVudFgsIGNsaWVudFksIGRlbHRhWCwgZGVsdGFZLCBzb3VyY2VFdmVudCB9O1xuICB9LFxuICB0b3VjaHN0YXJ0OiAoc291cmNlRXZlbnQsIGN1cnJlbnQpID0+IHtcbiAgICByZXR1cm4gYWxsb2NUb3VjaEV2ZW50KFwidG91Y2hzdGFydFwiLCBzb3VyY2VFdmVudCwgY3VycmVudCk7XG4gIH0sXG4gIHRvdWNobW92ZTogKHNvdXJjZUV2ZW50LCBjdXJyZW50KSA9PiB7XG4gICAgcmV0dXJuIGFsbG9jVG91Y2hFdmVudChcInRvdWNobW92ZVwiLCBzb3VyY2VFdmVudCwgY3VycmVudCk7XG4gIH0sXG4gIHRvdWNoZW5kOiAoc291cmNlRXZlbnQsIGN1cnJlbnQpID0+IHtcbiAgICByZXR1cm4gYWxsb2NUb3VjaEV2ZW50KFwidG91Y2hlbmRcIiwgc291cmNlRXZlbnQsIGN1cnJlbnQpO1xuICB9LFxuICB0b3VjaGNhbmNlbDogKHNvdXJjZUV2ZW50LCBjdXJyZW50KSA9PiB7XG4gICAgcmV0dXJuIGFsbG9jVG91Y2hFdmVudChcInRvdWNoY2FuY2VsXCIsIHNvdXJjZUV2ZW50LCBjdXJyZW50KTtcbiAgfVxufTtcbnZhciBXaWRnZXRFdmVudFV0aWwgPSBjbGFzcyB7XG4gIHN0YXRpYyBhbGxvYyh0eXBlLCBzb3VyY2VFdmVudCwgY3VycmVudCkge1xuICAgIHJldHVybiBXaWRnZXRBbGxvY2F0b3JzW3R5cGVdKHNvdXJjZUV2ZW50LCBjdXJyZW50KTtcbiAgfVxuICBzdGF0aWMgaXNIVE1MRXZlbnQodHlwZSkge1xuICAgIGNvbnN0IGh0bWxUeXBlcyA9IFdJREdFVF9IVE1MX0VWRU5UUztcbiAgICByZXR1cm4gaHRtbFR5cGVzLmluY2x1ZGVzKHR5cGUpO1xuICB9XG4gIHN0YXRpYyBjYWxjQ3VycmVudFhZKGN1cnJlbnQsIGV2ZW50KSB7XG4gICAgY29uc3QgY3VycmVudFJlY3QgPSBjdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7IGN1cnJlbnRYOiBldmVudC5jbGllbnRYIC0gY3VycmVudFJlY3QueCwgY3VycmVudFk6IGV2ZW50LmNsaWVudFkgLSBjdXJyZW50UmVjdC55IH07XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3dpZGdldC93aWRnZXRMaXN0ZW5lckhUTUwudHNcbnZhciBXaWRnZXRMaXN0ZW5lckhUTUwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMud2lkZ2V0TGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5zb3VyY2VMaXN0ZW5lcnMgPSB7fTtcbiAgfVxuICBpbml0U291cmNlSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5zb3VyY2VMaXN0ZW5lcnMgPz8gKHRoaXMuc291cmNlTGlzdGVuZXJzID0ge30pO1xuICAgIHRoaXMuc291cmNlTGlzdGVuZXJzW3R5cGVdID0gaGFuZGxlcjtcbiAgfVxuICBsYXp5R2V0V2lkZ2V0TGlzdGVuZXJzKHR5cGUsIHRhcmdldCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoISh0eXBlIGluICh0aGlzLnNvdXJjZUxpc3RlbmVycyA/PyB7fSkpKSB7XG4gICAgICBjb25zdCBzb3VyY2VIYW5kbGVyID0gKHNvdXJjZUV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHdpZGdldEV2ZW50ID0gV2lkZ2V0RXZlbnRVdGlsLmFsbG9jKHR5cGUsIHNvdXJjZUV2ZW50LCB0YXJnZXQuZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgZm9yIChjb25zdCB3aWRnZXRMaXN0ZW5lciBvZiB0aGlzLndpZGdldExpc3RlbmVycz8uW3R5cGVdID8/IFtdKSB7XG4gICAgICAgICAgd2lkZ2V0TGlzdGVuZXIod2lkZ2V0RXZlbnQsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBvcHRzID0ge307XG4gICAgICBpZiAodHlwZS5zdGFydHNXaXRoKFwidG91Y2hcIikpXG4gICAgICAgIG9wdHMucGFzc2l2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5pbml0U291cmNlSGFuZGxlcih0eXBlLCBzb3VyY2VIYW5kbGVyKTtcbiAgICAgIHRhcmdldC5nZXRFbGVtZW50KCkuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBzb3VyY2VIYW5kbGVyLCBvcHRzKTtcbiAgICB9XG4gICAgdGhpcy53aWRnZXRMaXN0ZW5lcnMgPz8gKHRoaXMud2lkZ2V0TGlzdGVuZXJzID0ge30pO1xuICAgIChfYSA9IHRoaXMud2lkZ2V0TGlzdGVuZXJzKVt0eXBlXSA/PyAoX2FbdHlwZV0gPSBbXSk7XG4gICAgcmV0dXJuIHRoaXMud2lkZ2V0TGlzdGVuZXJzW3R5cGVdO1xuICB9XG4gIGFkZCh0eXBlLCB0YXJnZXQsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxhenlHZXRXaWRnZXRMaXN0ZW5lcnModHlwZSwgdGFyZ2V0KTtcbiAgICBsaXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcbiAgfVxuICByZW1vdmUodHlwZSwgdGFyZ2V0LCBoYW5kbGVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5sYXp5R2V0V2lkZ2V0TGlzdGVuZXJzKHR5cGUsIHRhcmdldCk7XG4gICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG4gIGRlc3Ryb3kodGFyZ2V0KSB7XG4gICAgZm9yIChjb25zdCBba2V5LCBzb3VyY2VIYW5kbGVyXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnNvdXJjZUxpc3RlbmVycyA/PyB7fSkpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBrZXk7XG4gICAgICB0YXJnZXQuZ2V0RWxlbWVudCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgc291cmNlSGFuZGxlcik7XG4gICAgfVxuICAgIHRoaXMud2lkZ2V0TGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIHRoaXMuc291cmNlTGlzdGVuZXJzID0gdm9pZCAwO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy93aWRnZXQvbW91c2VEcmFnZ2VyLnRzXG52YXIgTW91c2VEcmFnZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihnbG9iLCBzZWxmLCBteUNhbGxiYWNrcywgZG93bkV2ZW50KSB7XG4gICAgdGhpcy5nbG9iID0gZ2xvYjtcbiAgICB0aGlzLnNlbGYgPSBzZWxmO1xuICAgIHRoaXMud2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgdGhpcy5tb3VzZWdlbmVyYWwgPSAoZ2VuZXJhbEV2ZW50KSA9PiB7XG4gICAgICBnZW5lcmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBnZW5lcmFsRXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfTtcbiAgICB0aGlzLm1vdXNlbW92ZSA9IChtb3ZlRXZlbnQpID0+IHtcbiAgICAgIG1vdmVFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIG1vdmVFdmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIHRoaXMuZ2xvYi5nbG9iYWxNb3VzZURyYWdDYWxsYmFja3M/Lm1vdXNlbW92ZShtb3ZlRXZlbnQpO1xuICAgIH07XG4gICAgdGhpcy5tb3VzZXVwID0gKHVwRXZlbnQpID0+IHtcbiAgICAgIGlmICh1cEV2ZW50LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICB1cEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB1cEV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLmdsb2IuZ2xvYmFsTW91c2VEcmFnQ2FsbGJhY2tzPy5tb3VzZXVwKHVwRXZlbnQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHsgd2luZG93OiB3aW5kb3cyLCBtb3VzZWdlbmVyYWwsIG1vdXNlbW92ZSwgbW91c2V1cCB9ID0gdGhpcztcbiAgICB3aW5kb3cyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbW91c2VnZW5lcmFsLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgd2luZG93Mi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCBtb3VzZWdlbmVyYWwsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICB3aW5kb3cyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIG1vdXNlZ2VuZXJhbCwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgIHdpbmRvdzIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIG1vdXNlZ2VuZXJhbCwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgIHdpbmRvdzIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCBtb3VzZWdlbmVyYWwsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICB3aW5kb3cyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW91c2Vtb3ZlLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgd2luZG93Mi5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBtb3VzZXVwLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgc2VsZi5tb3VzZURyYWdnZXIgPSB0aGlzO1xuICAgIGdsb2IuZ2xvYmFsTW91c2VEcmFnQ2FsbGJhY2tzID0gbXlDYWxsYmFja3M7XG4gICAgZ2xvYi5nbG9iYWxNb3VzZURyYWdDYWxsYmFja3MubW91c2Vkb3duKGRvd25FdmVudCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCB7IHdpbmRvdzogd2luZG93MiwgbW91c2VnZW5lcmFsLCBtb3VzZW1vdmUsIG1vdXNldXAgfSA9IHRoaXM7XG4gICAgd2luZG93Mi5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIG1vdXNlZ2VuZXJhbCwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgIHdpbmRvdzIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgbW91c2VnZW5lcmFsLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgd2luZG93Mi5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBtb3VzZWdlbmVyYWwsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICB3aW5kb3cyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBtb3VzZWdlbmVyYWwsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICB3aW5kb3cyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgbW91c2VnZW5lcmFsLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgd2luZG93Mi5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlbW92ZSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgIHdpbmRvdzIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgbW91c2V1cCwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgIHRoaXMuZ2xvYi5nbG9iYWxNb3VzZURyYWdDYWxsYmFja3MgPSB2b2lkIDA7XG4gICAgdGhpcy5zZWxmLm1vdXNlRHJhZ2dlciA9IHZvaWQgMDtcbiAgfVxufTtcbmZ1bmN0aW9uIHN0YXJ0TW91c2VEcmFnKGdsb2IsIHNlbGYsIG15Q2FsbGJhY2tzLCBkb3duRXZlbnQpIHtcbiAgaWYgKGdsb2IuZ2xvYmFsTW91c2VEcmFnQ2FsbGJhY2tzICE9IG51bGwpXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgcmV0dXJuIG5ldyBNb3VzZURyYWdnZXIoZ2xvYiwgc2VsZiwgbXlDYWxsYmFja3MsIGRvd25FdmVudCk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3dpZGdldC90b3VjaERyYWdnZXIudHNcbnZhciBMT05HX1RBUF9EVVJBVElPTl9NUyA9IDUwMDtcbnZhciBMT05HX1RBUF9JTlRFUlJVUFRfTUlOX1RPVUNITU9WRV9QWFBYID0gMTAwO1xuZnVuY3Rpb24gZGVsdGFDbGllbnRTcXVhcmVkKGEsIGIpIHtcbiAgY29uc3QgZHggPSBhLmNsaWVudFggLSBiLmNsaWVudFg7XG4gIGNvbnN0IGR5ID0gYS5jbGllbnRZIC0gYi5jbGllbnRZO1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG52YXIgZ0lzSW5Mb25nVGFwID0gZmFsc2U7XG52YXIgVG91Y2hEcmFnZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihnbG9iLCBzZWxmLCBteUNhbGxiYWNrcywgaW5pdGlhbFRvdWNoLCB0YXJnZXQpIHtcbiAgICB0aGlzLmdsb2IgPSBnbG9iO1xuICAgIHRoaXMuc2VsZiA9IHNlbGY7XG4gICAgdGhpcy5pbml0aWFsVG91Y2ggPSBpbml0aWFsVG91Y2g7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5sb25nVGFwSW50ZXJydXB0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxvbmd0YXAgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IHRhcmdldCwgaW5pdGlhbFRvdWNoIH0gPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLmxvbmdUYXBJbnRlcnJ1cHRlZCkge1xuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgVG91Y2hFdmVudChcInRvdWNoY2FuY2VsXCIsIHsgdG91Y2hlczogW2luaXRpYWxUb3VjaF0sIGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICBnSXNJbkxvbmdUYXAgPSB0cnVlO1xuICAgICAgICBjb25zdCBsb25nVGFwTW92ZSA9IChlKSA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBsb25nVGFwRW5kID0gKGUpID0+IHtcbiAgICAgICAgICBnSXNJbkxvbmdUYXAgPSBmYWxzZTtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgbG9uZ1RhcE1vdmUpO1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgbG9uZ1RhcEVuZCk7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCBsb25nVGFwRW5kKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgbG9uZ1RhcE1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgbG9uZ1RhcEVuZCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCBsb25nVGFwRW5kLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGluaXRpYWxUb3VjaDtcbiAgICAgICAgY29uc3QgY29udGV4dE1lbnVFdmVudCA9IG5ldyBQb2ludGVyRXZlbnQoXCJjb250ZXh0bWVudVwiLCB7XG4gICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgIHZpZXc6IGdldFdpbmRvdygpLFxuICAgICAgICAgIGNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSxcbiAgICAgICAgICBwb2ludGVyVHlwZTogXCJ0b3VjaFwiXG4gICAgICAgIH0pO1xuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChjb250ZXh0TWVudUV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudG91Y2htb3ZlID0gKG1vdmVFdmVudCkgPT4ge1xuICAgICAgY29uc3QgeyBnbG9iLCBzZWxmLCBpbml0aWFsVG91Y2ggfSA9IHRoaXM7XG4gICAgICBjb25zdCB0b3VjaCA9IHRoaXMuZmluZEluaXRpYWxGaW5nZXIobW92ZUV2ZW50LnRhcmdldFRvdWNoZXMpO1xuICAgICAgaWYgKHRvdWNoICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5sb25nVGFwSW50ZXJydXB0ZWQgPSB0aGlzLmxvbmdUYXBJbnRlcnJ1cHRlZCB8fCBkZWx0YUNsaWVudFNxdWFyZWQoaW5pdGlhbFRvdWNoLCB0b3VjaCkgPiBMT05HX1RBUF9JTlRFUlJVUFRfTUlOX1RPVUNITU9WRV9QWFBYO1xuICAgICAgICBpZiAoc2VsZi5kcmFnVG91Y2hFbmFibGVkICYmIHRvdWNoICE9IG51bGwpIHtcbiAgICAgICAgICBnbG9iLmdsb2JhbFRvdWNoRHJhZ0NhbGxiYWNrcz8udG91Y2htb3ZlKG1vdmVFdmVudCwgdG91Y2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnRvdWNoZW5kID0gKGVuZEV2ZW50KSA9PiB7XG4gICAgICB0aGlzLmxvbmdUYXBJbnRlcnJ1cHRlZCA9IHRydWU7XG4gICAgICBjb25zdCB0b3VjaCA9IHRoaXMuZmluZEluaXRpYWxGaW5nZXIoZW5kRXZlbnQuY2hhbmdlZFRvdWNoZXMsIGVuZEV2ZW50LnRvdWNoZXMpO1xuICAgICAgaWYgKHRvdWNoICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5nbG9iLmdsb2JhbFRvdWNoRHJhZ0NhbGxiYWNrcz8udG91Y2hlbmQoZW5kRXZlbnQsIHRvdWNoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH07XG4gICAgdGhpcy5sb25ndGFwVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMubG9uZ3RhcCwgTE9OR19UQVBfRFVSQVRJT05fTVMpO1xuICAgIGNvbnN0IHsgdG91Y2htb3ZlLCB0b3VjaGVuZCB9ID0gdGhpcztcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0b3VjaG1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRvdWNoZW5kLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdG91Y2hlbmQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCB0b3VjaGVuZCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICBzZWxmLnRvdWNoRHJhZ2dlciA9IHRoaXM7XG4gICAgZ2xvYi5nbG9iYWxUb3VjaERyYWdDYWxsYmFja3MgPSBteUNhbGxiYWNrcztcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHsgbG9uZ3RhcFRpbWVyLCB0b3VjaG1vdmUsIHRvdWNoZW5kIH0gPSB0aGlzO1xuICAgIGNsZWFyVGltZW91dChsb25ndGFwVGltZXIpO1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRvdWNoZW5kKTtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRvdWNobW92ZSk7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRvdWNoZW5kKTtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgdG91Y2hlbmQpO1xuICAgIHRoaXMuZ2xvYi5nbG9iYWxUb3VjaERyYWdDYWxsYmFja3MgPSB2b2lkIDA7XG4gICAgdGhpcy5zZWxmLnRvdWNoRHJhZ2dlciA9IHZvaWQgMDtcbiAgfVxuICBmaW5kSW5pdGlhbEZpbmdlciguLi50b3VjaExpc3RzKSB7XG4gICAgY29uc3QgdG91Y2hlcyA9IHRvdWNoTGlzdHMubWFwKCh0b3VjaExpc3QpID0+IEFycmF5LmZyb20odG91Y2hMaXN0KSkuZmxhdCgpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRvdWNoZXMpLmZpbmQoKHYpID0+IHYuaWRlbnRpZmllciA9PT0gdGhpcy5pbml0aWFsVG91Y2guaWRlbnRpZmllcik7XG4gIH1cbn07XG5mdW5jdGlvbiBzdGFydE9uZUZpbmdlclRvdWNoKGdsb2IsIHNlbGYsIG15Q2FsbGJhY2tzLCBpbml0aWFsVG91Y2gsIHRhcmdldCkge1xuICBpZiAoZ2xvYi5nbG9iYWxUb3VjaERyYWdDYWxsYmFja3MgIT0gbnVsbCB8fCBnSXNJbkxvbmdUYXApXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgcmV0dXJuIG5ldyBUb3VjaERyYWdnZXIoZ2xvYiwgc2VsZiwgbXlDYWxsYmFja3MsIGluaXRpYWxUb3VjaCwgdGFyZ2V0KTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvd2lkZ2V0L3dpZGdldExpc3RlbmVySW50ZXJuYWwudHNcbmZ1bmN0aW9uIG1ha2VNb3VzZURyYWcoY3VycmVudCwgdHlwZSwgb3JpZ2luMywgc291cmNlRXZlbnQpIHtcbiAgY29uc3QgeyBjdXJyZW50WCwgY3VycmVudFkgfSA9IFdpZGdldEV2ZW50VXRpbC5jYWxjQ3VycmVudFhZKGN1cnJlbnQuZ2V0RWxlbWVudCgpLCBzb3VyY2VFdmVudCk7XG4gIGNvbnN0IG9yaWdpbkRlbHRhWCA9IHNvdXJjZUV2ZW50LnBhZ2VYIC0gb3JpZ2luMy5wYWdlWDtcbiAgY29uc3Qgb3JpZ2luRGVsdGFZID0gc291cmNlRXZlbnQucGFnZVkgLSBvcmlnaW4zLnBhZ2VZO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgZGV2aWNlOiBcIm1vdXNlXCIsXG4gICAgb2Zmc2V0WDogb3JpZ2luMy5vZmZzZXRYICsgb3JpZ2luRGVsdGFYLFxuICAgIG9mZnNldFk6IG9yaWdpbjMub2Zmc2V0WSArIG9yaWdpbkRlbHRhWSxcbiAgICBjbGllbnRYOiBzb3VyY2VFdmVudC5jbGllbnRYLFxuICAgIGNsaWVudFk6IHNvdXJjZUV2ZW50LmNsaWVudFksXG4gICAgY3VycmVudFgsXG4gICAgY3VycmVudFksXG4gICAgb3JpZ2luRGVsdGFYLFxuICAgIG9yaWdpbkRlbHRhWSxcbiAgICBzb3VyY2VFdmVudFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VG91Y2hPZmZzZXRzKGN1cnJlbnQsIHsgcGFnZVgsIHBhZ2VZIH0pIHtcbiAgY29uc3QgeyB4LCB5IH0gPSBjdXJyZW50LmdldEVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHsgb2Zmc2V0WDogcGFnZVggLSB4LCBvZmZzZXRZOiBwYWdlWSAtIHkgfTtcbn1cbmZ1bmN0aW9uIG1ha2VUb3VjaERyYWcoY3VycmVudCwgdHlwZSwgb3JpZ2luMywgc291cmNlRXZlbnQsIHRvdWNoKSB7XG4gIGNvbnN0IHsgY3VycmVudFgsIGN1cnJlbnRZIH0gPSBXaWRnZXRFdmVudFV0aWwuY2FsY0N1cnJlbnRYWShjdXJyZW50LmdldEVsZW1lbnQoKSwgdG91Y2gpO1xuICBjb25zdCBvcmlnaW5EZWx0YVggPSB0b3VjaC5wYWdlWCAtIG9yaWdpbjMucGFnZVg7XG4gIGNvbnN0IG9yaWdpbkRlbHRhWSA9IHRvdWNoLnBhZ2VZIC0gb3JpZ2luMy5wYWdlWTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIGRldmljZTogXCJ0b3VjaFwiLFxuICAgIG9mZnNldFg6IG9yaWdpbjMub2Zmc2V0WCArIG9yaWdpbkRlbHRhWCxcbiAgICBvZmZzZXRZOiBvcmlnaW4zLm9mZnNldFkgKyBvcmlnaW5EZWx0YVksXG4gICAgY2xpZW50WDogdG91Y2guY2xpZW50WCxcbiAgICBjbGllbnRZOiB0b3VjaC5jbGllbnRZLFxuICAgIGN1cnJlbnRYLFxuICAgIGN1cnJlbnRZLFxuICAgIG9yaWdpbkRlbHRhWCxcbiAgICBvcmlnaW5EZWx0YVksXG4gICAgc291cmNlRXZlbnRcbiAgfTtcbn1cbnZhciBHbG9iYWxDYWxsYmFja3MgPSB7fTtcbnZhciBXaWRnZXRMaXN0ZW5lckludGVybmFsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihkaXNwYXRjaENhbGxiYWNrKSB7XG4gICAgdGhpcy5kaXNwYXRjaENhbGxiYWNrID0gZGlzcGF0Y2hDYWxsYmFjaztcbiAgICB0aGlzLmRyYWdUb3VjaEVuYWJsZWQgPSB0cnVlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kcmFnVHJpZ2dlclJlbW92ZXI/LigpO1xuICAgIHRoaXMuZHJhZ1RyaWdnZXJSZW1vdmVyID0gdm9pZCAwO1xuICAgIHRoaXMuZHJhZ1N0YXJ0TGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIHRoaXMuZHJhZ01vdmVMaXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5kcmFnRW5kTGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIHRoaXMubW91c2VEcmFnZ2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy50b3VjaERyYWdnZXI/LmRlc3Ryb3koKTtcbiAgfVxuICBhZGQodHlwZSwgdGFyZ2V0LCBoYW5kbGVyKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiZHJhZy1zdGFydFwiOiB7XG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0TGlzdGVuZXJzID8/ICh0aGlzLmRyYWdTdGFydExpc3RlbmVycyA9IFtdKTtcbiAgICAgICAgdGhpcy5kcmFnU3RhcnRMaXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckRyYWdUcmlnZ2VyKHRhcmdldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRyYWctbW92ZVwiOiB7XG4gICAgICAgIHRoaXMuZHJhZ01vdmVMaXN0ZW5lcnMgPz8gKHRoaXMuZHJhZ01vdmVMaXN0ZW5lcnMgPSBbXSk7XG4gICAgICAgIHRoaXMuZHJhZ01vdmVMaXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckRyYWdUcmlnZ2VyKHRhcmdldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRyYWctZW5kXCI6IHtcbiAgICAgICAgdGhpcy5kcmFnRW5kTGlzdGVuZXJzID8/ICh0aGlzLmRyYWdFbmRMaXN0ZW5lcnMgPSBbXSk7XG4gICAgICAgIHRoaXMuZHJhZ0VuZExpc3RlbmVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRHJhZ1RyaWdnZXIodGFyZ2V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlbW92ZSh0eXBlLCBfdGFyZ2V0LCBoYW5kbGVyKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiZHJhZy1zdGFydFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVIYW5kbGVyKHRoaXMuZHJhZ1N0YXJ0TGlzdGVuZXJzLCBoYW5kbGVyKTtcbiAgICAgIGNhc2UgXCJkcmFnLW1vdmVcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlSGFuZGxlcih0aGlzLmRyYWdNb3ZlTGlzdGVuZXJzLCBoYW5kbGVyKTtcbiAgICAgIGNhc2UgXCJkcmFnLWVuZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVIYW5kbGVyKHRoaXMuZHJhZ0VuZExpc3RlbmVycywgaGFuZGxlcik7XG4gICAgfVxuICB9XG4gIHJlbW92ZUhhbmRsZXIoYXJyYXkyLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgaW5kZXggPSBhcnJheTI/LmluZGV4T2YoaGFuZGxlcik7XG4gICAgaWYgKGluZGV4ICE9PSB2b2lkIDApXG4gICAgICBhcnJheTI/LnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgcmVnaXN0ZXJEcmFnVHJpZ2dlcih0YXJnZXQpIHtcbiAgICBpZiAodGhpcy5kcmFnVHJpZ2dlclJlbW92ZXIgPT0gbnVsbCkge1xuICAgICAgY29uc3QgbW91c2VUcmlnZ2VyID0gKGV2ZW50KSA9PiB0aGlzLnRyaWdnZXJNb3VzZURyYWcodGFyZ2V0LCBldmVudCk7XG4gICAgICBjb25zdCB0b3VjaFRyaWdnZXIgPSAoZXZlbnQpID0+IHRoaXMudHJpZ2dlclRvdWNoRHJhZyh0YXJnZXQsIGV2ZW50KTtcbiAgICAgIHRhcmdldC5nZXRFbGVtZW50KCkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBtb3VzZVRyaWdnZXIpO1xuICAgICAgdGFyZ2V0LmdldEVsZW1lbnQoKS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0b3VjaFRyaWdnZXIsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICB0aGlzLmRyYWdUcmlnZ2VyUmVtb3ZlciA9ICgpID0+IHtcbiAgICAgICAgdGFyZ2V0LmdldEVsZW1lbnQoKS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIG1vdXNlVHJpZ2dlcik7XG4gICAgICAgIHRhcmdldC5nZXRFbGVtZW50KCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdG91Y2hUcmlnZ2VyKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHRyaWdnZXJNb3VzZURyYWcoY3VycmVudCwgZG93bkV2ZW50KSB7XG4gICAgaWYgKGRvd25FdmVudC5idXR0b24gPT09IDApIHtcbiAgICAgIHRoaXMuc3RhcnRNb3VzZURyYWcoY3VycmVudCwgZG93bkV2ZW50KTtcbiAgICB9XG4gIH1cbiAgc3RhcnRNb3VzZURyYWcoY3VycmVudCwgaW5pdGlhbERvd25FdmVudCkge1xuICAgIGNvbnN0IG9yaWdpbjMgPSB7IHBhZ2VYOiBOYU4sIHBhZ2VZOiBOYU4sIG9mZnNldFg6IE5hTiwgb2Zmc2V0WTogTmFOIH07XG4gICAgcGFydGlhbEFzc2lnbihbXCJwYWdlWFwiLCBcInBhZ2VZXCIsIFwib2Zmc2V0WFwiLCBcIm9mZnNldFlcIl0sIG9yaWdpbjMsIGluaXRpYWxEb3duRXZlbnQpO1xuICAgIGNvbnN0IGRyYWdDYWxsYmFja3MgPSB7XG4gICAgICBtb3VzZWRvd246IChkb3duRXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgZHJhZ1N0YXJ0RXZlbnQgPSBtYWtlTW91c2VEcmFnKGN1cnJlbnQsIFwiZHJhZy1zdGFydFwiLCBvcmlnaW4zLCBkb3duRXZlbnQpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKFwiZHJhZy1zdGFydFwiLCBjdXJyZW50LCBkcmFnU3RhcnRFdmVudCk7XG4gICAgICB9LFxuICAgICAgbW91c2Vtb3ZlOiAobW92ZUV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBtYWtlTW91c2VEcmFnKGN1cnJlbnQsIFwiZHJhZy1tb3ZlXCIsIG9yaWdpbjMsIG1vdmVFdmVudCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goXCJkcmFnLW1vdmVcIiwgY3VycmVudCwgZHJhZ01vdmVFdmVudCk7XG4gICAgICB9LFxuICAgICAgbW91c2V1cDogKHVwRXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgZHJhZ0VuZEV2ZW50ID0gbWFrZU1vdXNlRHJhZyhjdXJyZW50LCBcImRyYWctZW5kXCIsIG9yaWdpbjMsIHVwRXZlbnQpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKFwiZHJhZy1lbmRcIiwgY3VycmVudCwgZHJhZ0VuZEV2ZW50KTtcbiAgICAgICAgdGhpcy5lbmREcmFnKGN1cnJlbnQsIGRyYWdFbmRFdmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1vdXNlRHJhZ2dlciA9IHN0YXJ0TW91c2VEcmFnKEdsb2JhbENhbGxiYWNrcywgdGhpcywgZHJhZ0NhbGxiYWNrcywgaW5pdGlhbERvd25FdmVudCk7XG4gIH1cbiAgZW5kRHJhZyh0YXJnZXQsIHsgc291cmNlRXZlbnQsIGNsaWVudFgsIGNsaWVudFkgfSkge1xuICAgIGNvbnN0IGVsZW0gPSB0YXJnZXQuZ2V0RWxlbWVudCgpO1xuICAgIGNvbnN0IHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmICghQkJveFZhbHVlcy5jb250YWluc1BvaW50KHJlY3QsIGNsaWVudFgsIGNsaWVudFkpKSB7XG4gICAgICBlbGVtLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoXCJtb3VzZWxlYXZlXCIsIHNvdXJjZUV2ZW50KSk7XG4gICAgICBzb3VyY2VFdmVudC50YXJnZXQ/LmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoXCJtb3VzZWVudGVyXCIsIHNvdXJjZUV2ZW50KSk7XG4gICAgfVxuICB9XG4gIHRyaWdnZXJUb3VjaERyYWcoY3VycmVudCwgc3RhcnRFdmVudCkge1xuICAgIGNvbnN0IHRvdWNoID0gc3RhcnRFdmVudC50YXJnZXRUb3VjaGVzLml0ZW0oMCk7XG4gICAgaWYgKHN0YXJ0RXZlbnQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDEgJiYgdG91Y2ggIT0gbnVsbCkge1xuICAgICAgdGhpcy5zdGFydE9uZUZpbmdlclRvdWNoKGN1cnJlbnQsIHN0YXJ0RXZlbnQsIHRvdWNoKTtcbiAgICB9XG4gIH1cbiAgc3RhcnRPbmVGaW5nZXJUb3VjaChjdXJyZW50LCBpbml0aWFsRXZlbnQsIGluaXRpYWxUb3VjaCkge1xuICAgIGNvbnN0IG9yaWdpbjMgPSB7IHBhZ2VYOiBOYU4sIHBhZ2VZOiBOYU4sIC4uLmdldFRvdWNoT2Zmc2V0cyhjdXJyZW50LCBpbml0aWFsVG91Y2gpIH07XG4gICAgcGFydGlhbEFzc2lnbihbXCJwYWdlWFwiLCBcInBhZ2VZXCJdLCBvcmlnaW4zLCBpbml0aWFsVG91Y2gpO1xuICAgIGNvbnN0IGRyYWdDYWxsYmFja3MgPSB7XG4gICAgICB0b3VjaG1vdmU6IChtb3ZlRXZlbnQsIHRvdWNoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBtYWtlVG91Y2hEcmFnKGN1cnJlbnQsIFwiZHJhZy1tb3ZlXCIsIG9yaWdpbjMsIG1vdmVFdmVudCwgdG91Y2gpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKFwiZHJhZy1tb3ZlXCIsIGN1cnJlbnQsIGRyYWdNb3ZlRXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHRvdWNoZW5kOiAoY2FuY2VsRXZlbnQsIHRvdWNoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBtYWtlVG91Y2hEcmFnKGN1cnJlbnQsIFwiZHJhZy1lbmRcIiwgb3JpZ2luMywgY2FuY2VsRXZlbnQsIHRvdWNoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaChcImRyYWctZW5kXCIsIGN1cnJlbnQsIGRyYWdNb3ZlRXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdGFyZ2V0ID0gY3VycmVudC5nZXRFbGVtZW50KCk7XG4gICAgdGhpcy50b3VjaERyYWdnZXIgPSBzdGFydE9uZUZpbmdlclRvdWNoKEdsb2JhbENhbGxiYWNrcywgdGhpcywgZHJhZ0NhbGxiYWNrcywgaW5pdGlhbFRvdWNoLCB0YXJnZXQpO1xuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbWFrZVRvdWNoRHJhZyhjdXJyZW50LCBcImRyYWctc3RhcnRcIiwgb3JpZ2luMywgaW5pdGlhbEV2ZW50LCBpbml0aWFsVG91Y2gpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJkcmFnLXN0YXJ0XCIsIGN1cnJlbnQsIGRyYWdTdGFydEV2ZW50KTtcbiAgfVxuICBkaXNwYXRjaCh0eXBlLCBjdXJyZW50LCBldmVudCkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImRyYWctc3RhcnRcIjpcbiAgICAgICAgdGhpcy5kcmFnU3RhcnRMaXN0ZW5lcnM/LmZvckVhY2goKGhhbmRsZXIpID0+IGhhbmRsZXIoZXZlbnQsIGN1cnJlbnQpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZHJhZy1tb3ZlXCI6XG4gICAgICAgIHRoaXMuZHJhZ01vdmVMaXN0ZW5lcnM/LmZvckVhY2goKGhhbmRsZXIpID0+IGhhbmRsZXIoZXZlbnQsIGN1cnJlbnQpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZHJhZy1lbmRcIjpcbiAgICAgICAgdGhpcy5kcmFnRW5kTGlzdGVuZXJzPy5mb3JFYWNoKChoYW5kbGVyKSA9PiBoYW5kbGVyKGV2ZW50LCBjdXJyZW50KSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoQ2FsbGJhY2sodHlwZSwgZXZlbnQpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy93aWRnZXQvd2lkZ2V0LnRzXG52YXIgV2lkZ2V0Qm91bmRzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlbGVtKSB7XG4gICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgfVxuICBzZXRCb3VuZHMoYm91bmRzKSB7XG4gICAgc2V0RWxlbWVudEJCb3godGhpcy5lbGVtQ29udGFpbmVyID8/IHRoaXMuZWxlbSwgYm91bmRzKTtcbiAgfVxuICBnZXRCb3VuZHMoKSB7XG4gICAgcmV0dXJuIGdldEVsZW1lbnRCQm94KHRoaXMuZWxlbUNvbnRhaW5lciA/PyB0aGlzLmVsZW0pO1xuICB9XG4gIHN0YXRpYyBzZXRFbGVtZW50Q29udGFpbmVyKHdpZGdldCwgZWxlbUNvbnRhaW5lcikge1xuICAgIGNvbnN0IGN1cnJlbnRCb3VuZHMgPSB3aWRnZXQuZ2V0Qm91bmRzKCk7XG4gICAgc2V0RWxlbWVudEJCb3goZWxlbUNvbnRhaW5lciwgY3VycmVudEJvdW5kcyk7XG4gICAgc2V0RWxlbWVudFN0eWxlcyh3aWRnZXQuZWxlbSwgeyB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIgfSk7XG4gICAgd2lkZ2V0LmVsZW0ucmVtb3ZlKCk7XG4gICAgd2lkZ2V0LmVsZW1Db250YWluZXIgPSBlbGVtQ29udGFpbmVyO1xuICAgIHdpZGdldC5lbGVtQ29udGFpbmVyLnJlcGxhY2VDaGlsZHJlbih3aWRnZXQuZWxlbSk7XG4gIH1cbn07XG52YXIgV2lkZ2V0ID0gY2xhc3MgZXh0ZW5kcyBXaWRnZXRCb3VuZHMge1xuICBjb25zdHJ1Y3RvcihlbGVtKSB7XG4gICAgc3VwZXIoZWxlbSk7XG4gICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICB0aGlzLmluZGV4ID0gTmFOO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgfVxuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW07XG4gIH1cbiAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cbiAgZ2V0IGNsaWVudFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW0uY2xpZW50V2lkdGg7XG4gIH1cbiAgZ2V0IGNsaWVudEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtLmNsaWVudEhlaWdodDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucGFyZW50Py5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBjaGlsZC5wYXJlbnQgPSB2b2lkIDA7XG4gICAgICBjaGlsZC5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGVzdHJ1Y3RvcigpO1xuICAgIHRoaXMuZWxlbS5yZW1vdmUoKTtcbiAgICB0aGlzLmVsZW1Db250YWluZXI/LnJlbW92ZSgpO1xuICAgIHRoaXMuaW50ZXJuYWxMaXN0ZW5lcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuaHRtbExpc3RlbmVyPy5kZXN0cm95KHRoaXMpO1xuICB9XG4gIHNldEhpZGRlbihoaWRkZW4pIHtcbiAgICBzZXRFbGVtZW50U3R5bGUodGhpcy5lbGVtLCBcImRpc3BsYXlcIiwgaGlkZGVuID8gXCJub25lXCIgOiB2b2lkIDApO1xuICB9XG4gIGlzSGlkZGVuKCkge1xuICAgIHJldHVybiBnZXRXaW5kb3coKT8uZ2V0Q29tcHV0ZWRTdHlsZT8uKHRoaXMuZWxlbSkuZGlzcGxheSA9PT0gXCJub25lXCI7XG4gIH1cbiAgc2V0Q3Vyc29yKGN1cnNvcikge1xuICAgIHNldEVsZW1lbnRTdHlsZSh0aGlzLmVsZW0sIFwiY3Vyc29yXCIsIGN1cnNvcik7XG4gIH1cbiAgc2V0VGV4dENvbnRlbnQodGV4dENvbnRlbnQpIHtcbiAgICB0aGlzLmVsZW0udGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudCA/PyBudWxsO1xuICB9XG4gIHNldEFyaWFEZXNjcmliZWRCeShhcmlhRGVzY3JpYmVkQnkpIHtcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5lbGVtLCBcImFyaWEtZGVzY3JpYmVkYnlcIiwgYXJpYURlc2NyaWJlZEJ5KTtcbiAgfVxuICBzZXRBcmlhSGlkZGVuKGFyaWFIaWRkZW4pIHtcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5lbGVtLCBcImFyaWEtaGlkZGVuXCIsIGFyaWFIaWRkZW4pO1xuICB9XG4gIHNldEFyaWFMYWJlbChhcmlhTGFiZWwpIHtcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5lbGVtLCBcImFyaWEtbGFiZWxcIiwgYXJpYUxhYmVsKTtcbiAgfVxuICBzZXRJbm5lckhUTUwoaHRtbCkge1xuICAgIHRoaXMuZWxlbS5pbm5lckhUTUwgPSBodG1sO1xuICB9XG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIGdldEF0dHJpYnV0ZSh0aGlzLmVsZW0sIFwiYXJpYS1kaXNhYmxlZFwiLCBmYWxzZSk7XG4gIH1cbiAgcGFyc2VGbG9hdChzKSB7XG4gICAgcmV0dXJuIHMgPT09IFwiXCIgPyAwIDogcGFyc2VGbG9hdChzKTtcbiAgfVxuICBjc3NMZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlRmxvYXQodGhpcy5lbGVtLnN0eWxlLmxlZnQpO1xuICB9XG4gIGNzc1RvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZsb2F0KHRoaXMuZWxlbS5zdHlsZS50b3ApO1xuICB9XG4gIGNzc1dpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlRmxvYXQodGhpcy5lbGVtLnN0eWxlLndpZHRoKTtcbiAgfVxuICBjc3NIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGbG9hdCh0aGlzLmVsZW0uc3R5bGUuaGVpZ2h0KTtcbiAgfVxuICBmb2N1cygpIHtcbiAgICB0aGlzLmVsZW0uZm9jdXMoKTtcbiAgfVxuICBzZXRQcmV2ZW50c0RlZmF1bHQocHJldmVudERlZmF1bHQpIHtcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5lbGVtLCBcImRhdGEtcHJldmVudGRlZmF1bHRcIiwgcHJldmVudERlZmF1bHQpO1xuICB9XG4gIHNldFRhYkluZGV4KHRhYkluZGV4KSB7XG4gICAgc2V0QXR0cmlidXRlKHRoaXMuZWxlbSwgXCJ0YWJpbmRleFwiLCB0YWJJbmRleCk7XG4gIH1cbiAgYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICB0aGlzLmFkZENoaWxkVG9ET00oY2hpbGQsIHRoaXMuZ2V0QmVmb3JlKGNoaWxkKSk7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICBjaGlsZC5pbmRleCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgIHRoaXMub25DaGlsZEFkZGVkKGNoaWxkKTtcbiAgfVxuICByZW1vdmVDaGlsZChjaGlsZCkge1xuICAgIGNvbnN0IGkgPSB0aGlzLmNoaWxkcmVuLmZpbmRJbmRleCgodmFsdWUpID0+IHZhbHVlID09PSBjaGlsZCk7XG4gICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaSwgMSk7XG4gICAgdGhpcy5yZW1vdmVDaGlsZEZyb21ET00oY2hpbGQpO1xuICAgIHRoaXMub25DaGlsZFJlbW92ZWQoY2hpbGQpO1xuICB9XG4gIG1vdmVDaGlsZChjaGlsZCwgZG9tSW5kZXgpIHtcbiAgICBpZiAoY2hpbGQuZG9tSW5kZXggPT09IGRvbUluZGV4KVxuICAgICAgcmV0dXJuO1xuICAgIGNoaWxkLmRvbUluZGV4ID0gZG9tSW5kZXg7XG4gICAgdGhpcy5yZW1vdmVDaGlsZEZyb21ET00oY2hpbGQpO1xuICAgIHRoaXMuYWRkQ2hpbGRUb0RPTShjaGlsZCwgdGhpcy5nZXRCZWZvcmUoY2hpbGQpKTtcbiAgfVxuICBhZGRDbGFzcyguLi50b2tlbnMpIHtcbiAgICB0aGlzLmVsZW0uY2xhc3NMaXN0LmFkZCguLi50b2tlbnMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKC4uLnRva2Vucykge1xuICAgIHRoaXMuZWxlbS5jbGFzc0xpc3QucmVtb3ZlKC4uLnRva2Vucyk7XG4gIH1cbiAgdG9nZ2xlQ2xhc3ModG9rZW4sIGZvcmNlKSB7XG4gICAgdGhpcy5lbGVtLmNsYXNzTGlzdC50b2dnbGUodG9rZW4sIGZvcmNlKTtcbiAgfVxuICBhcHBlbmRPckluc2VydChjaGlsZCwgYmVmb3JlKSB7XG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgYmVmb3JlLmdldEVsZW1lbnQoKS5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJiZWZvcmViZWdpblwiLCBjaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWxlbS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9XG4gIGFkZENoaWxkVG9ET00oY2hpbGQsIGJlZm9yZSkge1xuICAgIHRoaXMuYXBwZW5kT3JJbnNlcnQoY2hpbGQuZ2V0RWxlbWVudCgpLCBiZWZvcmUpO1xuICB9XG4gIHJlbW92ZUNoaWxkRnJvbURPTShjaGlsZCkge1xuICAgIHRoaXMuZWxlbS5yZW1vdmVDaGlsZChjaGlsZC5nZXRFbGVtZW50KCkpO1xuICB9XG4gIG9uQ2hpbGRBZGRlZChfY2hpbGQpIHtcbiAgfVxuICBvbkNoaWxkUmVtb3ZlZChfY2hpbGQpIHtcbiAgfVxuICBnZXRCZWZvcmUoeyBkb21JbmRleCB9KSB7XG4gICAgaWYgKGRvbUluZGV4ID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmZpbHRlcigoY2hpbGQpID0+IGNoaWxkLmRvbUluZGV4ICE9PSB2b2lkIDAgJiYgY2hpbGQuZG9tSW5kZXggPiBkb21JbmRleCkucmVkdWNlKChwcmV2LCBjdXJyKSA9PiAhcHJldiB8fCBjdXJyLmRvbUluZGV4IDwgcHJldi5kb21JbmRleCA/IGN1cnIgOiBwcmV2LCB2b2lkIDApO1xuICB9XG4gIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKFdpZGdldEV2ZW50VXRpbC5pc0hUTUxFdmVudCh0eXBlKSkge1xuICAgICAgdGhpcy5odG1sTGlzdGVuZXIgPz8gKHRoaXMuaHRtbExpc3RlbmVyID0gbmV3IFdpZGdldExpc3RlbmVySFRNTCgpKTtcbiAgICAgIHRoaXMuaHRtbExpc3RlbmVyLmFkZCh0eXBlLCB0aGlzLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW50ZXJuYWxMaXN0ZW5lciA/PyAodGhpcy5pbnRlcm5hbExpc3RlbmVyID0gbmV3IFdpZGdldExpc3RlbmVySW50ZXJuYWwodGhpcy5vbkRpc3BhdGNoLmJpbmQodGhpcykpKTtcbiAgICAgIHRoaXMuaW50ZXJuYWxMaXN0ZW5lci5hZGQodHlwZSwgdGhpcywgbGlzdGVuZXIpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4gdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoV2lkZ2V0RXZlbnRVdGlsLmlzSFRNTEV2ZW50KHR5cGUpKSB7XG4gICAgICB0aGlzLmh0bWxMaXN0ZW5lcj8ucmVtb3ZlKHR5cGUsIHRoaXMsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaHRtbExpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgIHRoaXMuaW50ZXJuYWxMaXN0ZW5lcj8ucmVtb3ZlKHR5cGUsIHRoaXMsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbiAgc2V0RHJhZ1RvdWNoRW5hYmxlZChkcmFnVG91Y2hFbmFibGVkKSB7XG4gICAgdGhpcy5pbnRlcm5hbExpc3RlbmVyID8/ICh0aGlzLmludGVybmFsTGlzdGVuZXIgPSBuZXcgV2lkZ2V0TGlzdGVuZXJJbnRlcm5hbCh0aGlzLm9uRGlzcGF0Y2guYmluZCh0aGlzKSkpO1xuICAgIHRoaXMuaW50ZXJuYWxMaXN0ZW5lci5kcmFnVG91Y2hFbmFibGVkID0gZHJhZ1RvdWNoRW5hYmxlZDtcbiAgfVxuICBvbkRpc3BhdGNoKHR5cGUsIGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5zb3VyY2VFdmVudC5idWJibGVzKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB7IHBhcmVudCB9ID0gdGhpcztcbiAgICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgaW50ZXJuYWxMaXN0ZW5lciB9ID0gcGFyZW50O1xuICAgICAgaWYgKGludGVybmFsTGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBwYXJlbnRFdmVudCA9IHsgLi4uZXZlbnQsIC4uLldpZGdldEV2ZW50VXRpbC5jYWxjQ3VycmVudFhZKHBhcmVudC5nZXRFbGVtZW50KCksIGV2ZW50KSB9O1xuICAgICAgICBpbnRlcm5hbExpc3RlbmVyLmRpc3BhdGNoKHR5cGUsIHBhcmVudCwgcGFyZW50RXZlbnQpO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGFkZFdpbmRvd0V2ZW50KF90eXBlLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IHBhZ2VoaWRlSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnBlcnNpc3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH07XG4gICAgZ2V0V2luZG93KCkuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIHBhZ2VoaWRlSGFuZGxlcik7XG4gICAgcmV0dXJuICgpID0+IGdldFdpbmRvdygpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBwYWdlaGlkZUhhbmRsZXIpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sYXlvdXQvbGF5b3V0TWFuYWdlci50c1xudmFyIExheW91dEVsZW1lbnQgPSAvKiBAX19QVVJFX18gKi8gKChMYXlvdXRFbGVtZW50MikgPT4ge1xuICBMYXlvdXRFbGVtZW50MltMYXlvdXRFbGVtZW50MltcIkNhcHRpb25cIl0gPSAwXSA9IFwiQ2FwdGlvblwiO1xuICBMYXlvdXRFbGVtZW50MltMYXlvdXRFbGVtZW50MltcIkxlZ2VuZFwiXSA9IDFdID0gXCJMZWdlbmRcIjtcbiAgTGF5b3V0RWxlbWVudDJbTGF5b3V0RWxlbWVudDJbXCJUb29sYmFyTGVmdFwiXSA9IDJdID0gXCJUb29sYmFyTGVmdFwiO1xuICBMYXlvdXRFbGVtZW50MltMYXlvdXRFbGVtZW50MltcIlRvb2xiYXJCb3R0b21cIl0gPSAzXSA9IFwiVG9vbGJhckJvdHRvbVwiO1xuICBMYXlvdXRFbGVtZW50MltMYXlvdXRFbGVtZW50MltcIk5hdmlnYXRvclwiXSA9IDRdID0gXCJOYXZpZ2F0b3JcIjtcbiAgTGF5b3V0RWxlbWVudDJbTGF5b3V0RWxlbWVudDJbXCJPdmVybGF5XCJdID0gNV0gPSBcIk92ZXJsYXlcIjtcbiAgcmV0dXJuIExheW91dEVsZW1lbnQyO1xufSkoTGF5b3V0RWxlbWVudCB8fCB7fSk7XG52YXIgTGF5b3V0TWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgdGhpcy5lbGVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiB0aGlzLmV2ZW50cy5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuICByZWdpc3RlckVsZW1lbnQoZWxlbWVudDIsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudHMuaGFzKGVsZW1lbnQyKSkge1xuICAgICAgdGhpcy5lbGVtZW50cy5nZXQoZWxlbWVudDIpLmFkZChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWxlbWVudHMuc2V0KGVsZW1lbnQyLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbbGlzdGVuZXJdKSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB0aGlzLmVsZW1lbnRzLmdldChlbGVtZW50Mik/LmRlbGV0ZShsaXN0ZW5lcik7XG4gIH1cbiAgY3JlYXRlQ29udGV4dCh3aWR0aDIsIGhlaWdodDIpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gbmV3IExheW91dENvbnRleHQod2lkdGgyLCBoZWlnaHQyKTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQyIG9mIE9iamVjdC52YWx1ZXMoTGF5b3V0RWxlbWVudCkpIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudDIgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdGhpcy5lbGVtZW50cy5nZXQoZWxlbWVudDIpPy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoY29udGV4dCkpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuICBlbWl0TGF5b3V0Q29tcGxldGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGV2ZW50VHlwZSA9IFwibGF5b3V0OmNvbXBsZXRlXCI7XG4gICAgY29uc3QgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IGNvbnRleHQ7XG4gICAgdGhpcy5ldmVudHMuZW1pdChldmVudFR5cGUsIHtcbiAgICAgIHR5cGU6IGV2ZW50VHlwZSxcbiAgICAgIGF4ZXM6IG9wdGlvbnMuYXhlcyA/PyBbXSxcbiAgICAgIGNoYXJ0OiB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9LFxuICAgICAgY2xpcFNlcmllczogb3B0aW9ucy5jbGlwU2VyaWVzID8/IGZhbHNlLFxuICAgICAgc2VyaWVzOiBvcHRpb25zLnNlcmllc1xuICAgIH0pO1xuICB9XG59O1xudmFyIExheW91dENvbnRleHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoMiwgaGVpZ2h0Mikge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDI7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQyO1xuICAgIHRoaXMubGF5b3V0Qm94ID0gbmV3IEJCb3goMCwgMCwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY2hhcnRDYXB0aW9ucy50c1xudmFyIENoYXJ0Q2FwdGlvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudGl0bGUgPSBuZXcgQ2FwdGlvbigpO1xuICAgIHRoaXMuc3VidGl0bGUgPSBuZXcgQ2FwdGlvbigpO1xuICAgIHRoaXMuZm9vdG5vdGUgPSBuZXcgQ2FwdGlvbigpO1xuICB9XG4gIHBvc2l0aW9uQ2FwdGlvbnMoY3R4KSB7XG4gICAgY29uc3QgeyB0aXRsZSwgc3VidGl0bGUsIGZvb3Rub3RlIH0gPSB0aGlzO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IGN0eC5sYXlvdXRCb3guaGVpZ2h0IC8gMTA7XG4gICAgaWYgKHRpdGxlLmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IHsgc3BhY2luZyA9IHN1YnRpdGxlLmVuYWJsZWQgPyBDYXB0aW9uLlNNQUxMX1BBRERJTkcgOiBDYXB0aW9uLkxBUkdFX1BBRERJTkcgfSA9IHRpdGxlO1xuICAgICAgdGhpcy5wb3NpdGlvbkNhcHRpb24oXCJ0b3BcIiwgdGl0bGUsIGN0eC5sYXlvdXRCb3gsIG1heEhlaWdodCk7XG4gICAgICB0aGlzLnNocmlua0xheW91dEJ5Q2FwdGlvbihcInRvcFwiLCB0aXRsZSwgY3R4LmxheW91dEJveCwgc3BhY2luZyk7XG4gICAgfVxuICAgIGlmIChzdWJ0aXRsZS5lbmFibGVkKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uQ2FwdGlvbihcInRvcFwiLCBzdWJ0aXRsZSwgY3R4LmxheW91dEJveCwgbWF4SGVpZ2h0KTtcbiAgICAgIHRoaXMuc2hyaW5rTGF5b3V0QnlDYXB0aW9uKFwidG9wXCIsIHN1YnRpdGxlLCBjdHgubGF5b3V0Qm94LCBzdWJ0aXRsZS5zcGFjaW5nKTtcbiAgICB9XG4gICAgaWYgKGZvb3Rub3RlLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMucG9zaXRpb25DYXB0aW9uKFwiYm90dG9tXCIsIGZvb3Rub3RlLCBjdHgubGF5b3V0Qm94LCBtYXhIZWlnaHQpO1xuICAgICAgdGhpcy5zaHJpbmtMYXlvdXRCeUNhcHRpb24oXCJib3R0b21cIiwgZm9vdG5vdGUsIGN0eC5sYXlvdXRCb3gsIGZvb3Rub3RlLnNwYWNpbmcpO1xuICAgIH1cbiAgfVxuICBwb3NpdGlvbkFic29sdXRlQ2FwdGlvbnMoY3R4KSB7XG4gICAgY29uc3QgeyB0aXRsZSwgc3VidGl0bGUsIGZvb3Rub3RlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcmVjdCB9ID0gY3R4LnNlcmllcztcbiAgICBmb3IgKGNvbnN0IGNhcHRpb24gb2YgW3RpdGxlLCBzdWJ0aXRsZSwgZm9vdG5vdGVdKSB7XG4gICAgICBpZiAoY2FwdGlvbi5sYXlvdXRTdHlsZSAhPT0gXCJvdmVybGF5XCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGNhcHRpb24udGV4dEFsaWduID09PSBcImxlZnRcIikge1xuICAgICAgICBjYXB0aW9uLm5vZGUueCA9IHJlY3QueCArIGNhcHRpb24ucGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoY2FwdGlvbi50ZXh0QWxpZ24gPT09IFwicmlnaHRcIikge1xuICAgICAgICBjb25zdCBiYm94ID0gY2FwdGlvbi5ub2RlLmdldEJCb3goKTtcbiAgICAgICAgY2FwdGlvbi5ub2RlLnggPSByZWN0LnggKyByZWN0LndpZHRoIC0gYmJveC53aWR0aCAtIGNhcHRpb24ucGFkZGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29tcHV0ZVgoYWxpZ24yLCBsYXlvdXRCb3gpIHtcbiAgICBpZiAoYWxpZ24yID09PSBcImxlZnRcIikge1xuICAgICAgcmV0dXJuIGxheW91dEJveC54O1xuICAgIH0gZWxzZSBpZiAoYWxpZ24yID09PSBcInJpZ2h0XCIpIHtcbiAgICAgIHJldHVybiBsYXlvdXRCb3gueCArIGxheW91dEJveC53aWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIGxheW91dEJveC54ICsgbGF5b3V0Qm94LndpZHRoIC8gMjtcbiAgfVxuICBwb3NpdGlvbkNhcHRpb24odkFsaWduLCBjYXB0aW9uLCBsYXlvdXRCb3gsIG1heEhlaWdodCkge1xuICAgIGNvbnN0IGNvbnRhaW5lckhlaWdodCA9IE1hdGgubWF4KFRleHRVdGlscy5nZXRMaW5lSGVpZ2h0KGNhcHRpb24uZm9udFNpemUpLCBtYXhIZWlnaHQpO1xuICAgIGNhcHRpb24ubm9kZS54ID0gdGhpcy5jb21wdXRlWChjYXB0aW9uLnRleHRBbGlnbiwgbGF5b3V0Qm94KSArIGNhcHRpb24ucGFkZGluZztcbiAgICBjYXB0aW9uLm5vZGUueSA9IGxheW91dEJveC55ICsgKHZBbGlnbiA9PT0gXCJ0b3BcIiA/IDAgOiBsYXlvdXRCb3guaGVpZ2h0KSArIGNhcHRpb24ucGFkZGluZztcbiAgICBjYXB0aW9uLm5vZGUudGV4dEJhc2VsaW5lID0gdkFsaWduO1xuICAgIGNhcHRpb24uY29tcHV0ZVRleHRXcmFwKGxheW91dEJveC53aWR0aCwgY29udGFpbmVySGVpZ2h0KTtcbiAgfVxuICBzaHJpbmtMYXlvdXRCeUNhcHRpb24odkFsaWduLCBjYXB0aW9uLCBsYXlvdXRCb3gsIHNwYWNpbmcgPSAwKSB7XG4gICAgaWYgKGNhcHRpb24ubGF5b3V0U3R5bGUgPT09IFwiYmxvY2tcIikge1xuICAgICAgY29uc3QgYmJveCA9IGNhcHRpb24ubm9kZS5nZXRCQm94KCk7XG4gICAgICBsYXlvdXRCb3guc2hyaW5rKFxuICAgICAgICB2QWxpZ24gPT09IFwidG9wXCIgPyBNYXRoLmNlaWwoYmJveC55IC0gbGF5b3V0Qm94LnkgKyBiYm94LmhlaWdodCArIHNwYWNpbmcpIDogTWF0aC5jZWlsKGxheW91dEJveC55ICsgbGF5b3V0Qm94LmhlaWdodCAtIGJib3gueSArIHNwYWNpbmcpLFxuICAgICAgICB2QWxpZ25cbiAgICAgICk7XG4gICAgfVxuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQ2hhcnRDYXB0aW9ucy5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBDaGFydENhcHRpb25zLnByb3RvdHlwZSwgXCJzdWJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIENoYXJ0Q2FwdGlvbnMucHJvdG90eXBlLCBcImZvb3Rub3RlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvcHJlc2V0L2NoYXJ0VHlwZU9yaWdpbmF0b3IudHNcbnZhciBjaGFydFR5cGVzID0gW1xuICBcImNhbmRsZXN0aWNrXCIsXG4gIFwiaG9sbG93LWNhbmRsZXN0aWNrXCIsXG4gIFwib2hsY1wiLFxuICBcImxpbmVcIixcbiAgXCJzdGVwLWxpbmVcIixcbiAgXCJobGNcIixcbiAgXCJoaWdoLWxvd1wiXG5dO1xudmFyIENoYXJ0VHlwZU9yaWdpbmF0b3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0U2VydmljZSkge1xuICAgIHRoaXMuY2hhcnRTZXJ2aWNlID0gY2hhcnRTZXJ2aWNlO1xuICAgIHRoaXMubWVtZW50b09yaWdpbmF0b3JLZXkgPSBcImNoYXJ0VHlwZVwiO1xuICB9XG4gIGNyZWF0ZU1lbWVudG8oKSB7XG4gICAgbGV0IGNoYXJ0VHlwZSA9IHRoaXMuY2hhcnRTZXJ2aWNlLnB1YmxpY0FwaT8uZ2V0T3B0aW9ucygpPy5jaGFydFR5cGU7XG4gICAgaWYgKGNoYXJ0VHlwZSA9PSBudWxsKVxuICAgICAgY2hhcnRUeXBlID0gXCJjYW5kbGVzdGlja1wiO1xuICAgIHJldHVybiBjaGFydFR5cGU7XG4gIH1cbiAgZ3VhcmRNZW1lbnRvKGJsb2IpIHtcbiAgICByZXR1cm4gYmxvYiA9PSBudWxsIHx8IGNoYXJ0VHlwZXMuaW5jbHVkZXMoYmxvYik7XG4gIH1cbiAgcmVzdG9yZU1lbWVudG8oX3ZlcnNpb24sIF9tZW1lbnRvVmVyc2lvbiwgbWVtZW50bykge1xuICAgIGlmIChtZW1lbnRvID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgY2hhcnRUeXBlOiBtZW1lbnRvIH07XG4gICAgdGhpcy5jaGFydFNlcnZpY2UucHVibGljQXBpPy51cGRhdGVEZWx0YShvcHRpb25zKS5jYXRjaCgoZSkgPT4gbG9nZ2VyX2V4cG9ydHMuZXJyb3IoXCJlcnJvciByZXN0b3Jpbmcgc3RhdGVcIiwgZSkpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2Rlc3Ryb3kudHNcbnZhciBEZXN0cm95Rm5zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmxlbmd0aCA9IDA7XG4gIH1cbiAgc2V0Rm5zKGRlc3Ryb3lGbnMpIHtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBkZXN0cm95Rm5zO1xuICB9XG4gIHB1c2goLi4uZGVzdHJveUZucykge1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKC4uLmRlc3Ryb3lGbnMpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy92ZXJzaW9uLnRzXG52YXIgVkVSU0lPTiA9IFwiMTEuMS4xXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2FwaS9zdGF0ZS9oaXN0b3J5TWFuYWdlci50c1xudmFyIE5PVF9GT1VORCA9IFN5bWJvbChcInByZXZpb3VzLW1lbWVudG8tbm90LWZvdW5kXCIpO1xudmFyIEhpc3RvcnlNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFydEV2ZW50TWFuYWdlcikge1xuICAgIHRoaXMuaGlzdG9yeSA9IFtdO1xuICAgIHRoaXMuaGlzdG9yeUluZGV4ID0gLTE7XG4gICAgdGhpcy5vcmlnaW5hdG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5jbGVhclN0YXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLm1heEhpc3RvcnlMZW5ndGggPSAxMDA7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImhpc3RvcnlcIik7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gbmV3IERlc3Ryb3lGbnMoKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuc2V0Rm5zKFtcbiAgICAgIGNoYXJ0RXZlbnRNYW5hZ2VyLmFkZExpc3RlbmVyKFwic2VyaWVzLXVuZG9cIiwgdGhpcy51bmRvLmJpbmQodGhpcykpLFxuICAgICAgY2hhcnRFdmVudE1hbmFnZXIuYWRkTGlzdGVuZXIoXCJzZXJpZXMtcmVkb1wiLCB0aGlzLnJlZG8uYmluZCh0aGlzKSlcbiAgICBdKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5kZXN0cm95KCk7XG4gIH1cbiAgYWRkTWVtZW50b09yaWdpbmF0b3Iob3JpZ2luYXRvcikge1xuICAgIHRoaXMub3JpZ2luYXRvcnMuc2V0KG9yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXksIG9yaWdpbmF0b3IpO1xuICAgIHRoaXMuY2xlYXJTdGF0ZS5zZXQob3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleSwgb3JpZ2luYXRvci5jcmVhdGVNZW1lbnRvKCkpO1xuICAgIHRoaXMuZGVidWdFdmVudChcIkhpc3RvcnkgYWRkIG9yaWdpbmF0b3I6XCIsIG9yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXkpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuZGVidWcoYEhpc3RvcnkgY2xlYXI6YCwgT2JqZWN0LmtleXModGhpcy5vcmlnaW5hdG9ycykpO1xuICAgIHRoaXMuaGlzdG9yeSA9IFtdO1xuICAgIHRoaXMuaGlzdG9yeUluZGV4ID0gLTE7XG4gICAgZm9yIChjb25zdCBbbWVtZW50b09yaWdpbmF0b3JLZXksIG9yaWdpbmF0b3JdIG9mIHRoaXMub3JpZ2luYXRvcnMuZW50cmllcygpKSB7XG4gICAgICB0aGlzLmNsZWFyU3RhdGUuc2V0KG1lbWVudG9PcmlnaW5hdG9yS2V5LCBvcmlnaW5hdG9yLmNyZWF0ZU1lbWVudG8oKSk7XG4gICAgfVxuICB9XG4gIHJlY29yZChsYWJlbCwgLi4ub3JpZ2luYXRvcnMpIHtcbiAgICBpZiAodGhpcy5oaXN0b3J5SW5kZXggPCB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5oaXN0b3J5ID0gdGhpcy5oaXN0b3J5LnNsaWNlKDAsIHRoaXMuaGlzdG9yeUluZGV4ICsgMSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhpc3RvcnkubGVuZ3RoID4gdGhpcy5tYXhIaXN0b3J5TGVuZ3RoKSB7XG4gICAgICB0aGlzLmhpc3RvcnkgPSB0aGlzLmhpc3Rvcnkuc2xpY2UoLXRoaXMubWF4SGlzdG9yeUxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IG1lbWVudG9zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IG9yaWdpbmF0b3Igb2Ygb3JpZ2luYXRvcnMpIHtcbiAgICAgIGlmICghdGhpcy5vcmlnaW5hdG9ycy5oYXMob3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBPcmlnaW5hdG9yIFske29yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXl9XSBoYXMgbm90IGJlZW4gYWRkZWQgdG8gdGhlIEhpc3RvcnlNYW5hZ2VyLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG1lbWVudG9zLnNldChvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5LCBvcmlnaW5hdG9yLmNyZWF0ZU1lbWVudG8oKSk7XG4gICAgfVxuICAgIHRoaXMuaGlzdG9yeS5wdXNoKHsgbGFiZWwsIG1lbWVudG9zIH0pO1xuICAgIHRoaXMuaGlzdG9yeUluZGV4ID0gdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDE7XG4gICAgdGhpcy5kZWJ1Z0V2ZW50KGBIaXN0b3J5IHJlY29yZDogWyR7bGFiZWx9XWApO1xuICB9XG4gIHVuZG8oKSB7XG4gICAgY29uc3QgdW5kb0FjdGlvbiA9IHRoaXMuaGlzdG9yeVt0aGlzLmhpc3RvcnlJbmRleF07XG4gICAgaWYgKCF1bmRvQWN0aW9uKVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgbWVtZW50b09yaWdpbmF0b3JLZXkgb2YgdW5kb0FjdGlvbi5tZW1lbnRvcy5rZXlzKCkpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzTWVtZW50byA9IHRoaXMuZmluZFByZXZpb3VzTWVtZW50byhtZW1lbnRvT3JpZ2luYXRvcktleSk7XG4gICAgICBpZiAocHJldmlvdXNNZW1lbnRvID09PSBOT1RfRk9VTkQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBwcmV2aW91cyBtZW1lbnRvIGZvciBbJHttZW1lbnRvT3JpZ2luYXRvcktleX1dLmApO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXN0b3JlTWVtZW50byhtZW1lbnRvT3JpZ2luYXRvcktleSwgcHJldmlvdXNNZW1lbnRvKTtcbiAgICB9XG4gICAgdGhpcy5oaXN0b3J5SW5kZXggLT0gMTtcbiAgICB0aGlzLmRlYnVnRXZlbnQoYEhpc3RvcnkgdW5kbzogWyR7dW5kb0FjdGlvbi5sYWJlbH1dYCk7XG4gIH1cbiAgcmVkbygpIHtcbiAgICBjb25zdCByZWRvQWN0aW9uID0gdGhpcy5oaXN0b3J5W3RoaXMuaGlzdG9yeUluZGV4ICsgMV07XG4gICAgaWYgKCFyZWRvQWN0aW9uKVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgW21lbWVudG9PcmlnaW5hdG9yS2V5LCBtZW1lbnRvXSBvZiByZWRvQWN0aW9uLm1lbWVudG9zLmVudHJpZXMoKSkge1xuICAgICAgdGhpcy5yZXN0b3JlTWVtZW50byhtZW1lbnRvT3JpZ2luYXRvcktleSwgbWVtZW50byk7XG4gICAgfVxuICAgIHRoaXMuaGlzdG9yeUluZGV4ICs9IDE7XG4gICAgdGhpcy5kZWJ1Z0V2ZW50KGBIaXN0b3J5IHJlZG86IFske3JlZG9BY3Rpb24ubGFiZWx9XWApO1xuICB9XG4gIGZpbmRQcmV2aW91c01lbWVudG8obWVtZW50b09yaWdpbmF0b3JLZXkpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5oaXN0b3J5SW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRoaXMuaGlzdG9yeVtpXS5tZW1lbnRvcy5oYXMobWVtZW50b09yaWdpbmF0b3JLZXkpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpc3RvcnlbaV0ubWVtZW50b3MuZ2V0KG1lbWVudG9PcmlnaW5hdG9yS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuY2xlYXJTdGF0ZS5oYXMobWVtZW50b09yaWdpbmF0b3JLZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGVhclN0YXRlLmdldChtZW1lbnRvT3JpZ2luYXRvcktleSk7XG4gICAgfVxuICAgIHJldHVybiBOT1RfRk9VTkQ7XG4gIH1cbiAgcmVzdG9yZU1lbWVudG8obWVtZW50b09yaWdpbmF0b3JLZXksIG1lbWVudG8pIHtcbiAgICB0aGlzLm9yaWdpbmF0b3JzLmdldChtZW1lbnRvT3JpZ2luYXRvcktleSk/LnJlc3RvcmVNZW1lbnRvKFZFUlNJT04sIFZFUlNJT04sIG1lbWVudG8pO1xuICB9XG4gIGRlYnVnRXZlbnQoLi4ubG9nQ29udGVudCkge1xuICAgIHRoaXMuZGVidWcoXG4gICAgICAuLi5sb2dDb250ZW50LFxuICAgICAgdGhpcy5oaXN0b3J5Lm1hcCgoYWN0aW9uLCBpbmRleCkgPT4gaW5kZXggPT09IHRoaXMuaGlzdG9yeUluZGV4ID8gYCoqICR7YWN0aW9uLmxhYmVsfSAqKmAgOiBhY3Rpb24ubGFiZWwpXG4gICAgKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvYXBpL3N0YXRlL21lbWVudG8udHNcbnZhciBNZW1lbnRvQ2FyZXRha2VyID0gY2xhc3MgX01lbWVudG9DYXJldGFrZXIge1xuICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbi5zcGxpdChcIi1cIilbMF07XG4gIH1cbiAgc2F2ZSguLi5vcmlnaW5hdG9ycykge1xuICAgIGNvbnN0IHBhY2tldCA9IHsgdmVyc2lvbjogdGhpcy52ZXJzaW9uIH07XG4gICAgZm9yIChjb25zdCBvcmlnaW5hdG9yIG9mIE9iamVjdC52YWx1ZXMob3JpZ2luYXRvcnMpKSB7XG4gICAgICBwYWNrZXRbb3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleV0gPSB0aGlzLmVuY29kZShvcmlnaW5hdG9yLCBvcmlnaW5hdG9yLmNyZWF0ZU1lbWVudG8oKSk7XG4gICAgfVxuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbiAgcmVzdG9yZShibG9iLCAuLi5vcmlnaW5hdG9ycykge1xuICAgIGlmICh0eXBlb2YgYmxvYiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoYENvdWxkIG5vdCByZXN0b3JlIGRhdGEgb2YgdHlwZSBbJHt0eXBlb2YgYmxvYn1dLCBleHBlY3RpbmcgYW4gb2JqZWN0LCBpZ25vcmluZy5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGJsb2IgPT0gbnVsbCkge1xuICAgICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoYENvdWxkIG5vdCByZXN0b3JlIGRhdGEgb2YgdHlwZSBbbnVsbF0sIGV4cGVjdGluZyBhbiBvYmplY3QsIGlnbm9yaW5nLmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIShcInZlcnNpb25cIiBpbiBibG9iKSB8fCB0eXBlb2YgYmxvYi52ZXJzaW9uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBsb2dnZXJfZXhwb3J0cy53YXJuT25jZShgQ291bGQgbm90IHJlc3RvcmUgZGF0YSwgbWlzc2luZyBbdmVyc2lvbl0gc3RyaW5nIGluIG9iamVjdCwgaWdub3JpbmcuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb3JpZ2luYXRvciBvZiBvcmlnaW5hdG9ycykge1xuICAgICAgY29uc3QgbWVtZW50byA9IHRoaXMuZGVjb2RlKG9yaWdpbmF0b3IsIGJsb2Jbb3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleV0pO1xuICAgICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICAgIGlmICghb3JpZ2luYXRvci5ndWFyZE1lbWVudG8obWVtZW50bywgbWVzc2FnZXMpKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzU3RyaW5nID0gbWVzc2FnZXMubGVuZ3RoID4gMCA/IGBcblxuJHttZXNzYWdlcy5qb2luKFwiXFxuXFxuXCIpfVxuXG5gIDogXCJcIjtcbiAgICAgICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoXG4gICAgICAgICAgYENvdWxkIG5vdCByZXN0b3JlIFske29yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXl9XSBkYXRhLCB2YWx1ZSB3YXMgaW52YWxpZCwgaWdub3JpbmcuJHttZXNzYWdlc1N0cmluZ31gLFxuICAgICAgICAgIG1lbWVudG9cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb3JpZ2luYXRvci5yZXN0b3JlTWVtZW50byh0aGlzLnZlcnNpb24sIGJsb2IudmVyc2lvbiwgbWVtZW50byk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFbmNvZGUgYSBtZW1lbnRvIGFzIGEgc2VyaWFsaXphYmxlIG9iamVjdCwgZW5jb2RpbmcgYW55IG5vbi1zZXJpYWxpemJsZSB0eXBlcy5cbiAgICovXG4gIGVuY29kZShvcmlnaW5hdG9yLCBtZW1lbnRvKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1lbWVudG8sIF9NZW1lbnRvQ2FyZXRha2VyLmVuY29kZVR5cGVzKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBlbmNvZGUgWyR7b3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleX1dIHZhbHVlIFske2Vycm9yMn1dLmAsIHtcbiAgICAgICAgY2F1c2U6IGVycm9yMlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gZW5jb2RlZCBtZW1lbnRvLCBkZWNvZGluZyBhbnkgbm9uLXNlcmlhbGl6YWJsZSB0eXBlcy5cbiAgICovXG4gIGRlY29kZShvcmlnaW5hdG9yLCBlbmNvZGVkKSB7XG4gICAgaWYgKGVuY29kZWQgPT0gbnVsbClcbiAgICAgIHJldHVybiBlbmNvZGVkO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbmNvZGVkKSwgX01lbWVudG9DYXJldGFrZXIuZGVjb2RlVHlwZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVjb2RlIFske29yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXl9XSB2YWx1ZSBbJHtlcnJvcjJ9XS5gLCB7XG4gICAgICAgIGNhdXNlOiBlcnJvcjJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZW5jb2RlVHlwZXMoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChpc0RhdGUodGhpc1trZXldKSkge1xuICAgICAgcmV0dXJuIHsgX190eXBlOiBcImRhdGVcIiwgdmFsdWU6IHRoaXNba2V5XS50b0lTT1N0cmluZygpIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlVHlwZXMoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChpc09iamVjdCh0aGlzW2tleV0pICYmIFwiX190eXBlXCIgaW4gdGhpc1trZXldICYmIHRoaXNba2V5XS5fX3R5cGUgPT09IFwiZGF0ZVwiKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodGhpc1trZXldLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvc3RhdGUvc3RhdGVNYW5hZ2VyLnRzXG52YXIgU3RhdGVNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNhcmV0YWtlciA9IG5ldyBNZW1lbnRvQ2FyZXRha2VyKFZFUlNJT04pO1xuICAgIHRoaXMuc3RhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIHNldFN0YXRlKG9yaWdpbmF0b3IsIHZhbHVlKSB7XG4gICAgaWYgKG9iamVjdHNFcXVhbCh0aGlzLnN0YXRlLmdldChvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5KSwgdmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGVBbmRSZXN0b3JlKG9yaWdpbmF0b3IsIHZhbHVlKTtcbiAgfVxuICBzZXRTdGF0ZUFuZFJlc3RvcmUob3JpZ2luYXRvciwgdmFsdWUpIHtcbiAgICB0aGlzLnN0YXRlLnNldChvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5LCB2YWx1ZSk7XG4gICAgdGhpcy5yZXN0b3JlU3RhdGUob3JpZ2luYXRvcik7XG4gIH1cbiAgcmVzdG9yZVN0YXRlKG9yaWdpbmF0b3IpIHtcbiAgICBjb25zdCB7IGNhcmV0YWtlciwgc3RhdGUgfSA9IHRoaXM7XG4gICAgaWYgKCFzdGF0ZS5oYXMob3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdmFsdWUgPSBzdGF0ZS5nZXQob3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleSk7XG4gICAgY2FyZXRha2VyLnJlc3RvcmUoeyB2ZXJzaW9uOiBjYXJldGFrZXIudmVyc2lvbiwgW29yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXldOiB2YWx1ZSB9LCBvcmlnaW5hdG9yKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc3R5bGVzLmNzc1xudmFyIHN0eWxlc19kZWZhdWx0ID0gJy5hZy1jaGFydHMtd3JhcHBlciwuYWctY2hhcnRzLXdyYXBwZXI6YWZ0ZXIsLmFnLWNoYXJ0cy13cmFwcGVyOmJlZm9yZSwuYWctY2hhcnRzLXdyYXBwZXIgKiwuYWctY2hhcnRzLXdyYXBwZXIgKjphZnRlciwuYWctY2hhcnRzLXdyYXBwZXIgKjpiZWZvcmV7Ym94LXNpemluZzpib3JkZXItYm94fS5hZy1jaGFydHMtd3JhcHBlcnstLWFsaWduLWl0ZW1zOiBjZW50ZXI7LS1qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtwb3NpdGlvbjpyZWxhdGl2ZTt1c2VyLXNlbGVjdDpub25lOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6cmdiYSgwLDAsMCwwKX0uYWctY2hhcnRzLXdyYXBwZXItLXNhZmUtaG9yaXpvbnRhbHstLWp1c3RpZnktY29udGVudDogZmxleC1zdGFydH0uYWctY2hhcnRzLXdyYXBwZXItLXNhZmUtdmVydGljYWx7LS1hbGlnbi1pdGVtczogZmxleC1zdGFydH0uYWctY2hhcnRzLXRhYi1ndWFyZHt3aWR0aDowJTtoZWlnaHQ6MCU7cG9zaXRpb246YWJzb2x1dGU7cG9pbnRlci1ldmVudHM6bm9uZX0uYWctY2hhcnRzLWNhbnZhcy1jZW50ZXJ7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtwb3NpdGlvbjphYnNvbHV0ZTt0b3VjaC1hY3Rpb246YXV0bztwb2ludGVyLWV2ZW50czphdXRvO2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczp2YXIoLS1hbGlnbi1pdGVtcyk7anVzdGlmeS1jb250ZW50OnZhcigtLWp1c3RpZnktY29udGVudCl9LmFnLWNoYXJ0cy1jYW52YXMtY29udGFpbmVyLC5hZy1jaGFydHMtY2FudmFze3Bvc2l0aW9uOnJlbGF0aXZlO3VzZXItc2VsZWN0Om5vbmU7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lfS5hZy1jaGFydHMtY2FudmFzLWNvbnRhaW5lcj4qLC5hZy1jaGFydHMtY2FudmFzPip7ZGlzcGxheTpibG9jaztwb2ludGVyLWV2ZW50czpub25lfS5hZy1jaGFydHMtc2VyaWVzLWFyZWF7b3V0bGluZTpub25lO3BvaW50ZXItZXZlbnRzOmF1dG87cG9zaXRpb246YWJzb2x1dGV9LmFnLWNoYXJ0cy1zd2FwY2hhaW57b3V0bGluZTpub25lO29wYWNpdHk6MDtwb2ludGVyLWV2ZW50czpub25lO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCV9LmFnLWNoYXJ0cy1zd2FwY2hhaW46Zm9jdXMtdmlzaWJsZXtvcGFjaXR5OjF9LmFnLWNoYXJ0cy1jYW52YXMtcHJveHksLmFnLWNoYXJ0cy1jYW52YXMtb3ZlcmxheXtpbnNldDowO3BvaW50ZXItZXZlbnRzOm5vbmU7cG9zaXRpb246YWJzb2x1dGU7dXNlci1zZWxlY3Q6bm9uZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmV9LmFnLWNoYXJ0cy1jYW52YXMtb3ZlcmxheT4qe3Bvc2l0aW9uOmFic29sdXRlO3BvaW50ZXItZXZlbnRzOmF1dG99LmFnLWNoYXJ0cy10aGVtZS1kZWZhdWx0LC5hZy1jaGFydHMtdGhlbWUtZGVmYXVsdC1kYXJrey0tYWctY2hhcnRzLWFjY2VudC1jb2xvcjogIzIxOTZmMzstLWFnLWNoYXJ0cy1iYWNrZ3JvdW5kLWNvbG9yOiAjZmZmOy0tYWctY2hhcnRzLWJvcmRlci1jb2xvcjogI2RkZGRkZDstLWFnLWNoYXJ0cy1mb3JlZ3JvdW5kLWNvbG9yOiAjNDY0NjQ2Oy0tYWctY2hhcnRzLWZvbnQtZmFtaWx5OiBWZXJkYW5hLCBzYW5zLXNlcmlmOy0tYWctY2hhcnRzLWZvbnQtc2l6ZTogMTJweDstLWFnLWNoYXJ0cy1mb250LXdlaWdodDogNDAwOy0tYWctY2hhcnRzLXBhZGRpbmc6IDIwcHg7LS1hZy1jaGFydHMtc2hhZG93LWNvbG9yOiAjMDAwMDAwODA7LS1hZy1jaGFydHMtc3VidGxlLXRleHQtY29sb3I6ICM4YzhjOGM7LS1hZy1jaGFydHMtdGV4dC1jb2xvcjogIzQ2NDY0NjstLWFnLWNoYXJ0cy1jaHJvbWUtYmFja2dyb3VuZC1jb2xvcjogI2ZhZmFmYTstLWFnLWNoYXJ0cy1jaHJvbWUtZm9udC1mYW1pbHk6IFZlcmRhbmEsIHNhbnMtc2VyaWY7LS1hZy1jaGFydHMtY2hyb21lLWZvbnQtc2l6ZTogMTJweDstLWFnLWNoYXJ0cy1jaHJvbWUtZm9udC13ZWlnaHQ6IDQwMDstLWFnLWNoYXJ0cy1jaHJvbWUtc3VidGxlLXRleHQtY29sb3I6ICM4YzhjOGM7LS1hZy1jaGFydHMtY2hyb21lLXRleHQtY29sb3I6ICMxODFkMWY7LS1hZy1jaGFydHMtaW5wdXQtYmFja2dyb3VuZC1jb2xvcjogI2ZmZjstLWFnLWNoYXJ0cy1pbnB1dC10ZXh0LWNvbG9yOiAjNDY0NjQ2Oy0tYWctY2hhcnRzLWNyb3NzaGFpci1sYWJlbC1iYWNrZ3JvdW5kLWNvbG9yOiAjZmZmOy0tYWctY2hhcnRzLWNyb3NzaGFpci1sYWJlbC10ZXh0LWNvbG9yOiAjNDY0NjQ2Oy0tYWctY2hhcnRzLXNwYWNpbmc6IDRweDstLWFnLWNoYXJ0cy1ib3JkZXItcmFkaXVzOiA0cHg7LS1hZy1jaGFydHMtc2hhZG93OiAwIDJweCA4cHggMCBjb2xvci1taXgoaW4gc3JnYiwgYmxhY2sgOCUsIHRyYW5zcGFyZW50KTstLWFnLWNoYXJ0cy1mb2N1cy1zaGFkb3c6IDAgMCAwIDNweCB2YXIoLS1hZy1jaGFydHMtYWNjZW50LWNvbG9yKTstLWFnLWNoYXJ0cy1mb2N1cy1jb2xvcjogY29sb3ItbWl4KGluIHNyZ2IsIHZhcigtLWFnLWNoYXJ0cy1iYWNrZ3JvdW5kLWNvbG9yKSwgdmFyKC0tYWctY2hhcnRzLWFjY2VudC1jb2xvcikgMTIlKTstLWFnLWNoYXJ0cy1pbnB1dC1ib3JkZXItY29sb3I6IHZhcigtLWFnLWNoYXJ0cy1ib3JkZXItY29sb3IpOy0tYWctY2hhcnRzLWlucHV0LWJvcmRlci1yYWRpdXM6IHZhcigtLWFnLWNoYXJ0cy1ib3JkZXItcmFkaXVzKTstLWFnLWNoYXJ0cy1pbnB1dC1mb2N1cy1ib3JkZXItY29sb3I6IHZhcigtLWFnLWNoYXJ0cy1hY2NlbnQtY29sb3IpOy0tYWctY2hhcnRzLWlucHV0LWZvY3VzLXRleHQtY29sb3I6IHZhcigtLWFnLWNoYXJ0cy1hY2NlbnQtY29sb3IpOy0tYWctY2hhcnRzLWlucHV0LWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6IGNvbG9yLW1peCggaW4gc3JnYiwgdmFyKC0tYWctY2hhcnRzLWNocm9tZS1iYWNrZ3JvdW5kLWNvbG9yKSwgdmFyKC0tYWctY2hhcnRzLWZvcmVncm91bmQtY29sb3IpIDYlICk7LS1hZy1jaGFydHMtaW5wdXQtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtYm9yZGVyLWNvbG9yKTstLWFnLWNoYXJ0cy1pbnB1dC1kaXNhYmxlZC10ZXh0LWNvbG9yOiBjb2xvci1taXgoIGluIHNyZ2IsIHZhcigtLWFnLWNoYXJ0cy1jaHJvbWUtYmFja2dyb3VuZC1jb2xvciksIHZhcigtLWFnLWNoYXJ0cy1pbnB1dC10ZXh0LWNvbG9yKSA1MCUgKTstLWFnLWNoYXJ0cy1pbnB1dC1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOiBjb2xvci1taXgoIGluIHNyZ2IsIHZhcigtLWFnLWNoYXJ0cy1pbnB1dC1iYWNrZ3JvdW5kLWNvbG9yKSwgdmFyKC0tYWctY2hhcnRzLWlucHV0LXRleHQtY29sb3IpIDYwJSApOy0tYWctY2hhcnRzLWJ1dHRvbi1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtYmFja2dyb3VuZC1jb2xvcik7LS1hZy1jaGFydHMtYnV0dG9uLWJvcmRlci1jb2xvcjogdmFyKC0tYWctY2hhcnRzLWJvcmRlci1jb2xvcik7LS1hZy1jaGFydHMtYnV0dG9uLWJvcmRlci1yYWRpdXM6IHZhcigtLWFnLWNoYXJ0cy1ib3JkZXItcmFkaXVzKTstLWFnLWNoYXJ0cy1idXR0b24tdGV4dC1jb2xvcjogdmFyKC0tYWctY2hhcnRzLXRleHQtY29sb3IpOy0tYWctY2hhcnRzLWJ1dHRvbi1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOiBjb2xvci1taXgoIGluIHNyZ2IsIHZhcigtLWFnLWNoYXJ0cy1idXR0b24tYmFja2dyb3VuZC1jb2xvciksIHZhcigtLWFnLWNoYXJ0cy1hY2NlbnQtY29sb3IpIDEyJSApOy0tYWctY2hhcnRzLWJ1dHRvbi1mb2N1cy1ib3JkZXItY29sb3I6IHZhcigtLWFnLWNoYXJ0cy1hY2NlbnQtY29sb3IpOy0tYWctY2hhcnRzLWJ1dHRvbi1mb2N1cy10ZXh0LWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtYWNjZW50LWNvbG9yKTstLWFnLWNoYXJ0cy1idXR0b24tZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjogY29sb3ItbWl4KCBpbiBzcmdiLCB2YXIoLS1hZy1jaGFydHMtY2hyb21lLWJhY2tncm91bmQtY29sb3IpLCB2YXIoLS1hZy1jaGFydHMtZm9yZWdyb3VuZC1jb2xvcikgNiUgKTstLWFnLWNoYXJ0cy1idXR0b24tZGlzYWJsZWQtYm9yZGVyLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtYm9yZGVyLWNvbG9yKTstLWFnLWNoYXJ0cy1idXR0b24tZGlzYWJsZWQtdGV4dC1jb2xvcjogY29sb3ItbWl4KCBpbiBzcmdiLCB2YXIoLS1hZy1jaGFydHMtY2hyb21lLWJhY2tncm91bmQtY29sb3IpLCB2YXIoLS1hZy1jaGFydHMtY2hyb21lLXRleHQtY29sb3IpIDUwJSApOy0tYWctY2hhcnRzLWNoZWNrYm94LWJhY2tncm91bmQtY29sb3I6IGNvbG9yLW1peCggaW4gc3JnYiwgdmFyKC0tYWctY2hhcnRzLWJhY2tncm91bmQtY29sb3IpLCB2YXIoLS1hZy1jaGFydHMtZm9yZWdyb3VuZC1jb2xvcikgMzUlICk7LS1hZy1jaGFydHMtY2hlY2tib3gtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtYWNjZW50LWNvbG9yKTstLWFnLWNoYXJ0cy1jaHJvbWUtZm9udC1zaXplLXNtYWxsOiB2YXIoLS1hZy1jaGFydHMtY2hyb21lLWZvbnQtc2l6ZSk7LS1hZy1jaGFydHMtY2hyb21lLWZvbnQtc2l6ZS1tZWRpdW06IGNhbGModmFyKC0tYWctY2hhcnRzLWNocm9tZS1mb250LXNpemUpICogKDEzIC8gMTIpKTstLWFnLWNoYXJ0cy1jaHJvbWUtZm9udC1zaXplLWxhcmdlOiBjYWxjKHZhcigtLWFnLWNoYXJ0cy1jaHJvbWUtZm9udC1zaXplKSAqICgxNCAvIDEyKSk7LS1hZy1jaGFydHMtYm9yZGVyOiBzb2xpZCAxcHggdmFyKC0tYWctY2hhcnRzLWJvcmRlci1jb2xvcik7LS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyOiBzb2xpZCAxcHggdmFyKC0tYWctY2hhcnRzLWFjY2VudC1jb2xvcik7LS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLXNoYWRvdzogMCAwIDAgM3B4IGNvbG9yLW1peChpbiBzcmdiLCB0cmFuc3BhcmVudCwgdmFyKC0tYWctY2hhcnRzLWFjY2VudC1jb2xvcikgMjAlKTstLWFnLWNoYXJ0cy1sYXllci1tZW51OiA2Oy0tYWctY2hhcnRzLWxheWVyLXVpLW92ZXJsYXk6IDU7LS1hZy1jaGFydHMtbGF5ZXItdG9vbHRpcDogNDstLWFnLWNoYXJ0cy1sYXllci10b29sYmFyOiAzOy0tYWctY2hhcnRzLWxheWVyLWNyb3NzaGFpcjogMjstLWFnLWNoYXJ0cy1sYXllci1hbm5vdGF0aW9uczogMX0uYWctY2hhcnRzLXRoZW1lLWRlZmF1bHQtZGFya3stLWFnLWNoYXJ0cy1zaGFkb3c6IDAgMnB4IDEycHggMCBjb2xvci1taXgoaW4gc3JnYiwgYmxhY2sgMzMuMyUsIHRyYW5zcGFyZW50KTstLWFnLWNoYXJ0cy1mb2N1cy1jb2xvcjogY29sb3ItbWl4KGluIHNyZ2IsIHZhcigtLWFnLWNoYXJ0cy1iYWNrZ3JvdW5kLWNvbG9yKSwgdmFyKC0tYWctY2hhcnRzLWFjY2VudC1jb2xvcikgMjIlKX0uYWctY2hhcnQtY2FudmFzLXdyYXBwZXIgLmFnLWNoYXJ0cy10aGVtZS1kZWZhdWx0ey0tYWctY2hhcnRzLWJvcmRlci1yYWRpdXM6IHZhcigtLWFnLWJvcmRlci1yYWRpdXMsIDRweCk7LS1hZy1jaGFydHMtYm9yZGVyOiB2YXIoLS1hZy1ib3JkZXJzLWNyaXRpY2FsLCBzb2xpZCAxcHgpIHZhcigtLWFnLWNoYXJ0cy1ib3JkZXItY29sb3IpOy0tYWctY2hhcnRzLWZvY3VzLXNoYWRvdzogdmFyKC0tYWctZm9jdXMtc2hhZG93LCAwIDAgMCAzcHggdmFyKC0tYWctY2hhcnRzLWFjY2VudC1jb2xvcikpOy0tYWctY2hhcnRzLWZvY3VzLWJvcmRlci1zaGFkb3c6IHZhciggLS1hZy1mb2N1cy1zaGFkb3csIDAgMCAwIDNweCBjb2xvci1taXgoaW4gc3JnYiwgdHJhbnNwYXJlbnQsIHZhcigtLWFnLWNoYXJ0cy1hY2NlbnQtY29sb3IpIDIwJSkgKX0uYWctY2hhcnRzLWljb257ZGlzcGxheTpibG9jazt3aWR0aDoyMHB4O2hlaWdodDoyMHB4O3NwZWFrOm5vbmU7c3BlYWs6bmV2ZXI7bWFzazp2YXIoLS1pY29uKSBjZW50ZXIgLyBjb250YWluIG5vLXJlcGVhdDtiYWNrZ3JvdW5kLWNvbG9yOmN1cnJlbnRDb2xvcjt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjI1cyBlYXNlLWluLW91dH0uYWctY2hhcnRzLWljb24tYWxpZ24tY2VudGVyey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjR0YwYUNCbWFXeHNQU0lqTURBd0lpQmtQU0pOTnlBeE1HZzJkakZJTjNwTk5DQTNhREV5ZGpGSU5IcHRNU0EyYURFd2RqRklOWG9pTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tYWxpZ24tbGVmdHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4Y0dGMGFDQm1hV3hzUFNJak1EQXdJaUJrUFNKTk5DQXhNR2cyZGpGSU5IcHRNQzB6YURFeWRqRklOSHB0TUNBMmFERXdkakZJTkhvaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWFsaWduLXJpZ2h0ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjR0YwYUNCbWFXeHNQU0lqTURBd0lpQmtQU0pOTVRBZ01UQm9Obll4YUMwMmVrMDBJRGRvTVRKMk1VZzBlbTB5SURab01UQjJNVWcyZWlJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLWFycm93LWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNHRjBhQ0JtYVd4c0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJZ1pEMGlUVEUxTGpJNU15QTBMalZJTVRJdU5YWXRNVWd4TjNZMGFDMHhWalV1TWpBM2JDMDVMalkwTmlBNUxqWTBOeTB1TnpBNExTNDNNRGg2SWlCbWFXeHNQU0lqTURBd0lpOCtQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswM0lERTJZVEl1TlNBeUxqVWdNQ0F4SURFdE5TQXdJREl1TlNBeUxqVWdNQ0F3SURFZ05TQXdiUzB5TGpVZ01TNDFZVEV1TlNBeExqVWdNQ0F4SURBZ01DMHpJREV1TlNBeExqVWdNQ0F3SURBZ01DQXpJaUJtYVd4c1BTSWpNREF3SWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tYXJyb3ctZG93bi1kcmF3aW5ney0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNEtQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswMklEaE1NUzQxSURoTU1UQWdNVGhNTVRndU5TQTRUREUwSURoTU1UUWdNMHcySUROTU5pQTRXazAzSURSTU55QTVTRE11TmpZeU5EUk1NVEFnTVRZdU5EVTJUREUyTGpNek56WWdPVXd4TXlBNVRERXpJRFJNTnlBMFdpSWdabWxzYkQwaVlteGhZMnNpTHo0S1BDOXpkbWMrQ2c9PSl9LmFnLWNoYXJ0cy1pY29uLWFycm93LXVwLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0S1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazB4TkNBeE1rZ3hPQzQxVERFd0lESk1NUzQxSURFeVNEWk1OaTR3TURBd01pQXhOMGd4TkZZeE1scE5NVE1nTVRaV01URklNVFl1TXpNM05rd3hNQ0F6TGpVME5EQTFURE11TmpZeU5EUWdNVEZJTjB3M0xqQXdNREF5SURFMlNERXpXaUlnWm1sc2JEMGlZbXhoWTJzaUx6NEtQQzl6ZG1jK0NnPT0pfS5hZy1jaGFydHMtaWNvbi1jYWxsb3V0LWFubm90YXRpb257LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NeUEwTGpWQk1TNDFJREV1TlNBd0lEQWdNU0EwTGpVZ00yZ3hNVUV4TGpVZ01TNDFJREFnTUNBeElERTNJRFF1TlhZNFlURXVOU0F4TGpVZ01DQXdJREV0TVM0MUlERXVOV2d0TkM0MU1UUmhNallnTWpZZ01DQXdJREF0TWk0d01UY2dNUzQxTkd3dExqTXhOQzR5Tm1NdExqVTFMalExTnkweExqRXhOUzQ1TWpZdE1TNDNOaUF4TGpRdExqWTJPUzQwT1RFdE1TNDFOakl0TGpBeE1pMHhMalUyTWkwdU9GWXhORWcwTGpWQk1TNDFJREV1TlNBd0lEQWdNU0F6SURFeUxqVjZUVFF1TlNBMFlTNDFMalVnTUNBd0lEQXRMalV1TlhZNFlTNDFMalVnTUNBd0lEQWdMalV1TldneExqZ3pNM1l6TGpNM01tRXpOaUF6TmlBd0lEQWdNQ0F4TGpZM09DMHhMak16T0d3dU16SXRMakkyTldFeU5pQXlOaUF3SURBZ01TQXlMakl5TlMweExqWTROV3d1TVRJMkxTNHdPRFJJTVRVdU5XRXVOUzQxSURBZ01DQXdJQzQxTFM0MWRpMDRZUzQxTGpVZ01DQXdJREF0TGpVdExqVjZJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tY2FuZGxlc3RpY2stc2VyaWVzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk55QXhkak5vTW5ZeE1rZzNkak5JTm5ZdE0wZzBWalJvTWxZeGVrMDFJRFZvTTNZeE1FZzFlazB4TVNBeE5GWTJhREpXTXk0eU5XZ3hWalpvTW5ZNGFDMHlkakl1TnpWb0xURldNVFI2YlRFdE4yZ3pkalpvTFRONklpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1jbG9zZXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4Y0dGMGFDQmtQU0p0TlNBMUlERXdJREV3VFRVZ01UVWdNVFVnTlNJZ2MzUnliMnRsUFNJak1EQXdJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1jb21tZW50LWFubm90YXRpb257LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OeTQxTVRNZ015NDVPVFZoTmk0MUlEWXVOU0F3SURBZ01TQTJMakE1T0NBeE1TNDBNV010TGpVNE9DNHpPVE10TVM0eU1UY3VOVE0yTFRFdU9ESTVMalU0TldFeE15QXhNeUF3SURBZ01TMHhMakkzTGpBeE4wRXlOeUF5TnlBd0lEQWdNQ0F4TUNBeE5rZzBMalZoTGpVdU5TQXdJREFnTVMwdU5TMHVOVll4TUhFd0xTNHlORGN0TGpBd055MHVOVEV6WXkwdU1EQTRMUzQwTVRZdExqQXhOaTB1T0RVM0xqQXhOeTB4TGpJMk9TNHdOUzB1TmpFeUxqRTVNaTB4TGpJMExqVTROUzB4TGpnellUWXVOU0EyTGpVZ01DQXdJREVnTWk0NU1UZ3RNaTR6T1ROdE15NDFOaTQyTVdFMUxqVWdOUzQxSURBZ01DQXdMVFV1TmpRMklESXVNelJqTFM0eU5qWXVNemszTFM0ek56a3VPRFF5TFM0ME1pQXhMak0xTkMwdU1ETXVNell0TGpBeU1pNDNNVGd0TGpBeE5TQXhMakV3T0ZFMUlEa3VOamc1SURVZ01UQjJOV2cxY1M0ek1URXVNREF4TGpVNU15NHdNRGhqTGpNNUxqQXdOeTQzTkRjdU1ERTFJREV1TVRBNExTNHdNVFV1TlRFeUxTNHdOREV1T1RVM0xTNHhOVFFnTVM0ek5UVXRMalF5WVRVdU5TQTFMalVnTUNBd0lEQXRNUzQ1T0RNdE9TNDVOamNpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLWNyb3NzaGFpci1hZGQtbGluZXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdaRDBpVFRFd0lEVXVOV0V1TlM0MUlEQWdNQ0F4SUM0MUxqVjJNeTQxYURNdU9EYzFZUzQxTGpVZ01DQXdJREVnTUNBeFNERXdMalYyTkM0eU5XRXVOUzQxSURBZ01TQXhMVEVnTUZZeE1DNDFTRFV1TmpJMVlTNDFMalVnTUNBeElERWdNQzB4U0RrdU5WWTJZUzQxTGpVZ01DQXdJREVnTGpVdExqVWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1kYXRlLXJhbmdlLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNHRjBhQ0JrUFNKTk1pQXlhREYyTVRaSU1ucHRNVFVnTUdneGRqRTJhQzB4ZWlJZ1ptbHNiRDBpSXpFNE1VUXhSaUl2UGp4d1lYUm9JR1E5SWsweE15NHhOVGNnTVRGSU5YWXRNV2czTGpjNU0wd3hNU0E0TGpJd04yd3VOekEzTFM0M01EY2dNeTR4T0RJZ015NHhPREl0TXk0eE9ESWdNeTR4T0RJdExqY3dOeTB1TnpBM2VpSWdabWxzYkQwaUl6QXdNQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tZGF0ZS1wcmljZS1yYW5nZS1kcmF3aW5ney0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjR0YwYUNCa1BTSk5NeUF5U0RKMk1UWm9NWHB0TXk0MU1EY2dOQzQ0T1V3NExqVWdOQzQ0T1RWV01UQklOWFl4YURNdU5YWTNhREYyTFRkb05TNHdPRGhzTFRFdU9UVTNJREV1T1RVM0xqY3dOeTQzTURjZ015NHhPREl0TXk0eE9ESk1NVE11TXpNNElEY3VNMnd0TGpjd055NDNNRGRNTVRRdU5qSTBJREV3U0RrdU5WWTBMamt6TW13eExqazFOeUF4TGprMU55NDNNRGN0TGpjd04wdzRMams0TWlBeklEVXVPQ0EyTGpFNE1ub2lJR1pwYkd3OUlpTXhPREZFTVVZaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWRlbGV0ZXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWkQwaVRUZ3VORGsySURndU9UazJRUzQxTGpVZ01DQXdJREVnT1NBNUxqUTVNblkwWVM0MUxqVWdNQ0F4SURFdE1TQXVNREE0ZGkwMFlTNDFMalVnTUNBd0lERWdMalE1TmkwdU5UQTBUVEV5SURrdU5XRXVOUzQxSURBZ01DQXdMVEVnTUhZMFlTNDFMalVnTUNBd0lEQWdNU0F3ZWlJdlBqeHdZWFJvSUdacGJHdzlJaU14TXpFM01qSWlJR1pwYkd3dGNuVnNaVDBpWlhabGJtOWtaQ0lnWkQwaVRUWWdOVll6TGpWQk1pNDFJREl1TlNBd0lEQWdNU0E0TGpVZ01XZ3pRVEl1TlNBeUxqVWdNQ0F3SURFZ01UUWdNeTQxVmpWb01pNDRNek5oTGpVdU5TQXdJREFnTVNBd0lERklNVFYyTVRBdU1qVmpNQ0F1TkRFMUxTNHdOall1T0RZekxTNHpJREV1TWpJeExTNHlOVGN1TXprMExTNDJOekl1TmpFeUxURXVNaTQyTVRKb0xUZGpMUzQxTWpnZ01DMHVPVFF6TFM0eU1UZ3RNUzR5TFM0Mk1USXRMakl6TkMwdU16VTRMUzR6TFM0NE1EWXRMak10TVM0eU1qRldOa2d6TGpNek0yRXVOUzQxSURBZ01DQXhJREF0TVhwdE1TMHhMalZCTVM0MUlERXVOU0F3SURBZ01TQTRMalVnTW1nelFURXVOU0F4TGpVZ01DQXdJREVnTVRNZ015NDFWalZJTjNwTk5pQXhOaTR5TlZZMmFEaDJNVEF1TWpWak1DQXVNek0xTFM0d05Ua3VOVFUwTFM0eE16Z3VOamMxTFM0d05UVXVNRGcxTFM0eE5DNHhOVGd0TGpNMk1pNHhOVGhvTFRkakxTNHlNaklnTUMwdU16QTNMUzR3TnpNdExqTTJNaTB1TVRVNExTNHdPQzB1TVRJeExTNHhNemd0TGpNMExTNHhNemd0TGpZM05TSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1kaXNqb2ludC1jaGFubmVsLC5hZy1jaGFydHMtaWNvbi1kaXNqb2ludC1jaGFubmVsLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTVRrdU1ESTRJREUzTGpRMllUSXVNalVnTWk0eU5TQXdJREFnTUMwMExqQTVNaTB4TGpnMWJDMDVMalV4TVMweUxqTTNPR0V5TGpJMUlESXVNalVnTUNBeElEQXRMakl5TlM0NU56UnNPUzQwTnpVZ01pNHpOamxoTWk0eU5URWdNaTR5TlRFZ01DQXdJREFnTkM0ek5UTXVPRGcyYlMweExqWTJNaTB4TGprMk5XRXhMakkxSURFdU1qVWdNQ0F4SURFdExqZzROU0F5TGpNek9DQXhMakkxSURFdU1qVWdNQ0F3SURFZ0xqZzROUzB5TGpNek9FMDBMak0wTXlBeE15NDJOamxoTVM0eU5TQXhMakkxSURBZ01TQXdMVEl1TXpNNExTNDRPRFVnTVM0eU5TQXhMakkxSURBZ01DQXdJREl1TXpNNExqZzROVTB6TGprM0lEZ3VOelk1WVRJdU1qVWdNaTR5TlNBd0lEQWdNQ0F4TGpRMU5TMHlMakV4YkRrdU5URXhMVEl1TXpjNFlUSXVNalVnTWk0eU5TQXdJREVnTUMwdU1qWXRMamsyTlV3MUxqSWdOUzQyT0RWaE1pNHlOU0F5TGpJMUlEQWdNU0F3TFRFdU1qTWdNeTR3T0RSdExqTTNNeTB5TGpVME4yRXhMakkxSURFdU1qVWdNQ0F4SURFdE1pNHpNemd1T0RnMUlERXVNalVnTVM0eU5TQXdJREFnTVNBeUxqTXpPQzB1T0RnMWJURXpMamMxTFRNdU5ETTRZVEV1TWpVZ01TNHlOU0F3SURFZ01TMHlMak16T0M0NE9EVWdNUzR5TlNBeExqSTFJREFnTUNBeElESXVNek00TFM0NE9EVWlJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tZHJhZy1oYW5kbGV7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OFkybHlZMnhsSUdONFBTSTFMamMxSWlCamVUMGlOeTQzTlNJZ2NqMGlMamMxSWlCbWFXeHNQU0lqTURBd0lpQm1hV3hzTFc5d1lXTnBkSGs5SWk0MUlpOCtQR05wY21Oc1pTQmplRDBpT1M0M05TSWdZM2s5SWpjdU56VWlJSEk5SWk0M05TSWdabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXZjR0ZqYVhSNVBTSXVOU0l2UGp4amFYSmpiR1VnWTNnOUlqRXpMamMxSWlCamVUMGlOeTQzTlNJZ2NqMGlMamMxSWlCbWFXeHNQU0lqTURBd0lpQm1hV3hzTFc5d1lXTnBkSGs5SWk0MUlpOCtQR05wY21Oc1pTQmplRDBpTVRNdU56VWlJR041UFNJeE1TNDNOU0lnY2owaUxqYzFJaUJtYVd4c1BTSWpNREF3SWlCbWFXeHNMVzl3WVdOcGRIazlJaTQxSWk4K1BHTnBjbU5zWlNCamVEMGlPUzQzTlNJZ1kzazlJakV4TGpjMUlpQnlQU0l1TnpVaUlHWnBiR3c5SWlNd01EQWlJR1pwYkd3dGIzQmhZMmwwZVQwaUxqVWlMejQ4WTJseVkyeGxJR040UFNJMUxqYzFJaUJqZVQwaU1URXVOelVpSUhJOUlpNDNOU0lnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF2Y0dGamFYUjVQU0l1TlNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLWZpYm9uYWNjaS1yZXRyYWNlbWVudC1kcmF3aW5ney0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjR0YwYUNCbWFXeHNQU0lqTURBd0lpQmtQU0pOTWlBMWFERXlkakZJTW5vaUx6NDhZMmx5WTJ4bElHTjRQU0l4TlM0M05TSWdZM2s5SWpVdU5TSWdjajBpTVM0M05TSWdjM1J5YjJ0bFBTSWpNREF3SWk4K1BHTnBjbU5zWlNCamVEMGlOQzR5TlNJZ1kzazlJakUwTGpVaUlISTlJakV1TnpVaUlITjBjbTlyWlQwaUl6QXdNQ0l2UGp4d1lYUm9JR1pwYkd3OUlpTXdNREFpSUdROUlrMHhPQ0F4TlVnMmRpMHhhREV5ZW0wd0xUUXVOVWd5ZGkweGFERTJlaUl2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tZmlib25hY2NpLXJldHJhY2VtZW50LXRyZW5kLWJhc2VkLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNHRjBhQ0JtYVd4c1BTSWpNREF3SWlCa1BTSnROQzQ1T1RZZ01USXVOamMwSURNdU1qa3hMVFV1TnpRekxqZzJPQzQwT1RjdE15NHlPVEVnTlM0M05ETjZJaTgrUEdOcGNtTnNaU0JqZUQwaU9TNDNOU0lnWTNrOUlqVXVOU0lnY2owaU1TNDNOU0lnYzNSeWIydGxQU0lqTURBd0lpOCtQR05wY21Oc1pTQmplRDBpTkM0ek5URWlJR041UFNJeE5DNDFJaUJ5UFNJeExqYzFJaUJ6ZEhKdmEyVTlJaU13TURBaUx6NDhjR0YwYUNCbWFXeHNQU0lqTURBd0lpQmtQU0pOTVRnZ05tZ3ROMVkxYURkNmJUQWdOQzQxYUMwM2RpMHhhRGQ2YlRBZ05DNDFTRFoyTFRGb01USjZJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1maWxsLWNvbG9yey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0p0T0M0d056RWdOQzR3TmkwdU9USTBMUzQ1TWpRdU56QTNMUzQzTURjZ055NHlPRGdnTnk0eU9EZ3ROQzQ1TlNBMExqazFZVE11TlNBekxqVWdNQ0F3SURFdE5DNDVOU0F3YkMweExqUXhOQzB4TGpReE5HRXpMalVnTXk0MUlEQWdNQ0F4SURBdE5DNDVOWHB0TGpjd055NDNNRGhNTkM0MU16WWdPUzR3TVdFeUxqVWdNaTQxSURBZ01DQXdJREFnTXk0MU16Wk1OUzQ1TlNBeE15NDVObUV5TGpVZ01pNDFJREFnTUNBd0lETXVOVE0xSURCc05DNHlORE10TkM0eU5ETjZiVFl1T1NBM0xqSXdNaTB1TXpRMUxqTTJNeTB1TXpRMExTNHpOak5oTGpVdU5TQXdJREFnTVNBdU5qZzRJREJ0TFM0ek5EVWdNUzR3T0dFNElEZ2dNQ0F3SURBdExqSTRMak15TXlBMExqTWdOQzR6SURBZ01DQXdMUzQwTURrdU5UZ3lZeTB1TVRFekxqSXdNUzB1TVRRMExqTXlOaTB1TVRRMExqTTNPR0V1T0RNekxqZ3pNeUF3SURBZ01DQXhMalkyTnlBd1l6QXRMakExTWkwdU1ETXhMUzR4TnpjdExqRTBOQzB1TXpjNFlUUXVNeUEwTGpNZ01DQXdJREF0TGpReExTNDFPRElnT0NBNElEQWdNQ0F3TFM0eU9DMHVNekl5YlMwdU16UTBMVEV1TURndU16UTBMak0yTXk0ek5EUXRMak0yTXk0d01ESXVNREF5TGpBd05DNHdNRFF1TURFekxqQXhNbUUySURZZ01DQXdJREVnTGpJd05pNHlNRGhqTGpFek1TNHhNell1TXpBNExqTXlOeTQwT0RVdU5UUTFMakUzTmk0eU1UVXVNell6TGpRMk55NDFNRGN1TnpJMExqRXpOeTR5TkRNdU1qY3pMalUxTXk0eU56TXVPRFk0WVRFdU9ETXpJREV1T0RNeklEQWdNU0F4TFRNdU5qWTNJREJqTUMwdU16RTFMakV6TmkwdU5qSTFMakkzTXkwdU9EWTRMakUwTkMwdU1qVTNMak16TFM0MU1Ea3VOVEEzTFM0M01qUmhPU0E1SURBZ01DQXhJQzQyTkRVdExqY3dPR3d1TURRMkxTNHdORFV1TURFekxTNHdNVEl1TURBMExTNHdNRFI2SWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWhvbGxvdy1jYW5kbGVzdGljay1zZXJpZXN7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF2Y0dGamFYUjVQU0l1TVRVaUlHUTlJazAxSURWb00zWXhNRWcxZWlJdlBqeHdZWFJvSUdacGJHdzlJaU14TXpFM01qSWlJR1pwYkd3dGNuVnNaVDBpWlhabGJtOWtaQ0lnWkQwaVRUY2dNWFl6YURKMk1USklOM1l6U0RaMkxUTklORlkwYURKV01YcE5OU0ExYUROMk1UQklOWHB0TnlBeWFETjJObWd0TTNwdExURWdOMVkyYURKV015NHlOV2d4Vmpab01uWTRhQzB5ZGpJdU56Vm9MVEZXTVRSNklpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1ob3Jpem9udGFsLWxpbmUsLmFnLWNoYXJ0cy1pY29uLWhvcml6b250YWwtbGluZS1kcmF3aW5ney0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTkxqVWdPUzQxYURjdU16QTJZVEl1TWpVZ01pNHlOU0F3SURBZ01TQTBMak00T0NBd1NERTVMalYyTVdndE55NHpNRFpoTWk0eU5TQXlMakkxSURBZ01DQXhMVFF1TXpnNElEQklMalY2YlRrdU5TQXhMamMxWVRFdU1qVWdNUzR5TlNBd0lERWdNQ0F3TFRJdU5TQXhMakkxSURFdU1qVWdNQ0F3SURBZ01DQXlMalVpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLWxpbmUtY29sb3J7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NVFF1TWpReUlESXVOekl5WXkwdU5qRXlJREF0TVM0eUxqSTBNeTB4TGpZek1pNDJOelZzTFRFdU16UXpJREV1TXpRMFlTNDFMalVnTUNBd0lEQXRMakV4TWk0eE1USk1OQzR3TlNBeE1TNDVOVGxqTFM0eU1EY3VNakEzTFM0ek5pNDBOaTB1TkRRMkxqYzBkaTR3TURGc0xTNDJPU0F5TGpjMk4zWXVNREF5WVM0NE1pNDRNaUF3SURBZ01DQXhMakF5TWlBeExqQXlNV2d1TURBeWJESXVOak0wTFM0NE1qSmpMakk0TFM0d09EVXVOVE0wTFM0eU16Y3VOelF0TGpRME0ydzNMakV3TnkwM0xqRXdPR0V1TlM0MUlEQWdNQ0F3SUM0eE1USXRMakV4TW13eExqTTBNeTB4TGpNME0yRXlMak13T0NBeUxqTXdPQ0F3SURBZ01DMHhMall6TWkwekxqazBUVEUwTGpFeU1pQTNiREV1TURRMExURXVNRFExWVRFdU16QTRJREV1TXpBNElEQWdNU0F3TFRFdU9EUTVMVEV1T0RWTU1USXVNamN4SURVdU1UVjZiUzB5TGpVMU9DMHhMakUwTWkwMkxqZ3dOeUEyTGpnd09XRXVPQzQ0SURBZ01DQXdMUzR4T1RZdU16STFiQzB1TnpVZ01pNDBOamdnTWk0ME55MHVOelE1WVM0NExqZ2dNQ0F3SURBZ0xqTXlOUzB1TVRrMGJEWXVPREE0TFRZdU9ERjZJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tbGluZS1zZXJpZXN7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0p0TVRjdU16WXlJRFF1T0RjekxUUXVOVGswSURZdU5qVTBMVFF1T0RVdE15NHpNVGN0TkM0eU5URWdOaTQ1TnpjdExqZzFOQzB1TlRKTU55NDJNVElnTmk0M09XdzBMamc1T1NBekxqTTFJRFF1TURJNExUVXVPRE0yZWlJZ1kyeHBjQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLWxpbmUtc3R5bGUtZGFzaGVkey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjR0YwYUNCbWFXeHNQU0lqTURBd0lpQmtQU0pOTWlBNWFEUjJNVWd5ZW0weE1pQXdhRFIyTVdndE5IcE5PQ0E1YURSMk1VZzRlaUl2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tbGluZS1zdHlsZS1kb3R0ZWR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OFkybHlZMnhsSUdONFBTSXlMalVpSUdONVBTSTVMalVpSUhJOUlpNDFJaUJtYVd4c1BTSWpNREF3SWk4K1BHTnBjbU5zWlNCamVEMGlOQzQxSWlCamVUMGlPUzQxSWlCeVBTSXVOU0lnWm1sc2JEMGlJekF3TUNJdlBqeGphWEpqYkdVZ1kzZzlJall1TlNJZ1kzazlJamt1TlNJZ2NqMGlMalVpSUdacGJHdzlJaU13TURBaUx6NDhZMmx5WTJ4bElHTjRQU0k0TGpVaUlHTjVQU0k1TGpVaUlISTlJaTQxSWlCbWFXeHNQU0lqTURBd0lpOCtQR05wY21Oc1pTQmplRDBpTVRBdU5TSWdZM2s5SWprdU5TSWdjajBpTGpVaUlHWnBiR3c5SWlNd01EQWlMejQ4WTJseVkyeGxJR040UFNJeE1pNDFJaUJqZVQwaU9TNDFJaUJ5UFNJdU5TSWdabWxzYkQwaUl6QXdNQ0l2UGp4amFYSmpiR1VnWTNnOUlqRTBMalVpSUdONVBTSTVMalVpSUhJOUlpNDFJaUJtYVd4c1BTSWpNREF3SWk4K1BHTnBjbU5zWlNCamVEMGlNVFl1TlNJZ1kzazlJamt1TlNJZ2NqMGlMalVpSUdacGJHdzlJaU13TURBaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWxpbmUtc3R5bGUtc29saWR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNHRjBhQ0JtYVd4c1BTSWpNREF3SWlCa1BTSk5NaUE1YURFMmRqRklNbm9pTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tbGluZS13aXRoLW1hcmtlcnMtc2VyaWVzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKdE1UZ3VNVGs0SURRdU9EZzRMVE11TlRVMklEUXVPVEU0WVRJdU1qVWdNaTR5TlNBd0lERWdNUzB6TGpnMk5pNDNOV3d0TVM0ME16SXRMamxoTWk0eU5DQXlMakkwSURBZ01DQXhMVEl1TURBNUxqUXpOV3d0TXk0NE1qZ2dOaTQwTWpndExqZzJMUzQxTVRKTU5pNDBOU0E1TGpZeU0yRXlMakkxSURJdU1qVWdNQ0F4SURFZ015NDFNUzB1TnpZeGJERXVNekk1TGpnek5XRXlMakkwSURJdU1qUWdNQ0F3SURFZ01pNDFOVGN0TGpRNU4yd3pMalUwTWkwMExqZzVPSHB0TFRRdU9UWWdOUzR4TlROaE1TNHlOU0F4TGpJMUlEQWdNU0F3TFM0Mk5DQXlMalF4T1NBeExqSTFJREV1TWpVZ01DQXdJREFnTGpZMExUSXVOREU1VFRrdU1TQTRMak15TVhFdU1EWTJMUzR4T1RJdU1EWTNMUzQwTURSaE1TNHlOU0F4TGpJMUlEQWdNU0F3TFM0d05qY3VOREEwSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWxvY2ssLmFnLWNoYXJ0cy1pY29uLWxvY2tlZHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk1UQXVNakEzSURNdU56WTBZVEl1T0RrMElESXVPRGswSURBZ01DQXdMVEl1T0RrMUlESXVPRGswVmpsb05TNDNPRGxXTmk0Mk5UaGhNaTQ0T1RRZ01pNDRPVFFnTUNBd0lEQXRNaTQ0T1RVdE1pNDRPVFJOTVRRdU1TQTVWall1TmpVNFlUTXVPRGswSURNdU9EazBJREFnTVNBd0xUY3VOemc1SURCMk1pNHpORGxCTWk0MUlESXVOU0F3SURBZ01DQTBJREV4TGpWMk0wRXlMalVnTWk0MUlEQWdNQ0F3SURZdU5TQXhOMmc0WVRJdU5TQXlMalVnTUNBd0lEQWdNaTQxTFRJdU5YWXRNMEV5TGpVZ01pNDFJREFnTUNBd0lERTBMalVnT1hwTk5pNDFJREV3UVRFdU5TQXhMalVnTUNBd0lEQWdOU0F4TVM0MWRqTkJNUzQxSURFdU5TQXdJREFnTUNBMkxqVWdNVFpvT0dFeExqVWdNUzQxSURBZ01DQXdJREV1TlMweExqVjJMVE5oTVM0MUlERXVOU0F3SURBZ01DMHhMalV0TVM0MWVpSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1tZWFzdXJlci1kcmF3aW5ney0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjR0YwYUNCbWFXeHNMWEoxYkdVOUltVjJaVzV2WkdRaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSWdaRDBpYlRRdU5EWXhJREV5TGpjeElERXVOVE15TFRFdU5UTXhJREV1TkRFMElERXVOREUwTGpjd055MHVOekEzVERZdU55QXhNQzQwTnpKc01TNDFNekl0TVM0MU16TWdNaUF5SUM0M01EY3RMamN3TnkweUxUSWdOaTR3TVMwMkxqQXhJREl1T0RNZ01pNDRNamhNTlM0d05TQXhOeTQzTnpnZ01pNHlNaklnTVRRdU9UVnNNUzQxTXpJdE1TNDFNeklnTVM0ME1UUWdNUzQwTVRRdU56QTNMUzQzTURkNlRTNDRNRGdnTVRRdU9UVnNMamN3TnkwdU56QTNUREUwTGpJME15QXhMalV4Tld3dU56QTNMUzQzTURjdU56QTNMamN3TnlBeUxqZ3lPQ0F5TGpneU9DNDNNRGN1TnpBM0xTNDNNRGN1TnpBM1REVXVOelUzSURFNExqUTROV3d0TGpjd055NDNNRGN0TGpjd055MHVOekEzTFRJdU9ESTRMVEl1T0RJNGVtMHhNUzR3TnpndE5pNDRNelZNTVRBdU5EY2dOaTQzYkM0M01EY3RMamN3TnlBeExqUXhOU0F4TGpReE5IcHRMamd5TkMwekxqWTFOQ0F4SURFZ0xqY3dPQzB1TnpBM0xURXRNWG9pSUdacGJHdzlJaU14T0RGRU1VWWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1ub3RlLWFubm90YXRpb257LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NeUEwTGpWQk1TNDFJREV1TlNBd0lEQWdNU0EwTGpVZ00yZ3hNVUV4TGpVZ01TNDFJREFnTUNBeElERTNJRFF1TlhZNFlURXVOU0F4TGpVZ01DQXdJREV0TVM0MUlERXVOV2d0TXk0eU1Xd3RNUzQwTmprZ01pNDFOMkV4SURFZ01DQXdJREV0TVM0Mk9ESXVNRGcxVERjdU1qUXpJREUwU0RRdU5VRXhMalVnTVM0MUlEQWdNQ0F4SURNZ01USXVOWHBOTkM0MUlEUmhMalV1TlNBd0lEQWdNQzB1TlM0MWRqaGhMalV1TlNBd0lEQWdNQ0F1TlM0MWFETXVNalUzYkRJdU1UazJJRE11TURjMFRERXhMamN4SURFemFETXVOemxoTGpVdU5TQXdJREFnTUNBdU5TMHVOWFl0T0dFdU5TNDFJREFnTUNBd0xTNDFMUzQxZWlJZ1kyeHBjQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpOCtQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk5pNDFJRFl1TlVFdU5TNDFJREFnTUNBeElEY2dObWcyWVM0MUxqVWdNQ0F3SURFZ01DQXhTRGRoTGpVdU5TQXdJREFnTVMwdU5TMHVOVTAyTGpVZ09TNDFRUzQxTGpVZ01DQXdJREVnTnlBNWFEWmhMalV1TlNBd0lEQWdNU0F3SURGSU4yRXVOUzQxSURBZ01DQXhMUzQxTFM0MUlpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1vaGxjLXNlcmllc3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWkQwaVRURXpJREV4YUMwemRpMHhhRE5XTTJneGRqSm9OSFl4YUMwMGRqRXhhQzB4ZWswMklERTNkaTB5YUROMkxURklObFkwU0RWMk1VZ3lkakZvTTNZeE1Yb2lMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1wYW4tZW5key0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1pEMGliVFl1TmpRMklERXpMamd4TXkwdU16VXpMak0xTkM0M01EY3VOekEzTGpNMU5DMHVNelUwZWsweE1TNHhOallnTVRCc0xqTTFOQzR6TlRRdU16VTBMUzR6TlRRdExqTTFOQzB1TXpVMGVrMDNMak0xTlNBMUxqUTRJRGNnTlM0eE1qWnNMUzQzTURjdU56QTNMak0xTXk0ek5UUjZiVEFnT1M0d05DQTBMakUyTmkwMExqRTJOaTB1TnpBM0xTNDNNRGd0TkM0eE5qY2dOQzR4TmpkNmJUUXVNVFkyTFRRdU9EYzBURGN1TXpVMElEVXVORGhzTFM0M01EZ3VOekEzSURRdU1UWTNJRFF1TVRZM2VrMHhNeTR3T0RNZ05YWXhNR2d4VmpWNklpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLXBhbi1sZWZ0ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTVRJdU56a2dOUzQ0TXpNZ09DNDJNalVnTVRCc05DNHhOallnTkM0eE5qY3RMamN3Tnk0M01EZE1OeTR5TVNBeE1HdzBMamczTXkwMExqZzNOSG9pSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXBhbi1yaWdodHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk55NHlNU0F4TkM0eE5qY2dNVEV1TXpjMklERXdJRGN1TWpFZ05TNDRNek5zTGpjd055MHVOekEzVERFeUxqYzVJREV3YkMwMExqZzNNeUEwTGpnM05Ib2lJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tcGFuLXN0YXJ0ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1pEMGlUVFlnTlhZeE1HZ3hWalY2VFRrdU5qSTBJREV3YkRRdU1UWTJMVFF1TVRZM0xTNDNNRGN0TGpjd04wdzRMakl4SURFd2JEUXVPRGMwSURRdU9EYzBMamN3TnkwdU56QTNlaUl2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tcGFyYWxsZWwtY2hhbm5lbCwuYWctY2hhcnRzLWljb24tcGFyYWxsZWwtY2hhbm5lbC1kcmF3aW5ney0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk1UY3VOeklnTlM0ek16RkJNaTR5TlNBeUxqSTFJREFnTVNBd0lERTBMamN3TlNBekxqWnNMVGt1TkRrZ05DNDFOakpoTWk0eU5TQXlMakkxSURBZ01TQXdJQzR5TURrZ01TNHdNV3c1TGpZMk1pMDBMalkwTm1FeUxqSTFJREl1TWpVZ01DQXdJREFnTWk0Mk16UXVPREExYlM0ek56TXRNaTQxTkRkaE1TNHlOU0F4TGpJMUlEQWdNU0F4TFRJdU16TTRMamc0TlNBeExqSTFJREV1TWpVZ01DQXdJREVnTWk0ek16Z3RMamc0TlUwMExqTTBNeUE0TGpZM1lURXVNalVnTVM0eU5TQXdJREVnTVMweUxqTXpPQzQ0T0RVZ01TNHlOU0F4TGpJMUlEQWdNQ0F4SURJdU16TTRMUzQ0T0RWTk5TNHpNRGNnTVRZdU56STRZVEl1TWpVZ01pNHlOU0F3SURFZ01TMHVOVEkxTFM0NE5UaHNPUzQ1TWpNdE5DNDNOMkV5TGpJMUlESXVNalVnTUNBeElERWdMak00TVM0NU1qWjZiUzB1T1RZMExqSTNOR0V4TGpJMUlERXVNalVnTUNBeElERXRNaTR6TXpndU9EZzFJREV1TWpVZ01TNHlOU0F3SURBZ01TQXlMak16T0MwdU9EZzFiVEV6TGpBeU15MDFMakV3Tm1FeExqSTFJREV1TWpVZ01DQXhJREF0TGpnNE5TMHlMak16T1NBeExqSTFJREV1TWpVZ01DQXdJREFnTGpnNE5TQXlMak16T1NJZ1kyeHBjQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLXBvc2l0aW9uLWJvdHRvbXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4Y0dGMGFDQm1hV3hzUFNJak1EQXdJaUJtYVd4c0xXOXdZV05wZEhrOUlpNHlOU0lnWkQwaVRUTWdNVEJvTVRSMk1VZ3plbTB6TFROb09IWXhTRFo2SWk4K1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1pEMGlUVFlnTVROb09IWXhTRFo2SWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tcG9zaXRpb24tY2VudGVyey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQWlJR2hsYVdkb2REMGlNakFpSUhacFpYZENiM2c5SWpBZ01DQXlNQ0F5TUNJZ1ptbHNiRDBpYm05dVpTSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjR0YwYUNCbWFXeHNQU0lqTURBd0lpQmtQU0pOTXlBeE1HZ3hOSFl4U0RONklpOCtQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxdmNHRmphWFI1UFNJdU1qVWlJR1E5SWswMklEZG9PSFl4U0RaNmJUQWdObWc0ZGpGSU5ub2lMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1wb3NpdGlvbi10b3B7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNHRjBhQ0JtYVd4c1BTSWpNREF3SWlCbWFXeHNMVzl3WVdOcGRIazlJaTR5TlNJZ1pEMGlUVE1nTVRCb01UUjJNVWd6ZWlJdlBqeHdZWFJvSUdacGJHdzlJaU13TURBaUlHUTlJazAySURkb09IWXhTRFo2SWk4K1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF2Y0dGamFYUjVQU0l1TWpVaUlHUTlJazAySURFemFEaDJNVWcyZWlJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXByaWNlLWxhYmVsLWFubm90YXRpb257LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OQzQxSUROQk1TNDFJREV1TlNBd0lEQWdNQ0F6SURRdU5WWXhNMkV4TGpVZ01TNDFJREFnTUNBd0lERXVOU0F4TGpWb0xqZ3pNM1l1TURVM1l5NHlOREl0TGpJNU9TNDFPVGN0TGpVd015QXhMUzQxTkRoV01UTXVOVWcwTGpWQkxqVXVOU0F3SURBZ01TQTBJREV6VmpRdU5XRXVOUzQxSURBZ01DQXhJQzQxTFM0MWFERXhZUzQxTGpVZ01DQXdJREVnTGpVdU5YWTRZUzQxTGpVZ01DQXdJREV0TGpVdU5XZ3ROQzQ0TVRoc0xTNHhNall1TURnMFlUSTJJREkySURBZ01DQXdMVEl1TWpJMUlERXVOamcxYkMwdU16SXVNalkxTFM0d05qZ3VNRFUyWVRFdU5TQXhMalVnTUNBd0lERXRNaTQyTURrZ01TNHpOVFJqTGpBek15NDNOak11T1RBMUlERXVNak00SURFdU5UWXVOelUyTGpZME5pMHVORGMwSURFdU1qRXRMamswTXlBeExqYzJNUzB4TGpSc0xqTXhNeTB1TWpaQk1qWWdNallnTUNBd0lERWdNVEF1T1RnMklERTBTREUxTGpWaE1TNDFJREV1TlNBd0lEQWdNQ0F4TGpVdE1TNDFkaTA0UVRFdU5TQXhMalVnTUNBd0lEQWdNVFV1TlNBemVpSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaTgrUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOT0M0M01UWWdNVFF1T0RFMVlUSXVNalVnTWk0eU5TQXdJREVnTVMwMExqSXhJREV1TlRreklESXVNalVnTWk0eU5TQXdJREFnTVNBMExqSXhMVEV1TlRremJTMHhMalkyTWlBeExqazJObUV4TGpJMUlERXVNalVnTUNBeElEQXRMamc0TlMweUxqTXpPU0F4TGpJMUlERXVNalVnTUNBd0lEQWdMamc0TlNBeUxqTXpPU0lnWTJ4cGNDMXlkV3hsUFNKbGRtVnViMlJrSWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tcHJpY2UtcmFuZ2UtZHJhd2luZ3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4Y0dGMGFDQmtQU0pOT1M0d05EWWdNVFZXTlM0NE56ZG9MamswTWxZeE5Yb2lJR1pwYkd3OUlpTXhPREZFTVVZaUx6NDhjR0YwYUNCa1BTSk5PUzR3TkRZZ01UVldOUzQ0Tnpkb0xqazBNbFl4TlhvaUlHWnBiR3c5SWlNeE9ERkVNVVlpTHo0OGNHRjBhQ0JrUFNKTk9TNDFJRFl1TWpJNElEY3VNVFkzSURndU16YzJJRFl1TlNBM0xqYzJNaUE1TGpVZ05Xd3pJREl1TnpZeUxTNDJOamN1TmpFMGVpSWdabWxzYkQwaUl6QXdNQ0l2UGp4d1lYUm9JR1E5SWsweUlERTRkaTB4YURFMmRqRjZUVElnTTFZeWFERTJkakY2SWlCbWFXeHNQU0lqTVRneFJERkdJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1yZXNldHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk1USXVNRFFnTkM0ME5EVmhOUzQ0TVNBMUxqZ3hJREFnTUNBd0xUY3VNalUzSURJdU5EVXpMalV1TlNBd0lEQWdNUzB1T0RZMUxTNDFNREpCTmk0NE1TQTJMamd4SURBZ01TQXhJRE1nT1M0NE1UTmhMalV1TlNBd0lEQWdNU0F4SURBZ05TNDRNU0ExTGpneElEQWdNU0F3SURndU1EUXROUzR6TmpnaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQanh3WVhSb0lHWnBiR3c5SWlNd01EQWlJR1pwYkd3dGNuVnNaVDBpWlhabGJtOWtaQ0lnWkQwaVRUUXVNamc1SURNdU1EQXlZUzQxTGpVZ01DQXdJREVnTGpVdU5YWXlMalkxTldneUxqWTFOV0V1TlM0MUlEQWdNQ0F4SURBZ01VZzBMakk1WVM0MUxqVWdNQ0F3SURFdExqVXRMalZXTXk0MU1ESmhMalV1TlNBd0lEQWdNU0F1TlMwdU5TSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1zZXR0aW5nc3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIyYVdWM1FtOTRQU0l3SURBZ01qQWdNakFpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUlnZUcxc09uTndZV05sUFNKd2NtVnpaWEoyWlNJZ2MzUjViR1U5SW1acGJHd3RjblZzWlRwbGRtVnViMlJrSWo0OGNHRjBhQ0JrUFNKTk1UQWdNVE5oTXlBeklEQWdNU0F3SURBdE5pQXpJRE1nTUNBd0lEQWdNQ0EyYlRBdE1XRXlJRElnTUNBeElERXRMakF3TVMwekxqazVPVUV5SURJZ01DQXdJREVnTVRBZ01USWlMejQ4Y0dGMGFDQmtQU0pOTWk0ek1TQXhOQzR6TkRWakxTNDRNVGN0TVM0ME9URXVNREkzTFRJdU5EazVMalEzTkMweUxqZzJOUzQxTXpFdExqUXpOQzQ1TmprdExqTTJOUzQ1TnpJdE1TNDBPQzB1TURBekxURXVNVEUxTFM0ME5ERXRNUzR3TkRZdExqazNNaTB4TGpRNE1TMHVORFUwTFM0ek56RXRNUzR6TVRjdE1TNDBNRFV0TGpRek5DMHlMamt6Tm13dU1EQTFMUzR3TURsakxqZzROQzB4TGpVeUlESXVNakEzTFRFdU1qa2dNaTQzTlRVdE1TNHdPRE11TmpReExqSTBNeTQ0TURFdU5qVTJJREV1TnpZNExqRXdNUzQ1TmpRdExqVTJMalk0TmkwdU9UQTBMamM1TmkweExqVTRNaTR3T1RRdExqVTNPQzQxTlRrdE1TNDRORE1nTWk0ek1qWXRNUzQ0TkROb0xqQXhZekV1TnpVNUxqQXdOU0F5TGpJeU1pQXhMakkyTmlBeUxqTXhOaUF4TGpnME15NHhNUzQyTnpndExqRTJPQ0F4TGpBeU1pNDNPVFlnTVM0MU9ESXVPVFkzTGpVMU5TQXhMakV5Tnk0eE5ESWdNUzQzTmpndExqRXdNUzQxTkRrdExqSXdPQ0F4TGpnM05pMHVORE00SURJdU56WWdNUzR3T1RKekxqQXlJREl1TlRZMUxTNDBNelFnTWk0NU16WmpMUzQxTXpFdU5ETTFMUzQ1TmprdU16WTJMUzQ1TnpJZ01TNDBPREV1TURBeklERXVNVEUxTGpRME1TQXhMakEwTmk0NU56SWdNUzQwT0M0ME5UUXVNemN5SURFdU16RTNJREV1TkRBMkxqUXpOQ0F5TGprek4yd3RMakF3TlM0d01EbGpMUzQ0T0RRZ01TNDFNaTB5TGpJd055QXhMakk1TFRJdU56VTFJREV1TURnekxTNDJOREV0TGpJME15MHVPREF4TFM0Mk5UWXRNUzQzTmpndExqRXdNUzB1T1RZMExqVTJMUzQyT0RZdU9UQTBMUzQzT1RZZ01TNDFPREV0TGpBNU5DNDFOemt0TGpVMU9TQXhMamcwTkMweUxqTXlOaUF4TGpnME5HZ3RMakF4WXkweExqYzFPUzB1TURBMUxUSXVNakl5TFRFdU1qWTJMVEl1TXpFMkxURXVPRFEwTFM0eE1TMHVOamMzTGpFMk9DMHhMakF5TVMwdU56azJMVEV1TlRneExTNDVOamN0TGpVMU5TMHhMakV5TnkwdU1UUXlMVEV1TnpZNExqRXdNUzB1TlRRNUxqSXdPQzB4TGpnM05pNDBNemd0TWk0M05pMHhMakE1TW13dExqQXlMUzR3TXpaNlRUa3VPVGcwSURJdU1UWXlTREV3WXpFdU16VTFJREFnTVM0ek5ESWdNUzR3TXprZ01TNHpOVE1nTVM0ME1qVXVNREE0TGpNeE1pNHdOQ0F4TGpFMklERXVNalU1SURFdU9EY3liQzR3TVRVdU1EQTRZekV1TWpJMUxqY2dNUzQ1TnpZdU16QTBJREl1TWpVeExqRTFOUzR6TXpjdExqRTRNeUF4TGpJeU5pMHVOekV4SURFdU9UQXlMalEwTld3dU1EQTRMakF4TkdNdU5qYzRJREV1TVRjekxTNHlNamtnTVM0Mk9ESXRMalUxT0NBeExqZzROQzB1TWpZMkxqRTJNeTB1T1RnMExqWXhOUzB1T1RreElESXVNREkzZGk0d01UWmpMakF3TnlBeExqUXhNaTQzTWpVZ01TNDROalF1T1RreElESXVNREkzTGpNeU9DNHlNREVnTVM0eU1qa3VOekEzTGpVMk5pQXhMamczYkMwdU1EQTRMakF4TkdNdExqWTNOeUF4TGpFM05DMHhMalUzTVM0Mk5ETXRNUzQ1TVM0ME5Ua3RMakkzTlMwdU1UUTVMVEV1TURJMkxTNDFORFV0TWk0eU5URXVNVFUwYkMwdU1ERTFMakF3T1dNdE1TNHlNVGt1TnpFeUxURXVNalV4SURFdU5UWXRNUzR5TlRrZ01TNDROekl0TGpBeE1TNHpPRFl1TURBeUlERXVOREkxTFRFdU16VXpJREV1TkRJMWN5MHhMak0wTWkweExqQXpPUzB4TGpNMU15MHhMalF5TldNdExqQXdPQzB1TXpFeUxTNHdOQzB4TGpFMkxURXVNalU1TFRFdU9EY3liQzB1TURFMUxTNHdNRGxqTFRFdU1qSTFMUzQyT1RrdE1TNDVOell0TGpNd015MHlMakkxTVMwdU1UVTBMUzR6TXpZdU1UZ3pMVEV1TWpFNUxqY3dOaTB4TGpnNU5DMHVORE15YkMwdU1ERTJMUzR3TWpkakxTNDJOemd0TVM0eE56UXVNakk1TFRFdU5qZ3lMalUxT0MweExqZzROQzR5TmpZdExqRTJNeTQ1T0RRdExqWXhOUzQ1T1RFdE1pNHdNamQyTFM0d01UWmpMUzR3TURjdE1TNDBNVEl0TGpjeU5TMHhMamcyTkMwdU9Ua3hMVEl1TURJM0xTNHpNamd0TGpJd01TMHhMakl5T1MwdU56QTNMUzQxTmpZdE1TNDROMnd1TURBNExTNHdNVFJqTGpZM055MHhMakUzTkNBeExqVTNNUzB1TmpReklERXVPVEV0TGpRMU9TNHlOelV1TVRRNUlERXVNREkyTGpVME5TQXlMakkxTVMwdU1UVTFiQzR3TVRVdExqQXdPR014TGpJeE9TMHVOekV5SURFdU1qVXhMVEV1TlRZZ01TNHlOVGt0TVM0NE56SXVNREV0TGpNNE5DMHVNREF5TFRFdU5ERTNJREV1TXpNM0xURXVOREkxSWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tc3RlcC1saW5lLXNlcmllc3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFNE1VUXhSaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OaUEwYURWMk9HZ3pWamhvTlhZeGFDMDBkalJvTFRWV05VZzNkakV3U0RKMkxURm9OSG9pSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXRleHQtYW5ub3RhdGlvbnstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakFpSUdobGFXZG9kRDBpTWpBaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TUNBeU1DSWdabWxzYkQwaWJtOXVaU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajRLUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMDBJRFJJTVRaV04wZ3hOVlkxU0RFd0xqVldNVFZJTVRSV01UWklObFl4TlVnNUxqVldOVWcxVmpkSU5GWTBXaUlnWm1sc2JEMGlZbXhoWTJzaUx6NEtQQzl6ZG1jK0NnPT0pfS5hZy1jaGFydHMtaWNvbi10cmVuZC1saW5lLC5hZy1jaGFydHMtaWNvbi10cmVuZC1saW5lLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTlM0ek1UUWdNVEF1T1RNNFlUSXVNalVnTWk0eU5TQXdJREVnTVNBdU1ERXRNV2c1TGpNMU1tRXlMakkxSURJdU1qVWdNQ0F4SURFZ0xqQXhJREY2YlMweUxqRTRPUzQzTWpsaE1TNHlOU0F4TGpJMUlEQWdNU0F3SURBdE1pNDFJREV1TWpVZ01TNHlOU0F3SURBZ01DQXdJREl1TlcweE15NDNOU0F3WVRFdU1qVWdNUzR5TlNBd0lERWdNQ0F3TFRJdU5TQXhMakkxSURFdU1qVWdNQ0F3SURBZ01DQXlMalVpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXVubG9jaywuYWctY2hhcnRzLWljb24tdW5sb2NrZWR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NVEF1TmpVeElETXVOV0V5TGpnNU5DQXlMamc1TkNBd0lEQWdNQzB5TGpnNU5DQXlMamc1TkZZNVNERTBMalZoTWk0MUlESXVOU0F3SURBZ01TQXlMalVnTWk0MWRqTmhNaTQxSURJdU5TQXdJREFnTVMweUxqVWdNaTQxYUMwNFFUSXVOU0F5TGpVZ01DQXdJREVnTkNBeE5DNDFkaTB6UVRJdU5TQXlMalVnTUNBd0lERWdOaTQxSURsb0xqSTFOMVkyTGpNNU5HRXpMamc1TkNBekxqZzVOQ0F3SURFZ01TQTNMamM0T1NBd0lDNDFMalVnTUNBd0lERXRNU0F3UVRJdU9EazBJREl1T0RrMElEQWdNQ0F3SURFd0xqWTFJRE11TlUwMkxqVWdNVEJCTVM0MUlERXVOU0F3SURBZ01DQTFJREV4TGpWMk0wRXhMalVnTVM0MUlEQWdNQ0F3SURZdU5TQXhObWc0WVRFdU5TQXhMalVnTUNBd0lEQWdNUzQxTFRFdU5YWXRNMkV4TGpVZ01TNDFJREFnTUNBd0xURXVOUzB4TGpWNklpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi12ZXJ0aWNhbC1saW5lLC5hZy1jaGFydHMtaWNvbi12ZXJ0aWNhbC1saW5lLWRyYXdpbmd7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTVRBdU5TQTNMamd3Tm1FeUxqSTFJREl1TWpVZ01DQXdJREVnTUNBMExqTTRPRll4T1M0MWFDMHhkaTAzTGpNd05tRXlMakkxSURJdU1qVWdNQ0F3SURFZ01DMDBMak00T0ZZdU5XZ3hlbTB0TGpVdU9UUTBZVEV1TWpVZ01TNHlOU0F3SURFZ01TQXdJREl1TlNBeExqSTFJREV1TWpVZ01DQXdJREVnTUMweUxqVWlJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tem9vbS1pbnstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdaRDBpVFRFd0lEVXVOV0V1TlM0MUlEQWdNQ0F4SUM0MUxqVjJNeTQxYURNdU9EYzFZUzQxTGpVZ01DQXdJREVnTUNBeFNERXdMalYyTkM0eU5XRXVOUzQxSURBZ01TQXhMVEVnTUZZeE1DNDFTRFV1TmpJMVlTNDFMalVnTUNBeElERWdNQzB4U0RrdU5WWTJZUzQxTGpVZ01DQXdJREVnTGpVdExqVWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi16b29tLW91dHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk5TNDFJREV3WVM0MUxqVWdNQ0F3SURFZ0xqVXRMalZvT0dFdU5TNDFJREFnTUNBeElEQWdNVWcyWVM0MUxqVWdNQ0F3SURFdExqVXRMalVpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLWhpZ2gtbG93LXNlcmllc3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OeUEwYURKMk1USklORlkwYUROTk5TQTFhRE4yTVRCSU5YcE5NVEVnTVRSV05tZzFkamhvTFRWdE1TMDNhRE4yTm1ndE0zb2lJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24taGxjLXNlcmllc3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSnRNVGd1TVRZeklERXVPRE0zTFRVdU16TTBJREV4TGpZeU1VdzJMamsxTnlBNExqRXliQzAwTGpFNU9TQTVMall5TWkwdU9URTJMUzQwSURRdU56VTJMVEV3TGpsTU1USXVORGtnTVRFdU9DQXhOeTR5TlRRZ01TNDBNbm9pSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqeHdZWFJvSUdacGJHdzlJaU13TURBaUlHWnBiR3d0YjNCaFkybDBlVDBpTGpRaUlHWnBiR3d0Y25Wc1pUMGlaWFpsYm05a1pDSWdaRDBpVFRVdU9ESTFJREl1TnpBMExqVTFJREV6TGpjNE5Xd3VPVEF5TGpReklEUXVOekkwTFRrdU9URTVJRFl1TURNMElEVXVNREk1SURNdU1qVTFMVGd1TVRRdExqa3lPQzB1TXpjdE1pNDNORFVnTmk0NE5ucHROeTQ0TlRJZ01UUXVOak0ySURVdU56Z3RNVE11TVRNNUxTNDVNVFV0TGpRd01pMDFMakl4T1NBeE1TNDROaTAyTGpBd05TMDFMalV3TkMwekxqSTNPQ0EzTGpZME9DNDVNaTR6T1RRZ01pNDNNakl0Tmk0ek5USjZJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tem9vbS1pbi1hbHR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJaUJtYVd4c1BTSnViMjVsSWlCemRISnZhMlU5SW1OMWNuSmxiblJEYjJ4dmNpSWdjM1J5YjJ0bExYZHBaSFJvUFNJeUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlJR05zWVhOelBTSnNkV05wWkdVZ2JIVmphV1JsTFhwdmIyMHRhVzRpUGp4amFYSmpiR1VnWTNnOUlqRXhJaUJqZVQwaU1URWlJSEk5SWpnaUx6NDhiR2x1WlNCNE1UMGlNakVpSUhneVBTSXhOaTQyTlNJZ2VURTlJakl4SWlCNU1qMGlNVFl1TmpVaUx6NDhiR2x1WlNCNE1UMGlNVEVpSUhneVBTSXhNU0lnZVRFOUlqZ2lJSGt5UFNJeE5DSXZQanhzYVc1bElIZ3hQU0k0SWlCNE1qMGlNVFFpSUhreFBTSXhNU0lnZVRJOUlqRXhJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi16b29tLW91dC1hbHR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJaUJtYVd4c1BTSnViMjVsSWlCemRISnZhMlU5SW1OMWNuSmxiblJEYjJ4dmNpSWdjM1J5YjJ0bExYZHBaSFJvUFNJeUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlJR05zWVhOelBTSnNkV05wWkdVZ2JIVmphV1JsTFhwdmIyMHRiM1YwSWo0OFkybHlZMnhsSUdONFBTSXhNU0lnWTNrOUlqRXhJaUJ5UFNJNElpOCtQR3hwYm1VZ2VERTlJakl4SWlCNE1qMGlNVFl1TmpVaUlIa3hQU0l5TVNJZ2VUSTlJakUyTGpZMUlpOCtQR3hwYm1VZ2VERTlJamdpSUhneVBTSXhOQ0lnZVRFOUlqRXhJaUI1TWowaU1URWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaW5wdXR7LS1pbnB1dC1sYXllci1hY3RpdmU6IDE7LS1pbnB1dC1sYXllci1mb2N1czogMjstLWlucHV0LXBhZGRpbmc6IGNhbGModmFyKC0tYWctY2hhcnRzLXNwYWNpbmcpICogMik7LS1pbnB1dC1wYWRkaW5nLWxhcmdlOiBjYWxjKHZhcigtLWFnLWNoYXJ0cy1zcGFjaW5nKSAqIDIuNSk7Y29sb3I6dmFyKC0tYWctY2hhcnRzLWlucHV0LXRleHQtY29sb3IpO2ZvbnQtZmFtaWx5OnZhcigtLWFnLWNoYXJ0cy1jaHJvbWUtZm9udC1mYW1pbHkpO2ZvbnQtc2l6ZTp2YXIoLS1hZy1jaGFydHMtY2hyb21lLWZvbnQtc2l6ZS1sYXJnZSk7dHJhbnNpdGlvbi1kdXJhdGlvbjouMjVzO3RyYW5zaXRpb24tcHJvcGVydHk6bm9uZTt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLW91dH0uYWctY2hhcnRzLWlucHV0OmZvY3VzLXZpc2libGV7b3V0bGluZTp2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyKTtib3gtc2hhZG93OnZhcigtLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXItc2hhZG93KTt6LWluZGV4OnZhcigtLWlucHV0LWxheWVyLWZvY3VzKX0uYWctY2hhcnRzLWJ1dHRvbntiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy1idXR0b24tYmFja2dyb3VuZC1jb2xvcik7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1hZy1jaGFydHMtYm9yZGVyLWNvbG9yKTtib3JkZXItcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1idXR0b24tYm9yZGVyLXJhZGl1cyk7Y29sb3I6dmFyKC0tYWctY2hhcnRzLWJ1dHRvbi10ZXh0LWNvbG9yKTtjdXJzb3I6cG9pbnRlcjtwYWRkaW5nOnZhcigtLWlucHV0LXBhZGRpbmcpO3RyYW5zaXRpb24tcHJvcGVydHk6YmFja2dyb3VuZCxib3JkZXItY29sb3J9LmFnLWNoYXJ0cy1idXR0b246aG92ZXJ7YmFja2dyb3VuZDp2YXIoLS1hZy1jaGFydHMtZm9jdXMtY29sb3IpfS5hZy1jaGFydHMtYnV0dG9uOmhhcyguYWctY2hhcnRzLWljb24pe3BhZGRpbmc6MnB4fS5hZy1jaGFydHMtY2hlY2tib3h7LS1jaGVja2JveC10cmFuc2l0aW9uLWR1cmF0aW9uOiAuMXM7YXBwZWFyYW5jZTpub25lO2JhY2tncm91bmQ6dmFyKC0tYWctY2hhcnRzLWNoZWNrYm94LWJhY2tncm91bmQtY29sb3IpO2JvcmRlci1yYWRpdXM6Y2FsYyh2YXIoLS1hZy1jaGFydHMtYm9yZGVyLXJhZGl1cykgKiA5KTtjdXJzb3I6cG9pbnRlcjtoZWlnaHQ6MThweDttYXJnaW46MDt0cmFuc2l0aW9uLWR1cmF0aW9uOnZhcigtLWNoZWNrYm94LXRyYW5zaXRpb24tZHVyYXRpb24pO3RyYW5zaXRpb24tcHJvcGVydHk6bWFyZ2luO3dpZHRoOjI5cHh9LmFnLWNoYXJ0cy1jaGVja2JveDpiZWZvcmV7ZGlzcGxheTpibG9jaztiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy1pbnB1dC1iYWNrZ3JvdW5kLWNvbG9yKTtib3JkZXItcmFkaXVzOmNhbGModmFyKC0tYWctY2hhcnRzLWJvcmRlci1yYWRpdXMpICogNyk7Y29udGVudDpcIiBcIjtoZWlnaHQ6MTRweDttYXJnaW46MnB4O3RyYW5zaXRpb24tZHVyYXRpb246dmFyKC0tY2hlY2tib3gtdHJhbnNpdGlvbi1kdXJhdGlvbik7dHJhbnNpdGlvbi1wcm9wZXJ0eTptYXJnaW47dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246dmFyKC0tYWctY2hhcnRzLWlucHV0LXRyYW5zaXRpb24tZWFzaW5nKTt3aWR0aDoxNHB4fS5hZy1jaGFydHMtY2hlY2tib3g6Y2hlY2tlZHtiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy1jaGVja2JveC1jaGVja2VkLWJhY2tncm91bmQtY29sb3IpfS5hZy1jaGFydHMtY2hlY2tib3g6Y2hlY2tlZDpiZWZvcmV7bWFyZ2luLWxlZnQ6MTNweH0uYWctY2hhcnRzLXNlbGVjdHtiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy1pbnB1dC1iYWNrZ3JvdW5kLWNvbG9yKTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWFnLWNoYXJ0cy1pbnB1dC1ib3JkZXItY29sb3IpO2JvcmRlci1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWlucHV0LWJvcmRlci1yYWRpdXMpO3BhZGRpbmc6M3B4IDJweCA0cHg7Zm9udC1zaXplOmluaGVyaXR9LmFnLWNoYXJ0cy10ZXh0YXJlYXstLXRleHRhcmVhLWxpbmUtaGVpZ2h0OiAxLjM4O2JhY2tncm91bmQ6dmFyKC0tYWctY2hhcnRzLWlucHV0LWJhY2tncm91bmQtY29sb3IpO2JvcmRlcjoxcHggc29saWQgdmFyKC0tYWctY2hhcnRzLWJvcmRlci1jb2xvcik7Ym9yZGVyLXJhZGl1czp2YXIoLS1hZy1jaGFydHMtaW5wdXQtYm9yZGVyLXJhZGl1cyk7bGluZS1oZWlnaHQ6dmFyKC0tdGV4dGFyZWEtbGluZS1oZWlnaHQpO2ZvbnQtZmFtaWx5OnZhcigtLWFnLWNoYXJ0cy1jaHJvbWUtZm9udC1mYW1pbHkpO2ZvbnQtc2l6ZTp2YXIoLS1hZy1jaGFydHMtY2hyb21lLWZvbnQtc2l6ZS1sYXJnZSk7cGFkZGluZzp2YXIoLS1pbnB1dC1wYWRkaW5nLWxhcmdlKSB2YXIoLS1pbnB1dC1wYWRkaW5nKX0uYWctY2hhcnRzLXRleHRhcmVhOjpwbGFjZWhvbGRlcntjb2xvcjp2YXIoLS1hZy1jaGFydHMtaW5wdXQtcGxhY2Vob2xkZXItdGV4dC1jb2xvcil9LmFnLWNoYXJ0cy1wcm94eS1jb250YWluZXJ7cG9pbnRlci1ldmVudHM6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZX0uYWctY2hhcnRzLXByb3h5LWVsZW17LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7YXBwZWFyYW5jZTpub25lO2JhY2tncm91bmQ6bm9uZTtib3JkZXI6bm9uZTtjb2xvcjojMDAwMDtvdmVyZmxvdzpoaWRkZW47cG9pbnRlci1ldmVudHM6YXV0bztwb3NpdGlvbjphYnNvbHV0ZX0uYWctY2hhcnRzLXByb3h5LWVsZW06Oi1tb3otcmFuZ2UtdGh1bWIsLmFnLWNoYXJ0cy1wcm94eS1lbGVtOjotbW96LXJhbmdlLXRyYWNre29wYWNpdHk6MH0uYWctY2hhcnRzLXByb3h5LWVsZW06Oi13ZWJraXQtc2xpZGVyLXJ1bm5hYmxlLXRyYWNrLC5hZy1jaGFydHMtcHJveHktZWxlbTo6LXdlYmtpdC1zbGlkZXItdGh1bWJ7b3BhY2l0eTowfS5hZy1jaGFydHMtcHJveHktZWxlbTpmb2N1cy12aXNpYmxle291dGxpbmU6dmFyKC0tYWctY2hhcnRzLWZvY3VzLWJvcmRlcik7Ym94LXNoYWRvdzp2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLXNoYWRvdyl9LmFnLWNoYXJ0cy1mb2N1cy1pbmRpY2F0b3J7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jaztwb2ludGVyLWV2ZW50czpub25lO3VzZXItc2VsZWN0Om5vbmU7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCV9LmFnLWNoYXJ0cy1mb2N1cy1pbmRpY2F0b3I+ZGl2e3Bvc2l0aW9uOmFic29sdXRlO291dGxpbmU6c29saWQgMXB4IHZhcigtLWFnLWNoYXJ0cy1jaHJvbWUtYmFja2dyb3VuZC1jb2xvcik7Ym94LXNoYWRvdzp2YXIoLS1hZy1jaGFydHMtZm9jdXMtc2hhZG93KX0uYWctY2hhcnRzLWZvY3VzLWluZGljYXRvcj5zdmd7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtmaWxsOm5vbmU7b3ZlcmZsb3c6dmlzaWJsZX0uYWctY2hhcnRzLWZvY3VzLXN2Zy1vdXRlci1wYXRoe3N0cm9rZTp2YXIoLS1hZy1jaGFydHMtY2hyb21lLWJhY2tncm91bmQtY29sb3IpO3N0cm9rZS13aWR0aDo0cHh9LmFnLWNoYXJ0cy1mb2N1cy1zdmctaW5uZXItcGF0aHtzdHJva2U6dmFyKC0tYWctY2hhcnRzLWFjY2VudC1jb2xvcik7c3Ryb2tlLXdpZHRoOjJweH0uYWctY2hhcnRzLW92ZXJsYXl7Y29sb3I6IzE4MWQxZjtwb2ludGVyLWV2ZW50czpub25lfS5hZy1jaGFydHMtb3ZlcmxheS5hZy1jaGFydHMtZGFyay1vdmVybGF5e2NvbG9yOiNmZmZ9LmFnLWNoYXJ0cy1vdmVybGF5LS1sb2FkaW5ne2NvbG9yOiM4YzhjOGN9LmFnLWNoYXJ0cy1vdmVybGF5X19sb2FkaW5nLWJhY2tncm91bmR7YmFja2dyb3VuZDojZmZmO3BvaW50ZXItZXZlbnRzOm5vbmV9LmFnLWNoYXJ0cy1vdmVybGF5LmFnLWNoYXJ0cy1kYXJrLW92ZXJsYXkgLmFnLWNoYXJ0cy1vdmVybGF5X19sb2FkaW5nLWJhY2tncm91bmR7YmFja2dyb3VuZDojMTkyMjMyfS5hZy1jaGFydHMtdG9vbHRpcHstLXRvb2x0aXAtYXJyb3ctc2l6ZTogOHB4O3Bvc2l0aW9uOmZpeGVkO2luc2V0OnVuc2V0O21hcmdpbjowO3BhZGRpbmc6MDtvdmVyZmxvdzp2aXNpYmxlO3dpZHRoOm1heC1jb250ZW50O21heC13aWR0aDoxMDAlO2ZvbnQtZmFtaWx5OnZhcigtLWFnLWNoYXJ0cy1jaHJvbWUtZm9udC1mYW1pbHkpO2ZvbnQtc2l6ZTp2YXIoLS1hZy1jaGFydHMtY2hyb21lLWZvbnQtc2l6ZSk7Zm9udC13ZWlnaHQ6dmFyKC0tYWctY2hhcnRzLWNocm9tZS1mb250LXdlaWdodCk7Y29sb3I6dmFyKC0tYWctY2hhcnRzLWNocm9tZS10ZXh0LWNvbG9yKTtiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy1jaHJvbWUtYmFja2dyb3VuZC1jb2xvcik7Ym9yZGVyOnZhcigtLWFnLWNoYXJ0cy1ib3JkZXIpO2JvcmRlci1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJvcmRlci1yYWRpdXMpO2JveC1zaGFkb3c6dmFyKC0tYWctY2hhcnRzLXNoYWRvdyl9LmFnLWNoYXJ0cy10b29sdGlwLS1jb21wYWN0IC5hZy1jaGFydHMtdG9vbHRpcC1jb250ZW50e3BhZGRpbmc6M3B4IDZweH0uYWctY2hhcnRzLXRvb2x0aXAtLWFycm93OmJlZm9yZXtjb250ZW50OlwiXCI7cG9zaXRpb246YWJzb2x1dGU7dG9wOjEwMCU7bGVmdDo1MCU7bWFyZ2luOjAgYXV0bzt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUpIHRyYW5zbGF0ZVkoY2FsYyh2YXIoLS10b29sdGlwLWFycm93LXNpemUpICogLS41KSkgcm90YXRlKDQ1ZGVnKTtkaXNwbGF5OmJsb2NrO3dpZHRoOnZhcigtLXRvb2x0aXAtYXJyb3ctc2l6ZSk7aGVpZ2h0OnZhcigtLXRvb2x0aXAtYXJyb3ctc2l6ZSk7Ym9yZGVyOmluaGVyaXQ7Ym9yZGVyLXRvcDpub25lO2JvcmRlci1sZWZ0Om5vbmU7Y2xpcC1wYXRoOnBvbHlnb24oMCUgMTAwJSwxMDAlIDAlLDEwMCUgMTAwJSl9LmFnLWNoYXJ0cy10b29sdGlwLS1hcnJvdzphZnRlcnstLXRvb2x0aXAtaW5uZXItc2l6ZTogY2FsYyh2YXIoLS10b29sdGlwLWFycm93LXNpemUpIC0gMnB4KTtjb250ZW50OlwiXCI7cG9zaXRpb246YWJzb2x1dGU7dG9wOjEwMCU7bGVmdDo1MCU7bWFyZ2luOjAgYXV0bzt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUpIHRyYW5zbGF0ZVkoY2FsYyh2YXIoLS10b29sdGlwLWlubmVyLXNpemUpICogLS41KSkgcm90YXRlKDQ1ZGVnKTtkaXNwbGF5OmJsb2NrO3dpZHRoOnZhcigtLXRvb2x0aXAtaW5uZXItc2l6ZSk7aGVpZ2h0OnZhcigtLXRvb2x0aXAtaW5uZXItc2l6ZSk7Ym9yZGVyOmluaGVyaXQ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50O2JhY2tncm91bmQ6aW5oZXJpdDtjbGlwLXBhdGg6cG9seWdvbigtMTAlIDEwMCUsMTAwJSAtMTAlLDEwMCUgMTAwJSl9LmFnLWNoYXJ0cy10b29sdGlwLS1uby1pbnRlcmFjdGlvbntwb2ludGVyLWV2ZW50czpub25lO3VzZXItc2VsZWN0Om5vbmU7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lfS5hZy1jaGFydHMtdG9vbHRpcC0td3JhcC1hbHdheXN7b3ZlcmZsb3ctd3JhcDpicmVhay13b3JkO3dvcmQtYnJlYWs6YnJlYWstd29yZDtoeXBoZW5zOm5vbmV9LmFnLWNoYXJ0cy10b29sdGlwLS13cmFwLWh5cGhlbmF0ZXtvdmVyZmxvdy13cmFwOmJyZWFrLXdvcmQ7d29yZC1icmVhazpicmVhay13b3JkO2h5cGhlbnM6YXV0b30uYWctY2hhcnRzLXRvb2x0aXAtLXdyYXAtb24tc3BhY2V7b3ZlcmZsb3ctd3JhcDpub3JtYWw7d29yZC1icmVhazpub3JtYWx9LmFnLWNoYXJ0cy10b29sdGlwLS13cmFwLW5ldmVye3doaXRlLXNwYWNlOm5vd3JhcH0uYWctY2hhcnRzLXRvb2x0aXAtaGVhZGluZywuYWctY2hhcnRzLXRvb2x0aXAtdGl0bGUsLmFnLWNoYXJ0cy10b29sdGlwLWxhYmVsLC5hZy1jaGFydHMtdG9vbHRpcC12YWx1ZXtvdmVyZmxvdzpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpc30uYWctY2hhcnRzLXRvb2x0aXAtY29udGVudHtkaXNwbGF5OmdyaWQ7Z3JpZDphdXRvLWZsb3cgbWlubWF4KDFlbSxhdXRvKSAvIDFmcjtwYWRkaW5nOjhweCAxMnB4O2dhcDo4cHh9LmFnLWNoYXJ0cy10b29sdGlwLWNvbnRlbnQ6aGFzKC5hZy1jaGFydHMtdG9vbHRpcC1zeW1ib2wpe2dyaWQ6YXV0by1mbG93IG1pbm1heCgxZW0sYXV0bykgLyBhdXRvIDFmcn0uYWctY2hhcnRzLXRvb2x0aXAtaGVhZGluZ3tncmlkLWNvbHVtbjoxIC8gLTF9LmFnLWNoYXJ0cy10b29sdGlwLXN5bWJvbHtncmlkLWNvbHVtbjoxIC8gMjthbGlnbi1zZWxmOmNlbnRlcn0uYWctY2hhcnRzLXRvb2x0aXAtc3ltYm9sIHN2Z3tkaXNwbGF5OmJsb2NrfS5hZy1jaGFydHMtdG9vbHRpcC10aXRsZXtncmlkLWNvbHVtbjotMiAvIC0xfS5hZy1jaGFydHMtdG9vbHRpcC1yb3d7Z3JpZC1jb2x1bW46MSAvIC0xO2Rpc3BsYXk6ZmxleDtnYXA6MTZweDthbGlnbi1pdGVtczpiYXNlbGluZTtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjtvdmVyZmxvdzpoaWRkZW59LmFnLWNoYXJ0cy10b29sdGlwLXJvdy0taW5saW5le2dyaWQtY29sdW1uOi0yIC8gLTF9LmFnLWNoYXJ0cy10b29sdGlwLWxhYmVse2ZsZXg6MTttaW4td2lkdGg6MH0uYWctY2hhcnRzLXRvb2x0aXAtdmFsdWV7bWluLXdpZHRoOjB9LmFnLWNoYXJ0cy1wb3BvdmVye3Bvc2l0aW9uOmFic29sdXRlO2JvcmRlcjp2YXIoLS1hZy1jaGFydHMtYm9yZGVyKTtib3JkZXItcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1ib3JkZXItcmFkaXVzKTtiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy1jaHJvbWUtYmFja2dyb3VuZC1jb2xvcik7Y29sb3I6dmFyKC0tYWctY2hhcnRzLWNocm9tZS10ZXh0LWNvbG9yKTtmb250LWZhbWlseTp2YXIoLS1hZy1jaGFydHMtY2hyb21lLWZvbnQtZmFtaWx5KTtmb250LXNpemU6dmFyKC0tYWctY2hhcnRzLWNocm9tZS1mb250LXNpemUpO2ZvbnQtd2VpZ2h0OnZhcigtLWFnLWNoYXJ0cy1jaHJvbWUtZm9udC13ZWlnaHQpO2JveC1zaGFkb3c6dmFyKC0tYWctY2hhcnRzLXNoYWRvdyk7ei1pbmRleDp2YXIoLS1hZy1jaGFydHMtbGF5ZXItdWktb3ZlcmxheSl9LmFnLWNoYXJ0cy1tZW51ey0taXRlbS1wYWRkaW5nOiA2cHggMTJweDstLWljb24tY29sb3I6IHZhcigtLWFnLWNoYXJ0cy1jaHJvbWUtdGV4dC1jb2xvcik7ZGlzcGxheTpncmlkO2dyaWQ6YXV0by1mbG93IGF1dG8gLyAxZnI7Y29sdW1uLWdhcDoxMnB4O2ZvbnQtc2l6ZTp2YXIoLS1hZy1jaGFydHMtY2hyb21lLWZvbnQtc2l6ZSl9LmFnLWNoYXJ0cy1tZW51OmhhcyguYWctY2hhcnRzLW1lbnVfX2ljb24sLmFnLWNoYXJ0cy1tZW51X19yb3ctLXN0cm9rZS13aWR0aC12aXNpYmxlKXtncmlkOmF1dG8tZmxvdyBhdXRvIC8gYXV0byAxZnJ9LmFnLWNoYXJ0cy1tZW51X19yb3ctLXN0cm9rZS13aWR0aC12aXNpYmxlOmJlZm9yZXtjb250ZW50OlwiXCI7aGVpZ2h0OnZhcigtLXN0cm9rZVdpZHRoKTt3aWR0aDoxMnB4O2JhY2tncm91bmQ6dmFyKC0taWNvbi1jb2xvcil9LmFnLWNoYXJ0cy1tZW51X19yb3ctLXN0cm9rZS13aWR0aC12aXNpYmxlW2FyaWEtZGlzYWJsZWQ9dHJ1ZV06YmVmb3Jle2ZpbHRlcjpncmF5c2NhbGUoMSk7b3BhY2l0eTouNX0uYWctY2hhcnRzLW1lbnVfX3Jvd3tkaXNwbGF5OmdyaWQ7Z3JpZC1jb2x1bW46MSAvIC0xO2dyaWQtdGVtcGxhdGUtY29sdW1uczpzdWJncmlkO2FsaWduLWl0ZW1zOmNlbnRlcjtwYWRkaW5nOnZhcigtLWl0ZW0tcGFkZGluZyl9LmFnLWNoYXJ0cy1tZW51X19yb3c6bm90KC5hZy1jaGFydHMtbWVudV9fcm93LS1hY3RpdmUpe2N1cnNvcjpwb2ludGVyfS5hZy1jaGFydHMtbWVudV9fcm93OmZpcnN0LWNoaWxke2JvcmRlci10b3AtbGVmdC1yYWRpdXM6aW5oZXJpdDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czppbmhlcml0fS5hZy1jaGFydHMtbWVudV9fcm93Omxhc3QtY2hpbGR7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czppbmhlcml0O2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOmluaGVyaXR9LmFnLWNoYXJ0cy1tZW51X19yb3c6Zm9jdXN7YmFja2dyb3VuZDp2YXIoLS1hZy1jaGFydHMtZm9jdXMtY29sb3IpfS5hZy1jaGFydHMtbWVudV9fcm93OmZvY3VzLXZpc2libGV7b3V0bGluZTp2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyKTtib3gtc2hhZG93OnZhcigtLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXItc2hhZG93KTt6LWluZGV4OnZhcigtLWFnLWNoYXJ0cy1sYXllci1tZW51KX0uYWctY2hhcnRzLW1lbnVfX3Jvdy0tYWN0aXZley0taWNvbi1jb2xvcjogdmFyKC0tYWctY2hhcnRzLWFjY2VudC1jb2xvcik7YmFja2dyb3VuZDp2YXIoLS1hZy1jaGFydHMtZm9jdXMtY29sb3IpO2NvbG9yOnZhcigtLWFnLWNoYXJ0cy1hY2NlbnQtY29sb3IpfS5hZy1jaGFydHMtbWVudV9fbGFiZWx7Z3JpZC1jb2x1bW46LTEgLyBzcGFuIDF9LmFnLWNoYXJ0cy10b29sYmFyey0tdG9vbGJhci1nYXA6IGNhbGModmFyKC0tYWctY2hhcnRzLXNwYWNpbmcpICogMik7LS10b29sYmFyLXNpemU6IDM0cHg7LS10b29sYmFyLWJ1dHRvbi1wYWRkaW5nOiA2cHg7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6ZmxleDtmbGV4LXdyYXA6bm93cmFwO3Bvc2l0aW9uOmFic29sdXRlfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9ue2FsaWduLWl0ZW1zOmNlbnRlcjtiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy1jaHJvbWUtYmFja2dyb3VuZC1jb2xvcik7Ym9yZGVyOnZhcigtLWFnLWNoYXJ0cy1ib3JkZXIpO2NvbG9yOnZhcigtLWFnLWNoYXJ0cy1jaHJvbWUtdGV4dC1jb2xvcik7Y3Vyc29yOnBvaW50ZXI7ZGlzcGxheTpmbGV4O2ZvbnQtZmFtaWx5OnZhcigtLWFnLWNoYXJ0cy1jaHJvbWUtZm9udC1mYW1pbHkpO2ZvbnQtc2l6ZTp2YXIoLS1hZy1jaGFydHMtY2hyb21lLWZvbnQtc2l6ZS1tZWRpdW0pO2ZvbnQtd2VpZ2h0OnZhcigtLWFnLWNoYXJ0cy1jaHJvbWUtZm9udC13ZWlnaHQpO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWluLWhlaWdodDp2YXIoLS10b29sYmFyLXNpemUpO21pbi13aWR0aDp2YXIoLS10b29sYmFyLXNpemUpO3BhZGRpbmc6dmFyKC0tdG9vbGJhci1idXR0b24tcGFkZGluZyk7cG9zaXRpb246cmVsYXRpdmU7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4yNXMgZWFzZS1pbi1vdXQsYm9yZGVyLWNvbG9yIC4yNXMgZWFzZS1pbi1vdXQsY29sb3IgLjI1cyBlYXNlLWluLW91dDt3aGl0ZS1zcGFjZTpub3dyYXB9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b246aG92ZXJ7YmFja2dyb3VuZDp2YXIoLS1hZy1jaGFydHMtZm9jdXMtY29sb3IpO3otaW5kZXg6MX0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbjpmb2N1cy12aXNpYmxle291dGxpbmU6dmFyKC0tYWctY2hhcnRzLWZvY3VzLWJvcmRlcik7Ym94LXNoYWRvdzp2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLXNoYWRvdyk7ei1pbmRleDpjYWxjKHZhcigtLWFnLWNoYXJ0cy1sYXllci11aS1vdmVybGF5KSArIDEpfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1hY3RpdmV7YmFja2dyb3VuZDp2YXIoLS1hZy1jaGFydHMtZm9jdXMtY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1hZy1jaGFydHMtYWNjZW50LWNvbG9yKTtjb2xvcjp2YXIoLS1hZy1jaGFydHMtYWNjZW50LWNvbG9yKTt6LWluZGV4OjJ9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b25bYXJpYS1kaXNhYmxlZD10cnVlXXtiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy1idXR0b24tZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcik7Y29sb3I6dmFyKC0tYWctY2hhcnRzLWJ1dHRvbi1kaXNhYmxlZC10ZXh0LWNvbG9yKTtjdXJzb3I6ZGVmYXVsdH0uYWctY2hhcnRzLXRvb2xiYXItLWhvcml6b250YWx7ZmxleC1kaXJlY3Rpb246cm93Oy5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9ue21hcmdpbjowIDAgMCAtMXB4fS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1maXJzdHtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1ib3JkZXItcmFkaXVzKTtib3JkZXItdG9wLWxlZnQtcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1ib3JkZXItcmFkaXVzKTttYXJnaW46MH0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tbGFzdHtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czp2YXIoLS1hZy1jaGFydHMtYm9yZGVyLXJhZGl1cyk7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJvcmRlci1yYWRpdXMpfX0uYWctY2hhcnRzLXRvb2xiYXItLXZlcnRpY2Fse2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjsuYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbnttYXJnaW46LTFweCAwIDA7bWF4LXdpZHRoOjEwMCV9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWZpcnN0e2JvcmRlci10b3AtbGVmdC1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJvcmRlci1yYWRpdXMpO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1ib3JkZXItcmFkaXVzKTttYXJnaW46MH0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tbGFzdHtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1ib3JkZXItcmFkaXVzKTtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czp2YXIoLS1hZy1jaGFydHMtYm9yZGVyLXJhZGl1cyl9fS5hZy1jaGFydHMtdG9vbGJhcl9faWNvbisuYWctY2hhcnRzLXRvb2xiYXJfX2xhYmVse21hcmdpbi1sZWZ0OnZhcigtLXRvb2xiYXItZ2FwKX0uYWctY2hhcnRzLXRvb2xiYXJfX2ljb24sLmFnLWNoYXJ0cy10b29sYmFyX19sYWJlbHtwb2ludGVyLWV2ZW50czpub25lfS5hZy1jaGFydHMtZmxvYXRpbmctdG9vbGJhcntib3JkZXI6bm9uZTtkaXNwbGF5OmZsZXg7LmFnLWNoYXJ0cy10b29sYmFye2FsaWduLWl0ZW1zOnVuc2V0O3Bvc2l0aW9uOnVuc2V0fX0uYWctY2hhcnRzLWZsb2F0aW5nLXRvb2xiYXJfX2RyYWctaGFuZGxle2FsaWduLWl0ZW1zOmNlbnRlcjtiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy1jaHJvbWUtYmFja2dyb3VuZC1jb2xvcik7Ym9yZGVyOnZhcigtLWFnLWNoYXJ0cy1ib3JkZXIpO2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJvcmRlci1yYWRpdXMpO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJvcmRlci1yYWRpdXMpO2N1cnNvcjpncmFiO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO21pbi13aWR0aDoyNHB4O3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6MH0uYWctY2hhcnRzLWZsb2F0aW5nLXRvb2xiYXJfX2RyYWctaGFuZGxlLS1kcmFnZ2luZ3tjdXJzb3I6Z3JhYmJpbmd9XFxuJztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9saXN0ZW5lcnMudHNcbnZhciBMaXN0ZW5lcnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgYWRkTGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgcmVjb3JkID0geyBzeW1ib2w6IFN5bWJvbChldmVudFR5cGUpLCBoYW5kbGVyIH07XG4gICAgaWYgKHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycy5oYXMoZXZlbnRUeXBlKSkge1xuICAgICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmdldChldmVudFR5cGUpLnB1c2gocmVjb3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLnNldChldmVudFR5cGUsIFtyZWNvcmRdKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHRoaXMucmVtb3ZlTGlzdGVuZXIocmVjb3JkLnN5bWJvbCk7XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXIoZXZlbnRTeW1ib2wpIHtcbiAgICBmb3IgKGNvbnN0IFt0eXBlLCBsaXN0ZW5lcnNdIG9mIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycy5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IG1hdGNoSW5kZXggPSBsaXN0ZW5lcnMuZmluZEluZGV4KChsaXN0ZW5lcikgPT4gbGlzdGVuZXIuc3ltYm9sID09PSBldmVudFN5bWJvbCk7XG4gICAgICBpZiAobWF0Y2hJbmRleCA+PSAwKSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UobWF0Y2hJbmRleCwgMSk7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGlzcGF0Y2goZXZlbnRUeXBlLCAuLi5wYXJhbXMpIHtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuZ2V0TGlzdGVuZXJzQnlUeXBlKGV2ZW50VHlwZSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyLmhhbmRsZXIoLi4ucGFyYW1zKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyX2V4cG9ydHMuZXJyb3JPbmNlKFN0cmluZyhlKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldExpc3RlbmVyc0J5VHlwZShldmVudFR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmdldChldmVudFR5cGUpID8/IFtdO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmNsZWFyKCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvYmFzZU1hbmFnZXIudHNcbnZhciBCYXNlTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gIH1cbiAgYWRkTGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5hZGRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubGlzdGVuZXJzLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2d1YXJkZWRFbGVtZW50LnRzXG52YXIgR3VhcmRlZEVsZW1lbnQgPSBjbGFzcyBfR3VhcmRlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50MiwgdG9wVGFiR3VhcmQsIGJvdHRvbVRhYkd1YXJkKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDI7XG4gICAgdGhpcy50b3BUYWJHdWFyZCA9IHRvcFRhYkd1YXJkO1xuICAgIHRoaXMuYm90dG9tVGFiR3VhcmQgPSBib3R0b21UYWJHdWFyZDtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLmd1YXJkVGFiSW5kZXggPSAwO1xuICAgIHRoaXMuaGFzRm9jdXMgPSBmYWxzZTtcbiAgICB0aGlzLmluaXRUYWJHdWFyZCh0aGlzLnRvcFRhYkd1YXJkLCAoZWwpID0+IHRoaXMub25UYWIoZWwsIGZhbHNlKSk7XG4gICAgdGhpcy5pbml0VGFiR3VhcmQodGhpcy5ib3R0b21UYWJHdWFyZCwgKGVsKSA9PiB0aGlzLm9uVGFiKGVsLCB0cnVlKSk7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCAoKSA9PiB0aGlzLm9uRm9jdXMoKSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoZXYpID0+IHRoaXMub25CbHVyKGV2KSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICB9XG4gIHNldCB0YWJJbmRleChpbmRleCkge1xuICAgIHRoaXMuZ3VhcmRUYWJJbmRleCA9IGluZGV4O1xuICAgIGlmICh0aGlzLmd1YXJkVGFiSW5kZXggPT09IDApIHtcbiAgICAgIHRoaXMuc2V0R3VhcmRJbmRpY2VzKHZvaWQgMCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5oYXNGb2N1cykge1xuICAgICAgdGhpcy5zZXRHdWFyZEluZGljZXModGhpcy5ndWFyZFRhYkluZGV4KTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIHRoaXMuZGVzdHJveUZucylcbiAgICAgIGZuKCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmxlbmd0aCA9IDA7XG4gIH1cbiAgaW5pdFRhYkd1YXJkKGd1YXJkLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgaGFuZGxlckJpbmRpbmcgPSAoKSA9PiBoYW5kbGVyKGd1YXJkKTtcbiAgICBndWFyZC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgaGFuZGxlckJpbmRpbmcpO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKCgpID0+IGd1YXJkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBoYW5kbGVyQmluZGluZykpO1xuICB9XG4gIHNldEd1YXJkSW5kaWNlcyhpbmRleCkge1xuICAgIGNvbnN0IHRhYmluZGV4ID0gaW5kZXg7XG4gICAgc2V0QXR0cmlidXRlKHRoaXMudG9wVGFiR3VhcmQsIFwidGFiaW5kZXhcIiwgdGFiaW5kZXgpO1xuICAgIHNldEF0dHJpYnV0ZSh0aGlzLmJvdHRvbVRhYkd1YXJkLCBcInRhYmluZGV4XCIsIHRhYmluZGV4KTtcbiAgfVxuICBvbkZvY3VzKCkge1xuICAgIHRoaXMuaGFzRm9jdXMgPSB0cnVlO1xuICAgIGlmICh0aGlzLmd1YXJkVGFiSW5kZXggIT09IDApIHtcbiAgICAgIHRoaXMuc2V0R3VhcmRJbmRpY2VzKDApO1xuICAgIH1cbiAgfVxuICBvbkJsdXIoeyByZWxhdGVkVGFyZ2V0IH0pIHtcbiAgICBjb25zdCB7IHRvcFRhYkd1YXJkOiB0b3AsIGJvdHRvbVRhYkd1YXJkOiBib3QgfSA9IHRoaXM7XG4gICAgdGhpcy5oYXNGb2N1cyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmd1YXJkVGFiSW5kZXggIT09IDAgJiYgcmVsYXRlZFRhcmdldCAhPT0gdG9wICYmIHJlbGF0ZWRUYXJnZXQgIT09IGJvdCkge1xuICAgICAgdGhpcy5zZXRHdWFyZEluZGljZXModGhpcy5ndWFyZFRhYkluZGV4KTtcbiAgICB9XG4gIH1cbiAgb25UYWIoZ3VhcmQsIHJldmVyc2UpIHtcbiAgICBpZiAodGhpcy5ndWFyZFRhYkluZGV4ICE9PSAwKSB7XG4gICAgICBsZXQgZm9jdXNUYXJnZXQ7XG4gICAgICBpZiAoZ3VhcmQudGFiSW5kZXggPT09IDApIHtcbiAgICAgICAgZm9jdXNUYXJnZXQgPSB0aGlzLmZpbmRFeGl0VGFyZ2V0KCFyZXZlcnNlKTtcbiAgICAgICAgdGhpcy5zZXRHdWFyZEluZGljZXModGhpcy5ndWFyZFRhYkluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvY3VzVGFyZ2V0ID0gdGhpcy5maW5kRW50ZXJUYXJnZXQocmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICBmb2N1c1RhcmdldD8uZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHF1ZXJ5Rm9jdXNhYmxlKGVsZW1lbnQyLCBzZWxlY3RvcnMpIHtcbiAgICBjb25zdCBteVdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQyLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3JzKSkuZmlsdGVyKChlKSA9PiB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gbXlXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlKTtcbiAgICAgICAgcmV0dXJuIHN0eWxlLmRpc3BsYXkgIT09IFwibm9uZVwiICYmIHN0eWxlLnZpc2liaWxpdHkgIT09IFwibm9uZVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICB9XG4gIGZpbmRFbnRlclRhcmdldChyZXZlcnNlKSB7XG4gICAgY29uc3QgZm9jdXNhYmxlcyA9IF9HdWFyZGVkRWxlbWVudC5xdWVyeUZvY3VzYWJsZSh0aGlzLmVsZW1lbnQsICdbdGFiaW5kZXg9XCIwXCJdJyk7XG4gICAgY29uc3QgaW5kZXggPSByZXZlcnNlID8gZm9jdXNhYmxlcy5sZW5ndGggLSAxIDogMDtcbiAgICByZXR1cm4gZm9jdXNhYmxlc1tpbmRleF07XG4gIH1cbiAgZmluZEV4aXRUYXJnZXQocmV2ZXJzZSkge1xuICAgIGNvbnN0IGZvY3VzYWJsZXMgPSBfR3VhcmRlZEVsZW1lbnQucXVlcnlGb2N1c2FibGUoZ2V0RG9jdW1lbnQoKSwgXCJbdGFiaW5kZXhdXCIpLmZpbHRlcigoZSkgPT4gZS50YWJJbmRleCA+IDApLnNvcnQoKGEsIGIpID0+IGEudGFiSW5kZXggLSBiLnRhYkluZGV4KTtcbiAgICBjb25zdCB7IGJlZm9yZSwgYWZ0ZXIgfSA9IF9HdWFyZGVkRWxlbWVudC5maW5kQmVmb3JlQW5kQWZ0ZXIoZm9jdXNhYmxlcywgdGhpcy5ndWFyZFRhYkluZGV4KTtcbiAgICByZXR1cm4gcmV2ZXJzZSA/IGJlZm9yZSA6IGFmdGVyO1xuICB9XG4gIHN0YXRpYyBmaW5kQmVmb3JlQW5kQWZ0ZXIoZWxlbWVudHMsIHRhcmdldFRhYkluZGV4KSB7XG4gICAgbGV0IGxlZnQgPSAwO1xuICAgIGxldCByaWdodCA9IGVsZW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgbGV0IGJlZm9yZSA9IHZvaWQgMDtcbiAgICBsZXQgYWZ0ZXIgPSB2b2lkIDA7XG4gICAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRUYWJJbmRleCA9IGVsZW1lbnRzW21pZF0udGFiSW5kZXg7XG4gICAgICBpZiAoY3VycmVudFRhYkluZGV4ID09PSB0YXJnZXRUYWJJbmRleCkge1xuICAgICAgICBiZWZvcmUgPSBlbGVtZW50c1ttaWQgLSAxXSB8fCB2b2lkIDA7XG4gICAgICAgIGFmdGVyID0gZWxlbWVudHNbbWlkICsgMV0gfHwgdm9pZCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudFRhYkluZGV4IDwgdGFyZ2V0VGFiSW5kZXgpIHtcbiAgICAgICAgYmVmb3JlID0gZWxlbWVudHNbbWlkXTtcbiAgICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZnRlciA9IGVsZW1lbnRzW21pZF07XG4gICAgICAgIHJpZ2h0ID0gbWlkIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYmVmb3JlLCBhZnRlciB9O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2tleW5hdlV0aWwudHNcbmZ1bmN0aW9uIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgZWxlbSwgdHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgY29uc3QgcmVtb3ZlciA9ICgpID0+IGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gIGRlc3Ryb3lGbnMucHVzaChyZW1vdmVyKTtcbiAgcmV0dXJuIHJlbW92ZXI7XG59XG5mdW5jdGlvbiBhZGRFc2NhcGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIGVsZW0sIG9uRXNjYXBlKSB7XG4gIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgZWxlbSwgXCJrZXlkb3duXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgIG9uRXNjYXBlKGV2ZW50KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkTW91c2VDbG9zZUxpc3RlbmVyKGRlc3Ryb3lGbnMsIG1lbnUsIGhpZGVDYWxsYmFjaykge1xuICBjb25zdCBzZWxmID0gYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCB3aW5kb3csIFwibW91c2Vkb3duXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChbMCwgMl0uaW5jbHVkZXMoZXZlbnQuYnV0dG9uKSAmJiAhY29udGFpbnNQb2ludDIobWVudSwgZXZlbnQpKSB7XG4gICAgICBoaWRlQ2FsbGJhY2soKTtcbiAgICAgIHNlbGYoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIGFkZFRvdWNoQ2xvc2VMaXN0ZW5lcihkZXN0cm95Rm5zLCBtZW51LCBoaWRlQ2FsbGJhY2spIHtcbiAgY29uc3Qgc2VsZiA9IGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgd2luZG93LCBcInRvdWNoc3RhcnRcIiwgKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgdG91Y2hlcyA9IEFycmF5LmZyb20oZXZlbnQudGFyZ2V0VG91Y2hlcyk7XG4gICAgaWYgKHRvdWNoZXMuc29tZSgodG91Y2gpID0+ICFjb250YWluc1BvaW50MihtZW51LCB0b3VjaCkpKSB7XG4gICAgICBoaWRlQ2FsbGJhY2soKTtcbiAgICAgIHNlbGYoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zUG9pbnQyKGNvbnRhaW5lciwgZXZlbnQpIHtcbiAgaWYgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHsgY2xpZW50WDogZXgsIGNsaWVudFk6IGV5IH0gPSBldmVudDtcbiAgICByZXR1cm4gZXggPj0geCAmJiBleSA+PSB5ICYmIGV4IDw9IHggKyB3aWR0aDIgJiYgZXkgPD0geSArIGhlaWdodDI7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaGFzTm9Nb2RpZmllcnMoZXZlbnQpIHtcbiAgcmV0dXJuICEoZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSk7XG59XG5mdW5jdGlvbiBtYXRjaGVzS2V5KGV2ZW50LCBrZXksIC4uLm1vcmVrZXlzKSB7XG4gIHJldHVybiBoYXNOb01vZGlmaWVycyhldmVudCkgJiYgKGV2ZW50LmtleSA9PT0ga2V5IHx8IG1vcmVrZXlzLnNvbWUoKGFsdGtleSkgPT4gZXZlbnQua2V5ID09PSBhbHRrZXkpKTtcbn1cbmZ1bmN0aW9uIGxpbmtUd29CdXR0b25zKGRlc3Ryb3lGbnMsIHNyYywgZHN0LCBrZXkpIHtcbiAgaWYgKCFkc3QpXG4gICAgcmV0dXJuO1xuICBhZGRSZW1vdmFibGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIHNyYywgXCJrZXlkb3duXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChtYXRjaGVzS2V5KGV2ZW50LCBrZXkpKSB7XG4gICAgICBkc3QuZm9jdXMoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbGlua1RocmVlQnV0dG9ucyhkZXN0cm95Rm5zLCBjdXJyLCBuZXh0LCBuZXh0S2V5LCBwcmV2LCBwcmV2S2V5KSB7XG4gIGxpbmtUd29CdXR0b25zKGRlc3Ryb3lGbnMsIGN1cnIsIHByZXYsIHByZXZLZXkpO1xuICBsaW5rVHdvQnV0dG9ucyhkZXN0cm95Rm5zLCBjdXJyLCBuZXh0LCBuZXh0S2V5KTtcbiAgYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBjdXJyLCBcImtleWRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgaWYgKG1hdGNoZXNLZXkoZXZlbnQsIG5leHRLZXksIHByZXZLZXkpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSk7XG59XG52YXIgUFJFVl9ORVhUX0tFWVMgPSB7XG4gIGhvcml6b250YWw6IHsgbmV4dEtleTogXCJBcnJvd1JpZ2h0XCIsIHByZXZLZXk6IFwiQXJyb3dMZWZ0XCIgfSxcbiAgdmVydGljYWw6IHsgbmV4dEtleTogXCJBcnJvd0Rvd25cIiwgcHJldktleTogXCJBcnJvd1VwXCIgfVxufTtcbmZ1bmN0aW9uIGluaXRSb3ZpbmdUYWJJbmRleChvcHRzKSB7XG4gIGNvbnN0IHsgb3JpZW50YXRpb24sIGJ1dHRvbnMsIHdyYXBBcm91bmQgPSBmYWxzZSwgb25Fc2NhcGUsIG9uRm9jdXMsIG9uQmx1ciB9ID0gb3B0cztcbiAgY29uc3QgeyBuZXh0S2V5LCBwcmV2S2V5IH0gPSBQUkVWX05FWFRfS0VZU1tvcmllbnRhdGlvbl07XG4gIGNvbnN0IHNldFRhYkluZGljZXMgPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICYmIFwidGFiSW5kZXhcIiBpbiBldmVudC50YXJnZXQpIHtcbiAgICAgIGJ1dHRvbnMuZm9yRWFjaCgoYikgPT4gYi50YWJJbmRleCA9IC0xKTtcbiAgICAgIGV2ZW50LnRhcmdldC50YWJJbmRleCA9IDA7XG4gICAgfVxuICB9O1xuICBjb25zdCBbYywgbV0gPSB3cmFwQXJvdW5kID8gW2J1dHRvbnMubGVuZ3RoLCBidXR0b25zLmxlbmd0aF0gOiBbMCwgSW5maW5pdHldO1xuICBjb25zdCBkZXN0cm95Rm5zID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnV0dG9ucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByZXYgPSBidXR0b25zWyhjICsgaSAtIDEpICUgbV07XG4gICAgY29uc3QgY3VyciA9IGJ1dHRvbnNbaV07XG4gICAgY29uc3QgbmV4dCA9IGJ1dHRvbnNbKGMgKyBpICsgMSkgJSBtXTtcbiAgICBhZGRSZW1vdmFibGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIGN1cnIsIFwiZm9jdXNcIiwgc2V0VGFiSW5kaWNlcyk7XG4gICAgaWYgKG9uRm9jdXMpXG4gICAgICBhZGRSZW1vdmFibGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIGN1cnIsIFwiZm9jdXNcIiwgb25Gb2N1cyk7XG4gICAgaWYgKG9uQmx1cilcbiAgICAgIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgY3VyciwgXCJibHVyXCIsIG9uQmx1cik7XG4gICAgaWYgKG9uRXNjYXBlKVxuICAgICAgYWRkRXNjYXBlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBjdXJyLCBvbkVzY2FwZSk7XG4gICAgbGlua1RocmVlQnV0dG9ucyhkZXN0cm95Rm5zLCBjdXJyLCBuZXh0LCBuZXh0S2V5LCBwcmV2LCBwcmV2S2V5KTtcbiAgICBjdXJyLnRhYkluZGV4ID0gaSA9PT0gMCA/IDAgOiAtMTtcbiAgfVxuICByZXR1cm4gZGVzdHJveUZucztcbn1cbnZhciBNZW51Q2xvc2VySW1wID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihtZW51LCBsYXN0Rm9jdXMsIGNsb3NlQ2FsbGJhY2spIHtcbiAgICB0aGlzLmxhc3RGb2N1cyA9IGxhc3RGb2N1cztcbiAgICB0aGlzLmNsb3NlQ2FsbGJhY2sgPSBjbG9zZUNhbGxiYWNrO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKGFkZE1vdXNlQ2xvc2VMaXN0ZW5lcih0aGlzLmRlc3Ryb3lGbnMsIG1lbnUsICgpID0+IHRoaXMuY2xvc2UodHJ1ZSkpKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChhZGRUb3VjaENsb3NlTGlzdGVuZXIodGhpcy5kZXN0cm95Rm5zLCBtZW51LCAoKSA9PiB0aGlzLmNsb3NlKHRydWUpKSk7XG4gIH1cbiAgY2xvc2UobW91c2Vkb3duKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGQpID0+IGQoKSk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jbG9zZUNhbGxiYWNrKCk7XG4gICAgdGhpcy5maW5pc2hDbG9zaW5nKG1vdXNlZG93bik7XG4gIH1cbiAgZmluaXNoQ2xvc2luZyhtb3VzZWRvd24pIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZCkgPT4gZCgpKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMubGVuZ3RoID0gMDtcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5sYXN0Rm9jdXMsIFwiYXJpYS1leHBhbmRlZFwiLCBmYWxzZSk7XG4gICAgaWYgKCFtb3VzZWRvd24pIHtcbiAgICAgIHRoaXMubGFzdEZvY3VzPy5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgfVxuICAgIHRoaXMubGFzdEZvY3VzID0gdm9pZCAwO1xuICB9XG59O1xuZnVuY3Rpb24gaW5pdE1lbnVLZXlOYXYob3B0cykge1xuICBjb25zdCB7XG4gICAgc291cmNlRXZlbnQsXG4gICAgb3JpZW50YXRpb24sXG4gICAgbWVudSxcbiAgICBidXR0b25zLFxuICAgIGNsb3NlQ2FsbGJhY2ssXG4gICAgb3ZlcnJpZGVGb2N1c1Zpc2libGUsXG4gICAgYXV0b0Nsb3NlT25CbHVyID0gZmFsc2VcbiAgfSA9IG9wdHM7XG4gIGNvbnN0IHsgbmV4dEtleSwgcHJldktleSB9ID0gUFJFVl9ORVhUX0tFWVNbb3JpZW50YXRpb25dO1xuICBjb25zdCBsYXN0Rm9jdXMgPSBnZXRMYXN0Rm9jdXMoc291cmNlRXZlbnQpO1xuICBzZXRBdHRyaWJ1dGUobGFzdEZvY3VzLCBcImFyaWEtZXhwYW5kZWRcIiwgdHJ1ZSk7XG4gIGNvbnN0IG1lbnVDbG9zZXIgPSBuZXcgTWVudUNsb3NlckltcChtZW51LCBsYXN0Rm9jdXMsIGNsb3NlQ2FsbGJhY2spO1xuICBjb25zdCBvbkVzY2FwZSA9ICgpID0+IG1lbnVDbG9zZXIuY2xvc2UoKTtcbiAgY29uc3QgeyBkZXN0cm95Rm5zIH0gPSBtZW51Q2xvc2VyO1xuICBtZW51LnJvbGUgPSBcIm1lbnVcIjtcbiAgbWVudS5hcmlhT3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgZGVzdHJveUZucy5wdXNoKC4uLmluaXRSb3ZpbmdUYWJJbmRleCh7IG9yaWVudGF0aW9uLCBidXR0b25zLCBvbkVzY2FwZSwgd3JhcEFyb3VuZDogdHJ1ZSB9KSk7XG4gIG1lbnUudGFiSW5kZXggPSAtMTtcbiAgYWRkRXNjYXBlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBtZW51LCBvbkVzY2FwZSk7XG4gIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgbWVudSwgXCJrZXlkb3duXCIsIChldikgPT4ge1xuICAgIGlmIChldi50YXJnZXQgPT09IG1lbnUgJiYgKGV2LmtleSA9PT0gbmV4dEtleSB8fCBldi5rZXkgPT09IHByZXZLZXkpKSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgYnV0dG9uc1swXT8uZm9jdXMoKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoYXV0b0Nsb3NlT25CbHVyKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IChldikgPT4ge1xuICAgICAgY29uc3QgYnV0dG9uQXJyYXkgPSBidXR0b25zO1xuICAgICAgY29uc3QgaXNMZWF2aW5nTWVudSA9ICFidXR0b25BcnJheS5pbmNsdWRlcyhldi5yZWxhdGVkVGFyZ2V0KTtcbiAgICAgIGlmIChpc0xlYXZpbmdNZW51KSB7XG4gICAgICAgIG9uRXNjYXBlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGJ1dHRvbiBvZiBidXR0b25zKSB7XG4gICAgICBhZGRSZW1vdmFibGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIGJ1dHRvbiwgXCJibHVyXCIsIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxuICBidXR0b25zWzBdPy5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gIGlmIChvdmVycmlkZUZvY3VzVmlzaWJsZSAhPT0gdm9pZCAwKSB7XG4gICAgYnV0dG9ucy5mb3JFYWNoKChiKSA9PiBiLnNldEF0dHJpYnV0ZShcImRhdGEtZm9jdXMtdmlzaWJsZS1vdmVycmlkZVwiLCBvdmVycmlkZUZvY3VzVmlzaWJsZS50b1N0cmluZygpKSk7XG4gICAgY29uc3Qga2V5ZG93blRydWVPdmVycmlkZXIgPSAoKSA9PiB7XG4gICAgICBidXR0b25zLmZvckVhY2goKGIpID0+IGIuc2V0QXR0cmlidXRlKFwiZGF0YS1mb2N1cy12aXNpYmxlLW92ZXJyaWRlXCIsIFwidHJ1ZVwiKSk7XG4gICAgfTtcbiAgICBhZGRSZW1vdmFibGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIG1lbnUsIFwia2V5ZG93blwiLCBrZXlkb3duVHJ1ZU92ZXJyaWRlciwgeyBvbmNlOiB0cnVlIH0pO1xuICB9XG4gIHJldHVybiBtZW51Q2xvc2VyO1xufVxuZnVuY3Rpb24gbWFrZUFjY2Vzc2libGVDbGlja0xpc3RlbmVyKGVsZW1lbnQyLCBvbmNsaWNrKSB7XG4gIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICBpZiAoZWxlbWVudDIuYXJpYURpc2FibGVkID09PSBcInRydWVcIikge1xuICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIG9uY2xpY2soZXZlbnQpO1xuICB9O1xufVxuZnVuY3Rpb24gaXNCdXR0b25DbGlja0V2ZW50KGV2ZW50KSB7XG4gIGlmIChcImJ1dHRvblwiIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmJ1dHRvbiA9PT0gMDtcbiAgfVxuICByZXR1cm4gaGFzTm9Nb2RpZmllcnMoZXZlbnQpICYmIChldmVudC5jb2RlID09PSBcIlNwYWNlXCIgfHwgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpO1xufVxuZnVuY3Rpb24gZ2V0TGFzdEZvY3VzKHNvdXJjZUV2ZW50KSB7XG4gIGlmIChzb3VyY2VFdmVudD8udGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgXCJ0YWJpbmRleFwiIGluIHNvdXJjZUV2ZW50LnRhcmdldC5hdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIHNvdXJjZUV2ZW50LnRhcmdldDtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gc3RvcFBhZ2VTY3JvbGxpbmcoZWxlbWVudDIpIHtcbiAgY29uc3QgaGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHNob3VsZFByZXZlbnQgPSBnZXRBdHRyaWJ1dGUoZXZlbnQudGFyZ2V0LCBcImRhdGEtcHJldmVudGRlZmF1bHRcIiwgdHJ1ZSk7XG4gICAgaWYgKHNob3VsZFByZXZlbnQgJiYgbWF0Y2hlc0tleShldmVudCwgXCJBcnJvd1JpZ2h0XCIsIFwiQXJyb3dMZWZ0XCIsIFwiQXJyb3dEb3duXCIsIFwiQXJyb3dVcFwiKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07XG4gIGVsZW1lbnQyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZXIpO1xuICByZXR1cm4gKCkgPT4gZWxlbWVudDIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlcik7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvcGl4ZWxSYXRpb09ic2VydmVyLnRzXG52YXIgUGl4ZWxSYXRpb09ic2VydmVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjYWxsYmFjazIpIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2syO1xuICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IGdldFdpbmRvdyhcImRldmljZVBpeGVsUmF0aW9cIikgPz8gMTtcbiAgICB0aGlzLmRldmljZVBpeGVsUmF0aW9NZWRpYVF1ZXJ5ID0gdm9pZCAwO1xuICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpb0xpc3RlbmVyID0gKGUpID0+IHtcbiAgICAgIGlmIChlLm1hdGNoZXMpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IGdldFdpbmRvdyhcImRldmljZVBpeGVsUmF0aW9cIikgPz8gMTtcbiAgICAgIHRoaXMudW5yZWdpc3RlckRldmljZVBpeGVsUmF0aW9MaXN0ZW5lcigpO1xuICAgICAgdGhpcy5yZWdpc3RlckRldmljZVBpeGVsUmF0aW9MaXN0ZW5lcigpO1xuICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLnBpeGVsUmF0aW8pO1xuICAgIH07XG4gIH1cbiAgZ2V0IHBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxuICBvYnNlcnZlKCkge1xuICAgIHRoaXMucmVnaXN0ZXJEZXZpY2VQaXhlbFJhdGlvTGlzdGVuZXIoKTtcbiAgfVxuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMudW5yZWdpc3RlckRldmljZVBpeGVsUmF0aW9MaXN0ZW5lcigpO1xuICB9XG4gIHVucmVnaXN0ZXJEZXZpY2VQaXhlbFJhdGlvTGlzdGVuZXIoKSB7XG4gICAgdGhpcy5kZXZpY2VQaXhlbFJhdGlvTWVkaWFRdWVyeT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLmRldmljZVBpeGVsUmF0aW9MaXN0ZW5lcik7XG4gICAgdGhpcy5kZXZpY2VQaXhlbFJhdGlvTWVkaWFRdWVyeSA9IHZvaWQgMDtcbiAgfVxuICByZWdpc3RlckRldmljZVBpeGVsUmF0aW9MaXN0ZW5lcigpIHtcbiAgICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvTWVkaWFRdWVyeSA9IGdldFdpbmRvdyhcIm1hdGNoTWVkaWFcIik/LihgKHJlc29sdXRpb246ICR7dGhpcy5waXhlbFJhdGlvfWRwcHgpYCk7XG4gICAgZGV2aWNlUGl4ZWxSYXRpb01lZGlhUXVlcnk/LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5kZXZpY2VQaXhlbFJhdGlvTGlzdGVuZXIpO1xuICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpb01lZGlhUXVlcnkgPSBkZXZpY2VQaXhlbFJhdGlvTWVkaWFRdWVyeTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9zaXplTW9uaXRvci50c1xudmFyIFNpemVNb25pdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmRvY3VtZW50UmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLnF1ZXVlZE9ic2VydmVSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMub25Mb2FkID0gKCkgPT4ge1xuICAgICAgdGhpcy5kb2N1bWVudFJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMucXVldWVkT2JzZXJ2ZVJlcXVlc3RzLmZvckVhY2goKFtlbCwgY2JdKSA9PiB0aGlzLm9ic2VydmUoZWwsIGNiKSk7XG4gICAgICB0aGlzLnF1ZXVlZE9ic2VydmVSZXF1ZXN0cyA9IFtdO1xuICAgICAgdGhpcy5vYnNlcnZlV2luZG93KCk7XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBjb250ZW50UmVjdDogeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfVxuICAgICAgICB9IG9mIGVudHJpZXMpIHtcbiAgICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZWxlbWVudHMuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgdGhpcy5jaGVja1NpemUoZW50cnksIHRhcmdldCwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBhbmltYXRpb25GcmFtZTtcbiAgICB0aGlzLnBpeGVsUmF0aW9PYnNlcnZlciA9IG5ldyBQaXhlbFJhdGlvT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvbkZyYW1lKTtcbiAgICAgIGFuaW1hdGlvbkZyYW1lID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmNoZWNrUGl4ZWxSYXRpbygpLCAwKTtcbiAgICB9KTtcbiAgICB0aGlzLmRvY3VtZW50UmVhZHkgPSBnZXREb2N1bWVudChcInJlYWR5U3RhdGVcIikgPT09IFwiY29tcGxldGVcIjtcbiAgICBpZiAodGhpcy5kb2N1bWVudFJlYWR5KSB7XG4gICAgICB0aGlzLm9ic2VydmVXaW5kb3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2V0V2luZG93KCk/LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRoaXMub25Mb2FkKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBnZXRXaW5kb3coKT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdGhpcy5vbkxvYWQpO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMucGl4ZWxSYXRpb09ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5waXhlbFJhdGlvT2JzZXJ2ZXIgPSB2b2lkIDA7XG4gIH1cbiAgb2JzZXJ2ZVdpbmRvdygpIHtcbiAgICB0aGlzLnBpeGVsUmF0aW9PYnNlcnZlcj8ub2JzZXJ2ZSgpO1xuICB9XG4gIGNoZWNrUGl4ZWxSYXRpbygpIHtcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gdGhpcy5waXhlbFJhdGlvT2JzZXJ2ZXI/LnBpeGVsUmF0aW8gPz8gMTtcbiAgICBmb3IgKGNvbnN0IFtlbGVtZW50MiwgZW50cnldIG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgIGlmIChlbnRyeS5zaXplICE9IG51bGwgJiYgZW50cnkuc2l6ZS5waXhlbFJhdGlvICE9PSBwaXhlbFJhdGlvKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSBlbnRyeS5zaXplO1xuICAgICAgICBlbnRyeS5zaXplID0geyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIHBpeGVsUmF0aW8gfTtcbiAgICAgICAgZW50cnkuY2IoZW50cnkuc2l6ZSwgZWxlbWVudDIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjaGVja1NpemUoZW50cnksIGVsZW1lbnQyLCB3aWR0aDIsIGhlaWdodDIpIHtcbiAgICBpZiAoIWVudHJ5KVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh3aWR0aDIgIT09IGVudHJ5LnNpemU/LndpZHRoIHx8IGhlaWdodDIgIT09IGVudHJ5LnNpemU/LmhlaWdodCkge1xuICAgICAgY29uc3QgcGl4ZWxSYXRpbyA9IHRoaXMucGl4ZWxSYXRpb09ic2VydmVyPy5waXhlbFJhdGlvID8/IDE7XG4gICAgICBlbnRyeS5zaXplID0geyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIHBpeGVsUmF0aW8gfTtcbiAgICAgIGVudHJ5LmNiKGVudHJ5LnNpemUsIGVsZW1lbnQyKTtcbiAgICB9XG4gIH1cbiAgLy8gT25seSBhIHNpbmdsZSBjYWxsYmFjayBpcyBzdXBwb3J0ZWQuXG4gIG9ic2VydmUoZWxlbWVudDIsIGNiKSB7XG4gICAgaWYgKCF0aGlzLmRvY3VtZW50UmVhZHkpIHtcbiAgICAgIHRoaXMucXVldWVkT2JzZXJ2ZVJlcXVlc3RzLnB1c2goW2VsZW1lbnQyLCBjYl0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbGVtZW50cy5oYXMoZWxlbWVudDIpKSB7XG4gICAgICB0aGlzLnJlbW92ZUZyb21RdWV1ZShlbGVtZW50Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXI/Lm9ic2VydmUoZWxlbWVudDIpO1xuICAgIH1cbiAgICBjb25zdCBlbnRyeSA9IHsgY2IgfTtcbiAgICB0aGlzLmVsZW1lbnRzLnNldChlbGVtZW50MiwgZW50cnkpO1xuICB9XG4gIHVub2JzZXJ2ZShlbGVtZW50Mikge1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXI/LnVub2JzZXJ2ZShlbGVtZW50Mik7XG4gICAgdGhpcy5lbGVtZW50cy5kZWxldGUoZWxlbWVudDIpO1xuICAgIHRoaXMucmVtb3ZlRnJvbVF1ZXVlKGVsZW1lbnQyKTtcbiAgICBpZiAoIXRoaXMuZWxlbWVudHMuc2l6ZSkge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICB9XG4gIHJlbW92ZUZyb21RdWV1ZShlbGVtZW50Mikge1xuICAgIHRoaXMucXVldWVkT2JzZXJ2ZVJlcXVlc3RzID0gdGhpcy5xdWV1ZWRPYnNlcnZlUmVxdWVzdHMuZmlsdGVyKChbZWxdKSA9PiBlbCAhPT0gZWxlbWVudDIpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3N0YXRlVHJhY2tlci50c1xudmFyIFN0YXRlVHJhY2tlciA9IGNsYXNzIGV4dGVuZHMgTWFwIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdFZhbHVlLCBkZWZhdWx0U3RhdGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0gZGVmYXVsdFN0YXRlO1xuICB9XG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5kZWxldGUoa2V5KTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0YXRlSWQoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5rZXlzKCkpLnBvcCgpID8/IHRoaXMuZGVmYXVsdFN0YXRlO1xuICB9XG4gIHN0YXRlVmFsdWUoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy52YWx1ZXMoKSkucG9wKCkgPz8gdGhpcy5kZWZhdWx0VmFsdWU7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2RvbS9kb21MYXlvdXQuaHRtbFxudmFyIGRvbUxheW91dF9kZWZhdWx0ID0gJzxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGNsYXNzPVwiYWctY2hhcnRzLXdyYXBwZXIgYWctY2hhcnRzLXN0eWxlc1wiIGRhdGEtYWctY2hhcnRzPjxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGNsYXNzPVwiYWctY2hhcnRzLWNhbnZhcy1jZW50ZXJcIj48ZGl2IHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cImFnLWNoYXJ0cy1jYW52YXMtY29udGFpbmVyXCI+PGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJhZy1jaGFydHMtY2FudmFzXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9kaXY+PGRpdiByb2xlPVwiZmlndXJlXCIgY2xhc3M9XCJhZy1jaGFydHMtY2FudmFzLXByb3h5XCI+PGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJhZy1jaGFydHMtc2VyaWVzLWFyZWFcIj48L2Rpdj48L2Rpdj48ZGl2IHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cImFnLWNoYXJ0cy1jYW52YXMtb3ZlcmxheVwiPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2Pic7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2RvbS9kb21NYW5hZ2VyLnRzXG52YXIgRE9NX0VMRU1FTlRfQ0xBU1NFUyA9IFtcbiAgXCJzdHlsZXNcIixcbiAgXCJjYW52YXNcIixcbiAgXCJjYW52YXMtY2VudGVyXCIsXG4gIFwiY2FudmFzLWNvbnRhaW5lclwiLFxuICBcImNhbnZhcy1vdmVybGF5XCIsXG4gIFwiY2FudmFzLXByb3h5XCIsXG4gIFwic2VyaWVzLWFyZWFcIlxuXTtcbnZhciBDT05UQUlORVJfTU9ESUZJRVJTID0ge1xuICBzYWZlSG9yaXpvbnRhbDogXCJhZy1jaGFydHMtd3JhcHBlci0tc2FmZS1ob3Jpem9udGFsXCIsXG4gIHNhZmVWZXJ0aWNhbDogXCJhZy1jaGFydHMtd3JhcHBlci0tc2FmZS12ZXJ0aWNhbFwiXG59O1xudmFyIGRvbUVsZW1lbnRDb25maWcgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFtcInN0eWxlc1wiLCB7IGNoaWxkRWxlbWVudFR5cGU6IFwic3R5bGVcIiB9XSxcbiAgW1wiY2FudmFzXCIsIHsgY2hpbGRFbGVtZW50VHlwZTogXCJjYW52YXNcIiB9XSxcbiAgW1wiY2FudmFzLXByb3h5XCIsIHsgY2hpbGRFbGVtZW50VHlwZTogXCJkaXZcIiB9XSxcbiAgW1wiY2FudmFzLW92ZXJsYXlcIiwgeyBjaGlsZEVsZW1lbnRUeXBlOiBcImRpdlwiIH1dLFxuICBbXCJjYW52YXMtY2VudGVyXCIsIHsgY2hpbGRFbGVtZW50VHlwZTogXCJkaXZcIiB9XSxcbiAgW1wic2VyaWVzLWFyZWFcIiwgeyBjaGlsZEVsZW1lbnRUeXBlOiBcImRpdlwiIH1dXG5dKTtcbmZ1bmN0aW9uIHNldHVwT2JzZXJ2ZXIoZWxlbWVudDIsIGNiKSB7XG4gIGlmICh0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgcmV0dXJuO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAoZW50cmllcykgPT4ge1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGlmIChlbnRyeS50YXJnZXQgPT09IGVsZW1lbnQyKSB7XG4gICAgICAgICAgY2IoZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB7IHJvb3Q6IGVsZW1lbnQyIH1cbiAgKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50Mik7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbnZhciBOVUxMX0RPTVJFQ1QgPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIHRvcDogMCxcbiAgYm90dG9tOiAwLFxuICBsZWZ0OiAwLFxuICByaWdodDogMCxcbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBOVUxMX0RPTVJFQ1Q7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVUYWJHdWFyZEVsZW1lbnQoZ3VhcmRlZEVsZW0sIHdoZXJlKSB7XG4gIGNvbnN0IGRpdiA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGRpdi5jbGFzc05hbWUgPSBcImFnLWNoYXJ0cy10YWItZ3VhcmRcIjtcbiAgZ3VhcmRlZEVsZW0uaW5zZXJ0QWRqYWNlbnRFbGVtZW50KHdoZXJlLCBkaXYpO1xuICByZXR1cm4gZGl2O1xufVxudmFyIERPTU1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY29udGFpbmVyLCBzdHlsZUNvbnRhaW5lcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zdHlsZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29udGFpbmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29udGFpbmVyU2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpemVNb25pdG9yID0gbmV3IFNpemVNb25pdG9yKCk7XG4gICAgdGhpcy5jdXJzb3JTdGF0ZSA9IG5ldyBTdGF0ZVRyYWNrZXIoXCJkZWZhdWx0XCIpO1xuICAgIHRoaXMubWluV2lkdGggPSAwO1xuICAgIHRoaXMubWluSGVpZ2h0ID0gMDtcbiAgICBjb25zdCB0ZW1wbGF0ZUVsID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0ZW1wbGF0ZUVsLmlubmVySFRNTCA9IGRvbUxheW91dF9kZWZhdWx0O1xuICAgIHRoaXMuZWxlbWVudCA9IHRlbXBsYXRlRWwuY2hpbGRyZW4uaXRlbSgwKTtcbiAgICB0aGlzLnN0eWxlUm9vdEVsZW1lbnQgPSBzdHlsZUNvbnRhaW5lcjtcbiAgICB0aGlzLnJvb3RFbGVtZW50cyA9IERPTV9FTEVNRU5UX0NMQVNTRVMucmVkdWNlKFxuICAgICAgKHIsIGMpID0+IHtcbiAgICAgICAgY29uc3QgY3NzQ2xhc3MgPSBgYWctY2hhcnRzLSR7Y31gO1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY3NzQ2xhc3MpID8gdGhpcy5lbGVtZW50IDogdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoYC4ke2Nzc0NsYXNzfWApO1xuICAgICAgICBpZiAoIWVsKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gdW5hYmxlIHRvIGZpbmQgRE9NIGVsZW1lbnQgJHtjc3NDbGFzc31gKTtcbiAgICAgICAgcltjXSA9IHsgZWxlbWVudDogZWwsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBsaXN0ZW5lcnM6IFtdIH07XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICBsZXQgaGlkZGVuID0gZmFsc2U7XG4gICAgdGhpcy5vYnNlcnZlciA9IHNldHVwT2JzZXJ2ZXIodGhpcy5lbGVtZW50LCAoaW50ZXJzZWN0aW9uUmF0aW8pID0+IHtcbiAgICAgIGlmIChpbnRlcnNlY3Rpb25SYXRpbyA9PT0gMCAmJiAhaGlkZGVuKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiaGlkZGVuXCIsIHsgdHlwZTogXCJoaWRkZW5cIiB9KTtcbiAgICAgIH1cbiAgICAgIGhpZGRlbiA9IGludGVyc2VjdGlvblJhdGlvID09PSAwO1xuICAgIH0pO1xuICAgIHRoaXMuc2V0U2l6ZU9wdGlvbnMoKTtcbiAgICB0aGlzLnVwZGF0ZUNvbnRhaW5lclNpemUoKTtcbiAgICB0aGlzLmFkZFN0eWxlcyhcImFnLWNoYXJ0cy1jb21tdW5pdHlcIiwgc3R5bGVzX2RlZmF1bHQpO1xuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIHRoaXMuc2V0Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKHN0b3BQYWdlU2Nyb2xsaW5nKHRoaXMuZWxlbWVudCkpO1xuICAgIGNvbnN0IGd1YXJkZWRFbGVtZW50ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuYWctY2hhcnRzLWNhbnZhcy1jZW50ZXJcIik7XG4gICAgaWYgKGd1YXJkZWRFbGVtZW50ID09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbml0aWFsaXppbmcgdGFiIGd1YXJkc1wiKTtcbiAgICBjb25zdCB0b3BHdWFyZCA9IGNyZWF0ZVRhYkd1YXJkRWxlbWVudChndWFyZGVkRWxlbWVudCwgXCJiZWZvcmViZWdpblwiKTtcbiAgICBjb25zdCBib3RHdWFyZCA9IGNyZWF0ZVRhYkd1YXJkRWxlbWVudChndWFyZGVkRWxlbWVudCwgXCJhZnRlcmVuZFwiKTtcbiAgICB0aGlzLnRhYkd1YXJkcyA9IG5ldyBHdWFyZGVkRWxlbWVudChndWFyZGVkRWxlbWVudCwgdG9wR3VhcmQsIGJvdEd1YXJkKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLm9ic2VydmVyPy51bm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuc2l6ZU1vbml0b3IudW5vYnNlcnZlKHRoaXMuY29udGFpbmVyKTtcbiAgICB9XG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLnJvb3RFbGVtZW50cykuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGVsLmNoaWxkcmVuLmZvckVhY2goKGMpID0+IGMucmVtb3ZlKCkpO1xuICAgICAgZWwuZWxlbWVudC5yZW1vdmUoKTtcbiAgICB9KTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlKCk7XG4gIH1cbiAgc2V0U2l6ZU9wdGlvbnMobWluV2lkdGggPSAzMDAsIG1pbkhlaWdodCA9IDMwMCwgb3B0aW9uc1dpZHRoLCBvcHRpb25zSGVpZ2h0KSB7XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gdGhpcy5lbGVtZW50O1xuICAgIHN0eWxlLndpZHRoID0gYCR7b3B0aW9uc1dpZHRoID8/IG1pbldpZHRofXB4YDtcbiAgICBzdHlsZS5oZWlnaHQgPSBgJHtvcHRpb25zSGVpZ2h0ID8/IG1pbkhlaWdodH1weGA7XG4gICAgdGhpcy5taW5XaWR0aCA9IG9wdGlvbnNXaWR0aCA/PyBtaW5XaWR0aDtcbiAgICB0aGlzLm1pbkhlaWdodCA9IG9wdGlvbnNIZWlnaHQgPz8gbWluSGVpZ2h0O1xuICAgIHRoaXMudXBkYXRlQ29udGFpbmVyQ2xhc3NOYW1lKCk7XG4gIH1cbiAgdXBkYXRlQ29udGFpbmVyU2l6ZSgpIHtcbiAgICBjb25zdCB7IHN0eWxlOiBjZW50ZXJTdHlsZSB9ID0gdGhpcy5yb290RWxlbWVudHNbXCJjYW52YXMtY2VudGVyXCJdLmVsZW1lbnQ7XG4gICAgY2VudGVyU3R5bGUudmlzaWJpbGl0eSA9IHRoaXMuY29udGFpbmVyU2l6ZSA9PSBudWxsID8gXCJoaWRkZW5cIiA6IFwiXCI7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyU2l6ZSkge1xuICAgICAgY2VudGVyU3R5bGUud2lkdGggPSBgJHt0aGlzLmNvbnRhaW5lclNpemUud2lkdGggPz8gMH1weGA7XG4gICAgICBjZW50ZXJTdHlsZS5oZWlnaHQgPSBgJHt0aGlzLmNvbnRhaW5lclNpemUuaGVpZ2h0ID8/IDB9cHhgO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZW50ZXJTdHlsZS53aWR0aCA9IFwiXCI7XG4gICAgICBjZW50ZXJTdHlsZS5oZWlnaHQgPSBcIlwiO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUNvbnRhaW5lckNsYXNzTmFtZSgpO1xuICB9XG4gIHNldFRhYkd1YXJkSW5kZXgodGFiSW5kZXgpIHtcbiAgICB0aGlzLnRhYkd1YXJkcy50YWJJbmRleCA9IHRhYkluZGV4O1xuICB9XG4gIHNldENvbnRhaW5lcihuZXdDb250YWluZXIpIHtcbiAgICBpZiAobmV3Q29udGFpbmVyID09PSB0aGlzLmNvbnRhaW5lcilcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICB0aGlzLnNpemVNb25pdG9yLnVub2JzZXJ2ZSh0aGlzLmNvbnRhaW5lcik7XG4gICAgfVxuICAgIGNvbnN0IGlzU2hhZG93RG9tID0gdGhpcy5nZXRTaGFkb3dEb2N1bWVudFJvb3QobmV3Q29udGFpbmVyKSAhPSBudWxsO1xuICAgIGlmICghaXNTaGFkb3dEb20pIHtcbiAgICAgIGZvciAoY29uc3QgaWQgb2YgdGhpcy5yb290RWxlbWVudHNbXCJzdHlsZXNcIl0uY2hpbGRyZW4ua2V5cygpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoXCJzdHlsZXNcIiwgaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lciA9IG5ld0NvbnRhaW5lcjtcbiAgICBmb3IgKGNvbnN0IFtpZCwgc3R5bGVzXSBvZiB0aGlzLnN0eWxlcykge1xuICAgICAgdGhpcy5hZGRTdHlsZXMoaWQsIHN0eWxlcyk7XG4gICAgfVxuICAgIG5ld0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgIHRoaXMuc2l6ZU1vbml0b3Iub2JzZXJ2ZShuZXdDb250YWluZXIsIChzaXplKSA9PiB7XG4gICAgICB0aGlzLmNvbnRhaW5lclNpemUgPSBzaXplO1xuICAgICAgdGhpcy51cGRhdGVDb250YWluZXJTaXplKCk7XG4gICAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcInJlc2l6ZVwiLCB7IHR5cGU6IFwicmVzaXplXCIgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJjb250YWluZXItY2hhbmdlZFwiLCB7IHR5cGU6IFwiY29udGFpbmVyLWNoYW5nZWRcIiB9KTtcbiAgfVxuICBzZXRUaGVtZUNsYXNzKHRoZW1lQ2xhc3NOYW1lKSB7XG4gICAgY29uc3QgdGhlbWVDbGFzc05hbWVQcmVmaXggPSBcImFnLWNoYXJ0cy10aGVtZS1cIjtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmZvckVhY2goKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgaWYgKGNsYXNzTmFtZS5zdGFydHNXaXRoKHRoZW1lQ2xhc3NOYW1lUHJlZml4KSAmJiBjbGFzc05hbWUgIT09IHRoZW1lQ2xhc3NOYW1lKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhlbWVDbGFzc05hbWUpO1xuICB9XG4gIHNldFRoZW1lUGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICBjb25zdCBrZXlzTWFwID0ge1xuICAgICAgYWNjZW50Q29sb3I6IFwiYWNjZW50LWNvbG9yXCIsXG4gICAgICBheGlzQ29sb3I6IFwiYXhpcy1jb2xvclwiLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBcImJhY2tncm91bmQtY29sb3JcIixcbiAgICAgIGJvcmRlckNvbG9yOiBcImJvcmRlci1jb2xvclwiLFxuICAgICAgZm9yZWdyb3VuZENvbG9yOiBcImZvcmVncm91bmQtY29sb3JcIixcbiAgICAgIGZvbnRGYW1pbHk6IFwiZm9udC1mYW1pbHlcIixcbiAgICAgIGZvbnRTaXplOiBcImZvbnQtc2l6ZVwiLFxuICAgICAgZm9udFdlaWdodDogXCJmb250LXdlaWdodFwiLFxuICAgICAgZ3JpZExpbmVDb2xvcjogXCJncmlkLWxpbmUtY29sb3JcIixcbiAgICAgIHBhZGRpbmc6IFwicGFkZGluZ1wiLFxuICAgICAgc3VidGxlVGV4dENvbG9yOiBcInN1YnRsZS10ZXh0LWNvbG9yXCIsXG4gICAgICB0ZXh0Q29sb3I6IFwidGV4dC1jb2xvclwiLFxuICAgICAgY2hyb21lQmFja2dyb3VuZENvbG9yOiBcImNocm9tZS1iYWNrZ3JvdW5kLWNvbG9yXCIsXG4gICAgICBjaHJvbWVGb250RmFtaWx5OiBcImNocm9tZS1mb250LWZhbWlseVwiLFxuICAgICAgY2hyb21lRm9udFNpemU6IFwiY2hyb21lLWZvbnQtc2l6ZVwiLFxuICAgICAgY2hyb21lRm9udFdlaWdodDogXCJjaHJvbWUtZm9udC13ZWlnaHRcIixcbiAgICAgIGNocm9tZVN1YnRsZVRleHRDb2xvcjogXCJjaHJvbWUtc3VidGxlLXRleHQtY29sb3JcIixcbiAgICAgIGNocm9tZVRleHRDb2xvcjogXCJjaHJvbWUtdGV4dC1jb2xvclwiLFxuICAgICAgaW5wdXRCYWNrZ3JvdW5kQ29sb3I6IFwiaW5wdXQtYmFja2dyb3VuZC1jb2xvclwiLFxuICAgICAgaW5wdXRUZXh0Q29sb3I6IFwiaW5wdXQtdGV4dC1jb2xvclwiLFxuICAgICAgY3Jvc3NoYWlyTGFiZWxCYWNrZ3JvdW5kQ29sb3I6IFwiY3Jvc3NoYWlyLWxhYmVsLWJhY2tncm91bmQtY29sb3JcIixcbiAgICAgIGNyb3NzaGFpckxhYmVsVGV4dENvbG9yOiBcImNyb3NzaGFpci1sYWJlbC10ZXh0LWNvbG9yXCJcbiAgICB9O1xuICAgIGNvbnN0IGxlbmd0aEtleXMgPSBbXCJmb250U2l6ZVwiLCBcImNocm9tZUZvbnRTaXplXCJdO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICAgIGxldCBmb3JtYXR0ZWRWYWx1ZSA9IGAke3ZhbHVlfWA7XG4gICAgICBpZiAobGVuZ3RoS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIGZvcm1hdHRlZFZhbHVlID0gYCR7dmFsdWV9cHhgO1xuICAgICAgfVxuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGAtLWFnLWNoYXJ0cy0ke2tleXNNYXBba2V5XX1gLCBmb3JtYXR0ZWRWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUNhbnZhc0xhYmVsKGFyaWFMYWJlbCkge1xuICAgIHNldEF0dHJpYnV0ZSh0aGlzLnJvb3RFbGVtZW50c1tcImNhbnZhcy1wcm94eVwiXS5lbGVtZW50LCBcImFyaWEtbGFiZWxcIiwgYXJpYUxhYmVsKTtcbiAgfVxuICBnZXRFdmVudEVsZW1lbnQoZGVmYXVsdEVsZW0sIGV2ZW50VHlwZSkge1xuICAgIGNvbnN0IGV2ZW50cyA9IFtcImZvY3VzXCIsIFwiYmx1clwiLCBcImtleWRvd25cIiwgXCJrZXl1cFwiXTtcbiAgICByZXR1cm4gZXZlbnRzLmluY2x1ZGVzKGV2ZW50VHlwZSkgPyB0aGlzLnJvb3RFbGVtZW50c1tcInNlcmllcy1hcmVhXCJdLmVsZW1lbnQgOiBkZWZhdWx0RWxlbTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgdGhpcy5nZXRFdmVudEVsZW1lbnQodGhpcy5lbGVtZW50LCB0eXBlKS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgdGhpcy5nZXRFdmVudEVsZW1lbnQodGhpcy5lbGVtZW50LCB0eXBlKS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgfVxuICAvKiogR2V0IHRoZSBtYWluIGNoYXJ0IGFyZWEgY2xpZW50IGJvdW5kIHJlY3QuICovXG4gIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5yb290RWxlbWVudHNbXCJjYW52YXNcIl0uZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjbGllbnQgYm91bmRpbmcgcmVjdCBmb3Igb3ZlcmxheSBlbGVtZW50cyB0aGF0IG1pZ2h0IGZsb2F0IG91dHNpZGUgdGhlIGJvdW5kcyBvZiB0aGVcbiAgICogbWFpbiBjaGFydCBhcmVhLlxuICAgKi9cbiAgZ2V0T3ZlcmxheUNsaWVudFJlY3QoKSB7XG4gICAgY29uc3Qgd2luZG93MiA9IGdldFdpbmRvdygpO1xuICAgIGNvbnN0IHdpbmRvd0JCb3ggPSBuZXcgQkJveCgwLCAwLCB3aW5kb3cyLmlubmVyV2lkdGgsIHdpbmRvdzIuaW5uZXJIZWlnaHQpO1xuICAgIGNvbnN0IGNvbnRhaW5lckJCb3ggPSB0aGlzLmdldFJhd092ZXJsYXlDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHdpbmRvd0JCb3guaW50ZXJzZWN0aW9uKGNvbnRhaW5lckJCb3gpPy50b0RPTVJlY3QoKSA/PyBOVUxMX0RPTVJFQ1Q7XG4gIH1cbiAgZ2V0UmF3T3ZlcmxheUNsaWVudFJlY3QoKSB7XG4gICAgbGV0IGVsZW1lbnQyID0gdGhpcy5lbGVtZW50O1xuICAgIHdoaWxlIChlbGVtZW50MiAhPSBudWxsKSB7XG4gICAgICBjb25zdCBzdHlsZU1hcCA9IGVsZW1lbnQyLmNvbXB1dGVkU3R5bGVNYXA/LigpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dZID0gc3R5bGVNYXA/LmdldChcIm92ZXJmbG93LXlcIik/LnRvU3RyaW5nKCk7XG4gICAgICBpZiAob3ZlcmZsb3dZID09PSBcImF1dG9cIiB8fCBvdmVyZmxvd1kgPT09IFwic2Nyb2xsXCIpIHtcbiAgICAgICAgcmV0dXJuIEJCb3guZnJvbURPTVJlY3QoZWxlbWVudDIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgfVxuICAgICAgZWxlbWVudDIgPSBlbGVtZW50Mi5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICBjb25zdCBkb2NSb290ID0gdGhpcy5nZXRTaGFkb3dEb2N1bWVudFJvb3QoKTtcbiAgICBpZiAoZG9jUm9vdCAhPSBudWxsKVxuICAgICAgcmV0dXJuIEJCb3guZnJvbURPTVJlY3QoZG9jUm9vdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgY29uc3QgeyBpbm5lcldpZHRoLCBpbm5lckhlaWdodCB9ID0gZ2V0V2luZG93KCk7XG4gICAgcmV0dXJuIG5ldyBCQm94KDAsIDAsIGlubmVyV2lkdGgsIGlubmVySGVpZ2h0KTtcbiAgfVxuICBnZXRTaGFkb3dEb2N1bWVudFJvb3QoY3VycmVudCA9IHRoaXMuY29udGFpbmVyKSB7XG4gICAgY29uc3QgZG9jUm9vdCA9IGN1cnJlbnQ/Lm93bmVyRG9jdW1lbnQ/LmJvZHkgPz8gZ2V0RG9jdW1lbnQoXCJib2R5XCIpO1xuICAgIHdoaWxlIChjdXJyZW50ICE9IG51bGwpIHtcbiAgICAgIGlmIChjdXJyZW50ID09PSBkb2NSb290KSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudC5wYXJlbnROb2RlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRQYXJlbnQoZG9tRWxlbWVudENsYXNzKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdEVsZW1lbnRzW2RvbUVsZW1lbnRDbGFzc10uZWxlbWVudDtcbiAgfVxuICBnZXRDaGlsZEJvdW5kaW5nQ2xpZW50UmVjdCh0eXBlKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy5yb290RWxlbWVudHNbdHlwZV07XG4gICAgY29uc3QgY2hpbGRSZWN0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4udmFsdWVzKCkpIHtcbiAgICAgIGNoaWxkUmVjdHMucHVzaChCQm94LmZyb21ET01SZWN0KGNoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSk7XG4gICAgfVxuICAgIHJldHVybiBCQm94Lm1lcmdlKGNoaWxkUmVjdHMpO1xuICB9XG4gIGlzTWFuYWdlZENoaWxkRE9NRWxlbWVudChlbCwgZG9tRWxlbWVudENsYXNzLCBpZCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMucm9vdEVsZW1lbnRzW2RvbUVsZW1lbnRDbGFzc107XG4gICAgY29uc3Qgc2VhcmNoID0gY2hpbGRyZW4/LmdldChpZCk7XG4gICAgcmV0dXJuIHNlYXJjaCAhPSBudWxsICYmIGVsLmNvbnRhaW5zKHNlYXJjaCk7XG4gIH1cbiAgY29udGFpbnMoZWxlbWVudDIsIGRvbUVsZW1lbnRDbGFzcykge1xuICAgIGlmIChkb21FbGVtZW50Q2xhc3MgPT0gbnVsbClcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY29udGFpbnMoZWxlbWVudDIpO1xuICAgIHJldHVybiB0aGlzLnJvb3RFbGVtZW50c1tkb21FbGVtZW50Q2xhc3NdLmVsZW1lbnQuY29udGFpbnMoZWxlbWVudDIpO1xuICB9XG4gIGFkZFN0eWxlcyhpZCwgc3R5bGVzKSB7XG4gICAgY29uc3QgZGF0YUF0dHJpYnV0ZSA9IFwiZGF0YS1hZy1jaGFydHNcIjtcbiAgICB0aGlzLnN0eWxlcy5zZXQoaWQsIHN0eWxlcyk7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY2hlY2tJZCA9IChlbCkgPT4ge1xuICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShkYXRhQXR0cmlidXRlKSA9PT0gaWQ7XG4gICAgfTtcbiAgICBjb25zdCBhZGRTdHlsZUVsZW1lbnQgPSAoZWwpID0+IHtcbiAgICAgIGNvbnN0IG1ldGFFbGVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcIlRJVExFXCIsIFwiTUVUQVwiXSk7XG4gICAgICBsZXQgc2tpcHBpbmdNZXRhRWxlbWVudHMgPSB0cnVlO1xuICAgICAgbGV0IGluc2VydEFmdGVyRWw7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGVsLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChza2lwcGluZ01ldGFFbGVtZW50cyAmJiBtZXRhRWxlbWVudHMuaGFzKGNoaWxkLnRhZ05hbWUpKSB7XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJFbCA9IGNoaWxkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHNraXBwaW5nTWV0YUVsZW1lbnRzID0gZmFsc2U7XG4gICAgICAgIGlmIChjaGVja0lkKGNoaWxkKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChjaGlsZC5oYXNBdHRyaWJ1dGUoZGF0YUF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICBpbnNlcnRBZnRlckVsID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0eWxlRWwgPSBjcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBpZiAoaW5zZXJ0QWZ0ZXJFbCAhPSBudWxsKSB7XG4gICAgICAgIGVsLmluc2VydEJlZm9yZShzdHlsZUVsLCBpbnNlcnRBZnRlckVsLm5leHRTaWJsaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnByZXBlbmQoc3R5bGVFbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGVFbDtcbiAgICB9O1xuICAgIGxldCBzdHlsZUVsZW1lbnQ7XG4gICAgaWYgKHRoaXMuc3R5bGVSb290RWxlbWVudCkge1xuICAgICAgc3R5bGVFbGVtZW50ID0gYWRkU3R5bGVFbGVtZW50KHRoaXMuc3R5bGVSb290RWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRvY3VtZW50Um9vdCA9IHRoaXMuZ2V0U2hhZG93RG9jdW1lbnRSb290KHRoaXMuY29udGFpbmVyKTtcbiAgICAgIGlmIChkb2N1bWVudFJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzdHlsZUVsZW1lbnQgPSB0aGlzLmFkZENoaWxkKFwic3R5bGVzXCIsIGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlRWxlbWVudCA9IGFkZFN0eWxlRWxlbWVudChnZXREb2N1bWVudChcImhlYWRcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVFbGVtZW50ID09IG51bGwgfHwgY2hlY2tJZChzdHlsZUVsZW1lbnQpKVxuICAgICAgcmV0dXJuO1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoZGF0YUF0dHJpYnV0ZSwgaWQpO1xuICAgIHN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSBzdHlsZXM7XG4gIH1cbiAgcmVtb3ZlU3R5bGVzKGlkKSB7XG4gICAgdGhpcy5yZW1vdmVDaGlsZChcInN0eWxlc1wiLCBpZCk7XG4gIH1cbiAgdXBkYXRlQ3Vyc29yKGNhbGxlcklkLCBzdHlsZSkge1xuICAgIHRoaXMuY3Vyc29yU3RhdGUuc2V0KGNhbGxlcklkLCBzdHlsZSk7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLmN1cnNvciA9IHRoaXMuY3Vyc29yU3RhdGUuc3RhdGVWYWx1ZSgpO1xuICB9XG4gIGdldEN1cnNvcigpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnN0eWxlLmN1cnNvcjtcbiAgfVxuICBhZGRDaGlsZChkb21FbGVtZW50Q2xhc3MsIGlkLCBjaGlsZCwgaW5zZXJ0KSB7XG4gICAgY29uc3QgeyBlbGVtZW50OiBlbGVtZW50MiwgY2hpbGRyZW4sIGxpc3RlbmVycyB9ID0gdGhpcy5yb290RWxlbWVudHNbZG9tRWxlbWVudENsYXNzXTtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSB1bmFibGUgdG8gY3JlYXRlIERPTSBlbGVtZW50cyBhZnRlciBkZXN0cm95KClcIik7XG4gICAgfVxuICAgIGlmIChjaGlsZHJlbi5oYXMoaWQpKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW4uZ2V0KGlkKTtcbiAgICB9XG4gICAgY29uc3QgeyBjaGlsZEVsZW1lbnRUeXBlID0gXCJkaXZcIiB9ID0gZG9tRWxlbWVudENvbmZpZy5nZXQoZG9tRWxlbWVudENsYXNzKSA/PyB7fTtcbiAgICBpZiAoY2hpbGQgJiYgY2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBjaGlsZEVsZW1lbnRUeXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIG1pc21hdGNoaW5nIERPTSBlbGVtZW50IHR5cGVcIik7XG4gICAgfVxuICAgIGNvbnN0IG5ld0NoaWxkID0gY2hpbGQgPz8gY3JlYXRlRWxlbWVudChjaGlsZEVsZW1lbnRUeXBlKTtcbiAgICBmb3IgKGNvbnN0IFt0eXBlLCBmbiwgb3B0c10gb2YgbGlzdGVuZXJzKSB7XG4gICAgICBuZXdDaGlsZC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRzKTtcbiAgICB9XG4gICAgY2hpbGRyZW4uc2V0KGlkLCBuZXdDaGlsZCk7XG4gICAgaWYgKGluc2VydCkge1xuICAgICAgY29uc3QgcXVlcnlSZXN1bHQgPSBlbGVtZW50Mi5xdWVyeVNlbGVjdG9yKGluc2VydC5xdWVyeSk7XG4gICAgICBpZiAocXVlcnlSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIGFkZENoaWxkIHF1ZXJ5IGZhaWxlZCAke2luc2VydC5xdWVyeX1gKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5UmVzdWx0Lmluc2VydEFkamFjZW50RWxlbWVudChpbnNlcnQud2hlcmUsIG5ld0NoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudDI/LmFwcGVuZENoaWxkKG5ld0NoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0NoaWxkO1xuICB9XG4gIHJlbW92ZUNoaWxkKGRvbUVsZW1lbnRDbGFzcywgaWQpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzLnJvb3RFbGVtZW50c1tkb21FbGVtZW50Q2xhc3NdO1xuICAgIGlmICghY2hpbGRyZW4pXG4gICAgICByZXR1cm47XG4gICAgY2hpbGRyZW4uZ2V0KGlkKT8ucmVtb3ZlKCk7XG4gICAgY2hpbGRyZW4uZGVsZXRlKGlkKTtcbiAgfVxuICBpbmNyZW1lbnREYXRhQ291bnRlcihuYW1lKSB7XG4gICAgY29uc3QgeyBkYXRhc2V0IH0gPSB0aGlzLmVsZW1lbnQ7XG4gICAgZGF0YXNldFtuYW1lXSA/PyAoZGF0YXNldFtuYW1lXSA9IFwiMFwiKTtcbiAgICBkYXRhc2V0W25hbWVdID0gU3RyaW5nKE51bWJlcihkYXRhc2V0W25hbWVdKSArIDEpO1xuICB9XG4gIHNldERhdGFCb29sZWFuKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5lbGVtZW50LmRhdGFzZXRbbmFtZV0gPSBTdHJpbmcodmFsdWUpO1xuICB9XG4gIHVwZGF0ZUNvbnRhaW5lckNsYXNzTmFtZSgpIHtcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGVsZW1lbnQyLCBjb250YWluZXJTaXplLCBtaW5XaWR0aCwgbWluSGVpZ2h0IH0gPSB0aGlzO1xuICAgIGVsZW1lbnQyLmNsYXNzTGlzdC50b2dnbGUoQ09OVEFJTkVSX01PRElGSUVSUy5zYWZlSG9yaXpvbnRhbCwgbWluV2lkdGggPj0gKGNvbnRhaW5lclNpemU/LndpZHRoID8/IEluZmluaXR5KSk7XG4gICAgZWxlbWVudDIuY2xhc3NMaXN0LnRvZ2dsZShDT05UQUlORVJfTU9ESUZJRVJTLnNhZmVWZXJ0aWNhbCwgbWluSGVpZ2h0ID49IChjb250YWluZXJTaXplPy5oZWlnaHQgPz8gSW5maW5pdHkpKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvd2lkZ2V0L2JvdW5kZWRUZXh0V2lkZ2V0LnRzXG52YXIgQm91bmRlZFRleHRXaWRnZXQgPSBjbGFzcyBleHRlbmRzIFdpZGdldCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgIHRoaXMudGV4dEVsZW1lbnQgPSBjcmVhdGVTdmdFbGVtZW50KFwidGV4dFwiKTtcbiAgICB0aGlzLnRleHRFbGVtZW50LnJvbGUgPSBcInByZXNlbnRhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudCA9IGNyZWF0ZVN2Z0VsZW1lbnQoXCJzdmdcIik7XG4gICAgdGhpcy5zdmdFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudGV4dEVsZW1lbnQpO1xuICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gXCIwXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50LnJvbGUgPSBcInByZXNlbnRhdGlvblwiO1xuICAgIHRoaXMuZWxlbS5hcHBlbmRDaGlsZCh0aGlzLnN2Z0VsZW1lbnQpO1xuICAgIHRoaXMuZWxlbS5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcbiAgfVxuICBzZXQgdGV4dENvbnRlbnQodGV4dDIpIHtcbiAgICB0aGlzLnRleHRFbGVtZW50LnRleHRDb250ZW50ID0gdGV4dDI7XG4gICAgY29uc3QgYmJveENhbGN1bGF0b3IgPSB0aGlzLnRleHRFbGVtZW50O1xuICAgIGNvbnN0IGJib3ggPSBiYm94Q2FsY3VsYXRvci5nZXRCQm94Py4oKTtcbiAgICBpZiAoYmJveCkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgYCR7YmJveC54fSAke2Jib3gueX0gJHtiYm94LndpZHRofSAke2Jib3guaGVpZ2h0fWApO1xuICAgIH1cbiAgfVxuICBnZXQgdGV4dENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dEVsZW1lbnQudGV4dENvbnRlbnQ7XG4gIH1cbiAgZGVzdHJ1Y3RvcigpIHtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvd2lkZ2V0L2J1dHRvbldpZGdldC50c1xudmFyIEJ1dHRvbldpZGdldCA9IGNsYXNzIGV4dGVuZHMgV2lkZ2V0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSk7XG4gICAgdGhpcy5zZXRFbmFibGVkKHRydWUpO1xuICB9XG4gIGRlc3RydWN0b3IoKSB7XG4gIH1cbiAgc2V0RW5hYmxlZChlbmFibGVkKSB7XG4gICAgc2V0QXR0cmlidXRlKHRoaXMuZWxlbSwgXCJhcmlhLWRpc2FibGVkXCIsICFlbmFibGVkKTtcbiAgICBzZXRFbGVtZW50U3R5bGUodGhpcy5lbGVtLCBcInBvaW50ZXItZXZlbnRzXCIsIGVuYWJsZWQgPyB2b2lkIDAgOiBcIm5vbmVcIik7XG4gIH1cbiAgYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gc3VwZXIuYWRkTGlzdGVuZXIodHlwZSwgKGV2LCBjdXJyZW50KSA9PiB7XG4gICAgICBpZiAoKHR5cGUgPT09IFwiY2xpY2tcIiB8fCB0eXBlID09PSBcImRibGNsaWNrXCIpICYmIHRoaXMuaXNEaXNhYmxlZCgpKVxuICAgICAgICByZXR1cm47XG4gICAgICBsaXN0ZW5lcihldiwgY3VycmVudCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3dpZGdldC9ncm91cFdpZGdldC50c1xudmFyIEdyb3VwV2lkZ2V0ID0gY2xhc3MgZXh0ZW5kcyBXaWRnZXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihjcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5lbGVtLCBcInJvbGVcIiwgXCJncm91cFwiKTtcbiAgfVxuICBkZXN0cnVjdG9yKCkge1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy93aWRnZXQvcm92aW5nVGFiQ29udGFpbmVyV2lkZ2V0LnRzXG52YXIgUm92aW5nVGFiQ29udGFpbmVyV2lkZ2V0ID0gY2xhc3MgZXh0ZW5kcyBXaWRnZXQge1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsT3JpZW50YXRpb24sIHJvbGUpIHtcbiAgICBzdXBlcihjcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICB0aGlzLmZvY3VzZWRDaGlsZEluZGV4ID0gMDtcbiAgICB0aGlzLm9uQ2hpbGRGb2N1cyA9IChfZXZlbnQsIGNoaWxkKSA9PiB7XG4gICAgICBjb25zdCBvbGRGb2N1cyA9IHRoaXMuY2hpbGRyZW5bdGhpcy5mb2N1c2VkQ2hpbGRJbmRleF07XG4gICAgICB0aGlzLmZvY3VzZWRDaGlsZEluZGV4ID0gY2hpbGQuaW5kZXg7XG4gICAgICBvbGRGb2N1cz8uc2V0VGFiSW5kZXgoLTEpO1xuICAgICAgY2hpbGQuc2V0VGFiSW5kZXgoMCk7XG4gICAgfTtcbiAgICB0aGlzLm9uQ2hpbGRLZXlEb3duID0gKGV2ZW50LCBjaGlsZCkgPT4ge1xuICAgICAgY29uc3Qgcm92aW5nT3JpZW50YXRpb24gPSB0aGlzLm9yaWVudGF0aW9uO1xuICAgICAgY29uc3QgW3ByaW1hcnlLZXlzLCBzZWNvbmRhcnlLZXlzXSA9IHJvdmluZ09yaWVudGF0aW9uID09PSBcImJvdGhcIiA/IFtQUkVWX05FWFRfS0VZU1tcImhvcml6b250YWxcIl0sIFBSRVZfTkVYVF9LRVlTW1widmVydGljYWxcIl1dIDogW1BSRVZfTkVYVF9LRVlTW3JvdmluZ09yaWVudGF0aW9uXSwgdm9pZCAwXTtcbiAgICAgIGxldCB0YXJnZXRJbmRleCA9IC0xO1xuICAgICAgaWYgKGhhc05vTW9kaWZpZXJzKGV2ZW50LnNvdXJjZUV2ZW50KSkge1xuICAgICAgICBjb25zdCBrZXkgPSBldmVudC5zb3VyY2VFdmVudC5rZXk7XG4gICAgICAgIGlmIChrZXkgPT09IHByaW1hcnlLZXlzLm5leHRLZXkgfHwga2V5ID09PSBzZWNvbmRhcnlLZXlzPy5uZXh0S2V5KSB7XG4gICAgICAgICAgdGFyZ2V0SW5kZXggPSBjaGlsZC5pbmRleCArIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBwcmltYXJ5S2V5cy5wcmV2S2V5IHx8IGtleSA9PT0gc2Vjb25kYXJ5S2V5cz8ucHJldktleSkge1xuICAgICAgICAgIHRhcmdldEluZGV4ID0gY2hpbGQuaW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmNoaWxkcmVuW3RhcmdldEluZGV4XT8uZm9jdXMoKTtcbiAgICB9O1xuICAgIHRoaXMub3JpZW50YXRpb24gPSBpbml0aWFsT3JpZW50YXRpb247XG4gICAgc2V0QXR0cmlidXRlKHRoaXMuZWxlbSwgXCJyb2xlXCIsIHJvbGUpO1xuICB9XG4gIGdldCBvcmllbnRhdGlvbigpIHtcbiAgICByZXR1cm4gZ2V0QXR0cmlidXRlKHRoaXMuZWxlbSwgXCJhcmlhLW9yaWVudGF0aW9uXCIpID8/IFwiYm90aFwiO1xuICB9XG4gIHNldCBvcmllbnRhdGlvbihvcmllbnRhdGlvbikge1xuICAgIHNldEF0dHJpYnV0ZSh0aGlzLmVsZW0sIFwiYXJpYS1vcmllbnRhdGlvblwiLCBvcmllbnRhdGlvbiAhPT0gXCJib3RoXCIgPyBvcmllbnRhdGlvbiA6IHZvaWQgMCk7XG4gIH1cbiAgZm9jdXMoKSB7XG4gICAgdGhpcy5jaGlsZHJlblt0aGlzLmZvY3VzZWRDaGlsZEluZGV4XT8uZm9jdXMoKTtcbiAgfVxuICBvbkNoaWxkQWRkZWQoY2hpbGQpIHtcbiAgICBjaGlsZC5hZGRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMub25DaGlsZEZvY3VzKTtcbiAgICBjaGlsZC5hZGRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5vbkNoaWxkS2V5RG93bik7XG4gICAgY2hpbGQuc2V0VGFiSW5kZXgodGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDEgPyAwIDogLTEpO1xuICB9XG4gIG9uQ2hpbGRSZW1vdmVkKGNoaWxkKSB7XG4gICAgY2hpbGQucmVtb3ZlTGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLm9uQ2hpbGRGb2N1cyk7XG4gICAgY2hpbGQucmVtb3ZlTGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMub25DaGlsZEtleURvd24pO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy93aWRnZXQvbGlzdFdpZGdldC50c1xudmFyIExpc3RXaWRnZXQgPSBjbGFzcyBleHRlbmRzIFJvdmluZ1RhYkNvbnRhaW5lcldpZGdldCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiYm90aFwiLCBcImxpc3RcIik7XG4gICAgdGhpcy5zZXRIaWRkZW4odHJ1ZSk7XG4gIH1cbiAgZGVzdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGMpID0+IGMuZ2V0RWxlbWVudCgpLnBhcmVudEVsZW1lbnQucmVtb3ZlKCkpO1xuICB9XG4gIGFkZENoaWxkVG9ET00oY2hpbGQsIGJlZm9yZSkge1xuICAgIGNvbnN0IGxpc3RJdGVtID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBzZXRBdHRyaWJ1dGUobGlzdEl0ZW0sIFwicm9sZVwiLCBcImxpc3RpdGVtXCIpO1xuICAgIHNldEVsZW1lbnRTdHlsZShsaXN0SXRlbSwgXCJwb3NpdGlvblwiLCBcImFic29sdXRlXCIpO1xuICAgIFdpZGdldC5zZXRFbGVtZW50Q29udGFpbmVyKGNoaWxkLCBsaXN0SXRlbSk7XG4gICAgdGhpcy5hcHBlbmRPckluc2VydChsaXN0SXRlbSwgYmVmb3JlKTtcbiAgICB0aGlzLnNldEhpZGRlbihmYWxzZSk7XG4gIH1cbiAgcmVtb3ZlQ2hpbGRGcm9tRE9NKGNoaWxkKSB7XG4gICAgY2hpbGQuZ2V0RWxlbWVudCgpLnBhcmVudEVsZW1lbnQucmVtb3ZlKCk7XG4gICAgdGhpcy5zZXRIaWRkZW4odGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApO1xuICB9XG4gIHNldEhpZGRlbihoaWRkZW4pIHtcbiAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIGhpZGRlbiA9IHRydWU7XG4gICAgfVxuICAgIHN1cGVyLnNldEhpZGRlbihoaWRkZW4pO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy93aWRnZXQvbmF0aXZlV2lkZ2V0LnRzXG52YXIgTmF0aXZlV2lkZ2V0ID0gY2xhc3MgZXh0ZW5kcyBXaWRnZXQge1xuICBjb25zdHJ1Y3RvcihlbGVtKSB7XG4gICAgc3VwZXIoZWxlbSk7XG4gIH1cbiAgZGVzdHJ1Y3RvcigpIHtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvd2lkZ2V0L3NsaWRlcldpZGdldC50c1xudmFyIF9TbGlkZXJXaWRnZXQgPSBjbGFzcyBfU2xpZGVyV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoY3JlYXRlRWxlbWVudChcImlucHV0XCIpKTtcbiAgICB0aGlzLl9zdGVwID0gX1NsaWRlcldpZGdldC5TVEVQX09ORTtcbiAgICB0aGlzLm9yaWVudGF0aW9uID0gXCJib3RoXCI7XG4gIH1cbiAgZ2V0IHN0ZXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZXA7XG4gIH1cbiAgc2V0IHN0ZXAoc3RlcCkge1xuICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICAgIHRoaXMuZ2V0RWxlbWVudCgpLnN0ZXAgPSBzdGVwLmF0dHJpYnV0ZVZhbHVlO1xuICB9XG4gIGdldCBrZXlib2FyZFN0ZXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleWJvYXJkU3RlcD8uc3RlcCA/PyB0aGlzLl9zdGVwO1xuICB9XG4gIHNldCBrZXlib2FyZFN0ZXAoc3RlcCkge1xuICAgIGlmIChzdGVwID09PSB0aGlzLl9rZXlib2FyZFN0ZXA/LnN0ZXApXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMuX2tleWJvYXJkU3RlcCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlib2FyZFN0ZXAub25LZXlEb3duKTtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLl9rZXlib2FyZFN0ZXAub25LZXlVcCk7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9rZXlib2FyZFN0ZXAub25CbHVyKTtcbiAgICAgIHRoaXMuX2tleWJvYXJkU3RlcCA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHN0ZXAgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qgb25LZXlEb3duID0gKCkgPT4gdGhpcy5nZXRFbGVtZW50KCkuc3RlcCA9IHN0ZXAuYXR0cmlidXRlVmFsdWU7XG4gICAgICBjb25zdCByZXNldFN0ZXAgPSAoKSA9PiB0aGlzLmdldEVsZW1lbnQoKS5zdGVwID0gdGhpcy5fc3RlcC5hdHRyaWJ1dGVWYWx1ZTtcbiAgICAgIHRoaXMuX2tleWJvYXJkU3RlcCA9IHsgc3RlcCwgb25LZXlEb3duLCBvbktleVVwOiByZXNldFN0ZXAsIG9uQmx1cjogcmVzZXRTdGVwIH07XG4gICAgICB0aGlzLmFkZExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlib2FyZFN0ZXAub25LZXlEb3duKTtcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLl9rZXlib2FyZFN0ZXAub25LZXlVcCk7XG4gICAgICB0aGlzLmFkZExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9rZXlib2FyZFN0ZXAub25CbHVyKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG9yaWVudGF0aW9uKCkge1xuICAgIHJldHVybiBnZXRBdHRyaWJ1dGUodGhpcy5lbGVtLCBcImFyaWEtb3JpZW50YXRpb25cIikgPz8gXCJib3RoXCI7XG4gIH1cbiAgc2V0IG9yaWVudGF0aW9uKG9yaWVudGF0aW9uKSB7XG4gICAgc2V0QXR0cmlidXRlKHRoaXMuZWxlbSwgXCJhcmlhLW9yaWVudGF0aW9uXCIsIG9yaWVudGF0aW9uICE9PSBcImJvdGhcIiA/IG9yaWVudGF0aW9uIDogdm9pZCAwKTtcbiAgICBfU2xpZGVyV2lkZ2V0LnJlZ2lzdGVyRGVmYXVsdFByZXZlbnRlcnModGhpcywgb3JpZW50YXRpb24pO1xuICB9XG4gIGRlc3RydWN0b3IoKSB7XG4gIH1cbiAgY2xhbXBWYWx1ZVJhdGlvKGNsYW1wTWluLCBjbGFtcE1heCkge1xuICAgIGNvbnN0IHJhdGlvMiA9IHRoaXMuZ2V0VmFsdWVSYXRpbygpO1xuICAgIGNvbnN0IGNsYW1wZWRSYXRpbyA9IGNsYW1wKGNsYW1wTWluLCByYXRpbzIsIGNsYW1wTWF4KTtcbiAgICBpZiAoY2xhbXBlZFJhdGlvICE9PSByYXRpbzIpIHtcbiAgICAgIHRoaXMuc2V0VmFsdWVSYXRpbyhjbGFtcGVkUmF0aW8pO1xuICAgIH1cbiAgICByZXR1cm4gY2xhbXBlZFJhdGlvO1xuICB9XG4gIHNldFZhbHVlUmF0aW8ocmF0aW8yLCBvcHRzKSB7XG4gICAgY29uc3QgeyBkaXZpZGVyIH0gPSB0aGlzLnN0ZXA7XG4gICAgY29uc3QgdmFsdWUgPSBNYXRoLnJvdW5kKHJhdGlvMiAqIDFlNCkgLyBkaXZpZGVyO1xuICAgIGNvbnN0IHsgYXJpYVZhbHVlVGV4dCA9IGZvcm1hdFBlcmNlbnQodmFsdWUgLyBkaXZpZGVyKSB9ID0gb3B0cyA/PyB7fTtcbiAgICBjb25zdCBlbGVtID0gdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgZWxlbS52YWx1ZSA9IGAke3ZhbHVlfWA7XG4gICAgZWxlbS5hcmlhVmFsdWVUZXh0ID0gYXJpYVZhbHVlVGV4dDtcbiAgfVxuICBnZXRWYWx1ZVJhdGlvKCkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMuZ2V0RWxlbWVudCgpLnZhbHVlKSAvIHRoaXMuc3RlcC5kaXZpZGVyO1xuICB9XG4gIHN0YXRpYyByZWdpc3RlckRlZmF1bHRQcmV2ZW50ZXJzKHRhcmdldCwgb3JpZW50YXRpb24pIHtcbiAgICBpZiAob3JpZW50YXRpb24gPT09IFwiYm90aFwiKSB7XG4gICAgICB0YXJnZXQucmVtb3ZlTGlzdGVuZXIoXCJrZXlkb3duXCIsIF9TbGlkZXJXaWRnZXQub25LZXlEb3duKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0LmFkZExpc3RlbmVyKFwia2V5ZG93blwiLCBfU2xpZGVyV2lkZ2V0Lm9uS2V5RG93bik7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBvbktleURvd24oZXYsIGN1cnJlbnQpIHtcbiAgICBsZXQgaWdub3JlZEtleXMgPSBbXTtcbiAgICBjb25zdCB7IG9yaWVudGF0aW9uIH0gPSBjdXJyZW50O1xuICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgIGlnbm9yZWRLZXlzID0gW1wiQXJyb3dVcFwiLCBcIkFycm93RG93blwiXTtcbiAgICB9IGVsc2UgaWYgKG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgIGlnbm9yZWRLZXlzID0gW1wiQXJyb3dMZWZ0XCIsIFwiQXJyb3dSaWdodFwiXTtcbiAgICB9XG4gICAgaWYgKGlnbm9yZWRLZXlzLmluY2x1ZGVzKGV2LnNvdXJjZUV2ZW50LmNvZGUpKSB7XG4gICAgICBldi5zb3VyY2VFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxufTtcbl9TbGlkZXJXaWRnZXQuU1RFUF9PTkUgPSB7IGF0dHJpYnV0ZVZhbHVlOiBcIjFcIiwgZGl2aWRlcjogMSB9O1xuX1NsaWRlcldpZGdldC5TVEVQX0hVTkRSRVRIID0geyBhdHRyaWJ1dGVWYWx1ZTogXCIwLjAxXCIsIGRpdmlkZXI6IDEwMCB9O1xudmFyIFNsaWRlcldpZGdldCA9IF9TbGlkZXJXaWRnZXQ7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3dpZGdldC9zd2l0Y2hXaWRnZXQudHNcbnZhciBTd2l0Y2hXaWRnZXQgPSBjbGFzcyBleHRlbmRzIEJ1dHRvbldpZGdldCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgc2V0QXR0cmlidXRlKHRoaXMuZWxlbSwgXCJyb2xlXCIsIFwic3dpdGNoXCIpO1xuICAgIHRoaXMuc2V0Q2hlY2tlZChmYWxzZSk7XG4gIH1cbiAgc2V0Q2hlY2tlZChjaGVja2VkKSB7XG4gICAgc2V0QXR0cmlidXRlKHRoaXMuZWxlbSwgXCJhcmlhLWNoZWNrZWRcIiwgY2hlY2tlZCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3dpZGdldC90b29sYmFyV2lkZ2V0LnRzXG52YXIgVG9vbGJhcldpZGdldCA9IGNsYXNzIGV4dGVuZHMgUm92aW5nVGFiQ29udGFpbmVyV2lkZ2V0IHtcbiAgY29uc3RydWN0b3Iob3JpZW50YXRpb24gPSBcImhvcml6b250YWxcIikge1xuICAgIHN1cGVyKG9yaWVudGF0aW9uLCBcInRvb2xiYXJcIik7XG4gIH1cbiAgZGVzdHJ1Y3RvcigpIHtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvZG9tL3Byb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLnRzXG5mdW5jdGlvbiBjaGVja1R5cGUodHlwZSwgbWV0YSkge1xuICByZXR1cm4gbWV0YS5wYXJhbXM/LnR5cGUgPT09IHR5cGU7XG59XG5mdW5jdGlvbiBhbGxvY2F0ZVJlc3VsdCh0eXBlKSB7XG4gIGlmIChcImJ1dHRvblwiID09PSB0eXBlKSB7XG4gICAgcmV0dXJuIG5ldyBCdXR0b25XaWRnZXQoKTtcbiAgfSBlbHNlIGlmIChcInNsaWRlclwiID09PSB0eXBlKSB7XG4gICAgcmV0dXJuIG5ldyBTbGlkZXJXaWRnZXQoKTtcbiAgfSBlbHNlIGlmIChcInRvb2xiYXJcIiA9PT0gdHlwZSkge1xuICAgIHJldHVybiBuZXcgVG9vbGJhcldpZGdldCgpO1xuICB9IGVsc2UgaWYgKFwiZ3JvdXBcIiA9PT0gdHlwZSkge1xuICAgIHJldHVybiBuZXcgR3JvdXBXaWRnZXQoKTtcbiAgfSBlbHNlIGlmIChcImxpc3RcIiA9PT0gdHlwZSkge1xuICAgIHJldHVybiBuZXcgTGlzdFdpZGdldCgpO1xuICB9IGVsc2UgaWYgKFwicmVnaW9uXCIgPT09IHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IE5hdGl2ZVdpZGdldChjcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgfSBlbHNlIGlmIChcInRleHRcIiA9PT0gdHlwZSkge1xuICAgIHJldHVybiBuZXcgQm91bmRlZFRleHRXaWRnZXQoKTtcbiAgfSBlbHNlIGlmIChcImxpc3Rzd2l0Y2hcIiA9PT0gdHlwZSkge1xuICAgIHJldHVybiBuZXcgU3dpdGNoV2lkZ2V0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoXCJBRyBDaGFydHMgLSBlcnJvciBhbGxvY2F0aW5nIG1ldGFcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGFsbG9jYXRlTWV0YShwYXJhbXMpIHtcbiAgY29uc3QgbWV0YSA9IHsgcGFyYW1zLCByZXN1bHQ6IHZvaWQgMCB9O1xuICBtZXRhLnJlc3VsdCA9IGFsbG9jYXRlUmVzdWx0KG1ldGEucGFyYW1zLnR5cGUpO1xuICByZXR1cm4gbWV0YTtcbn1cbnZhciBQcm94eUludGVyYWN0aW9uU2VydmljZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobG9jYWxlTWFuYWdlciwgZG9tTWFuYWdlcikge1xuICAgIHRoaXMubG9jYWxlTWFuYWdlciA9IGxvY2FsZU1hbmFnZXI7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gZG9tTWFuYWdlcjtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gIH1cbiAgYWRkTG9jYWxpc2F0aW9uKGZuKSB7XG4gICAgZm4oKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaCh0aGlzLmxvY2FsZU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsb2NhbGUtY2hhbmdlZFwiLCBmbikpO1xuICB9XG4gIGNyZWF0ZVByb3h5Q29udGFpbmVyKGFyZ3MpIHtcbiAgICBjb25zdCBtZXRhID0gYWxsb2NhdGVNZXRhKGFyZ3MpO1xuICAgIGNvbnN0IHsgcGFyYW1zLCByZXN1bHQgfSA9IG1ldGE7XG4gICAgY29uc3QgZGl2ID0gcmVzdWx0LmdldEVsZW1lbnQoKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIuYWRkQ2hpbGQoXCJjYW52YXMtcHJveHlcIiwgcGFyYW1zLmRvbU1hbmFnZXJJZCwgZGl2KTtcbiAgICBkaXYuY2xhc3NMaXN0LmFkZCguLi5wYXJhbXMuY2xhc3NMaXN0LCBcImFnLWNoYXJ0cy1wcm94eS1jb250YWluZXJcIik7XG4gICAgZGl2LnJvbGUgPSBwYXJhbXMudHlwZTtcbiAgICBpZiAoXCJhcmlhT3JpZW50YXRpb25cIiBpbiBwYXJhbXMpIHtcbiAgICAgIGRpdi5hcmlhT3JpZW50YXRpb24gPSBwYXJhbXMuYXJpYU9yaWVudGF0aW9uO1xuICAgIH1cbiAgICBpZiAoY2hlY2tUeXBlKFwidG9vbGJhclwiLCBtZXRhKSkge1xuICAgICAgbWV0YS5yZXN1bHQub3JpZW50YXRpb24gPSBtZXRhLnBhcmFtcy5vcmllbnRhdGlvbjtcbiAgICB9XG4gICAgdGhpcy5hZGRMb2NhbGlzYXRpb24oKCkgPT4ge1xuICAgICAgZGl2LmFyaWFMYWJlbCA9IHRoaXMubG9jYWxlTWFuYWdlci50KHBhcmFtcy5hcmlhTGFiZWwuaWQsIHBhcmFtcy5hcmlhTGFiZWwucGFyYW1zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNyZWF0ZVByb3h5RWxlbWVudChhcmdzKSB7XG4gICAgY29uc3QgbWV0YSA9IGFsbG9jYXRlTWV0YShhcmdzKTtcbiAgICBpZiAoY2hlY2tUeXBlKFwiYnV0dG9uXCIsIG1ldGEpKSB7XG4gICAgICBjb25zdCB7IHBhcmFtcywgcmVzdWx0IH0gPSBtZXRhO1xuICAgICAgY29uc3QgYnV0dG9uID0gcmVzdWx0LmdldEVsZW1lbnQoKTtcbiAgICAgIHRoaXMuaW5pdEludGVyYWN0KHBhcmFtcywgcmVzdWx0KTtcbiAgICAgIGlmICh0eXBlb2YgcGFyYW1zLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9IHBhcmFtcy50ZXh0Q29udGVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgdGV4dENvbnRlbnQgfSA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5hZGRMb2NhbGlzYXRpb24oKCkgPT4ge1xuICAgICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9IHRoaXMubG9jYWxlTWFuYWdlci50KHRleHRDb250ZW50LmlkLCB0ZXh0Q29udGVudC5wYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0UGFyZW50KG1ldGEucGFyYW1zLCBtZXRhLnJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChjaGVja1R5cGUoXCJzbGlkZXJcIiwgbWV0YSkpIHtcbiAgICAgIGNvbnN0IHsgcGFyYW1zLCByZXN1bHQgfSA9IG1ldGE7XG4gICAgICBjb25zdCBzbGlkZXIgPSByZXN1bHQuZ2V0RWxlbWVudCgpO1xuICAgICAgdGhpcy5pbml0SW50ZXJhY3QocGFyYW1zLCByZXN1bHQpO1xuICAgICAgc2xpZGVyLnR5cGUgPSBcInJhbmdlXCI7XG4gICAgICBzbGlkZXIucm9sZSA9IFwicHJlc2VudGF0aW9uXCI7XG4gICAgICBzbGlkZXIuc3R5bGUubWFyZ2luID0gXCIwcHhcIjtcbiAgICAgIHRoaXMuYWRkTG9jYWxpc2F0aW9uKCgpID0+IHtcbiAgICAgICAgc2xpZGVyLmFyaWFMYWJlbCA9IHRoaXMubG9jYWxlTWFuYWdlci50KHBhcmFtcy5hcmlhTGFiZWwuaWQsIHBhcmFtcy5hcmlhTGFiZWwucGFyYW1zKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRQYXJlbnQobWV0YS5wYXJhbXMsIG1ldGEucmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKGNoZWNrVHlwZShcInRleHRcIiwgbWV0YSkpIHtcbiAgICAgIGNvbnN0IHsgcGFyYW1zLCByZXN1bHQgfSA9IG1ldGE7XG4gICAgICB0aGlzLmluaXRFbGVtZW50KHBhcmFtcywgcmVzdWx0KTtcbiAgICAgIHRoaXMuc2V0UGFyZW50KG1ldGEucGFyYW1zLCBtZXRhLnJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChjaGVja1R5cGUoXCJsaXN0c3dpdGNoXCIsIG1ldGEpKSB7XG4gICAgICBjb25zdCB7IHBhcmFtcywgcmVzdWx0OiBidXR0b24gfSA9IG1ldGE7XG4gICAgICB0aGlzLmluaXRJbnRlcmFjdChwYXJhbXMsIGJ1dHRvbik7XG4gICAgICBidXR0b24uc2V0VGV4dENvbnRlbnQocGFyYW1zLnRleHRDb250ZW50KTtcbiAgICAgIGJ1dHRvbi5zZXRDaGVja2VkKHBhcmFtcy5hcmlhQ2hlY2tlZCk7XG4gICAgICBidXR0b24uc2V0QXJpYURlc2NyaWJlZEJ5KHBhcmFtcy5hcmlhRGVzY3JpYmVkQnkpO1xuICAgICAgdGhpcy5zZXRQYXJlbnQobWV0YS5wYXJhbXMsIG1ldGEucmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKGNoZWNrVHlwZShcInJlZ2lvblwiLCBtZXRhKSkge1xuICAgICAgY29uc3QgeyBwYXJhbXMsIHJlc3VsdCB9ID0gbWV0YTtcbiAgICAgIGNvbnN0IHJlZ2lvbiA9IHJlc3VsdC5nZXRFbGVtZW50KCk7XG4gICAgICB0aGlzLmluaXRJbnRlcmFjdChwYXJhbXMsIHJlc3VsdCk7XG4gICAgICByZWdpb24ucm9sZSA9IFwicmVnaW9uXCI7XG4gICAgICB0aGlzLnNldFBhcmVudChtZXRhLnBhcmFtcywgbWV0YS5yZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YS5yZXN1bHQ7XG4gIH1cbiAgaW5pdEVsZW1lbnQocGFyYW1zLCB3aWRnZXQpIHtcbiAgICBjb25zdCBlbGVtZW50MiA9IHdpZGdldC5nZXRFbGVtZW50KCk7XG4gICAgc2V0QXR0cmlidXRlKGVsZW1lbnQyLCBcImlkXCIsIHBhcmFtcy5pZCk7XG4gICAgc2V0RWxlbWVudFN0eWxlKGVsZW1lbnQyLCBcImN1cnNvclwiLCBwYXJhbXMuY3Vyc29yKTtcbiAgICBlbGVtZW50Mi5jbGFzc0xpc3QudG9nZ2xlKFwiYWctY2hhcnRzLXByb3h5LWVsZW1cIiwgdHJ1ZSk7XG4gICAgcmV0dXJuIGVsZW1lbnQyO1xuICB9XG4gIGluaXRJbnRlcmFjdChwYXJhbXMsIHdpZGdldCkge1xuICAgIGNvbnN0IHsgdGFiSW5kZXgsIGRvbUluZGV4IH0gPSBwYXJhbXM7XG4gICAgY29uc3QgZWxlbWVudDIgPSB0aGlzLmluaXRFbGVtZW50KHBhcmFtcywgd2lkZ2V0KTtcbiAgICBpZiAodGFiSW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgZWxlbWVudDIudGFiSW5kZXggPSB0YWJJbmRleDtcbiAgICB9XG4gICAgaWYgKGRvbUluZGV4ICE9PSB2b2lkIDApIHtcbiAgICAgIHdpZGdldC5kb21JbmRleCA9IGRvbUluZGV4O1xuICAgIH1cbiAgfVxuICBzZXRQYXJlbnQocGFyYW1zLCBlbGVtZW50Mikge1xuICAgIGlmIChcInBhcmVudFwiIGluIHBhcmFtcykge1xuICAgICAgcGFyYW1zLnBhcmVudD8uYWRkQ2hpbGQoZWxlbWVudDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpbnNlcnQgPSB7IHdoZXJlOiBwYXJhbXMud2hlcmUsIHF1ZXJ5OiBcIi5hZy1jaGFydHMtc2VyaWVzLWFyZWFcIiB9O1xuICAgICAgdGhpcy5kb21NYW5hZ2VyLmFkZENoaWxkKFwiY2FudmFzLXByb3h5XCIsIHBhcmFtcy5kb21NYW5hZ2VySWQsIGVsZW1lbnQyLmdldEVsZW1lbnQoKSwgaW5zZXJ0KTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1sb2NhbGUvc3JjL2VuLVVTLnRzXG52YXIgQUdfQ0hBUlRTX0xPQ0FMRV9FTl9VUyA9IHtcbiAgLy8gU2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnQgd2hlbiBmb2N1c2luZyBhbiBpdGVtIGluIHRoZSBjaGFydFxuICBhcmlhQW5ub3VuY2VIb3ZlckRhdHVtOiBcIiR7ZGF0dW19XCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50IHdoZW4gZm9jdXNpbmcgYSBjaGFydFxuICBhcmlhQW5ub3VuY2VDaGFydDogXCJjaGFydCwgJHtzZXJpZXNDb3VudH1bbnVtYmVyXSBzZXJpZXNcIixcbiAgLy8gU2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnQgd2hlbiBmb2N1c2luZyBhIGhpZXJhcmNoeSBjaGFydFxuICBhcmlhQW5ub3VuY2VIaWVyYXJjaHlDaGFydDogXCJoaWVyYXJjaHkgY2hhcnQsICR7Y2FwdGlvbn1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnQgd2hlbiBmb2N1c2luZyBhIGdhdWdlIGNoYXJ0XG4gIGFyaWFBbm5vdW5jZUdhdWdlQ2hhcnQ6IFwiZ2F1Z2UgY2hhcnQsICR7Y2FwdGlvbn1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnQgd2hlbiBmb2N1c2luZyBhbiBpdGVtIGluIGEgdHJlZW1hcCBvciBzdW5idXJzdCBjaGFydFxuICBhcmlhQW5ub3VuY2VIaWVyYXJjaHlEYXR1bTogXCJsZXZlbCAke2xldmVsfVtudW1iZXJdLCAke2NvdW50fVtudW1iZXJdIGNoaWxkcmVuLCAke2Rlc2NyaXB0aW9ufVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudCB3aGVuIGZvY3VzaW5nIGEgbGluayBpbiBhIFNhbmtleSBvciBjaG9yZCBjaGFydFxuICBhcmlhQW5ub3VuY2VGbG93UHJvcG9ydGlvbkxpbms6IFwibGluayAke2luZGV4fSBvZiAke2NvdW50fSwgZnJvbSAke2Zyb219IHRvICR7dG99LCAke3NpemVOYW1lfSAke3NpemV9XCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50IHdoZW4gZm9jdXNpbmcgYSBub2RlIGluIGEgU2Fua2V5IG9yIGNob3JkIGNoYXJ0XG4gIGFyaWFBbm5vdW5jZUZsb3dQcm9wb3J0aW9uTm9kZTogXCJub2RlICR7aW5kZXh9IG9mICR7Y291bnR9LCAke2Rlc2NyaXB0aW9ufVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIGRlc2NyaXB0aW9uIGZvciBsZWdlbmQgaXRlbXNcbiAgYXJpYURlc2NyaXB0aW9uTGVnZW5kSXRlbTogXCJQcmVzcyBTcGFjZSBvciBFbnRlciB0byB0b2dnbGUgdmlzaWJpbGl0eVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIGZvciB0aGUgJysnIGhvcml6b250YWwgbGluZSBidXR0b24gb24gdGhlIFktYXhpc1xuICBhcmlhTGFiZWxBZGRIb3Jpem9udGFsTGluZTogXCJBZGQgSG9yaXpvbnRhbCBMaW5lXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgYW5ub3RhdGlvbi1vcHRpb25zIHRvb2xiYXJcbiAgYXJpYUxhYmVsQW5ub3RhdGlvbk9wdGlvbnNUb29sYmFyOiBcIkFubm90YXRpb24gT3B0aW9uc1wiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIGFubm90YXRpb24tc2V0dGluZ3MgZGlhbG9nXG4gIGFyaWFMYWJlbEFubm90YXRpb25TZXR0aW5nc0RpYWxvZzogXCJBbm5vdGF0aW9uIFNldHRpbmdzXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIGNvbG9yIHBpY2tlciBkaWFsb2dcbiAgYXJpYUxhYmVsQ29sb3JQaWNrZXI6IFwiQ29sb3IgcGlja2VyXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIGZpbmFuY2lhbCBjaGFydHMgdG9vbGJhclxuICBhcmlhTGFiZWxGaW5hbmNpYWxDaGFydHM6IFwiRmluYW5jaWFsIENoYXJ0c1wiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHRoZSBsZWdlbmQgdG9vbGJhclxuICBhcmlhTGFiZWxMZWdlbmQ6IFwiTGVnZW5kXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIGxlZ2VuZCBwYWdpbmF0aW9uIGJ1dHRvblxuICBhcmlhTGFiZWxMZWdlbmRQYWdpbmF0aW9uOiBcIkxlZ2VuZCBQYWdpbmF0aW9uXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIHByZXZpb3VzIGxlZ2VuZCBwYWdlIGJ1dHRvblxuICBhcmlhTGFiZWxMZWdlbmRQYWdlUHJldmlvdXM6IFwiUHJldmlvdXMgTGVnZW5kIFBhZ2VcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgbmV4dCBsZWdlbmQgcGFnZSBidXR0b25cbiAgYXJpYUxhYmVsTGVnZW5kUGFnZU5leHQ6IFwiTmV4dCBMZWdlbmQgUGFnZVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHRoZSBhbiBpdGVtIGluIHRoZSBsZWdlbmRcbiAgYXJpYUxhYmVsTGVnZW5kSXRlbTogXCIke2xhYmVsfSwgTGVnZW5kIGl0ZW0gJHtpbmRleH1bbnVtYmVyXSBvZiAke2NvdW50fVtudW1iZXJdXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIGFuIHVua25vd24gaXRlbSBpbiB0aGUgbGVnZW5kXG4gIGFyaWFMYWJlbExlZ2VuZEl0ZW1Vbmtub3duOiBcIlVua25vd24gbGVnZW5kIGl0ZW1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgbmF2aWdhdG9yIGVsZW1lbnRcbiAgYXJpYUxhYmVsTmF2aWdhdG9yOiBcIk5hdmlnYXRvclwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIGFuIGFjY2Vzc2liaWxpdHkgY29udHJvbCB0aGF0IGNoYW5nZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBuYXZpZ2F0b3IncyByYW5nZVxuICBhcmlhTGFiZWxOYXZpZ2F0b3JSYW5nZTogXCJSYW5nZVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIGFuIGFjY2Vzc2liaWxpdHkgY29udHJvbCB0aGF0IGNoYW5nZXMgdGhlIHN0YXJ0IG9mIHRoZSBuYXZpZ2F0b3IncyByYW5nZVxuICBhcmlhTGFiZWxOYXZpZ2F0b3JNaW5pbXVtOiBcIk1pbmltdW1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciBhbiBhY2Nlc3NpYmlsaXR5IGNvbnRyb2wgdGhhdCBjaGFuZ2VzIHRoZSBlbmQgb2YgdGhlIG5hdmlnYXRvcidzIHJhbmdlXG4gIGFyaWFMYWJlbE5hdmlnYXRvck1heGltdW06IFwiTWF4aW11bVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHJhbmdlcyB0b29sYmFyXG4gIGFyaWFMYWJlbFJhbmdlc1Rvb2xiYXI6IFwiUmFuZ2VzXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIHNldHRpbmdzIGRpYWxvZyB0YWItYmFyXG4gIGFyaWFMYWJlbFNldHRpbmdzVGFiQmFyOiBcIlNldHRpbmdzXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3Igem9vbSB0b29sYmFyXG4gIGFyaWFMYWJlbFpvb21Ub29sYmFyOiBcIlpvb21cIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgdmFsdWUgb2YgdGhlIG5hdmlnYXRvcidzIHJhbmdlXG4gIGFyaWFWYWx1ZVBhblJhbmdlOiBcIiR7bWlufVtwZXJjZW50XSB0byAke21heH1bcGVyY2VudF1cIixcbiAgLy8gQWx0LXRleHQgZm9yIHRoZSBzb2xpZCBsaW5lIGRhc2ggc3R5bGUgbWVudSBpdGVtIGljb25cbiAgaWNvbkFsdFRleHRMaW5lU3R5bGVTb2xpZDogXCJTb2xpZFwiLFxuICAvLyBBbHQtdGV4dCBmb3IgdGhlIGxvbmctZGFzaGVkIGxpbmUgZGFzaCBzdHlsZSBtZW51IGl0ZW0gaWNvblxuICBpY29uQWx0VGV4dExpbmVTdHlsZURhc2hlZDogXCJMb25nLWRhc2hlZFwiLFxuICAvLyBBbHQtdGV4dCBmb3IgdGhlIHNob3J0LWRhc2hlZCBsaW5lIGRhc2ggc3R5bGUgbWVudSBpdGVtIGljb25cbiAgaWNvbkFsdFRleHRMaW5lU3R5bGVEb3R0ZWQ6IFwiU2hvcnQtZGFzaGVkXCIsXG4gIC8vIEFsdC10ZXh0IGZvciB0aGUgJ3Bvc2l0aW9uLXRvcCcgaWNvblxuICBpY29uQWx0VGV4dFBvc2l0aW9uVG9wOiBcIlRvcFwiLFxuICAvLyBBbHQtdGV4dCBmb3IgdGhlICdwb3NpdGlvbi1jZW50ZXInIGljb25cbiAgaWNvbkFsdFRleHRQb3NpdGlvbkNlbnRlcjogXCJDZW50ZXJcIixcbiAgLy8gQWx0LXRleHQgZm9yIHRoZSAncG9zaXRpb24tYm90dG9tJyBpY29uXG4gIGljb25BbHRUZXh0UG9zaXRpb25Cb3R0b206IFwiQm90dG9tXCIsXG4gIC8vIEFsdC10ZXh0IGZvciB0aGUgJ3Bvc2l0aW9uLWxlZnQnIGljb25cbiAgaWNvbkFsdFRleHRBbGlnbkxlZnQ6IFwiTGVmdFwiLFxuICAvLyBBbHQtdGV4dCBmb3IgdGhlICdhbGlnbi1jZW50ZXInIGljb25cbiAgaWNvbkFsdFRleHRBbGlnbkNlbnRlcjogXCJDZW50ZXJcIixcbiAgLy8gQWx0LXRleHQgZm9yIHRoZSAncG9zaXRpb24tcmlnaHQnIGljb25cbiAgaWNvbkFsdFRleHRBbGlnblJpZ2h0OiBcIlJpZ2h0XCIsXG4gIC8vIEFsdC10ZXh0IGZvciB0aGUgJ2Nsb3NlJyBpY29uXG4gIGljb25BbHRUZXh0Q2xvc2U6IFwiQ2xvc2VcIixcbiAgLy8gRGVmYXVsdCB0ZXh0IGZvciB0aGUgJ2xvYWRpbmcgZGF0YScgb3ZlcmxheVxuICBvdmVybGF5TG9hZGluZ0RhdGE6IFwiTG9hZGluZyBkYXRhLi4uXCIsXG4gIC8vIERlZmF1bHQgdGV4dCBmb3IgdGhlICdubyBkYXRhJyBvdmVybGF5XG4gIG92ZXJsYXlOb0RhdGE6IFwiTm8gZGF0YSB0byBkaXNwbGF5XCIsXG4gIC8vIERlZmF1bHQgdGV4dCBmb3IgdGhlICdubyB2aXNpYmxlIHNlcmllcycgb3ZlcmxheVxuICBvdmVybGF5Tm9WaXNpYmxlU2VyaWVzOiBcIk5vIHZpc2libGUgc2VyaWVzXCIsXG4gIC8vIERlZmF1bHQgdGV4dCBmb3IgdGhlICd1bnN1cHBvcnRlZCBicm93c2VyJyBvdmVybGF5XG4gIG92ZXJsYXlVbnN1cHBvcnRlZEJyb3dzZXI6IFwiSW5jb21wYXRpYmxlIGJyb3dzZXIgdmVyc2lvbi4gUGxlYXNlIHVwZ3JhZGUgeW91ciBicm93c2VyLlwiLFxuICAvLyBUZXh0IGZvciBmcmVxdWVuY3kgbGFiZWwgaW4gSGlzdG9ncmFtIFNlcmllcyB0b29sdGlwXG4gIHNlcmllc0hpc3RvZ3JhbVRvb2x0aXBGcmVxdWVuY3k6IFwiRnJlcXVlbmN5XCIsXG4gIC8vIFRleHQgZm9yIHN1bSBsYWJlbCBpbiBIaXN0b2dyYW0gU2VyaWVzIHRvb2x0aXBcbiAgc2VyaWVzSGlzdG9ncmFtVG9vbHRpcFN1bTogXCIke3lOYW1lfSAoc3VtKVwiLFxuICAvLyBUZXh0IGZvciBzdW0gbGFiZWwgaW4gSGlzdG9ncmFtIFNlcmllcyB0b29sdGlwXG4gIHNlcmllc0hpc3RvZ3JhbVRvb2x0aXBDb3VudDogXCIke3lOYW1lfSAoY291bnQpXCIsXG4gIC8vIFRleHQgZm9yIHN1bSBsYWJlbCBpbiBIaXN0b2dyYW0gU2VyaWVzIHRvb2x0aXBcbiAgc2VyaWVzSGlzdG9ncmFtVG9vbHRpcE1lYW46IFwiJHt5TmFtZX0gKG1lYW4pXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgY2hhcnQgdHlwZSBidXR0b25cbiAgdG9vbGJhclNlcmllc1R5cGVEcm9wZG93bjogXCJDaGFydCBUeXBlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgT0hMQyBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZU9ITEM6IFwiT0hMQ1wiLFxuICAvLyBUZXh0IGZvciB0aGUgc2VyaWVzIHR5cGUgdG9vbGJhcidzIEhMQyBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZUhMQzogXCJITENcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBoaWdoIGxvdyBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZUhpZ2hMb3c6IFwiSGlnaCBMb3dcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBjYW5kbGVzIGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlQ2FuZGxlczogXCJDYW5kbGVzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgaG9sbG93IGNhbmRsZXMgY2hhcnQgdHlwZSBidXR0b25cbiAgdG9vbGJhclNlcmllc1R5cGVIb2xsb3dDYW5kbGVzOiBcIkhvbGxvdyBDYW5kbGVzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgbGluZSBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZUxpbmU6IFwiTGluZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgc2VyaWVzIHR5cGUgdG9vbGJhcidzIGxpbmUgd2l0aCBtYXJrZXJzIGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlTGluZVdpdGhNYXJrZXJzOiBcIkxpbmUgd2l0aCBNYXJrZXJzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgbGluZSB3aXRoIHN0ZXAgbGluZSBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZVN0ZXBMaW5lOiBcIlN0ZXAgTGluZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgdHJlbmQgbGluZSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zVHJlbmRMaW5lOiBcIlRyZW5kIExpbmVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIEZpYm9uYWNjaSBSZXRyYWNlbWVudCBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zRmlib25hY2NpUmV0cmFjZW1lbnQ6IFwiRmliIFJldHJhY2VtZW50XCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBGaWJvbmFjY2kgUmV0cmFjZW1lbnQgVHJlbmQgQmFzZWQgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0ZpYm9uYWNjaVJldHJhY2VtZW50VHJlbmRCYXNlZDogXCJGaWIgVHJlbmQgQmFzZWRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGhvcml6b250YWwgbGluZSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zSG9yaXpvbnRhbExpbmU6IFwiSG9yaXpvbnRhbCBMaW5lXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyB2ZXJ0aWNhbCBsaW5lIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNWZXJ0aWNhbExpbmU6IFwiVmVydGljYWwgTGluZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgcGFyYWxsZWwgY2hhbm5lbCBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zUGFyYWxsZWxDaGFubmVsOiBcIlBhcmFsbGVsIENoYW5uZWxcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGRpc2pvaW50IGNoYW5uZWwgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0Rpc2pvaW50Q2hhbm5lbDogXCJEaXNqb2ludCBDaGFubmVsXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBjbGVhciBhbGwgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0NsZWFyQWxsOiBcIkNsZWFyIEFsbFwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgZmlsbCBjb2xvciBwaWNrZXIgYW5ub3RhdGlvbiBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zRmlsbENvbG9yOiBcIkZpbGwgQ29sb3JcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGxpbmUgY29sb3IgcGlja2VyIGFubm90YXRpb24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0xpbmVDb2xvcjogXCJMaW5lIENvbG9yXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBsaW5lIHN0eWxlIHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0xpbmVTdHlsZTogXCJMaW5lIFN0eWxlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBsaW5lIHN0cm9rZSB3aWR0aCBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zTGluZVN0cm9rZVdpZHRoOiBcIkxpbmUgU3Ryb2tlIFdpZHRoXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBzZXR0aW5ncyBhbm5vdGF0aW9uIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNTZXR0aW5nczogXCJTZXR0aW5nc1wiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgdGV4dCBjb2xvciBwaWNrZXIgYW5ub3RhdGlvbiBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zVGV4dENvbG9yOiBcIlRleHQgQ29sb3JcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHRleHQgc2l6ZSBwaWNrZXIgYW5ub3RhdGlvbiBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zVGV4dFNpemU6IFwiVGV4dCBTaXplXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBsb2NrIGFubm90YXRpb24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0xvY2s6IFwiTG9ja1wiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgdW5sb2NrIGFubm90YXRpb24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1VubG9jazogXCJVbmxvY2tcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGRlbGV0ZSBhbm5vdGF0aW9uIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNEZWxldGU6IFwiRGVsZXRlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBkcmFnIGhhbmRsZVxuICB0b29sYmFyQW5ub3RhdGlvbnNEcmFnSGFuZGxlOiBcIkRyYWcgVG9vbGJhclwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgbGluZSBkcmF3aW5ncyBtZW51IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNMaW5lQW5ub3RhdGlvbnM6IFwiVHJlbmQgTGluZXNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIEZpYm9uYWNjaSBkcmF3aW5ncyBtZW51IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNGaWJvbmFjY2lBbm5vdGF0aW9uczogXCJGaWJvbmFjY2lcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHRleHQgYW5ub3RhdGlvbnMgbWVudSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zVGV4dEFubm90YXRpb25zOiBcIlRleHQgQW5ub3RhdGlvbnNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHNoYXBlcyBtZW51IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNTaGFwZUFubm90YXRpb25zOiBcIkFycm93c1wiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgbWVhc3VyZXJzIG1lbnUgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc01lYXN1cmVyQW5ub3RhdGlvbnM6IFwiTWVhc3VyZXJzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBjYWxsb3V0IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNDYWxsb3V0OiBcIkNhbGxvdXRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGNvbW1lbnQgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0NvbW1lbnQ6IFwiQ29tbWVudFwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3Mgbm90ZSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zTm90ZTogXCJOb3RlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyB0ZXh0IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNUZXh0OiBcIlRleHRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGFycm93IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNBcnJvdzogXCJBcnJvd1wiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgYXJyb3cgdXAgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0Fycm93VXA6IFwiQXJyb3cgVXBcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGFycm93IGRvd24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0Fycm93RG93bjogXCJBcnJvdyBEb3duXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBkYXRlIHJhbmdlIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNEYXRlUmFuZ2U6IFwiRGF0ZSBSYW5nZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgcHJpY2UgcmFuZ2UgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1ByaWNlUmFuZ2U6IFwiUHJpY2UgUmFuZ2VcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGRhdGUgYW5kIHByaWNlIHJhbmdlIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNEYXRlUHJpY2VSYW5nZTogXCJEYXRlIGFuZCBQcmljZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgcXVpY2sgZGF0ZSBhbmQgcHJpY2UgcmFuZ2UgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1F1aWNrRGF0ZVByaWNlUmFuZ2U6IFwiTWVhc3VyZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDEgbW9udGggYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTFNb250aDogXCIxTVwiLFxuICAvLyBBcmlhIGxhYmVsIGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDEgbW9udGggYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTFNb250aEFyaWE6IFwiMSBtb250aFwiLFxuICAvLyBUZXh0IGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDMgbW9udGggYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTNNb250aHM6IFwiM01cIixcbiAgLy8gQXJpYSBsYWJlbCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyAzIG1vbnRoIGJ1dHRvblxuICB0b29sYmFyUmFuZ2UzTW9udGhzQXJpYTogXCIzIG1vbnRoc1wiLFxuICAvLyBUZXh0IGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDYgbW9udGggYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTZNb250aHM6IFwiNk1cIixcbiAgLy8gQXJpYSBsYWJlbCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyA2IG1vbnRoIGJ1dHRvblxuICB0b29sYmFyUmFuZ2U2TW9udGhzQXJpYTogXCI2IG1vbnRoc1wiLFxuICAvLyBUZXh0IGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIHllYXIgdG8gZGF0ZSBidXR0b25cbiAgdG9vbGJhclJhbmdlWWVhclRvRGF0ZTogXCJZVERcIixcbiAgLy8gQXJpYSBsYWJlbCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyB5ZWFyIHRvIGRhdGUgbW9udGggYnV0dG9uXG4gIHRvb2xiYXJSYW5nZVllYXJUb0RhdGVBcmlhOiBcIlllYXIgdG8gZGF0ZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIDEgeWVhciBidXR0b25cbiAgdG9vbGJhclJhbmdlMVllYXI6IFwiMVlcIixcbiAgLy8gQXJpYSBsYWJlbCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyAxIHllYXIgYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTFZZWFyQXJpYTogXCIxIHllYXJcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyBmdWxsIHJhbmdlIGJ1dHRvblxuICB0b29sYmFyUmFuZ2VBbGw6IFwiQWxsXCIsXG4gIC8vIEFyaWEgbGFiZWwgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgZnVsbCByYW5nZSBidXR0b25cbiAgdG9vbGJhclJhbmdlQWxsQXJpYTogXCJBbGxcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHpvb20gb3V0IGJ1dHRvblxuICB0b29sYmFyWm9vbVpvb21PdXQ6IFwiWm9vbSBvdXRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHpvb20gaW4gYnV0dG9uXG4gIHRvb2xiYXJab29tWm9vbUluOiBcIlpvb20gaW5cIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHBhbiBsZWZ0IGJ1dHRvblxuICB0b29sYmFyWm9vbVBhbkxlZnQ6IFwiUGFuIGxlZnRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHBhbiByaWdodCBidXR0b25cbiAgdG9vbGJhclpvb21QYW5SaWdodDogXCJQYW4gcmlnaHRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHBhbiB0byB0aGUgc3RhcnQgYnV0dG9uXG4gIHRvb2xiYXJab29tUGFuU3RhcnQ6IFwiUGFuIHRvIHRoZSBzdGFydFwiLFxuICAvLyBUZXh0IGZvciB0aGUgem9vbSB0b29sYmFyJ3MgcGFuIHRvIHRoZSBlbmQgYnV0dG9uXG4gIHRvb2xiYXJab29tUGFuRW5kOiBcIlBhbiB0byB0aGUgZW5kXCIsXG4gIC8vIFRleHQgZm9yIHRoZSB6b29tIHRvb2xiYXIncyBwYW4gcmVzZXQgYnV0dG9uXG4gIHRvb2xiYXJab29tUmVzZXQ6IFwiUmVzZXQgdGhlIHpvb21cIixcbiAgLy8gVGV4dCBmb3IgdGhlIGNvbnRleHQgbWVudSdzIGRvd25sb2FkIGJ1dHRvblxuICBjb250ZXh0TWVudURvd25sb2FkOiBcIkRvd25sb2FkXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBjb250ZXh0IG1lbnUncyB0b2dnbGUgc2VyaWVzIHZpc2liaWxpdHkgYnV0dG9uXG4gIGNvbnRleHRNZW51VG9nZ2xlU2VyaWVzVmlzaWJpbGl0eTogXCJUb2dnbGUgVmlzaWJpbGl0eVwiLFxuICAvLyBUZXh0IGZvciB0aGUgY29udGV4dCBtZW51J3MgdG9nZ2xlIG90aGVyIHNlcmllcyB2aXNpYmlsaXR5IGJ1dHRvblxuICBjb250ZXh0TWVudVRvZ2dsZU90aGVyU2VyaWVzOiBcIlRvZ2dsZSBPdGhlciBTZXJpZXNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGNvbnRleHQgbWVudSdzIHpvb20gdG8gcG9pbnQgYnV0dG9uXG4gIGNvbnRleHRNZW51Wm9vbVRvQ3Vyc29yOiBcIlpvb20gdG8gaGVyZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgY29udGV4dCBtZW51J3MgcGFuIHRvIHBvaW50IGJ1dHRvblxuICBjb250ZXh0TWVudVBhblRvQ3Vyc29yOiBcIlBhbiB0byBoZXJlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGhlYWRlciBjaGFubmVsIHRhYiBsYWJlbFxuICBkaWFsb2dIZWFkZXJDaGFubmVsOiBcIkNoYW5uZWxcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgaGVhZGVyIGxpbmUgdGFiIGxhYmVsXG4gIGRpYWxvZ0hlYWRlckxpbmU6IFwiTGluZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyBoZWFkZXIgZmlib25hY2NpIHJldHJhY2VtZW50IGxpbmUgdGFiIGxhYmVsXG4gIGRpYWxvZ0hlYWRlckZpYm9uYWNjaVJhbmdlOiBcIkZpYiBSZXRyYWNlbWVudFwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyBoZWFkZXIgZGF0ZSByYW5nZSB0YWIgbGFiZWxcbiAgZGlhbG9nSGVhZGVyRGF0ZVJhbmdlOiBcIkRhdGUgUmFuZ2VcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgaGVhZGVyIHByaWNlIHJhbmdlIHRhYiBsYWJlbFxuICBkaWFsb2dIZWFkZXJQcmljZVJhbmdlOiBcIlByaWNlIFJhbmdlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGhlYWRlciBkYXRlIGFuZCBwcmljZSByYW5nZSB0YWIgbGFiZWxcbiAgZGlhbG9nSGVhZGVyRGF0ZVByaWNlUmFuZ2U6IFwiRGF0ZSBhbmQgUHJpY2VcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgaGVhZGVyIHRleHQgdGFiIGxhYmVsXG4gIGRpYWxvZ0hlYWRlclRleHQ6IFwiVGV4dFwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyB0ZXh0IGFsaWdubWVudCByYWRpbyBsYWJlbFxuICBkaWFsb2dJbnB1dEFsaWduOiBcIkFsaWduXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGNvbG9yIHBpY2tlciBsYWJlbFxuICBkaWFsb2dJbnB1dENvbG9yUGlja2VyOiBcIkNvbG9yXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGNvbG9yIHBpY2tlciBhbHQgdGV4dFxuICBkaWFsb2dJbnB1dENvbG9yUGlja2VyQWx0VGV4dDogXCJUZXh0IENvbG9yXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGZpbGwgY29sb3IgcGlja2VyIGxhYmVsXG4gIGRpYWxvZ0lucHV0RmlsbENvbG9yUGlja2VyOiBcIkZpbGxcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgZmlsbCBjb2xvciBwaWNrZXIgYWx0IHRleHRcbiAgZGlhbG9nSW5wdXRGaWxsQ29sb3JQaWNrZXJBbHRUZXh0OiBcIkZpbGwgQ29sb3JcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgZXh0ZW5kIGNoYW5uZWwgc3RhcnQgY2hlY2tib3hcbiAgZGlhbG9nSW5wdXRFeHRlbmRDaGFubmVsU3RhcnQ6IFwiRXh0ZW5kIGNoYW5uZWwgc3RhcnRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgZXh0ZW5kIGNoYW5uZWwgZW5kIGNoZWNrYm94XG4gIGRpYWxvZ0lucHV0RXh0ZW5kQ2hhbm5lbEVuZDogXCJFeHRlbmQgY2hhbm5lbCBlbmRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgZXh0ZW5kIGxpbmUgc3RhcnQgY2hlY2tib3hcbiAgZGlhbG9nSW5wdXRFeHRlbmRMaW5lU3RhcnQ6IFwiRXh0ZW5kIGxpbmUgc3RhcnRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgZXh0ZW5kIGxpbmUgZW5kIGNoZWNrYm94XG4gIGRpYWxvZ0lucHV0RXh0ZW5kTGluZUVuZDogXCJFeHRlbmQgbGluZSBlbmRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgZXh0ZW5kIGFib3ZlIGNoZWNrYm94XG4gIGRpYWxvZ0lucHV0RXh0ZW5kQWJvdmU6IFwiRXh0ZW5kIGFib3ZlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGV4dGVuZCBiZWxvdyBjaGVja2JveFxuICBkaWFsb2dJbnB1dEV4dGVuZEJlbG93OiBcIkV4dGVuZCBiZWxvd1wiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyBleHRlbmQgbGVmdCBjaGVja2JveFxuICBkaWFsb2dJbnB1dEV4dGVuZExlZnQ6IFwiRXh0ZW5kIGxlZnRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgZXh0ZW5kIHJpZ2h0IGNoZWNrYm94XG4gIGRpYWxvZ0lucHV0RXh0ZW5kUmlnaHQ6IFwiRXh0ZW5kIHJpZ2h0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIHJldmVyc2UgY2hlY2tib3hcbiAgZGlhbG9nSW5wdXRSZXZlcnNlOiBcIlJldmVyc2VcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3Mgc2hvdyBmaWxsIGNoZWNrYm94XG4gIGRpYWxvZ0lucHV0U2hvd0ZpbGw6IFwiU2hvdyBGaWxsXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIGZvbnQgc2l6ZSBzZWxlY3QgYm94IGxhYmVsXG4gIGRpYWxvZ0lucHV0Rm9udFNpemU6IFwiU2l6ZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyBmb250IHNpemUgc2VsZWN0IGJveCBhbHQgdGV4dFxuICBkaWFsb2dJbnB1dEZvbnRTaXplQWx0VGV4dDogXCJGb250IFNpemVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3MgbGluZSBzdHlsZSByYWRpbyBsYWJlbFxuICBkaWFsb2dJbnB1dExpbmVTdHlsZTogXCJEYXNoXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIHRleHQgcG9zaXRpb24gcmFkaW8gbGFiZWxcbiAgZGlhbG9nSW5wdXRQb3NpdGlvbjogXCJQb3NpdGlvblwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiBkaWFsb2cncyBzdHJva2Ugd2lkdGggbGFiZWxcbiAgZGlhbG9nSW5wdXRTdHJva2VXaWR0aDogXCJXZWlnaHRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gZGlhbG9nJ3Mgc3Ryb2tlIHdpZHRoIGxhYmVsXG4gIGRpYWxvZ0lucHV0U3Ryb2tlV2lkdGhBbHRUZXh0OiBcIkxpbmUgV2VpZ2h0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIEZpYm9uYWNjaSBiYW5kcyBsYWJlbFxuICBkaWFsb2dJbnB1dEZpYm9uYWNjaUJhbmRzOiBcIkJhbmRzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIGRpYWxvZydzIEZpYm9uYWNjaSBiYW5kcyBsYWJlbFxuICBkaWFsb2dJbnB1dEZpYm9uYWNjaUJhbmRzQWx0VGV4dDogXCJGaWJvbmFjY2kgQmFuZHNcIixcbiAgLy8gVGV4dCBmb3IgdGV4dCBhcmVhIGlucHV0IHBsYWNlaG9sZGVyc1xuICBpbnB1dFRleHRhcmVhUGxhY2Vob2xkZXI6IFwiQWRkIFRleHRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIG1lYXN1cmVyIHN0YXRpc3RpY3MgZGF0ZSByYW5nZSBiYXJzIHZhbHVlXG4gIG1lYXN1cmVyRGF0ZVJhbmdlQmFyczogXCIke3ZhbHVlfVtudW1iZXJdIGJhcnNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIG1lYXN1cmVyIHN0YXRpc3RpY3MgcHJpY2UgcmFuZ2UgdmFsdWVcbiAgbWVhc3VyZXJQcmljZVJhbmdlVmFsdWU6IFwiJHt2YWx1ZX1bbnVtYmVyXVwiLFxuICAvLyBUZXh0IGZvciB0aGUgbWVhc3VyZXIgc3RhdGlzdGljcyBwcmljZSByYW5nZSBwZXJjZW50YWdlXG4gIG1lYXN1cmVyUHJpY2VSYW5nZVBlcmNlbnQ6IFwiJHt2YWx1ZX1bcGVyY2VudF1cIixcbiAgLy8gVGV4dCBmb3IgdGhlIG1lYXN1cmVyIHN0YXRpc3RpY3Mgdm9sdW1lIHZhbHVlXG4gIG1lYXN1cmVyVm9sdW1lOiBcIlZvbCAke3ZhbHVlfVwiXG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9sb2NhbGUvZGVmYXVsdE1lc3NhZ2VGb3JtYXR0ZXIudHNcbnZhciBtZXNzYWdlUmVnRXhwID0gL1xcJFxceyhcXHcrKX0oPzpcXFsoXFx3KyldKT8vZ2k7XG52YXIgZm9ybWF0dGVycyA9IHtcbiAgbnVtYmVyOiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoXCJlbi1VU1wiKSxcbiAgcGVyY2VudDogbmV3IEludGwuTnVtYmVyRm9ybWF0KFwiZW4tVVNcIiwgeyBzdHlsZTogXCJwZXJjZW50XCIsIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMiwgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyIH0pLFxuICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHsgZGF0ZVN0eWxlOiBcImZ1bGxcIiB9KSxcbiAgdGltZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlbi1VU1wiLCB7IHRpbWVTdHlsZTogXCJmdWxsXCIgfSksXG4gIGRhdGV0aW1lOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHsgZGF0ZVN0eWxlOiBcImZ1bGxcIiwgdGltZVN0eWxlOiBcImZ1bGxcIiB9KVxufTtcbnZhciBkZWZhdWx0TWVzc2FnZUZvcm1hdHRlciA9ICh7IGRlZmF1bHRWYWx1ZSwgdmFyaWFibGVzIH0pID0+IHtcbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZT8ucmVwbGFjZUFsbChtZXNzYWdlUmVnRXhwLCAoXywgbWF0Y2gsIGZvcm1hdCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gdmFyaWFibGVzW21hdGNoXTtcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBmb3JtYXQgIT0gbnVsbCA/IGZvcm1hdHRlcnNbZm9ybWF0XSA6IG51bGw7XG4gICAgaWYgKGZvcm1hdCAhPSBudWxsICYmIGZvcm1hdHRlciA9PSBudWxsKSB7XG4gICAgICBsb2dnZXJfZXhwb3J0cy53YXJuT25jZShgRm9ybWF0IHN0eWxlIFske2Zvcm1hdH1dIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdHRlciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLm51bWJlci5mb3JtYXQodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5kYXRldGltZS5mb3JtYXQodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgfSk7XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9sb2NhbGUvbG9jYWxlTWFuYWdlci50c1xudmFyIExvY2FsZU1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIExpc3RlbmVycyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5sb2NhbGVUZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMuZ2V0TG9jYWxlVGV4dCA9IHZvaWQgMDtcbiAgfVxuICBzZXRMb2NhbGVUZXh0KGxvY2FsZVRleHQpIHtcbiAgICBpZiAodGhpcy5sb2NhbGVUZXh0ICE9PSBsb2NhbGVUZXh0KSB7XG4gICAgICB0aGlzLmxvY2FsZVRleHQgPSBsb2NhbGVUZXh0O1xuICAgICAgdGhpcy5kaXNwYXRjaChcImxvY2FsZS1jaGFuZ2VkXCIpO1xuICAgIH1cbiAgfVxuICBzZXRMb2NhbGVUZXh0Rm9ybWF0dGVyKGdldExvY2FsZVRleHQpIHtcbiAgICB0aGlzLmdldExvY2FsZVRleHQgPSBnZXRMb2NhbGVUZXh0O1xuICAgIGlmICh0aGlzLmdldExvY2FsZVRleHQgIT09IGdldExvY2FsZVRleHQpIHtcbiAgICAgIHRoaXMuZ2V0TG9jYWxlVGV4dCA9IGdldExvY2FsZVRleHQ7XG4gICAgICB0aGlzLmRpc3BhdGNoKFwibG9jYWxlLWNoYW5nZWRcIik7XG4gICAgfVxuICB9XG4gIHQoa2V5LCB2YXJpYWJsZXMgPSB7fSkge1xuICAgIGNvbnN0IHsgbG9jYWxlVGV4dCA9IEFHX0NIQVJUU19MT0NBTEVfRU5fVVMsIGdldExvY2FsZVRleHQgfSA9IHRoaXM7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlID0gbG9jYWxlVGV4dFtrZXldO1xuICAgIHJldHVybiBnZXRMb2NhbGVUZXh0Py4oeyBrZXksIGRlZmF1bHRWYWx1ZSwgdmFyaWFibGVzIH0pID8/IGRlZmF1bHRNZXNzYWdlRm9ybWF0dGVyKHsga2V5LCBkZWZhdWx0VmFsdWUsIHZhcmlhYmxlcyB9KSA/PyBrZXk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2NhbnZhcy9oZHBpQ2FudmFzLnRzXG52YXIgSGRwaUNhbnZhcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy53aWR0aCA9IDYwMDtcbiAgICB0aGlzLmhlaWdodCA9IDMwMDtcbiAgICBjb25zdCB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiwgY2FudmFzRWxlbWVudCwgd2lsbFJlYWRGcmVxdWVudGx5ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5waXhlbFJhdGlvID0gb3B0aW9ucy5waXhlbFJhdGlvID8/IGdldFdpbmRvdyhcImRldmljZVBpeGVsUmF0aW9cIikgPz8gMTtcbiAgICB0aGlzLmVsZW1lbnQgPSBjYW52YXNFbGVtZW50ID8/IGNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gKHdpZHRoMiA/PyB0aGlzLndpZHRoKSArIFwicHhcIjtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKGhlaWdodDIgPz8gdGhpcy5oZWlnaHQpICsgXCJweFwiO1xuICAgIHRoaXMuZWxlbWVudC53aWR0aCA9IE1hdGgucm91bmQoKHdpZHRoMiA/PyB0aGlzLndpZHRoKSAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgdGhpcy5lbGVtZW50LmhlaWdodCA9IE1hdGgucm91bmQoKGhlaWdodDIgPz8gdGhpcy5oZWlnaHQpICogdGhpcy5waXhlbFJhdGlvKTtcbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmVsZW1lbnQuZ2V0Q29udGV4dChcIjJkXCIsIHsgd2lsbFJlYWRGcmVxdWVudGx5IH0pO1xuICAgIHRoaXMub25FbmFibGVkQ2hhbmdlKCk7XG4gICAgdGhpcy5yZXNpemUod2lkdGgyID8/IDAsIGhlaWdodDIgPz8gMCwgdGhpcy5waXhlbFJhdGlvKTtcbiAgICBkZWJ1Z0NvbnRleHQodGhpcy5jb250ZXh0KTtcbiAgfVxuICBkcmF3SW1hZ2UoY29udGV4dCwgZHggPSAwLCBkeSA9IDApIHtcbiAgICByZXR1cm4gY29udGV4dC5kcmF3SW1hZ2UodGhpcy5jb250ZXh0LmNhbnZhcywgZHgsIGR5KTtcbiAgfVxuICB0b0RhdGFVUkwodHlwZSkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQudG9EYXRhVVJMKHR5cGUpO1xuICB9XG4gIHJlc2l6ZSh3aWR0aDIsIGhlaWdodDIsIHBpeGVsUmF0aW8pIHtcbiAgICBpZiAoISh3aWR0aDIgPiAwICYmIGhlaWdodDIgPiAwKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGVsZW1lbnQyLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgIGVsZW1lbnQyLndpZHRoID0gTWF0aC5yb3VuZCh3aWR0aDIgKiBwaXhlbFJhdGlvKTtcbiAgICBlbGVtZW50Mi5oZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodDIgKiBwaXhlbFJhdGlvKTtcbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICBlbGVtZW50Mi5zdHlsZS53aWR0aCA9IHdpZHRoMiArIFwicHhcIjtcbiAgICBlbGVtZW50Mi5zdHlsZS5oZWlnaHQgPSBoZWlnaHQyICsgXCJweFwiO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDI7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQyO1xuICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgY2xlYXJDb250ZXh0KHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZSgpO1xuICAgIHRoaXMuZWxlbWVudC53aWR0aCA9IDA7XG4gICAgdGhpcy5lbGVtZW50LmhlaWdodCA9IDA7XG4gICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCAwLCAwKTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG4gIG9uRW5hYmxlZENoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHRoaXMuZW5hYmxlZCA/IFwiXCIgOiBcIm5vbmVcIjtcbiAgICB9XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB0YXJnZXQub25FbmFibGVkQ2hhbmdlKCkpXG5dLCBIZHBpQ2FudmFzLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9sYXllcnNNYW5hZ2VyLnRzXG52YXIgTGF5ZXJzTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzKSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcInNjZW5lXCIpO1xuICAgIHRoaXMubGF5ZXJzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLm5leHRMYXllcklkID0gMDtcbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllcnNNYXAuc2l6ZTtcbiAgfVxuICByZXNpemUod2lkdGgyLCBoZWlnaHQyLCBwaXhlbFJhdGlvKSB7XG4gICAgdGhpcy5jYW52YXMucmVzaXplKHdpZHRoMiwgaGVpZ2h0MiwgcGl4ZWxSYXRpbyk7XG4gICAgdGhpcy5sYXllcnNNYXAuZm9yRWFjaCgoeyBjYW52YXMgfSkgPT4gY2FudmFzLnJlc2l6ZSh3aWR0aDIsIGhlaWdodDIsIHBpeGVsUmF0aW8pKTtcbiAgfVxuICBhZGRMYXllcihvcHRzKSB7XG4gICAgY29uc3QgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIHBpeGVsUmF0aW8gfSA9IHRoaXMuY2FudmFzO1xuICAgIGNvbnN0IHsgbmFtZSB9ID0gb3B0cztcbiAgICBjb25zdCBjYW52YXMgPSBuZXcgSGRwaU9mZnNjcmVlbkNhbnZhcyh7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiwgcGl4ZWxSYXRpbyB9KTtcbiAgICB0aGlzLmxheWVyc01hcC5zZXQoY2FudmFzLCB7XG4gICAgICBpZDogdGhpcy5uZXh0TGF5ZXJJZCsrLFxuICAgICAgbmFtZSxcbiAgICAgIGNhbnZhc1xuICAgIH0pO1xuICAgIHRoaXMuZGVidWcoXCJTY2VuZS5hZGRMYXllcigpIC0gbGF5ZXJzXCIsIHRoaXMubGF5ZXJzTWFwKTtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG4gIHJlbW92ZUxheWVyKGNhbnZhcykge1xuICAgIGlmICh0aGlzLmxheWVyc01hcC5oYXMoY2FudmFzKSkge1xuICAgICAgdGhpcy5sYXllcnNNYXAuZGVsZXRlKGNhbnZhcyk7XG4gICAgICBjYW52YXMuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kZWJ1ZyhcIlNjZW5lLnJlbW92ZUxheWVyKCkgLSAgbGF5ZXJzXCIsIHRoaXMubGF5ZXJzTWFwKTtcbiAgICB9XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVyc01hcC52YWx1ZXMoKSkge1xuICAgICAgbGF5ZXIuY2FudmFzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5sYXllcnNNYXAuY2xlYXIoKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2NlbmVEZWJ1Zy50c1xuZnVuY3Rpb24gZm9ybWF0Qnl0ZXModmFsdWUpIHtcbiAgZm9yIChjb25zdCB1bml0IG9mIFtcIkJcIiwgXCJLQlwiLCBcIk1CXCIsIFwiR0JcIl0pIHtcbiAgICBpZiAodmFsdWUgPCAxNTM2KSB7XG4gICAgICByZXR1cm4gYCR7dmFsdWUudG9GaXhlZCgxKX0ke3VuaXR9YDtcbiAgICB9XG4gICAgdmFsdWUgLz0gMTAyNDtcbiAgfVxuICByZXR1cm4gYCR7dmFsdWUudG9GaXhlZCgxKX1UQn1gO1xufVxuZnVuY3Rpb24gbWVtb3J5VXNhZ2UoKSB7XG4gIGlmICghKFwibWVtb3J5XCIgaW4gcGVyZm9ybWFuY2UpKVxuICAgIHJldHVybjtcbiAgY29uc3QgeyB0b3RhbEpTSGVhcFNpemUsIHVzZWRKU0hlYXBTaXplLCBqc0hlYXBTaXplTGltaXQgfSA9IHBlcmZvcm1hbmNlLm1lbW9yeTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAoY29uc3QgYW1vdW50IG9mIFt1c2VkSlNIZWFwU2l6ZSwgdG90YWxKU0hlYXBTaXplLCBqc0hlYXBTaXplTGltaXRdKSB7XG4gICAgaWYgKHR5cGVvZiBhbW91bnQgIT09IFwibnVtYmVyXCIpXG4gICAgICBjb250aW51ZTtcbiAgICByZXN1bHQucHVzaChmb3JtYXRCeXRlcyhhbW91bnQpKTtcbiAgfVxuICByZXR1cm4gYEhlYXAgJHtyZXN1bHQuam9pbihcIiAvIFwiKX1gO1xufVxuZnVuY3Rpb24gZGVidWdTdGF0cyhsYXllcnNNYW5hZ2VyLCBkZWJ1Z1NwbGl0VGltZXMsIGN0eCwgcmVuZGVyQ3R4U3RhdHMsIGV4dHJhRGVidWdTdGF0cyA9IHt9LCBzZXJpZXNSZWN0ID0gQkJveC56ZXJvKSB7XG4gIGlmICghRGVidWcuY2hlY2soXCJzY2VuZTpzdGF0c1wiIC8qIFNDRU5FX1NUQVRTICovLCBcInNjZW5lOnN0YXRzOnZlcmJvc2VcIiAvKiBTQ0VORV9TVEFUU19WRVJCT1NFICovKSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHtcbiAgICBsYXllcnNSZW5kZXJlZCA9IDAsXG4gICAgbGF5ZXJzU2tpcHBlZCA9IDAsXG4gICAgbm9kZXNSZW5kZXJlZCA9IDAsXG4gICAgbm9kZXNTa2lwcGVkID0gMCxcbiAgICBvcHNQZXJmb3JtZWQgPSAwLFxuICAgIG9wc1NraXBwZWQgPSAwXG4gIH0gPSByZW5kZXJDdHhTdGF0cyA/PyB7fTtcbiAgY29uc3QgZW5kMiA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICBjb25zdCB7IHN0YXJ0OiBzdGFydDIsIC4uLmR1cmF0aW9ucyB9ID0gZGVidWdTcGxpdFRpbWVzO1xuICBjb25zdCBzcGxpdHMgPSBPYmplY3QuZW50cmllcyhkdXJhdGlvbnMpLm1hcCgoW24sIHRdKSA9PiB7XG4gICAgcmV0dXJuIHRpbWUobiwgdCk7XG4gIH0pLmZpbHRlcigodikgPT4gdiAhPSBudWxsKS5qb2luKFwiICsgXCIpO1xuICBjb25zdCBleHRyYXMgPSBPYmplY3QuZW50cmllcyhleHRyYURlYnVnU3RhdHMpLm1hcCgoW2ssIHZdKSA9PiBgJHtrfTogJHtKU09OLnN0cmluZ2lmeSh2KX1gKS5qb2luKFwiIDsgXCIpO1xuICBjb25zdCBkZXRhaWxlZFN0YXRzID0gRGVidWcuY2hlY2soXCJzY2VuZTpzdGF0czp2ZXJib3NlXCIgLyogU0NFTkVfU1RBVFNfVkVSQk9TRSAqLyk7XG4gIGNvbnN0IG1lbVVzYWdlID0gbWVtb3J5VXNhZ2UoKTtcbiAgY29uc3Qgc3RhdHMgPSBbXG4gICAgYCR7dGltZShcIlxcdTIzRjFcXHVGRTBGXCIsIHN0YXJ0MiwgZW5kMil9ICgke3NwbGl0c30pYCxcbiAgICBgJHtleHRyYXN9YCxcbiAgICBgTGF5ZXJzOiAke2RldGFpbGVkU3RhdHMgPyBwY3QobGF5ZXJzUmVuZGVyZWQsIGxheWVyc1NraXBwZWQpIDogbGF5ZXJzTWFuYWdlci5zaXplfWAsXG4gICAgZGV0YWlsZWRTdGF0cyA/IGBOb2RlczogJHtwY3Qobm9kZXNSZW5kZXJlZCwgbm9kZXNTa2lwcGVkKX1gIDogbnVsbCxcbiAgICBkZXRhaWxlZFN0YXRzID8gYE9wczogJHtwY3Qob3BzUGVyZm9ybWVkLCBvcHNTa2lwcGVkKX1gIDogbnVsbCxcbiAgICBkZXRhaWxlZFN0YXRzICYmIG1lbVVzYWdlID8gbWVtVXNhZ2UgOiBudWxsXG4gIF0uZmlsdGVyKGlzU3RyaW5nKTtcbiAgY29uc3QgbWVhc3VyZXIyID0gbmV3IFNpbXBsZVRleHRNZWFzdXJlcigodCkgPT4gY3R4Lm1lYXN1cmVUZXh0KHQpKTtcbiAgY29uc3Qgc3RhdHNTaXplID0gbmV3IE1hcChzdGF0cy5tYXAoKHQpID0+IFt0LCBtZWFzdXJlcjIubWVhc3VyZUxpbmVzKHQpXSkpO1xuICBjb25zdCB3aWR0aDIgPSBNYXRoLm1heCguLi5BcnJheS5mcm9tKHN0YXRzU2l6ZS52YWx1ZXMoKSwgKHMpID0+IHMud2lkdGgpKTtcbiAgY29uc3QgaGVpZ2h0MiA9IGFjY3VtdWxhdGUoc3RhdHNTaXplLnZhbHVlcygpLCAocykgPT4gcy5oZWlnaHQpO1xuICBjb25zdCB4ID0gMiArIHNlcmllc1JlY3QueDtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgY3R4LmZpbGxSZWN0KHgsIDAsIHdpZHRoMiwgaGVpZ2h0Mik7XG4gIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gIGxldCB5ID0gMDtcbiAgZm9yIChjb25zdCBbc3RhdCwgc2l6ZV0gb2Ygc3RhdHNTaXplLmVudHJpZXMoKSkge1xuICAgIHkgKz0gc2l6ZS5oZWlnaHQ7XG4gICAgY3R4LmZpbGxUZXh0KHN0YXQsIHgsIHkpO1xuICB9XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBwcmVwYXJlU2NlbmVOb2RlSGlnaGxpZ2h0KGN0eCkge1xuICBjb25zdCBjb25maWcgPSB0b0FycmF5KGdldFdpbmRvdyhcImFnQ2hhcnRzU2NlbmVEZWJ1Z1wiKSk7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgY29uZmlnKSB7XG4gICAgaWYgKG5hbWUgPT09IFwibGF5b3V0XCIpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFwic2VyaWVzUm9vdFwiLCBcImxlZ2VuZFwiLCBcInJvb3RcIiwgLy4qQXhpcy1cXGQrLWF4aXMuKi8pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgICB9XG4gIH1cbiAgY3R4LmRlYnVnTm9kZVNlYXJjaCA9IHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRlYnVnU2NlbmVOb2RlSGlnaGxpZ2h0KGN0eCwgZGVidWdOb2Rlcykge1xuICBjdHguc2F2ZSgpO1xuICBmb3IgKGNvbnN0IFtuYW1lLCBub2RlXSBvZiBPYmplY3QuZW50cmllcyhkZWJ1Z05vZGVzKSkge1xuICAgIGNvbnN0IGJib3ggPSBUcmFuc2Zvcm1hYmxlLnRvQ2FudmFzKG5vZGUpO1xuICAgIGlmICghYmJveCkge1xuICAgICAgbG9nZ2VyX2V4cG9ydHMubG9nKGBTY2VuZS5yZW5kZXIoKSAtIG5vIGJib3ggZm9yIGRlYnVnZ2VkIG5vZGUgWyR7bmFtZX1dLmApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuODtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJlZFwiO1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIGN0eC5zdHJva2VSZWN0KGJib3gueCwgYmJveC55LCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IFwicmVkXCI7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgIGN0eC5mb250ID0gXCIxNnB4IHNhbnMtc2VyaWZcIjtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcbiAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gICAgY3R4LnN0cm9rZVRleHQobmFtZSwgYmJveC54LCBiYm94LnksIGJib3gud2lkdGgpO1xuICAgIGN0eC5maWxsVGV4dChuYW1lLCBiYm94LngsIGJib3gueSwgYmJveC53aWR0aCk7XG4gIH1cbiAgY3R4LnJlc3RvcmUoKTtcbn1cbnZhciBza2lwcGVkUHJvcGVydGllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG52YXIgYWxsb3dlZFByb3BlcnRpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiZ3JhZGllbnRcIixcbiAgLy8gJ19kYXR1bScsXG4gIFwiekluZGV4XCIsXG4gIFwiY2xpcFJlY3RcIixcbiAgXCJjYWNoZWRCQm94XCIsXG4gIFwiY2hpbGROb2RlQ291bnRzXCIsXG4gIFwicGF0aFwiLFxuICBcIl9fekluZGV4XCIsXG4gIFwibmFtZVwiLFxuICBcIl9fc2NhbGluZ0NlbnRlclhcIixcbiAgXCJfX3NjYWxpbmdDZW50ZXJZXCIsXG4gIFwiX19yb3RhdGlvbkNlbnRlclhcIixcbiAgXCJfX3JvdGF0aW9uQ2VudGVyWVwiLFxuICBcIl9wcmV2aW91c0RhdHVtXCIsXG4gIFwiX19maWxsXCIsXG4gIFwiX19saW5lRGFzaFwiLFxuICBcImJvcmRlclBhdGhcIixcbiAgXCJib3JkZXJDbGlwUGF0aFwiLFxuICBcIl9jbGlwUGF0aFwiXG5dKTtcbmZ1bmN0aW9uIG5vZGVQcm9wcyhub2RlKSB7XG4gIGNvbnN0IHsgLi4uYWxsUHJvcHMgfSA9IG5vZGU7XG4gIGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3Qua2V5cyhhbGxQcm9wcykpIHtcbiAgICBpZiAoYWxsb3dlZFByb3BlcnRpZXMuaGFzKHByb3ApKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKHR5cGVvZiBhbGxQcm9wc1twcm9wXSA9PT0gXCJudW1iZXJcIilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICh0eXBlb2YgYWxsUHJvcHNbcHJvcF0gPT09IFwic3RyaW5nXCIpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAodHlwZW9mIGFsbFByb3BzW3Byb3BdID09PSBcImJvb2xlYW5cIilcbiAgICAgIGNvbnRpbnVlO1xuICAgIHNraXBwZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICBkZWxldGUgYWxsUHJvcHNbcHJvcF07XG4gIH1cbiAgcmV0dXJuIGFsbFByb3BzO1xufVxuZnVuY3Rpb24gYnVpbGRUcmVlKG5vZGUsIG1vZGUpIHtcbiAgaWYgKCFEZWJ1Zy5jaGVjayh0cnVlLCBcInNjZW5lXCIgLyogU0NFTkUgKi8pKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGxldCBvcmRlciA9IDA7XG4gIHJldHVybiB7XG4gICAgbm9kZTogbW9kZSA9PT0gXCJqc29uXCIgPyBub2RlUHJvcHMobm9kZSkgOiBub2RlLFxuICAgIG5hbWU6IG5vZGUubmFtZSA/PyBub2RlLmlkLFxuICAgIGRpcnR5OiBub2RlLmRpcnR5LFxuICAgIC4uLkFycmF5LmZyb20obm9kZS5jaGlsZHJlbigpLCAoYykgPT4gYnVpbGRUcmVlKGMsIG1vZGUpKS5yZWR1Y2UoXG4gICAgICAocmVzdWx0LCBjaGlsZFRyZWUpID0+IHtcbiAgICAgICAgbGV0IHsgbmFtZTogdHJlZU5vZGVOYW1lIH0gPSBjaGlsZFRyZWU7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBub2RlOiB7IHZpc2libGUsIG9wYWNpdHksIHpJbmRleCwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblksIHJvdGF0aW9uLCBzY2FsaW5nWCwgc2NhbGluZ1kgfSxcbiAgICAgICAgICBub2RlOiBjaGlsZE5vZGVcbiAgICAgICAgfSA9IGNoaWxkVHJlZTtcbiAgICAgICAgaWYgKCF2aXNpYmxlIHx8IG9wYWNpdHkgPD0gMCkge1xuICAgICAgICAgIHRyZWVOb2RlTmFtZSA9IGAoJHt0cmVlTm9kZU5hbWV9KWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEdyb3VwLmlzKGNoaWxkTm9kZSkgJiYgY2hpbGROb2RlLnJlbmRlclRvT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgICAgICAgdHJlZU5vZGVOYW1lID0gYCoke3RyZWVOb2RlTmFtZX0qYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB6SW5kZXhTdHJpbmcgPSBBcnJheS5pc0FycmF5KHpJbmRleCkgPyBgKCR7ekluZGV4LmpvaW4oXCIsIFwiKX0pYCA6IHpJbmRleDtcbiAgICAgICAgY29uc3Qga2V5ID0gW1xuICAgICAgICAgIGAkeyhvcmRlcisrKS50b1N0cmluZygpLnBhZFN0YXJ0KDMsIFwiMFwiKX18YCxcbiAgICAgICAgICBgJHt0cmVlTm9kZU5hbWUgPz8gXCI8dW5rbm93bj5cIn1gLFxuICAgICAgICAgIGB6OiAke3pJbmRleFN0cmluZ31gLFxuICAgICAgICAgIHRyYW5zbGF0aW9uWCAmJiBgeDogJHt0cmFuc2xhdGlvblh9YCxcbiAgICAgICAgICB0cmFuc2xhdGlvblkgJiYgYHk6ICR7dHJhbnNsYXRpb25ZfWAsXG4gICAgICAgICAgcm90YXRpb24gJiYgYHI6ICR7cm90YXRpb259YCxcbiAgICAgICAgICBzY2FsaW5nWCAhPSBudWxsICYmIHNjYWxpbmdYICE9PSAxICYmIGBzeDogJHtzY2FsaW5nWH1gLFxuICAgICAgICAgIHNjYWxpbmdZICE9IG51bGwgJiYgc2NhbGluZ1kgIT09IDEgJiYgYHN5OiAke3NjYWxpbmdZfWBcbiAgICAgICAgXS5maWx0ZXIoKHYpID0+ICEhdikuam9pbihcIiBcIik7XG4gICAgICAgIGxldCBzZWxlY3RlZEtleSA9IGtleTtcbiAgICAgICAgbGV0IGluZGV4ID0gMTtcbiAgICAgICAgd2hpbGUgKHJlc3VsdFtzZWxlY3RlZEtleV0gIT0gbnVsbCAmJiBpbmRleCA8IDEwMCkge1xuICAgICAgICAgIHNlbGVjdGVkS2V5ID0gYCR7a2V5fSAoJHtpbmRleCsrfSlgO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtzZWxlY3RlZEtleV0gPSBjaGlsZFRyZWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAge31cbiAgICApXG4gIH07XG59XG5mdW5jdGlvbiBidWlsZERpcnR5VHJlZShub2RlKSB7XG4gIGlmICghbm9kZS5kaXJ0eSkge1xuICAgIHJldHVybiB7IGRpcnR5VHJlZToge30sIHBhdGhzOiBbXSB9O1xuICB9XG4gIGNvbnN0IGNoaWxkcmVuRGlydHlUcmVlID0gQXJyYXkuZnJvbShub2RlLmNoaWxkcmVuKCksIChjKSA9PiBidWlsZERpcnR5VHJlZShjKSkuZmlsdGVyKChjKSA9PiBjLnBhdGhzLmxlbmd0aCA+IDApO1xuICBjb25zdCBuYW1lID0gR3JvdXAuaXMobm9kZSkgPyBub2RlLm5hbWUgPz8gbm9kZS5pZCA6IG5vZGUuaWQ7XG4gIGNvbnN0IHBhdGhzID0gY2hpbGRyZW5EaXJ0eVRyZWUubGVuZ3RoID8gY2hpbGRyZW5EaXJ0eVRyZWUuZmxhdE1hcCgoYykgPT4gYy5wYXRocykubWFwKChwKSA9PiBgJHtuYW1lfS4ke3B9YCkgOiBbbmFtZV07XG4gIHJldHVybiB7XG4gICAgZGlydHlUcmVlOiB7XG4gICAgICBuYW1lLFxuICAgICAgbm9kZSxcbiAgICAgIGRpcnR5OiBub2RlLmRpcnR5LFxuICAgICAgLi4uY2hpbGRyZW5EaXJ0eVRyZWUubWFwKChjKSA9PiBjLmRpcnR5VHJlZSkuZmlsdGVyKCh0KSA9PiB0LmRpcnR5ICE9IG51bGwpLnJlZHVjZSgocmVzdWx0LCBjaGlsZFRyZWUpID0+IHtcbiAgICAgICAgcmVzdWx0W2NoaWxkVHJlZS5uYW1lID8/IFwiPHVua25vd24+XCJdID0gY2hpbGRUcmVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwge30pXG4gICAgfSxcbiAgICBwYXRoc1xuICB9O1xufVxuZnVuY3Rpb24gcGN0KHJlbmRlcmVkLCBza2lwcGVkKSB7XG4gIGNvbnN0IHRvdGFsID0gcmVuZGVyZWQgKyBza2lwcGVkO1xuICByZXR1cm4gYCR7cmVuZGVyZWR9IC8gJHt0b3RhbH0gKCR7TWF0aC5yb3VuZCgxMDAgKiByZW5kZXJlZCAvIHRvdGFsKX0lKWA7XG59XG5mdW5jdGlvbiB0aW1lKG5hbWUsIHN0YXJ0MiwgZW5kMikge1xuICBjb25zdCBkdXJhdGlvbiA9IGVuZDIgIT0gbnVsbCA/IGVuZDIgLSBzdGFydDIgOiBzdGFydDI7XG4gIHJldHVybiBgJHtuYW1lfTogJHtNYXRoLnJvdW5kKGR1cmF0aW9uICogMTAwKSAvIDEwMH1tc2A7XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRlKGl0ZXJhdG9yLCBtYXBwZXIpIHtcbiAgbGV0IHN1bTIgPSAwO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlcmF0b3IpIHtcbiAgICBzdW0yICs9IG1hcHBlcihpdGVtKTtcbiAgfVxuICByZXR1cm4gc3VtMjtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2NlbmUudHNcbnZhciBTY2VuZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzT3B0aW9ucykge1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJzY2VuZVwiIC8qIFNDRU5FICovKTtcbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdTaXplID0gbnVsbDtcbiAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICB0aGlzLmNhbnZhcyA9IG5ldyBIZHBpQ2FudmFzKGNhbnZhc09wdGlvbnMpO1xuICAgIHRoaXMubGF5ZXJzTWFuYWdlciA9IG5ldyBMYXllcnNNYW5hZ2VyKHRoaXMuY2FudmFzKTtcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ1NpemU/LlswXSA/PyB0aGlzLmNhbnZhcy53aWR0aDtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmdTaXplPy5bMV0gPz8gdGhpcy5jYW52YXMuaGVpZ2h0O1xuICB9XG4gIGdldCBwaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmdTaXplPy5bMl0gPz8gdGhpcy5jYW52YXMucGl4ZWxSYXRpbztcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgdjEwLjIuMCBPbmx5IHVzZWQgYnkgQUcgR3JpZCBTcGFya2xpbmVzICovXG4gIHNldENvbnRhaW5lcih2YWx1ZSkge1xuICAgIGNvbnN0IHsgZWxlbWVudDogZWxlbWVudDIgfSA9IHRoaXMuY2FudmFzO1xuICAgIGVsZW1lbnQyLnBhcmVudEVsZW1lbnQ/LnJlbW92ZUNoaWxkKGVsZW1lbnQyKTtcbiAgICB2YWx1ZS5hcHBlbmRDaGlsZChlbGVtZW50Mik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0Um9vdChub2RlKSB7XG4gICAgaWYgKHRoaXMucm9vdCA9PT0gbm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5yb290Py5fc2V0TGF5ZXJNYW5hZ2VyKCk7XG4gICAgdGhpcy5yb290ID0gbm9kZTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIG5vZGUuX3NldExheWVyTWFuYWdlcih0aGlzLmxheWVyc01hbmFnZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLmNhbnZhcy5jbGVhcigpO1xuICB9XG4gIGF0dGFjaE5vZGUobm9kZSkge1xuICAgIHRoaXMuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgcmV0dXJuICgpID0+IHRoaXMucmVtb3ZlQ2hpbGQobm9kZSk7XG4gIH1cbiAgYXBwZW5kQ2hpbGQobm9kZSkge1xuICAgIHRoaXMucm9vdD8uYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVtb3ZlQ2hpbGQobm9kZSkge1xuICAgIHRoaXMucm9vdD8ucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZG93bmxvYWQoZmlsZU5hbWUsIGZpbGVGb3JtYXQpIHtcbiAgICBkb3dubG9hZFVybCh0aGlzLmNhbnZhcy50b0RhdGFVUkwoZmlsZUZvcm1hdCksIGZpbGVOYW1lPy50cmltKCkgPz8gXCJpbWFnZVwiKTtcbiAgfVxuICAvKiogTk9URTogSW50ZWdyYXRlZCBDaGFydHMgdW5kb2N1bWVudGVkIGltYWdlIGRvd25sb2FkIG1ldGhvZC4gKi9cbiAgZ2V0RGF0YVVSTChmaWxlRm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTChmaWxlRm9ybWF0KTtcbiAgfVxuICByZXNpemUod2lkdGgyLCBoZWlnaHQyLCBwaXhlbFJhdGlvKSB7XG4gICAgd2lkdGgyID0gTWF0aC5yb3VuZCh3aWR0aDIpO1xuICAgIGhlaWdodDIgPSBNYXRoLnJvdW5kKGhlaWdodDIpO1xuICAgIHBpeGVsUmF0aW8gPz8gKHBpeGVsUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW8pO1xuICAgIGlmICh3aWR0aDIgPiAwICYmIGhlaWdodDIgPiAwICYmICh3aWR0aDIgIT09IHRoaXMud2lkdGggfHwgaGVpZ2h0MiAhPT0gdGhpcy5oZWlnaHQgfHwgcGl4ZWxSYXRpbyAhPT0gdGhpcy5waXhlbFJhdGlvKSkge1xuICAgICAgdGhpcy5wZW5kaW5nU2l6ZSA9IFt3aWR0aDIsIGhlaWdodDIsIHBpeGVsUmF0aW9dO1xuICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVuZGVyKG9wdHMpIHtcbiAgICBjb25zdCB7IGRlYnVnU3BsaXRUaW1lcyA9IHsgc3RhcnQ6IHBlcmZvcm1hbmNlLm5vdygpIH0sIGV4dHJhRGVidWdTdGF0cywgc2VyaWVzUmVjdCB9ID0gb3B0cyA/PyB7fTtcbiAgICBjb25zdCB7XG4gICAgICBjYW52YXMsXG4gICAgICBjYW52YXM6IHsgY29udGV4dDogY3R4IH0gPSB7fSxcbiAgICAgIHJvb3QsXG4gICAgICBwZW5kaW5nU2l6ZSxcbiAgICAgIHdpZHRoOiB3aWR0aDIsXG4gICAgICBoZWlnaHQ6IGhlaWdodDIsXG4gICAgICBwaXhlbFJhdGlvOiBkZXZpY2VQaXhlbFJhdGlvXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVuZGVyU3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKHBlbmRpbmdTaXplKSB7XG4gICAgICB0aGlzLmxheWVyc01hbmFnZXIucmVzaXplKC4uLnBlbmRpbmdTaXplKTtcbiAgICAgIHRoaXMucGVuZGluZ1NpemUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAocm9vdCAmJiAhcm9vdC52aXNpYmxlKSB7XG4gICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJvb3Q/LmRpcnR5ID09PSBmYWxzZSAmJiAhdGhpcy5pc0RpcnR5KSB7XG4gICAgICBpZiAodGhpcy5kZWJ1Zy5jaGVjaygpKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJTY2VuZS5yZW5kZXIoKSAtIG5vLW9wXCIsIHtcbiAgICAgICAgICB0cmVlOiBidWlsZFRyZWUocm9vdCwgXCJjb25zb2xlXCIpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGVidWdTdGF0cyh0aGlzLmxheWVyc01hbmFnZXIsIGRlYnVnU3BsaXRUaW1lcywgY3R4LCB2b2lkIDAsIGV4dHJhRGVidWdTdGF0cywgc2VyaWVzUmVjdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlckN0eCA9IHtcbiAgICAgIGN0eCxcbiAgICAgIHdpZHRoOiB3aWR0aDIsXG4gICAgICBoZWlnaHQ6IGhlaWdodDIsXG4gICAgICBkZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgZGVidWdOb2Rlczoge31cbiAgICB9O1xuICAgIGlmIChEZWJ1Zy5jaGVjayhcInNjZW5lOnN0YXRzOnZlcmJvc2VcIiAvKiBTQ0VORV9TVEFUU19WRVJCT1NFICovKSkge1xuICAgICAgcmVuZGVyQ3R4LnN0YXRzID0ge1xuICAgICAgICBsYXllcnNSZW5kZXJlZDogMCxcbiAgICAgICAgbGF5ZXJzU2tpcHBlZDogMCxcbiAgICAgICAgbm9kZXNSZW5kZXJlZDogMCxcbiAgICAgICAgbm9kZXNTa2lwcGVkOiAwLFxuICAgICAgICBvcHNQZXJmb3JtZWQ6IDAsXG4gICAgICAgIG9wc1NraXBwZWQ6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIHByZXBhcmVTY2VuZU5vZGVIaWdobGlnaHQocmVuZGVyQ3R4KTtcbiAgICBsZXQgY2FudmFzQ2xlYXJlZCA9IGZhbHNlO1xuICAgIGlmIChyb290Py5kaXJ0eSAhPT0gZmFsc2UpIHtcbiAgICAgIGNhbnZhc0NsZWFyZWQgPSB0cnVlO1xuICAgICAgY2FudmFzLmNsZWFyKCk7XG4gICAgfVxuICAgIGlmIChyb290ICYmIERlYnVnLmNoZWNrKFwic2NlbmU6ZGlydHlUcmVlXCIgLyogU0NFTkVfRElSVFlfVFJFRSAqLykpIHtcbiAgICAgIGNvbnN0IHsgZGlydHlUcmVlLCBwYXRocyB9ID0gYnVpbGREaXJ0eVRyZWUocm9vdCk7XG4gICAgICBEZWJ1Zy5jcmVhdGUoXCJzY2VuZTpkaXJ0eVRyZWVcIiAvKiBTQ0VORV9ESVJUWV9UUkVFICovKShcIlNjZW5lLnJlbmRlcigpIC0gZGlydHlUcmVlXCIsIHsgZGlydHlUcmVlLCBwYXRocyB9KTtcbiAgICB9XG4gICAgaWYgKHJvb3QgJiYgY2FudmFzQ2xlYXJlZCkge1xuICAgICAgaWYgKHJvb3QudmlzaWJsZSkge1xuICAgICAgICByb290LnByZVJlbmRlcihyZW5kZXJDdHgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGVidWcuY2hlY2soKSkge1xuICAgICAgICBjb25zdCB0cmVlID0gYnVpbGRUcmVlKHJvb3QsIFwiY29uc29sZVwiKTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIlNjZW5lLnJlbmRlcigpIC0gYmVmb3JlXCIsIHtcbiAgICAgICAgICBjYW52YXNDbGVhcmVkLFxuICAgICAgICAgIHRyZWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocm9vdC52aXNpYmxlKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHJvb3QucmVuZGVyKHJlbmRlckN0eCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGRlYnVnU3BsaXRUaW1lc1tcIlxcdTI3MERcXHVGRTBGXCJdID0gcGVyZm9ybWFuY2Uubm93KCkgLSByZW5kZXJTdGFydFRpbWU7XG4gICAgY3R4LnZlcmlmeURlcHRoWmVybz8uKCk7XG4gICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgZGVidWdTdGF0cyh0aGlzLmxheWVyc01hbmFnZXIsIGRlYnVnU3BsaXRUaW1lcywgY3R4LCByZW5kZXJDdHguc3RhdHMsIGV4dHJhRGVidWdTdGF0cywgc2VyaWVzUmVjdCk7XG4gICAgZGVidWdTY2VuZU5vZGVIaWdobGlnaHQoY3R4LCByZW5kZXJDdHguZGVidWdOb2Rlcyk7XG4gICAgaWYgKHJvb3QgJiYgdGhpcy5kZWJ1Zy5jaGVjaygpKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiU2NlbmUucmVuZGVyKCkgLSBhZnRlclwiLCB7XG4gICAgICAgIHRyZWU6IGJ1aWxkVHJlZShyb290LCBcImNvbnNvbGVcIiksXG4gICAgICAgIGNhbnZhc0NsZWFyZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB0b1NWRygpIHtcbiAgICBjb25zdCB7IHJvb3QsIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gdGhpcztcbiAgICBpZiAocm9vdCA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIHJldHVybiBOb2RlLnRvU1ZHKHJvb3QsIHdpZHRoMiwgaGVpZ2h0Mik7XG4gIH1cbiAgLyoqIEFsdGVybmF0aXZlIHRvIGRlc3Ryb3koKSB0aGF0IHByZXNlcnZlcyByZS11c2FibGUgcmVzb3VyY2VzLiAqL1xuICBzdHJpcCgpIHtcbiAgICBjb25zdCB7IGNvbnRleHQsIHBpeGVsUmF0aW8gfSA9IHRoaXMuY2FudmFzO1xuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgIHRoaXMubGF5ZXJzTWFuYWdlci5jbGVhcigpO1xuICAgIHRoaXMuc2V0Um9vdChudWxsKTtcbiAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc3RyaXAoKTtcbiAgICB0aGlzLmNhbnZhcy5kZXN0cm95KCk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IGNhbnZhczogdm9pZCAwIH0pO1xuICB9XG59O1xuU2NlbmUuY2xhc3NOYW1lID0gXCJTY2VuZVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2NhbGxiYWNrQ2FjaGUudHNcbnZhciBDYWxsYmFja0NhY2hlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIH1cbiAgY2FsbChmbiwgLi4ucGFyYW1zKSB7XG4gICAgbGV0IHNlcmlhbGlzZWRQYXJhbXM7XG4gICAgbGV0IHBhcmFtQ2FjaGUgPSB0aGlzLmNhY2hlLmdldChmbik7XG4gICAgdHJ5IHtcbiAgICAgIHNlcmlhbGlzZWRQYXJhbXMgPSBKU09OLnN0cmluZ2lmeShwYXJhbXMpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHRoaXMuaW52b2tlKGZuLCBwYXJhbXMsIHBhcmFtQ2FjaGUpO1xuICAgIH1cbiAgICBpZiAocGFyYW1DYWNoZSA9PSBudWxsKSB7XG4gICAgICBwYXJhbUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuY2FjaGUuc2V0KGZuLCBwYXJhbUNhY2hlKTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbUNhY2hlLmhhcyhzZXJpYWxpc2VkUGFyYW1zKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW52b2tlKGZuLCBwYXJhbXMsIHBhcmFtQ2FjaGUsIHNlcmlhbGlzZWRQYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1DYWNoZS5nZXQoc2VyaWFsaXNlZFBhcmFtcyk7XG4gIH1cbiAgaW52b2tlKGZuLCBwYXJhbXMsIHBhcmFtQ2FjaGUsIHNlcmlhbGlzZWRQYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZm4oLi4ucGFyYW1zKTtcbiAgICAgIGlmIChwYXJhbUNhY2hlICYmIHNlcmlhbGlzZWRQYXJhbXMgIT0gbnVsbCkge1xuICAgICAgICBwYXJhbUNhY2hlLnNldChzZXJpYWxpc2VkUGFyYW1zLCByZXN1bHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXJfZXhwb3J0cy53YXJuT25jZShgVXNlciBjYWxsYmFjayBlcnJvcmVkLCBpZ25vcmluZ2AsIGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpbnZhbGlkYXRlQ2FjaGUoKSB7XG4gICAgdGhpcy5jYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9hbm5vdGF0aW9uL2Fubm90YXRpb25NYW5hZ2VyLnRzXG52YXIgQW5ub3RhdGlvbk1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoYW5ub3RhdGlvblJvb3QpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYW5ub3RhdGlvblJvb3QgPSBhbm5vdGF0aW9uUm9vdDtcbiAgICB0aGlzLm1lbWVudG9PcmlnaW5hdG9yS2V5ID0gXCJhbm5vdGF0aW9uc1wiO1xuICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBbXTtcbiAgfVxuICBjcmVhdGVNZW1lbnRvKCkge1xuICAgIHJldHVybiB0aGlzLmFubm90YXRpb25zO1xuICB9XG4gIGd1YXJkTWVtZW50byhibG9iKSB7XG4gICAgcmV0dXJuIGJsb2IgPT0gbnVsbCB8fCBpc0FycmF5KGJsb2IpO1xuICB9XG4gIHJlc3RvcmVNZW1lbnRvKF92ZXJzaW9uLCBfbWVtZW50b1ZlcnNpb24sIG1lbWVudG8pIHtcbiAgICB0aGlzLmFubm90YXRpb25zID0gdGhpcy5jbGVhbkRhdGEobWVtZW50byA/PyBbXSkubWFwKChhbm5vdGF0aW9uKSA9PiB7XG4gICAgICBjb25zdCBhbm5vdGF0aW9uVGhlbWUgPSB0aGlzLmdldEFubm90YXRpb25UeXBlU3R5bGVzKGFubm90YXRpb24udHlwZSk7XG4gICAgICByZXR1cm4gbWVyZ2VEZWZhdWx0cyhhbm5vdGF0aW9uLCBhbm5vdGF0aW9uVGhlbWUpO1xuICAgIH0pO1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwicmVzdG9yZS1hbm5vdGF0aW9uc1wiLCB7XG4gICAgICB0eXBlOiBcInJlc3RvcmUtYW5ub3RhdGlvbnNcIixcbiAgICAgIGFubm90YXRpb25zOiB0aGlzLmFubm90YXRpb25zXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlRGF0YShhbm5vdGF0aW9ucykge1xuICAgIHRoaXMuYW5ub3RhdGlvbnMgPSB0aGlzLmNsZWFuRGF0YShhbm5vdGF0aW9ucyA/PyBbXSk7XG4gIH1cbiAgYXR0YWNoTm9kZShub2RlKSB7XG4gICAgdGhpcy5hbm5vdGF0aW9uUm9vdC5hcHBlbmQobm9kZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblJvb3Q/LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfVxuICBzZXRBbm5vdGF0aW9uU3R5bGVzKHN0eWxlcykge1xuICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICB9XG4gIGdldEFubm90YXRpb25UeXBlU3R5bGVzKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZXM/Llt0eXBlXTtcbiAgfVxuICBjbGVhbkRhdGEoYW5ub3RhdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGFubm90YXRpb24gb2YgYW5ub3RhdGlvbnMpIHtcbiAgICAgIGlmIChcInRleHRBbGlnblwiIGluIGFubm90YXRpb24pXG4gICAgICAgIGRlbGV0ZSBhbm5vdGF0aW9uLnRleHRBbGlnbjtcbiAgICB9XG4gICAgcmV0dXJuIGFubm90YXRpb25zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNNYW5hZ2VyLnRzXG52YXIgQXhpc01hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNjZW5lUm9vdCkge1xuICAgIHRoaXMuc2NlbmVSb290ID0gc2NlbmVSb290O1xuICAgIHRoaXMuYXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5heGlzR3JpZEdyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogXCJBeGVzLUdyaWRzXCIsIHpJbmRleDogMSAvKiBBWElTX0dSSUQgKi8gfSk7XG4gICAgdGhpcy5heGlzR3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBcIkF4ZXNcIiwgekluZGV4OiAyIC8qIEFYSVMgKi8gfSk7XG4gICAgdGhpcy5heGlzTGFiZWxHcm91cCA9IG5ldyBHcm91cCh7IG5hbWU6IFwiQXhlcy1MYWJlbHNcIiwgekluZGV4OiAxMyAvKiBTRVJJRVNfTEFCRUwgKi8gfSk7XG4gICAgdGhpcy5heGlzQ3Jvc3NsaW5lUmFuZ2VHcm91cCA9IG5ldyBHcm91cCh7XG4gICAgICBuYW1lOiBcIkF4ZXMtQ3Jvc3NsaW5lcy1SYW5nZVwiLFxuICAgICAgekluZGV4OiA0IC8qIFNFUklFU19DUk9TU0xJTkVfUkFOR0UgKi9cbiAgICB9KTtcbiAgICB0aGlzLmF4aXNDcm9zc2xpbmVMaW5lR3JvdXAgPSBuZXcgR3JvdXAoe1xuICAgICAgbmFtZTogXCJBeGVzLUNyb3NzbGluZXMtTGluZVwiLFxuICAgICAgekluZGV4OiA4IC8qIFNFUklFU19DUk9TU0xJTkVfTElORSAqL1xuICAgIH0pO1xuICAgIHRoaXMuYXhpc0Nyb3NzbGluZUxhYmVsR3JvdXAgPSBuZXcgR3JvdXAoe1xuICAgICAgbmFtZTogXCJBeGVzLUNyb3NzbGluZXMtTGFiZWxcIixcbiAgICAgIHpJbmRleDogMTMgLyogU0VSSUVTX0xBQkVMICovXG4gICAgfSk7XG4gICAgdGhpcy5zY2VuZVJvb3QuYXBwZW5kQ2hpbGQodGhpcy5heGlzR3JvdXApO1xuICAgIHRoaXMuc2NlbmVSb290LmFwcGVuZENoaWxkKHRoaXMuYXhpc0dyaWRHcm91cCk7XG4gICAgdGhpcy5zY2VuZVJvb3QuYXBwZW5kQ2hpbGQodGhpcy5heGlzTGFiZWxHcm91cCk7XG4gICAgdGhpcy5zY2VuZVJvb3QuYXBwZW5kQ2hpbGQodGhpcy5heGlzQ3Jvc3NsaW5lUmFuZ2VHcm91cCk7XG4gICAgdGhpcy5zY2VuZVJvb3QuYXBwZW5kQ2hpbGQodGhpcy5heGlzQ3Jvc3NsaW5lTGluZUdyb3VwKTtcbiAgICB0aGlzLnNjZW5lUm9vdC5hcHBlbmRDaGlsZCh0aGlzLmF4aXNDcm9zc2xpbmVMYWJlbEdyb3VwKTtcbiAgfVxuICB1cGRhdGVBeGVzKG9sZEF4ZXMsIG5ld0F4ZXMpIHtcbiAgICBjb25zdCBheGlzTm9kZXMgPSB7XG4gICAgICBheGlzTm9kZTogdGhpcy5heGlzR3JvdXAsXG4gICAgICBncmlkTm9kZTogdGhpcy5heGlzR3JpZEdyb3VwLFxuICAgICAgbGFiZWxOb2RlOiB0aGlzLmF4aXNMYWJlbEdyb3VwLFxuICAgICAgY3Jvc3NMaW5lUmFuZ2VOb2RlOiB0aGlzLmF4aXNDcm9zc2xpbmVSYW5nZUdyb3VwLFxuICAgICAgY3Jvc3NMaW5lTGluZU5vZGU6IHRoaXMuYXhpc0Nyb3NzbGluZUxpbmVHcm91cCxcbiAgICAgIGNyb3NzTGluZUxhYmVsTm9kZTogdGhpcy5heGlzQ3Jvc3NsaW5lTGFiZWxHcm91cFxuICAgIH07XG4gICAgZm9yIChjb25zdCBheGlzIG9mIG9sZEF4ZXMpIHtcbiAgICAgIGlmIChuZXdBeGVzLmluY2x1ZGVzKGF4aXMpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGF4aXMuZGV0YWNoQXhpcyhheGlzTm9kZXMpO1xuICAgICAgYXhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXhpcyBvZiBuZXdBeGVzKSB7XG4gICAgICBpZiAob2xkQXhlcz8uaW5jbHVkZXMoYXhpcykpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgYXhpcy5hdHRhY2hBeGlzKGF4aXNOb2Rlcyk7XG4gICAgfVxuICAgIHRoaXMuYXhlcy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgYXhpcyBvZiBuZXdBeGVzKSB7XG4gICAgICBjb25zdCBjdHggPSBheGlzLmNyZWF0ZUF4aXNDb250ZXh0KCk7XG4gICAgICBpZiAodGhpcy5heGVzLmhhcyhjdHguZGlyZWN0aW9uKSkge1xuICAgICAgICB0aGlzLmF4ZXMuZ2V0KGN0eC5kaXJlY3Rpb24pPy5wdXNoKGN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF4ZXMuc2V0KGN0eC5kaXJlY3Rpb24sIFtjdHhdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0QXhpc0NvbnRleHQoZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhlcy5nZXQoZGlyZWN0aW9uKSA/PyBbXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYXhlcy5jbGVhcigpO1xuICAgIHRoaXMuc2NlbmVSb290LnJlbW92ZUNoaWxkKHRoaXMuYXhpc0dyb3VwKTtcbiAgICB0aGlzLnNjZW5lUm9vdC5yZW1vdmVDaGlsZCh0aGlzLmF4aXNHcmlkR3JvdXApO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL2RhdGFTZXJ2aWNlLnRzXG52YXIgRGF0YVNlcnZpY2UgPSBjbGFzcyBleHRlbmRzIExpc3RlbmVycyB7XG4gIGNvbnN0cnVjdG9yKGFuaW1hdGlvbk1hbmFnZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlciA9IGFuaW1hdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5kaXNwYXRjaE9ubHlMYXRlc3QgPSB0cnVlO1xuICAgIHRoaXMuZGlzcGF0Y2hUaHJvdHRsZSA9IDA7XG4gICAgdGhpcy5yZXF1ZXN0VGhyb3R0bGUgPSAzMDA7XG4gICAgdGhpcy5pc0xvYWRpbmdJbml0aWFsRGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuaXNMb2FkaW5nRGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuZnJlc2hSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMucmVxdWVzdENvdW50ZXIgPSAwO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJkYXRhLW1vZGVsXCIsIFwiZGF0YS1zb3VyY2VcIik7XG4gICAgdGhpcy50aHJvdHRsZWRGZXRjaCA9IHRoaXMuY3JlYXRlVGhyb3R0bGVkRmV0Y2godGhpcy5yZXF1ZXN0VGhyb3R0bGUpO1xuICAgIHRoaXMudGhyb3R0bGVkRGlzcGF0Y2ggPSB0aGlzLmNyZWF0ZVRocm90dGxlZERpc3BhdGNoKHRoaXMuZGlzcGF0Y2hUaHJvdHRsZSk7XG4gIH1cbiAgdXBkYXRlQ2FsbGJhY2soZGF0YVNvdXJjZUNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhU291cmNlQ2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmRlYnVnKFwiRGF0YVNlcnZpY2UgLSB1cGRhdGVkIGRhdGEgc291cmNlIGNhbGxiYWNrXCIpO1xuICAgIHRoaXMuZGF0YVNvdXJjZUNhbGxiYWNrID0gZGF0YVNvdXJjZUNhbGxiYWNrO1xuICAgIHRoaXMuaXNMb2FkaW5nSW5pdGlhbERhdGEgPSB0cnVlO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5za2lwKCk7XG4gICAgdGhpcy5kaXNwYXRjaChcImRhdGEtc291cmNlLWNoYW5nZVwiKTtcbiAgfVxuICBjbGVhckNhbGxiYWNrKCkge1xuICAgIHRoaXMuZGF0YVNvdXJjZUNhbGxiYWNrID0gdm9pZCAwO1xuICB9XG4gIGxvYWQocGFyYW1zKSB7XG4gICAgdGhpcy5pc0xvYWRpbmdEYXRhID0gdHJ1ZTtcbiAgICB0aGlzLnRocm90dGxlZEZldGNoKHBhcmFtcyk7XG4gIH1cbiAgaXNMYXp5KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2VDYWxsYmFjayAhPSBudWxsO1xuICB9XG4gIGlzTG9hZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xhenkoKSAmJiAodGhpcy5pc0xvYWRpbmdJbml0aWFsRGF0YSB8fCB0aGlzLmlzTG9hZGluZ0RhdGEpO1xuICB9XG4gIGNyZWF0ZVRocm90dGxlZEZldGNoKHJlcXVlc3RUaHJvdHRsZSkge1xuICAgIHJldHVybiB0aHJvdHRsZShcbiAgICAgIChwYXJhbXMpID0+IHRoaXMuZmV0Y2gocGFyYW1zKS5jYXRjaCgoZSkgPT4gbG9nZ2VyX2V4cG9ydHMuZXJyb3IoXCJjYWxsYmFjayBmYWlsZWRcIiwgZSkpLFxuICAgICAgcmVxdWVzdFRocm90dGxlLFxuICAgICAge1xuICAgICAgICBsZWFkaW5nOiBmYWxzZSxcbiAgICAgICAgdHJhaWxpbmc6IHRydWVcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGNyZWF0ZVRocm90dGxlZERpc3BhdGNoKGRpc3BhdGNoVGhyb3R0bGUpIHtcbiAgICByZXR1cm4gdGhyb3R0bGUoXG4gICAgICAoaWQsIGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhgRGF0YVNlcnZpY2UgLSBkaXNwYXRjaGluZyAnZGF0YS1sb2FkJyB8ICR7aWR9YCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goXCJkYXRhLWxvYWRcIiwgeyB0eXBlOiBcImRhdGEtbG9hZFwiLCBkYXRhIH0pO1xuICAgICAgfSxcbiAgICAgIGRpc3BhdGNoVGhyb3R0bGUsXG4gICAgICB7XG4gICAgICAgIGxlYWRpbmc6IHRydWUsXG4gICAgICAgIHRyYWlsaW5nOiB0cnVlXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmZXRjaChwYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMuZGF0YVNvdXJjZUNhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhU2VydmljZSAtIFtkYXRhU291cmNlLmdldERhdGFdIGNhbGxiYWNrIG5vdCBpbml0aWFsaXNlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnQyID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgaWQgPSB0aGlzLnJlcXVlc3RDb3VudGVyKys7XG4gICAgdGhpcy5kZWJ1ZyhgRGF0YVNlcnZpY2UgLSByZXF1ZXN0aW5nIHwgJHtpZH1gKTtcbiAgICB0aGlzLmZyZXNoUmVxdWVzdHMucHVzaChpZCk7XG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIHRyeSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZGF0YVNvdXJjZUNhbGxiYWNrKHBhcmFtcyk7XG4gICAgICB0aGlzLmRlYnVnKGBEYXRhU2VydmljZSAtIHJlc3BvbnNlIHwgJHtwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0Mn1tcyB8ICR7aWR9YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICB0aGlzLmRlYnVnKGBEYXRhU2VydmljZSAtIHJlcXVlc3QgZmFpbGVkIHwgJHtpZH1gKTtcbiAgICAgIGxvZ2dlcl9leHBvcnRzLmVycm9yT25jZShgRGF0YVNlcnZpY2UgLSByZXF1ZXN0IGZhaWxlZCB8IFske2Vycm9yMn1dYCk7XG4gICAgfVxuICAgIHRoaXMuaXNMb2FkaW5nSW5pdGlhbERhdGEgPSBmYWxzZTtcbiAgICBjb25zdCByZXF1ZXN0SW5kZXggPSB0aGlzLmZyZXNoUmVxdWVzdHMuZmluZEluZGV4KChyaWQpID0+IHJpZCA9PT0gaWQpO1xuICAgIGlmIChyZXF1ZXN0SW5kZXggPT09IC0xIHx8IHRoaXMuZGlzcGF0Y2hPbmx5TGF0ZXN0ICYmIHJlcXVlc3RJbmRleCAhPT0gdGhpcy5mcmVzaFJlcXVlc3RzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuZGVidWcoYERhdGFTZXJ2aWNlIC0gZGlzY2FyZGluZyBzdGFsZSByZXF1ZXN0IHwgJHtpZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5mcmVzaFJlcXVlc3RzID0gdGhpcy5mcmVzaFJlcXVlc3RzLnNsaWNlKHJlcXVlc3RJbmRleCArIDEpO1xuICAgIGlmICh0aGlzLmZyZXNoUmVxdWVzdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmlzTG9hZGluZ0RhdGEgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICB0aGlzLnRocm90dGxlZERpc3BhdGNoKGlkLCByZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2goXCJkYXRhLWVycm9yXCIpO1xuICAgIH1cbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZShkaXNwYXRjaFRocm90dGxlKSB7XG4gICAgICB0aGlzLnRocm90dGxlZERpc3BhdGNoID0gdGhpcy5jcmVhdGVUaHJvdHRsZWREaXNwYXRjaChkaXNwYXRjaFRocm90dGxlKTtcbiAgICB9XG4gIH0pXG5dLCBEYXRhU2VydmljZS5wcm90b3R5cGUsIFwiZGlzcGF0Y2hUaHJvdHRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZShyZXF1ZXN0VGhyb3R0bGUpIHtcbiAgICAgIHRoaXMudGhyb3R0bGVkRmV0Y2ggPSB0aGlzLmNyZWF0ZVRocm90dGxlZEZldGNoKHJlcXVlc3RUaHJvdHRsZSk7XG4gICAgfVxuICB9KVxuXSwgRGF0YVNlcnZpY2UucHJvdG90eXBlLCBcInJlcXVlc3RUaHJvdHRsZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vYW5pbWF0aW9uQmF0Y2gudHNcbnZhciBBbmltYXRpb25CYXRjaCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobWF4QW5pbWF0aW9uVGltZSkge1xuICAgIHRoaXMubWF4QW5pbWF0aW9uVGltZSA9IG1heEFuaW1hdGlvblRpbWU7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImFuaW1hdGlvblwiKTtcbiAgICB0aGlzLmNvbnRyb2xsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnN0b3BwZWRDYnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuY3VycmVudFBoYXNlID0gMDtcbiAgICB0aGlzLnBoYXNlcyA9IG5ldyBNYXAoUEhBU0VfT1JERVIubWFwKChwKSA9PiBbcCwgW11dKSk7XG4gICAgdGhpcy5za2lwQW5pbWF0aW9ucyA9IGZhbHNlO1xuICAgIHRoaXMuYW5pbWF0aW9uVGltZUNvbnN1bWVkID0gMDtcbiAgICAvKiogR3VhcmQgYWdhaW5zdCBwcmVtYXR1cmUgYW5pbWF0aW9uIGV4ZWN1dGlvbi4gKi9cbiAgICB0aGlzLmlzUmVhZHkgPSBmYWxzZTtcbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sbGVycy5zaXplO1xuICB9XG4gIGdldCBjb25zdW1lZFRpbWVNcygpIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRpb25UaW1lQ29uc3VtZWQ7XG4gIH1cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbGxlcnMuc2l6ZSA+IDA7XG4gIH1cbiAgZ2V0QWN0aXZlQ29udHJvbGxlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGhhc2VzLmdldChQSEFTRV9PUkRFUlt0aGlzLmN1cnJlbnRQaGFzZV0pID8/IFtdO1xuICB9XG4gIGNoZWNrT3ZlcmxhcHBpbmdJZChpZCkge1xuICAgIGlmIChpZCAhPSBudWxsICYmIHRoaXMuY29udHJvbGxlcnMuaGFzKGlkKSkge1xuICAgICAgdGhpcy5jb250cm9sbGVycy5nZXQoaWQpLnN0b3AoKTtcbiAgICAgIHRoaXMuZGVidWcoYFNraXBwaW5nIGFuaW1hdGlvbiBiYXRjaCBkdWUgdG8gdXBkYXRlIG9mIGV4aXN0aW5nIGFuaW1hdGlvbjogJHtpZH1gKTtcbiAgICAgIHRoaXMuc2tpcCgpO1xuICAgIH1cbiAgfVxuICBhZGRBbmltYXRpb24oYW5pbWF0aW9uKSB7XG4gICAgaWYgKGFuaW1hdGlvbi5pc0NvbXBsZXRlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGFuaW1hdGlvblBoYXNlSWR4ID0gUEhBU0VfT1JERVIuaW5kZXhPZihhbmltYXRpb24ucGhhc2UpO1xuICAgIGlmIChhbmltYXRpb25QaGFzZUlkeCA8IHRoaXMuY3VycmVudFBoYXNlKSB7XG4gICAgICB0aGlzLmRlYnVnKGBTa2lwcGluZyBhbmltYXRpb24gZHVlIHRvIGJlaW5nIGZvciBhbiBlYXJsaWVyIHBoYXNlYCwgYW5pbWF0aW9uLmlkKTtcbiAgICAgIGFuaW1hdGlvbi5zdG9wKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY29udHJvbGxlcnMuc2V0KGFuaW1hdGlvbi5pZCwgYW5pbWF0aW9uKTtcbiAgICB0aGlzLnBoYXNlcy5nZXQoYW5pbWF0aW9uLnBoYXNlKT8ucHVzaChhbmltYXRpb24pO1xuICB9XG4gIHJlbW92ZUFuaW1hdGlvbihhbmltYXRpb24pIHtcbiAgICB0aGlzLmNvbnRyb2xsZXJzLmRlbGV0ZShhbmltYXRpb24uaWQpO1xuICAgIGNvbnN0IHBoYXNlID0gdGhpcy5waGFzZXMuZ2V0KGFuaW1hdGlvbi5waGFzZSk7XG4gICAgY29uc3QgaW5kZXggPSBwaGFzZT8uaW5kZXhPZihhbmltYXRpb24pO1xuICAgIGlmIChpbmRleCAhPSBudWxsICYmIGluZGV4ID49IDApIHtcbiAgICAgIHBoYXNlPy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuICBwcm9ncmVzcyhkZWx0YVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNSZWFkeSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgdW51c2VkVGltZSA9IGRlbHRhVGltZSA9PT0gMCA/IDAuMDEgOiBkZWx0YVRpbWU7XG4gICAgY29uc3QgcmVmcmVzaCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBoYXNlMiA9IFBIQVNFX09SREVSW3RoaXMuY3VycmVudFBoYXNlXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBoYXNlQ29udHJvbGxlcnM6IFsuLi50aGlzLmdldEFjdGl2ZUNvbnRyb2xsZXJzKCldLFxuICAgICAgICBwaGFzZTogcGhhc2UyLFxuICAgICAgICBwaGFzZU1ldGE6IFBIQVNFX01FVEFEQVRBW3BoYXNlMl1cbiAgICAgIH07XG4gICAgfTtcbiAgICBsZXQgeyBwaGFzZSwgcGhhc2VDb250cm9sbGVycywgcGhhc2VNZXRhIH0gPSByZWZyZXNoKCk7XG4gICAgY29uc3QgYXJlUGhhc2VzQ29tcGxldGUgPSAoKSA9PiBQSEFTRV9PUkRFUlt0aGlzLmN1cnJlbnRQaGFzZV0gPT0gbnVsbDtcbiAgICBjb25zdCBwcm9ncmVzc1BoYXNlID0gKCkgPT4ge1xuICAgICAgKHsgcGhhc2UsIHBoYXNlQ29udHJvbGxlcnMsIHBoYXNlTWV0YSB9ID0gcmVmcmVzaCgpKTtcbiAgICAgIHdoaWxlICghYXJlUGhhc2VzQ29tcGxldGUoKSAmJiBwaGFzZUNvbnRyb2xsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRQaGFzZSsrO1xuICAgICAgICAoeyBwaGFzZSwgcGhhc2VDb250cm9sbGVycywgcGhhc2VNZXRhIH0gPSByZWZyZXNoKCkpO1xuICAgICAgICB0aGlzLmRlYnVnKGBBbmltYXRpb25CYXRjaCAtIHBoYXNlIGNoYW5naW5nIHRvICR7cGhhc2V9YCwgeyB1bnVzZWRUaW1lIH0sIHBoYXNlQ29udHJvbGxlcnMpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLmNvbnRyb2xsZXJzLnNpemU7XG4gICAgdGhpcy5kZWJ1ZyhgQW5pbWF0aW9uQmF0Y2ggLSAke2RlbHRhVGltZX1tczsgcGhhc2UgJHtwaGFzZX0gd2l0aCAke3BoYXNlQ29udHJvbGxlcnM/Lmxlbmd0aH0gb2YgJHt0b3RhbH1gKTtcbiAgICBkbyB7XG4gICAgICBjb25zdCBwaGFzZURlbHRhVGltZSA9IHVudXNlZFRpbWU7XG4gICAgICBjb25zdCBza2lwUGhhc2UgPSBwaGFzZU1ldGEuc2tpcElmTm9FYXJsaWVyQW5pbWF0aW9ucyAmJiB0aGlzLmFuaW1hdGlvblRpbWVDb25zdW1lZCA9PT0gMDtcbiAgICAgIGxldCBjb21wbGV0ZUNvdW50ID0gMDtcbiAgICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiBwaGFzZUNvbnRyb2xsZXJzKSB7XG4gICAgICAgIGlmIChza2lwUGhhc2UpIHtcbiAgICAgICAgICBjb250cm9sbGVyLnN0b3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1bnVzZWRUaW1lID0gTWF0aC5taW4oY29udHJvbGxlci51cGRhdGUocGhhc2VEZWx0YVRpbWUpLCB1bnVzZWRUaW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbGxlci5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgY29tcGxldGVDb3VudCsrO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQW5pbWF0aW9uKGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmFuaW1hdGlvblRpbWVDb25zdW1lZCArPSBwaGFzZURlbHRhVGltZSAtIHVudXNlZFRpbWU7XG4gICAgICB0aGlzLmRlYnVnKGBBbmltYXRpb25CYXRjaCAtIHVwZGF0ZWQgJHtwaGFzZUNvbnRyb2xsZXJzLmxlbmd0aH0gY29udHJvbGxlcnM7ICR7Y29tcGxldGVDb3VudH0gY29tcGxldGVkYCk7XG4gICAgICB0aGlzLmRlYnVnKGBBbmltYXRpb25CYXRjaCAtIGFuaW1hdGlvblRpbWVDb25zdW1lZDogJHt0aGlzLmFuaW1hdGlvblRpbWVDb25zdW1lZH1gKTtcbiAgICAgIHByb2dyZXNzUGhhc2UoKTtcbiAgICB9IHdoaWxlICh1bnVzZWRUaW1lID4gMCAmJiAhYXJlUGhhc2VzQ29tcGxldGUoKSk7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uVGltZUNvbnN1bWVkID4gdGhpcy5tYXhBbmltYXRpb25UaW1lKSB7XG4gICAgICB0aGlzLmRlYnVnKGBBbmltYXRpb24gYmF0Y2ggZXhjZWVkZWQgbWF4IGFuaW1hdGlvbiB0aW1lLCBza2lwcGluZ2AsIFsuLi50aGlzLmNvbnRyb2xsZXJzXSk7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICB9XG4gIH1cbiAgcmVhZHkoKSB7XG4gICAgaWYgKHRoaXMuaXNSZWFkeSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMuZGVidWcoYEFuaW1hdGlvbkJhdGNoIC0gcmVhZHk7IHNraXBwZWQ6ICR7dGhpcy5za2lwQW5pbWF0aW9uc31gLCBbLi4udGhpcy5jb250cm9sbGVyc10pO1xuICAgIGxldCBza2lwQWxsID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IFssIGNvbnRyb2xsZXJdIG9mIHRoaXMuY29udHJvbGxlcnMpIHtcbiAgICAgIGlmIChjb250cm9sbGVyLmR1cmF0aW9uID4gMCAmJiBQSEFTRV9NRVRBREFUQVtjb250cm9sbGVyLnBoYXNlXS5za2lwSWZOb0VhcmxpZXJBbmltYXRpb25zICE9PSB0cnVlKSB7XG4gICAgICAgIHNraXBBbGwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc2tpcEFsbCkge1xuICAgICAgZm9yIChjb25zdCBbLCBjb250cm9sbGVyXSBvZiB0aGlzLmNvbnRyb2xsZXJzKSB7XG4gICAgICAgIGlmIChjb250cm9sbGVyLmF1dG9wbGF5KSB7XG4gICAgICAgICAgY29udHJvbGxlci5wbGF5KHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNraXAoc2tpcCA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5za2lwQW5pbWF0aW9ucyA9PT0gZmFsc2UgJiYgc2tpcCA9PT0gdHJ1ZSkge1xuICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuY29udHJvbGxlcnMudmFsdWVzKCkpIHtcbiAgICAgICAgY29udHJvbGxlci5zdG9wKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnRyb2xsZXJzLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuc2tpcEFuaW1hdGlvbnMgPSBza2lwO1xuICB9XG4gIHBsYXkoKSB7XG4gICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuY29udHJvbGxlcnMudmFsdWVzKCkpIHtcbiAgICAgIGNvbnRyb2xsZXIucGxheSgpO1xuICAgIH1cbiAgfVxuICBzdG9wKCkge1xuICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzLnZhbHVlcygpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb250cm9sbGVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbmltYXRpb24oY29udHJvbGxlcik7XG4gICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgbG9nZ2VyX2V4cG9ydHMuZXJyb3IoXCJFcnJvciBkdXJpbmcgYW5pbWF0aW9uIHN0b3BcIiwgZXJyb3IyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaFN0b3BwZWQoKTtcbiAgfVxuICBzdG9wQnlBbmltYXRpb25JZChpZCkge1xuICAgIGlmIChpZCAhPSBudWxsICYmIHRoaXMuY29udHJvbGxlcnMuaGFzKGlkKSkge1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY29udHJvbGxlcnMuZ2V0KGlkKTtcbiAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc3RvcCgpO1xuICAgICAgICB0aGlzLnJlbW92ZUFuaW1hdGlvbihjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZChpZCkge1xuICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoY29udHJvbGxlci5ncm91cElkID09PSBpZCkge1xuICAgICAgICB0aGlzLnN0b3BCeUFuaW1hdGlvbklkKGNvbnRyb2xsZXIuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNwYXRjaFN0b3BwZWQoKSB7XG4gICAgdGhpcy5zdG9wcGVkQ2JzLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICB0aGlzLnN0b3BwZWRDYnMuY2xlYXIoKTtcbiAgfVxuICBpc1NraXBwZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2tpcEFuaW1hdGlvbnM7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICB0aGlzLmNvbnRyb2xsZXJzLmNsZWFyKCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2ludGVyYWN0aW9uTWFuYWdlci50c1xudmFyIEludGVyYWN0aW9uU3RhdGUgPSAvKiBAX19QVVJFX18gKi8gKChJbnRlcmFjdGlvblN0YXRlMikgPT4ge1xuICBJbnRlcmFjdGlvblN0YXRlMltJbnRlcmFjdGlvblN0YXRlMltcIkRlZmF1bHRcIl0gPSAzMl0gPSBcIkRlZmF1bHRcIjtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJab29tRHJhZ1wiXSA9IDE2XSA9IFwiWm9vbURyYWdcIjtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJBbm5vdGF0aW9uc1wiXSA9IDhdID0gXCJBbm5vdGF0aW9uc1wiO1xuICBJbnRlcmFjdGlvblN0YXRlMltJbnRlcmFjdGlvblN0YXRlMltcIkNvbnRleHRNZW51XCJdID0gNF0gPSBcIkNvbnRleHRNZW51XCI7XG4gIEludGVyYWN0aW9uU3RhdGUyW0ludGVyYWN0aW9uU3RhdGUyW1wiQW5pbWF0aW9uXCJdID0gMl0gPSBcIkFuaW1hdGlvblwiO1xuICBJbnRlcmFjdGlvblN0YXRlMltJbnRlcmFjdGlvblN0YXRlMltcIkFubm90YXRpb25zU2VsZWN0ZWRcIl0gPSAxXSA9IFwiQW5ub3RhdGlvbnNTZWxlY3RlZFwiO1xuICBJbnRlcmFjdGlvblN0YXRlMltJbnRlcmFjdGlvblN0YXRlMltcIkNsaWNrYWJsZVwiXSA9IDQxXSA9IFwiQ2xpY2thYmxlXCI7XG4gIEludGVyYWN0aW9uU3RhdGUyW0ludGVyYWN0aW9uU3RhdGUyW1wiRm9jdXNhYmxlXCJdID0gMzRdID0gXCJGb2N1c2FibGVcIjtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJLZXlhYmxlXCJdID0gNDNdID0gXCJLZXlhYmxlXCI7XG4gIEludGVyYWN0aW9uU3RhdGUyW0ludGVyYWN0aW9uU3RhdGUyW1wiQ29udGV4dE1lbnVhYmxlXCJdID0gMzZdID0gXCJDb250ZXh0TWVudWFibGVcIjtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJBbm5vdGF0aW9uc01vdmVhYmxlXCJdID0gOV0gPSBcIkFubm90YXRpb25zTW92ZWFibGVcIjtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJBbm5vdGF0aW9uc0RyYWdnYWJsZVwiXSA9IDU3XSA9IFwiQW5ub3RhdGlvbnNEcmFnZ2FibGVcIjtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJab29tRHJhZ2dhYmxlXCJdID0gNTBdID0gXCJab29tRHJhZ2dhYmxlXCI7XG4gIEludGVyYWN0aW9uU3RhdGUyW0ludGVyYWN0aW9uU3RhdGUyW1wiWm9vbUNsaWNrYWJsZVwiXSA9IDM0XSA9IFwiWm9vbUNsaWNrYWJsZVwiO1xuICBJbnRlcmFjdGlvblN0YXRlMltJbnRlcmFjdGlvblN0YXRlMltcIlpvb21XaGVlbGFibGVcIl0gPSA1OV0gPSBcIlpvb21XaGVlbGFibGVcIjtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJBbGxcIl0gPSA2M10gPSBcIkFsbFwiO1xuICByZXR1cm4gSW50ZXJhY3Rpb25TdGF0ZTI7XG59KShJbnRlcmFjdGlvblN0YXRlIHx8IHt9KTtcbnZhciBJbnRlcmFjdGlvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhdGVRdWV1ZSA9IDMyIC8qIERlZmF1bHQgKi8gfCAyIC8qIEFuaW1hdGlvbiAqLztcbiAgfVxuICBwdXNoU3RhdGUoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlUXVldWUgfD0gc3RhdGU7XG4gIH1cbiAgcG9wU3RhdGUoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlUXVldWUgJj0gfnN0YXRlO1xuICB9XG4gIGlzU3RhdGUoYWxsb3dlZFN0YXRlcykge1xuICAgIHJldHVybiAhISh0aGlzLnN0YXRlUXVldWUgJiAtdGhpcy5zdGF0ZVF1ZXVlICYgYWxsb3dlZFN0YXRlcyk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2FuaW1hdGlvbk1hbmFnZXIudHNcbmZ1bmN0aW9uIHZhbGlkQW5pbWF0aW9uRHVyYXRpb24odGVzdGVlKSB7XG4gIGlmICh0ZXN0ZWUgPT0gbnVsbClcbiAgICByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuICFpc05hTih0ZXN0ZWUpICYmIHRlc3RlZSA+PSAwICYmIHRlc3RlZSA8PSAyO1xufVxudmFyIEFuaW1hdGlvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGludGVyYWN0aW9uTWFuYWdlciwgY2hhcnRVcGRhdGVNdXRleCkge1xuICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyID0gaW50ZXJhY3Rpb25NYW5hZ2VyO1xuICAgIHRoaXMuY2hhcnRVcGRhdGVNdXRleCA9IGNoYXJ0VXBkYXRlTXV0ZXg7XG4gICAgdGhpcy5kZWZhdWx0RHVyYXRpb24gPSAxZTM7XG4gICAgdGhpcy5iYXRjaCA9IG5ldyBBbmltYXRpb25CYXRjaCh0aGlzLmRlZmF1bHREdXJhdGlvbiAqIDEuNSk7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImFuaW1hdGlvblwiKTtcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLnJhZkF2YWlsYWJsZSA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuICAgIHRoaXMucmVxdWVzdElkID0gbnVsbDtcbiAgICB0aGlzLnNraXBBbmltYXRpb25zID0gdHJ1ZTtcbiAgICB0aGlzLmN1cnJlbnRBbm9ueW1vdXNBbmltYXRpb25JZCA9IDA7XG4gIH1cbiAgYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiB0aGlzLmV2ZW50cy5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuIGFuaW1hdGlvbiB0byB0d2VlbiBhIHZhbHVlIGJldHdlZW4gdGhlIGBmcm9tYCBhbmQgYHRvYCBwcm9wZXJ0aWVzLiBJZiBhbiBhbmltYXRpb24gYWxyZWFkeSBleGlzdHNcbiAgICogd2l0aCB0aGUgc2FtZSBgaWRgLCBpbW1lZGlhdGVseSBzdG9wIGl0LlxuICAgKi9cbiAgYW5pbWF0ZShvcHRzKSB7XG4gICAgY29uc3QgYmF0Y2ggPSB0aGlzLmJhdGNoO1xuICAgIHRyeSB7XG4gICAgICBiYXRjaC5jaGVja092ZXJsYXBwaW5nSWQob3B0cy5pZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICB0aGlzLmZhaWxzYWZlT25FcnJvcihlcnJvcjIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgeyBpZCB9ID0gb3B0cztcbiAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgaWQgPSBgX18ke3RoaXMuY3VycmVudEFub255bW91c0FuaW1hdGlvbklkfWA7XG4gICAgICB0aGlzLmN1cnJlbnRBbm9ueW1vdXNBbmltYXRpb25JZCArPSAxO1xuICAgIH1cbiAgICBjb25zdCBza2lwID0gdGhpcy5pc1NraXBwZWQoKSB8fCBvcHRzLnBoYXNlID09PSBcIm5vbmVcIjtcbiAgICBpZiAoc2tpcCkge1xuICAgICAgdGhpcy5kZWJ1ZyhcIkFuaW1hdGlvbk1hbmFnZXIgLSBza2lwcGluZyBhbmltYXRpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IHsgZGVsYXksIGR1cmF0aW9uIH0gPSBvcHRzO1xuICAgIGlmICghdmFsaWRBbmltYXRpb25EdXJhdGlvbihkZWxheSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQW5pbWF0aW9uIGRlbGF5IG9mICR7ZGVsYXl9IGlzIHVuc3VwcG9ydGVkICgke2lkfSlgKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZEFuaW1hdGlvbkR1cmF0aW9uKGR1cmF0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbmltYXRpb24gZHVyYXRpb24gb2YgJHtkdXJhdGlvbn0gaXMgdW5zdXBwb3J0ZWQgKCR7aWR9KWApO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBpZCxcbiAgICAgIHNraXAsXG4gICAgICBhdXRvcGxheTogdGhpcy5pc1BsYXlpbmcgPyBvcHRzLmF1dG9wbGF5IDogZmFsc2UsXG4gICAgICBwaGFzZTogb3B0cy5waGFzZSxcbiAgICAgIGRlZmF1bHREdXJhdGlvbjogdGhpcy5kZWZhdWx0RHVyYXRpb25cbiAgICB9KTtcbiAgICBpZiAodGhpcy5mb3JjZVRpbWVKdW1wKGFuaW1hdGlvbiwgdGhpcy5kZWZhdWx0RHVyYXRpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmF0Y2guYWRkQW5pbWF0aW9uKGFuaW1hdGlvbik7XG4gICAgcmV0dXJuIGFuaW1hdGlvbjtcbiAgfVxuICBwbGF5KCkge1xuICAgIGlmICh0aGlzLmlzUGxheWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG4gICAgdGhpcy5kZWJ1ZyhcIkFuaW1hdGlvbk1hbmFnZXIucGxheSgpXCIpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmJhdGNoLnBsYXkoKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgIHRoaXMuZmFpbHNhZmVPbkVycm9yKGVycm9yMik7XG4gICAgfVxuICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbigpO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbigpO1xuICAgIHRoaXMuZGVidWcoXCJBbmltYXRpb25NYW5hZ2VyLnN0b3AoKVwiKTtcbiAgICB0aGlzLmJhdGNoLnN0b3AoKTtcbiAgfVxuICBzdG9wQnlBbmltYXRpb25JZChpZCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmJhdGNoLnN0b3BCeUFuaW1hdGlvbklkKGlkKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgIHRoaXMuZmFpbHNhZmVPbkVycm9yKGVycm9yMik7XG4gICAgfVxuICB9XG4gIHN0b3BCeUFuaW1hdGlvbkdyb3VwSWQoaWQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5iYXRjaC5zdG9wQnlBbmltYXRpb25Hcm91cElkKGlkKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgIHRoaXMuZmFpbHNhZmVPbkVycm9yKGVycm9yMik7XG4gICAgfVxuICB9XG4gIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLmlzUGxheWluZykge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuICB9XG4gIHNraXAoc2tpcCA9IHRydWUpIHtcbiAgICB0aGlzLnNraXBBbmltYXRpb25zID0gc2tpcDtcbiAgfVxuICBpc1NraXBwZWQoKSB7XG4gICAgcmV0dXJuICF0aGlzLnJhZkF2YWlsYWJsZSB8fCB0aGlzLnNraXBBbmltYXRpb25zIHx8IHRoaXMuYmF0Y2guaXNTa2lwcGVkKCk7XG4gIH1cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQbGF5aW5nICYmIHRoaXMuYmF0Y2guaXNBY3RpdmUoKTtcbiAgfVxuICBza2lwQ3VycmVudEJhdGNoKCkge1xuICAgIGlmICh0aGlzLmRlYnVnLmNoZWNrKCkpIHtcbiAgICAgIHRoaXMuZGVidWcoYEFuaW1hdGlvbk1hbmFnZXIgLSBza2lwQ3VycmVudEJhdGNoKClgLCB7IHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayB9KTtcbiAgICB9XG4gICAgdGhpcy5iYXRjaC5za2lwKCk7XG4gIH1cbiAgLyoqIE1vY2tpbmcgcG9pbnQgZm9yIHRlc3RzIHRvIGd1YXJhbnRlZSB0aGF0IGFuaW1hdGlvbiB1cGRhdGVzIGhhcHBlbi4gKi9cbiAgaXNTa2lwcGluZ0ZyYW1lcygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKiogTW9ja2luZyBwb2ludCBmb3IgdGVzdHMgdG8gY2FwdHVyZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgY2FsbGJhY2tzLiAqL1xuICBzY2hlZHVsZUFuaW1hdGlvbkZyYW1lKGNiKSB7XG4gICAgdGhpcy5yZXF1ZXN0SWQgPSBnZXRXaW5kb3coKS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHQpID0+IHtcbiAgICAgIGNiKHQpLmNhdGNoKChlKSA9PiBsb2dnZXJfZXhwb3J0cy5lcnJvcihlKSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqIE1vY2tpbmcgcG9pbnQgZm9yIHRlc3RzIHRvIHNraXAgYW5pbWF0aW9ucyB0byBhIHNwZWNpZmljIHBvaW50IGluIHRpbWUuICovXG4gIGZvcmNlVGltZUp1bXAoX2FuaW1hdGlvbiwgX2RlZmF1bHREdXJhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXF1ZXN0QW5pbWF0aW9uKCkge1xuICAgIGlmICghdGhpcy5yYWZBdmFpbGFibGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCF0aGlzLmJhdGNoLmlzQWN0aXZlKCkgfHwgdGhpcy5yZXF1ZXN0SWQgIT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHByZXZUaW1lO1xuICAgIGNvbnN0IG9uQW5pbWF0aW9uRnJhbWUgPSBhc3luYyAodGltZTIpID0+IHtcbiAgICAgIGNvbnN0IGV4ZWN1dGVBbmltYXRpb25GcmFtZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZGVsdGFUaW1lID0gdGltZTIgLSAocHJldlRpbWUgPz8gdGltZTIpO1xuICAgICAgICBwcmV2VGltZSA9IHRpbWUyO1xuICAgICAgICB0aGlzLmRlYnVnKFwiQW5pbWF0aW9uTWFuYWdlciAtIG9uQW5pbWF0aW9uRnJhbWUoKVwiLCB7XG4gICAgICAgICAgY29udHJvbGxlcnNDb3VudDogdGhpcy5iYXRjaC5zaXplLFxuICAgICAgICAgIGRlbHRhVGltZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIucHVzaFN0YXRlKDIgLyogQW5pbWF0aW9uICovKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmJhdGNoLnByb2dyZXNzKGRlbHRhVGltZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICAgIHRoaXMuZmFpbHNhZmVPbkVycm9yKGVycm9yMik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudHMuZW1pdChcImFuaW1hdGlvbi1mcmFtZVwiLCB7XG4gICAgICAgICAgdHlwZTogXCJhbmltYXRpb24tZnJhbWVcIixcbiAgICAgICAgICBkZWx0YU1zOiBkZWx0YVRpbWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuaXNTa2lwcGluZ0ZyYW1lcygpKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2hhcnRVcGRhdGVNdXRleC5hY3F1aXJlSW1tZWRpYXRlbHkoZXhlY3V0ZUFuaW1hdGlvbkZyYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2hhcnRVcGRhdGVNdXRleC5hY3F1aXJlKGV4ZWN1dGVBbmltYXRpb25GcmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5iYXRjaC5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVBbmltYXRpb25GcmFtZShvbkFuaW1hdGlvbkZyYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmF0Y2guc3RvcCgpO1xuICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KFwiYW5pbWF0aW9uLXN0b3BcIiwge1xuICAgICAgICAgIHR5cGU6IFwiYW5pbWF0aW9uLXN0b3BcIixcbiAgICAgICAgICBkZWx0YU1zOiB0aGlzLmJhdGNoLmNvbnN1bWVkVGltZU1zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5ldmVudHMuZW1pdChcImFuaW1hdGlvbi1zdGFydFwiLCB7XG4gICAgICB0eXBlOiBcImFuaW1hdGlvbi1zdGFydFwiLFxuICAgICAgZGVsdGFNczogMFxuICAgIH0pO1xuICAgIHRoaXMuc2NoZWR1bGVBbmltYXRpb25GcmFtZShvbkFuaW1hdGlvbkZyYW1lKTtcbiAgfVxuICBjYW5jZWxBbmltYXRpb24oKSB7XG4gICAgaWYgKHRoaXMucmVxdWVzdElkID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVxdWVzdElkKTtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IG51bGw7XG4gICAgdGhpcy5zdGFydEJhdGNoKCk7XG4gIH1cbiAgZmFpbHNhZmVPbkVycm9yKGVycm9yMiwgY2FuY2VsQW5pbWF0aW9uID0gdHJ1ZSkge1xuICAgIGxvZ2dlcl9leHBvcnRzLmVycm9yKFwiRXJyb3IgZHVyaW5nIGFuaW1hdGlvbiwgc2tpcHBpbmcgYW5pbWF0aW9uc1wiLCBlcnJvcjIpO1xuICAgIGlmIChjYW5jZWxBbmltYXRpb24pIHtcbiAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uKCk7XG4gICAgfVxuICB9XG4gIHN0YXJ0QmF0Y2goc2tpcEFuaW1hdGlvbnMpIHtcbiAgICB0aGlzLmRlYnVnKGBBbmltYXRpb25NYW5hZ2VyIC0gc3RhcnRCYXRjaCgpIHdpdGggc2tpcEFuaW1hdGlvbnM9JHtza2lwQW5pbWF0aW9uc30uYCk7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuYmF0Y2guZGVzdHJveSgpO1xuICAgIHRoaXMuYmF0Y2ggPSBuZXcgQW5pbWF0aW9uQmF0Y2godGhpcy5kZWZhdWx0RHVyYXRpb24gKiAxLjUpO1xuICAgIGlmIChza2lwQW5pbWF0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5iYXRjaC5za2lwKCk7XG4gICAgfVxuICB9XG4gIGVuZEJhdGNoKCkge1xuICAgIGlmICh0aGlzLmJhdGNoLmlzQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuYmF0Y2gucmVhZHkoKTtcbiAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlci5wb3BTdGF0ZSgyIC8qIEFuaW1hdGlvbiAqLyk7XG4gICAgICBpZiAodGhpcy5iYXRjaC5pc1NraXBwZWQoKSkge1xuICAgICAgICB0aGlzLmJhdGNoLnNraXAoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkJhdGNoU3RvcChjYikge1xuICAgIHRoaXMuYmF0Y2guc3RvcHBlZENicy5hZGQoY2IpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy5ldmVudHMuY2xlYXIoKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vY2hhcnRFdmVudE1hbmFnZXIudHNcbnZhciBDaGFydEV2ZW50TWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBzZXJpZXNFdmVudCh0eXBlKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2godHlwZSwgeyB0eXBlIH0pO1xuICB9XG4gIHNlcmllc0tleU5hdlpvb20oZGVsdGEzLCB3aWRnZXRFdmVudCkge1xuICAgIGNvbnN0IGV2ZW50ID0geyB0eXBlOiBcInNlcmllcy1rZXluYXYtem9vbVwiLCBkZWx0YTogZGVsdGEzLCB3aWRnZXRFdmVudCB9O1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwic2VyaWVzLWtleW5hdi16b29tXCIsIGV2ZW50KTtcbiAgfVxuICBsZWdlbmRJdGVtQ2xpY2sobGVnZW5kVHlwZSwgc2VyaWVzLCBpdGVtSWQsIGVuYWJsZWQsIGxlZ2VuZEl0ZW1OYW1lKSB7XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICB0eXBlOiBcImxlZ2VuZC1pdGVtLWNsaWNrXCIsXG4gICAgICBsZWdlbmRUeXBlLFxuICAgICAgc2VyaWVzLFxuICAgICAgaXRlbUlkLFxuICAgICAgZW5hYmxlZCxcbiAgICAgIGxlZ2VuZEl0ZW1OYW1lXG4gICAgfTtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImxlZ2VuZC1pdGVtLWNsaWNrXCIsIGV2ZW50KTtcbiAgfVxuICBsZWdlbmRJdGVtRG91YmxlQ2xpY2sobGVnZW5kVHlwZSwgc2VyaWVzLCBpdGVtSWQsIGVuYWJsZWQsIG51bVZpc2libGVJdGVtcywgbGVnZW5kSXRlbU5hbWUpIHtcbiAgICBjb25zdCBldmVudCA9IHtcbiAgICAgIHR5cGU6IFwibGVnZW5kLWl0ZW0tZG91YmxlLWNsaWNrXCIsXG4gICAgICBsZWdlbmRUeXBlLFxuICAgICAgc2VyaWVzLFxuICAgICAgaXRlbUlkLFxuICAgICAgZW5hYmxlZCxcbiAgICAgIGxlZ2VuZEl0ZW1OYW1lLFxuICAgICAgbnVtVmlzaWJsZUl0ZW1zXG4gICAgfTtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImxlZ2VuZC1pdGVtLWRvdWJsZS1jbGlja1wiLCBldmVudCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2NvbnRleHRNZW51UmVnaXN0cnkudHNcbnZhciBDb250ZXh0TWVudVJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRlZmF1bHRBY3Rpb25zID0gW107XG4gICAgdGhpcy5kaXNhYmxlZEFjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuaGlkZGVuQWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgTGlzdGVuZXJzKCk7XG4gIH1cbiAgc3RhdGljIGNoZWNrKHR5cGUsIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnR5cGUgPT09IHR5cGU7XG4gIH1cbiAgc3RhdGljIGNoZWNrQ2FsbGJhY2soZGVzaXJlZFR5cGUsIHR5cGUsIF9jYWxsYmFjaykge1xuICAgIHJldHVybiBkZXNpcmVkVHlwZSA9PT0gdHlwZTtcbiAgfVxuICBkaXNwYXRjaENvbnRleHQodHlwZSwgcG9pbnRlckV2ZW50LCBjb250ZXh0LCBwb3NpdGlvbikge1xuICAgIGNvbnN0IHsgc291cmNlRXZlbnQgfSA9IHBvaW50ZXJFdmVudDtcbiAgICBjb25zdCB4ID0gcG9zaXRpb24/LnggPz8gcG9pbnRlckV2ZW50LmNhbnZhc1g7XG4gICAgY29uc3QgeSA9IHBvc2l0aW9uPy55ID8/IHBvaW50ZXJFdmVudC5jYW52YXNZO1xuICAgIHNvdXJjZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGNvbnN0IGV2ZW50ID0geyB0eXBlLCB4LCB5LCBjb250ZXh0LCBzb3VyY2VFdmVudCB9O1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiXCIsIGV2ZW50KTtcbiAgfVxuICBhZGRMaXN0ZW5lcihoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLmFkZExpc3RlbmVyKFwiXCIsIGhhbmRsZXIpO1xuICB9XG4gIGZpbHRlckFjdGlvbnModHlwZSkge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRBY3Rpb25zLmZpbHRlcigoYWN0aW9uKSA9PiB7XG4gICAgICByZXR1cm4gYWN0aW9uLmlkICE9IG51bGwgJiYgIXRoaXMuaGlkZGVuQWN0aW9ucy5oYXMoYWN0aW9uLmlkKSAmJiBbXCJhbGxcIiwgdHlwZV0uaW5jbHVkZXMoYWN0aW9uLnR5cGUpO1xuICAgIH0pO1xuICB9XG4gIHJlZ2lzdGVyRGVmYXVsdEFjdGlvbihhY3Rpb24pIHtcbiAgICBjb25zdCBkaWRBZGQgPSBhY3Rpb24uaWQgIT0gbnVsbCAmJiAhdGhpcy5kZWZhdWx0QWN0aW9ucy5zb21lKCh7IGlkIH0pID0+IGlkID09PSBhY3Rpb24uaWQpO1xuICAgIGlmIChkaWRBZGQpIHtcbiAgICAgIHRoaXMuZGVmYXVsdEFjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBkaWRBZGQgPyB0aGlzLmRlZmF1bHRBY3Rpb25zLmZpbmRJbmRleCgoeyBpZCB9KSA9PiBpZCA9PT0gYWN0aW9uLmlkKSA6IC0xO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLmRlZmF1bHRBY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBlbmFibGVBY3Rpb24oYWN0aW9uSWQpIHtcbiAgICB0aGlzLmRpc2FibGVkQWN0aW9ucy5kZWxldGUoYWN0aW9uSWQpO1xuICB9XG4gIGRpc2FibGVBY3Rpb24oYWN0aW9uSWQpIHtcbiAgICB0aGlzLmRpc2FibGVkQWN0aW9ucy5hZGQoYWN0aW9uSWQpO1xuICB9XG4gIHNob3dBY3Rpb24oYWN0aW9uSWQpIHtcbiAgICB0aGlzLmhpZGRlbkFjdGlvbnMuYWRkKGFjdGlvbklkKTtcbiAgfVxuICBoaWRlQWN0aW9uKGFjdGlvbklkKSB7XG4gICAgdGhpcy5oaWRkZW5BY3Rpb25zLmRlbGV0ZShhY3Rpb25JZCk7XG4gIH1cbiAgaXNEaXNhYmxlZChhY3Rpb25JZCkge1xuICAgIHJldHVybiB0aGlzLmRpc2FibGVkQWN0aW9ucy5oYXMoYWN0aW9uSWQpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9oaWdobGlnaHRNYW5hZ2VyLnRzXG52YXIgSGlnaGxpZ2h0TWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuaGlnaGxpZ2h0U3RhdGVzID0gbmV3IFN0YXRlVHJhY2tlcigpO1xuICB9XG4gIHVwZGF0ZUhpZ2hsaWdodChjYWxsZXJJZCwgaGlnaGxpZ2h0ZWREYXR1bSkge1xuICAgIGNvbnN0IHsgYWN0aXZlSGlnaGxpZ2h0OiBwcmV2aW91c0hpZ2hsaWdodCB9ID0gdGhpcztcbiAgICB0aGlzLmhpZ2hsaWdodFN0YXRlcy5zZXQoY2FsbGVySWQsIGhpZ2hsaWdodGVkRGF0dW0pO1xuICAgIHRoaXMuYWN0aXZlSGlnaGxpZ2h0ID0gdGhpcy5oaWdobGlnaHRTdGF0ZXMuc3RhdGVWYWx1ZSgpO1xuICAgIGlmICghdGhpcy5pc0VxdWFsKHRoaXMuYWN0aXZlSGlnaGxpZ2h0LCBwcmV2aW91c0hpZ2hsaWdodCkpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiaGlnaGxpZ2h0LWNoYW5nZVwiLCB7XG4gICAgICAgIHR5cGU6IFwiaGlnaGxpZ2h0LWNoYW5nZVwiLFxuICAgICAgICBjdXJyZW50SGlnaGxpZ2h0OiB0aGlzLmFjdGl2ZUhpZ2hsaWdodCxcbiAgICAgICAgcHJldmlvdXNIaWdobGlnaHQsXG4gICAgICAgIGNhbGxlcklkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0QWN0aXZlSGlnaGxpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZUhpZ2hsaWdodDtcbiAgfVxuICBpc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYiB8fCBhICE9IG51bGwgJiYgYiAhPSBudWxsICYmIGE/LnNlcmllcyA9PT0gYj8uc2VyaWVzICYmIGE/Lml0ZW1JZCA9PT0gYj8uaXRlbUlkICYmIGE/LmRhdHVtID09PSBiPy5kYXR1bTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3V0aWwudHNcbmZ1bmN0aW9uIGRhdHVtQm91bmRhcnlQb2ludHMoZGF0dW0sIGRvbWFpbikge1xuICBpZiAoZGF0dW0gPT0gbnVsbCB8fCBkb21haW4ubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtmYWxzZSwgZmFsc2VdO1xuICB9XG4gIGNvbnN0IGRhdHVtVmFsdWUgPSBkYXR1bS52YWx1ZU9mKCk7XG4gIGNvbnN0IGQwID0gZG9tYWluWzBdO1xuICBjb25zdCBkMSA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV07XG4gIGlmICh0eXBlb2YgZDAgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gW2RhdHVtVmFsdWUgPT09IGQwLCBkYXR1bVZhbHVlID09PSBkMV07XG4gIH1cbiAgbGV0IG1pbiA9IGQwLnZhbHVlT2YoKTtcbiAgbGV0IG1heCA9IGQxLnZhbHVlT2YoKTtcbiAgaWYgKG1pbiA+IG1heCkge1xuICAgIFttaW4sIG1heF0gPSBbbWF4LCBtaW5dO1xuICB9XG4gIHJldHVybiBbZGF0dW1WYWx1ZSA9PT0gbWluLCBkYXR1bVZhbHVlID09PSBtYXhdO1xufVxuZnVuY3Rpb24gZGF0dW1TdHlsZXJQcm9wZXJ0aWVzKGRhdHVtLCB4S2V5LCB5S2V5LCB4RG9tYWluLCB5RG9tYWluKSB7XG4gIGNvbnN0IHsgeFZhbHVlLCB5VmFsdWUgfSA9IGRhdHVtO1xuICBjb25zdCBbbWluLCBtYXhdID0gZGF0dW1Cb3VuZGFyeVBvaW50cyh5VmFsdWUsIHlEb21haW4pO1xuICBjb25zdCBbZmlyc3QyLCBsYXN0XSA9IGRhdHVtQm91bmRhcnlQb2ludHMoeFZhbHVlLCB4RG9tYWluKTtcbiAgcmV0dXJuIHtcbiAgICBkYXR1bSxcbiAgICB4S2V5LFxuICAgIHlLZXksXG4gICAgeFZhbHVlLFxuICAgIHlWYWx1ZSxcbiAgICBmaXJzdDogZmlyc3QyLFxuICAgIGxhc3QsXG4gICAgbWluLFxuICAgIG1heFxuICB9O1xufVxuZnVuY3Rpb24gdmlzaWJsZVJhbmdlSW5kaWNlcyhsZW5ndGgyLCBbcmFuZ2UwLCByYW5nZTFdLCB4UmFuZ2UpIHtcbiAgY29uc3QgeE1pbkluZGV4ID0gZmluZE1pbkluZGV4KDAsIGxlbmd0aDIgLSAxLCAoaW5kZXgpID0+IHtcbiAgICBjb25zdCB4MSA9IHhSYW5nZShpbmRleCk/LlsxXSA/PyBOYU47XG4gICAgcmV0dXJuICFOdW1iZXIuaXNGaW5pdGUoeDEpIHx8IHgxID4gcmFuZ2UwO1xuICB9KSA/PyAwO1xuICBsZXQgeE1heEluZGV4ID0gZmluZE1heEluZGV4KDAsIGxlbmd0aDIgLSAxLCAoaW5kZXgpID0+IHtcbiAgICBjb25zdCB4MCA9IHhSYW5nZShpbmRleCk/LlswXSA/PyBOYU47XG4gICAgcmV0dXJuICFOdW1iZXIuaXNGaW5pdGUoeDApIHx8IHgwIDwgcmFuZ2UxO1xuICB9KSA/PyBsZW5ndGgyIC0gMTtcbiAgeE1heEluZGV4ID0gTWF0aC5taW4oeE1heEluZGV4ICsgMSwgbGVuZ3RoMik7XG4gIHJldHVybiBbeE1pbkluZGV4LCB4TWF4SW5kZXhdO1xufVxuZnVuY3Rpb24gZ2V0RGF0dW1SZWZQb2ludChzZXJpZXMsIGRhdHVtKSB7XG4gIGNvbnN0IHJlZlBvaW50ID0gZGF0dW0ueUJhcj8udXBwZXJQb2ludCA/PyBkYXR1bS5taWRQb2ludCA/PyBzZXJpZXMuZGF0dW1NaWRQb2ludD8uKGRhdHVtKTtcbiAgaWYgKHJlZlBvaW50KSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBUcmFuc2Zvcm1hYmxlLnRvQ2FudmFzUG9pbnQoc2VyaWVzLmNvbnRlbnRHcm91cCwgcmVmUG9pbnQueCwgcmVmUG9pbnQueSk7XG4gICAgcmV0dXJuIHsgY2FudmFzWDogTWF0aC5yb3VuZCh4KSwgY2FudmFzWTogTWF0aC5yb3VuZCh5KSB9O1xuICB9XG59XG5mdW5jdGlvbiBjb3VudEV4cGFuZGluZ1NlYXJjaChtaW4sIG1heCwgc3RhcnQyLCBjb3VudFVudGlsLCBpdGVyYXRlZSkge1xuICBsZXQgaSA9IC0xO1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgc2hpZnQgPSAwO1xuICBsZXQgcmVhY2hlZEFuRW5kID0gZmFsc2U7XG4gIHdoaWxlIChjb3VudCA8IGNvdW50VW50aWwgJiYgaSA8PSBtYXggLSBtaW4pIHtcbiAgICBpICs9IDE7XG4gICAgY29uc3QgaW5kZXggPSBzdGFydDIgKyBzaGlmdDtcbiAgICBpZiAoIXJlYWNoZWRBbkVuZClcbiAgICAgIHNoaWZ0ICo9IC0xO1xuICAgIGlmIChzaGlmdCA+PSAwKVxuICAgICAgc2hpZnQgKz0gMTtcbiAgICBpZiAocmVhY2hlZEFuRW5kICYmIHNoaWZ0IDwgMClcbiAgICAgIHNoaWZ0IC09IDE7XG4gICAgaWYgKGluZGV4IDwgbWluIHx8IGluZGV4ID4gbWF4KSB7XG4gICAgICByZWFjaGVkQW5FbmQgPSB0cnVlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpdGVyYXRlZShpbmRleCkpXG4gICAgICBjb3VudCArPSAxO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vdG9vbHRpcE1hbmFnZXIudHNcbnZhciBUb29sdGlwTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZG9tTWFuYWdlciwgdG9vbHRpcCkge1xuICAgIHRoaXMuZG9tTWFuYWdlciA9IGRvbU1hbmFnZXI7XG4gICAgdGhpcy50b29sdGlwID0gdG9vbHRpcDtcbiAgICB0aGlzLnN0YXRlVHJhY2tlciA9IG5ldyBTdGF0ZVRyYWNrZXIoKTtcbiAgICB0aGlzLnN1cHByZXNzU3RhdGUgPSBuZXcgU3RhdGVUcmFja2VyKGZhbHNlKTtcbiAgICB0aGlzLmFwcGxpZWRTdGF0ZSA9IG51bGw7XG4gICAgdG9vbHRpcC5zZXR1cChkb21NYW5hZ2VyKTtcbiAgICBkb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwiaGlkZGVuXCIsICgpID0+IHRoaXMudG9vbHRpcC5oaWRlKCkpO1xuICB9XG4gIHVwZGF0ZVRvb2x0aXAoY2FsbGVySWQsIG1ldGEsIGNvbnRlbnQpIHtcbiAgICBpZiAoIXRoaXMudG9vbHRpcC5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnRlbnQgPz8gKGNvbnRlbnQgPSB0aGlzLnN0YXRlVHJhY2tlci5nZXQoY2FsbGVySWQpPy5jb250ZW50KTtcbiAgICB0aGlzLnN0YXRlVHJhY2tlci5zZXQoY2FsbGVySWQsIHsgY29udGVudCwgbWV0YSB9KTtcbiAgICB0aGlzLmFwcGx5U3RhdGVzKCk7XG4gIH1cbiAgcmVtb3ZlVG9vbHRpcChjYWxsZXJJZCkge1xuICAgIGlmICghdGhpcy50b29sdGlwLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5zdGF0ZVRyYWNrZXIuZGVsZXRlKGNhbGxlcklkKTtcbiAgICB0aGlzLmFwcGx5U3RhdGVzKCk7XG4gIH1cbiAgc3VwcHJlc3NUb29sdGlwKGNhbGxlcklkKSB7XG4gICAgdGhpcy5zdXBwcmVzc1N0YXRlLnNldChjYWxsZXJJZCwgdHJ1ZSk7XG4gIH1cbiAgdW5zdXBwcmVzc1Rvb2x0aXAoY2FsbGVySWQpIHtcbiAgICB0aGlzLnN1cHByZXNzU3RhdGUuZGVsZXRlKGNhbGxlcklkKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVTdHlsZXMoXCJ0b29sdGlwXCIpO1xuICB9XG4gIGFwcGx5U3RhdGVzKCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5zdGF0ZVRyYWNrZXIuc3RhdGVJZCgpO1xuICAgIGNvbnN0IHN0YXRlID0gaWQgPyB0aGlzLnN0YXRlVHJhY2tlci5nZXQoaWQpIDogbnVsbDtcbiAgICBpZiAodGhpcy5zdXBwcmVzc1N0YXRlLnN0YXRlVmFsdWUoKSB8fCBzdGF0ZT8ubWV0YSA9PSBudWxsIHx8IHN0YXRlPy5jb250ZW50ID09IG51bGwpIHtcbiAgICAgIHRoaXMuYXBwbGllZFN0YXRlID0gbnVsbDtcbiAgICAgIHRoaXMudG9vbHRpcC5oaWRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhc1JlY3QgPSB0aGlzLmRvbU1hbmFnZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgYm91bmRpbmdSZWN0ID0gdGhpcy50b29sdGlwLmJvdW5kcyA9PT0gXCJleHRlbmRlZFwiID8gdGhpcy5kb21NYW5hZ2VyLmdldE92ZXJsYXlDbGllbnRSZWN0KCkgOiBjYW52YXNSZWN0O1xuICAgIGlmICh0aGlzLmFwcGxpZWRTdGF0ZT8uY29udGVudCA9PT0gc3RhdGU/LmNvbnRlbnQpIHtcbiAgICAgIGNvbnN0IHJlbmRlckluc3RhbnRseSA9IHRoaXMudG9vbHRpcC5pc1Zpc2libGUoKTtcbiAgICAgIHRoaXMudG9vbHRpcC5zaG93KGJvdW5kaW5nUmVjdCwgY2FudmFzUmVjdCwgc3RhdGU/Lm1ldGEsIG51bGwsIHJlbmRlckluc3RhbnRseSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9vbHRpcC5zaG93KGJvdW5kaW5nUmVjdCwgY2FudmFzUmVjdCwgc3RhdGU/Lm1ldGEsIHN0YXRlPy5jb250ZW50KTtcbiAgICB9XG4gICAgdGhpcy5hcHBsaWVkU3RhdGUgPSBzdGF0ZTtcbiAgfVxuICBzdGF0aWMgbWFrZVRvb2x0aXBNZXRhKGV2ZW50LCBzZXJpZXMsIGRhdHVtKSB7XG4gICAgY29uc3QgeyBjYW52YXNYLCBjYW52YXNZIH0gPSBldmVudDtcbiAgICBjb25zdCB0b29sdGlwID0gc2VyaWVzLnByb3BlcnRpZXMudG9vbHRpcDtcbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgY2FudmFzWCxcbiAgICAgIGNhbnZhc1ksXG4gICAgICBlbmFibGVJbnRlcmFjdGlvbjogdG9vbHRpcC5pbnRlcmFjdGlvbj8uZW5hYmxlZCA/PyBmYWxzZSxcbiAgICAgIGxhc3RQb2ludGVyRXZlbnQ6IHsgdHlwZTogZXZlbnQudHlwZSwgY2FudmFzWCwgY2FudmFzWSB9LFxuICAgICAgc2hvd0Fycm93OiB0b29sdGlwLnNob3dBcnJvdyxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHR5cGU6IHRvb2x0aXAucG9zaXRpb24udHlwZSxcbiAgICAgICAgeE9mZnNldDogdG9vbHRpcC5wb3NpdGlvbi54T2Zmc2V0LFxuICAgICAgICB5T2Zmc2V0OiB0b29sdGlwLnBvc2l0aW9uLnlPZmZzZXRcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlZlBvaW50ID0gZ2V0RGF0dW1SZWZQb2ludChzZXJpZXMsIGRhdHVtKTtcbiAgICBpZiAoKHRvb2x0aXAucG9zaXRpb24udHlwZSA9PT0gXCJub2RlXCIgfHwgdG9vbHRpcC5wb3NpdGlvbi50eXBlID09PSBcInNwYXJrbGluZVwiKSAmJiByZWZQb2ludCkge1xuICAgICAgcmV0dXJuIHsgLi4ubWV0YSwgY2FudmFzWDogcmVmUG9pbnQuY2FudmFzWCwgY2FudmFzWTogcmVmUG9pbnQuY2FudmFzWSB9O1xuICAgIH1cbiAgICByZXR1cm4gbWV0YTtcbiAgfVxuICBpc0VudGVyaW5nSW50ZXJhY3RpdmVUb29sdGlwKGV2ZW50KSB7XG4gICAgY29uc3QgeyB0b29sdGlwIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBldmVudC5zb3VyY2VFdmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIHJldHVybiB0b29sdGlwLmludGVyYWN0aXZlICYmIHRvb2x0aXAuZW5hYmxlZCAmJiB0b29sdGlwLmlzVmlzaWJsZSgpICYmIHRvb2x0aXAuY29udGFpbnMocmVsYXRlZFRhcmdldCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2RyYWdJbnRlcnByZXRlci50c1xudmFyIERSQUdfVEhSRVNIT0xEX1BYID0gMztcbnZhciBET1VCTEVfVEFQX1RJTUVSX01TID0gNTA1O1xuZnVuY3Rpb24gbWFrZVN5bnRoZXRpYyhkZXZpY2UsIHR5cGUsIGV2ZW50KSB7XG4gIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSwgY2xpZW50WCwgY2xpZW50WSwgY3VycmVudFgsIGN1cnJlbnRZLCBzb3VyY2VFdmVudCB9ID0gZXZlbnQ7XG4gIHJldHVybiB7IHR5cGUsIGRldmljZSwgb2Zmc2V0WCwgb2Zmc2V0WSwgY2xpZW50WCwgY2xpZW50WSwgY3VycmVudFgsIGN1cnJlbnRZLCBzb3VyY2VFdmVudCB9O1xufVxuZnVuY3Rpb24gY2hlY2tEaXN0YW5jZVNxdWFyZWQoZHgsIGR5KSB7XG4gIGNvbnN0IGRpc3RhbmNlU3F1YXJlZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgY29uc3QgdGhyZXNob2xkU3F1YXJlZCA9IERSQUdfVEhSRVNIT0xEX1BYICogRFJBR19USFJFU0hPTERfUFg7XG4gIHJldHVybiBkaXN0YW5jZVNxdWFyZWQyID49IHRocmVzaG9sZFNxdWFyZWQ7XG59XG52YXIgRHJhZ0ludGVycHJldGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih3aWRnZXQpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnRvdWNoID0geyBkaXN0YW5jZVRyYXZlbGxlZFg6IDAsIGRpc3RhbmNlVHJhdmVsbGVkWTogMCwgY2xpZW50WDogMCwgY2xpZW50WTogMCB9O1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgd2lkZ2V0LmFkZExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLm9uVG91Y2hTdGFydC5iaW5kKHRoaXMpKSxcbiAgICAgIHdpZGdldC5hZGRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLm9uVG91Y2hNb3ZlLmJpbmQodGhpcykpLFxuICAgICAgd2lkZ2V0LmFkZExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5vblRvdWNoRW5kLmJpbmQodGhpcykpLFxuICAgICAgd2lkZ2V0LmFkZExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSksXG4gICAgICB3aWRnZXQuYWRkTGlzdGVuZXIoXCJkYmxjbGlja1wiLCB0aGlzLm9uRGJsQ2xpY2suYmluZCh0aGlzKSksXG4gICAgICB3aWRnZXQuYWRkTGlzdGVuZXIoXCJkcmFnLXN0YXJ0XCIsIHRoaXMub25EcmFnU3RhcnQuYmluZCh0aGlzKSksXG4gICAgICB3aWRnZXQuYWRkTGlzdGVuZXIoXCJkcmFnLW1vdmVcIiwgdGhpcy5vbkRyYWdNb3ZlLmJpbmQodGhpcykpLFxuICAgICAgd2lkZ2V0LmFkZExpc3RlbmVyKFwiZHJhZy1lbmRcIiwgdGhpcy5vbkRyYWdFbmQuYmluZCh0aGlzKSlcbiAgICApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgICB0aGlzLmxpc3RlbmVycy5kZXN0cm95KCk7XG4gIH1cbiAgYWRkTGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5hZGRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgfVxuICBkaXNwYXRjaChldmVudCkge1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKGV2ZW50LnR5cGUsIGV2ZW50KTtcbiAgfVxuICBvblRvdWNoU3RhcnQoZSkge1xuICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZS5zb3VyY2VFdmVudC50YXJnZXRUb3VjaGVzLml0ZW0oMCkgPz8geyBjbGllbnRYOiBJbmZpbml0eSwgY2xpZW50WTogSW5maW5pdHkgfTtcbiAgICB0aGlzLnRvdWNoLmRpc3RhbmNlVHJhdmVsbGVkWCA9IDA7XG4gICAgdGhpcy50b3VjaC5kaXN0YW5jZVRyYXZlbGxlZFkgPSAwO1xuICAgIHRoaXMudG91Y2guY2xpZW50WCA9IGNsaWVudFg7XG4gICAgdGhpcy50b3VjaC5jbGllbnRZID0gY2xpZW50WTtcbiAgfVxuICBvblRvdWNoTW92ZShlKSB7XG4gICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBlLnNvdXJjZUV2ZW50LnRhcmdldFRvdWNoZXMuaXRlbSgwKSA/PyB7IGNsaWVudFg6IEluZmluaXR5LCBjbGllbnRZOiBJbmZpbml0eSB9O1xuICAgIHRoaXMudG91Y2guZGlzdGFuY2VUcmF2ZWxsZWRYICs9IE1hdGguYWJzKHRoaXMudG91Y2guY2xpZW50WCAtIGNsaWVudFgpO1xuICAgIHRoaXMudG91Y2guZGlzdGFuY2VUcmF2ZWxsZWRZICs9IE1hdGguYWJzKHRoaXMudG91Y2guY2xpZW50WSAtIGNsaWVudFkpO1xuICAgIHRoaXMudG91Y2guY2xpZW50WCA9IGNsaWVudFg7XG4gICAgdGhpcy50b3VjaC5jbGllbnRZID0gY2xpZW50WTtcbiAgfVxuICBvblRvdWNoRW5kKGV2ZW50KSB7XG4gICAgZXZlbnQuc291cmNlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgIHRoaXMuZGlzcGF0Y2goZXZlbnQpO1xuICB9XG4gIG9uRGJsQ2xpY2soZXZlbnQpIHtcbiAgICB0aGlzLmRpc3BhdGNoKHsgZGV2aWNlOiBcIm1vdXNlXCIsIC4uLmV2ZW50IH0pO1xuICB9XG4gIG9uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgdGhpcy5kcmFnU3RhcnRFdmVudCA9IGV2ZW50O1xuICB9XG4gIG9uRHJhZ01vdmUoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kcmFnU3RhcnRFdmVudCAhPSBudWxsKSB7XG4gICAgICBpZiAoY2hlY2tEaXN0YW5jZVNxdWFyZWQoZXZlbnQub3JpZ2luRGVsdGFYLCBldmVudC5vcmlnaW5EZWx0YVkpKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2godGhpcy5kcmFnU3RhcnRFdmVudCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyAuLi50aGlzLmRyYWdTdGFydEV2ZW50LCB0eXBlOiBcImRyYWctbW92ZVwiIH0pO1xuICAgICAgICB0aGlzLmRyYWdTdGFydEV2ZW50ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgdGhpcy5kaXNwYXRjaChldmVudCk7XG4gICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmRldmljZSA9PT0gXCJtb3VzZVwiKSB7XG4gICAgICBjb25zdCBjbGljayA9IG1ha2VTeW50aGV0aWMoXCJtb3VzZVwiLCBcImNsaWNrXCIsIGV2ZW50KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2goY2xpY2spO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gXCJ0b3VjaGVuZFwiKSB7XG4gICAgICBpZiAoY2hlY2tEaXN0YW5jZVNxdWFyZWQodGhpcy50b3VjaC5kaXN0YW5jZVRyYXZlbGxlZFgsIHRoaXMudG91Y2guZGlzdGFuY2VUcmF2ZWxsZWRZKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjbGljayA9IG1ha2VTeW50aGV0aWMoXCJ0b3VjaFwiLCBcImNsaWNrXCIsIGV2ZW50KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2goY2xpY2spO1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGlmICh0aGlzLmxhc3RDbGlja1RpbWUgIT09IHZvaWQgMCAmJiBub3cgLSB0aGlzLmxhc3RDbGlja1RpbWUgPD0gRE9VQkxFX1RBUF9USU1FUl9NUykge1xuICAgICAgICBjb25zdCBkYmxDbGljayA9IG1ha2VTeW50aGV0aWMoZXZlbnQuZGV2aWNlLCBcImRibGNsaWNrXCIsIGV2ZW50KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaChkYmxDbGljayk7XG4gICAgICAgIHRoaXMubGFzdENsaWNrVGltZSA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdENsaWNrVGltZSA9IG5vdztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL3dpZGdldFNldC50c1xudmFyIERPTU1hbmFnZXJXaWRnZXQgPSBjbGFzcyBleHRlbmRzIE5hdGl2ZVdpZGdldCB7XG4gIGNvbnN0cnVjdG9yKGVsZW0pIHtcbiAgICBzdXBlcihlbGVtKTtcbiAgfVxuICBhZGRDaGlsZFRvRE9NKCkge1xuICB9XG4gIHJlbW92ZUNoaWxkRnJvbURPTSgpIHtcbiAgfVxufTtcbnZhciBXaWRnZXRTZXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRvbU1hbmFnZXIpIHtcbiAgICB0aGlzLnNlcmllc1dpZGdldCA9IG5ldyBET01NYW5hZ2VyV2lkZ2V0KGRvbU1hbmFnZXIuZ2V0UGFyZW50KFwic2VyaWVzLWFyZWFcIikpO1xuICAgIHRoaXMuY2hhcnRXaWRnZXQgPSBuZXcgRE9NTWFuYWdlcldpZGdldChkb21NYW5hZ2VyLmdldFBhcmVudChcImNhbnZhcy1wcm94eVwiKSk7XG4gICAgdGhpcy5jb250YWluZXJXaWRnZXQgPSBuZXcgRE9NTWFuYWdlcldpZGdldChkb21NYW5hZ2VyLmdldFBhcmVudChcImNhbnZhcy1jb250YWluZXJcIikpO1xuICAgIHRoaXMuY29udGFpbmVyV2lkZ2V0LmFkZENoaWxkKHRoaXMuY2hhcnRXaWRnZXQpO1xuICAgIHRoaXMuY2hhcnRXaWRnZXQuYWRkQ2hpbGQodGhpcy5zZXJpZXNXaWRnZXQpO1xuICAgIHRoaXMuc2VyaWVzRHJhZ0ludGVycHJldGVyID0gbmV3IERyYWdJbnRlcnByZXRlcih0aGlzLnNlcmllc1dpZGdldCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnNlcmllc0RyYWdJbnRlcnByZXRlci5kZXN0cm95KCk7XG4gICAgdGhpcy5zZXJpZXNXaWRnZXQuZGVzdHJveSgpO1xuICAgIHRoaXMuY2hhcnRXaWRnZXQuZGVzdHJveSgpO1xuICAgIHRoaXMuY29udGFpbmVyV2lkZ2V0LmRlc3Ryb3koKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC92ZWN0b3I0LnRzXG52YXIgVmVjNCA9IHtcbiAgYm90dG9tQ2VudGVyLFxuICBjZW50ZXIsXG4gIGNsb25lLFxuICBjb2xsaWRlcyxcbiAgZW5kLFxuICBmcm9tLFxuICBoZWlnaHQsXG4gIHJvdW5kOiByb3VuZDIsXG4gIHN0YXJ0LFxuICB0b3BDZW50ZXIsXG4gIG9yaWdpbixcbiAgd2lkdGhcbn07XG5mdW5jdGlvbiBzdGFydChhKSB7XG4gIHJldHVybiB7IHg6IGEueDEsIHk6IGEueTEgfTtcbn1cbmZ1bmN0aW9uIGVuZChhKSB7XG4gIHJldHVybiB7IHg6IGEueDIsIHk6IGEueTIgfTtcbn1cbmZ1bmN0aW9uIHRvcENlbnRlcihhKSB7XG4gIHJldHVybiB7IHg6IChhLngxICsgYS54MikgLyAyLCB5OiBNYXRoLm1pbihhLnkxLCBhLnkyKSB9O1xufVxuZnVuY3Rpb24gY2VudGVyKGEpIHtcbiAgcmV0dXJuIHsgeDogKGEueDEgKyBhLngyKSAvIDIsIHk6IChhLnkxICsgYS55MikgLyAyIH07XG59XG5mdW5jdGlvbiBib3R0b21DZW50ZXIoYSkge1xuICByZXR1cm4geyB4OiAoYS54MSArIGEueDIpIC8gMiwgeTogTWF0aC5tYXgoYS55MSwgYS55MikgfTtcbn1cbmZ1bmN0aW9uIHdpZHRoKGEpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEueDIgLSBhLngxKTtcbn1cbmZ1bmN0aW9uIGhlaWdodChhKSB7XG4gIHJldHVybiBNYXRoLmFicyhhLnkyIC0gYS55MSk7XG59XG5mdW5jdGlvbiByb3VuZDIoYSkge1xuICByZXR1cm4geyB4MTogTWF0aC5yb3VuZChhLngxKSwgeTE6IE1hdGgucm91bmQoYS55MSksIHgyOiBNYXRoLnJvdW5kKGEueDIpLCB5MjogTWF0aC5yb3VuZChhLnkyKSB9O1xufVxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICByZXR1cm4geyB4MTogYS54MSwgeTE6IGEueTEsIHgyOiBhLngyLCB5MjogYS55MiB9O1xufVxuZnVuY3Rpb24gY29sbGlkZXMoYSwgYikge1xuICBjb25zdCBhbiA9IG5vcm1hbGlzZShhKTtcbiAgY29uc3QgYm4gPSBub3JtYWxpc2UoYik7XG4gIHJldHVybiBhbi54MSA8PSBibi54MiAmJiBhbi54MiA+PSBibi54MSAmJiBhbi55MSA8PSBibi55MiAmJiBhbi55MiA+PSBibi55MTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZShhKSB7XG4gIHJldHVybiB7IHgxOiBNYXRoLm1pbihhLngxLCBhLngyKSwgeDI6IE1hdGgubWF4KGEueDEsIGEueDIpLCB5MTogTWF0aC5taW4oYS55MSwgYS55MiksIHkyOiBNYXRoLm1heChhLnkxLCBhLnkyKSB9O1xufVxuZnVuY3Rpb24gZnJvbShhLCBiLCBjLCBkKSB7XG4gIGlmICh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB7IHgxOiBhLCB5MTogYiwgeDI6IGMsIHkyOiBkIH07XG4gIH1cbiAgaWYgKFwid2lkdGhcIiBpbiBhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiBhLngsXG4gICAgICB5MTogYS55LFxuICAgICAgeDI6IGEueCArIGEud2lkdGgsXG4gICAgICB5MjogYS55ICsgYS5oZWlnaHRcbiAgICB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVmFsdWVzIGNhbiBub3QgYmUgY29udmVydGVkIGludG8gYSB2ZWN0b3I0OiBbJHtKU09OLnN0cmluZ2lmeShhKX1dIFske2J9XSBbJHtjfV0gWyR7ZH1dYCk7XG59XG5mdW5jdGlvbiBvcmlnaW4oKSB7XG4gIHJldHVybiB7IHgxOiAwLCB5MTogMCwgeDI6IDAsIHkyOiAwIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvcGFuVG9CQm94LnRzXG5mdW5jdGlvbiBub3JtYWxpemUyKHNjcmVlbk1pbiwgbWluLCBzY3JlZW5NYXgsIG1heCwgdGFyZ2V0KSB7XG4gIHJldHVybiBtaW4gKyAobWF4IC0gbWluKSAqICgodGFyZ2V0IC0gc2NyZWVuTWluKSAvIChzY3JlZW5NYXggLSBzY3JlZW5NaW4pKTtcbn1cbmZ1bmN0aW9uIHVubm9ybWFsaXplKHNjcmVlbk1pbiwgbWluLCBzY3JlZW5NYXgsIG1heCwgcmF0aW8yKSB7XG4gIHJldHVybiBzY3JlZW5NaW4gKyAocmF0aW8yIC0gbWluKSAqICgoc2NyZWVuTWF4IC0gc2NyZWVuTWluKSAvIChtYXggLSBtaW4pKTtcbn1cbmZ1bmN0aW9uIGNhbGNXb3JsZEF4aXModmlld3BvcnRNaW4sIHZpZXdwb3J0TWF4LCByYXRpbzIpIHtcbiAgcmV0dXJuIFtcbiAgICB1bm5vcm1hbGl6ZSh2aWV3cG9ydE1pbiwgcmF0aW8yLm1pbiwgdmlld3BvcnRNYXgsIHJhdGlvMi5tYXgsIDApLFxuICAgIHVubm9ybWFsaXplKHZpZXdwb3J0TWluLCByYXRpbzIubWluLCB2aWV3cG9ydE1heCwgcmF0aW8yLm1heCwgMSlcbiAgXTtcbn1cbmZ1bmN0aW9uIGNhbGNXb3JsZFZlYzQodmlld3BvcnQsIHJhdGlvWCwgcmF0aW9ZKSB7XG4gIGNvbnN0IFt4MSwgeDJdID0gY2FsY1dvcmxkQXhpcyh2aWV3cG9ydC54MSwgdmlld3BvcnQueDIsIHJhdGlvWCk7XG4gIGNvbnN0IFt5MSwgeTJdID0gY2FsY1dvcmxkQXhpcyh2aWV3cG9ydC55MSwgdmlld3BvcnQueTIsIHJhdGlvWSk7XG4gIHJldHVybiB7IHgxLCB4MiwgeTEsIHkyIH07XG59XG5mdW5jdGlvbiBwYW5BeGVzVW5ub3JtYWxpemVkKHdvcmxkTWluLCB3b3JsZE1heCwgdmlld3BvcnRNaW4sIHZpZXdwb3J0TWF4LCB0YXJnZXRNaW4sIHRhcmdldE1heCkge1xuICBpZiAodmlld3BvcnRNaW4gPD0gdGFyZ2V0TWluICYmIHRhcmdldE1heCA8PSB2aWV3cG9ydE1heClcbiAgICByZXR1cm4gdmlld3BvcnRNaW47XG4gIGNvbnN0IG1pbkRpZmYgPSB0YXJnZXRNaW4gLSB2aWV3cG9ydE1pbjtcbiAgY29uc3QgbWF4RGlmZiA9IHRhcmdldE1heCAtIHZpZXdwb3J0TWF4O1xuICBjb25zdCBkaWZmMiA9IE1hdGguYWJzKG1pbkRpZmYpIDwgTWF0aC5hYnMobWF4RGlmZikgPyBtaW5EaWZmIDogbWF4RGlmZjtcbiAgcmV0dXJuIGNsYW1wKHdvcmxkTWluLCB2aWV3cG9ydE1pbiArIGRpZmYyLCB3b3JsZE1heCk7XG59XG5mdW5jdGlvbiBjYWxjUGFuVG9CQm94UmF0aW9zKHZpZXdwb3J0QkJveCwgcmF0aW9zLCB0YXJnZXRCQm94KSB7XG4gIGNvbnN0IHsgeDogcmF0aW9YID0geyBtaW46IDAsIG1heDogMSB9LCB5OiByYXRpb1kgPSB7IG1pbjogMCwgbWF4OiAxIH0gfSA9IHJhdGlvcztcbiAgY29uc3QgdGFyZ2V0ID0gVmVjNC5mcm9tKHRhcmdldEJCb3gpO1xuICBjb25zdCB2aWV3cG9ydCA9IFZlYzQuZnJvbSh2aWV3cG9ydEJCb3gpO1xuICBjb25zdCB3b3JsZCA9IGNhbGNXb3JsZFZlYzQodmlld3BvcnQsIHJhdGlvWCwgcmF0aW9ZKTtcbiAgY29uc3QgeCA9IHBhbkF4ZXNVbm5vcm1hbGl6ZWQod29ybGQueDEsIHdvcmxkLngyLCB2aWV3cG9ydC54MSwgdmlld3BvcnQueDIsIHRhcmdldC54MSwgdGFyZ2V0LngyKTtcbiAgY29uc3QgeSA9IHBhbkF4ZXNVbm5vcm1hbGl6ZWQod29ybGQueTEsIHdvcmxkLnkyLCB2aWV3cG9ydC55MSwgdmlld3BvcnQueTIsIHRhcmdldC55MSwgdGFyZ2V0LnkyKTtcbiAgcmV0dXJuIHtcbiAgICB4OiB7XG4gICAgICBtaW46IG5vcm1hbGl6ZTIodmlld3BvcnQueDEsIHJhdGlvWC5taW4sIHZpZXdwb3J0LngyLCByYXRpb1gubWF4LCB4KSxcbiAgICAgIG1heDogbm9ybWFsaXplMih2aWV3cG9ydC54MSwgcmF0aW9YLm1pbiwgdmlld3BvcnQueDIsIHJhdGlvWC5tYXgsIHggKyB2aWV3cG9ydEJCb3gud2lkdGgpXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICBtaW46IG5vcm1hbGl6ZTIodmlld3BvcnQueTEsIHJhdGlvWS5taW4sIHZpZXdwb3J0LnkyLCByYXRpb1kubWF4LCB5KSxcbiAgICAgIG1heDogbm9ybWFsaXplMih2aWV3cG9ydC55MSwgcmF0aW9ZLm1pbiwgdmlld3BvcnQueTIsIHJhdGlvWS5tYXgsIHkgKyB2aWV3cG9ydEJCb3guaGVpZ2h0KVxuICAgIH1cbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vem9vbU1hbmFnZXIudHNcbnZhciBleHBlY3RlZE1lbWVudG9LZXlzID0gW1wicmFuZ2VYXCIsIFwicmFuZ2VZXCIsIFwicmF0aW9YXCIsIFwicmF0aW9ZXCIsIFwiYXV0b1NjYWxlZEF4ZXNcIl07XG52YXIgWm9vbU1hbmFnZXJBdXRvU2NhbGVBeGlzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBhZGRpbmcgPSAwO1xuICAgIHRoaXMubWFudWFsbHlBZGp1c3RlZCA9IGZhbHNlO1xuICB9XG59O1xudmFyIHJhbmdlVmFsaWRhdG9yID0gKGF4aXMpID0+IGF0dGFjaERlc2NyaXB0aW9uKCh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICBpZiAoIUNvbnRpbnVvdXNTY2FsZS5pcyhheGlzPy5zY2FsZSkgJiYgIU9yZGluYWxUaW1lU2NhbGUuaXMoYXhpcz8uc2NhbGUpKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBjb250ZXh0LmVuZCA9PSBudWxsKVxuICAgIHJldHVybiB0cnVlO1xuICByZXR1cm4gdmFsdWUgPD0gY29udGV4dC5lbmQ7XG59LCBgdG8gYmUgbGVzcyB0aGFuIGVuZGApO1xudmFyIFpvb21NYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGZpcmVDaGFydEV2ZW50LCBsYXlvdXRNYW5hZ2VyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmZpcmVDaGFydEV2ZW50ID0gZmlyZUNoYXJ0RXZlbnQ7XG4gICAgdGhpcy5tZW1lbnRvT3JpZ2luYXRvcktleSA9IFwiem9vbVwiO1xuICAgIHRoaXMuYXhpc1pvb21NYW5hZ2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5zdGF0ZSA9IG5ldyBTdGF0ZVRyYWNrZXIodm9pZCAwLCBcImluaXRpYWxcIik7XG4gICAgdGhpcy5heGVzID0gW107XG4gICAgdGhpcy5kaWRMYXlvdXRBeGVzID0gZmFsc2U7XG4gICAgdGhpcy5hdXRvU2NhbGVZQXhpcyA9IG5ldyBab29tTWFuYWdlckF1dG9TY2FsZUF4aXMoKTtcbiAgICB0aGlzLmxhc3RSZXN0b3JlZFN0YXRlID0gdm9pZCAwO1xuICAgIHRoaXMuaW5kZXBlbmRlbnRBeGVzID0gZmFsc2U7XG4gICAgdGhpcy5uYXZpZ2F0b3JNb2R1bGUgPSBmYWxzZTtcbiAgICB0aGlzLnpvb21Nb2R1bGUgPSBmYWxzZTtcbiAgICAvLyBUaGUgaW5pdGlhbCBzdGF0ZSBtZW1lbnRvIGNhbiBub3QgYmUgcmVzdG9yZWQgdW50aWwgdGhlIGNoYXJ0IGhhcyBwZXJmb3JtZWQgaXRzIGZpcnN0IGxheW91dC4gSW5zdGVhZCBzYXZlIGl0IGFzXG4gICAgLy8gcGVuZGluZyBhbmQgcmVzdG9yZSB0aGVuIGRlbGV0ZSBpdCBvbiB0aGUgZmlyc3QgbGF5b3V0LlxuICAgIHRoaXMucGVuZGluZ01lbWVudG8gPSB2b2lkIDA7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICBsYXlvdXRNYW5hZ2VyLmFkZExpc3RlbmVyKFwibGF5b3V0OmNvbXBsZXRlXCIsICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBwZW5kaW5nTWVtZW50byB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2hvdWxkUGVyZm9ybUluaXRpYWxMYXlvdXQgPSAhdGhpcy5kaWRMYXlvdXRBeGVzO1xuICAgICAgICB0aGlzLmRpZExheW91dEF4ZXMgPSB0cnVlO1xuICAgICAgICBpZiAocGVuZGluZ01lbWVudG8pIHtcbiAgICAgICAgICB0aGlzLnJlc3RvcmVNZW1lbnRvKHBlbmRpbmdNZW1lbnRvLnZlcnNpb24sIHBlbmRpbmdNZW1lbnRvLm1lbWVudG9WZXJzaW9uLCBwZW5kaW5nTWVtZW50by5tZW1lbnRvKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaG91bGRQZXJmb3JtSW5pdGlhbExheW91dCkge1xuICAgICAgICAgIHRoaXMuYXV0b1NjYWxlWVpvb20oXCJ6b29tLW1hbmFnZXJcIik7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBjcmVhdGVNZW1lbnRvKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1lbWVudG9SYW5nZXMoKTtcbiAgfVxuICBndWFyZE1lbWVudG8oYmxvYiwgbWVzc2FnZXMpIHtcbiAgICBpZiAoYmxvYiA9PSBudWxsKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFpc09iamVjdChibG9iKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhibG9iKSkge1xuICAgICAgaWYgKCFleHBlY3RlZE1lbWVudG9LZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcmltYXJ5WCA9IHRoaXMuZ2V0UHJpbWFyeUF4aXMoXCJ4XCIgLyogWCAqLyk7XG4gICAgY29uc3QgcHJpbWFyeVkgPSB0aGlzLmdldFByaW1hcnlBeGlzKFwieVwiIC8qIFkgKi8pO1xuICAgIGNvbnN0IHpvb21NZW1lbnRvRGVmcyA9IHtcbiAgICAgIHJhbmdlWDogeyBzdGFydDogYW5kKG9yKG51bWJlciwgZGF0ZSksIHJhbmdlVmFsaWRhdG9yKHByaW1hcnlYKSksIGVuZDogb3IobnVtYmVyLCBkYXRlKSB9LFxuICAgICAgcmFuZ2VZOiB7IHN0YXJ0OiBhbmQob3IobnVtYmVyLCBkYXRlKSwgcmFuZ2VWYWxpZGF0b3IocHJpbWFyeVkpKSwgZW5kOiBvcihudW1iZXIsIGRhdGUpIH0sXG4gICAgICByYXRpb1g6IHsgc3RhcnQ6IGFuZChyYXRpbywgbGVzc1RoYW4oXCJlbmRcIikpLCBlbmQ6IHJhdGlvIH0sXG4gICAgICByYXRpb1k6IHsgc3RhcnQ6IGFuZChyYXRpbywgbGVzc1RoYW4oXCJlbmRcIikpLCBlbmQ6IHJhdGlvIH0sXG4gICAgICBhdXRvU2NhbGVkQXhlczogYXJyYXlPZih1bmlvbihcInlcIikpXG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZShibG9iLCB6b29tTWVtZW50b0RlZnMpO1xuICAgIGlmIChyZXN1bHQuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goLi4ucmVzdWx0LmVycm9ycy5tYXAoKGUpID0+IGUubWVzc2FnZSkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXN0b3JlTWVtZW50byh2ZXJzaW9uLCBtZW1lbnRvVmVyc2lvbiwgbWVtZW50bykge1xuICAgIGNvbnN0IHsgaW5kZXBlbmRlbnRBeGVzIH0gPSB0aGlzO1xuICAgIGlmICghdGhpcy5heGVzIHx8ICF0aGlzLmRpZExheW91dEF4ZXMpIHtcbiAgICAgIHRoaXMucGVuZGluZ01lbWVudG8gPSB7IHZlcnNpb24sIG1lbWVudG9WZXJzaW9uLCBtZW1lbnRvIH07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ01lbWVudG8gPSB2b2lkIDA7XG4gICAgY29uc3Qgem9vbSA9IHRoaXMuZ2V0RGVmaW5lZFpvb20oKTtcbiAgICBpZiAobWVtZW50bz8ucmFuZ2VYKSB7XG4gICAgICB6b29tLnggPSB0aGlzLnJhbmdlVG9SYXRpbyhtZW1lbnRvLnJhbmdlWCwgXCJ4XCIgLyogWCAqLykgPz8geyBtaW46IDAsIG1heDogMSB9O1xuICAgIH0gZWxzZSBpZiAobWVtZW50bz8ucmF0aW9YKSB7XG4gICAgICB6b29tLnggPSB7XG4gICAgICAgIG1pbjogbWVtZW50by5yYXRpb1guc3RhcnQgPz8gMCxcbiAgICAgICAgbWF4OiBtZW1lbnRvLnJhdGlvWC5lbmQgPz8gMVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgem9vbS54ID0geyBtaW46IDAsIG1heDogMSB9O1xuICAgIH1cbiAgICBpZiAoIXRoaXMubmF2aWdhdG9yTW9kdWxlIHx8IHRoaXMuem9vbU1vZHVsZSkge1xuICAgICAgbGV0IHlBdXRvU2NhbGUgPSBtZW1lbnRvPy5hdXRvU2NhbGVkQXhlcz8uaW5jbHVkZXMoXCJ5XCIpO1xuICAgICAgaWYgKG1lbWVudG8/LnJhbmdlWSkge1xuICAgICAgICB6b29tLnkgPSB0aGlzLnJhbmdlVG9SYXRpbyhtZW1lbnRvLnJhbmdlWSwgXCJ5XCIgLyogWSAqLykgPz8geyBtaW46IDAsIG1heDogMSB9O1xuICAgICAgICB5QXV0b1NjYWxlID8/ICh5QXV0b1NjYWxlID0gZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmIChtZW1lbnRvPy5yYXRpb1kpIHtcbiAgICAgICAgem9vbS55ID0ge1xuICAgICAgICAgIG1pbjogbWVtZW50by5yYXRpb1kuc3RhcnQgPz8gMCxcbiAgICAgICAgICBtYXg6IG1lbWVudG8ucmF0aW9ZLmVuZCA/PyAxXG4gICAgICAgIH07XG4gICAgICAgIHlBdXRvU2NhbGUgPz8gKHlBdXRvU2NhbGUgPSBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB6b29tLnkgPSB7IG1pbjogMCwgbWF4OiAxIH07XG4gICAgICAgIHlBdXRvU2NhbGUgPz8gKHlBdXRvU2NhbGUgPSB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHpvb20uYXV0b1NjYWxlWUF4aXMgPSB5QXV0b1NjYWxlO1xuICAgIH1cbiAgICB0aGlzLmxhc3RSZXN0b3JlZFN0YXRlID0gem9vbTtcbiAgICBpZiAoaW5kZXBlbmRlbnRBeGVzICE9PSB0cnVlKSB7XG4gICAgICB0aGlzLnVwZGF0ZVpvb20oXCJ6b29tLW1hbmFnZXJcIiwgem9vbSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByaW1hcnlYID0gdGhpcy5nZXRQcmltYXJ5QXhpcyhcInhcIiAvKiBYICovKTtcbiAgICBjb25zdCBwcmltYXJ5WSA9IHRoaXMuZ2V0UHJpbWFyeUF4aXMoXCJ5XCIgLyogWSAqLyk7XG4gICAgZm9yIChjb25zdCBheGlzIG9mIFtwcmltYXJ5WCwgcHJpbWFyeVldKSB7XG4gICAgICBpZiAoIWF4aXMpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdGhpcy51cGRhdGVBeGlzWm9vbShcInpvb20tbWFuYWdlclwiLCBheGlzLmlkLCB6b29tW2F4aXMuZGlyZWN0aW9uXSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUF4ZXMoYXhlcykge1xuICAgIHRoaXMuYXhlcyA9IGF4ZXM7XG4gICAgY29uc3Qgem9vbU1hbmFnZXJzID0gbmV3IE1hcChheGVzLm1hcCgoYXhpcykgPT4gW2F4aXMuaWQsIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5nZXQoYXhpcy5pZCldKSk7XG4gICAgdGhpcy5heGlzWm9vbU1hbmFnZXJzLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBheGlzIG9mIGF4ZXMpIHtcbiAgICAgIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5zZXQoYXhpcy5pZCwgem9vbU1hbmFnZXJzLmdldChheGlzLmlkKSA/PyBuZXcgQXhpc1pvb21NYW5hZ2VyKGF4aXMpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUuc2l6ZSA+IDAgJiYgYXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnVwZGF0ZVpvb20odGhpcy5zdGF0ZS5zdGF0ZUlkKCksIHRoaXMuc3RhdGUuc3RhdGVWYWx1ZSgpKTtcbiAgICB9XG4gIH1cbiAgc2V0SW5kZXBlbmRlbnRBeGVzKGluZGVwZW5kZW50ID0gdHJ1ZSkge1xuICAgIHRoaXMuaW5kZXBlbmRlbnRBeGVzID0gaW5kZXBlbmRlbnQ7XG4gIH1cbiAgc2V0QXV0b1NjYWxlWUF4aXMoZW5hYmxlZCwgcGFkZGluZykge1xuICAgIHRoaXMuYXV0b1NjYWxlWUF4aXMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgdGhpcy5hdXRvU2NhbGVZQXhpcy5wYWRkaW5nID0gcGFkZGluZztcbiAgfVxuICBzZXROYXZpZ2F0b3JFbmFibGVkKGVuYWJsZWQgPSB0cnVlKSB7XG4gICAgdGhpcy5uYXZpZ2F0b3JNb2R1bGUgPSBlbmFibGVkO1xuICB9XG4gIHNldFpvb21Nb2R1bGVFbmFibGVkKGVuYWJsZWQgPSB0cnVlKSB7XG4gICAgdGhpcy56b29tTW9kdWxlID0gZW5hYmxlZDtcbiAgfVxuICBpc1pvb21FbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnpvb21Nb2R1bGU7XG4gIH1cbiAgdXBkYXRlWm9vbShjYWxsZXJJZCwgbmV3Wm9vbSkge1xuICAgIGlmIChuZXdab29tPy54ICYmIChuZXdab29tLngubWluIDwgMCB8fCBuZXdab29tLngubWF4ID4gMSkpIHtcbiAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKFxuICAgICAgICBgQXR0ZW1wdGVkIHRvIHVwZGF0ZSB4LWF4aXMgem9vbSB0byBhbiBpbnZhbGlkIHJhdGlvIG9mIFt7IG1pbjogJHtuZXdab29tLngubWlufSwgbWF4OiAke25ld1pvb20ueC5tYXh9IH1dLCBleHBlY3RpbmcgYSByYXRpbyBvZiAwIHRvIDEsIGlnbm9yaW5nLmBcbiAgICAgICk7XG4gICAgICBuZXdab29tLnggPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChuZXdab29tPy55ICYmIChuZXdab29tLnkubWluIDwgMCB8fCBuZXdab29tLnkubWF4ID4gMSkpIHtcbiAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKFxuICAgICAgICBgQXR0ZW1wdGVkIHRvIHVwZGF0ZSB5LWF4aXMgem9vbSB0byBhbiBpbnZhbGlkIHJhdGlvIG9mIFt7IG1pbjogJHtuZXdab29tLnkubWlufSwgbWF4OiAke25ld1pvb20ueS5tYXh9IH1dLCBleHBlY3RpbmcgYSByYXRpbyBvZiAwIHRvIDEsIGlnbm9yaW5nLmBcbiAgICAgICk7XG4gICAgICBuZXdab29tLnkgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh0aGlzLmF4aXNab29tTWFuYWdlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgY29uc3Qgc3RhdGVJZCA9IHRoaXMuc3RhdGUuc3RhdGVJZCgpO1xuICAgICAgaWYgKHN0YXRlSWQgPT09IFwiaW5pdGlhbFwiIHx8IHN0YXRlSWQgPT09IGNhbGxlcklkKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0KGNhbGxlcklkLCBuZXdab29tKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5zZXQoY2FsbGVySWQsIG5ld1pvb20pO1xuICAgIGNvbnN0IGF1dG9TY2FsZVlBeGlzID0gbmV3Wm9vbT8uYXV0b1NjYWxlWUF4aXM7XG4gICAgaWYgKGF1dG9TY2FsZVlBeGlzICE9IG51bGwpIHtcbiAgICAgIHRoaXMuYXV0b1NjYWxlWUF4aXMubWFudWFsbHlBZGp1c3RlZCA9ICFhdXRvU2NhbGVZQXhpcztcbiAgICB9XG4gICAgdGhpcy5heGlzWm9vbU1hbmFnZXJzLmZvckVhY2goKGF4aXMpID0+IHtcbiAgICAgIGF4aXMudXBkYXRlWm9vbShjYWxsZXJJZCwgbmV3Wm9vbT8uW2F4aXMuZ2V0RGlyZWN0aW9uKCldKTtcbiAgICB9KTtcbiAgICB0aGlzLmFwcGx5Q2hhbmdlcyhjYWxsZXJJZCk7XG4gIH1cbiAgdXBkYXRlQXhpc1pvb20oY2FsbGVySWQsIGF4aXNJZCwgbmV3Wm9vbSkge1xuICAgIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5nZXQoYXhpc0lkKT8udXBkYXRlWm9vbShjYWxsZXJJZCwgbmV3Wm9vbSk7XG4gICAgdGhpcy5hcHBseUNoYW5nZXMoY2FsbGVySWQpO1xuICB9XG4gIHJlc2V0Wm9vbShjYWxsZXJJZCkge1xuICAgIHRoaXMuYXV0b1NjYWxlWUF4aXMubWFudWFsbHlBZGp1c3RlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHpvb20gPSB0aGlzLmdldFJlc3RvcmVkWm9vbSgpO1xuICAgIHRoaXMudXBkYXRlWm9vbShjYWxsZXJJZCwge1xuICAgICAgeDogeyBtaW46IHpvb20/Lng/Lm1pbiA/PyAwLCBtYXg6IHpvb20/Lng/Lm1heCA/PyAxIH0sXG4gICAgICB5OiB7IG1pbjogem9vbT8ueT8ubWluID8/IDAsIG1heDogem9vbT8ueT8ubWF4ID8/IDEgfSxcbiAgICAgIGF1dG9TY2FsZVlBeGlzOiB6b29tPy5hdXRvU2NhbGVZQXhpcyA/PyB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVzZXRBeGlzWm9vbShjYWxsZXJJZCwgYXhpc0lkKSB7XG4gICAgY29uc3QgYXhpc1pvb21NYW5hZ2VyID0gdGhpcy5heGlzWm9vbU1hbmFnZXJzLmdldChheGlzSWQpO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGF4aXNab29tTWFuYWdlcj8uZ2V0RGlyZWN0aW9uKCk7XG4gICAgaWYgKGRpcmVjdGlvbiA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJlc3RvcmVkWm9vbSA9IHRoaXMuZ2V0UmVzdG9yZWRab29tKCk7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLykge1xuICAgICAgY29uc3QgYXV0b1NjYWxlWUF4aXMgPSByZXN0b3JlZFpvb20/LmF1dG9TY2FsZVlBeGlzID8/IHRydWU7XG4gICAgICB0aGlzLmF1dG9TY2FsZVlBeGlzLm1hbnVhbGx5QWRqdXN0ZWQgPSAhYXV0b1NjYWxlWUF4aXM7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlQXhpc1pvb20oY2FsbGVySWQsIGF4aXNJZCwgcmVzdG9yZWRab29tPy5bZGlyZWN0aW9uXSA/PyB7IG1pbjogMCwgbWF4OiAxIH0pO1xuICB9XG4gIHNldEF4aXNNYW51YWxseUFkanVzdGVkKF9jYWxsZXJJZCwgYXhpc0lkKSB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5heGlzWm9vbU1hbmFnZXJzLmdldChheGlzSWQpPy5nZXREaXJlY3Rpb24oKTtcbiAgICBpZiAoZGlyZWN0aW9uICE9PSBcInlcIiAvKiBZICovKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuYXV0b1NjYWxlWUF4aXMubWFudWFsbHlBZGp1c3RlZCA9IHRydWU7XG4gIH1cbiAgdXBkYXRlUHJpbWFyeUF4aXNab29tKGNhbGxlcklkLCBkaXJlY3Rpb24sIG5ld1pvb20pIHtcbiAgICBjb25zdCBwcmltYXJ5QXhpcyA9IHRoaXMuZ2V0UHJpbWFyeUF4aXMoZGlyZWN0aW9uKTtcbiAgICBpZiAoIXByaW1hcnlBeGlzKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMudXBkYXRlQXhpc1pvb20oY2FsbGVySWQsIHByaW1hcnlBeGlzLmlkLCBuZXdab29tKTtcbiAgfVxuICBwYW5Ub0JCb3goY2FsbGVySWQsIHNlcmllc1JlY3QsIHRhcmdldCkge1xuICAgIGlmICghdGhpcy5pc1pvb21FbmFibGVkKCkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgem9vbSA9IHRoaXMuZ2V0Wm9vbSgpO1xuICAgIGlmICh6b29tID09PSB2b2lkIDAgfHwgIXpvb20ueCAmJiAhem9vbS55KVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHBhbklzUG9zc2libGUgPSBzZXJpZXNSZWN0LndpZHRoID4gMCAmJiBzZXJpZXNSZWN0LmhlaWdodCA+IDAgJiYgTWF0aC5hYnModGFyZ2V0LndpZHRoKSA8PSBNYXRoLmFicyhzZXJpZXNSZWN0LndpZHRoKSAmJiBNYXRoLmFicyh0YXJnZXQuaGVpZ2h0KSA8PSBNYXRoLmFicyhzZXJpZXNSZWN0LmhlaWdodCk7XG4gICAgaWYgKCFwYW5Jc1Bvc3NpYmxlKSB7XG4gICAgICBsb2dnZXJfZXhwb3J0cy53YXJuT25jZShgY2Fubm90IHBhbiB0byB0YXJnZXQgQkJveCAtIGNoYXJ0IHRvbyBzbWFsbD9gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbmV3Wm9vbSA9IGNhbGNQYW5Ub0JCb3hSYXRpb3Moc2VyaWVzUmVjdCwgem9vbSwgdGFyZ2V0KTtcbiAgICBpZiAodGhpcy5pbmRlcGVuZGVudEF4ZXMpIHtcbiAgICAgIHRoaXMudXBkYXRlUHJpbWFyeUF4aXNab29tKGNhbGxlcklkLCBcInhcIiAvKiBYICovLCBuZXdab29tLngpO1xuICAgICAgdGhpcy51cGRhdGVQcmltYXJ5QXhpc1pvb20oY2FsbGVySWQsIFwieVwiIC8qIFkgKi8sIG5ld1pvb20ueSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlWm9vbShjYWxsZXJJZCwgbmV3Wm9vbSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIEZpcmUgdGhpcyBldmVudCB0byBzaWduYWwgdG8gbGlzdGVuZXJzIHRoYXQgdGhlIHZpZXcgaXMgY2hhbmdpbmcgdGhyb3VnaCBhIHpvb20gYW5kL29yIHBhbiBjaGFuZ2UuXG4gIGZpcmVab29tUGFuU3RhcnRFdmVudChjYWxsZXJJZCkge1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiem9vbS1wYW4tc3RhcnRcIiwgeyB0eXBlOiBcInpvb20tcGFuLXN0YXJ0XCIsIGNhbGxlcklkIH0pO1xuICB9XG4gIGV4dGVuZFRvRW5kKGNhbGxlcklkLCBkaXJlY3Rpb24sIGV4dGVudDIpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmRXaXRoKGNhbGxlcklkLCBkaXJlY3Rpb24sIChlbmQyKSA9PiBOdW1iZXIoZW5kMikgLSBleHRlbnQyKTtcbiAgfVxuICBleHRlbmRXaXRoKGNhbGxlcklkLCBkaXJlY3Rpb24sIGZuKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuZ2V0UHJpbWFyeUF4aXMoZGlyZWN0aW9uKTtcbiAgICBpZiAoIWF4aXMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZXh0ZW50cyA9IHRoaXMuZ2V0RG9tYWluRXh0ZW50cyhheGlzKTtcbiAgICBpZiAoIWV4dGVudHMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgWywgZW5kMl0gPSBleHRlbnRzO1xuICAgIGNvbnN0IHN0YXJ0MiA9IGZuKGVuZDIpO1xuICAgIGNvbnN0IHJhdGlvMiA9IHRoaXMucmFuZ2VUb1JhdGlvKHsgc3RhcnQ6IHN0YXJ0MiwgZW5kOiBlbmQyIH0sIGRpcmVjdGlvbik7XG4gICAgaWYgKCFyYXRpbzIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy51cGRhdGVab29tKGNhbGxlcklkLCB7IFtkaXJlY3Rpb25dOiByYXRpbzIgfSk7XG4gIH1cbiAgdXBkYXRlV2l0aChjYWxsZXJJZCwgZGlyZWN0aW9uLCBmbikge1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmdldFByaW1hcnlBeGlzKGRpcmVjdGlvbik7XG4gICAgaWYgKCFheGlzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGV4dGVudHMgPSB0aGlzLmdldERvbWFpbkV4dGVudHMoYXhpcyk7XG4gICAgaWYgKCFleHRlbnRzKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBbc3RhcnQyLCBlbmQyXSA9IGV4dGVudHM7XG4gICAgW3N0YXJ0MiwgZW5kMl0gPSBmbihzdGFydDIsIGVuZDIpO1xuICAgIGNvbnN0IHJhdGlvMiA9IHRoaXMucmFuZ2VUb1JhdGlvKHsgc3RhcnQ6IHN0YXJ0MiwgZW5kOiBlbmQyIH0sIGRpcmVjdGlvbik7XG4gICAgaWYgKCFyYXRpbzIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy51cGRhdGVab29tKGNhbGxlcklkLCB7IFtkaXJlY3Rpb25dOiByYXRpbzIgfSk7XG4gIH1cbiAgZ2V0Wm9vbSgpIHtcbiAgICBsZXQgeDtcbiAgICBsZXQgeTtcbiAgICB0aGlzLmF4aXNab29tTWFuYWdlcnMuZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgICAgaWYgKGF4aXMuZ2V0RGlyZWN0aW9uKCkgPT09IFwieFwiIC8qIFggKi8pIHtcbiAgICAgICAgeCA/PyAoeCA9IGF4aXMuZ2V0Wm9vbSgpKTtcbiAgICAgIH0gZWxzZSBpZiAoYXhpcy5nZXREaXJlY3Rpb24oKSA9PT0gXCJ5XCIgLyogWSAqLykge1xuICAgICAgICB5ID8/ICh5ID0gYXhpcy5nZXRab29tKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh4IHx8IHkpIHtcbiAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9XG4gIH1cbiAgZ2V0QXhpc1pvb20oYXhpc0lkKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5nZXQoYXhpc0lkKT8uZ2V0Wm9vbSgpID8/IHsgbWluOiAwLCBtYXg6IDEgfTtcbiAgfVxuICBnZXRBeGlzWm9vbXMoKSB7XG4gICAgY29uc3QgYXhlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2F4aXNJZCwgYXhpc10gb2YgdGhpcy5heGlzWm9vbU1hbmFnZXJzLmVudHJpZXMoKSkge1xuICAgICAgYXhlc1theGlzSWRdID0ge1xuICAgICAgICBkaXJlY3Rpb246IGF4aXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICAgIHpvb206IGF4aXMuZ2V0Wm9vbSgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYXhlcztcbiAgfVxuICBnZXRSZXN0b3JlZFpvb20oKSB7XG4gICAgcmV0dXJuIHRoaXMubGFzdFJlc3RvcmVkU3RhdGU7XG4gIH1cbiAgZ2V0UHJpbWFyeUF4aXNJZChkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcmltYXJ5QXhpcyhkaXJlY3Rpb24pPy5pZDtcbiAgfVxuICBpc1Zpc2libGVJdGVtc0NvdW50QXRMZWFzdCh6b29tLCBtaW5WaXNpYmxlSXRlbXMpIHtcbiAgICBjb25zdCB4QXhpcyA9IHRoaXMuZ2V0UHJpbWFyeUF4aXMoXCJ4XCIgLyogWCAqLyk7XG4gICAgY29uc3QgeUF4aXMgPSB0aGlzLmdldFByaW1hcnlBeGlzKFwieVwiIC8qIFkgKi8pO1xuICAgIGNvbnN0IHByb2Nlc3NlZFNlcmllc0lkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgbGV0IHZpc2libGVJdGVtc0NvdW50ID0gMDtcbiAgICBjb25zdCB4VmlzaWJsZVJhbmdlID0gW3pvb20ueC5taW4sIHpvb20ueC5tYXhdO1xuICAgIGNvbnN0IHlWaXNpYmxlUmFuZ2UgPSBbem9vbS55Lm1pbiwgem9vbS55Lm1heF07XG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2YgeEF4aXM/LmJvdW5kU2VyaWVzID8/IFtdKSB7XG4gICAgICBwcm9jZXNzZWRTZXJpZXNJZHMuYWRkKHNlcmllcy5pZCk7XG4gICAgICBjb25zdCByZW1haW5pbmdJdGVtcyA9IG1pblZpc2libGVJdGVtcyAtICh2aXNpYmxlSXRlbXNDb3VudCA/PyAwKTtcbiAgICAgIGNvbnN0IHNlcmllc1Zpc2libGVJdGVtcyA9IHNlcmllcy5nZXRWaXNpYmxlSXRlbXMoeFZpc2libGVSYW5nZSwgeVZpc2libGVSYW5nZSwgcmVtYWluaW5nSXRlbXMpO1xuICAgICAgdmlzaWJsZUl0ZW1zQ291bnQgKz0gc2VyaWVzVmlzaWJsZUl0ZW1zO1xuICAgICAgaWYgKHZpc2libGVJdGVtc0NvdW50ID49IG1pblZpc2libGVJdGVtcylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIHlBeGlzPy5ib3VuZFNlcmllcyA/PyBbXSkge1xuICAgICAgaWYgKHByb2Nlc3NlZFNlcmllc0lkcy5oYXMoc2VyaWVzLmlkKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCByZW1haW5pbmdJdGVtcyA9IG1pblZpc2libGVJdGVtcyAtICh2aXNpYmxlSXRlbXNDb3VudCA/PyAwKTtcbiAgICAgIGNvbnN0IHNlcmllc1Zpc2libGVJdGVtcyA9IHNlcmllcy5nZXRWaXNpYmxlSXRlbXMoeFZpc2libGVSYW5nZSwgeVZpc2libGVSYW5nZSwgcmVtYWluaW5nSXRlbXMpO1xuICAgICAgdmlzaWJsZUl0ZW1zQ291bnQgKz0gc2VyaWVzVmlzaWJsZUl0ZW1zO1xuICAgICAgaWYgKHZpc2libGVJdGVtc0NvdW50ID49IG1pblZpc2libGVJdGVtcylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzZWRTZXJpZXNJZHMuc2l6ZSA9PT0gMDtcbiAgfVxuICBnZXRNZW1lbnRvUmFuZ2VzKCkge1xuICAgIGNvbnN0IHpvb20gPSB0aGlzLmdldERlZmluZWRab29tKCk7XG4gICAgbGV0IGF1dG9TY2FsZWRBeGVzO1xuICAgIGlmICh0aGlzLmF1dG9TY2FsZVlBeGlzLmVuYWJsZWQpIHtcbiAgICAgIGF1dG9TY2FsZWRBeGVzID0gdGhpcy5hdXRvU2NhbGVZQXhpcy5tYW51YWxseUFkanVzdGVkID8gW10gOiBbXCJ5XCJdO1xuICAgIH1cbiAgICBjb25zdCBtZW1lbnRvID0ge1xuICAgICAgcmFuZ2VYOiB0aGlzLmdldFJhbmdlRGlyZWN0aW9uKHpvb20ueCwgXCJ4XCIgLyogWCAqLyksXG4gICAgICByYW5nZVk6IHRoaXMuZ2V0UmFuZ2VEaXJlY3Rpb24oem9vbS55LCBcInlcIiAvKiBZICovKSxcbiAgICAgIHJhdGlvWDogeyBzdGFydDogem9vbS54Lm1pbiwgZW5kOiB6b29tLngubWF4IH0sXG4gICAgICByYXRpb1k6IHsgc3RhcnQ6IHpvb20ueS5taW4sIGVuZDogem9vbS55Lm1heCB9LFxuICAgICAgYXV0b1NjYWxlZEF4ZXNcbiAgICB9O1xuICAgIHJldHVybiBtZW1lbnRvO1xuICB9XG4gIGF1dG9TY2FsZVlab29tKGNhbGxlcklkLCBhcHBseUNoYW5nZXMgPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLmlzWm9vbUVuYWJsZWQoKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGluZGVwZW5kZW50QXhlcywgYXV0b1NjYWxlWUF4aXMgfSA9IHRoaXM7XG4gICAgY29uc3Qgem9vbSA9IHRoaXMuZ2V0Wm9vbSgpO1xuICAgIGlmICh6b29tPy54ID09IG51bGwgfHwgIWF1dG9TY2FsZVlBeGlzLmVuYWJsZWQgfHwgYXV0b1NjYWxlWUF4aXMubWFudWFsbHlBZGp1c3RlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHBhZGRpbmcgfSA9IGF1dG9TY2FsZVlBeGlzO1xuICAgIGxldCB6b29tWTtcbiAgICBpZiAoem9vbS54Py5taW4gPT09IDAgJiYgem9vbS54Py5tYXggPT09IDEpIHtcbiAgICAgIHpvb21ZID0geyBtaW46IDAsIG1heDogMSB9O1xuICAgIH0gZWxzZSBpZiAoaW5kZXBlbmRlbnRBeGVzKSB7XG4gICAgICB6b29tWSA9IHRoaXMucHJpbWFyeUF4aXNab29tKFwieVwiIC8qIFkgKi8sIHpvb20ueCwgeyBwYWRkaW5nIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB6b29tWSA9IHRoaXMuY29tYmluZWRBeGlzWm9vbShcInlcIiAvKiBZICovLCB6b29tLngsIHsgcGFkZGluZyB9KTtcbiAgICB9XG4gICAgaWYgKHpvb21ZID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGluZGVwZW5kZW50QXhlcykge1xuICAgICAgY29uc3QgcHJpbWFyeUF4aXMgPSB0aGlzLmdldFByaW1hcnlBeGlzKFwieVwiIC8qIFkgKi8pO1xuICAgICAgY29uc3QgcHJpbWFyeUF4aXNNYW5hZ2VyID0gcHJpbWFyeUF4aXMgPT0gbnVsbCA/IHZvaWQgMCA6IHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5nZXQocHJpbWFyeUF4aXMuaWQpO1xuICAgICAgcHJpbWFyeUF4aXNNYW5hZ2VyPy51cGRhdGVab29tKFwiem9vbS1tYW5hZ2VyXCIsIHpvb21ZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBheGlzWm9vbU1hbmFnZXIgb2YgdGhpcy5heGlzWm9vbU1hbmFnZXJzLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChheGlzWm9vbU1hbmFnZXIuZ2V0RGlyZWN0aW9uKCkgPT09IFwieVwiIC8qIFkgKi8pIHtcbiAgICAgICAgICBheGlzWm9vbU1hbmFnZXIudXBkYXRlWm9vbShcInpvb20tbWFuYWdlclwiLCB6b29tWSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFwcGx5Q2hhbmdlcykge1xuICAgICAgdGhpcy5hcHBseUNoYW5nZXMoY2FsbGVySWQpO1xuICAgIH1cbiAgfVxuICBhcHBseUNoYW5nZXMoY2FsbGVySWQpIHtcbiAgICB0aGlzLmF1dG9TY2FsZVlab29tKGNhbGxlcklkLCBmYWxzZSk7XG4gICAgY29uc3QgY2hhbmdlZCA9IEFycmF5LmZyb20odGhpcy5heGlzWm9vbU1hbmFnZXJzLnZhbHVlcygpLCAoYXhpcykgPT4gYXhpcy5hcHBseUNoYW5nZXMoKSkuaW5jbHVkZXModHJ1ZSk7XG4gICAgaWYgKCFjaGFuZ2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF4ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtheGlzSWQsIGF4aXNdIG9mIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5lbnRyaWVzKCkpIHtcbiAgICAgIGF4ZXNbYXhpc0lkXSA9IGF4aXMuZ2V0Wm9vbSgpO1xuICAgIH1cbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcInpvb20tY2hhbmdlXCIsIHsgdHlwZTogXCJ6b29tLWNoYW5nZVwiLCAuLi50aGlzLmdldFpvb20oKSwgYXhlcywgY2FsbGVySWQgfSk7XG4gICAgdGhpcy5maXJlQ2hhcnRFdmVudCh7IHR5cGU6IFwiem9vbVwiLCAuLi50aGlzLmdldE1lbWVudG9SYW5nZXMoKSB9KTtcbiAgfVxuICBnZXRSYW5nZURpcmVjdGlvbihyYXRpbzIsIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmdldFByaW1hcnlBeGlzKGRpcmVjdGlvbik7XG4gICAgaWYgKCFheGlzIHx8ICFDb250aW51b3VzU2NhbGUuaXMoYXhpcy5zY2FsZSkgJiYgIU9yZGluYWxUaW1lU2NhbGUuaXMoYXhpcy5zY2FsZSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZXh0ZW50cyA9IHRoaXMuZ2V0RG9tYWluUGl4ZWxFeHRlbnRzKGF4aXMpO1xuICAgIGlmICghZXh0ZW50cylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbZDAsIGQxXSA9IGV4dGVudHM7XG4gICAgbGV0IHN0YXJ0MjtcbiAgICBsZXQgZW5kMjtcbiAgICBpZiAoZDAgPD0gZDEpIHtcbiAgICAgIHN0YXJ0MiA9IGF4aXMuc2NhbGUuaW52ZXJ0KDApO1xuICAgICAgZW5kMiA9IGF4aXMuc2NhbGUuaW52ZXJ0KGQwICsgKGQxIC0gZDApICogcmF0aW8yLm1heCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0MiA9IGF4aXMuc2NhbGUuaW52ZXJ0KGQwIC0gKGQwIC0gZDEpICogcmF0aW8yLm1pbik7XG4gICAgICBlbmQyID0gYXhpcy5zY2FsZS5pbnZlcnQoMCk7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydDIsIGVuZDogZW5kMiB9O1xuICB9XG4gIHJhbmdlVG9SYXRpbyhyYW5nZTMsIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmdldFByaW1hcnlBeGlzKGRpcmVjdGlvbik7XG4gICAgaWYgKCFheGlzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGV4dGVudHMgPSB0aGlzLmdldERvbWFpblBpeGVsRXh0ZW50cyhheGlzKTtcbiAgICBpZiAoIWV4dGVudHMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW2QwLCBkMV0gPSBleHRlbnRzO1xuICAgIGxldCByMCA9IHJhbmdlMy5zdGFydCA9PSBudWxsID8gZDAgOiBheGlzLnNjYWxlLmNvbnZlcnQ/LihyYW5nZTMuc3RhcnQpO1xuICAgIGxldCByMSA9IHJhbmdlMy5lbmQgPT0gbnVsbCA/IGQxIDogYXhpcy5zY2FsZS5jb252ZXJ0Py4ocmFuZ2UzLmVuZCk7XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcihyMCkgfHwgIWlzRmluaXRlTnVtYmVyKHIxKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbZE1pbiwgZE1heF0gPSBbTWF0aC5taW4oZDAsIGQxKSwgTWF0aC5tYXgoZDAsIGQxKV07XG4gICAgaWYgKHIwIDwgZE1pbiB8fCByMCA+IGRNYXgpIHtcbiAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKFxuICAgICAgICBgSW52YWxpZCByYW5nZSBzdGFydCBbJHtyYW5nZTMuc3RhcnR9XSwgZXhwZWN0aW5nIGEgdmFsdWUgYmV0d2VlbiBbJHtheGlzLnNjYWxlLmludmVydD8uKGQwKX1dIGFuZCBbJHtheGlzLnNjYWxlLmludmVydD8uKGQxKX1dLCBpZ25vcmluZy5gXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocjEgPCBkTWluIHx8IHIxID4gZE1heCkge1xuICAgICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoXG4gICAgICAgIGBJbnZhbGlkIHJhbmdlIGVuZCBbJHtyYW5nZTMuZW5kfV0sIGV4cGVjdGluZyBhIHZhbHVlIGJldHdlZW4gWyR7YXhpcy5zY2FsZS5pbnZlcnQ/LihkMCl9XSBhbmQgWyR7YXhpcy5zY2FsZS5pbnZlcnQ/LihkMSl9XSwgaWdub3JpbmcuYFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcjAgPSBNYXRoLm1pbihkTWF4LCBNYXRoLm1heChkTWluLCByMCkpO1xuICAgIHIxID0gTWF0aC5taW4oZE1heCwgTWF0aC5tYXgoZE1pbiwgcjEpKTtcbiAgICBjb25zdCBkaWZmMiA9IGQxIC0gZDA7XG4gICAgY29uc3QgbWluID0gTWF0aC5hYnMoKHIwIC0gZDApIC8gZGlmZjIpO1xuICAgIGNvbnN0IG1heCA9IE1hdGguYWJzKChyMSAtIGQwKSAvIGRpZmYyKTtcbiAgICByZXR1cm4geyBtaW4sIG1heCB9O1xuICB9XG4gIGdldFByaW1hcnlBeGlzKGRpcmVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLmF4ZXM/LmZpbmQoKGEpID0+IGEuZGlyZWN0aW9uID09PSBkaXJlY3Rpb24pO1xuICB9XG4gIGdldERvbWFpbkV4dGVudHMoYXhpcykge1xuICAgIGNvbnN0IHsgZG9tYWluIH0gPSBheGlzLnNjYWxlO1xuICAgIGNvbnN0IGQwID0gZG9tYWluLmF0KDApO1xuICAgIGNvbnN0IGQxID0gZG9tYWluLmF0KC0xKTtcbiAgICBpZiAoZDAgPT0gbnVsbCB8fCBkMSA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIHJldHVybiBbZDAsIGQxXTtcbiAgfVxuICBnZXREb21haW5QaXhlbEV4dGVudHMoYXhpcykge1xuICAgIGNvbnN0IHsgZG9tYWluIH0gPSBheGlzLnNjYWxlO1xuICAgIGNvbnN0IGQwID0gYXhpcy5zY2FsZS5jb252ZXJ0Py4oZG9tYWluLmF0KDApKTtcbiAgICBjb25zdCBkMSA9IGF4aXMuc2NhbGUuY29udmVydD8uKGRvbWFpbi5hdCgtMSkpO1xuICAgIGlmICghaXNGaW5pdGVOdW1iZXIoZDApIHx8ICFpc0Zpbml0ZU51bWJlcihkMSkpXG4gICAgICByZXR1cm47XG4gICAgcmV0dXJuIFtkMCwgZDFdO1xuICB9XG4gIGdldERlZmluZWRab29tKCkge1xuICAgIGNvbnN0IHpvb20gPSB0aGlzLmdldFpvb20oKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeyBtaW46IHpvb20/Lng/Lm1pbiA/PyAwLCBtYXg6IHpvb20/Lng/Lm1heCA/PyAxIH0sXG4gICAgICB5OiB7IG1pbjogem9vbT8ueT8ubWluID8/IDAsIG1heDogem9vbT8ueT8ubWF4ID8/IDEgfVxuICAgIH07XG4gIH1cbiAgem9vbUJvdW5kcyh4QXhpcywgeUF4aXMsIHpvb20sIHBhZGRpbmcpIHtcbiAgICBjb25zdCB4U2NhbGUgPSB4QXhpcy5zY2FsZTtcbiAgICBjb25zdCB4U2NhbGVSYW5nZSA9IHhTY2FsZS5yYW5nZTtcbiAgICB4U2NhbGUucmFuZ2UgPSBbMCwgMV07XG4gICAgY29uc3QgeVNjYWxlID0geUF4aXMuc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlUmFuZ2UgPSB5U2NhbGUucmFuZ2U7XG4gICAgeVNjYWxlLnJhbmdlID0gWzAsIDFdO1xuICAgIGxldCBtaW4gPSAxO1xuICAgIGxldCBtaW5QYWRkaW5nID0gZmFsc2U7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgbGV0IG1heFBhZGRpbmcgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHNlcmllcyBvZiB5QXhpcy5ib3VuZFNlcmllcykge1xuICAgICAgY29uc3QgeyBjb25uZWN0c1RvWUF4aXMgfSA9IHNlcmllcztcbiAgICAgIGNvbnN0IHlWYWx1ZXMgPSBzZXJpZXMuZ2V0UmFuZ2UoXCJ5XCIgLyogWSAqLywgW3pvb20ubWluLCB6b29tLm1heF0pO1xuICAgICAgZm9yIChjb25zdCB5VmFsdWUgb2YgeVZhbHVlcykge1xuICAgICAgICBjb25zdCB5ID0geVNjYWxlLmNvbnZlcnQoeVZhbHVlKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeSkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh5IDwgbWluKSB7XG4gICAgICAgICAgbWluID0geTtcbiAgICAgICAgICBtaW5QYWRkaW5nID0gIWNvbm5lY3RzVG9ZQXhpcyB8fCB5VmFsdWUgPCAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ID4gbWF4KSB7XG4gICAgICAgICAgbWF4ID0geTtcbiAgICAgICAgICBtYXhQYWRkaW5nID0gIWNvbm5lY3RzVG9ZQXhpcyB8fCB5VmFsdWUgPiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0Zpbml0ZU51bWJlcih5QXhpcy5taW4pKSB7XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoeUF4aXMubWF4KSkge1xuICAgICAgbWF4ID0gMTtcbiAgICB9XG4gICAgeFNjYWxlLnJhbmdlID0geFNjYWxlUmFuZ2U7XG4gICAgeVNjYWxlLnJhbmdlID0geVNjYWxlUmFuZ2U7XG4gICAgaWYgKG1pbiA+PSBtYXgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdG90YWxQYWRkaW5nID0gKG1pblBhZGRpbmcgPyBwYWRkaW5nIDogMCkgKyAobWF4UGFkZGluZyA/IHBhZGRpbmcgOiAwKTtcbiAgICBjb25zdCBwYWRkZWREZWx0YSA9IE1hdGgubWluKChtYXggLSBtaW4pICogKDEgKyB0b3RhbFBhZGRpbmcpLCAxKTtcbiAgICBpZiAocGFkZGVkRGVsdGEgPD0gMClcbiAgICAgIHJldHVybjtcbiAgICBpZiAobWluUGFkZGluZyAmJiBtYXhQYWRkaW5nKSB7XG4gICAgICBjb25zdCBtaWQgPSAobWF4ICsgbWluKSAvIDI7XG4gICAgICBtaW4gPSBtaWQgLSBwYWRkZWREZWx0YSAvIDI7XG4gICAgICBtYXggPSBtaWQgKyBwYWRkZWREZWx0YSAvIDI7XG4gICAgfSBlbHNlIGlmICghbWluUGFkZGluZyAmJiBtYXhQYWRkaW5nKSB7XG4gICAgICBtYXggPSBtaW4gKyBwYWRkZWREZWx0YTtcbiAgICB9IGVsc2UgaWYgKG1pblBhZGRpbmcgJiYgIW1heFBhZGRpbmcpIHtcbiAgICAgIG1pbiA9IG1heCAtIHBhZGRlZERlbHRhO1xuICAgIH1cbiAgICBpZiAobWluIDwgMCkge1xuICAgICAgbWF4ICs9IC1taW47XG4gICAgICBtaW4gPSAwO1xuICAgIH0gZWxzZSBpZiAobWF4ID4gMSkge1xuICAgICAgbWluIC09IG1heCAtIDE7XG4gICAgICBtYXggPSAxO1xuICAgIH1cbiAgICByZXR1cm4geyBtaW4sIG1heCB9O1xuICB9XG4gIHByaW1hcnlBeGlzWm9vbShkaXJlY3Rpb24sIHpvb20sIHsgcGFkZGluZyA9IDAgfSA9IHt9KSB7XG4gICAgY29uc3QgY3Jvc3NEaXJlY3Rpb24gPSBkaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8gPyBcInlcIiAvKiBZICovIDogXCJ4XCIgLyogWCAqLztcbiAgICBjb25zdCB4QXhpcyA9IHRoaXMuZ2V0UHJpbWFyeUF4aXMoY3Jvc3NEaXJlY3Rpb24pO1xuICAgIGNvbnN0IHlBeGlzID0gdGhpcy5nZXRQcmltYXJ5QXhpcyhkaXJlY3Rpb24pO1xuICAgIGlmICh4QXhpcyA9PSBudWxsIHx8IHlBeGlzID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgcmV0dXJuIHRoaXMuem9vbUJvdW5kcyh4QXhpcywgeUF4aXMsIHpvb20sIHBhZGRpbmcpO1xuICB9XG4gIGNvbWJpbmVkQXhpc1pvb20oZGlyZWN0aW9uLCB6b29tLCB7IHBhZGRpbmcgPSAwIH0gPSB7fSkge1xuICAgIGNvbnN0IGNyb3NzRGlyZWN0aW9uID0gZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovID8gXCJ5XCIgLyogWSAqLyA6IFwieFwiIC8qIFggKi87XG4gICAgY29uc3Qgc2VyaWVzWEF4ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgeEF4aXMgb2YgdGhpcy5heGVzKSB7XG4gICAgICBpZiAoeEF4aXMuZGlyZWN0aW9uICE9PSBjcm9zc0RpcmVjdGlvbilcbiAgICAgICAgY29udGludWU7XG4gICAgICBmb3IgKGNvbnN0IHNlcmllcyBvZiB4QXhpcy5ib3VuZFNlcmllcykge1xuICAgICAgICBzZXJpZXNYQXhlcy5zZXQoc2VyaWVzLCB4QXhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBtaW4gPSAxO1xuICAgIGxldCBtYXggPSAwO1xuICAgIGZvciAoY29uc3QgeUF4aXMgb2YgdGhpcy5heGVzKSB7XG4gICAgICBpZiAoeUF4aXMuZGlyZWN0aW9uICE9PSBkaXJlY3Rpb24pXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgZm9yIChjb25zdCBzZXJpZXMgb2YgeUF4aXMuYm91bmRTZXJpZXMpIHtcbiAgICAgICAgY29uc3QgeEF4aXMgPSBzZXJpZXNYQXhlcy5nZXQoc2VyaWVzKTtcbiAgICAgICAgaWYgKHhBeGlzID09IG51bGwpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuem9vbUJvdW5kcyh4QXhpcywgeUF4aXMsIHpvb20sIHBhZGRpbmcpO1xuICAgICAgICBpZiAoYm91bmRzID09IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGJvdW5kcy5taW4pO1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGJvdW5kcy5tYXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZWx0YTMgPSAxZS02O1xuICAgIGlmIChtaW4gPCBkZWx0YTMpXG4gICAgICBtaW4gPSAwO1xuICAgIGlmIChtYXggPiAxIC0gZGVsdGEzKVxuICAgICAgbWF4ID0gMTtcbiAgICBpZiAobWluID4gbWF4KVxuICAgICAgcmV0dXJuO1xuICAgIHJldHVybiB7IG1pbiwgbWF4IH07XG4gIH1cbn07XG52YXIgQXhpc1pvb21NYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihheGlzKSB7XG4gICAgdGhpcy5heGlzID0gYXhpcztcbiAgICBjb25zdCBbbWluID0gMCwgbWF4ID0gMV0gPSBheGlzLnZpc2libGVSYW5nZTtcbiAgICB0aGlzLnN0YXRlID0gbmV3IFN0YXRlVHJhY2tlcih7IG1pbiwgbWF4IH0pO1xuICAgIHRoaXMuY3VycmVudFpvb20gPSB0aGlzLnN0YXRlLnN0YXRlVmFsdWUoKTtcbiAgfVxuICBnZXREaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhpcy5kaXJlY3Rpb247XG4gIH1cbiAgdXBkYXRlWm9vbShjYWxsZXJJZCwgbmV3Wm9vbSkge1xuICAgIHRoaXMuc3RhdGUuc2V0KGNhbGxlcklkLCBuZXdab29tKTtcbiAgfVxuICBnZXRab29tKCkge1xuICAgIHJldHVybiBkZWVwQ2xvbmUodGhpcy5zdGF0ZS5zdGF0ZVZhbHVlKCkpO1xuICB9XG4gIGhhc0NoYW5nZXMoKSB7XG4gICAgY29uc3QgY3VycmVudFpvb20gPSB0aGlzLmN1cnJlbnRab29tO1xuICAgIGNvbnN0IHBlbmRpbmdab29tID0gdGhpcy5zdGF0ZS5zdGF0ZVZhbHVlKCk7XG4gICAgcmV0dXJuIGN1cnJlbnRab29tLm1pbiAhPT0gcGVuZGluZ1pvb20ubWluIHx8IGN1cnJlbnRab29tLm1heCAhPT0gcGVuZGluZ1pvb20ubWF4O1xuICB9XG4gIGFwcGx5Q2hhbmdlcygpIHtcbiAgICBjb25zdCBoYXNDaGFuZ2VzID0gdGhpcy5oYXNDaGFuZ2VzKCk7XG4gICAgdGhpcy5jdXJyZW50Wm9vbSA9IHRoaXMuc3RhdGUuc3RhdGVWYWx1ZSgpO1xuICAgIHJldHVybiBoYXNDaGFuZ2VzO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sYXlvdXQvc2VyaWVzTGFiZWxMYXlvdXRNYW5hZ2VyLnRzXG52YXIgU2VyaWVzTGFiZWxMYXlvdXRNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmxhYmVsRGF0YSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgdXBkYXRlTGFiZWxzKHBsYWNlZExhYmVsU2VyaWVzLCBwYWRkaW5nLCBzZXJpZXNSZWN0ID0gQkJveC56ZXJvKSB7XG4gICAgY29uc3QgYm91bmRzID0ge1xuICAgICAgeDogLXBhZGRpbmcubGVmdCxcbiAgICAgIHk6IC1wYWRkaW5nLnRvcCxcbiAgICAgIHdpZHRoOiBzZXJpZXNSZWN0LndpZHRoICsgcGFkZGluZy5sZWZ0ICsgcGFkZGluZy5yaWdodCxcbiAgICAgIGhlaWdodDogc2VyaWVzUmVjdC5oZWlnaHQgKyBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tXG4gICAgfTtcbiAgICBjb25zdCBleHBlY3RlZFNlcmllc0lkID0gbmV3IFNldChwbGFjZWRMYWJlbFNlcmllcy5tYXAoKHMpID0+IHMuaWQpKTtcbiAgICBmb3IgKGNvbnN0IHNlcmllc0lkIG9mIHRoaXMubGFiZWxEYXRhLmtleXMoKSkge1xuICAgICAgaWYgKCFleHBlY3RlZFNlcmllc0lkLmhhcyhzZXJpZXNJZCkpIHtcbiAgICAgICAgdGhpcy5sYWJlbERhdGEuZGVsZXRlKHNlcmllc0lkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2YgcGxhY2VkTGFiZWxTZXJpZXMpIHtcbiAgICAgIGNvbnN0IGxhYmVsRGF0YSA9IHNlcmllcy5nZXRMYWJlbERhdGEoKTtcbiAgICAgIGlmIChsYWJlbERhdGEuZXZlcnkoaXNQb2ludExhYmVsRGF0dW0pKSB7XG4gICAgICAgIHRoaXMubGFiZWxEYXRhLnNldChzZXJpZXMuaWQsIGxhYmVsRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBsYWNlZExhYmVscyA9IHBsYWNlTGFiZWxzKHRoaXMubGFiZWxEYXRhLCBib3VuZHMsIDUpO1xuICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIHBsYWNlZExhYmVsU2VyaWVzKSB7XG4gICAgICBzZXJpZXMudXBkYXRlUGxhY2VkTGFiZWxEYXRhPy4ocGxhY2VkTGFiZWxzLmdldChzZXJpZXMuaWQpID8/IFtdKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2xlZ2VuZC9sZWdlbmRNYW5hZ2VyLnRzXG52YXIgTGVnZW5kTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubWVtZW50b09yaWdpbmF0b3JLZXkgPSBcImxlZ2VuZFwiO1xuICAgIHRoaXMubGVnZW5kRGF0YU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgY3JlYXRlTWVtZW50bygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREYXRhKCkuZmlsdGVyKCh7IGhpZGVJbkxlZ2VuZCwgaXNGaXhlZCB9KSA9PiAhaGlkZUluTGVnZW5kICYmICFpc0ZpeGVkKS5tYXAoKHsgZW5hYmxlZCwgc2VyaWVzSWQsIGl0ZW1JZCwgbGVnZW5kSXRlbU5hbWUgfSkgPT4gKHtcbiAgICAgIHZpc2libGU6IGVuYWJsZWQsXG4gICAgICBzZXJpZXNJZCxcbiAgICAgIGl0ZW1JZCxcbiAgICAgIGxlZ2VuZEl0ZW1OYW1lXG4gICAgfSkpO1xuICB9XG4gIGd1YXJkTWVtZW50byhibG9iKSB7XG4gICAgcmV0dXJuIGJsb2IgPT0gbnVsbCB8fCBpc0FycmF5KGJsb2IpO1xuICB9XG4gIHJlc3RvcmVNZW1lbnRvKF92ZXJzaW9uLCBfbWVtZW50b1ZlcnNpb24sIG1lbWVudG8pIHtcbiAgICBtZW1lbnRvPy5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgeyBzZXJpZXNJZCwgZGF0YSB9ID0gdGhpcy5nZXRSZXN0b3JlZERhdGEoZGF0dW0pID8/IHt9O1xuICAgICAgaWYgKCFzZXJpZXNJZCB8fCAhZGF0YSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZURhdGEoc2VyaWVzSWQsIGRhdGEpO1xuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgZ2V0UmVzdG9yZWREYXRhKGRhdHVtKSB7XG4gICAgY29uc3QgeyBzZXJpZXNJZCwgaXRlbUlkLCBsZWdlbmRJdGVtTmFtZSwgdmlzaWJsZSB9ID0gZGF0dW07XG4gICAgaWYgKHNlcmllc0lkKSB7XG4gICAgICBjb25zdCBsZWdlbmREYXRhID0gdGhpcy5sZWdlbmREYXRhTWFwLmdldChzZXJpZXNJZCkgPz8gW107XG4gICAgICBjb25zdCBkYXRhID0gbGVnZW5kRGF0YS5tYXAoKGQpID0+IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBkLnNlcmllc0lkID09PSBzZXJpZXNJZCAmJiAoIWl0ZW1JZCB8fCBkLml0ZW1JZCA9PT0gaXRlbUlkKTtcbiAgICAgICAgaWYgKG1hdGNoICYmIGQuaXNGaXhlZCkge1xuICAgICAgICAgIHRoaXMud2FybkZpeGVkKGQuc2VyaWVzSWQsIGQuaXRlbUlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWQuaXNGaXhlZCAmJiBtYXRjaCA/IHsgLi4uZCwgZW5hYmxlZDogdmlzaWJsZSB9IDogZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgc2VyaWVzSWQsIGRhdGEgfTtcbiAgICB9XG4gICAgaWYgKGl0ZW1JZCA9PSBudWxsICYmIGxlZ2VuZEl0ZW1OYW1lID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsZWdlbmREYXR1bSBvZiB0aGlzLmdldERhdGEoKSkge1xuICAgICAgaWYgKGl0ZW1JZCAhPSBudWxsICYmIGxlZ2VuZERhdHVtLml0ZW1JZCAhPT0gaXRlbUlkIHx8IGxlZ2VuZEl0ZW1OYW1lICE9IG51bGwgJiYgbGVnZW5kRGF0dW0ubGVnZW5kSXRlbU5hbWUgIT09IGxlZ2VuZEl0ZW1OYW1lKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGxlZ2VuZERhdHVtLmlzRml4ZWQpIHtcbiAgICAgICAgdGhpcy53YXJuRml4ZWQobGVnZW5kRGF0dW0uc2VyaWVzSWQsIGl0ZW1JZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlcmllc0xlZ2VuZERhdGEgPSAodGhpcy5sZWdlbmREYXRhTWFwLmdldChsZWdlbmREYXR1bS5zZXJpZXNJZCkgPz8gW10pLm1hcChcbiAgICAgICAgKGQpID0+IGQuaXRlbUlkID09PSBpdGVtSWQgfHwgZC5sZWdlbmRJdGVtTmFtZSA9PT0gbGVnZW5kSXRlbU5hbWUgPyB7IC4uLmQsIGVuYWJsZWQ6IHZpc2libGUgfSA6IGRcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZXJpZXNJZDogbGVnZW5kRGF0dW0uc2VyaWVzSWQsXG4gICAgICAgIGRhdGE6IHNlcmllc0xlZ2VuZERhdGFcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHdhcm5GaXhlZChzZXJpZXNJZCwgaXRlbUlkKSB7XG4gICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoXG4gICAgICBgVGhlIGxlZ2VuZCBpdGVtIHdpdGggc2VyaWVzSWQgWyR7c2VyaWVzSWR9XSBhbmQgaXRlbUlkIFske2l0ZW1JZH1dIGlzIG5vdCBjb25maWd1cmFibGUsIHRoaXMgc2VyaWVzIGl0ZW0gY2Fubm90IGJlIHRvZ2dsZWQgdGhyb3VnaCB0aGUgbGVnZW5kLmBcbiAgICApO1xuICB9XG4gIHVwZGF0ZShkYXRhKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJsZWdlbmQtY2hhbmdlXCIsIHtcbiAgICAgIHR5cGU6IFwibGVnZW5kLWNoYW5nZVwiLFxuICAgICAgbGVnZW5kRGF0YTogZGF0YSA/PyB0aGlzLmdldERhdGEoKVxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZURhdGEoc2VyaWVzSWQsIGRhdGEgPSBbXSkge1xuICAgIHRoaXMubGVnZW5kRGF0YU1hcC5zZXQoc2VyaWVzSWQsIGRhdGEpO1xuICB9XG4gIGNsZWFyRGF0YSgpIHtcbiAgICB0aGlzLmxlZ2VuZERhdGFNYXAuY2xlYXIoKTtcbiAgfVxuICB0b2dnbGVJdGVtKHtcbiAgICBlbmFibGVkLFxuICAgIHNlcmllc0lkLFxuICAgIGl0ZW1JZCxcbiAgICBsZWdlbmRJdGVtTmFtZVxuICB9KSB7XG4gICAgaWYgKGxlZ2VuZEl0ZW1OYW1lKSB7XG4gICAgICB0aGlzLmdldERhdGEoKS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdEYXRhID0gKHRoaXMubGVnZW5kRGF0YU1hcC5nZXQoZGF0dW0uc2VyaWVzSWQpID8/IFtdKS5tYXAoXG4gICAgICAgICAgKGQpID0+IGQubGVnZW5kSXRlbU5hbWUgPT09IGxlZ2VuZEl0ZW1OYW1lID8geyAuLi5kLCBlbmFibGVkIH0gOiBkXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YShkYXR1bS5zZXJpZXNJZCwgbmV3RGF0YSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWVzTGVnZW5kRGF0YSA9IHRoaXMuZ2V0RGF0YShzZXJpZXNJZCk7XG4gICAgY29uc3Qgc2luZ2xlTGVnZW5kSXRlbSA9IHNlcmllc0xlZ2VuZERhdGEubGVuZ3RoID09PSAxO1xuICAgIGNvbnN0IGRhdGEgPSBzZXJpZXNMZWdlbmREYXRhLm1hcChcbiAgICAgIChkYXR1bSkgPT4gaXRlbUlkID09IG51bGwgJiYgc2luZ2xlTGVnZW5kSXRlbSB8fCBkYXR1bS5pdGVtSWQgPT09IGl0ZW1JZCA/IHsgLi4uZGF0dW0sIGVuYWJsZWQgfSA6IGRhdHVtXG4gICAgKTtcbiAgICB0aGlzLnVwZGF0ZURhdGEoc2VyaWVzSWQsIGRhdGEpO1xuICB9XG4gIGdldERhdGEoc2VyaWVzSWQpIHtcbiAgICBpZiAoc2VyaWVzSWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlZ2VuZERhdGFNYXAuZ2V0KHNlcmllc0lkKSA/PyBbXTtcbiAgICB9XG4gICAgcmV0dXJuIFsuLi50aGlzLmxlZ2VuZERhdGFNYXBdLnJlZHVjZShcbiAgICAgIChkYXRhLCBbXywgbGVnZW5kRGF0YV0pID0+IGRhdGEuY29uY2F0KGxlZ2VuZERhdGEpLFxuICAgICAgW11cbiAgICApO1xuICB9XG4gIGdldERhdHVtKHsgc2VyaWVzSWQsIGl0ZW1JZCB9ID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXREYXRhKHNlcmllc0lkKS5maW5kKChkYXR1bSkgPT4gZGF0dW0uaXRlbUlkID09PSBpdGVtSWQpO1xuICB9XG4gIGdldFNlcmllc0VuYWJsZWQoc2VyaWVzSWQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhKHNlcmllc0lkKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZGF0YS5zb21lKChkKSA9PiBkLmVuYWJsZWQpO1xuICAgIH1cbiAgfVxuICBnZXRJdGVtRW5hYmxlZCh7IHNlcmllc0lkLCBpdGVtSWQgfSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGF0dW0oeyBzZXJpZXNJZCwgaXRlbUlkIH0pPy5lbmFibGVkID8/IHRydWU7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNTdGF0ZU1hbmFnZXIudHNcbnZhciBTZXJpZXNTdGF0ZU1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZ3JvdXBzID0ge307XG4gIH1cbiAgcmVnaXN0ZXJTZXJpZXMoeyBpbnRlcm5hbElkLCBzZXJpZXNHcm91cGluZywgdmlzaWJsZSwgdHlwZSB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghc2VyaWVzR3JvdXBpbmcpXG4gICAgICByZXR1cm47XG4gICAgKF9hID0gdGhpcy5ncm91cHMpW3R5cGVdID8/IChfYVt0eXBlXSA9IHt9KTtcbiAgICB0aGlzLmdyb3Vwc1t0eXBlXVtpbnRlcm5hbElkXSA9IHsgZ3JvdXBpbmc6IHNlcmllc0dyb3VwaW5nLCB2aXNpYmxlIH07XG4gIH1cbiAgdXBkYXRlU2VyaWVzKHsgaW50ZXJuYWxJZCwgc2VyaWVzR3JvdXBpbmcsIHZpc2libGUsIHR5cGUgfSkge1xuICAgIGlmICghc2VyaWVzR3JvdXBpbmcpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLmdyb3Vwc1t0eXBlXT8uW2ludGVybmFsSWRdO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkuZ3JvdXBpbmcgPSBzZXJpZXNHcm91cGluZztcbiAgICAgIGVudHJ5LnZpc2libGUgPSB2aXNpYmxlO1xuICAgIH1cbiAgfVxuICBkZXJlZ2lzdGVyU2VyaWVzKHsgaW50ZXJuYWxJZCwgdHlwZSB9KSB7XG4gICAgaWYgKHRoaXMuZ3JvdXBzW3R5cGVdKSB7XG4gICAgICBkZWxldGUgdGhpcy5ncm91cHNbdHlwZV1baW50ZXJuYWxJZF07XG4gICAgfVxuICAgIGlmICh0aGlzLmdyb3Vwc1t0eXBlXSAmJiBPYmplY3Qua2V5cyh0aGlzLmdyb3Vwc1t0eXBlXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgdGhpcy5ncm91cHNbdHlwZV07XG4gICAgfVxuICB9XG4gIGdldFZpc2libGVQZWVyR3JvdXBJbmRleCh7IHR5cGUsIHNlcmllc0dyb3VwaW5nLCB2aXNpYmxlIH0pIHtcbiAgICBpZiAoIXNlcmllc0dyb3VwaW5nKSB7XG4gICAgICByZXR1cm4geyB2aXNpYmxlR3JvdXBDb3VudDogdmlzaWJsZSA/IDEgOiAwLCB2aXNpYmxlU2FtZVN0YWNrQ291bnQ6IHZpc2libGUgPyAxIDogMCwgaW5kZXg6IDAgfTtcbiAgICB9XG4gICAgY29uc3QgdmlzaWJsZUdyb3Vwc1NldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgdmlzaWJsZVNhbWVTdGFja1NldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBPYmplY3QudmFsdWVzKHRoaXMuZ3JvdXBzW3R5cGVdID8/IHt9KSkge1xuICAgICAgaWYgKCFlbnRyeS52aXNpYmxlKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZpc2libGVHcm91cHNTZXQuYWRkKGVudHJ5Lmdyb3VwaW5nLmdyb3VwSW5kZXgpO1xuICAgICAgaWYgKGVudHJ5Lmdyb3VwaW5nLmdyb3VwSW5kZXggPT09IHNlcmllc0dyb3VwaW5nLmdyb3VwSW5kZXgpIHtcbiAgICAgICAgdmlzaWJsZVNhbWVTdGFja1NldC5hZGQoZW50cnkuZ3JvdXBpbmcuc3RhY2tJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHZpc2libGVHcm91cHMgPSBBcnJheS5mcm9tKHZpc2libGVHcm91cHNTZXQpO1xuICAgIHZpc2libGVHcm91cHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIHJldHVybiB7XG4gICAgICB2aXNpYmxlR3JvdXBDb3VudDogdmlzaWJsZUdyb3Vwcy5sZW5ndGgsXG4gICAgICB2aXNpYmxlU2FtZVN0YWNrQ291bnQ6IHZpc2libGVTYW1lU3RhY2tTZXQuc2l6ZSxcbiAgICAgIGluZGV4OiB2aXNpYmxlR3JvdXBzLmluZGV4T2Yoc2VyaWVzR3JvdXBpbmcuZ3JvdXBJbmRleClcbiAgICB9O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jaGFydFVwZGF0ZVR5cGUudHNcbnZhciBDaGFydFVwZGF0ZVR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChDaGFydFVwZGF0ZVR5cGUyKSA9PiB7XG4gIENoYXJ0VXBkYXRlVHlwZTJbQ2hhcnRVcGRhdGVUeXBlMltcIkZVTExcIl0gPSAwXSA9IFwiRlVMTFwiO1xuICBDaGFydFVwZGF0ZVR5cGUyW0NoYXJ0VXBkYXRlVHlwZTJbXCJVUERBVEVfREFUQVwiXSA9IDFdID0gXCJVUERBVEVfREFUQVwiO1xuICBDaGFydFVwZGF0ZVR5cGUyW0NoYXJ0VXBkYXRlVHlwZTJbXCJQUk9DRVNTX0RBVEFcIl0gPSAyXSA9IFwiUFJPQ0VTU19EQVRBXCI7XG4gIENoYXJ0VXBkYXRlVHlwZTJbQ2hhcnRVcGRhdGVUeXBlMltcIlBFUkZPUk1fTEFZT1VUXCJdID0gM10gPSBcIlBFUkZPUk1fTEFZT1VUXCI7XG4gIENoYXJ0VXBkYXRlVHlwZTJbQ2hhcnRVcGRhdGVUeXBlMltcIlNFUklFU19VUERBVEVcIl0gPSA0XSA9IFwiU0VSSUVTX1VQREFURVwiO1xuICBDaGFydFVwZGF0ZVR5cGUyW0NoYXJ0VXBkYXRlVHlwZTJbXCJQUkVfU0NFTkVfUkVOREVSXCJdID0gNV0gPSBcIlBSRV9TQ0VORV9SRU5ERVJcIjtcbiAgQ2hhcnRVcGRhdGVUeXBlMltDaGFydFVwZGF0ZVR5cGUyW1wiU0NFTkVfUkVOREVSXCJdID0gNl0gPSBcIlNDRU5FX1JFTkRFUlwiO1xuICBDaGFydFVwZGF0ZVR5cGUyW0NoYXJ0VXBkYXRlVHlwZTJbXCJOT05FXCJdID0gN10gPSBcIk5PTkVcIjtcbiAgcmV0dXJuIENoYXJ0VXBkYXRlVHlwZTI7XG59KShDaGFydFVwZGF0ZVR5cGUgfHwge30pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC91cGRhdGVTZXJ2aWNlLnRzXG52YXIgVXBkYXRlU2VydmljZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodXBkYXRlQ2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrID0gdXBkYXRlQ2FsbGJhY2s7XG4gICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIH1cbiAgYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiB0aGlzLmV2ZW50cy5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuICByZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ldmVudHMuY2xlYXIoKTtcbiAgfVxuICB1cGRhdGUodHlwZSA9IDAgLyogRlVMTCAqLywgb3B0aW9ucykge1xuICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sodHlwZSwgb3B0aW9ucyk7XG4gIH1cbiAgZGlzcGF0Y2hVcGRhdGVDb21wbGV0ZSgpIHtcbiAgICB0aGlzLmV2ZW50cy5lbWl0KFwidXBkYXRlLWNvbXBsZXRlXCIsIHsgdHlwZTogXCJ1cGRhdGUtY29tcGxldGVcIiB9KTtcbiAgfVxuICBkaXNwYXRjaFByZURvbVVwZGF0ZSgpIHtcbiAgICB0aGlzLmV2ZW50cy5lbWl0KFwicHJlLWRvbS11cGRhdGVcIiwgeyB0eXBlOiBcInByZS1kb20tdXBkYXRlXCIgfSk7XG4gIH1cbiAgZGlzcGF0Y2hQcmVTY2VuZVJlbmRlcigpIHtcbiAgICB0aGlzLmV2ZW50cy5lbWl0KFwicHJlLXNjZW5lLXJlbmRlclwiLCB7IHR5cGU6IFwicHJlLXNjZW5lLXJlbmRlclwiIH0pO1xuICB9XG4gIGRpc3BhdGNoUHJvY2Vzc0RhdGEoeyBzZXJpZXMgfSkge1xuICAgIHRoaXMuZXZlbnRzLmVtaXQoXCJwcm9jZXNzLWRhdGFcIiwgeyB0eXBlOiBcInByb2Nlc3MtZGF0YVwiLCBzZXJpZXMgfSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NoYXJ0Q29udGV4dC50c1xudmFyIENoYXJ0Q29udGV4dCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIHZhcnMpIHtcbiAgICB0aGlzLmNhbGxiYWNrQ2FjaGUgPSBuZXcgQ2FsbGJhY2tDYWNoZSgpO1xuICAgIHRoaXMuY2hhcnRFdmVudE1hbmFnZXIgPSBuZXcgQ2hhcnRFdmVudE1hbmFnZXIoKTtcbiAgICB0aGlzLmhpZ2hsaWdodE1hbmFnZXIgPSBuZXcgSGlnaGxpZ2h0TWFuYWdlcigpO1xuICAgIHRoaXMubGF5b3V0TWFuYWdlciA9IG5ldyBMYXlvdXRNYW5hZ2VyKCk7XG4gICAgdGhpcy5sb2NhbGVNYW5hZ2VyID0gbmV3IExvY2FsZU1hbmFnZXIoKTtcbiAgICB0aGlzLnNlcmllc1N0YXRlTWFuYWdlciA9IG5ldyBTZXJpZXNTdGF0ZU1hbmFnZXIoKTtcbiAgICB0aGlzLnN0YXRlTWFuYWdlciA9IG5ldyBTdGF0ZU1hbmFnZXIoKTtcbiAgICB0aGlzLnNlcmllc0xhYmVsTGF5b3V0TWFuYWdlciA9IG5ldyBTZXJpZXNMYWJlbExheW91dE1hbmFnZXIoKTtcbiAgICB0aGlzLmNvbnRleHRNb2R1bGVzID0gW107XG4gICAgY29uc3Qge1xuICAgICAgc2NlbmUsXG4gICAgICByb290LFxuICAgICAgc3luY01hbmFnZXIsXG4gICAgICBjb250YWluZXIsXG4gICAgICBmaXJlRXZlbnQsXG4gICAgICB1cGRhdGVDYWxsYmFjayxcbiAgICAgIHVwZGF0ZU11dGV4LFxuICAgICAgc3R5bGVDb250YWluZXIsXG4gICAgICBjaGFydFR5cGVcbiAgICB9ID0gdmFycztcbiAgICB0aGlzLmNoYXJ0U2VydmljZSA9IGNoYXJ0O1xuICAgIHRoaXMuc3luY01hbmFnZXIgPSBzeW5jTWFuYWdlcjtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBuZXcgRE9NTWFuYWdlcihjb250YWluZXIsIHN0eWxlQ29udGFpbmVyKTtcbiAgICB0aGlzLndpZGdldHMgPSBuZXcgV2lkZ2V0U2V0KHRoaXMuZG9tTWFuYWdlcik7XG4gICAgY29uc3QgY2FudmFzRWxlbWVudCA9IHRoaXMuZG9tTWFuYWdlci5hZGRDaGlsZChcbiAgICAgIFwiY2FudmFzXCIsXG4gICAgICBcInNjZW5lLWNhbnZhc1wiLFxuICAgICAgc2NlbmU/LmNhbnZhcy5lbGVtZW50XG4gICAgKTtcbiAgICB0aGlzLnNjZW5lID0gc2NlbmUgPz8gbmV3IFNjZW5lKHsgY2FudmFzRWxlbWVudCB9KTtcbiAgICB0aGlzLnNjZW5lLnNldFJvb3Qocm9vdCk7XG4gICAgdGhpcy5heGlzTWFuYWdlciA9IG5ldyBBeGlzTWFuYWdlcihyb290KTtcbiAgICB0aGlzLmxlZ2VuZE1hbmFnZXIgPSBuZXcgTGVnZW5kTWFuYWdlcigpO1xuICAgIHRoaXMuYW5ub3RhdGlvbk1hbmFnZXIgPSBuZXcgQW5ub3RhdGlvbk1hbmFnZXIoY2hhcnQuYW5ub3RhdGlvblJvb3QpO1xuICAgIHRoaXMuY2hhcnRUeXBlT3JpZ2luYXRvciA9IG5ldyBDaGFydFR5cGVPcmlnaW5hdG9yKGNoYXJ0KTtcbiAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlciA9IG5ldyBJbnRlcmFjdGlvbk1hbmFnZXIoKTtcbiAgICB0aGlzLmNvbnRleHRNZW51UmVnaXN0cnkgPSBuZXcgQ29udGV4dE1lbnVSZWdpc3RyeSgpO1xuICAgIHRoaXMudXBkYXRlU2VydmljZSA9IG5ldyBVcGRhdGVTZXJ2aWNlKHVwZGF0ZUNhbGxiYWNrKTtcbiAgICB0aGlzLnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlID0gbmV3IFByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlKHRoaXMubG9jYWxlTWFuYWdlciwgdGhpcy5kb21NYW5hZ2VyKTtcbiAgICB0aGlzLmhpc3RvcnlNYW5hZ2VyID0gbmV3IEhpc3RvcnlNYW5hZ2VyKHRoaXMuY2hhcnRFdmVudE1hbmFnZXIpO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlciA9IG5ldyBBbmltYXRpb25NYW5hZ2VyKHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLCB1cGRhdGVNdXRleCk7XG4gICAgdGhpcy5kYXRhU2VydmljZSA9IG5ldyBEYXRhU2VydmljZSh0aGlzLmFuaW1hdGlvbk1hbmFnZXIpO1xuICAgIHRoaXMudG9vbHRpcE1hbmFnZXIgPSBuZXcgVG9vbHRpcE1hbmFnZXIodGhpcy5kb21NYW5hZ2VyLCBjaGFydC50b29sdGlwKTtcbiAgICB0aGlzLnpvb21NYW5hZ2VyID0gbmV3IFpvb21NYW5hZ2VyKGZpcmVFdmVudCwgdGhpcy5sYXlvdXRNYW5hZ2VyKTtcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVSZWdpc3RyeS5ieVR5cGUoXCJjb250ZXh0XCIpKSB7XG4gICAgICBpZiAoIW1vZHVsZS5jaGFydFR5cGVzLmluY2x1ZGVzKGNoYXJ0VHlwZSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgbW9kdWxlSW5zdGFuY2UgPSBtb2R1bGUubW9kdWxlRmFjdG9yeSh0aGlzKTtcbiAgICAgIHRoaXMuY29udGV4dE1vZHVsZXMucHVzaChtb2R1bGVJbnN0YW5jZSk7XG4gICAgICB0aGlzW21vZHVsZS5jb250ZXh0S2V5XSA9IG1vZHVsZUluc3RhbmNlO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5oaWdobGlnaHRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmF4aXNNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FjaGUuaW52YWxpZGF0ZUNhY2hlKCk7XG4gICAgdGhpcy5jaGFydEV2ZW50TWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmhpZ2hsaWdodE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuZGVzdHJveSgpO1xuICAgIHRoaXMuc3luY01hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMudG9vbHRpcE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuem9vbU1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMud2lkZ2V0cy5kZXN0cm95KCk7XG4gICAgdGhpcy5jb250ZXh0TW9kdWxlcy5mb3JFYWNoKChtKSA9PiBtLmRlc3Ryb3koKSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NoYXJ0SGlnaGxpZ2h0LnRzXG52YXIgQ2hhcnRIaWdobGlnaHQgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnJhbmdlID0gXCJ0b29sdGlwXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShVTklPTihbXCJ0b29sdGlwXCIsIFwibm9kZVwiXSwgXCJhIHJhbmdlXCIpKVxuXSwgQ2hhcnRIaWdobGlnaHQucHJvdG90eXBlLCBcInJhbmdlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL2NhY2hpbmcudHNcbmZ1bmN0aW9uIHNldHNFcXVhbChhLCBiKSB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgYSkge1xuICAgIGlmICghYi5oYXModmFsdWUpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaWRzTWFwRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbClcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBba2V5LCBhVmFsdWVdIG9mIGEpIHtcbiAgICBjb25zdCBiVmFsdWUgPSBiLmdldChrZXkpO1xuICAgIGlmIChiVmFsdWUgPT0gbnVsbClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXNldHNFcXVhbChhVmFsdWUsIGJWYWx1ZSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBwcm9wc0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHsgdHlwZTogdHlwZUEsIGlkc01hcDogaWRzTWFwQSwgc2NvcGVzOiBzY29wZXNBLCBkYXRhOiBkYXRhQSwgLi4ucHJvcEEgfSA9IGFbaV07XG4gICAgY29uc3QgeyB0eXBlOiB0eXBlQiwgaWRzTWFwOiBpZHNNYXBCLCBzY29wZXM6IHNjb3Blc0IsIGRhdGE6IGRhdGFCLCAuLi5wcm9wQiB9ID0gYltpXTtcbiAgICBpZiAodHlwZUEgIT09IHR5cGVCKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChzY29wZXNBICYmIHNjb3Blc0IgJiYgIWFycmF5c0VxdWFsKHNjb3Blc0EsIHNjb3Blc0IpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkYXRhQSAmJiBkYXRhQiAmJiBkYXRhQSAhPT0gZGF0YUIpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFvYmplY3RzRXF1YWwocHJvcEEsIHByb3BCKSB8fCAhaWRzTWFwRXF1YWwoaWRzTWFwQSwgaWRzTWFwQikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBvcHRzRXF1YWwoYSwgYikge1xuICBjb25zdCB7IHByb3BzOiBwcm9wc0EsIC4uLnJlc3RBIH0gPSBhO1xuICBjb25zdCB7IHByb3BzOiBwcm9wc0IsIC4uLnJlc3RCIH0gPSBiO1xuICByZXR1cm4gb2JqZWN0c0VxdWFsKHJlc3RBLCByZXN0QikgJiYgcHJvcHNFcXVhbChwcm9wc0EsIHByb3BzQik7XG59XG5mdW5jdGlvbiBjYW5SZXVzZUNhY2hlZERhdGEoY2FjaGVkRGF0YUl0ZW0sIGRhdGEsIGlkcywgb3B0cykge1xuICByZXR1cm4gZGF0YSA9PT0gY2FjaGVkRGF0YUl0ZW0uZGF0YSAmJiBhcnJheXNFcXVhbChpZHMsIGNhY2hlZERhdGFJdGVtLmlkcykgJiYgb3B0c0VxdWFsKG9wdHMsIGNhY2hlZERhdGFJdGVtLm9wdHMpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL2RhdGFEb21haW4udHNcbnZhciBEaXNjcmV0ZURvbWFpbiA9IGNsYXNzIF9EaXNjcmV0ZURvbWFpbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZG9tYWluID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfRGlzY3JldGVEb21haW47XG4gIH1cbiAgZXh0ZW5kKHZhbCkge1xuICAgIHRoaXMuZG9tYWluLmFkZCh2YWwpO1xuICB9XG4gIGdldERvbWFpbigpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmRvbWFpbik7XG4gIH1cbn07XG52YXIgQ29udGludW91c0RvbWFpbiA9IGNsYXNzIF9Db250aW51b3VzRG9tYWluIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kb21haW4gPSBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gIH1cbiAgc3RhdGljIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgX0NvbnRpbnVvdXNEb21haW47XG4gIH1cbiAgc3RhdGljIGV4dGVuZERvbWFpbih2YWx1ZXMsIGRvbWFpbiA9IFtJbmZpbml0eSwgLUluZmluaXR5XSkge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRvbWFpblswXSA+IHZhbHVlKSB7XG4gICAgICAgIGRvbWFpblswXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGRvbWFpblsxXSA8IHZhbHVlKSB7XG4gICAgICAgIGRvbWFpblsxXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZG9tYWluO1xuICB9XG4gIGV4dGVuZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRvbWFpblswXSA+IHZhbHVlKSB7XG4gICAgICB0aGlzLmRvbWFpblswXSA9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5kb21haW5bMV0gPCB2YWx1ZSkge1xuICAgICAgdGhpcy5kb21haW5bMV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0RG9tYWluKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5kb21haW5dO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL3JhbmdlTG9va3VwLnRzXG52YXIgTUlOID0gMDtcbnZhciBNQVggPSAxO1xudmFyIFNQQU4gPSAyO1xudmFyIFJhbmdlTG9va3VwID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhbGxWYWx1ZXMpIHtcbiAgICBjb25zdCBkYXRhTGVuZ3RoID0gYWxsVmFsdWVzLnJlZHVjZSgoYWNjLCB2KSA9PiBNYXRoLm1heChhY2MsIHYubGVuZ3RoKSwgMCk7XG4gICAgY29uc3Qgc2l6ZVBvd2VyID0gMzIgLSBNYXRoLmNsejMyKGRhdGFMZW5ndGgpO1xuICAgIGxldCBtYXhMZXZlbFNpemUgPSAxIDw8IHNpemVQb3dlcjtcbiAgICBpZiAoZGF0YUxlbmd0aCA9PT0gbWF4TGV2ZWxTaXplIC8gMikge1xuICAgICAgbWF4TGV2ZWxTaXplID0gbWF4TGV2ZWxTaXplID4+PiAxO1xuICAgIH1cbiAgICB0aGlzLm1heExldmVsU2l6ZSA9IG1heExldmVsU2l6ZTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgRmxvYXQ2NEFycmF5KChtYXhMZXZlbFNpemUgKiAyIC0gMSkgKiAyKS5maWxsKE5hTik7XG4gICAgZm9yIChjb25zdCB2YWx1ZXMgb2YgYWxsVmFsdWVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IE51bWJlcih2YWx1ZXNbaV0pO1xuICAgICAgICBjb25zdCBidWZmZXJJbmRleCA9IG1heExldmVsU2l6ZSArIGkgLSAxO1xuICAgICAgICBjb25zdCBidWZmZXJNaW5JbmRleCA9IChidWZmZXJJbmRleCAqIFNQQU4gfCAwKSArIE1JTjtcbiAgICAgICAgY29uc3QgYnVmZmVyTWF4SW5kZXggPSAoYnVmZmVySW5kZXggKiBTUEFOIHwgMCkgKyBNQVg7XG4gICAgICAgIGNvbnN0IHByZXZNaW5WYWx1ZSA9IGJ1ZmZlcltidWZmZXJNaW5JbmRleF07XG4gICAgICAgIGNvbnN0IHByZXZNYXhWYWx1ZSA9IGJ1ZmZlcltidWZmZXJNYXhJbmRleF07XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHByZXZNaW5WYWx1ZSkgfHwgdmFsdWUgPCBwcmV2TWluVmFsdWUpIHtcbiAgICAgICAgICBidWZmZXJbYnVmZmVyTWluSW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocHJldk1heFZhbHVlKSB8fCB2YWx1ZSA+IHByZXZNYXhWYWx1ZSkge1xuICAgICAgICAgIGJ1ZmZlcltidWZmZXJNYXhJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBzaXplID0gbWF4TGV2ZWxTaXplIC8gMiB8IDA7IHNpemUgPj0gMTsgc2l6ZSA9IHNpemUgLyAyIHwgMCkge1xuICAgICAgY29uc3Qgc3RhcnQyID0gc2l6ZSAtIDEgfCAwO1xuICAgICAgY29uc3QgZW5kMiA9IHN0YXJ0MiArIHNpemUgfCAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgbm9kZUluZGV4ID0gc3RhcnQyICsgaTtcbiAgICAgICAgY29uc3QgbGVmdEluZGV4ID0gZW5kMiArIGkgKiAyO1xuICAgICAgICBjb25zdCByaWdodEluZGV4ID0gbGVmdEluZGV4ICsgMTtcbiAgICAgICAgY29uc3QgYU1pbiA9IGJ1ZmZlclsobGVmdEluZGV4ICogU1BBTiB8IDApICsgTUlOXTtcbiAgICAgICAgY29uc3QgYk1pbiA9IGJ1ZmZlclsocmlnaHRJbmRleCAqIFNQQU4gfCAwKSArIE1JTl07XG4gICAgICAgIGJ1ZmZlclsobm9kZUluZGV4ICogU1BBTiB8IDApICsgTUlOXSA9ICFOdW1iZXIuaXNGaW5pdGUoYk1pbikgfHwgYU1pbiA8IGJNaW4gPyBhTWluIDogYk1pbjtcbiAgICAgICAgY29uc3QgYU1heCA9IGJ1ZmZlclsobGVmdEluZGV4ICogU1BBTiB8IDApICsgTUFYXTtcbiAgICAgICAgY29uc3QgYk1heCA9IGJ1ZmZlclsocmlnaHRJbmRleCAqIFNQQU4gfCAwKSArIE1BWF07XG4gICAgICAgIGJ1ZmZlclsobm9kZUluZGV4ICogU1BBTiB8IDApICsgTUFYXSA9ICFOdW1iZXIuaXNGaW5pdGUoYk1heCkgfHwgYU1heCA+IGJNYXggPyBhTWF4IDogYk1heDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gIH1cbiAgY29tcHV0ZVJhbmdlSW50byhidWZmZXIsIHN0YXJ0MiwgZW5kMiwgYnVmZmVySW5kZXgsIGN1cnJlbnRTdGFydCwgc3RlcCwgaW50bykge1xuICAgIGNvbnN0IGN1cnJlbnRFbmQgPSBjdXJyZW50U3RhcnQgKyBzdGVwIC0gMTtcbiAgICBpZiAoY3VycmVudEVuZCA8IHN0YXJ0MiB8fCBjdXJyZW50U3RhcnQgPj0gZW5kMilcbiAgICAgIHJldHVybiBpbnRvO1xuICAgIGlmIChjdXJyZW50U3RhcnQgPj0gc3RhcnQyICYmIGN1cnJlbnRFbmQgPCBlbmQyKSB7XG4gICAgICBjb25zdCBtaW4gPSBidWZmZXJbKGJ1ZmZlckluZGV4ICogU1BBTiB8IDApICsgTUlOXTtcbiAgICAgIGNvbnN0IG1heCA9IGJ1ZmZlclsoYnVmZmVySW5kZXggKiBTUEFOIHwgMCkgKyBNQVhdO1xuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShtaW4pKVxuICAgICAgICBpbnRvWzBdID0gTWF0aC5taW4oaW50b1swXSwgbWluKTtcbiAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUobWF4KSlcbiAgICAgICAgaW50b1sxXSA9IE1hdGgubWF4KGludG9bMV0sIG1heCk7XG4gICAgfSBlbHNlIGlmIChzdGVwID4gMSkge1xuICAgICAgYnVmZmVySW5kZXggPSBidWZmZXJJbmRleCAqIDIgfCAwO1xuICAgICAgc3RlcCA9IHN0ZXAgLyAyIHwgMDtcbiAgICAgIHRoaXMuY29tcHV0ZVJhbmdlSW50byhidWZmZXIsIHN0YXJ0MiwgZW5kMiwgYnVmZmVySW5kZXggKyAxIHwgMCwgY3VycmVudFN0YXJ0LCBzdGVwLCBpbnRvKTtcbiAgICAgIHRoaXMuY29tcHV0ZVJhbmdlSW50byhidWZmZXIsIHN0YXJ0MiwgZW5kMiwgYnVmZmVySW5kZXggKyAyIHwgMCwgY3VycmVudFN0YXJ0ICsgc3RlcCwgc3RlcCwgaW50byk7XG4gICAgfVxuICAgIHJldHVybiBpbnRvO1xuICB9XG4gIHJhbmdlQmV0d2VlbihzdGFydDIsIGVuZDIpIHtcbiAgICBpZiAoc3RhcnQyID4gZW5kMilcbiAgICAgIHJldHVybiBbTmFOLCBOYU5dO1xuICAgIGNvbnN0IHsgbWF4TGV2ZWxTaXplLCBidWZmZXIgfSA9IHRoaXM7XG4gICAgY29uc3QgcmFuZ2UzID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICAgIHRoaXMuY29tcHV0ZVJhbmdlSW50byhidWZmZXIsIHN0YXJ0MiwgZW5kMiwgMCwgMCwgbWF4TGV2ZWxTaXplLCByYW5nZTMpO1xuICAgIHJldHVybiByYW5nZTM7XG4gIH1cbiAgZ2V0IHJhbmdlKCkge1xuICAgIGNvbnN0IHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgIHJldHVybiBbYnVmZmVyW01JTl0sIGJ1ZmZlcltNQVhdXTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZGF0YS9kYXRhTW9kZWwudHNcbnZhciBET01BSU5fUkFOR0VTID0gU3ltYm9sKFwiZG9tYWluLXJhbmdlc1wiKTtcbmZ1bmN0aW9uIHRvS2V5U3RyaW5nKGtleXMpIHtcbiAgcmV0dXJuIGtleXMubWFwKChrZXkpID0+IGlzT2JqZWN0KGtleSkgPyBKU09OLnN0cmluZ2lmeShrZXkpIDoga2V5KS5qb2luKFwiLVwiKTtcbn1cbmZ1bmN0aW9uIHJvdW5kMyh2YWwpIHtcbiAgY29uc3QgYWNjdXJhY3kgPSAxZTQ7XG4gIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbCkpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9IGVsc2UgaWYgKE1hdGguYWJzKHZhbCkgPiBhY2N1cmFjeSkge1xuICAgIHJldHVybiBNYXRoLnRydW5jKHZhbCk7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQodmFsICogYWNjdXJhY3kpIC8gYWNjdXJhY3k7XG59XG5mdW5jdGlvbiBmaXhOdW1lcmljRXh0ZW50KGV4dGVudDIpIHtcbiAgY29uc3QgbnVtYmVyRXh0ZW50ID0gZXh0ZW50Mj8ubWFwKE51bWJlcik7XG4gIHJldHVybiBudW1iZXJFeHRlbnQ/LmV2ZXJ5KE51bWJlci5pc0Zpbml0ZSkgPyBudW1iZXJFeHRlbnQgOiBbXTtcbn1cbmZ1bmN0aW9uIGdldE1pc3NDb3VudChzY29wZVByb3ZpZGVyLCBtaXNzTWFwKSB7XG4gIHJldHVybiBtaXNzTWFwPy5nZXQoc2NvcGVQcm92aWRlci5pZCkgPz8gMDtcbn1cbmZ1bmN0aW9uIGlzU2NvcGVkKG9iaikge1xuICByZXR1cm4gXCJzY29wZXNcIiBpbiBvYmogJiYgQXJyYXkuaXNBcnJheShvYmouc2NvcGVzKTtcbn1cbnZhciBJTlZBTElEX1ZBTFVFID0gU3ltYm9sKFwiaW52YWxpZFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5KGxlbmd0aDIsIHZhbHVlKSB7XG4gIGNvbnN0IG91dCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDI7IGkgKz0gMSkge1xuICAgIG91dFtpXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBkYXR1bUtleXMoa2V5cywgY29sdW1uU2NvcGUsIGRhdHVtSW5kZXgpIHtcbiAgY29uc3Qgb3V0ID0gW107XG4gIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgY29uc3Qga2V5ID0gay5nZXQoY29sdW1uU2NvcGUpPy5bZGF0dW1JbmRleF07XG4gICAgaWYgKGtleSA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIG91dC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGdldFBhdGhDb21wb25lbnRzKHBhdGgpIHtcbiAgY29uc3QgY29tcG9uZW50cyA9IFtdO1xuICBsZXQgbWF0Y2hJbmRleCA9IDA7XG4gIGxldCBtYXRjaEdyb3VwO1xuICBjb25zdCByZWdFeHAgPSAvKCg/Oig/Ol58XFwuKVxccypcXHcrfFxcW1xccyooPzonKD86W14nXXwoPzwhXFxcXClcXFxcJykqJ3xcIig/OlteXCJdfCg/PCFcXFxcKVxcXFxcIikqXCJ8LT9cXGQrKVxccypcXF0pXFxzKikvZztcbiAgd2hpbGUgKG1hdGNoR3JvdXAgPSByZWdFeHAuZXhlYyhwYXRoKSkge1xuICAgIGlmIChtYXRjaEdyb3VwLmluZGV4ICE9PSBtYXRjaEluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hdGNoSW5kZXggPSBtYXRjaEdyb3VwLmluZGV4ICsgbWF0Y2hHcm91cFswXS5sZW5ndGg7XG4gICAgY29uc3QgbWF0Y2ggPSBtYXRjaEdyb3VwWzFdLnRyaW0oKTtcbiAgICBpZiAobWF0Y2guc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICAgIGNvbXBvbmVudHMucHVzaChtYXRjaC5zbGljZSgxKS50cmltKCkpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2guc3RhcnRzV2l0aChcIltcIikpIHtcbiAgICAgIGNvbnN0IGFjY2Vzc29yID0gbWF0Y2guc2xpY2UoMSwgLTEpLnRyaW0oKTtcbiAgICAgIGlmIChhY2Nlc3Nvci5zdGFydHNXaXRoKGAnYCkpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKGFjY2Vzc29yLnNsaWNlKDEsIC0xKS5yZXBsYWNlKC8oPzwhXFxcXClcXFxcJy9nLCBgJ2ApKTtcbiAgICAgIH0gZWxzZSBpZiAoYWNjZXNzb3Iuc3RhcnRzV2l0aChgXCJgKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goYWNjZXNzb3Iuc2xpY2UoMSwgLTEpLnJlcGxhY2UoLyg/PCFcXFxcKVxcXFxcIi9nLCBgXCJgKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goYWNjZXNzb3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnRzLnB1c2gobWF0Y2gpO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hJbmRleCAhPT0gcGF0aC5sZW5ndGgpXG4gICAgcmV0dXJuO1xuICByZXR1cm4gY29tcG9uZW50cztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhBY2Nlc3Nvcihjb21wb25lbnRzKSB7XG4gIHJldHVybiAoZGF0dW0pID0+IHtcbiAgICBsZXQgY3VycmVudCA9IGRhdHVtO1xuICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIGNvbXBvbmVudHMpIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50W2NvbXBvbmVudF07XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50O1xuICB9O1xufVxudmFyIERhdGFNb2RlbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0cywgbW9kZSA9IFwic3RhbmRhbG9uZVwiLCBzdXBwcmVzc0ZpZWxkRG90Tm90YXRpb24gPSBmYWxzZSkge1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB0aGlzLnN1cHByZXNzRmllbGREb3ROb3RhdGlvbiA9IHN1cHByZXNzRmllbGREb3ROb3RhdGlvbjtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwiZGF0YS1tb2RlbFwiKTtcbiAgICB0aGlzLnNjb3BlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgdGhpcy5hZ2dyZWdhdGVzID0gW107XG4gICAgdGhpcy5ncm91cFByb2Nlc3NvcnMgPSBbXTtcbiAgICB0aGlzLnByb3BlcnR5UHJvY2Vzc29ycyA9IFtdO1xuICAgIHRoaXMucmVkdWNlcnMgPSBbXTtcbiAgICB0aGlzLnByb2Nlc3NvcnMgPSBbXTtcbiAgICB0aGlzLm1hcmtTY29wZURhdHVtSW52YWxpZCA9IGZ1bmN0aW9uKHNjb3BlcywgZGF0YSwgZGF0dW1JbmRleCwgaW52YWxpZERhdGEpIHtcbiAgICAgIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgICAgIGlmICghaW52YWxpZERhdGEuaGFzKHNjb3BlKSkge1xuICAgICAgICAgIGludmFsaWREYXRhLnNldChzY29wZSwgY3JlYXRlQXJyYXkoZGF0YS5sZW5ndGgsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaW52YWxpZERhdGEuZ2V0KHNjb3BlKVtkYXR1bUluZGV4XSA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQga2V5cyA9IHRydWU7XG4gICAgZm9yIChjb25zdCBuZXh0IG9mIG9wdHMucHJvcHMpIHtcbiAgICAgIGlmIChuZXh0LnR5cGUgPT09IFwia2V5XCIgJiYgIWtleXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gaW50ZXJuYWwgY29uZmlnIGVycm9yOiBrZXlzIG11c3QgY29tZSBiZWZvcmUgdmFsdWVzLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0LnR5cGUgPT09IFwidmFsdWVcIiAmJiBrZXlzKSB7XG4gICAgICAgIGtleXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdmVyaWZ5TWF0Y2hHcm91cElkID0gKHsgbWF0Y2hHcm91cElkcyA9IFtdIH0pID0+IHtcbiAgICAgIGZvciAoY29uc3QgbWF0Y2hHcm91cElkIG9mIG1hdGNoR3JvdXBJZHMpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVzLmV2ZXJ5KChkZWYpID0+IGRlZi5ncm91cElkICE9PSBtYXRjaEdyb3VwSWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEFHIENoYXJ0cyAtIGludGVybmFsIGNvbmZpZyBlcnJvcjogbWF0Y2hHcm91cElkcyBwcm9wZXJ0aWVzIG11c3QgbWF0Y2ggZGVmaW5lZCBncm91cHMgKCR7bWF0Y2hHcm91cElkfSkuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGtleVNjb3BlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgdmFsdWVTY29wZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgZGVmIG9mIG9wdHMucHJvcHMpIHtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IGRlZi50eXBlID09PSBcImtleVwiID8ga2V5U2NvcGVzIDogdmFsdWVTY29wZXM7XG4gICAgICBpZiAoaXNTY29wZWQoZGVmKSkge1xuICAgICAgICBkZWYuc2NvcGVzPy5mb3JFYWNoKChzKSA9PiBzY29wZXMuYWRkKHMpKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGVmLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImtleVwiOlxuICAgICAgICAgIHRoaXMua2V5cy5wdXNoKHsgLi4uZGVmLCBpbmRleDogdGhpcy5rZXlzLmxlbmd0aCwgbWlzc2luZzogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgaWYgKGRlZi5wcm9wZXJ0eSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBBRyBDaGFydHMgLSBpbnRlcm5hbCBjb25maWcgZXJyb3I6IG5vIHByb3BlcnRpZXMgc3BlY2lmaWVkIGZvciB2YWx1ZSBkZWZpbml0aW9uczogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICBkZWZcbiAgICAgICAgICAgICAgKX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHsgLi4uZGVmLCBpbmRleDogdGhpcy52YWx1ZXMubGVuZ3RoLCBtaXNzaW5nOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWdncmVnYXRlXCI6XG4gICAgICAgICAgdmVyaWZ5TWF0Y2hHcm91cElkKGRlZik7XG4gICAgICAgICAgdGhpcy5hZ2dyZWdhdGVzLnB1c2goeyAuLi5kZWYsIGluZGV4OiB0aGlzLmFnZ3JlZ2F0ZXMubGVuZ3RoIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZ3JvdXAtdmFsdWUtcHJvY2Vzc29yXCI6XG4gICAgICAgICAgdmVyaWZ5TWF0Y2hHcm91cElkKGRlZik7XG4gICAgICAgICAgdGhpcy5ncm91cFByb2Nlc3NvcnMucHVzaCh7IC4uLmRlZiwgaW5kZXg6IHRoaXMuZ3JvdXBQcm9jZXNzb3JzLmxlbmd0aCB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInByb3BlcnR5LXZhbHVlLXByb2Nlc3NvclwiOlxuICAgICAgICAgIHRoaXMucHJvcGVydHlQcm9jZXNzb3JzLnB1c2goeyAuLi5kZWYsIGluZGV4OiB0aGlzLnByb3BlcnR5UHJvY2Vzc29ycy5sZW5ndGggfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWR1Y2VyXCI6XG4gICAgICAgICAgdGhpcy5yZWR1Y2Vycy5wdXNoKHsgLi4uZGVmLCBpbmRleDogdGhpcy5yZWR1Y2Vycy5sZW5ndGggfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwcm9jZXNzb3JcIjpcbiAgICAgICAgICB0aGlzLnByb2Nlc3NvcnMucHVzaCh7IC4uLmRlZiwgaW5kZXg6IHRoaXMucHJvY2Vzc29ycy5sZW5ndGggfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIXRoaXMub3B0cy5ncm91cEJ5S2V5cyB8fCB0aGlzLm9wdHMuZ3JvdXBCeUZuICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHVuZ3JvdXBlZFNjb3BlcyA9IG5ldyBTZXQodmFsdWVTY29wZXMudmFsdWVzKCkpO1xuICAgICAga2V5U2NvcGVzLmZvckVhY2goKHMpID0+IHVuZ3JvdXBlZFNjb3Blcy5kZWxldGUocykpO1xuICAgICAgaWYgKHVuZ3JvdXBlZFNjb3Blcy5zaXplID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEFHIENoYXJ0cyAtIHNjb3BlcyBtaXNzaW5nIGtleSBmb3IgZ3JvdXBpbmcsIGlsbGVnYWwgY29uZmlndXJhdGlvbjogJHtbLi4udW5ncm91cGVkU2NvcGVzLnZhbHVlcygpXX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZChzY29wZSwgc2VhcmNoSWQpIHtcbiAgICBjb25zdCBkZWYgPSB0aGlzLnNjb3BlQ2FjaGUuZ2V0KHNjb3BlLmlkKT8uZ2V0KHNlYXJjaElkKTtcbiAgICBpZiAoIWRlZikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBkaWRuJ3QgZmluZCBwcm9wZXJ0eSBkZWZpbml0aW9uIGZvciBbJHtzZWFyY2hJZH0sICR7c2NvcGUuaWR9XWApO1xuICAgIH1cbiAgICByZXR1cm4geyBpbmRleDogZGVmLmluZGV4LCBkZWYgfTtcbiAgfVxuICByZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZChzY29wZSwgc2VhcmNoSWQpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQoc2NvcGUsIHNlYXJjaElkKS5pbmRleDtcbiAgfVxuICByZXNvbHZlS2V5c0J5SWQoc2NvcGUsIHNlYXJjaElkLCBwcm9jZXNzZWREYXRhKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHNjb3BlLCBzZWFyY2hJZCk7XG4gICAgY29uc3Qga2V5cyA9IHByb2Nlc3NlZERhdGEua2V5c1tpbmRleF07XG4gICAgaWYgKGtleXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBkaWRuJ3QgZmluZCBrZXlzIGZvciBbJHtzZWFyY2hJZH0sICR7c2NvcGUuaWR9XWApO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cy5nZXQoc2NvcGUuaWQpO1xuICB9XG4gIGhhc0NvbHVtbkJ5SWQoc2NvcGUsIHNlYXJjaElkKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NvcGVDYWNoZS5nZXQoc2NvcGUuaWQpPy5nZXQoc2VhcmNoSWQpICE9IG51bGw7XG4gIH1cbiAgcmVzb2x2ZUNvbHVtbkJ5SWQoc2NvcGUsIHNlYXJjaElkLCBwcm9jZXNzZWREYXRhKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHNjb3BlLCBzZWFyY2hJZCk7XG4gICAgY29uc3QgY29sdW1uID0gcHJvY2Vzc2VkRGF0YS5jb2x1bW5zPy5baW5kZXhdO1xuICAgIGlmIChjb2x1bW4gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBkaWRuJ3QgZmluZCBjb2x1bW4gZm9yIFske3NlYXJjaElkfSwgJHtzY29wZS5pZH1dYCk7XG4gICAgfVxuICAgIHJldHVybiBjb2x1bW47XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEgY29udmVuaWVuY2UgaXRlcmF0b3IgdG8gaXRlcmF0ZSBvdmVyIGFsbCBvZiB0aGUgZXh0cmFjdCBkYXR1bSB2YWx1ZXMgaW4gYVxuICAgKiBzcGVjaWZpYyBEYXRhR3JvdXAuXG4gICAqXG4gICAqIEBwYXJhbSBzY29wZSB0byB3aGljaCBkYXR1bXMgc2hvdWxkIGJlbG9uZ1xuICAgKiBAcGFyYW0gZ3JvdXAgY29udGFpbmluZyB0aGUgZGF0dW1zXG4gICAqIEBwYXJhbSBwcm9jZXNzZWREYXRhIGNvbnRhaW5pbmcgdGhlIGdyb3VwXG4gICAqL1xuICAqZm9yRWFjaERhdHVtKHNjb3BlLCBwcm9jZXNzZWREYXRhLCBncm91cCkge1xuICAgIGNvbnN0IGNvbHVtbkluZGV4ID0gcHJvY2Vzc2VkRGF0YS5jb2x1bW5TY29wZXMuZmluZEluZGV4KChzKSA9PiBzLmhhcyhzY29wZS5pZCkpO1xuICAgIGZvciAoY29uc3QgZGF0dW1JbmRleCBvZiBncm91cC5kYXR1bUluZGljZXNbY29sdW1uSW5kZXhdID8/IFtdKSB7XG4gICAgICB5aWVsZCBwcm9jZXNzZWREYXRhLmNvbHVtbnNbY29sdW1uSW5kZXhdW2RhdHVtSW5kZXhdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgYSBjb252ZW5pZW5jZSBpdGVyYXRvciB0byBpdGVyYXRlIG92ZXIgYWxsIG9mIHRoZSBleHRyYWN0ZWQgZGF0dW0gdmFsdWVzIGluIGFcbiAgICogR3JvdXBlZERhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBzY29wZSB0byB3aGljaCBkYXR1bXMgc2hvdWxkIGJlbG9uZ1xuICAgKiBAcGFyYW0gcHJvY2Vzc2VkRGF0YSB0byBpdGVyYXRlIHRocm91Z2hcbiAgICovXG4gICpmb3JFYWNoR3JvdXBEYXR1bShzY29wZSwgcHJvY2Vzc2VkRGF0YSkge1xuICAgIGNvbnN0IGNvbHVtbkluZGV4ID0gcHJvY2Vzc2VkRGF0YS5jb2x1bW5TY29wZXMuZmluZEluZGV4KChzKSA9PiBzLmhhcyhzY29wZS5pZCkpO1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIGdyb3VwSW5kZXg6IDAsXG4gICAgICBjb2x1bW5JbmRleFxuICAgIH07XG4gICAgY29uc3QgZW1wdHkgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHByb2Nlc3NlZERhdGEuZ3JvdXBzKSB7XG4gICAgICBvdXRwdXQuZ3JvdXAgPSBncm91cDtcbiAgICAgIGxldCB2YWx1ZUluZGV4ID0gMDtcbiAgICAgIGZvciAoY29uc3QgZGF0dW1JbmRleCBvZiBncm91cC5kYXR1bUluZGljZXNbY29sdW1uSW5kZXhdID8/IGVtcHR5KSB7XG4gICAgICAgIG91dHB1dC5kYXR1bUluZGV4ID0gZGF0dW1JbmRleDtcbiAgICAgICAgb3V0cHV0LnZhbHVlSW5kZXggPSB2YWx1ZUluZGV4Kys7XG4gICAgICAgIHlpZWxkIG91dHB1dDtcbiAgICAgIH1cbiAgICAgIG91dHB1dC5ncm91cEluZGV4Kys7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIHdpbmRvdy1iYXNlZCBjb252ZW5pZW5jZSBpdGVyYXRvciB0byBpdGVyYXRlIG92ZXIgYWxsIG9mIHRoZSBleHRyYWN0ZWQgZGF0dW1cbiAgICogdmFsdWVzIGluIGEgR3JvdXBlZERhdGEsIGluY2x1ZGluZyB0aGUgcHJldmlvdXMgYW5kIG5leHQgZW50cmllcyByZWxhdGl2ZSB0byBlYWNoIGRhdHVtLlxuICAgKlxuICAgKiBAcGFyYW0gc2NvcGUgdG8gd2hpY2ggZGF0dW1zIHNob3VsZCBiZWxvbmdcbiAgICogQHBhcmFtIHByb2Nlc3NlZERhdGEgdG8gaXRlcmF0ZSB0aHJvdWdoXG4gICAqL1xuICAqZm9yRWFjaEdyb3VwRGF0dW1UdXBsZShzY29wZSwgcHJvY2Vzc2VkRGF0YSkge1xuICAgIGNvbnN0IGNvbHVtbkluZGV4ID0gcHJvY2Vzc2VkRGF0YS5jb2x1bW5TY29wZXMuZmluZEluZGV4KChzKSA9PiBzLmhhcyhzY29wZS5pZCkpO1xuICAgIGNvbnN0IG91dHB1dCA9IHsgY29sdW1uSW5kZXgsIGRhdHVtSW5kZXhlczogW3ZvaWQgMCwgdm9pZCAwLCB2b2lkIDBdIH07XG4gICAgZm9yIChjb25zdCBuZXh0IG9mIHRoaXMuZm9yRWFjaEdyb3VwRGF0dW0oc2NvcGUsIHByb2Nlc3NlZERhdGEpKSB7XG4gICAgICBvdXRwdXQuZ3JvdXAgPSBvdXRwdXQubmV4dEdyb3VwO1xuICAgICAgb3V0cHV0Lmdyb3VwSW5kZXggPSBvdXRwdXQubmV4dEdyb3VwSW5kZXg7XG4gICAgICBvdXRwdXQubmV4dEdyb3VwID0gbmV4dC5ncm91cDtcbiAgICAgIG91dHB1dC5uZXh0R3JvdXBJbmRleCA9IG5leHQuZ3JvdXBJbmRleDtcbiAgICAgIG91dHB1dC5kYXR1bUluZGV4ZXNbMF0gPSBvdXRwdXQuZGF0dW1JbmRleGVzWzFdO1xuICAgICAgb3V0cHV0LmRhdHVtSW5kZXhlc1sxXSA9IG91dHB1dC5kYXR1bUluZGV4ZXNbMl07XG4gICAgICBvdXRwdXQuZGF0dW1JbmRleGVzWzJdID0gbmV4dC5kYXR1bUluZGV4O1xuICAgICAgaWYgKG91dHB1dC5ncm91cCAhPSBudWxsICYmIG91dHB1dC5kYXR1bUluZGV4ZXNbMV0gIT0gbnVsbCkge1xuICAgICAgICB5aWVsZCBvdXRwdXQ7XG4gICAgICB9XG4gICAgfVxuICAgIG91dHB1dC5ncm91cCA9IG91dHB1dC5uZXh0R3JvdXA7XG4gICAgb3V0cHV0Lmdyb3VwSW5kZXggPSBvdXRwdXQubmV4dEdyb3VwSW5kZXg7XG4gICAgb3V0cHV0Lm5leHRHcm91cCA9IHZvaWQgMDtcbiAgICBvdXRwdXQubmV4dEdyb3VwSW5kZXggPSB2b2lkIDA7XG4gICAgb3V0cHV0LmRhdHVtSW5kZXhlc1swXSA9IG91dHB1dC5kYXR1bUluZGV4ZXNbMV07XG4gICAgb3V0cHV0LmRhdHVtSW5kZXhlc1sxXSA9IG91dHB1dC5kYXR1bUluZGV4ZXNbMl07XG4gICAgb3V0cHV0LmRhdHVtSW5kZXhlc1syXSA9IHZvaWQgMDtcbiAgICBpZiAob3V0cHV0Lmdyb3VwICE9IG51bGwgJiYgb3V0cHV0LmRhdHVtSW5kZXhlc1sxXSAhPSBudWxsKSB7XG4gICAgICB5aWVsZCBvdXRwdXQ7XG4gICAgfVxuICB9XG4gIGdldERvbWFpbihzY29wZSwgc2VhcmNoSWQsIHR5cGUsIHByb2Nlc3NlZERhdGEpIHtcbiAgICBjb25zdCBkb21haW5zID0gdGhpcy5nZXREb21haW5zQnlUeXBlKHR5cGUgPz8gXCJ2YWx1ZVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgICByZXR1cm4gZG9tYWlucz8uW3RoaXMucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQoc2NvcGUsIHNlYXJjaElkKV0gPz8gW107XG4gIH1cbiAgZ2V0RG9tYWluQmV0d2VlblJhbmdlKHNjb3BlLCBzZWFyY2hJZHMsIFtpMCwgaTFdLCBwcm9jZXNzZWREYXRhKSB7XG4gICAgY29uc3QgY29sdW1uSW5kaWNlcyA9IHNlYXJjaElkcy5tYXAoKHNlYXJjaElkKSA9PiB0aGlzLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHNjb3BlLCBzZWFyY2hJZCkpO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gY29sdW1uSW5kaWNlcy5qb2luKFwiOlwiKTtcbiAgICBjb25zdCBkb21haW5SYW5nZXMgPSBwcm9jZXNzZWREYXRhW0RPTUFJTl9SQU5HRVNdO1xuICAgIGxldCByYW5nZUxvb2t1cCA9IGRvbWFpblJhbmdlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGlmIChyYW5nZUxvb2t1cCA9PSBudWxsKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBjb2x1bW5JbmRpY2VzLm1hcCgoY29sdW1uSW5kZXgpID0+IHByb2Nlc3NlZERhdGEuY29sdW1uc1tjb2x1bW5JbmRleF0pO1xuICAgICAgcmFuZ2VMb29rdXAgPSBuZXcgUmFuZ2VMb29rdXAodmFsdWVzKTtcbiAgICAgIGRvbWFpblJhbmdlcy5zZXQoY2FjaGVLZXksIHJhbmdlTG9va3VwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlTG9va3VwLnJhbmdlQmV0d2VlbihpMCwgaTEpO1xuICB9XG4gIGdldERvbWFpbnNCeVR5cGUodHlwZSwgcHJvY2Vzc2VkRGF0YSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImtleVwiOlxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRGF0YS5kb21haW4ua2V5cztcbiAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRGF0YS5kb21haW4udmFsdWVzO1xuICAgICAgY2FzZSBcImFnZ3JlZ2F0ZVwiOlxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRGF0YS5kb21haW4uYWdnVmFsdWVzO1xuICAgICAgY2FzZSBcImdyb3VwLXZhbHVlLXByb2Nlc3NvclwiOlxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRGF0YS5kb21haW4uZ3JvdXBzO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHByb2Nlc3NEYXRhKHNvdXJjZXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcHRzOiB7IGdyb3VwQnlLZXlzLCBncm91cEJ5Rm4gfSxcbiAgICAgIGFnZ3JlZ2F0ZXMsXG4gICAgICBncm91cFByb2Nlc3NvcnMsXG4gICAgICByZWR1Y2VycyxcbiAgICAgIHByb2Nlc3NvcnMsXG4gICAgICBwcm9wZXJ0eVByb2Nlc3NvcnNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzdGFydDIgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoZ3JvdXBCeUtleXMgJiYgdGhpcy5rZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcHJvY2Vzc2VkRGF0YSA9IHRoaXMuZXh0cmFjdERhdGEoc291cmNlcyk7XG4gICAgaWYgKGdyb3VwQnlLZXlzKSB7XG4gICAgICBwcm9jZXNzZWREYXRhID0gdGhpcy5ncm91cERhdGEocHJvY2Vzc2VkRGF0YSk7XG4gICAgfSBlbHNlIGlmIChncm91cEJ5Rm4pIHtcbiAgICAgIHByb2Nlc3NlZERhdGEgPSB0aGlzLmdyb3VwRGF0YShwcm9jZXNzZWREYXRhLCBncm91cEJ5Rm4ocHJvY2Vzc2VkRGF0YSkpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXBQcm9jZXNzb3JzLmxlbmd0aCA+IDAgJiYgcHJvY2Vzc2VkRGF0YS50eXBlID09PSBcImdyb3VwZWRcIikge1xuICAgICAgdGhpcy5wb3N0UHJvY2Vzc0dyb3Vwcyhwcm9jZXNzZWREYXRhKTtcbiAgICB9XG4gICAgaWYgKGFnZ3JlZ2F0ZXMubGVuZ3RoID4gMCAmJiBwcm9jZXNzZWREYXRhLnR5cGUgPT09IFwidW5ncm91cGVkXCIpIHtcbiAgICAgIHRoaXMuYWdncmVnYXRlVW5ncm91cGVkRGF0YShwcm9jZXNzZWREYXRhKTtcbiAgICB9IGVsc2UgaWYgKGFnZ3JlZ2F0ZXMubGVuZ3RoID4gMCAmJiBwcm9jZXNzZWREYXRhLnR5cGUgPT09IFwiZ3JvdXBlZFwiKSB7XG4gICAgICB0aGlzLmFnZ3JlZ2F0ZUdyb3VwZWREYXRhKHByb2Nlc3NlZERhdGEpO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHlQcm9jZXNzb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucG9zdFByb2Nlc3NQcm9wZXJ0aWVzKHByb2Nlc3NlZERhdGEpO1xuICAgIH1cbiAgICBpZiAocmVkdWNlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5yZWR1Y2VEYXRhKHByb2Nlc3NlZERhdGEpO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzc29ycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnBvc3RQcm9jZXNzRGF0YShwcm9jZXNzZWREYXRhKTtcbiAgICB9XG4gICAgdGhpcy53YXJuRGF0YU1pc3NpbmdQcm9wZXJ0aWVzKHNvdXJjZXMpO1xuICAgIGNvbnN0IGVuZDIgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBwcm9jZXNzZWREYXRhLnRpbWUgPSBlbmQyIC0gc3RhcnQyO1xuICAgIGlmICh0aGlzLmRlYnVnLmNoZWNrKCkpIHtcbiAgICAgIGxvZ1Byb2Nlc3NlZERhdGEocHJvY2Vzc2VkRGF0YSk7XG4gICAgfVxuICAgIHRoaXMucHJvY2Vzc1Njb3BlQ2FjaGUoKTtcbiAgICByZXR1cm4gcHJvY2Vzc2VkRGF0YTtcbiAgfVxuICB3YXJuRGF0YU1pc3NpbmdQcm9wZXJ0aWVzKHNvdXJjZXMpIHtcbiAgICBpZiAoc291cmNlcy5zaXplID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgZGVmIG9mIGl0ZXJhdGUodGhpcy5rZXlzLCB0aGlzLnZhbHVlcykpIHtcbiAgICAgIGZvciAoY29uc3QgW3Njb3BlLCBtaXNzQ291bnRdIG9mIGRlZi5taXNzaW5nKSB7XG4gICAgICAgIGlmIChtaXNzQ291bnQgPCAoc291cmNlcy5nZXQoc2NvcGUpPy5sZW5ndGggPz8gSW5maW5pdHkpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBzY29wZUhpbnQgPSBzY29wZSA9PSBudWxsID8gXCJcIiA6IGAgZm9yICR7c2NvcGV9YDtcbiAgICAgICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoYHRoZSBrZXkgJyR7ZGVmLnByb3BlcnR5fScgd2FzIG5vdCBmb3VuZCBpbiBhbnkgZGF0YSBlbGVtZW50JHtzY29wZUhpbnR9LmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwcm9jZXNzU2NvcGVDYWNoZSgpIHtcbiAgICB0aGlzLnNjb3BlQ2FjaGUuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGRlZiBvZiBpdGVyYXRlKHRoaXMua2V5cywgdGhpcy52YWx1ZXMsIHRoaXMuYWdncmVnYXRlcykpIHtcbiAgICAgIGlmICghZGVmLmlkc01hcClcbiAgICAgICAgY29udGludWU7XG4gICAgICBmb3IgKGNvbnN0IFtzY29wZSwgaWRzXSBvZiBkZWYuaWRzTWFwKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLnNjb3BlQ2FjaGUuaGFzKHNjb3BlKSkge1xuICAgICAgICAgICAgdGhpcy5zY29wZUNhY2hlLnNldChzY29wZSwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1tpZCwgZGVmXV0pKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2NvcGVDYWNoZS5nZXQoc2NvcGUpPy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkdXBsaWNhdGUgZGVmaW5pdGlvbiBpZHMgb24gdGhlIHNhbWUgc2NvcGUgYXJlIG5vdCBhbGxvd2VkLlwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY29wZUNhY2hlLmdldChzY29wZSkuc2V0KGlkLCBkZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YWx1ZUdyb3VwSWR4TG9va3VwKHsgbWF0Y2hHcm91cElkcyB9KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGRlZl0gb2YgdGhpcy52YWx1ZXMuZW50cmllcygpKSB7XG4gICAgICBpZiAoIW1hdGNoR3JvdXBJZHMgfHwgZGVmLmdyb3VwSWQgJiYgbWF0Y2hHcm91cElkcy5pbmNsdWRlcyhkZWYuZ3JvdXBJZCkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhbHVlSWR4TG9va3VwKHNjb3BlcywgcHJvcCkge1xuICAgIGNvbnN0IG5vU2NvcGVzVG9NYXRjaCA9IHNjb3BlcyA9PSBudWxsIHx8IHNjb3Blcy5sZW5ndGggPT09IDA7XG4gICAgY29uc3QgcHJvcElkID0gdHlwZW9mIHByb3AgPT09IFwic3RyaW5nXCIgPyBwcm9wIDogcHJvcC5pZDtcbiAgICBjb25zdCBoYXNNYXRjaGluZ1Njb3BlSWQgPSAoZGVmKSA9PiB7XG4gICAgICBpZiAoZGVmLmlkc01hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtzY29wZSwgaWRzXSBvZiBkZWYuaWRzTWFwKSB7XG4gICAgICAgICAgaWYgKHNjb3Blcz8uaW5jbHVkZXMoc2NvcGUpICYmIGlkcy5oYXMocHJvcElkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZhbHVlcy5yZWR1Y2UoKHJlcywgZGVmLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWREZWZTY29wZXMgPSBkZWYuc2NvcGVzID09IG51bGwgfHwgbm9TY29wZXNUb01hdGNoICYmICFkZWYuc2NvcGVzLmxlbmd0aCB8fCBkZWYuc2NvcGVzLnNvbWUoKHMpID0+IHNjb3Blcz8uaW5jbHVkZXMocykpO1xuICAgICAgaWYgKHZhbGlkRGVmU2NvcGVzICYmIChkZWYucHJvcGVydHkgPT09IHByb3BJZCB8fCBkZWYuaWQgPT09IHByb3BJZCB8fCBoYXNNYXRjaGluZ1Njb3BlSWQoZGVmKSkpIHtcbiAgICAgICAgcmVzLnB1c2goaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCBbXSk7XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEFHIENoYXJ0cyAtIGNvbmZpZ3VyYXRpb24gZXJyb3IsIHVua25vd24gcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShwcm9wKX0gaW4gc2NvcGUocykgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBzY29wZXNcbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGV4dHJhY3REYXRhKHNvdXJjZXMpIHtcbiAgICBjb25zdCB7IGRhdGFEb21haW4sIHByb2Nlc3NWYWx1ZSwgYWxsU2NvcGVzSGF2ZVNhbWVEZWZzIH0gPSB0aGlzLmluaXREYXRhRG9tYWluUHJvY2Vzc29yKCk7XG4gICAgY29uc3QgeyBrZXlzOiBrZXlEZWZzLCB2YWx1ZXM6IHZhbHVlRGVmcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGludmFsaWREYXRhLCBpbnZhbGlkS2V5cywgYWxsS2V5TWFwcGluZ3MgfSA9IHRoaXMuZXh0cmFjdEtleXMoa2V5RGVmcywgc291cmNlcywgcHJvY2Vzc1ZhbHVlKTtcbiAgICBjb25zdCB7IGNvbHVtbnMsIGNvbHVtblNjb3BlcywgcGFydGlhbFZhbGlkRGF0YUNvdW50LCBtYXhEYXRhTGVuZ3RoIH0gPSB0aGlzLmV4dHJhY3RWYWx1ZXMoXG4gICAgICBpbnZhbGlkRGF0YSxcbiAgICAgIHZhbHVlRGVmcyxcbiAgICAgIHNvdXJjZXMsXG4gICAgICBpbnZhbGlkS2V5cyxcbiAgICAgIHByb2Nlc3NWYWx1ZVxuICAgICk7XG4gICAgY29uc3QgcHJvcGVydHlEb21haW4gPSAoZGVmKSA9PiB7XG4gICAgICBjb25zdCBkZWZEb21haW4gPSBkYXRhRG9tYWluLmdldChkZWYpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZGVmRG9tYWluLmdldERvbWFpbigpO1xuICAgICAgaWYgKENvbnRpbnVvdXNEb21haW4uaXMoZGVmRG9tYWluKSAmJiByZXN1bHRbMF0gPiByZXN1bHRbMV0pIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInVuZ3JvdXBlZFwiLFxuICAgICAgaW5wdXQ6IHsgY291bnQ6IG1heERhdGFMZW5ndGggfSxcbiAgICAgIHNjb3BlczogbmV3IFNldChzb3VyY2VzLmtleXMoKSksXG4gICAgICBkYXRhU291cmNlczogc291cmNlcyxcbiAgICAgIGFnZ3JlZ2F0aW9uOiB2b2lkIDAsXG4gICAgICBrZXlzOiBbLi4uYWxsS2V5TWFwcGluZ3MudmFsdWVzKCldLFxuICAgICAgY29sdW1ucyxcbiAgICAgIGNvbHVtblNjb3BlcyxcbiAgICAgIGludmFsaWRLZXlzLFxuICAgICAgaW52YWxpZERhdGEsXG4gICAgICBkb21haW46IHtcbiAgICAgICAga2V5czoga2V5RGVmcy5tYXAocHJvcGVydHlEb21haW4pLFxuICAgICAgICB2YWx1ZXM6IHZhbHVlRGVmcy5tYXAocHJvcGVydHlEb21haW4pXG4gICAgICB9LFxuICAgICAgZGVmczoge1xuICAgICAgICBhbGxTY29wZXNIYXZlU2FtZURlZnMsXG4gICAgICAgIGtleXM6IGtleURlZnMsXG4gICAgICAgIHZhbHVlczogdmFsdWVEZWZzXG4gICAgICB9LFxuICAgICAgcGFydGlhbFZhbGlkRGF0YUNvdW50LFxuICAgICAgdGltZTogMCxcbiAgICAgIFtET01BSU5fUkFOR0VTXTogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICAgIH07XG4gIH1cbiAgZXh0cmFjdEtleXMoa2V5RGVmcywgc291cmNlcywgcHJvY2Vzc1ZhbHVlKSB7XG4gICAgY29uc3QgaW52YWxpZEtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGludmFsaWREYXRhID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBhbGxLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQga2V5RGVmS2V5cztcbiAgICBsZXQgc2NvcGVEYXRhUHJvY2Vzc2VkO1xuICAgIGNvbnN0IGNsb25lU2NvcGUgPSAoc291cmNlLCB0YXJnZXQpID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZVNjb3BlID0gc2NvcGVEYXRhUHJvY2Vzc2VkLmdldChzb3VyY2UpO1xuICAgICAga2V5RGVmS2V5cy5zZXQodGFyZ2V0LCBrZXlEZWZLZXlzLmdldChzb3VyY2VTY29wZSkpO1xuICAgICAgaWYgKGludmFsaWRLZXlzLmhhcyhzb3VyY2VTY29wZSkpIHtcbiAgICAgICAgaW52YWxpZEtleXMuc2V0KHRhcmdldCwgaW52YWxpZEtleXMuZ2V0KHNvdXJjZVNjb3BlKSk7XG4gICAgICAgIGludmFsaWREYXRhLnNldCh0YXJnZXQsIGludmFsaWREYXRhLmdldChzb3VyY2VTY29wZSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBrZXlEZWYgb2Yga2V5RGVmcykge1xuICAgICAgY29uc3QgeyBpbnZhbGlkVmFsdWUsIHNjb3Blczoga2V5U2NvcGVzIH0gPSBrZXlEZWY7XG4gICAgICBrZXlEZWZLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHNjb3BlRGF0YVByb2Nlc3NlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBhbGxLZXlzLnNldChrZXlEZWYsIGtleURlZktleXMpO1xuICAgICAgZm9yIChjb25zdCBzY29wZSBvZiBrZXlTY29wZXMgPz8gW10pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHNvdXJjZXMuZ2V0KHNjb3BlKSA/PyBbXTtcbiAgICAgICAgaWYgKHNjb3BlRGF0YVByb2Nlc3NlZC5oYXMoZGF0YSkpIHtcbiAgICAgICAgICBjbG9uZVNjb3BlKGRhdGEsIHNjb3BlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgIGtleURlZktleXMuc2V0KHNjb3BlLCBrZXlzKTtcbiAgICAgICAgc2NvcGVEYXRhUHJvY2Vzc2VkLnNldChkYXRhLCBzY29wZSk7XG4gICAgICAgIGxldCBpbnZhbGlkU2NvcGVLZXlzO1xuICAgICAgICBsZXQgaW52YWxpZFNjb3BlRGF0YTtcbiAgICAgICAgZm9yIChsZXQgZGF0dW1JbmRleCA9IDA7IGRhdHVtSW5kZXggPCBkYXRhLmxlbmd0aDsgZGF0dW1JbmRleCsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gcHJvY2Vzc1ZhbHVlKGtleURlZiwgZGF0YVtkYXR1bUluZGV4XSwgZGF0dW1JbmRleCwgc2NvcGUpO1xuICAgICAgICAgIGlmIChrZXkgIT09IElOVkFMSURfVkFMVUUpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleXMucHVzaChpbnZhbGlkVmFsdWUpO1xuICAgICAgICAgIGludmFsaWRTY29wZUtleXMgPz8gKGludmFsaWRTY29wZUtleXMgPSBjcmVhdGVBcnJheShkYXRhLmxlbmd0aCwgZmFsc2UpKTtcbiAgICAgICAgICBpbnZhbGlkU2NvcGVEYXRhID8/IChpbnZhbGlkU2NvcGVEYXRhID0gY3JlYXRlQXJyYXkoZGF0YS5sZW5ndGgsIGZhbHNlKSk7XG4gICAgICAgICAgaW52YWxpZFNjb3BlS2V5c1tkYXR1bUluZGV4XSA9IHRydWU7XG4gICAgICAgICAgaW52YWxpZFNjb3BlRGF0YVtkYXR1bUluZGV4XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludmFsaWRTY29wZUtleXMgJiYgaW52YWxpZFNjb3BlRGF0YSkge1xuICAgICAgICAgIGludmFsaWRLZXlzLnNldChzY29wZSwgaW52YWxpZFNjb3BlS2V5cyk7XG4gICAgICAgICAgaW52YWxpZERhdGEuc2V0KHNjb3BlLCBpbnZhbGlkU2NvcGVEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBpbnZhbGlkRGF0YSwgaW52YWxpZEtleXMsIGFsbEtleU1hcHBpbmdzOiBhbGxLZXlzIH07XG4gIH1cbiAgZXh0cmFjdFZhbHVlcyhpbnZhbGlkRGF0YSwgdmFsdWVEZWZzLCBzb3VyY2VzLCBpbnZhbGlkS2V5cywgcHJvY2Vzc1ZhbHVlKSB7XG4gICAgbGV0IHBhcnRpYWxWYWxpZERhdGFDb3VudCA9IDA7XG4gICAgY29uc3QgY29sdW1ucyA9IFtdO1xuICAgIGNvbnN0IGFsbENvbHVtblNjb3BlcyA9IFtdO1xuICAgIGxldCBtYXhEYXRhTGVuZ3RoID0gMDtcbiAgICBmb3IgKGNvbnN0IGRlZiBvZiB2YWx1ZURlZnMpIHtcbiAgICAgIGNvbnN0IHsgaW52YWxpZFZhbHVlIH0gPSBkZWY7XG4gICAgICBjb25zdCB2YWx1ZVNvdXJjZXMgPSBuZXcgU2V0KGRlZi5zY29wZXMubWFwKChzKSA9PiBzb3VyY2VzLmdldChzKSkpO1xuICAgICAgaWYgKHZhbHVlU291cmNlcy5zaXplID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIG1vcmUgdGhhbiBvbmUgZGF0YSBzb3VyY2UgZm9yOiAke0pTT04uc3RyaW5naWZ5KGRlZil9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb2x1bW5TY29wZXMgPSBuZXcgU2V0KGRlZi5zY29wZXMpO1xuICAgICAgY29uc3QgY29sdW1uU2NvcGUgPSBmaXJzdChkZWYuc2NvcGVzKTtcbiAgICAgIGNvbnN0IGNvbHVtblNvdXJjZSA9IHNvdXJjZXMuZ2V0KGNvbHVtblNjb3BlKTtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtblNvdXJjZS5tYXAoKHZhbHVlRGF0dW0sIGRhdHVtSW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgaW52YWxpZEtleSA9IGludmFsaWRLZXlzLmdldChjb2x1bW5TY29wZSk/LltkYXR1bUluZGV4XTtcbiAgICAgICAgbGV0IHZhbHVlID0gcHJvY2Vzc1ZhbHVlKGRlZiwgdmFsdWVEYXR1bSwgZGF0dW1JbmRleCwgZGVmLnNjb3Blcyk7XG4gICAgICAgIGlmIChpbnZhbGlkS2V5IHx8IHZhbHVlID09PSBJTlZBTElEX1ZBTFVFKSB7XG4gICAgICAgICAgdGhpcy5tYXJrU2NvcGVEYXR1bUludmFsaWQoZGVmLnNjb3BlcywgY29sdW1uU291cmNlLCBkYXR1bUluZGV4LCBpbnZhbGlkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludmFsaWRLZXkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGludmFsaWRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gSU5WQUxJRF9WQUxVRSkge1xuICAgICAgICAgIHBhcnRpYWxWYWxpZERhdGFDb3VudCArPSAxO1xuICAgICAgICAgIHZhbHVlID0gaW52YWxpZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgY29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICBhbGxDb2x1bW5TY29wZXMucHVzaChjb2x1bW5TY29wZXMpO1xuICAgICAgbWF4RGF0YUxlbmd0aCA9IE1hdGgubWF4KG1heERhdGFMZW5ndGgsIGNvbHVtbi5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4geyBjb2x1bW5zLCBjb2x1bW5TY29wZXM6IGFsbENvbHVtblNjb3BlcywgcGFydGlhbFZhbGlkRGF0YUNvdW50LCBtYXhEYXRhTGVuZ3RoIH07XG4gIH1cbiAgZ3JvdXBEYXRhKGRhdGEsIGdyb3VwaW5nRm4pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZ3JvdXBzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCB7IGtleXM6IGRhdGFLZXlzLCBjb2x1bW5zOiBhbGxDb2x1bW5zLCBjb2x1bW5TY29wZXMsIGludmFsaWRLZXlzLCBpbnZhbGlkRGF0YSB9ID0gZGF0YTtcbiAgICBjb25zdCBhbGxTY29wZXMgPSBkYXRhLnNjb3BlcztcbiAgICBjb25zdCBwcm9jZXNzZWRDb2x1bW5JbmRleGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIGFsbFNjb3Blcykge1xuICAgICAgY29uc3Qgc2NvcGVDb2x1bW5JbmRleGVzID0gYWxsQ29sdW1ucy5tYXAoKF8sIGlkeCkgPT4gaWR4KS5maWx0ZXIoKGlkeCkgPT4gIXByb2Nlc3NlZENvbHVtbkluZGV4ZXMuaGFzKGlkeCkgJiYgY29sdW1uU2NvcGVzW2lkeF0uaGFzKHNjb3BlKSk7XG4gICAgICBpZiAoc2NvcGVDb2x1bW5JbmRleGVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBmb3IgKGNvbnN0IGlkeCBvZiBzY29wZUNvbHVtbkluZGV4ZXMpIHtcbiAgICAgICAgcHJvY2Vzc2VkQ29sdW1uSW5kZXhlcy5hZGQoaWR4KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpYmxpbmdTY29wZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgZm9yIChjb25zdCBjb2x1bW5JZHggb2Ygc2NvcGVDb2x1bW5JbmRleGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uU2NvcGUgb2YgY29sdW1uU2NvcGVzW2NvbHVtbklkeF0pIHtcbiAgICAgICAgICBzaWJsaW5nU2NvcGVzLmFkZChjb2x1bW5TY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjb3BlS2V5cyA9IGRhdGFLZXlzLm1hcCgoaykgPT4gay5nZXQoc2NvcGUpKS5maWx0ZXIoKGspID0+IGsgIT0gbnVsbCk7XG4gICAgICBjb25zdCBmaXJzdENvbHVtbiA9IGFsbENvbHVtbnNbZmlyc3Qoc2NvcGVDb2x1bW5JbmRleGVzKV07XG4gICAgICBjb25zdCBzY29wZUludmFsaWREYXRhID0gaW52YWxpZERhdGE/LmdldChzY29wZSk7XG4gICAgICBjb25zdCBzY29wZUludmFsaWRLZXlzID0gaW52YWxpZEtleXM/LmdldChzY29wZSk7XG4gICAgICBmb3IgKGxldCBkYXR1bUluZGV4ID0gMDsgZGF0dW1JbmRleCA8IGZpcnN0Q29sdW1uLmxlbmd0aDsgZGF0dW1JbmRleCsrKSB7XG4gICAgICAgIGlmIChzY29wZUludmFsaWRLZXlzPy5bZGF0dW1JbmRleF0gPT09IHRydWUpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGtleXMgPSBzY29wZUtleXMubWFwKChrKSA9PiBrW2RhdHVtSW5kZXhdKTtcbiAgICAgICAgaWYgKGtleXMgPT0gbnVsbCB8fCBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIG5vIGtleXMgZm91bmQgZm9yIHNjb3BlOiBcIiArIHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBncm91cCA9IGdyb3VwaW5nRm4/LihrZXlzKSA/PyBrZXlzO1xuICAgICAgICBjb25zdCBncm91cFN0ciA9IHRvS2V5U3RyaW5nKGdyb3VwKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0R3JvdXAgPSBncm91cHMuZ2V0KGdyb3VwU3RyKSA/PyB7XG4gICAgICAgICAga2V5czogZ3JvdXAsXG4gICAgICAgICAgZGF0dW1JbmRpY2VzOiBbXSxcbiAgICAgICAgICB2YWxpZFNjb3BlczogYWxsU2NvcGVzXG4gICAgICAgIH07XG4gICAgICAgIGlmICghZ3JvdXBzLmhhcyhncm91cFN0cikpIHtcbiAgICAgICAgICBncm91cHMuc2V0KGdyb3VwU3RyLCBvdXRwdXRHcm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjb3BlSW52YWxpZERhdGE/LltkYXR1bUluZGV4XSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmIChvdXRwdXRHcm91cC52YWxpZFNjb3BlcyA9PT0gYWxsU2NvcGVzKSB7XG4gICAgICAgICAgICBvdXRwdXRHcm91cC52YWxpZFNjb3BlcyA9IG5ldyBTZXQoYWxsU2NvcGVzLnZhbHVlcygpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBpbnZhbGlkU2NvcGUgb2Ygc2libGluZ1Njb3Blcykge1xuICAgICAgICAgICAgb3V0cHV0R3JvdXAudmFsaWRTY29wZXMuZGVsZXRlKGludmFsaWRTY29wZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvdXRwdXRHcm91cC52YWxpZFNjb3Blcy5zaXplID09PSAwKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGNvbnN0IGNvbHVtbklkeCBvZiBzY29wZUNvbHVtbkluZGV4ZXMpIHtcbiAgICAgICAgICAoX2EgPSBvdXRwdXRHcm91cC5kYXR1bUluZGljZXMpW2NvbHVtbklkeF0gPz8gKF9hW2NvbHVtbklkeF0gPSBbXSk7XG4gICAgICAgICAgb3V0cHV0R3JvdXAuZGF0dW1JbmRpY2VzW2NvbHVtbklkeF0ucHVzaChkYXR1bUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHRHcm91cHMgPSBbXTtcbiAgICBjb25zdCByZXN1bHREYXRhID0gW107XG4gICAgZm9yIChjb25zdCB7IGtleXMsIGRhdHVtSW5kaWNlcywgdmFsaWRTY29wZXMgfSBvZiBncm91cHMudmFsdWVzKCkpIHtcbiAgICAgIGlmICh2YWxpZFNjb3Blcz8uc2l6ZSA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICByZXN1bHRHcm91cHMucHVzaChrZXlzKTtcbiAgICAgIHJlc3VsdERhdGEucHVzaCh7XG4gICAgICAgIGRhdHVtSW5kaWNlcyxcbiAgICAgICAga2V5cyxcbiAgICAgICAgYWdncmVnYXRpb246IFtdLFxuICAgICAgICB2YWxpZFNjb3Blc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgdHlwZTogXCJncm91cGVkXCIsXG4gICAgICBkb21haW46IHtcbiAgICAgICAgLi4uZGF0YS5kb21haW4sXG4gICAgICAgIGdyb3VwczogcmVzdWx0R3JvdXBzXG4gICAgICB9LFxuICAgICAgZ3JvdXBzOiByZXN1bHREYXRhXG4gICAgfTtcbiAgfVxuICBhZ2dyZWdhdGVVbmdyb3VwZWREYXRhKHByb2Nlc3NlZERhdGEpIHtcbiAgICBjb25zdCBkb21haW5BZ2dWYWx1ZXMgPSB0aGlzLmFnZ3JlZ2F0ZXMubWFwKCgpID0+IFtJbmZpbml0eSwgLUluZmluaXR5XSk7XG4gICAgcHJvY2Vzc2VkRGF0YS5kb21haW4uYWdnVmFsdWVzID0gZG9tYWluQWdnVmFsdWVzO1xuICAgIGNvbnN0IHsga2V5cywgY29sdW1ucywgZGF0YVNvdXJjZXMgfSA9IHByb2Nlc3NlZERhdGE7XG4gICAgY29uc3Qgb25seVNjb3BlID0gZmlyc3QoZGF0YVNvdXJjZXMua2V5cygpKTtcbiAgICBjb25zdCByYXdEYXRhID0gZGF0YVNvdXJjZXMuZ2V0KG9ubHlTY29wZSk7XG4gICAgcHJvY2Vzc2VkRGF0YS5hZ2dyZWdhdGlvbiA9IHJhd0RhdGE/Lm1hcCgoXywgZGF0dW1JbmRleCkgPT4ge1xuICAgICAgY29uc3QgYWdncmVnYXRpb24gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW2luZGV4LCBkZWZdIG9mIHRoaXMuYWdncmVnYXRlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IHRoaXMudmFsdWVHcm91cElkeExvb2t1cChkZWYpO1xuICAgICAgICBsZXQgZ3JvdXBBZ2dWYWx1ZXMgPSBkZWYuZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbj8uKCkgPz8gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICAgICAgICBjb25zdCB2YWx1ZXNUb0FnZyA9IGluZGljZXMubWFwKChjb2x1bW5JbmRleCkgPT4gY29sdW1uc1tjb2x1bW5JbmRleF1bZGF0dW1JbmRleF0pO1xuICAgICAgICBjb25zdCBrID0gZGF0dW1LZXlzKGtleXMsIG9ubHlTY29wZSwgZGF0dW1JbmRleCk7XG4gICAgICAgIGNvbnN0IHZhbHVlc0FnZyA9IGsgIT0gbnVsbCA/IGRlZi5hZ2dyZWdhdGVGdW5jdGlvbih2YWx1ZXNUb0FnZywgaykgOiB2b2lkIDA7XG4gICAgICAgIGlmICh2YWx1ZXNBZ2cpIHtcbiAgICAgICAgICBncm91cEFnZ1ZhbHVlcyA9IGRlZi5ncm91cEFnZ3JlZ2F0ZUZ1bmN0aW9uPy4odmFsdWVzQWdnLCBncm91cEFnZ1ZhbHVlcykgPz8gQ29udGludW91c0RvbWFpbi5leHRlbmREb21haW4odmFsdWVzQWdnLCBncm91cEFnZ1ZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmluYWxWYWx1ZXMgPSBkZWYuZmluYWxGdW5jdGlvbj8uKGdyb3VwQWdnVmFsdWVzKSA/PyBncm91cEFnZ1ZhbHVlcztcbiAgICAgICAgaWYgKGRlZi5yb3VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGZvciAoY29uc3QgaWR4IGluIGZpbmFsVmFsdWVzKSB7XG4gICAgICAgICAgICBmaW5hbFZhbHVlc1tpZHhdID0gcm91bmQzKGZpbmFsVmFsdWVzW2lkeF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZ2dyZWdhdGlvbltpbmRleF0gPSBmaW5hbFZhbHVlcztcbiAgICAgICAgQ29udGludW91c0RvbWFpbi5leHRlbmREb21haW4oZmluYWxWYWx1ZXMsIGRvbWFpbkFnZ1ZhbHVlc1tpbmRleF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFnZ3JlZ2F0aW9uO1xuICAgIH0pO1xuICB9XG4gIGFnZ3JlZ2F0ZUdyb3VwZWREYXRhKHByb2Nlc3NlZERhdGEpIHtcbiAgICBjb25zdCBkb21haW5BZ2dWYWx1ZXMgPSB0aGlzLmFnZ3JlZ2F0ZXMubWFwKCgpID0+IFtJbmZpbml0eSwgLUluZmluaXR5XSk7XG4gICAgcHJvY2Vzc2VkRGF0YS5kb21haW4uYWdnVmFsdWVzID0gZG9tYWluQWdnVmFsdWVzO1xuICAgIGNvbnN0IHsgY29sdW1ucyB9ID0gcHJvY2Vzc2VkRGF0YTtcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgZGVmXSBvZiB0aGlzLmFnZ3JlZ2F0ZXMuZW50cmllcygpKSB7XG4gICAgICBjb25zdCBpbmRpY2VzID0gdGhpcy52YWx1ZUdyb3VwSWR4TG9va3VwKGRlZik7XG4gICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHByb2Nlc3NlZERhdGEuZ3JvdXBzKSB7XG4gICAgICAgIGdyb3VwLmFnZ3JlZ2F0aW9uID8/IChncm91cC5hZ2dyZWdhdGlvbiA9IFtdKTtcbiAgICAgICAgaWYgKGdyb3VwLnZhbGlkU2NvcGVzPy5zaXplID09PSAwKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBncm91cEtleXMgPSBncm91cC5rZXlzO1xuICAgICAgICBsZXQgZ3JvdXBBZ2dWYWx1ZXMgPSBkZWYuZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbj8uKCkgPz8gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICAgICAgICBjb25zdCBtYXhEYXR1bUluZGV4ID0gTWF0aC5tYXgoXG4gICAgICAgICAgLi4uaW5kaWNlcy5tYXAoKGNvbHVtbkluZGV4KSA9PiBncm91cC5kYXR1bUluZGljZXNbY29sdW1uSW5kZXhdPy5sZW5ndGggPz8gMClcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChsZXQgZGF0dW1JbmRleCA9IDA7IGRhdHVtSW5kZXggPCBtYXhEYXR1bUluZGV4OyBkYXR1bUluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZXNUb0FnZyA9IGluZGljZXMubWFwKFxuICAgICAgICAgICAgKGNvbHVtbkluZGV4KSA9PiBjb2x1bW5zW2NvbHVtbkluZGV4XVtncm91cC5kYXR1bUluZGljZXNbY29sdW1uSW5kZXhdPy5bZGF0dW1JbmRleF1dXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZXNBZ2cgPSBkZWYuYWdncmVnYXRlRnVuY3Rpb24odmFsdWVzVG9BZ2csIGdyb3VwS2V5cyk7XG4gICAgICAgICAgaWYgKHZhbHVlc0FnZykge1xuICAgICAgICAgICAgZ3JvdXBBZ2dWYWx1ZXMgPSBkZWYuZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbj8uKHZhbHVlc0FnZywgZ3JvdXBBZ2dWYWx1ZXMpID8/IENvbnRpbnVvdXNEb21haW4uZXh0ZW5kRG9tYWluKHZhbHVlc0FnZywgZ3JvdXBBZ2dWYWx1ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaW5hbFZhbHVlcyA9IGRlZi5maW5hbEZ1bmN0aW9uPy4oZ3JvdXBBZ2dWYWx1ZXMpID8/IGdyb3VwQWdnVmFsdWVzO1xuICAgICAgICBpZiAoZGVmLnJvdW5kID09PSB0cnVlKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBpZHggaW4gZmluYWxWYWx1ZXMpIHtcbiAgICAgICAgICAgIGZpbmFsVmFsdWVzW2lkeF0gPSByb3VuZDMoZmluYWxWYWx1ZXNbaWR4XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdyb3VwLmFnZ3JlZ2F0aW9uW2luZGV4XSA9IGZpbmFsVmFsdWVzO1xuICAgICAgICBDb250aW51b3VzRG9tYWluLmV4dGVuZERvbWFpbihmaW5hbFZhbHVlcywgZG9tYWluQWdnVmFsdWVzW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBvc3RQcm9jZXNzR3JvdXBzKHByb2Nlc3NlZERhdGEpIHtcbiAgICBjb25zdCB7IGdyb3VwUHJvY2Vzc29ycyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGNvbHVtblNjb3BlcywgY29sdW1ucywgaW52YWxpZERhdGEsIHNjb3BlcyB9ID0gcHJvY2Vzc2VkRGF0YTtcbiAgICBmb3IgKGNvbnN0IHByb2Nlc3NvciBvZiBncm91cFByb2Nlc3NvcnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlSW5kZXhlcyA9IHRoaXMudmFsdWVHcm91cElkeExvb2t1cChwcm9jZXNzb3IpO1xuICAgICAgY29uc3QgYWRqdXN0Rm4gPSBwcm9jZXNzb3IuYWRqdXN0KCkoKTtcbiAgICAgIGZvciAoY29uc3QgZGF0YUdyb3VwIG9mIHByb2Nlc3NlZERhdGEuZ3JvdXBzKSB7XG4gICAgICAgIGlmIChkYXRhR3JvdXAudmFsaWRTY29wZXMgIT09IHNjb3BlcylcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYWRqdXN0Rm4oY29sdW1ucywgdmFsdWVJbmRleGVzLCBkYXRhR3JvdXApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB2YWx1ZUluZGV4IG9mIHZhbHVlSW5kZXhlcykge1xuICAgICAgICBjb25zdCB2YWx1ZURlZiA9IHRoaXMudmFsdWVzW3ZhbHVlSW5kZXhdO1xuICAgICAgICBjb25zdCBpc0Rpc2NyZXRlID0gdmFsdWVEZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCI7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNbdmFsdWVJbmRleF07XG4gICAgICAgIGNvbnN0IGNvbHVtblNjb3BlID0gZmlyc3QoY29sdW1uU2NvcGVzW3ZhbHVlSW5kZXhdKTtcbiAgICAgICAgY29uc3QgaW52YWxpZERhdHVtcyA9IGludmFsaWREYXRhPy5nZXQoY29sdW1uU2NvcGUpO1xuICAgICAgICBjb25zdCBkb21haW4gPSBpc0Rpc2NyZXRlID8gbmV3IERpc2NyZXRlRG9tYWluKCkgOiBuZXcgQ29udGludW91c0RvbWFpbigpO1xuICAgICAgICBmb3IgKGxldCBkYXR1bUluZGV4ID0gMDsgZGF0dW1JbmRleCA8IGNvbHVtbi5sZW5ndGg7IGRhdHVtSW5kZXggKz0gMSkge1xuICAgICAgICAgIGlmIChpbnZhbGlkRGF0dW1zPy5bZGF0dW1JbmRleF0gPT09IHRydWUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBkb21haW4uZXh0ZW5kKGNvbHVtbltkYXR1bUluZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc2VkRGF0YS5kb21haW4udmFsdWVzW3ZhbHVlSW5kZXhdID0gZG9tYWluLmdldERvbWFpbigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwb3N0UHJvY2Vzc1Byb3BlcnRpZXMocHJvY2Vzc2VkRGF0YSkge1xuICAgIGZvciAoY29uc3QgeyBhZGp1c3QsIHByb3BlcnR5LCBzY29wZXMgfSBvZiB0aGlzLnByb3BlcnR5UHJvY2Vzc29ycykge1xuICAgICAgZm9yIChjb25zdCBpZHggb2YgdGhpcy52YWx1ZUlkeExvb2t1cChzY29wZXMsIHByb3BlcnR5KSkge1xuICAgICAgICBhZGp1c3QoKShwcm9jZXNzZWREYXRhLCBpZHgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZWR1Y2VEYXRhKHByb2Nlc3NlZERhdGEpIHtcbiAgICBwcm9jZXNzZWREYXRhLnJlZHVjZWQgPz8gKHByb2Nlc3NlZERhdGEucmVkdWNlZCA9IHt9KTtcbiAgICBjb25zdCB7IGRhdGFTb3VyY2VzLCBrZXlzIH0gPSBwcm9jZXNzZWREYXRhO1xuICAgIGZvciAoY29uc3QgZGVmIG9mIHRoaXMucmVkdWNlcnMpIHtcbiAgICAgIGNvbnN0IHJlZHVjZXIgPSBkZWYucmVkdWNlcigpO1xuICAgICAgbGV0IGFjY1ZhbHVlID0gZGVmLmluaXRpYWxWYWx1ZTtcbiAgICAgIGlmIChwcm9jZXNzZWREYXRhLnR5cGUgPT09IFwiZ3JvdXBlZFwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgcHJvY2Vzc2VkRGF0YS5ncm91cHMpIHtcbiAgICAgICAgICBhY2NWYWx1ZSA9IHJlZHVjZXIoYWNjVmFsdWUsIGdyb3VwLmtleXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvbmx5U2NvcGUgPSBmaXJzdChkYXRhU291cmNlcy5rZXlzKCkpO1xuICAgICAgICBjb25zdCBrZXlDb2x1bW5zID0ga2V5cy5tYXAoKGspID0+IGsuZ2V0KG9ubHlTY29wZSkpLmZpbHRlcigoaykgPT4gayAhPSBudWxsKTtcbiAgICAgICAgY29uc3Qga2V5c1BhcmFtID0ga2V5Q29sdW1ucy5tYXAoKCkgPT4gdm9pZCAwKTtcbiAgICAgICAgY29uc3QgcmF3RGF0YSA9IGRhdGFTb3VyY2VzLmdldChvbmx5U2NvcGUpO1xuICAgICAgICBmb3IgKGxldCBkYXR1bUluZGV4ID0gMDsgZGF0dW1JbmRleCA8IHJhd0RhdGEubGVuZ3RoOyBkYXR1bUluZGV4ICs9IDEpIHtcbiAgICAgICAgICBmb3IgKGxldCBrZXlJZHggPSAwOyBrZXlJZHggPCBrZXlzUGFyYW0ubGVuZ3RoOyBrZXlJZHgrKykge1xuICAgICAgICAgICAga2V5c1BhcmFtW2tleUlkeF0gPSBrZXlDb2x1bW5zW2tleUlkeF0/LltkYXR1bUluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWNjVmFsdWUgPSByZWR1Y2VyKGFjY1ZhbHVlLCBrZXlzUGFyYW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9jZXNzZWREYXRhLnJlZHVjZWRbZGVmLnByb3BlcnR5XSA9IGFjY1ZhbHVlO1xuICAgIH1cbiAgfVxuICBwb3N0UHJvY2Vzc0RhdGEocHJvY2Vzc2VkRGF0YSkge1xuICAgIHByb2Nlc3NlZERhdGEucmVkdWNlZCA/PyAocHJvY2Vzc2VkRGF0YS5yZWR1Y2VkID0ge30pO1xuICAgIGZvciAoY29uc3QgZGVmIG9mIHRoaXMucHJvY2Vzc29ycykge1xuICAgICAgcHJvY2Vzc2VkRGF0YS5yZWR1Y2VkW2RlZi5wcm9wZXJ0eV0gPSBkZWYuY2FsY3VsYXRlKFxuICAgICAgICBwcm9jZXNzZWREYXRhLFxuICAgICAgICBwcm9jZXNzZWREYXRhLnJlZHVjZWRbZGVmLnByb3BlcnR5XVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaW5pdERhdGFEb21haW5Qcm9jZXNzb3IoKSB7XG4gICAgY29uc3QgeyBrZXlzOiBrZXlEZWZzLCB2YWx1ZXM6IHZhbHVlRGVmcyB9ID0gdGhpcztcbiAgICBjb25zdCBzY29wZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdmFsdWVEZWYgb2YgdmFsdWVEZWZzKSB7XG4gICAgICBpZiAoIXZhbHVlRGVmLnNjb3BlcylcbiAgICAgICAgY29udGludWU7XG4gICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIHZhbHVlRGVmLnNjb3Blcykge1xuICAgICAgICBzY29wZXMuYWRkKHNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGF0YURvbWFpbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgcHJvY2Vzc29yRm5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgYWxsU2NvcGVzSGF2ZVNhbWVEZWZzID0gdHJ1ZTtcbiAgICBjb25zdCBpbml0RGF0YURvbWFpbiA9ICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgZGVmIG9mIGl0ZXJhdGUoa2V5RGVmcywgdmFsdWVEZWZzKSkge1xuICAgICAgICBpZiAoZGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICAgICAgZGF0YURvbWFpbi5zZXQoZGVmLCBuZXcgRGlzY3JldGVEb21haW4oKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YURvbWFpbi5zZXQoZGVmLCBuZXcgQ29udGludW91c0RvbWFpbigpKTtcbiAgICAgICAgICBhbGxTY29wZXNIYXZlU2FtZURlZnMgJiYgKGFsbFNjb3Blc0hhdmVTYW1lRGVmcyA9IChkZWYuc2NvcGVzID8/IFtdKS5sZW5ndGggPT09IHNjb3Blcy5zaXplKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaW5pdERhdGFEb21haW4oKTtcbiAgICBjb25zdCBhY2Nlc3NvcnMgPSB0aGlzLmJ1aWxkQWNjZXNzb3JzKGl0ZXJhdGUoa2V5RGVmcywgdmFsdWVEZWZzKSk7XG4gICAgY29uc3QgcHJvY2Vzc1ZhbHVlID0gKGRlZiwgZGF0dW0sIGlkeCwgdmFsdWVTY29wZXMpID0+IHtcbiAgICAgIGxldCB2YWx1ZUluRGF0dW07XG4gICAgICBsZXQgdmFsdWU7XG4gICAgICBpZiAoYWNjZXNzb3JzLmhhcyhkZWYucHJvcGVydHkpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFsdWUgPSBhY2Nlc3NvcnMuZ2V0KGRlZi5wcm9wZXJ0eSkoZGF0dW0pO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZUluRGF0dW0gPSB2YWx1ZSAhPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVJbkRhdHVtID0gZGVmLnByb3BlcnR5IGluIGRhdHVtO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlSW5EYXR1bSA/IGRhdHVtW2RlZi5wcm9wZXJ0eV0gOiBkZWYubWlzc2luZ1ZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGRlZi5mb3JjZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgdmFsdWVOZWdhdGl2ZSA9IHZhbHVlSW5EYXR1bSAmJiBpc05lZ2F0aXZlKHZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZU5lZ2F0aXZlID8gLTEgKiBkZWYuZm9yY2VWYWx1ZSA6IGRlZi5mb3JjZVZhbHVlO1xuICAgICAgICB2YWx1ZUluRGF0dW0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbWlzc2luZ1ZhbHVlRGVmID0gXCJtaXNzaW5nVmFsdWVcIiBpbiBkZWY7XG4gICAgICBpZiAoIXZhbHVlSW5EYXR1bSAmJiAhbWlzc2luZ1ZhbHVlRGVmKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVTY29wZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCBtaXNzQ291bnQgPSBkZWYubWlzc2luZy5nZXQodmFsdWVTY29wZXMpID8/IDA7XG4gICAgICAgICAgZGVmLm1pc3Npbmcuc2V0KHZhbHVlU2NvcGVzLCBtaXNzQ291bnQgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIHZhbHVlU2NvcGVzKSB7XG4gICAgICAgICAgICBjb25zdCBtaXNzQ291bnQgPSBkZWYubWlzc2luZy5nZXQoc2NvcGUpID8/IDA7XG4gICAgICAgICAgICBkZWYubWlzc2luZy5zZXQoc2NvcGUsIG1pc3NDb3VudCArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFkYXRhRG9tYWluLmhhcyhkZWYpKSB7XG4gICAgICAgIGluaXREYXRhRG9tYWluKCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVJbkRhdHVtICYmIGRlZi52YWxpZGF0aW9uPy4odmFsdWUsIGRhdHVtLCBpZHgpID09PSBmYWxzZSkge1xuICAgICAgICBpZiAoXCJpbnZhbGlkVmFsdWVcIiBpbiBkZWYpIHtcbiAgICAgICAgICB2YWx1ZSA9IGRlZi5pbnZhbGlkVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMubW9kZSAhPT0gXCJpbnRlZ3JhdGVkXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKFxuICAgICAgICAgICAgICBgaW52YWxpZCB2YWx1ZSBvZiB0eXBlIFske3R5cGVvZiB2YWx1ZX1dIGZvciBbJHtkZWYuc2NvcGVzfSAvICR7ZGVmLmlkfV0gaWdub3JlZDpgLFxuICAgICAgICAgICAgICBgWyR7dmFsdWV9XWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBJTlZBTElEX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVmLnByb2Nlc3Nvcikge1xuICAgICAgICBpZiAoIXByb2Nlc3NvckZucy5oYXMoZGVmKSkge1xuICAgICAgICAgIHByb2Nlc3NvckZucy5zZXQoZGVmLCBkZWYucHJvY2Vzc29yKCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gcHJvY2Vzc29yRm5zLmdldChkZWYpPy4odmFsdWUpO1xuICAgICAgfVxuICAgICAgZGF0YURvbWFpbi5nZXQoZGVmKT8uZXh0ZW5kKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiB7IGRhdGFEb21haW4sIHByb2Nlc3NWYWx1ZSwgaW5pdERhdGFEb21haW4sIHNjb3BlcywgYWxsU2NvcGVzSGF2ZVNhbWVEZWZzIH07XG4gIH1cbiAgYnVpbGRBY2Nlc3NvcnMoZGVmcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKHRoaXMuc3VwcHJlc3NGaWVsZERvdE5vdGF0aW9uKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRlZiBvZiBkZWZzKSB7XG4gICAgICBjb25zdCBpc1BhdGggPSBkZWYucHJvcGVydHkuaW5jbHVkZXMoXCIuXCIpIHx8IGRlZi5wcm9wZXJ0eS5pbmNsdWRlcyhcIltcIik7XG4gICAgICBpZiAoIWlzUGF0aClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gZ2V0UGF0aENvbXBvbmVudHMoZGVmLnByb3BlcnR5KTtcbiAgICAgIGlmIChjb21wb25lbnRzID09IG51bGwpIHtcbiAgICAgICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoXCJJbnZhbGlkIHByb3BlcnR5IHBhdGggWyVzXVwiLCBkZWYucHJvcGVydHkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjY2Vzc29yID0gY3JlYXRlUGF0aEFjY2Vzc29yKGNvbXBvbmVudHMpO1xuICAgICAgcmVzdWx0LnNldChkZWYucHJvcGVydHksIGFjY2Vzc29yKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmZ1bmN0aW9uIGxvZ1Byb2Nlc3NlZERhdGEocHJvY2Vzc2VkRGF0YSkge1xuICBjb25zdCBsb2dWYWx1ZXMgPSAobmFtZSwgZGF0YSkgPT4ge1xuICAgIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGxvZ2dlcl9leHBvcnRzLmxvZyhgRGF0YU1vZGVsLnByb2Nlc3NEYXRhKCkgLSAke25hbWV9YCk7XG4gICAgICBsb2dnZXJfZXhwb3J0cy50YWJsZShkYXRhKTtcbiAgICB9XG4gIH07XG4gIGxvZ2dlcl9leHBvcnRzLmxvZyhcIkRhdGFNb2RlbC5wcm9jZXNzRGF0YSgpIC0gcHJvY2Vzc2VkRGF0YVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgbG9nVmFsdWVzKFwiS2V5IERvbWFpbnNcIiwgcHJvY2Vzc2VkRGF0YS5kb21haW4ua2V5cyk7XG4gIGxvZ1ZhbHVlcyhcIkdyb3VwIERvbWFpbnNcIiwgcHJvY2Vzc2VkRGF0YS5kb21haW4uZ3JvdXBzID8/IFtdKTtcbiAgbG9nVmFsdWVzKFwiVmFsdWUgRG9tYWluc1wiLCBwcm9jZXNzZWREYXRhLmRvbWFpbi52YWx1ZXMpO1xuICBsb2dWYWx1ZXMoXCJBZ2dyZWdhdGUgRG9tYWluc1wiLCBwcm9jZXNzZWREYXRhLmRvbWFpbi5hZ2dWYWx1ZXMgPz8gW10pO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL2RhdGFDb250cm9sbGVyLnRzXG52YXIgX0RhdGFDb250cm9sbGVyID0gY2xhc3MgX0RhdGFDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IobW9kZSwgc3VwcHJlc3NGaWVsZERvdE5vdGF0aW9uKSB7XG4gICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB0aGlzLnN1cHByZXNzRmllbGREb3ROb3RhdGlvbiA9IHN1cHByZXNzRmllbGREb3ROb3RhdGlvbjtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwiZGF0YS1tb2RlbFwiKTtcbiAgICB0aGlzLnJlcXVlc3RlZCA9IFtdO1xuICAgIHRoaXMuc3RhdHVzID0gXCJzZXR1cFwiO1xuICB9XG4gIGFzeW5jIHJlcXVlc3QoaWQsIGRhdGEsIG9wdHMpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IFwic2V0dXBcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBkYXRhIHJlcXVlc3QgYWZ0ZXIgZGF0YSBzZXR1cCBwaGFzZS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVxdWVzdGVkLnB1c2goeyBpZCwgb3B0cywgZGF0YSwgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xuICB9XG4gIGV4ZWN1dGUoY2FjaGVkRGF0YSkge1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gXCJzZXR1cFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIGRhdGEgcmVxdWVzdCBhZnRlciBkYXRhIHNldHVwIHBoYXNlLmApO1xuICAgIH1cbiAgICB0aGlzLnN0YXR1cyA9IFwiZXhlY3V0ZWRcIjtcbiAgICB0aGlzLmRlYnVnKFwiRGF0YUNvbnRyb2xsZXIuZXhlY3V0ZSgpIC0gcmVxdWVzdGVkXCIsIHRoaXMucmVxdWVzdGVkKTtcbiAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWRhdGVSZXF1ZXN0cyh0aGlzLnJlcXVlc3RlZCk7XG4gICAgdGhpcy5kZWJ1ZyhcIkRhdGFDb250cm9sbGVyLmV4ZWN1dGUoKSAtIHZhbGlkYXRlZFwiLCB2YWxpZCk7XG4gICAgY29uc3QgbWVyZ2VkID0gdGhpcy5tZXJnZVJlcXVlc3RlZCh2YWxpZCk7XG4gICAgdGhpcy5kZWJ1ZyhcIkRhdGFDb250cm9sbGVyLmV4ZWN1dGUoKSAtIG1lcmdlZFwiLCBtZXJnZWQpO1xuICAgIGlmICh0aGlzLmRlYnVnLmNoZWNrKCkpIHtcbiAgICAgIGdldFdpbmRvdygpLnByb2Nlc3NlZERhdGEgPSBbXTtcbiAgICB9XG4gICAgY29uc3QgbmV4dENhY2hlZERhdGEgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHsgZGF0YSwgaWRzLCBvcHRzLCByZXNvbHZlcywgcmVqZWN0cyB9IG9mIG1lcmdlZCkge1xuICAgICAgY29uc3QgcmV1c2FibGVDYWNoZSA9IGNhY2hlZERhdGE/LmZpbmQoKGNhY2hlSXRlbSkgPT4gY2FuUmV1c2VDYWNoZWREYXRhKGNhY2hlSXRlbSwgZGF0YSwgaWRzLCBvcHRzKSk7XG4gICAgICBsZXQgZGF0YU1vZGVsO1xuICAgICAgbGV0IHByb2Nlc3NlZERhdGE7XG4gICAgICBpZiAocmV1c2FibGVDYWNoZSA9PSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0YU1vZGVsID0gbmV3IERhdGFNb2RlbChvcHRzLCB0aGlzLm1vZGUsIHRoaXMuc3VwcHJlc3NGaWVsZERvdE5vdGF0aW9uKTtcbiAgICAgICAgICBjb25zdCBzb3VyY2VzID0gbmV3IE1hcCh2YWxpZC5tYXAoKHYpID0+IFt2LmlkLCB2LmRhdGFdKSk7XG4gICAgICAgICAgcHJvY2Vzc2VkRGF0YSA9IGRhdGFNb2RlbC5wcm9jZXNzRGF0YShzb3VyY2VzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgICAgcmVqZWN0cy5mb3JFYWNoKChjYikgPT4gY2IoZXJyb3IyKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICh7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gcmV1c2FibGVDYWNoZSk7XG4gICAgICB9XG4gICAgICBuZXh0Q2FjaGVkRGF0YS5wdXNoKHsgb3B0cywgZGF0YSwgaWRzLCBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSk7XG4gICAgICBpZiAodGhpcy5kZWJ1Zy5jaGVjaygpKSB7XG4gICAgICAgIGdldFdpbmRvdyhcInByb2Nlc3NlZERhdGFcIikucHVzaChwcm9jZXNzZWREYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzZWREYXRhPy5wYXJ0aWFsVmFsaWREYXRhQ291bnQgPT09IDApIHtcbiAgICAgICAgcmVzb2x2ZXMuZm9yRWFjaChcbiAgICAgICAgICAocmVzb2x2ZSkgPT4gcmVzb2x2ZSh7XG4gICAgICAgICAgICBkYXRhTW9kZWwsXG4gICAgICAgICAgICBwcm9jZXNzZWREYXRhXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzc2VkRGF0YSkge1xuICAgICAgICB0aGlzLnNwbGl0UmVzdWx0KGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSwgaWRzLCByZXNvbHZlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3RzLmZvckVhY2goKGNiKSA9PiBjYihuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIG5vIHByb2Nlc3NlZCBkYXRhIGdlbmVyYXRlZGApKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXh0Q2FjaGVkRGF0YTtcbiAgfVxuICB2YWxpZGF0ZVJlcXVlc3RzKHJlcXVlc3RlZCkge1xuICAgIGNvbnN0IHZhbGlkID0gW107XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIHJlcXVlc3RdIG9mIHJlcXVlc3RlZC5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChpbmRleCA+IDAgJiYgcmVxdWVzdC5kYXRhLmxlbmd0aCAhPT0gcmVxdWVzdGVkWzBdLmRhdGEubGVuZ3RoICYmIHJlcXVlc3Qub3B0cy5ncm91cEJ5RGF0YSA9PT0gZmFsc2UgJiYgcmVxdWVzdC5vcHRzLmdyb3VwQnlLZXlzID09PSBmYWxzZSkge1xuICAgICAgICByZXF1ZXN0LnJlamVjdChcbiAgICAgICAgICBuZXcgRXJyb3IoXCJhbGwgc2VyaWVzW10uZGF0YSBhcnJheXMgbXVzdCBiZSBvZiB0aGUgc2FtZSBsZW5ndGggYW5kIGhhdmUgbWF0Y2hpbmcga2V5cy5cIilcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbGlkLnB1c2gocmVxdWVzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWxpZDtcbiAgfVxuICBtZXJnZVJlcXVlc3RlZChyZXF1ZXN0ZWQpIHtcbiAgICBjb25zdCBncm91cGVkID0gW107XG4gICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RlZCkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBncm91cGVkLmZpbmQoX0RhdGFDb250cm9sbGVyLmdyb3VwTWF0Y2gocmVxdWVzdCkpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoLnB1c2gocmVxdWVzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncm91cGVkLnB1c2goW3JlcXVlc3RdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdyb3VwZWQubWFwKF9EYXRhQ29udHJvbGxlci5tZXJnZVJlcXVlc3RzKTtcbiAgfVxuICBzcGxpdFJlc3VsdChkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEsIHNjb3BlcywgcmVzb2x2ZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjb3Blcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVzb2x2ZSA9IHJlc29sdmVzW2ldO1xuICAgICAgcmVzb2x2ZSh7XG4gICAgICAgIGRhdGFNb2RlbCxcbiAgICAgICAgcHJvY2Vzc2VkRGF0YVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBncm91cE1hdGNoKHsgZGF0YSwgb3B0cyB9KSB7XG4gICAgZnVuY3Rpb24ga2V5cyhwcm9wczIpIHtcbiAgICAgIHJldHVybiBwcm9wczIuZmlsdGVyKChwKSA9PiBwLnR5cGUgPT09IFwia2V5XCIpLm1hcCgocCkgPT4gcC5wcm9wZXJ0eSkuam9pbihcIjtcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgZ3JvdXBCeURhdGEsIGdyb3VwQnlLZXlzID0gZmFsc2UsIGdyb3VwQnlGbiwgcHJvcHMgfSA9IG9wdHM7XG4gICAgY29uc3QgcHJvcHNLZXlzID0ga2V5cyhwcm9wcyk7XG4gICAgcmV0dXJuIChbZ3JvdXBdKSA9PiAoZ3JvdXBCeURhdGEgPT09IGZhbHNlIHx8IGdyb3VwLmRhdGEgPT09IGRhdGEpICYmIChncm91cC5vcHRzLmdyb3VwQnlLZXlzID8/IGZhbHNlKSA9PT0gZ3JvdXBCeUtleXMgJiYgZ3JvdXAub3B0cy5ncm91cEJ5Rm4gPT09IGdyb3VwQnlGbiAmJiBrZXlzKGdyb3VwLm9wdHMucHJvcHMpID09PSBwcm9wc0tleXM7XG4gIH1cbiAgc3RhdGljIG1lcmdlUmVxdWVzdHMocmVxdWVzdHMpIHtcbiAgICBjb25zdCBjcm9zc1Njb3BlTWVyZ2FibGVUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImtleVwiLCBcImdyb3VwLXZhbHVlLXByb2Nlc3NvclwiXSk7XG4gICAgcmV0dXJuIHJlcXVlc3RzLnJlZHVjZShcbiAgICAgIChyZXN1bHQsIHsgaWQsIGRhdGEsIHJlc29sdmUsIHJlamVjdCwgb3B0czogeyBwcm9wcywgLi4ub3B0cyB9IH0pID0+IHtcbiAgICAgICAgcmVzdWx0Lmlkcy5wdXNoKGlkKTtcbiAgICAgICAgcmVzdWx0LnJlamVjdHMucHVzaChyZWplY3QpO1xuICAgICAgICByZXN1bHQucmVzb2x2ZXMucHVzaChyZXNvbHZlKTtcbiAgICAgICAgcmVzdWx0LmRhdGEgPz8gKHJlc3VsdC5kYXRhID0gZGF0YSk7XG4gICAgICAgIHJlc3VsdC5vcHRzID8/IChyZXN1bHQub3B0cyA9IHsgLi4ub3B0cywgcHJvcHM6IFtdIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpIHtcbiAgICAgICAgICBjb25zdCBjbG9uZTIgPSB7IC4uLnByb3AsIHNjb3BlczogW2lkXSwgZGF0YSB9O1xuICAgICAgICAgIF9EYXRhQ29udHJvbGxlci5jcmVhdGVJZHNNYXAoaWQsIGNsb25lMik7XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSByZXN1bHQub3B0cy5wcm9wcy5maW5kKFxuICAgICAgICAgICAgKGV4aXN0aW5nKSA9PiBleGlzdGluZy50eXBlID09PSBjbG9uZTIudHlwZSAmJiAoY3Jvc3NTY29wZU1lcmdhYmxlVHlwZXMuaGFzKGV4aXN0aW5nLnR5cGUpIHx8IGV4aXN0aW5nLmRhdGEgPT09IGNsb25lMi5kYXRhKSAmJiBfRGF0YUNvbnRyb2xsZXIuZGVlcEVxdWFsKGV4aXN0aW5nLCBjbG9uZTIpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0cy5wcm9wcy5wdXNoKGNsb25lMik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWF0Y2guc2NvcGVzID8/IChtYXRjaC5zY29wZXMgPSBbXSk7XG4gICAgICAgICAgbWF0Y2guc2NvcGVzLnB1c2goLi4uY2xvbmUyLnNjb3BlcyA/PyBbXSk7XG4gICAgICAgICAgaWYgKChtYXRjaC50eXBlID09PSBcImtleVwiIHx8IG1hdGNoLnR5cGUgPT09IFwidmFsdWVcIikgJiYgY2xvbmUyLmlkc01hcD8uc2l6ZSkge1xuICAgICAgICAgICAgX0RhdGFDb250cm9sbGVyLm1lcmdlSWRzTWFwKGNsb25lMi5pZHNNYXAsIG1hdGNoLmlkc01hcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgeyBpZHM6IFtdLCByZWplY3RzOiBbXSwgcmVzb2x2ZXM6IFtdLCBkYXRhOiBudWxsLCBvcHRzOiBudWxsIH1cbiAgICApO1xuICB9XG4gIHN0YXRpYyBtZXJnZUlkc01hcChmcm9tTWFwLCB0b01hcCkge1xuICAgIGZvciAoY29uc3QgW3Njb3BlLCBpZHNdIG9mIGZyb21NYXApIHtcbiAgICAgIGNvbnN0IHRvTWFwVmFsdWUgPSB0b01hcC5nZXQoc2NvcGUpO1xuICAgICAgaWYgKHRvTWFwVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB0b01hcC5zZXQoc2NvcGUsIG5ldyBTZXQoaWRzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgICAgIHRvTWFwVmFsdWUuYWRkKGlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgY3JlYXRlSWRzTWFwKHNjb3BlLCBwcm9wKSB7XG4gICAgaWYgKHByb3AuaWQgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBwcm9wLmlkc01hcCA/PyAocHJvcC5pZHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBpZiAocHJvcC5pZHNNYXAuaGFzKHNjb3BlKSkge1xuICAgICAgcHJvcC5pZHNNYXAuZ2V0KHNjb3BlKS5hZGQocHJvcC5pZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3AuaWRzTWFwLnNldChzY29wZSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW3Byb3AuaWRdKSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBkZWVwRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBiID09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBpLCBsZW5ndGgyO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgbGVuZ3RoMiA9IGEubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoMiAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gbGVuZ3RoMiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKCFfRGF0YUNvbnRyb2xsZXIuZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgbGVuZ3RoMiA9IGtleXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aDIgIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSBsZW5ndGgyIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKCFfRGF0YUNvbnRyb2xsZXIuc2tpcEtleXMuaGFzKGtleSkgJiYgKCFPYmplY3QuaGFzT3duKGIsIGtleSkgfHwgIV9EYXRhQ29udHJvbGxlci5kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbi8vIG9wdGltaXplZCB2ZXJzaW9uIG9mIGRlZXAgZXF1YWxpdHkgZm9yIGBtZXJnZVJlcXVlc3RzYCB3aGljaCBjYW4gcG90ZW50aWFsbHkgbG9vcCBvdmVyIDFNIHRpbWVzXG5fRGF0YUNvbnRyb2xsZXIuc2tpcEtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJpZFwiLCBcImlkc01hcFwiLCBcInR5cGVcIiwgXCJzY29wZXNcIiwgXCJkYXRhXCJdKTtcbnZhciBEYXRhQ29udHJvbGxlciA9IF9EYXRhQ29udHJvbGxlcjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZmFjdG9yeS9heGlzUmVnaXN0cnkudHNcbnZhciBBeGlzUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYXhlc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy50aGVtZVRlbXBsYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgcmVnaXN0ZXIoYXhpc1R5cGUsIG1vZHVsZSkge1xuICAgIHRoaXMuYXhlc01hcC5zZXQoYXhpc1R5cGUsIG1vZHVsZS5tb2R1bGVGYWN0b3J5KTtcbiAgICBpZiAobW9kdWxlLnRoZW1lVGVtcGxhdGUpIHtcbiAgICAgIHRoaXMuc2V0VGhlbWVUZW1wbGF0ZShheGlzVHlwZSwgbW9kdWxlLnRoZW1lVGVtcGxhdGUpO1xuICAgIH1cbiAgfVxuICBjcmVhdGUoYXhpc1R5cGUsIG1vZHVsZUNvbnRleHQpIHtcbiAgICBjb25zdCBheGlzRmFjdG9yeSA9IHRoaXMuYXhlc01hcC5nZXQoYXhpc1R5cGUpO1xuICAgIGlmIChheGlzRmFjdG9yeSkge1xuICAgICAgcmV0dXJuIGF4aXNGYWN0b3J5KG1vZHVsZUNvbnRleHQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIHVua25vd24gYXhpcyB0eXBlOiAke2F4aXNUeXBlfWApO1xuICB9XG4gIGhhcyhheGlzVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmF4ZXNNYXAuaGFzKGF4aXNUeXBlKTtcbiAgfVxuICBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLmF4ZXNNYXAua2V5cygpO1xuICB9XG4gIHNldFRoZW1lVGVtcGxhdGUoYXhpc1R5cGUsIHRoZW1lVGVtcGxhdGUpIHtcbiAgICB0aGlzLnRoZW1lVGVtcGxhdGVzLnNldChheGlzVHlwZSwgdGhlbWVUZW1wbGF0ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0VGhlbWVUZW1wbGF0ZShheGlzVHlwZSkge1xuICAgIHJldHVybiB0aGlzLnRoZW1lVGVtcGxhdGVzLmdldChheGlzVHlwZSk7XG4gIH1cbn07XG52YXIgYXhpc1JlZ2lzdHJ5ID0gbmV3IEF4aXNSZWdpc3RyeSgpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L2V4cGVjdGVkRW50ZXJwcmlzZU1vZHVsZXMudHNcbnZhciBFWFBFQ1RFRF9FTlRFUlBSSVNFX01PRFVMRVMgPSBbXG4gIHtcbiAgICB0eXBlOiBcInJvb3RcIixcbiAgICBvcHRpb25zS2V5OiBcImFuaW1hdGlvblwiLFxuICAgIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIiwgXCJzdGFuZGFsb25lXCIsIFwiZ2F1Z2VcIl1cbiAgfSxcbiAgeyB0eXBlOiBcInJvb3RcIiwgb3B0aW9uc0tleTogXCJhbm5vdGF0aW9uc1wiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0gfSxcbiAge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIG9wdGlvbnNLZXk6IFwiYmFja2dyb3VuZFwiLFxuICAgIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIiwgXCJzdGFuZGFsb25lXCIsIFwiZ2F1Z2VcIl0sXG4gICAgb3B0aW9uc0lubmVyS2V5OiBcImltYWdlXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIG9wdGlvbnNLZXk6IFwiZm9yZWdyb3VuZFwiLFxuICAgIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIiwgXCJzdGFuZGFsb25lXCIsIFwiZ2F1Z2VcIl0sXG4gICAgb3B0aW9uc0lubmVyS2V5OiBcImltYWdlXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIG9wdGlvbnNLZXk6IFwiY2hhcnRUb29sYmFyXCIsXG4gICAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcInJvb3RcIixcbiAgICBvcHRpb25zS2V5OiBcImNvbnRleHRNZW51XCIsXG4gICAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiLCBcInN0YW5kYWxvbmVcIiwgXCJnYXVnZVwiXVxuICB9LFxuICB7IHR5cGU6IFwicm9vdFwiLCBvcHRpb25zS2V5OiBcInN0YXR1c0JhclwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwic3RhdHVzLWJhclwiIH0sXG4gIHtcbiAgICB0eXBlOiBcInJvb3RcIixcbiAgICBvcHRpb25zS2V5OiBcImRhdGFTb3VyY2VcIixcbiAgICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIiwgXCJwb2xhclwiLCBcImhpZXJhcmNoeVwiLCBcInRvcG9sb2d5XCIsIFwiZmxvdy1wcm9wb3J0aW9uXCIsIFwic3RhbmRhbG9uZVwiLCBcImdhdWdlXCJdXG4gIH0sXG4gIHsgdHlwZTogXCJyb290XCIsIG9wdGlvbnNLZXk6IFwic3luY1wiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0gfSxcbiAgeyB0eXBlOiBcInJvb3RcIiwgb3B0aW9uc0tleTogXCJ6b29tXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInRvcG9sb2d5XCJdIH0sXG4gIHsgdHlwZTogXCJyb290XCIsIG9wdGlvbnNLZXk6IFwicmFuZ2VzXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSB9LFxuICB7XG4gICAgdHlwZTogXCJsZWdlbmRcIixcbiAgICBvcHRpb25zS2V5OiBcImdyYWRpZW50TGVnZW5kXCIsXG4gICAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiLCBcInN0YW5kYWxvbmVcIiwgXCJnYXVnZVwiXSxcbiAgICBpZGVudGlmaWVyOiBcImdyYWRpZW50XCJcbiAgfSxcbiAgeyB0eXBlOiBcInJvb3RcIiwgb3B0aW9uc0tleTogXCJuYXZpZ2F0b3JcIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdIH0sXG4gIHsgdHlwZTogXCJheGlzXCIsIG9wdGlvbnNLZXk6IFwiYXhlc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcImFuZ2xlLWNhdGVnb3J5XCIgfSxcbiAgeyB0eXBlOiBcImF4aXNcIiwgb3B0aW9uc0tleTogXCJheGVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwiYW5nbGUtbnVtYmVyXCIgfSxcbiAgeyB0eXBlOiBcImF4aXNcIiwgb3B0aW9uc0tleTogXCJheGVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwicmFkaXVzLWNhdGVnb3J5XCIgfSxcbiAgeyB0eXBlOiBcImF4aXNcIiwgb3B0aW9uc0tleTogXCJheGVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwicmFkaXVzLW51bWJlclwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwiYmFyXCIsIGNvbW11bml0eTogdHJ1ZSB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcImxpbmVcIiwgY29tbXVuaXR5OiB0cnVlIH0sXG4gIHsgdHlwZTogXCJheGlzXCIsIG9wdGlvbnNLZXk6IFwiYXhlc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJvcmRpbmFsLXRpbWVcIiB9LFxuICB7IHR5cGU6IFwiYXhpcy1vcHRpb25cIiwgb3B0aW9uc0tleTogXCJjcm9zc2hhaXJcIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwiYm94LXBsb3RcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcImNhbmRsZXN0aWNrXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJjb25lLWZ1bm5lbFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwiZnVubmVsXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJvaGxjXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJoZWF0bWFwXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJyYW5nZS1hcmVhXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJyYW5nZS1iYXJcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcIndhdGVyZmFsbFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSwgaWRlbnRpZmllcjogXCJuaWdodGluZ2FsZVwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSwgaWRlbnRpZmllcjogXCJyYWRhci1hcmVhXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcInJhZGFyLWxpbmVcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwicmFkaWFsLWJhclwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSwgaWRlbnRpZmllcjogXCJyYWRpYWwtY29sdW1uXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImhpZXJhcmNoeVwiXSwgaWRlbnRpZmllcjogXCJzdW5idXJzdFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJoaWVyYXJjaHlcIl0sIGlkZW50aWZpZXI6IFwidHJlZW1hcFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJ0b3BvbG9neVwiXSwgaWRlbnRpZmllcjogXCJtYXAtc2hhcGVcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1widG9wb2xvZ3lcIl0sIGlkZW50aWZpZXI6IFwibWFwLWxpbmVcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1widG9wb2xvZ3lcIl0sIGlkZW50aWZpZXI6IFwibWFwLW1hcmtlclwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJ0b3BvbG9neVwiXSwgaWRlbnRpZmllcjogXCJtYXAtc2hhcGUtYmFja2dyb3VuZFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJ0b3BvbG9neVwiXSwgaWRlbnRpZmllcjogXCJtYXAtbGluZS1iYWNrZ3JvdW5kXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImZsb3ctcHJvcG9ydGlvblwiXSwgaWRlbnRpZmllcjogXCJjaG9yZFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJmbG93LXByb3BvcnRpb25cIl0sIGlkZW50aWZpZXI6IFwic2Fua2V5XCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInN0YW5kYWxvbmVcIl0sIGlkZW50aWZpZXI6IFwicHlyYW1pZFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJnYXVnZVwiXSwgaWRlbnRpZmllcjogXCJsaW5lYXItZ2F1Z2VcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiZ2F1Z2VcIl0sIGlkZW50aWZpZXI6IFwicmFkaWFsLWdhdWdlXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllcy1vcHRpb25cIiwgb3B0aW9uc0tleTogXCJlcnJvckJhclwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwiZXJyb3ItYmFyc1wiIH0sXG4gIHsgdHlwZTogXCJjb250ZXh0XCIsIGNvbnRleHRLZXk6IFwic2hhcmVkVG9vbGJhclwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0gfVxuXTtcbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZVNlcmllc1R5cGUodHlwZSkge1xuICByZXR1cm4gRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTLnNvbWUoKHMpID0+IHMudHlwZSA9PT0gXCJzZXJpZXNcIiAmJiBzLmlkZW50aWZpZXIgPT09IHR5cGUpO1xufVxuZnVuY3Rpb24gZ2V0RW50ZXJwcmlzZVNlcmllc0NoYXJ0VHlwZXModHlwZSkge1xuICByZXR1cm4gRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTLmZpbmQoKHMpID0+IHMudHlwZSA9PT0gXCJzZXJpZXNcIiAmJiBzLmlkZW50aWZpZXIgPT09IHR5cGUpPy5jaGFydFR5cGVzO1xufVxuZnVuY3Rpb24gaXNFbnRlcnByaXNlQ2FydGVzaWFuKHNlcmllc1R5cGUpIHtcbiAgY29uc3QgdHlwZSA9IGdldEVudGVycHJpc2VTZXJpZXNDaGFydFR5cGVzKHNlcmllc1R5cGUpPy5maW5kKCh2KSA9PiB2ID09PSBcImNhcnRlc2lhblwiKTtcbiAgcmV0dXJuIHR5cGUgPT09IFwiY2FydGVzaWFuXCI7XG59XG5mdW5jdGlvbiBpc0VudGVycHJpc2VQb2xhcihzZXJpZXNUeXBlKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlKT8uZmluZCgodikgPT4gdiA9PT0gXCJwb2xhclwiKTtcbiAgcmV0dXJuIHR5cGUgPT09IFwicG9sYXJcIjtcbn1cbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZUhpZXJhcmNoeShzZXJpZXNUeXBlKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlKT8uZmluZCgodikgPT4gdiA9PT0gXCJoaWVyYXJjaHlcIik7XG4gIHJldHVybiB0eXBlID09PSBcImhpZXJhcmNoeVwiO1xufVxuZnVuY3Rpb24gaXNFbnRlcnByaXNlVG9wb2xvZ3koc2VyaWVzVHlwZSkge1xuICBjb25zdCB0eXBlID0gZ2V0RW50ZXJwcmlzZVNlcmllc0NoYXJ0VHlwZXMoc2VyaWVzVHlwZSk/LmZpbmQoKHYpID0+IHYgPT09IFwidG9wb2xvZ3lcIik7XG4gIHJldHVybiB0eXBlID09PSBcInRvcG9sb2d5XCI7XG59XG5mdW5jdGlvbiBpc0VudGVycHJpc2VGbG93UHJvcG9ydGlvbihzZXJpZXNUeXBlKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlKT8uZmluZCgodikgPT4gdiA9PT0gXCJmbG93LXByb3BvcnRpb25cIik7XG4gIHJldHVybiB0eXBlID09PSBcImZsb3ctcHJvcG9ydGlvblwiO1xufVxuZnVuY3Rpb24gaXNFbnRlcnByaXNlU3RhbmRhbG9uZShzZXJpZXNUeXBlKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlKT8uZmluZCgodikgPT4gdiA9PT0gXCJzdGFuZGFsb25lXCIpO1xuICByZXR1cm4gdHlwZSA9PT0gXCJzdGFuZGFsb25lXCI7XG59XG5mdW5jdGlvbiBpc0VudGVycHJpc2VHYXVnZShzZXJpZXNUeXBlKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlKT8uZmluZCgodikgPT4gdiA9PT0gXCJnYXVnZVwiKTtcbiAgcmV0dXJuIHR5cGUgPT09IFwiZ2F1Z2VcIjtcbn1cbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZU1vZHVsZShtb2R1bGUpIHtcbiAgcmV0dXJuIG1vZHVsZS5wYWNrYWdlVHlwZSA9PT0gXCJlbnRlcnByaXNlXCI7XG59XG5mdW5jdGlvbiB2ZXJpZnlJZk1vZHVsZUV4cGVjdGVkKG1vZHVsZSkge1xuICBpZiAoIWlzRW50ZXJwcmlzZU1vZHVsZShtb2R1bGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gaW50ZXJuYWwgY29uZmlndXJhdGlvbiBlcnJvciwgb25seSBlbnRlcnByaXNlIG1vZHVsZXMgbmVlZCB2ZXJpZmljYXRpb24uXCIpO1xuICB9XG4gIGNvbnN0IHN0dWIgPSBFWFBFQ1RFRF9FTlRFUlBSSVNFX01PRFVMRVMuZmluZCgocykgPT4ge1xuICAgIHJldHVybiBzLnR5cGUgPT09IG1vZHVsZS50eXBlICYmIChcIm9wdGlvbnNLZXlcIiBpbiBzICYmIFwib3B0aW9uc0tleVwiIGluIG1vZHVsZSA/IHMub3B0aW9uc0tleSA9PT0gbW9kdWxlLm9wdGlvbnNLZXkgOiB0cnVlKSAmJiAoXCJjb250ZXh0S2V5XCIgaW4gcyAmJiBcImNvbnRleHRLZXlcIiBpbiBtb2R1bGUgPyBzLmNvbnRleHRLZXkgPT09IG1vZHVsZS5jb250ZXh0S2V5IDogdHJ1ZSkgJiYgcy5pZGVudGlmaWVyID09PSBtb2R1bGUuaWRlbnRpZmllciAmJiBtb2R1bGUuY2hhcnRUeXBlcy5ldmVyeSgodCkgPT4gcy5jaGFydFR5cGVzLmluY2x1ZGVzKHQpKTtcbiAgfSk7XG4gIGlmIChzdHViKSB7XG4gICAgc3R1Yi51c2VDb3VudCA/PyAoc3R1Yi51c2VDb3VudCA9IDApO1xuICAgIHN0dWIudXNlQ291bnQrKztcbiAgfVxuICByZXR1cm4gc3R1YiAhPSBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VW51c2VkRXhwZWN0ZWRNb2R1bGVzKCkge1xuICByZXR1cm4gRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTLmZpbHRlcigoeyB1c2VDb3VudCB9KSA9PiB1c2VDb3VudCA9PSBudWxsIHx8IHVzZUNvdW50ID09PSAwKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZmFjdG9yeS9sZWdlbmRSZWdpc3RyeS50c1xudmFyIExlZ2VuZFJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmxlZ2VuZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy50aGVtZVRlbXBsYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgcmVnaXN0ZXIobGVnZW5kVHlwZSwgeyBvcHRpb25zS2V5LCBtb2R1bGVGYWN0b3J5LCB0aGVtZVRlbXBsYXRlIH0pIHtcbiAgICB0aGlzLmxlZ2VuZE1hcC5zZXQobGVnZW5kVHlwZSwgeyBvcHRpb25zS2V5LCBtb2R1bGVGYWN0b3J5IH0pO1xuICAgIHRoaXMudGhlbWVUZW1wbGF0ZXMuc2V0KG9wdGlvbnNLZXksIHRoZW1lVGVtcGxhdGUpO1xuICB9XG4gIGNyZWF0ZShsZWdlbmRUeXBlLCBtb2R1bGVDb250ZXh0KSB7XG4gICAgY29uc3QgbGVnZW5kRmFjdG9yeSA9IHRoaXMubGVnZW5kTWFwLmdldChsZWdlbmRUeXBlKT8ubW9kdWxlRmFjdG9yeTtcbiAgICBpZiAobGVnZW5kRmFjdG9yeSkge1xuICAgICAgcmV0dXJuIGxlZ2VuZEZhY3RvcnkobW9kdWxlQ29udGV4dCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gdW5rbm93biBsZWdlbmQgdHlwZTogJHtsZWdlbmRUeXBlfWApO1xuICB9XG4gIGdldFRoZW1lVGVtcGxhdGVzKCkge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXModGhpcy50aGVtZVRlbXBsYXRlcyk7XG4gIH1cbiAgZ2V0S2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmxlZ2VuZE1hcC5lbnRyaWVzKCkpLnJlZHVjZShcbiAgICAgIChyZXN1bHQsIFtsZWdlbmRUeXBlLCByZWNvcmRdKSA9PiB7XG4gICAgICAgIHJlc3VsdFtsZWdlbmRUeXBlXSA9IHJlY29yZC5vcHRpb25zS2V5O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfVxufTtcbnZhciBsZWdlbmRSZWdpc3RyeSA9IG5ldyBMZWdlbmRSZWdpc3RyeSgpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L2NoYXJ0VHlwZXMudHNcbnZhciBDaGFydFR5cGVzID0gY2xhc3MgZXh0ZW5kcyBNYXAge1xuICBnZXQoc2VyaWVzVHlwZSkge1xuICAgIHJldHVybiBzdXBlci5nZXQoc2VyaWVzVHlwZSkgPz8gXCJ1bmtub3duXCI7XG4gIH1cbiAgaXNDYXJ0ZXNpYW4oc2VyaWVzVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmdldChzZXJpZXNUeXBlKSA9PT0gXCJjYXJ0ZXNpYW5cIjtcbiAgfVxuICBpc1BvbGFyKHNlcmllc1R5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoc2VyaWVzVHlwZSkgPT09IFwicG9sYXJcIjtcbiAgfVxuICBpc0hpZXJhcmNoeShzZXJpZXNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHNlcmllc1R5cGUpID09PSBcImhpZXJhcmNoeVwiO1xuICB9XG4gIGlzVG9wb2xvZ3koc2VyaWVzVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmdldChzZXJpZXNUeXBlKSA9PT0gXCJ0b3BvbG9neVwiO1xuICB9XG4gIGlzRmxvd1Byb3BvcnRpb24oc2VyaWVzVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmdldChzZXJpZXNUeXBlKSA9PT0gXCJmbG93LXByb3BvcnRpb25cIjtcbiAgfVxuICBpc1N0YW5kYWxvbmUoc2VyaWVzVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmdldChzZXJpZXNUeXBlKSA9PT0gXCJzdGFuZGFsb25lXCI7XG4gIH1cbiAgaXNHYXVnZShzZXJpZXNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHNlcmllc1R5cGUpID09PSBcImdhdWdlXCI7XG4gIH1cbiAgZ2V0IHNlcmllc1R5cGVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMua2V5cygpKTtcbiAgfVxuICBnZXQgY2FydGVzaWFuVHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzVHlwZXMuZmlsdGVyKCh0KSA9PiB0aGlzLmlzQ2FydGVzaWFuKHQpKTtcbiAgfVxuICBnZXQgcG9sYXJUeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNUeXBlcy5maWx0ZXIoKHQpID0+IHRoaXMuaXNQb2xhcih0KSk7XG4gIH1cbiAgZ2V0IGhpZXJhcmNoeVR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc1R5cGVzLmZpbHRlcigodCkgPT4gdGhpcy5pc0hpZXJhcmNoeSh0KSk7XG4gIH1cbiAgZ2V0IHRvcG9sb2d5VHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzVHlwZXMuZmlsdGVyKCh0KSA9PiB0aGlzLmlzVG9wb2xvZ3kodCkpO1xuICB9XG4gIGdldCBmbG93UHJvcG9ydGlvblR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc1R5cGVzLmZpbHRlcigodCkgPT4gdGhpcy5pc0Zsb3dQcm9wb3J0aW9uKHQpKTtcbiAgfVxuICBnZXQgc3RhbmRhbG9uZVR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc1R5cGVzLmZpbHRlcigodCkgPT4gdGhpcy5pc1N0YW5kYWxvbmUodCkpO1xuICB9XG4gIGdldCBnYXVnZVR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc1R5cGVzLmZpbHRlcigodCkgPT4gdGhpcy5pc0dhdWdlKHQpKTtcbiAgfVxufTtcbnZhciBDaGFydERlZmF1bHRzID0gY2xhc3MgZXh0ZW5kcyBNYXAge1xuICBzZXQoY2hhcnRUeXBlLCBkZWZhdWx0cykge1xuICAgIHJldHVybiBzdXBlci5zZXQoY2hhcnRUeXBlLCBtZXJnZURlZmF1bHRzKGRlZmF1bHRzLCB0aGlzLmdldChjaGFydFR5cGUpKSk7XG4gIH1cbn07XG52YXIgY2hhcnRUeXBlczIgPSBuZXcgQ2hhcnRUeXBlcygpO1xudmFyIHB1YmxpY0NoYXJ0VHlwZXMgPSBuZXcgQ2hhcnRUeXBlcygpO1xudmFyIGNoYXJ0RGVmYXVsdHMgPSBuZXcgQ2hhcnREZWZhdWx0cygpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L3Nlcmllc1JlZ2lzdHJ5LnRzXG52YXIgU2VyaWVzUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2VyaWVzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnRoZW1lVGVtcGxhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICByZWdpc3RlcihzZXJpZXNUeXBlLCB7XG4gICAgY2hhcnRUeXBlczogW2NoYXJ0VHlwZV0sXG4gICAgbW9kdWxlRmFjdG9yeSxcbiAgICB0b29sdGlwRGVmYXVsdHM6IHRvb2x0aXBEZWZhdWx0czIsXG4gICAgZGVmYXVsdEF4ZXMsXG4gICAgdGhlbWVUZW1wbGF0ZSxcbiAgICBwYWxldHRlRmFjdG9yeSxcbiAgICBzb2xvLFxuICAgIHN0YWNrYWJsZSxcbiAgICBncm91cGFibGUsXG4gICAgc3RhY2tlZEJ5RGVmYXVsdCxcbiAgICBoaWRkZW5cbiAgfSkge1xuICAgIHRoaXMuc2V0VGhlbWVUZW1wbGF0ZShzZXJpZXNUeXBlLCB0aGVtZVRlbXBsYXRlKTtcbiAgICB0aGlzLnNlcmllc01hcC5zZXQoc2VyaWVzVHlwZSwge1xuICAgICAgbW9kdWxlRmFjdG9yeSxcbiAgICAgIHRvb2x0aXBEZWZhdWx0czogdG9vbHRpcERlZmF1bHRzMixcbiAgICAgIGRlZmF1bHRBeGVzLFxuICAgICAgcGFsZXR0ZUZhY3RvcnksXG4gICAgICBzb2xvLFxuICAgICAgc3RhY2thYmxlLFxuICAgICAgZ3JvdXBhYmxlLFxuICAgICAgc3RhY2tlZEJ5RGVmYXVsdFxuICAgIH0pO1xuICAgIGNoYXJ0VHlwZXMyLnNldChzZXJpZXNUeXBlLCBjaGFydFR5cGUpO1xuICAgIGlmICghaGlkZGVuKSB7XG4gICAgICBwdWJsaWNDaGFydFR5cGVzLnNldChzZXJpZXNUeXBlLCBjaGFydFR5cGUpO1xuICAgIH1cbiAgfVxuICBjcmVhdGUoc2VyaWVzVHlwZSwgbW9kdWxlQ29udGV4dCkge1xuICAgIGNvbnN0IHNlcmllc0ZhY3RvcnkgPSB0aGlzLnNlcmllc01hcC5nZXQoc2VyaWVzVHlwZSk/Lm1vZHVsZUZhY3Rvcnk7XG4gICAgaWYgKHNlcmllc0ZhY3RvcnkpIHtcbiAgICAgIHJldHVybiBzZXJpZXNGYWN0b3J5KG1vZHVsZUNvbnRleHQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIHVua25vd24gc2VyaWVzIHR5cGU6ICR7c2VyaWVzVHlwZX1gKTtcbiAgfVxuICBjbG9uZURlZmF1bHRBeGVzKHNlcmllc1R5cGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0QXhlcyA9IHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlKT8uZGVmYXVsdEF4ZXM7XG4gICAgaWYgKGRlZmF1bHRBeGVzID09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBheGVzID0gdHlwZW9mIGRlZmF1bHRBeGVzID09PSBcImZ1bmN0aW9uXCIgPyBkZWZhdWx0QXhlcyhvcHRpb25zKSA6IGRlZmF1bHRBeGVzO1xuICAgIHJldHVybiB7IGF4ZXM6IGRlZXBDbG9uZShheGVzKSB9O1xuICB9XG4gIGlzRGVyaXZlZERlZmF1bHRBeGVzKHNlcmllc1R5cGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlKT8uZGVmYXVsdEF4ZXMgPT09IFwiZnVuY3Rpb25cIjtcbiAgfVxuICBzZXRUaGVtZVRlbXBsYXRlKHNlcmllc1R5cGUsIHRoZW1lVGVtcGxhdGUpIHtcbiAgICBjb25zdCBjdXJyZW50VGVtcGxhdGUgPSB0aGlzLnRoZW1lVGVtcGxhdGVzLmdldChzZXJpZXNUeXBlKTtcbiAgICB0aGlzLnRoZW1lVGVtcGxhdGVzLnNldChzZXJpZXNUeXBlLCBtZXJnZURlZmF1bHRzKHRoZW1lVGVtcGxhdGUsIGN1cnJlbnRUZW1wbGF0ZSkpO1xuICB9XG4gIGdldFRoZW1lVGVtcGxhdGUoc2VyaWVzVHlwZSkge1xuICAgIHJldHVybiB0aGlzLnRoZW1lVGVtcGxhdGVzLmdldChzZXJpZXNUeXBlKTtcbiAgfVxuICBnZXRQYWxldHRlRmFjdG9yeShzZXJpZXNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlKT8ucGFsZXR0ZUZhY3Rvcnk7XG4gIH1cbiAgZ2V0VG9vbHRpcERlZmF1bHMoc2VyaWVzVHlwZSkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc01hcC5nZXQoc2VyaWVzVHlwZSk/LnRvb2x0aXBEZWZhdWx0cztcbiAgfVxuICBpc1NvbG8oc2VyaWVzVHlwZSkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc01hcC5nZXQoc2VyaWVzVHlwZSk/LnNvbG8gPz8gZmFsc2U7XG4gIH1cbiAgaXNHcm91cGFibGUoc2VyaWVzVHlwZSkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc01hcC5nZXQoc2VyaWVzVHlwZSk/Lmdyb3VwYWJsZSA/PyBmYWxzZTtcbiAgfVxuICBpc1N0YWNrYWJsZShzZXJpZXNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlKT8uc3RhY2thYmxlID8/IGZhbHNlO1xuICB9XG4gIGlzU3RhY2tlZEJ5RGVmYXVsdChzZXJpZXNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlKT8uc3RhY2tlZEJ5RGVmYXVsdCA/PyBmYWxzZTtcbiAgfVxufTtcbnZhciBzZXJpZXNSZWdpc3RyeSA9IG5ldyBTZXJpZXNSZWdpc3RyeSgpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9zeW5jTWFuYWdlci50c1xudmFyIF9TeW5jTWFuYWdlciA9IGNsYXNzIF9TeW5jTWFuYWdlciBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgfVxuICBzdWJzY3JpYmUoZ3JvdXBJZCA9IF9TeW5jTWFuYWdlci5ERUZBVUxUX0dST1VQKSB7XG4gICAgbGV0IHN5bmNHcm91cCA9IHRoaXMuZ2V0KGdyb3VwSWQpO1xuICAgIGlmICghc3luY0dyb3VwKSB7XG4gICAgICBzeW5jR3JvdXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgX1N5bmNNYW5hZ2VyLmNoYXJ0c0dyb3Vwcy5zZXQoZ3JvdXBJZCwgc3luY0dyb3VwKTtcbiAgICB9XG4gICAgc3luY0dyb3VwLmFkZCh0aGlzLmNoYXJ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB1bnN1YnNjcmliZShncm91cElkID0gX1N5bmNNYW5hZ2VyLkRFRkFVTFRfR1JPVVApIHtcbiAgICB0aGlzLmdldChncm91cElkKT8uZGVsZXRlKHRoaXMuY2hhcnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldENoYXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0O1xuICB9XG4gIGdldEdyb3VwKGdyb3VwSWQgPSBfU3luY01hbmFnZXIuREVGQVVMVF9HUk9VUCkge1xuICAgIGNvbnN0IHN5bmNHcm91cCA9IHRoaXMuZ2V0KGdyb3VwSWQpO1xuICAgIHJldHVybiBzeW5jR3JvdXAgPyBBcnJheS5mcm9tKHN5bmNHcm91cCkgOiBbXTtcbiAgfVxuICBnZXRHcm91cFNpYmxpbmdzKGdyb3VwSWQgPSBfU3luY01hbmFnZXIuREVGQVVMVF9HUk9VUCkge1xuICAgIHJldHVybiB0aGlzLmdldEdyb3VwKGdyb3VwSWQpLmZpbHRlcigoY2hhcnQpID0+IGNoYXJ0ICE9PSB0aGlzLmNoYXJ0KTtcbiAgfVxuICBnZXQoZ3JvdXBJZCkge1xuICAgIHJldHVybiBfU3luY01hbmFnZXIuY2hhcnRzR3JvdXBzLmdldChncm91cElkKTtcbiAgfVxufTtcbl9TeW5jTWFuYWdlci5jaGFydHNHcm91cHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuX1N5bmNNYW5hZ2VyLkRFRkFVTFRfR1JPVVAgPSBTeW1ib2woXCJzeW5jLWdyb3VwLWRlZmF1bHRcIik7XG52YXIgU3luY01hbmFnZXIgPSBfU3luY01hbmFnZXI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2tleWJvYXJkLnRzXG52YXIgS2V5Ym9hcmQgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBLZXlib2FyZC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIEtleWJvYXJkLnByb3RvdHlwZSwgXCJ0YWJJbmRleFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFwcGluZy9wcmVwYXJlQXhpcy50c1xudmFyIENhcnRlc2lhbkF4aXNQb3NpdGlvbnMgPSBbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIl07XG5mdW5jdGlvbiBpc0F4aXNQb3NpdGlvbihwb3NpdGlvbikge1xuICByZXR1cm4gdHlwZW9mIHBvc2l0aW9uID09PSBcInN0cmluZ1wiICYmIENhcnRlc2lhbkF4aXNQb3NpdGlvbnMuaW5jbHVkZXMocG9zaXRpb24pO1xufVxuZnVuY3Rpb24gZ3Vlc3NJbnZhbGlkUG9zaXRpb25zKGF4ZXMpIHtcbiAgY29uc3QgaW52YWxpZEF4ZXMgPSBbXTtcbiAgY29uc3QgdXNlZFBvc2l0aW9ucyA9IFtdO1xuICBjb25zdCBndWVzc2VzID0gWy4uLkNhcnRlc2lhbkF4aXNQb3NpdGlvbnNdO1xuICBmb3IgKGNvbnN0IGF4aXMgb2YgYXhlcykge1xuICAgIGlmIChheGlzIGluc3RhbmNlb2YgQ2FydGVzaWFuQXhpcykge1xuICAgICAgaWYgKGlzQXhpc1Bvc2l0aW9uKGF4aXMucG9zaXRpb24pKSB7XG4gICAgICAgIHVzZWRQb3NpdGlvbnMucHVzaChheGlzLnBvc2l0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFsaWRBeGVzLnB1c2goYXhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgYXhpcyBvZiBpbnZhbGlkQXhlcykge1xuICAgIGxldCBuZXh0R3Vlc3M7XG4gICAgZG8ge1xuICAgICAgbmV4dEd1ZXNzID0gZ3Vlc3Nlcy5wb3AoKTtcbiAgICB9IHdoaWxlIChuZXh0R3Vlc3MgJiYgdXNlZFBvc2l0aW9ucy5pbmNsdWRlcyhuZXh0R3Vlc3MpKTtcbiAgICBpZiAobmV4dEd1ZXNzID09IG51bGwpXG4gICAgICBicmVhaztcbiAgICBheGlzLnBvc2l0aW9uID0gbmV4dEd1ZXNzO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcHBpbmcvcHJlcGFyZVNlcmllcy50c1xudmFyIE1BVENISU5HX0tFWVMgPSBbXCJkaXJlY3Rpb25cIiwgXCJ4S2V5XCIsIFwieUtleVwiLCBcInNpemVLZXlcIiwgXCJhbmdsZUtleVwiLCBcInJhZGl1c0tleVwiLCBcIm5vcm1hbGl6ZWRUb1wiXTtcbmZ1bmN0aW9uIG1hdGNoU2VyaWVzT3B0aW9ucyhzZXJpZXMsIG9wdFNlcmllcywgb2xkT3B0c1Nlcmllcykge1xuICBjb25zdCBnZW5lcmF0ZUtleSA9ICh0eXBlLCBpLCBvcHRzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gW3R5cGVdO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE1BVENISU5HX0tFWVMpIHtcbiAgICAgIGlmIChrZXkgaW4gaSAmJiBpW2tleV0gIT0gbnVsbClcbiAgICAgICAgcmVzdWx0LnB1c2goYCR7a2V5fT0ke2lba2V5XX1gKTtcbiAgICB9XG4gICAgaWYgKG9wdHM/LnNlcmllc0dyb3VwaW5nKSB7XG4gICAgICByZXN1bHQucHVzaChgc2VyaWVzR3JvdXBpbmcuZ3JvdXBJZD0ke29wdHM/LnNlcmllc0dyb3VwaW5nLmdyb3VwSWR9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbihcIjtcIik7XG4gIH07XG4gIGNvbnN0IHNlcmllc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBpZHggPSAwO1xuICBmb3IgKGNvbnN0IHMgb2Ygc2VyaWVzKSB7XG4gICAgY29uc3Qga2V5ID0gZ2VuZXJhdGVLZXkocy50eXBlLCBzLnByb3BlcnRpZXMsIG9sZE9wdHNTZXJpZXM/LltpZHhdKTtcbiAgICBpZiAoIXNlcmllc01hcC5oYXMoa2V5KSkge1xuICAgICAgc2VyaWVzTWFwLnNldChrZXksIFtdKTtcbiAgICB9XG4gICAgc2VyaWVzTWFwLmdldChrZXkpPy5wdXNoKFtzLCBpZHgrK10pO1xuICB9XG4gIGNvbnN0IG9wdHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBpZHggPSAwO1xuICBmb3IgKGNvbnN0IG8gb2Ygb3B0U2VyaWVzKSB7XG4gICAgY29uc3Qga2V5ID0gZ2VuZXJhdGVLZXkoby50eXBlLCBvLCBvKTtcbiAgICBpZiAoIW9wdHNNYXAuaGFzKGtleSkpIHtcbiAgICAgIG9wdHNNYXAuc2V0KGtleSwgW10pO1xuICAgIH1cbiAgICBvcHRzTWFwLmdldChrZXkpPy5wdXNoKFtvLCBpZHgrK10pO1xuICB9XG4gIGNvbnN0IG92ZXJsYXAgPSBbLi4uc2VyaWVzTWFwLmtleXMoKV0uc29tZSgoaykgPT4gb3B0c01hcC5oYXMoaykpO1xuICBpZiAoIW92ZXJsYXApIHtcbiAgICByZXR1cm4geyBzdGF0dXM6IFwibm8tb3ZlcmxhcFwiLCBvbGRLZXlzOiBzZXJpZXNNYXAua2V5cygpLCBuZXdLZXlzOiBvcHRzTWFwLmtleXMoKSB9O1xuICB9XG4gIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgZm9yIChjb25zdCBba2V5LCBvcHRzVHVwbGVzXSBvZiBvcHRzTWFwLmVudHJpZXMoKSkge1xuICAgIGZvciAoY29uc3QgW29wdHMsIHRhcmdldElkeF0gb2Ygb3B0c1R1cGxlcykge1xuICAgICAgY29uc3Qgc2VyaWVzQXJyYXkgPSBzZXJpZXNNYXAuZ2V0KGtleSk7XG4gICAgICBpZiAoc2VyaWVzQXJyYXkgPT0gbnVsbCB8fCBzZXJpZXNBcnJheS5sZW5ndGggPCAxKSB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IG9wdHMsIHRhcmdldElkeCwgaWR4OiB0YXJnZXRJZHgsIHN0YXR1czogXCJhZGRcIiB9KTtcbiAgICAgICAgc2VyaWVzTWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtvdXRwdXRTZXJpZXMsIGN1cnJlbnRJZHhdID0gc2VyaWVzQXJyYXkuc2hpZnQoKTtcbiAgICAgIGNvbnN0IHByZXZpb3VzT3B0cyA9IG9sZE9wdHNTZXJpZXM/LltjdXJyZW50SWR4XSA/PyB7fTtcbiAgICAgIGNvbnN0IGRpZmYyID0ganNvbkRpZmYocHJldmlvdXNPcHRzLCBvcHRzID8/IHt9KTtcbiAgICAgIGNvbnN0IHsgZ3JvdXBJbmRleCwgc3RhY2tJbmRleCB9ID0gZGlmZjI/LnNlcmllc0dyb3VwaW5nID8/IHt9O1xuICAgICAgaWYgKGdyb3VwSW5kZXggIT0gbnVsbCB8fCBzdGFja0luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICBvcHRzLFxuICAgICAgICAgIHNlcmllczogb3V0cHV0U2VyaWVzLFxuICAgICAgICAgIGRpZmY6IGRpZmYyLFxuICAgICAgICAgIHRhcmdldElkeCxcbiAgICAgICAgICBpZHg6IGN1cnJlbnRJZHgsXG4gICAgICAgICAgc3RhdHVzOiBcInNlcmllcy1ncm91cGluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChkaWZmMikge1xuICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgIG9wdHMsXG4gICAgICAgICAgc2VyaWVzOiBvdXRwdXRTZXJpZXMsXG4gICAgICAgICAgZGlmZjogZGlmZjIsXG4gICAgICAgICAgdGFyZ2V0SWR4LFxuICAgICAgICAgIGlkeDogY3VycmVudElkeCxcbiAgICAgICAgICBzdGF0dXM6IFwidXBkYXRlXCJcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBvcHRzLCBzZXJpZXM6IG91dHB1dFNlcmllcywgdGFyZ2V0SWR4LCBpZHg6IGN1cnJlbnRJZHgsIHN0YXR1czogXCJuby1vcFwiIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHNlcmllc0FycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZXJpZXNNYXAuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qgc2VyaWVzQXJyYXkgb2Ygc2VyaWVzTWFwLnZhbHVlcygpKSB7XG4gICAgZm9yIChjb25zdCBbb3V0cHV0U2VyaWVzLCBjdXJyZW50SWR4XSBvZiBzZXJpZXNBcnJheSkge1xuICAgICAgY2hhbmdlcy5wdXNoKHsgc2VyaWVzOiBvdXRwdXRTZXJpZXMsIGlkeDogY3VycmVudElkeCwgdGFyZ2V0SWR4OiAtMSwgc3RhdHVzOiBcInJlbW92ZVwiIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBzdGF0dXM6IFwib3ZlcmxhcFwiLCBjaGFuZ2VzIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcHBpbmcvdHlwZXMudHNcbmZ1bmN0aW9uIG9wdGlvbnNUeXBlKGlucHV0KSB7XG4gIGNvbnN0IHsgc2VyaWVzIH0gPSBpbnB1dDtcbiAgaWYgKCFzZXJpZXMpXG4gICAgcmV0dXJuO1xuICByZXR1cm4gc2VyaWVzWzBdPy50eXBlID8/IFwibGluZVwiO1xufVxuZnVuY3Rpb24gaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyhpbnB1dCkge1xuICBjb25zdCBzcGVjaWZpZWRUeXBlID0gb3B0aW9uc1R5cGUoaW5wdXQpO1xuICBpZiAoc3BlY2lmaWVkVHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBjaGFydFR5cGVzMi5pc0NhcnRlc2lhbihzcGVjaWZpZWRUeXBlKSB8fCBpc0VudGVycHJpc2VDYXJ0ZXNpYW4oc3BlY2lmaWVkVHlwZSk7XG59XG5mdW5jdGlvbiBpc0FnUG9sYXJDaGFydE9wdGlvbnMoaW5wdXQpIHtcbiAgY29uc3Qgc3BlY2lmaWVkVHlwZSA9IG9wdGlvbnNUeXBlKGlucHV0KTtcbiAgaWYgKHNwZWNpZmllZFR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gY2hhcnRUeXBlczIuaXNQb2xhcihzcGVjaWZpZWRUeXBlKSB8fCBpc0VudGVycHJpc2VQb2xhcihzcGVjaWZpZWRUeXBlKTtcbn1cbmZ1bmN0aW9uIGlzQWdIaWVyYXJjaHlDaGFydE9wdGlvbnMoaW5wdXQpIHtcbiAgY29uc3Qgc3BlY2lmaWVkVHlwZSA9IG9wdGlvbnNUeXBlKGlucHV0KTtcbiAgaWYgKHNwZWNpZmllZFR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gY2hhcnRUeXBlczIuaXNIaWVyYXJjaHkoc3BlY2lmaWVkVHlwZSkgfHwgaXNFbnRlcnByaXNlSGllcmFyY2h5KHNwZWNpZmllZFR5cGUpO1xufVxuZnVuY3Rpb24gaXNBZ1RvcG9sb2d5Q2hhcnRPcHRpb25zKGlucHV0KSB7XG4gIGNvbnN0IHNwZWNpZmllZFR5cGUgPSBvcHRpb25zVHlwZShpbnB1dCk7XG4gIGlmIChzcGVjaWZpZWRUeXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0VHlwZXMyLmlzVG9wb2xvZ3koc3BlY2lmaWVkVHlwZSkgfHwgaXNFbnRlcnByaXNlVG9wb2xvZ3koc3BlY2lmaWVkVHlwZSk7XG59XG5mdW5jdGlvbiBpc0FnRmxvd1Byb3BvcnRpb25DaGFydE9wdGlvbnMoaW5wdXQpIHtcbiAgY29uc3Qgc3BlY2lmaWVkVHlwZSA9IG9wdGlvbnNUeXBlKGlucHV0KTtcbiAgaWYgKHNwZWNpZmllZFR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gY2hhcnRUeXBlczIuaXNGbG93UHJvcG9ydGlvbihzcGVjaWZpZWRUeXBlKSB8fCBpc0VudGVycHJpc2VGbG93UHJvcG9ydGlvbihzcGVjaWZpZWRUeXBlKTtcbn1cbmZ1bmN0aW9uIGlzQWdTdGFuZGFsb25lQ2hhcnRPcHRpb25zKGlucHV0KSB7XG4gIGNvbnN0IHNwZWNpZmllZFR5cGUgPSBvcHRpb25zVHlwZShpbnB1dCk7XG4gIGlmIChzcGVjaWZpZWRUeXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0VHlwZXMyLmlzU3RhbmRhbG9uZShzcGVjaWZpZWRUeXBlKSB8fCBpc0VudGVycHJpc2VTdGFuZGFsb25lKHNwZWNpZmllZFR5cGUpO1xufVxuZnVuY3Rpb24gaXNBZ0dhdWdlQ2hhcnRPcHRpb25zKGlucHV0KSB7XG4gIGNvbnN0IHNwZWNpZmllZFR5cGUgPSBvcHRpb25zVHlwZShpbnB1dCk7XG4gIGlmIChzcGVjaWZpZWRUeXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0VHlwZXMyLmlzR2F1Z2Uoc3BlY2lmaWVkVHlwZSkgfHwgaXNFbnRlcnByaXNlR2F1Z2Uoc3BlY2lmaWVkVHlwZSk7XG59XG5mdW5jdGlvbiBpc0FnUG9sYXJDaGFydE9wdGlvbnNXaXRoU2VyaWVzQmFzZWRMZWdlbmQoaW5wdXQpIHtcbiAgY29uc3Qgc3BlY2lmaWVkVHlwZSA9IG9wdGlvbnNUeXBlKGlucHV0KTtcbiAgcmV0dXJuIGlzQWdQb2xhckNoYXJ0T3B0aW9ucyhpbnB1dCkgJiYgc3BlY2lmaWVkVHlwZSAhPT0gXCJwaWVcIiAmJiBzcGVjaWZpZWRUeXBlICE9PSBcImRvbnV0XCI7XG59XG5mdW5jdGlvbiBpc1Nlcmllc09wdGlvblR5cGUoaW5wdXQpIHtcbiAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0VHlwZXMyLmhhcyhpbnB1dCk7XG59XG5mdW5jdGlvbiBpc0F4aXNPcHRpb25UeXBlKGlucHV0KSB7XG4gIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBheGlzUmVnaXN0cnkuaGFzKGlucHV0KTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbW9kdWxlc01hbmFnZXIudHNcbnZhciBNb2R1bGVzTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgTW9kdWxlTWFwIHtcbiAgYXBwbHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IG0gb2YgdGhpcy5tb2R1bGVNYXAudmFsdWVzKCkpIHtcbiAgICAgIGlmIChtLm1vZHVsZS5vcHRpb25zS2V5IGluIG9wdGlvbnMgJiYgaXNQcm9wZXJ0aWVzKG0ubW9kdWxlSW5zdGFuY2UpKSB7XG4gICAgICAgIG0ubW9kdWxlSW5zdGFuY2Uuc2V0KG9wdGlvbnNbbS5tb2R1bGUub3B0aW9uc0tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAqbGVnZW5kcygpIHtcbiAgICBmb3IgKGNvbnN0IHsgbW9kdWxlLCBtb2R1bGVJbnN0YW5jZSB9IG9mIHRoaXMubW9kdWxlTWFwLnZhbHVlcygpKSB7XG4gICAgICBpZiAobW9kdWxlLnR5cGUgIT09IFwibGVnZW5kXCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgeWllbGQge1xuICAgICAgICBsZWdlbmRUeXBlOiBtb2R1bGUuaWRlbnRpZmllcixcbiAgICAgICAgbGVnZW5kOiBtb2R1bGVJbnN0YW5jZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L292ZXJsYXkvb3ZlcmxheS50c1xudmFyIERFRkFVTFRfT1ZFUkxBWV9DTEFTUyA9IFwiYWctY2hhcnRzLW92ZXJsYXlcIjtcbnZhciBERUZBVUxUX09WRVJMQVlfREFSS19DTEFTUyA9IFwiYWctY2hhcnRzLWRhcmstb3ZlcmxheVwiO1xudmFyIE92ZXJsYXkgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoY2xhc3NOYW1lLCBkZWZhdWx0TWVzc2FnZUlkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICB0aGlzLmRlZmF1bHRNZXNzYWdlSWQgPSBkZWZhdWx0TWVzc2FnZUlkO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cbiAgZ2V0VGV4dChsb2NhbGVNYW5hZ2VyKSB7XG4gICAgcmV0dXJuIGxvY2FsZU1hbmFnZXIudCh0aGlzLnRleHQgPz8gdGhpcy5kZWZhdWx0TWVzc2FnZUlkKTtcbiAgfVxuICBnZXRFbGVtZW50KGFuaW1hdGlvbk1hbmFnZXIsIGxvY2FsZU1hbmFnZXIsIHJlY3QpIHtcbiAgICB0aGlzLmNvbnRlbnQ/LnJlbW92ZSgpO1xuICAgIHRoaXMuZm9jdXNCb3ggPSByZWN0O1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICBjb25zdCBodG1sQ29udGVudCA9IHRoaXMucmVuZGVyZXIoKTtcbiAgICAgIGlmIChodG1sQ29udGVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGh0bWxDb250ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGVtcERpdiA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRlbXBEaXYuaW5uZXJIVE1MID0gaHRtbENvbnRlbnQ7XG4gICAgICAgIHRoaXMuY29udGVudCA9IHRlbXBEaXYuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBtYXJnaW46IFwiOHB4XCIsXG4gICAgICAgIGZvbnRGYW1pbHk6IFwidmFyKC0tYWctY2hhcnRzLWZvbnQtZmFtaWx5KVwiLFxuICAgICAgICBmb250U2l6ZTogXCJ2YXIoLS1hZy1jaGFydHMtZm9udC1zaXplKVwiLFxuICAgICAgICBmb250V2VpZ2h0OiBcInZhcigtLWFnLWNoYXJ0cy1mb250LXdlaWdodClcIlxuICAgICAgfSk7XG4gICAgICBjb250ZW50LmlubmVyVGV4dCA9IHRoaXMuZ2V0VGV4dChsb2NhbGVNYW5hZ2VyKTtcbiAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyPy5hbmltYXRlKHtcbiAgICAgICAgZnJvbTogMCxcbiAgICAgICAgdG86IDEsXG4gICAgICAgIGlkOiBcIm92ZXJsYXlcIixcbiAgICAgICAgcGhhc2U6IFwiYWRkXCIsXG4gICAgICAgIGdyb3VwSWQ6IFwib3BhY2l0eVwiLFxuICAgICAgICBvblVwZGF0ZSh2YWx1ZSkge1xuICAgICAgICAgIGNvbnRlbnQuc3R5bGUub3BhY2l0eSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3RvcCgpIHtcbiAgICAgICAgICBjb250ZW50LnN0eWxlLm9wYWNpdHkgPSBcIjFcIjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gIH1cbiAgcmVtb3ZlRWxlbWVudChjbGVhbnVwID0gKCkgPT4gdGhpcy5jb250ZW50Py5yZW1vdmUoKSwgYW5pbWF0aW9uTWFuYWdlcikge1xuICAgIGlmICghdGhpcy5jb250ZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChhbmltYXRpb25NYW5hZ2VyKSB7XG4gICAgICBjb25zdCB7IGNvbnRlbnQgfSA9IHRoaXM7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLmFuaW1hdGUoe1xuICAgICAgICBmcm9tOiAxLFxuICAgICAgICB0bzogMCxcbiAgICAgICAgcGhhc2U6IFwicmVtb3ZlXCIsXG4gICAgICAgIGlkOiBcIm92ZXJsYXlcIixcbiAgICAgICAgZ3JvdXBJZDogXCJvcGFjaXR5XCIsXG4gICAgICAgIG9uVXBkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgY29udGVudC5zdHlsZS5vcGFjaXR5ID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TdG9wKCkge1xuICAgICAgICAgIGNsZWFudXA/LigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYW51cD8uKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmZvY3VzQm94ID0gdm9pZCAwO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIE92ZXJsYXkucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIE92ZXJsYXkucHJvdG90eXBlLCBcInRleHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgT3ZlcmxheS5wcm90b3R5cGUsIFwicmVuZGVyZXJcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L292ZXJsYXkvY2hhcnRPdmVybGF5cy50c1xudmFyIENoYXJ0T3ZlcmxheXMgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmRhcmtUaGVtZSA9IGZhbHNlO1xuICAgIHRoaXMubG9hZGluZyA9IG5ldyBPdmVybGF5KFwiYWctY2hhcnRzLWxvYWRpbmctb3ZlcmxheVwiLCBcIm92ZXJsYXlMb2FkaW5nRGF0YVwiKTtcbiAgICB0aGlzLm5vRGF0YSA9IG5ldyBPdmVybGF5KFwiYWctY2hhcnRzLW5vLWRhdGEtb3ZlcmxheVwiLCBcIm92ZXJsYXlOb0RhdGFcIik7XG4gICAgdGhpcy5ub1Zpc2libGVTZXJpZXMgPSBuZXcgT3ZlcmxheShcImFnLWNoYXJ0cy1uby12aXNpYmxlLXNlcmllc1wiLCBcIm92ZXJsYXlOb1Zpc2libGVTZXJpZXNcIik7XG4gICAgdGhpcy51bnN1cHBvcnRlZEJyb3dzZXIgPSBuZXcgT3ZlcmxheShcImFnLWNoYXJ0cy11bnN1cHBvcnRlZC1icm93c2VyXCIsIFwib3ZlcmxheVVuc3VwcG9ydGVkQnJvd3NlclwiKTtcbiAgfVxuICBnZXRGb2N1c0luZm8obG9jYWxlTWFuYWdlcikge1xuICAgIGZvciAoY29uc3Qgb3ZlcmxheSBvZiBbdGhpcy5sb2FkaW5nLCB0aGlzLm5vRGF0YSwgdGhpcy5ub1Zpc2libGVTZXJpZXMsIHRoaXMudW5zdXBwb3J0ZWRCcm93c2VyXSkge1xuICAgICAgaWYgKG92ZXJsYXkuZm9jdXNCb3ggIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyB0ZXh0OiBvdmVybGF5LmdldFRleHQobG9jYWxlTWFuYWdlciksIHJlY3Q6IG92ZXJsYXkuZm9jdXNCb3ggfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubG9hZGluZy5yZW1vdmVFbGVtZW50KCk7XG4gICAgdGhpcy5ub0RhdGEucmVtb3ZlRWxlbWVudCgpO1xuICAgIHRoaXMubm9WaXNpYmxlU2VyaWVzLnJlbW92ZUVsZW1lbnQoKTtcbiAgICB0aGlzLnVuc3VwcG9ydGVkQnJvd3Nlci5yZW1vdmVFbGVtZW50KCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQ2hhcnRPdmVybGF5cy5wcm90b3R5cGUsIFwiZGFya1RoZW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQ2hhcnRPdmVybGF5cy5wcm90b3R5cGUsIFwibG9hZGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIENoYXJ0T3ZlcmxheXMucHJvdG90eXBlLCBcIm5vRGF0YVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIENoYXJ0T3ZlcmxheXMucHJvdG90eXBlLCBcIm5vVmlzaWJsZVNlcmllc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIENoYXJ0T3ZlcmxheXMucHJvdG90eXBlLCBcInVuc3VwcG9ydGVkQnJvd3NlclwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvb3ZlcmxheS9sb2FkaW5nU3Bpbm5lci50c1xuZnVuY3Rpb24gZ2V0TG9hZGluZ1NwaW5uZXIodGV4dDIsIGRlZmF1bHREdXJhdGlvbikge1xuICBjb25zdCB7IGFuaW1hdGlvbkR1cmF0aW9uIH0gPSBQSEFTRV9NRVRBREFUQVtcImFkZFwiXTtcbiAgY29uc3QgZHVyYXRpb24gPSBhbmltYXRpb25EdXJhdGlvbiAqIGRlZmF1bHREdXJhdGlvbjtcbiAgY29uc3QgY29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBgJHtERUZBVUxUX09WRVJMQVlfQ0xBU1N9LS1sb2FkaW5nYCwge1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgZm9udDogXCIxM3B4IFZlcmRhbmEsIHNhbnMtc2VyaWZcIixcbiAgICAvLyBGT05UX1NJWkUuTUVESVVNXG4gICAgdXNlclNlbGVjdDogXCJub25lXCIsXG4gICAgYW5pbWF0aW9uOiBgYWctY2hhcnRzLWxvYWRpbmcgJHtkdXJhdGlvbn1tcyBsaW5lYXIgNTBtcyBib3RoYFxuICB9KTtcbiAgY29uc3QgbWF0cml4ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIHdpZHRoOiBcIjQ1cHhcIixcbiAgICBoZWlnaHQ6IFwiNDBweFwiLFxuICAgIGJhY2tncm91bmRJbWFnZTogW1xuICAgICAgXCJsaW5lYXItZ3JhZGllbnQoIzAwMDAgY2FsYygxICogMTAwJSAvIDYpLCAjY2NjIDAgY2FsYygzICogMTAwJSAvIDYpLCAjMDAwMCAwKSwgXCIsXG4gICAgICBcImxpbmVhci1ncmFkaWVudCgjMDAwMCBjYWxjKDIgKiAxMDAlIC8gNiksICNjY2MgMCBjYWxjKDQgKiAxMDAlIC8gNiksICMwMDAwIDApLCBcIixcbiAgICAgIFwibGluZWFyLWdyYWRpZW50KCMwMDAwIGNhbGMoMyAqIDEwMCUgLyA2KSwgI2NjYyAwIGNhbGMoNSAqIDEwMCUgLyA2KSwgIzAwMDAgMClcIlxuICAgIF0uam9pbihcIlwiKSxcbiAgICBiYWNrZ3JvdW5kU2l6ZTogXCIxMHB4IDQwMCVcIixcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcIm5vLXJlcGVhdFwiLFxuICAgIGFuaW1hdGlvbjogXCJhZy1jaGFydHMtbG9hZGluZy1tYXRyaXggMXMgaW5maW5pdGUgbGluZWFyXCJcbiAgfSk7XG4gIGNvbnN0IGxhYmVsID0gY3JlYXRlRWxlbWVudChcInBcIiwgeyBtYXJnaW5Ub3A6IFwiMWVtXCIgfSk7XG4gIGxhYmVsLmlubmVyVGV4dCA9IHRleHQyO1xuICBjb25zdCBiYWNrZ3JvdW5kID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBgJHtERUZBVUxUX09WRVJMQVlfQ0xBU1N9X19sb2FkaW5nLWJhY2tncm91bmRgLCB7XG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICBpbnNldDogXCIwXCIsXG4gICAgb3BhY2l0eTogXCIwLjVcIixcbiAgICB6SW5kZXg6IFwiLTFcIlxuICB9KTtcbiAgY29uc3QgYW5pbWF0aW9uU3R5bGVzID0gY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBhbmltYXRpb25TdHlsZXMuaW5uZXJUZXh0ID0gW1xuICAgIFwiQGtleWZyYW1lcyBhZy1jaGFydHMtbG9hZGluZyB7IGZyb20geyBvcGFjaXR5OiAwIH0gdG8geyBvcGFjaXR5OiAxIH0gfVwiLFxuICAgIFwiQGtleWZyYW1lcyBhZy1jaGFydHMtbG9hZGluZy1tYXRyaXgge1wiLFxuICAgIFwiMCUgeyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwJSAwJSwgNTAlIDAlLCAxMDAlIDAlOyB9XCIsXG4gICAgXCIxMDAlIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogMCUgMTAwJSwgNTAlIDEwMCUsIDEwMCUgMTAwJTsgfVwiLFxuICAgIFwifVwiXG4gIF0uam9pbihcIiBcIik7XG4gIGNvbnRhaW5lci5yZXBsYWNlQ2hpbGRyZW4oYW5pbWF0aW9uU3R5bGVzLCBtYXRyaXgsIGxhYmVsLCBiYWNrZ3JvdW5kKTtcbiAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc1pJbmRleE1hcC50c1xudmFyIFNlcmllc1pJbmRleE1hcCA9IC8qIEBfX1BVUkVfXyAqLyAoKFNlcmllc1pJbmRleE1hcDIpID0+IHtcbiAgU2VyaWVzWkluZGV4TWFwMltTZXJpZXNaSW5kZXhNYXAyW1wiQkFDS0dST1VORFwiXSA9IDBdID0gXCJCQUNLR1JPVU5EXCI7XG4gIFNlcmllc1pJbmRleE1hcDJbU2VyaWVzWkluZGV4TWFwMltcIkFOWV9DT05URU5UXCJdID0gMV0gPSBcIkFOWV9DT05URU5UXCI7XG4gIHJldHVybiBTZXJpZXNaSW5kZXhNYXAyO1xufSkoU2VyaWVzWkluZGV4TWFwIHx8IHt9KTtcbnZhciBTZXJpZXNDb250ZW50WkluZGV4TWFwID0gLyogQF9fUFVSRV9fICovICgoU2VyaWVzQ29udGVudFpJbmRleE1hcDIpID0+IHtcbiAgU2VyaWVzQ29udGVudFpJbmRleE1hcDJbU2VyaWVzQ29udGVudFpJbmRleE1hcDJbXCJGT1JFR1JPVU5EXCJdID0gMF0gPSBcIkZPUkVHUk9VTkRcIjtcbiAgU2VyaWVzQ29udGVudFpJbmRleE1hcDJbU2VyaWVzQ29udGVudFpJbmRleE1hcDJbXCJISUdITElHSFRcIl0gPSAxXSA9IFwiSElHSExJR0hUXCI7XG4gIFNlcmllc0NvbnRlbnRaSW5kZXhNYXAyW1Nlcmllc0NvbnRlbnRaSW5kZXhNYXAyW1wiTEFCRUxcIl0gPSAyXSA9IFwiTEFCRUxcIjtcbiAgcmV0dXJuIFNlcmllc0NvbnRlbnRaSW5kZXhNYXAyO1xufSkoU2VyaWVzQ29udGVudFpJbmRleE1hcCB8fCB7fSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXMudHNcbnZhciBTZXJpZXNOb2RlUGlja01vZGUgPSAvKiBAX19QVVJFX18gKi8gKChTZXJpZXNOb2RlUGlja01vZGUyKSA9PiB7XG4gIFNlcmllc05vZGVQaWNrTW9kZTJbU2VyaWVzTm9kZVBpY2tNb2RlMltcIkVYQUNUX1NIQVBFX01BVENIXCJdID0gMF0gPSBcIkVYQUNUX1NIQVBFX01BVENIXCI7XG4gIFNlcmllc05vZGVQaWNrTW9kZTJbU2VyaWVzTm9kZVBpY2tNb2RlMltcIk5FQVJFU1RfTk9ERVwiXSA9IDFdID0gXCJORUFSRVNUX05PREVcIjtcbiAgU2VyaWVzTm9kZVBpY2tNb2RlMltTZXJpZXNOb2RlUGlja01vZGUyW1wiQVhJU19BTElHTkVEXCJdID0gMl0gPSBcIkFYSVNfQUxJR05FRFwiO1xuICByZXR1cm4gU2VyaWVzTm9kZVBpY2tNb2RlMjtcbn0pKFNlcmllc05vZGVQaWNrTW9kZSB8fCB7fSk7XG52YXIgQ1JPU1NfRklMVEVSX01BUktFUl9GSUxMX09QQUNJVFlfRkFDVE9SID0gMC4yNTtcbnZhciBDUk9TU19GSUxURVJfTUFSS0VSX1NUUk9LRV9PUEFDSVRZX0ZBQ1RPUiA9IDAuMTI1O1xudmFyIFNlcmllc05vZGVFdmVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodHlwZSwgZXZlbnQsIHsgZGF0dW0gfSwgc2VyaWVzKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgdGhpcy5kYXR1bSA9IGRhdHVtO1xuICAgIHRoaXMuc2VyaWVzSWQgPSBzZXJpZXMuaWQ7XG4gIH1cbn07XG52YXIgU2VyaWVzR3JvdXBpbmdDaGFuZ2VkRXZlbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNlcmllcywgc2VyaWVzR3JvdXBpbmcsIG9sZEdyb3VwaW5nKSB7XG4gICAgdGhpcy5zZXJpZXMgPSBzZXJpZXM7XG4gICAgdGhpcy5zZXJpZXNHcm91cGluZyA9IHNlcmllc0dyb3VwaW5nO1xuICAgIHRoaXMub2xkR3JvdXBpbmcgPSBvbGRHcm91cGluZztcbiAgICB0aGlzLnR5cGUgPSBcImdyb3VwaW5nQ2hhbmdlZFwiO1xuICB9XG59O1xudmFyIFNlcmllcyA9IGNsYXNzIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIGNvbnN0cnVjdG9yKHNlcmllc09wdHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMudXNlc1BsYWNlZExhYmVscyA9IGZhbHNlO1xuICAgIHRoaXMuc2VyaWVzR3JvdXBpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5Ob2RlRXZlbnQgPSBTZXJpZXNOb2RlRXZlbnQ7XG4gICAgdGhpcy5pbnRlcm5hbElkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgLy8gVGhlIGdyb3VwIG5vZGUgdGhhdCBjb250YWlucyB0aGUgc2VyaWVzIHJlbmRlcmluZyBpbiBpdHMgZGVmYXVsdCAobm9uLWhpZ2hsaWdodGVkKSBzdGF0ZS5cbiAgICB0aGlzLmNvbnRlbnRHcm91cCA9IG5ldyBUcmFuc2xhdGFibGVHcm91cCh7XG4gICAgICBuYW1lOiBgJHt0aGlzLmludGVybmFsSWR9LWNvbnRlbnRgLFxuICAgICAgekluZGV4OiAxIC8qIEFOWV9DT05URU5UICovXG4gICAgfSk7XG4gICAgLy8gVGhlIGdyb3VwIG5vZGUgdGhhdCBjb250YWlucyBhbGwgaGlnaGxpZ2h0ZWQgc2VyaWVzIGl0ZW1zLiBUaGlzIGlzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pc2F0aW9uXG4gICAgLy8gZm9yIGxhcmdlLXNjYWxlIGRhdGEtc2V0cywgd2hlcmUgdGhlIG9ubHkgdGhpbmcgdGhhdCByb3V0aW5lbHkgdmFyaWVzIGlzIHRoZSBjdXJyZW50bHlcbiAgICAvLyBoaWdobGlnaHRlZCBub2RlLlxuICAgIHRoaXMuaGlnaGxpZ2h0R3JvdXAgPSBuZXcgVHJhbnNsYXRhYmxlR3JvdXAoe1xuICAgICAgbmFtZTogYCR7dGhpcy5pbnRlcm5hbElkfS1oaWdobGlnaHRgLFxuICAgICAgekluZGV4OiAxIC8qIEFOWV9DT05URU5UICovXG4gICAgfSk7XG4gICAgLy8gRXJyb3IgYmFycyBldGMuXG4gICAgdGhpcy5hbm5vdGF0aW9uR3JvdXAgPSBuZXcgVHJhbnNsYXRhYmxlR3JvdXAoe1xuICAgICAgbmFtZTogYCR7dGhpcy5pbnRlcm5hbElkfS1hbm5vdGF0aW9uYFxuICAgIH0pO1xuICAgIC8vIExhemlseSBpbml0aWFsaXNlZCBsYWJlbEdyb3VwIGZvciBsYWJlbCBwcmVzZW50YXRpb24uXG4gICAgdGhpcy5sYWJlbEdyb3VwID0gbmV3IFRyYW5zbGF0YWJsZUdyb3VwKHtcbiAgICAgIG5hbWU6IGAke3RoaXMuaW50ZXJuYWxJZH0tc2VyaWVzLWxhYmVsc2BcbiAgICB9KTtcbiAgICB0aGlzLmF4ZXMgPSB7XG4gICAgICBbXCJ4XCIgLyogWCAqL106IHZvaWQgMCxcbiAgICAgIFtcInlcIiAvKiBZICovXTogdm9pZCAwXG4gICAgfTtcbiAgICB0aGlzLmRpcmVjdGlvbnMgPSBbXCJ4XCIgLyogWCAqLywgXCJ5XCIgLyogWSAqL107XG4gICAgLy8gRmxhZyB0byBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIHJlY2FsY3VsYXRlIG5vZGUgZGF0YS5cbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gICAgdGhpcy5tb2R1bGVNYXAgPSBuZXcgTW9kdWxlTWFwKCk7XG4gICAgdGhpcy5kYXR1bUNhbGxiYWNrQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29ubmVjdHNUb1lBeGlzID0gZmFsc2U7XG4gICAgdGhpcy5fZGVjbGFyYXRpb25PcmRlciA9IC0xO1xuICAgIHRoaXMuc2VyaWVzTGlzdGVuZXJzID0gbmV3IExpc3RlbmVycygpO1xuICAgIHRoaXMuX3BpY2tOb2RlQ2FjaGUgPSBuZXcgTFJVQ2FjaGUoKTtcbiAgICBjb25zdCB7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBwaWNrTW9kZXMsXG4gICAgICBkaXJlY3Rpb25LZXlzID0ge30sXG4gICAgICBkaXJlY3Rpb25OYW1lcyA9IHt9LFxuICAgICAgY2FuSGF2ZUF4ZXMgPSBmYWxzZSxcbiAgICAgIHVzZXNQbGFjZWRMYWJlbHMgPSBmYWxzZVxuICAgIH0gPSBzZXJpZXNPcHRzO1xuICAgIHRoaXMuY3R4ID0gbW9kdWxlQ3R4O1xuICAgIHRoaXMuZGlyZWN0aW9uS2V5cyA9IGRpcmVjdGlvbktleXM7XG4gICAgdGhpcy5kaXJlY3Rpb25OYW1lcyA9IGRpcmVjdGlvbk5hbWVzO1xuICAgIHRoaXMuY2FuSGF2ZUF4ZXMgPSBjYW5IYXZlQXhlcztcbiAgICB0aGlzLnVzZXNQbGFjZWRMYWJlbHMgPSB1c2VzUGxhY2VkTGFiZWxzO1xuICAgIHRoaXMuaGlnaGxpZ2h0R3JvdXAgPSBuZXcgVHJhbnNsYXRhYmxlR3JvdXAoe1xuICAgICAgbmFtZTogYCR7dGhpcy5pbnRlcm5hbElkfS1oaWdobGlnaHRgXG4gICAgfSk7XG4gICAgdGhpcy5oaWdobGlnaHROb2RlID0gdGhpcy5oaWdobGlnaHRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBcImhpZ2hsaWdodE5vZGVcIiwgekluZGV4OiAwIH0pKTtcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsID0gdGhpcy5oaWdobGlnaHRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBcImhpZ2hsaWdodExhYmVsXCIsIHpJbmRleDogMTAgfSkpO1xuICAgIHRoaXMucGlja01vZGVzID0gcGlja01vZGVzO1xuICB9XG4gIGdldCBwaWNrTW9kZUF4aXMoKSB7XG4gICAgcmV0dXJuIFwibWFpblwiO1xuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzPy5pZCA/PyB0aGlzLmludGVybmFsSWQ7XG4gIH1cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudHlwZSA/PyBcIlwiO1xuICB9XG4gIGdldCBmb2N1c2FibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEgPz8gdGhpcy5fY2hhcnREYXRhO1xuICB9XG4gIHNldCB2aXNpYmxlKG5ld1Zpc2liaWxpdHkpIHtcbiAgICB0aGlzLnByb3BlcnRpZXMudmlzaWJsZSA9IG5ld1Zpc2liaWxpdHk7XG4gICAgdGhpcy5jdHgubGVnZW5kTWFuYWdlci50b2dnbGVJdGVtKHsgZW5hYmxlZDogbmV3VmlzaWJpbGl0eSwgc2VyaWVzSWQ6IHRoaXMuaWQgfSk7XG4gICAgdGhpcy5jdHgubGVnZW5kTWFuYWdlci51cGRhdGUoKTtcbiAgICB0aGlzLnZpc2libGVNYXliZUNoYW5nZWQoKTtcbiAgfVxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdHgubGVnZW5kTWFuYWdlci5nZXRTZXJpZXNFbmFibGVkKHRoaXMuaWQpID8/IHRoaXMucHJvcGVydGllcy52aXNpYmxlO1xuICB9XG4gIGdldCBoYXNEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEgIT0gbnVsbCAmJiB0aGlzLmRhdGEubGVuZ3RoID4gMDtcbiAgfVxuICBnZXQgdG9vbHRpcEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy50b29sdGlwPy5lbmFibGVkID8/IGZhbHNlO1xuICB9XG4gIG9uRGF0YUNoYW5nZSgpIHtcbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gICAgdGhpcy5fcGlja05vZGVDYWNoZS5jbGVhcigpO1xuICB9XG4gIHNldE9wdGlvbnNEYXRhKGlucHV0KSB7XG4gICAgdGhpcy5fZGF0YSA9IGlucHV0O1xuICAgIHRoaXMub25EYXRhQ2hhbmdlKCk7XG4gIH1cbiAgc2V0Q2hhcnREYXRhKGlucHV0KSB7XG4gICAgdGhpcy5fY2hhcnREYXRhID0gaW5wdXQ7XG4gICAgaWYgKHRoaXMuZGF0YSA9PT0gaW5wdXQpIHtcbiAgICAgIHRoaXMub25EYXRhQ2hhbmdlKCk7XG4gICAgfVxuICB9XG4gIG9uU2VyaWVzR3JvdXBpbmdDaGFuZ2UocHJldiwgbmV4dCkge1xuICAgIGNvbnN0IHsgaW50ZXJuYWxJZCwgdHlwZSwgdmlzaWJsZSB9ID0gdGhpcztcbiAgICBpZiAocHJldikge1xuICAgICAgdGhpcy5jdHguc2VyaWVzU3RhdGVNYW5hZ2VyLmRlcmVnaXN0ZXJTZXJpZXModGhpcyk7XG4gICAgfVxuICAgIGlmIChuZXh0KSB7XG4gICAgICB0aGlzLmN0eC5zZXJpZXNTdGF0ZU1hbmFnZXIucmVnaXN0ZXJTZXJpZXMoeyBpbnRlcm5hbElkLCB0eXBlLCB2aXNpYmxlLCBzZXJpZXNHcm91cGluZzogbmV4dCB9KTtcbiAgICB9XG4gICAgdGhpcy5maXJlRXZlbnQobmV3IFNlcmllc0dyb3VwaW5nQ2hhbmdlZEV2ZW50KHRoaXMsIG5leHQsIHByZXYpKTtcbiAgfVxuICBnZXRCYW5kU2NhbGVQYWRkaW5nKCkge1xuICAgIHJldHVybiB7IGlubmVyOiAxLCBvdXRlcjogMCB9O1xuICB9XG4gIGF0dGFjaFNlcmllcyhzZXJpZXNDb250ZW50Tm9kZSwgc2VyaWVzTm9kZSwgYW5ub3RhdGlvbk5vZGUpIHtcbiAgICBzZXJpZXNDb250ZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRHcm91cCk7XG4gICAgc2VyaWVzTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmhpZ2hsaWdodEdyb3VwKTtcbiAgICBzZXJpZXNOb2RlLmFwcGVuZENoaWxkKHRoaXMubGFiZWxHcm91cCk7XG4gICAgYW5ub3RhdGlvbk5vZGU/LmFwcGVuZENoaWxkKHRoaXMuYW5ub3RhdGlvbkdyb3VwKTtcbiAgfVxuICBkZXRhY2hTZXJpZXMoc2VyaWVzQ29udGVudE5vZGUsIHNlcmllc05vZGUsIGFubm90YXRpb25Ob2RlKSB7XG4gICAgc2VyaWVzQ29udGVudE5vZGU/LnJlbW92ZUNoaWxkKHRoaXMuY29udGVudEdyb3VwKTtcbiAgICBzZXJpZXNOb2RlLnJlbW92ZUNoaWxkKHRoaXMuaGlnaGxpZ2h0R3JvdXApO1xuICAgIHNlcmllc05vZGUucmVtb3ZlQ2hpbGQodGhpcy5sYWJlbEdyb3VwKTtcbiAgICBhbm5vdGF0aW9uTm9kZT8ucmVtb3ZlQ2hpbGQodGhpcy5hbm5vdGF0aW9uR3JvdXApO1xuICB9XG4gIHNldFNlcmllc0luZGV4KGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSB0aGlzLl9kZWNsYXJhdGlvbk9yZGVyKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuX2RlY2xhcmF0aW9uT3JkZXIgPSBpbmRleDtcbiAgICB0aGlzLmNvbnRlbnRHcm91cC56SW5kZXggPSBbMSAvKiBBTllfQ09OVEVOVCAqLywgaW5kZXgsIDAgLyogRk9SRUdST1VORCAqL107XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC56SW5kZXggPSBbMSAvKiBBTllfQ09OVEVOVCAqLywgaW5kZXgsIDEgLyogSElHSExJR0hUICovXTtcbiAgICB0aGlzLmxhYmVsR3JvdXAuekluZGV4ID0gWzEgLyogQU5ZX0NPTlRFTlQgKi8sIGluZGV4LCAyIC8qIExBQkVMICovXTtcbiAgICB0aGlzLmFubm90YXRpb25Hcm91cC56SW5kZXggPSBpbmRleDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZW5kZXJUb09mZnNjcmVlbkNhbnZhcygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiBzdXBlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuICBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiB0aGlzLnNlcmllc0xpc3RlbmVycy5hZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gIH1cbiAgZGlzcGF0Y2godHlwZSwgZXZlbnQpIHtcbiAgICB0aGlzLnNlcmllc0xpc3RlbmVycy5kaXNwYXRjaCh0eXBlLCBldmVudCk7XG4gIH1cbiAgYWRkQ2hhcnRFdmVudExpc3RlbmVycygpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZikgPT4gZigpKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLnJlc2V0RGF0dW1DYWxsYmFja0NhY2hlKCk7XG4gICAgdGhpcy5jdHguc2VyaWVzU3RhdGVNYW5hZ2VyLmRlcmVnaXN0ZXJTZXJpZXModGhpcyk7XG4gIH1cbiAgZ2V0RGlyZWN0aW9uVmFsdWVzKGRpcmVjdGlvbiwgcHJvcGVydGllcykge1xuICAgIGNvbnN0IHJlc29sdmVkRGlyZWN0aW9uID0gdGhpcy5yZXNvbHZlS2V5RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgY29uc3Qga2V5cyA9IHByb3BlcnRpZXM/LltyZXNvbHZlZERpcmVjdGlvbl07XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgaWYgKCFrZXlzKSB7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICBjb25zdCBhZGRWYWx1ZXMgPSAoLi4uaXRlbXMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgaXRlbXMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgYWRkVmFsdWVzKC4uLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBhZGRWYWx1ZXMoLi4uT2JqZWN0LnZhbHVlcyh2YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgYWRkVmFsdWVzKC4uLmtleXMubWFwKChrZXkpID0+IHRoaXMucHJvcGVydGllc1trZXldKSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICBnZXRLZXlzKGRpcmVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLmdldERpcmVjdGlvblZhbHVlcyhkaXJlY3Rpb24sIHRoaXMuZGlyZWN0aW9uS2V5cyk7XG4gIH1cbiAgZ2V0S2V5UHJvcGVydGllcyhkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb25LZXlzW3RoaXMucmVzb2x2ZUtleURpcmVjdGlvbihkaXJlY3Rpb24pXSA/PyBbXTtcbiAgfVxuICBnZXROYW1lcyhkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5nZXREaXJlY3Rpb25WYWx1ZXMoZGlyZWN0aW9uLCB0aGlzLmRpcmVjdGlvbk5hbWVzKTtcbiAgfVxuICByZXNvbHZlS2V5RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIHJldHVybiBkaXJlY3Rpb247XG4gIH1cbiAgLy8gVGhlIHVuaW9uIG9mIHRoZSBzZXJpZXMgZG9tYWluICgnY29tbXVuaXR5JykgYW5kIHNlcmllcy1vcHRpb24gZG9tYWlucyAoJ2VudGVycHJpc2UnKS5cbiAgZ2V0RG9tYWluKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHNlcmllc0RvbWFpbiA9IHRoaXMuZ2V0U2VyaWVzRG9tYWluKGRpcmVjdGlvbik7XG4gICAgY29uc3QgbW9kdWxlRG9tYWlucyA9IHRoaXMubW9kdWxlTWFwLm1hcE1vZHVsZXMoKG1vZHVsZSkgPT4gbW9kdWxlLmdldERvbWFpbihkaXJlY3Rpb24pKS5mbGF0KCk7XG4gICAgcmV0dXJuIG1vZHVsZURvbWFpbnMubGVuZ3RoICE9PSAwID8gc2VyaWVzRG9tYWluLmNvbmNhdChtb2R1bGVEb21haW5zKSA6IHNlcmllc0RvbWFpbjtcbiAgfVxuICBnZXRSYW5nZShkaXJlY3Rpb24sIHZpc2libGVSYW5nZSkge1xuICAgIHJldHVybiB0aGlzLmdldFNlcmllc1JhbmdlKGRpcmVjdGlvbiwgdmlzaWJsZVJhbmdlKTtcbiAgfVxuICBnZXRWaXNpYmxlSXRlbXMoX3hWaXNpYmxlUmFuZ2UsIF95VmlzaWJsZVJhbmdlLCBfbWluVmlzaWJsZUl0ZW1zKSB7XG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG4gIGdldEdyYWRpZW50RmlsbE9wdGlvbnMoeyBib3VuZHMgfSwgZGVmYXVsdENvbG9yUmFuZ2UpIHtcbiAgICBjb25zdCB7IGF4ZXMgfSA9IHRoaXM7XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBjb25zdCB4UmFuZ2UgPSB4QXhpcz8ucmFuZ2UgPz8gWzAsIDFdO1xuICAgIGNvbnN0IHlSYW5nZSA9IHlBeGlzPy5yYW5nZSA/PyBbMCwgMV07XG4gICAgY29uc3QgW3gxLCB4Ml0gPSBmaW5kTWluTWF4KHhSYW5nZSk7XG4gICAgY29uc3QgW3kxLCB5Ml0gPSBmaW5kTWluTWF4KHlSYW5nZSk7XG4gICAgY29uc3Qgd2lkdGgyID0geDIgLSB4MTtcbiAgICBjb25zdCBoZWlnaHQyID0geTIgLSB5MTtcbiAgICBsZXQgZG9tYWluID0gWzAsIDFdO1xuICAgIGlmIChib3VuZHMgPT09IFwic2VyaWVzXCIpIHtcbiAgICAgIGRvbWFpbiA9IHRoaXMuZ2V0U2VyaWVzRG9tYWluKFwieVwiIC8qIFkgKi8pO1xuICAgIH0gZWxzZSBpZiAoYm91bmRzID09PSBcImF4ZXNcIikge1xuICAgICAgZG9tYWluID0geUF4aXM/LnNjYWxlLmRvbWFpbiA/PyBbMCwgMV07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBiYm94OiBuZXcgQkJveCh4MSwgeTEsIHdpZHRoMiwgaGVpZ2h0MiksXG4gICAgICBkb21haW4sXG4gICAgICBkZWZhdWx0Q29sb3JSYW5nZVxuICAgIH07XG4gIH1cbiAgLy8gSW5kaWNhdGUgdGhhdCBzb21ldGhpbmcgZXh0ZXJuYWwgY2hhbmdlZCBhbmQgd2Ugc2hvdWxkIHJlY2FsY3VsYXRlIG5vZGVEYXRhLlxuICBtYXJrTm9kZURhdGFEaXJ0eSgpIHtcbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gICAgdGhpcy5fcGlja05vZGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMudmlzaWJsZU1heWJlQ2hhbmdlZCgpO1xuICB9XG4gIHZpc2libGVNYXliZUNoYW5nZWQoKSB7XG4gICAgdGhpcy5jdHguc2VyaWVzU3RhdGVNYW5hZ2VyLnVwZGF0ZVNlcmllcyh0aGlzKTtcbiAgfVxuICBnZXRPcGFjaXR5KCkge1xuICAgIGNvbnN0IGRlZmF1bHRPcGFjaXR5ID0gMTtcbiAgICBjb25zdCB7IGRpbU9wYWNpdHkgPSAxLCBlbmFibGVkID0gdHJ1ZSB9ID0gdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodFN0eWxlLnNlcmllcztcbiAgICBpZiAoIWVuYWJsZWQgfHwgZGltT3BhY2l0eSA9PT0gZGVmYXVsdE9wYWNpdHkpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0T3BhY2l0eTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLmlzSXRlbUlkSGlnaGxpZ2h0ZWQoKSkge1xuICAgICAgY2FzZSAwIC8qIE5vbmUgKi86XG4gICAgICBjYXNlIDEgLyogVGhpcyAqLzpcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRPcGFjaXR5O1xuICAgICAgY2FzZSAyIC8qIE90aGVyICovOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGRpbU9wYWNpdHk7XG4gICAgfVxuICB9XG4gIGdldFN0cm9rZVdpZHRoKGRlZmF1bHRTdHJva2VXaWR0aCkge1xuICAgIGNvbnN0IHsgc3Ryb2tlV2lkdGgsIGVuYWJsZWQgPSB0cnVlIH0gPSB0aGlzLnByb3BlcnRpZXMuaGlnaGxpZ2h0U3R5bGUuc2VyaWVzO1xuICAgIGlmICghZW5hYmxlZCB8fCBzdHJva2VXaWR0aCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFN0cm9rZVdpZHRoO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMuaXNJdGVtSWRIaWdobGlnaHRlZCgpKSB7XG4gICAgICBjYXNlIDEgLyogVGhpcyAqLzpcbiAgICAgICAgcmV0dXJuIHN0cm9rZVdpZHRoO1xuICAgICAgY2FzZSAwIC8qIE5vbmUgKi86XG4gICAgICBjYXNlIDIgLyogT3RoZXIgKi86XG4gICAgICAgIHJldHVybiBkZWZhdWx0U3Ryb2tlV2lkdGg7XG4gICAgfVxuICB9XG4gIGlzSXRlbUlkSGlnaGxpZ2h0ZWQoKSB7XG4gICAgY29uc3Qgc2VyaWVzID0gdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlcj8uZ2V0QWN0aXZlSGlnaGxpZ2h0KCk/LnNlcmllcztcbiAgICBpZiAoc2VyaWVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgfVxuICAgIGlmIChzZXJpZXMgIT09IHRoaXMpIHtcbiAgICAgIHJldHVybiAyIC8qIE90aGVyICovO1xuICAgIH1cbiAgICByZXR1cm4gMSAvKiBUaGlzICovO1xuICB9XG4gIGdldE1vZHVsZVRvb2x0aXBQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlTWFwLm1hcE1vZHVsZXMoKG1vZHVsZSkgPT4gbW9kdWxlLmdldFRvb2x0aXBQYXJhbXMoKSkucmVkdWNlKCh0b3RhbCwgY3VycmVudCkgPT4gT2JqZWN0LmFzc2lnbih0b3RhbCwgY3VycmVudCksIHt9KTtcbiAgfVxuICBwaWNrTm9kZShwb2ludCwgaW50ZW50LCBleGFjdE1hdGNoT25seSA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyBwaWNrTW9kZXMsIHBpY2tNb2RlQXhpcywgdmlzaWJsZSwgY29udGVudEdyb3VwIH0gPSB0aGlzO1xuICAgIGlmICghdmlzaWJsZSB8fCAhY29udGVudEdyb3VwLnZpc2libGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGludGVudCA9PT0gXCJoaWdobGlnaHRcIiAmJiAhdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodC5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChpbnRlbnQgPT09IFwiaGlnaGxpZ2h0LXRvb2x0aXBcIiAmJiAhdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodC5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBtYXhEaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGlmIChpbnRlbnQgPT09IFwidG9vbHRpcFwiIHx8IGludGVudCA9PT0gXCJoaWdobGlnaHQtdG9vbHRpcFwiKSB7XG4gICAgICBjb25zdCB7IHRvb2x0aXAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICAgIG1heERpc3RhbmNlID0gdHlwZW9mIHRvb2x0aXAucmFuZ2UgPT09IFwibnVtYmVyXCIgPyB0b29sdGlwLnJhbmdlIDogSW5maW5pdHk7XG4gICAgICBleGFjdE1hdGNoT25seSB8fCAoZXhhY3RNYXRjaE9ubHkgPSB0b29sdGlwLnJhbmdlID09PSBcImV4YWN0XCIpO1xuICAgIH0gZWxzZSBpZiAoaW50ZW50ID09PSBcImV2ZW50XCIgfHwgaW50ZW50ID09PSBcImNvbnRleHQtbWVudVwiKSB7XG4gICAgICBjb25zdCB7IG5vZGVDbGlja1JhbmdlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICBtYXhEaXN0YW5jZSA9IHR5cGVvZiBub2RlQ2xpY2tSYW5nZSA9PT0gXCJudW1iZXJcIiA/IG5vZGVDbGlja1JhbmdlIDogSW5maW5pdHk7XG4gICAgICBleGFjdE1hdGNoT25seSB8fCAoZXhhY3RNYXRjaE9ubHkgPSBub2RlQ2xpY2tSYW5nZSA9PT0gXCJleGFjdFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRQaWNrTW9kZXMgPSBwaWNrTW9kZXMuZmlsdGVyKFxuICAgICAgKG0pID0+ICFleGFjdE1hdGNoT25seSB8fCBtID09PSAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXG4gICAgKTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50O1xuICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KHsgeCwgeSwgbWF4RGlzdGFuY2UsIHNlbGVjdGVkUGlja01vZGVzIH0pO1xuICAgIGlmICh0aGlzLl9waWNrTm9kZUNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGlja05vZGVDYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwaWNrTW9kZSBvZiBzZWxlY3RlZFBpY2tNb2Rlcykge1xuICAgICAgbGV0IG1hdGNoO1xuICAgICAgc3dpdGNoIChwaWNrTW9kZSkge1xuICAgICAgICBjYXNlIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi86XG4gICAgICAgICAgbWF0Y2ggPSB0aGlzLnBpY2tOb2RlRXhhY3RTaGFwZShwb2ludCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBORUFSRVNUX05PREUgKi86XG4gICAgICAgICAgbWF0Y2ggPSB0aGlzLnBpY2tOb2RlQ2xvc2VzdERhdHVtKHBvaW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyIC8qIEFYSVNfQUxJR05FRCAqLzpcbiAgICAgICAgICBtYXRjaCA9IHBpY2tNb2RlQXhpcyAhPSBudWxsID8gdGhpcy5waWNrTm9kZU1haW5BeGlzRmlyc3QocG9pbnQsIHBpY2tNb2RlQXhpcyA9PT0gXCJtYWluLWNhdGVnb3J5XCIpIDogdm9pZCAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmRpc3RhbmNlIDw9IG1heERpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waWNrTm9kZUNhY2hlLnNldChrZXksIHsgcGlja01vZGUsIG1hdGNoOiBtYXRjaC5kYXR1bSwgZGlzdGFuY2U6IG1hdGNoLmRpc3RhbmNlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGlja05vZGVDYWNoZS5zZXQoa2V5LCB2b2lkIDApO1xuICB9XG4gIHBpY2tOb2RlRXhhY3RTaGFwZShwb2ludCkge1xuICAgIGNvbnN0IG1hdGNoID0gdGhpcy5jb250ZW50R3JvdXAucGlja05vZGUocG9pbnQueCwgcG9pbnQueSk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmRhdHVtLm1pc3NpbmcgIT09IHRydWUpIHtcbiAgICAgIHJldHVybiB7IGRhdHVtOiBtYXRjaC5kYXR1bSwgZGlzdGFuY2U6IDAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBwaWNrTm9kZUNsb3Nlc3REYXR1bShfcG9pbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBTZXJpZXMucGlja05vZGVDbG9zZXN0RGF0dW0oKSBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcGlja05vZGVOZWFyZXN0RGlzdGFudE9iamVjdChwb2ludCwgaXRlbXMpIHtcbiAgICBjb25zdCBtYXRjaCA9IG5lYXJlc3RTcXVhcmVkKHBvaW50LngsIHBvaW50LnksIGl0ZW1zKTtcbiAgICBpZiAobWF0Y2gubmVhcmVzdCAhPT0gdm9pZCAwICYmIG1hdGNoLm5lYXJlc3QuZGF0dW0ubWlzc2luZyAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHsgZGF0dW06IG1hdGNoLm5lYXJlc3QuZGF0dW0sIGRpc3RhbmNlOiBNYXRoLnNxcnQobWF0Y2guZGlzdGFuY2VTcXVhcmVkKSB9O1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHBpY2tOb2RlTWFpbkF4aXNGaXJzdChfcG9pbnQsIF9yZXF1aXJlQ2F0ZWdvcnlBeGlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gU2VyaWVzLnBpY2tOb2RlTWFpbkF4aXNGaXJzdCgpIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBnZXRMYWJlbERhdGEoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHVwZGF0ZVBsYWNlZExhYmVsRGF0YShfbGFiZWxzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZpcmVOb2RlQ2xpY2tFdmVudChldmVudCwgZGF0dW0pIHtcbiAgICB0aGlzLmZpcmVFdmVudChuZXcgdGhpcy5Ob2RlRXZlbnQoXCJub2RlQ2xpY2tcIiwgZXZlbnQsIGRhdHVtLCB0aGlzKSk7XG4gIH1cbiAgZmlyZU5vZGVEb3VibGVDbGlja0V2ZW50KGV2ZW50LCBkYXR1bSkge1xuICAgIHRoaXMuZmlyZUV2ZW50KG5ldyB0aGlzLk5vZGVFdmVudChcIm5vZGVEb3VibGVDbGlja1wiLCBldmVudCwgZGF0dW0sIHRoaXMpKTtcbiAgfVxuICBjcmVhdGVOb2RlQ29udGV4dE1lbnVBY3Rpb25FdmVudChldmVudCwgZGF0dW0pIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuTm9kZUV2ZW50KFwibm9kZUNvbnRleHRNZW51QWN0aW9uXCIsIGV2ZW50LCBkYXR1bSwgdGhpcyk7XG4gIH1cbiAgb25MZWdlbmRJbml0aWFsU3RhdGUobGVnZW5kVHlwZSwgaW5pdGlhbFN0YXRlKSB7XG4gICAgY29uc3QgeyB2aXNpYmxlID0gdHJ1ZSwgaXRlbUlkLCBsZWdlbmRJdGVtTmFtZSB9ID0gaW5pdGlhbFN0YXRlID8/IHt9O1xuICAgIHRoaXMudG9nZ2xlU2VyaWVzSXRlbSh2aXNpYmxlLCBsZWdlbmRUeXBlLCBpdGVtSWQsIGxlZ2VuZEl0ZW1OYW1lKTtcbiAgfVxuICBvbkxlZ2VuZEl0ZW1DbGljayhldmVudCkge1xuICAgIGNvbnN0IHsgZW5hYmxlZCwgaXRlbUlkLCBzZXJpZXMsIGxlZ2VuZFR5cGUgfSA9IGV2ZW50O1xuICAgIGNvbnN0IGxlZ2VuZEl0ZW1OYW1lID0gXCJsZWdlbmRJdGVtTmFtZVwiIGluIHRoaXMucHJvcGVydGllcyA/IHRoaXMucHJvcGVydGllcy5sZWdlbmRJdGVtTmFtZSA6IHZvaWQgMDtcbiAgICBjb25zdCBsZWdlbmRJdGVtS2V5ID0gXCJsZWdlbmRJdGVtS2V5XCIgaW4gdGhpcy5wcm9wZXJ0aWVzID8gdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXkgOiB2b2lkIDA7XG4gICAgY29uc3QgbWF0Y2hlZExlZ2VuZEl0ZW1OYW1lID0gbGVnZW5kSXRlbU5hbWUgIT0gdm9pZCAwICYmIGxlZ2VuZEl0ZW1OYW1lID09PSBldmVudC5sZWdlbmRJdGVtTmFtZTtcbiAgICBpZiAoc2VyaWVzLmlkID09PSB0aGlzLmlkIHx8IG1hdGNoZWRMZWdlbmRJdGVtTmFtZSB8fCBsZWdlbmRJdGVtS2V5ICE9IHZvaWQgMCkge1xuICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKGVuYWJsZWQsIGxlZ2VuZFR5cGUsIGl0ZW1JZCwgbGVnZW5kSXRlbU5hbWUsIGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgb25MZWdlbmRJdGVtRG91YmxlQ2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCB7IGVuYWJsZWQsIGl0ZW1JZCwgc2VyaWVzLCBudW1WaXNpYmxlSXRlbXMsIGxlZ2VuZFR5cGUgfSA9IGV2ZW50O1xuICAgIGNvbnN0IGxlZ2VuZEl0ZW1OYW1lID0gXCJsZWdlbmRJdGVtTmFtZVwiIGluIHRoaXMucHJvcGVydGllcyA/IHRoaXMucHJvcGVydGllcy5sZWdlbmRJdGVtTmFtZSA6IHZvaWQgMDtcbiAgICBjb25zdCBsZWdlbmRJdGVtS2V5ID0gXCJsZWdlbmRJdGVtS2V5XCIgaW4gdGhpcy5wcm9wZXJ0aWVzID8gdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXkgOiB2b2lkIDA7XG4gICAgY29uc3QgbWF0Y2hlZExlZ2VuZEl0ZW1OYW1lID0gbGVnZW5kSXRlbU5hbWUgIT0gdm9pZCAwICYmIGxlZ2VuZEl0ZW1OYW1lID09PSBldmVudC5sZWdlbmRJdGVtTmFtZTtcbiAgICBpZiAoc2VyaWVzLmlkID09PSB0aGlzLmlkIHx8IG1hdGNoZWRMZWdlbmRJdGVtTmFtZSB8fCBsZWdlbmRJdGVtS2V5ICE9IHZvaWQgMCkge1xuICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKHRydWUsIGxlZ2VuZFR5cGUsIGl0ZW1JZCwgbGVnZW5kSXRlbU5hbWUsIGV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKGVuYWJsZWQgJiYgbnVtVmlzaWJsZUl0ZW1zID09PSAxKSB7XG4gICAgICB0aGlzLnRvZ2dsZVNlcmllc0l0ZW0odHJ1ZSwgbGVnZW5kVHlwZSwgdm9pZCAwLCBsZWdlbmRJdGVtTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9nZ2xlU2VyaWVzSXRlbShmYWxzZSwgbGVnZW5kVHlwZSwgdm9pZCAwLCBsZWdlbmRJdGVtTmFtZSk7XG4gICAgfVxuICB9XG4gIHRvZ2dsZVNlcmllc0l0ZW0oZW5hYmxlZCwgbGVnZW5kVHlwZSwgaXRlbUlkLCBsZWdlbmRJdGVtTmFtZSwgbGVnZW5kRXZlbnQpIHtcbiAgICBjb25zdCBzZXJpZXNJZCA9IHRoaXMuaWQ7XG4gICAgaWYgKGVuYWJsZWQgfHwgbGVnZW5kVHlwZSAhPT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICB0aGlzLnZpc2libGUgPSBlbmFibGVkO1xuICAgIH1cbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gICAgdGhpcy5fcGlja05vZGVDYWNoZS5jbGVhcigpO1xuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgdHlwZTogXCJzZXJpZXNWaXNpYmlsaXR5Q2hhbmdlXCIsXG4gICAgICBzZXJpZXNJZCxcbiAgICAgIGl0ZW1JZCxcbiAgICAgIGxlZ2VuZEl0ZW1OYW1lOiBsZWdlbmRFdmVudD8ubGVnZW5kSXRlbU5hbWUgPz8gbGVnZW5kSXRlbU5hbWUsXG4gICAgICB2aXNpYmxlOiBlbmFibGVkXG4gICAgfTtcbiAgICB0aGlzLmZpcmVFdmVudChldmVudCk7XG4gICAgdGhpcy5jdHgubGVnZW5kTWFuYWdlci50b2dnbGVJdGVtKHsgZW5hYmxlZCwgc2VyaWVzSWQsIGl0ZW1JZCwgbGVnZW5kSXRlbU5hbWUgfSk7XG4gIH1cbiAgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnZpc2libGU7XG4gIH1cbiAgZ2V0TW9kdWxlTWFwKCkge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZU1hcDtcbiAgfVxuICBjcmVhdGVNb2R1bGVDb250ZXh0KCkge1xuICAgIHJldHVybiB7IC4uLnRoaXMuY3R4LCBzZXJpZXM6IHRoaXMgfTtcbiAgfVxuICBnZXRMYWJlbFRleHQobGFiZWwsIHBhcmFtcywgZGVmYXVsdEZvcm1hdHRlciA9IGZvcm1hdFZhbHVlKSB7XG4gICAgaWYgKGxhYmVsLmZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuY3R4LmNhbGxiYWNrQ2FjaGUuY2FsbChsYWJlbC5mb3JtYXR0ZXIsIHsgc2VyaWVzSWQ6IHRoaXMuaWQsIC4uLnBhcmFtcyB9KSA/PyBkZWZhdWx0Rm9ybWF0dGVyKHBhcmFtcy52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0Rm9ybWF0dGVyKHBhcmFtcy52YWx1ZSk7XG4gIH1cbiAgZ2V0TWFya2VyU3R5bGUobWFya2VyLCBwYXJhbXMsIGRlZmF1bHRTdHlsZSA9IG1hcmtlci5nZXRTdHlsZSgpKSB7XG4gICAgY29uc3QgZGVmYXVsdFNpemUgPSB7IHNpemU6IHBhcmFtcy5kYXR1bS5wb2ludD8uc2l6ZSA/PyAwIH07XG4gICAgY29uc3QgbWFya2VyU3R5bGUgPSBtZXJnZURlZmF1bHRzKGRlZmF1bHRTaXplLCBkZWZhdWx0U3R5bGUpO1xuICAgIGlmIChtYXJrZXIuaXRlbVN0eWxlcikge1xuICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLmN0eC5jYWxsYmFja0NhY2hlLmNhbGwobWFya2VyLml0ZW1TdHlsZXIsIHtcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIC4uLm1hcmtlclN0eWxlLFxuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIGRhdHVtOiBwYXJhbXMuZGF0dW0uZGF0dW1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1lcmdlRGVmYXVsdHMoc3R5bGUsIG1hcmtlclN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlclN0eWxlO1xuICB9XG4gIHVwZGF0ZU1hcmtlclN0eWxlKG1hcmtlck5vZGUsIG1hcmtlciwgcGFyYW1zLCBkZWZhdWx0U3R5bGUgPSBtYXJrZXIuZ2V0U3R5bGUoKSwgeyBhcHBseVRyYW5zbGF0aW9uID0gdHJ1ZSwgc2VsZWN0ZWQgPSB0cnVlIH0gPSB7fSkge1xuICAgIGNvbnN0IHsgcG9pbnQgfSA9IHBhcmFtcy5kYXR1bTtcbiAgICBjb25zdCBhY3RpdmVTdHlsZSA9IHRoaXMuZ2V0TWFya2VyU3R5bGUobWFya2VyLCBwYXJhbXMsIGRlZmF1bHRTdHlsZSk7XG4gICAgY29uc3QgdmlzaWJsZSA9IHRoaXMudmlzaWJsZSAmJiBhY3RpdmVTdHlsZS5zaXplID4gMCAmJiBwb2ludCAmJiAhaXNOYU4ocG9pbnQueCkgJiYgIWlzTmFOKHBvaW50LnkpO1xuICAgIGlmIChhcHBseVRyYW5zbGF0aW9uKSB7XG4gICAgICBtYXJrZXJOb2RlLnNldFByb3BlcnRpZXMoeyB2aXNpYmxlLCAuLi5hY3RpdmVTdHlsZSwgdHJhbnNsYXRpb25YOiBwb2ludD8ueCwgdHJhbnNsYXRpb25ZOiBwb2ludD8ueSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFya2VyTm9kZS5zZXRQcm9wZXJ0aWVzKHsgdmlzaWJsZSwgLi4uYWN0aXZlU3R5bGUgfSk7XG4gICAgfVxuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIG1hcmtlck5vZGUuZmlsbE9wYWNpdHkgKj0gQ1JPU1NfRklMVEVSX01BUktFUl9GSUxMX09QQUNJVFlfRkFDVE9SO1xuICAgICAgbWFya2VyTm9kZS5zdHJva2VPcGFjaXR5ICo9IENST1NTX0ZJTFRFUl9NQVJLRVJfU1RST0tFX09QQUNJVFlfRkFDVE9SO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1hcmtlci5zaGFwZSA9PT0gXCJmdW5jdGlvblwiICYmICFtYXJrZXJOb2RlLmRpcnR5UGF0aCkge1xuICAgICAgbWFya2VyTm9kZS5wYXRoLmNsZWFyKHRydWUpO1xuICAgICAgbWFya2VyTm9kZS51cGRhdGVQYXRoKCk7XG4gICAgICBtYXJrZXJOb2RlLmNoZWNrUGF0aERpcnR5KCk7XG4gICAgICBjb25zdCBiYiA9IG1hcmtlck5vZGUuZ2V0QkJveCgpO1xuICAgICAgaWYgKHBvaW50ICE9PSB2b2lkIDAgJiYgYmIuaXNGaW5pdGUoKSkge1xuICAgICAgICBjb25zdCBjZW50ZXIyID0gYmIuY29tcHV0ZUNlbnRlcigpO1xuICAgICAgICBjb25zdCBbZHgsIGR5XSA9IFtcInhcIiwgXCJ5XCJdLm1hcChcbiAgICAgICAgICAoa2V5KSA9PiAoYWN0aXZlU3R5bGUuc3Ryb2tlV2lkdGggPz8gMCkgKyBNYXRoLmFicyhjZW50ZXIyW2tleV0gLSBwb2ludFtrZXldKVxuICAgICAgICApO1xuICAgICAgICBwb2ludC5mb2N1c1NpemUgPSBNYXRoLm1heChiYi53aWR0aCArIGR4LCBiYi5oZWlnaHQgKyBkeSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBub2RlRGF0YURlcGVuZGVuY2llcygpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZURhdGFEZXBlbmRlbmNpZXMgPz8geyBzZXJpZXNSZWN0V2lkdGg6IE5hTiwgc2VyaWVzUmVjdEhlaWdodDogTmFOIH07XG4gIH1cbiAgY2hlY2tSZXNpemUobmV3U2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IHsgd2lkdGg6IHNlcmllc1JlY3RXaWR0aCwgaGVpZ2h0OiBzZXJpZXNSZWN0SGVpZ2h0IH0gPSBuZXdTZXJpZXNSZWN0ID8/IHsgd2lkdGg6IE5hTiwgaGVpZ2h0OiBOYU4gfTtcbiAgICBjb25zdCBuZXdOb2RlRGF0YURlcGVuZGVuY2llcyA9IG5ld1Nlcmllc1JlY3QgPyB7IHNlcmllc1JlY3RXaWR0aCwgc2VyaWVzUmVjdEhlaWdodCB9IDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc2l6ZSA9IGpzb25EaWZmKHRoaXMubm9kZURhdGFEZXBlbmRlbmNpZXMsIG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzKSAhPSBudWxsO1xuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHRoaXMuX25vZGVEYXRhRGVwZW5kZW5jaWVzID0gbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXM7XG4gICAgICB0aGlzLm1hcmtOb2RlRGF0YURpcnR5KCk7XG4gICAgfVxuICAgIHJldHVybiByZXNpemU7XG4gIH1cbiAgcGlja0ZvY3VzKF9vcHRzKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXNldERhdHVtQ2FsbGJhY2tDYWNoZSgpIHtcbiAgICB0aGlzLmRhdHVtQ2FsbGJhY2tDYWNoZS5jbGVhcigpO1xuICB9XG4gIGNhY2hlZERhdHVtQ2FsbGJhY2soaWQsIGZuKSB7XG4gICAgY29uc3QgeyBkYXR1bUNhbGxiYWNrQ2FjaGUgfSA9IHRoaXM7XG4gICAgY29uc3QgZXhpc3RpbmcgPSBkYXR1bUNhbGxiYWNrQ2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoZXhpc3RpbmcgIT0gbnVsbClcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICBjb25zdCB2YWx1ZSA9IGZuKCk7XG4gICAgZGF0dW1DYWxsYmFja0NhY2hlLnNldChpZCwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBjaGFuZ2VWYWx1ZTogZnVuY3Rpb24obmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgIHRoaXMub25TZXJpZXNHcm91cGluZ0NoYW5nZShvbGRWYWwsIG5ld1ZhbCk7XG4gICAgfVxuICB9KVxuXSwgU2VyaWVzLnByb3RvdHlwZSwgXCJzZXJpZXNHcm91cGluZ1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvcG9seVJvb3RzLnRzXG5mdW5jdGlvbiBsaW5lYXJSb290KGEsIGIpIHtcbiAgY29uc3QgdCA9IC1iIC8gYTtcbiAgcmV0dXJuIGEgIT09IDAgJiYgdCA+PSAwICYmIHQgPD0gMSA/IFt0XSA6IFtdO1xufVxuZnVuY3Rpb24gcXVhZHJhdGljUm9vdHMoYSwgYiwgYykge1xuICBpZiAoYSA9PT0gMCkge1xuICAgIHJldHVybiBsaW5lYXJSb290KGIsIGMpO1xuICB9XG4gIGNvbnN0IEQgPSBiICogYiAtIDQgKiBhICogYztcbiAgY29uc3Qgcm9vdHMgPSBbXTtcbiAgaWYgKEQgPT09IDApIHtcbiAgICBjb25zdCB0ID0gLWIgLyAoMiAqIGEpO1xuICAgIGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG4gICAgICByb290cy5wdXNoKHQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChEID4gMCkge1xuICAgIGNvbnN0IHJEID0gTWF0aC5zcXJ0KEQpO1xuICAgIGNvbnN0IHQxID0gKC1iIC0gckQpIC8gKDIgKiBhKTtcbiAgICBjb25zdCB0MiA9ICgtYiArIHJEKSAvICgyICogYSk7XG4gICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgcm9vdHMucHVzaCh0MSk7XG4gICAgfVxuICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgIHJvb3RzLnB1c2godDIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcm9vdHM7XG59XG5mdW5jdGlvbiBjdWJpY1Jvb3RzKGEsIGIsIGMsIGQpIHtcbiAgaWYgKGEgPT09IDApIHtcbiAgICByZXR1cm4gcXVhZHJhdGljUm9vdHMoYiwgYywgZCk7XG4gIH1cbiAgY29uc3QgQSA9IGIgLyBhO1xuICBjb25zdCBCID0gYyAvIGE7XG4gIGNvbnN0IEMyID0gZCAvIGE7XG4gIGNvbnN0IFEgPSAoMyAqIEIgLSBBICogQSkgLyA5O1xuICBjb25zdCBSID0gKDkgKiBBICogQiAtIDI3ICogQzIgLSAyICogQSAqIEEgKiBBKSAvIDU0O1xuICBjb25zdCBEID0gUSAqIFEgKiBRICsgUiAqIFI7XG4gIGNvbnN0IHRoaXJkID0gMSAvIDM7XG4gIGNvbnN0IHJvb3RzID0gW107XG4gIGlmIChEID49IDApIHtcbiAgICBjb25zdCByRCA9IE1hdGguc3FydChEKTtcbiAgICBjb25zdCBTID0gTWF0aC5zaWduKFIgKyByRCkgKiBNYXRoLnBvdyhNYXRoLmFicyhSICsgckQpLCB0aGlyZCk7XG4gICAgY29uc3QgVCA9IE1hdGguc2lnbihSIC0gckQpICogTWF0aC5wb3coTWF0aC5hYnMoUiAtIHJEKSwgdGhpcmQpO1xuICAgIGNvbnN0IEltID0gTWF0aC5hYnMoTWF0aC5zcXJ0KDMpICogKFMgLSBUKSAvIDIpO1xuICAgIGNvbnN0IHQgPSAtdGhpcmQgKiBBICsgKFMgKyBUKTtcbiAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgcm9vdHMucHVzaCh0KTtcbiAgICB9XG4gICAgaWYgKEltID09PSAwKSB7XG4gICAgICBjb25zdCB0MiA9IC10aGlyZCAqIEEgLSAoUyArIFQpIC8gMjtcbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgcm9vdHMucHVzaCh0Mik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRoZXRhID0gTWF0aC5hY29zKFIgLyBNYXRoLnNxcnQoLVEgKiBRICogUSkpO1xuICAgIGNvbnN0IHRoaXJkQSA9IHRoaXJkICogQTtcbiAgICBjb25zdCB0d29TcXJ0USA9IDIgKiBNYXRoLnNxcnQoLVEpO1xuICAgIGNvbnN0IHQxID0gdHdvU3FydFEgKiBNYXRoLmNvcyh0aGlyZCAqIHRoZXRhKSAtIHRoaXJkQTtcbiAgICBjb25zdCB0MiA9IHR3b1NxcnRRICogTWF0aC5jb3ModGhpcmQgKiAodGhldGEgKyAyICogTWF0aC5QSSkpIC0gdGhpcmRBO1xuICAgIGNvbnN0IHQzID0gdHdvU3FydFEgKiBNYXRoLmNvcyh0aGlyZCAqICh0aGV0YSArIDQgKiBNYXRoLlBJKSkgLSB0aGlyZEE7XG4gICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgcm9vdHMucHVzaCh0MSk7XG4gICAgfVxuICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgIHJvb3RzLnB1c2godDIpO1xuICAgIH1cbiAgICBpZiAodDMgPj0gMCAmJiB0MyA8PSAxKSB7XG4gICAgICByb290cy5wdXNoKHQzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJvb3RzO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9pbnRlcnNlY3Rpb24udHNcbmZ1bmN0aW9uIHNlZ21lbnRJbnRlcnNlY3Rpb24oYXgxLCBheTEsIGF4MiwgYXkyLCBieDEsIGJ5MSwgYngyLCBieTIpIHtcbiAgY29uc3QgZCA9IChheDIgLSBheDEpICogKGJ5MiAtIGJ5MSkgLSAoYXkyIC0gYXkxKSAqIChieDIgLSBieDEpO1xuICBpZiAoZCA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IHVhID0gKChieDIgLSBieDEpICogKGF5MSAtIGJ5MSkgLSAoYXgxIC0gYngxKSAqIChieTIgLSBieTEpKSAvIGQ7XG4gIGNvbnN0IHViID0gKChheDIgLSBheDEpICogKGF5MSAtIGJ5MSkgLSAoYXkyIC0gYXkxKSAqIChheDEgLSBieDEpKSAvIGQ7XG4gIGlmICh1YSA+PSAwICYmIHVhIDw9IDEgJiYgdWIgPj0gMCAmJiB1YiA8PSAxKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjdWJpY1NlZ21lbnRJbnRlcnNlY3Rpb25zKHB4MSwgcHkxLCBweDIsIHB5MiwgcHgzLCBweTMsIHB4NCwgcHk0LCB4MSwgeTEsIHgyLCB5Mikge1xuICBsZXQgaW50ZXJzZWN0aW9ucyA9IDA7XG4gIGNvbnN0IEEgPSB5MSAtIHkyO1xuICBjb25zdCBCID0geDIgLSB4MTtcbiAgY29uc3QgQzIgPSB4MSAqICh5MiAtIHkxKSAtIHkxICogKHgyIC0geDEpO1xuICBjb25zdCBieCA9IGJlemllckNvZWZmaWNpZW50cyhweDEsIHB4MiwgcHgzLCBweDQpO1xuICBjb25zdCBieSA9IGJlemllckNvZWZmaWNpZW50cyhweTEsIHB5MiwgcHkzLCBweTQpO1xuICBjb25zdCBhID0gQSAqIGJ4WzBdICsgQiAqIGJ5WzBdO1xuICBjb25zdCBiID0gQSAqIGJ4WzFdICsgQiAqIGJ5WzFdO1xuICBjb25zdCBjID0gQSAqIGJ4WzJdICsgQiAqIGJ5WzJdO1xuICBjb25zdCBkID0gQSAqIGJ4WzNdICsgQiAqIGJ5WzNdICsgQzI7XG4gIGNvbnN0IHJvb3RzID0gY3ViaWNSb290cyhhLCBiLCBjLCBkKTtcbiAgZm9yIChjb25zdCB0IG9mIHJvb3RzKSB7XG4gICAgY29uc3QgdHQgPSB0ICogdDtcbiAgICBjb25zdCB0dHQgPSB0ICogdHQ7XG4gICAgY29uc3QgeCA9IGJ4WzBdICogdHR0ICsgYnhbMV0gKiB0dCArIGJ4WzJdICogdCArIGJ4WzNdO1xuICAgIGNvbnN0IHkgPSBieVswXSAqIHR0dCArIGJ5WzFdICogdHQgKyBieVsyXSAqIHQgKyBieVszXTtcbiAgICBsZXQgcztcbiAgICBpZiAoeDEgPT09IHgyKSB7XG4gICAgICBzID0gKHkgLSB5MSkgLyAoeTIgLSB5MSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSAoeCAtIHgxKSAvICh4MiAtIHgxKTtcbiAgICB9XG4gICAgaWYgKHMgPj0gMCAmJiBzIDw9IDEpIHtcbiAgICAgIGludGVyc2VjdGlvbnMrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG59XG5mdW5jdGlvbiBiZXppZXJDb2VmZmljaWVudHMoUDEsIFAyLCBQMywgUDQpIHtcbiAgcmV0dXJuIFtcbiAgICAvLyBCw6l6aWVyIGV4cHJlc3NlZCBhcyBtYXRyaXggb3BlcmF0aW9uczpcbiAgICAtUDEgKyAzICogUDIgLSAzICogUDMgKyBQNCxcbiAgICAvLyAgICAgICAgICAgICAgICAgfC0xICAzIC0zICAxfCB8UDF8XG4gICAgMyAqIFAxIC0gNiAqIFAyICsgMyAqIFAzLFxuICAgIC8vICAgW3ReMyB0XjIgdCAxXSB8IDMgLTYgIDMgIDB8IHxQMnxcbiAgICAtMyAqIFAxICsgMyAqIFAyLFxuICAgIC8vICAgICAgICAgICAgICAgICB8LTMgIDMgIDAgIDB8IHxQM3xcbiAgICBQMVxuICAgIC8vICAgICAgICAgICAgICAgICB8IDEgIDAgIDAgIDB8IHxQNHxcbiAgXTtcbn1cbmZ1bmN0aW9uIGFyY0ludGVyc2VjdGlvbnMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY291bnRlckNsb2Nrd2lzZSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgaWYgKGlzTmFOKGN4KSB8fCBpc05hTihjeSkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoY291bnRlckNsb2Nrd2lzZSkge1xuICAgIFtlbmRBbmdsZSwgc3RhcnRBbmdsZV0gPSBbc3RhcnRBbmdsZSwgZW5kQW5nbGVdO1xuICB9XG4gIGNvbnN0IGsgPSAoeTIgLSB5MSkgLyAoeDIgLSB4MSk7XG4gIGNvbnN0IHkwID0geTEgLSBrICogeDE7XG4gIGNvbnN0IGEgPSBNYXRoLnBvdyhrLCAyKSArIDE7XG4gIGNvbnN0IGIgPSAyICogKGsgKiAoeTAgLSBjeSkgLSBjeCk7XG4gIGNvbnN0IGMgPSBNYXRoLnBvdyhjeCwgMikgKyBNYXRoLnBvdyh5MCAtIGN5LCAyKSAtIE1hdGgucG93KHIsIDIpO1xuICBjb25zdCBkID0gTWF0aC5wb3coYiwgMikgLSA0ICogYSAqIGM7XG4gIGlmIChkIDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IGkxeCA9ICgtYiArIE1hdGguc3FydChkKSkgLyAyIC8gYTtcbiAgY29uc3QgaTJ4ID0gKC1iIC0gTWF0aC5zcXJ0KGQpKSAvIDIgLyBhO1xuICBsZXQgaW50ZXJzZWN0aW9ucyA9IDA7XG4gIFtpMXgsIGkyeF0uZm9yRWFjaCgoeCkgPT4ge1xuICAgIGNvbnN0IGlzWEluc2lkZUxpbmUgPSB4ID49IE1hdGgubWluKHgxLCB4MikgJiYgeCA8PSBNYXRoLm1heCh4MSwgeDIpO1xuICAgIGlmICghaXNYSW5zaWRlTGluZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB5ID0gayAqIHggKyB5MDtcbiAgICBjb25zdCBhZGphY2VudCA9IHggLSBjeDtcbiAgICBjb25zdCBvcHBvc2l0ZSA9IHkgLSBjeTtcbiAgICBjb25zdCBhbmdsZTIgPSBNYXRoLmF0YW4yKG9wcG9zaXRlLCBhZGphY2VudCk7XG4gICAgaWYgKGlzQmV0d2VlbkFuZ2xlcyhhbmdsZTIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgICAgaW50ZXJzZWN0aW9ucysrO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbnRlcnNlY3Rpb25zO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS91dGlsL2Jlemllci50c1xuZnVuY3Rpb24gZXZhbHVhdGVCZXppZXIocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgcmV0dXJuICgxIC0gdCkgKiogMyAqIHAwICsgMyAqICgxIC0gdCkgKiogMiAqIHQgKiBwMSArIDMgKiAoMSAtIHQpICogdCAqKiAyICogcDIgKyB0ICoqIDMgKiBwMztcbn1cbmZ1bmN0aW9uIHNvbHZlQmV6aWVyKHAwLCBwMSwgcDIsIHAzLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPD0gTWF0aC5taW4ocDAsIHAzKSkge1xuICAgIHJldHVybiBwMCA8IHAzID8gMCA6IDE7XG4gIH0gZWxzZSBpZiAodmFsdWUgPj0gTWF0aC5tYXgocDAsIHAzKSkge1xuICAgIHJldHVybiBwMCA8IHAzID8gMSA6IDA7XG4gIH1cbiAgbGV0IHQwID0gMDtcbiAgbGV0IHQxID0gMTtcbiAgbGV0IHQgPSBOYU47XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkgKz0gMSkge1xuICAgIHQgPSAodDAgKyB0MSkgLyAyO1xuICAgIGNvbnN0IGN1cnZlVmFsdWUgPSBldmFsdWF0ZUJlemllcihwMCwgcDEsIHAyLCBwMywgdCk7XG4gICAgaWYgKGN1cnZlVmFsdWUgPCB2YWx1ZSkge1xuICAgICAgdDAgPSB0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0MSA9IHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gc3BsaXRCZXppZXIocDB4LCBwMHksIHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3ksIHQpIHtcbiAgY29uc3QgeDAxID0gKDEgLSB0KSAqIHAweCArIHQgKiBwMXg7XG4gIGNvbnN0IHkwMSA9ICgxIC0gdCkgKiBwMHkgKyB0ICogcDF5O1xuICBjb25zdCB4MTIgPSAoMSAtIHQpICogcDF4ICsgdCAqIHAyeDtcbiAgY29uc3QgeTEyID0gKDEgLSB0KSAqIHAxeSArIHQgKiBwMnk7XG4gIGNvbnN0IHgyMyA9ICgxIC0gdCkgKiBwMnggKyB0ICogcDN4O1xuICBjb25zdCB5MjMgPSAoMSAtIHQpICogcDJ5ICsgdCAqIHAzeTtcbiAgY29uc3QgeDAxMiA9ICgxIC0gdCkgKiB4MDEgKyB0ICogeDEyO1xuICBjb25zdCB5MDEyID0gKDEgLSB0KSAqIHkwMSArIHQgKiB5MTI7XG4gIGNvbnN0IHgxMjMgPSAoMSAtIHQpICogeDEyICsgdCAqIHgyMztcbiAgY29uc3QgeTEyMyA9ICgxIC0gdCkgKiB5MTIgKyB0ICogeTIzO1xuICBjb25zdCB4MDEyMyA9ICgxIC0gdCkgKiB4MDEyICsgdCAqIHgxMjM7XG4gIGNvbnN0IHkwMTIzID0gKDEgLSB0KSAqIHkwMTIgKyB0ICogeTEyMztcbiAgcmV0dXJuIFtcbiAgICBbXG4gICAgICB7IHg6IHAweCwgeTogcDB5IH0sXG4gICAgICB7IHg6IHgwMSwgeTogeTAxIH0sXG4gICAgICB7IHg6IHgwMTIsIHk6IHkwMTIgfSxcbiAgICAgIHsgeDogeDAxMjMsIHk6IHkwMTIzIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIHsgeDogeDAxMjMsIHk6IHkwMTIzIH0sXG4gICAgICB7IHg6IHgxMjMsIHk6IHkxMjMgfSxcbiAgICAgIHsgeDogeDIzLCB5OiB5MjMgfSxcbiAgICAgIHsgeDogcDN4LCB5OiBwM3kgfVxuICAgIF1cbiAgXTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlcml2YXRpdmVFeHRyZW1hKHAwLCBwMSwgcDIsIHAzKSB7XG4gIGNvbnN0IGEgPSAtcDAgKyAzICogcDEgLSAzICogcDIgKyBwMztcbiAgY29uc3QgYiA9IDMgKiBwMCAtIDYgKiBwMSArIDMgKiBwMjtcbiAgY29uc3QgYyA9IC0zICogcDAgKyAzICogcDE7XG4gIGlmIChhID09PSAwKSB7XG4gICAgaWYgKGIgIT09IDApIHtcbiAgICAgIGNvbnN0IHQgPSAtYyAvIGI7XG4gICAgICBpZiAodCA+IDAgJiYgdCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIFt0XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IGRpc2NyaW1pbmFudCA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICBpZiAoZGlzY3JpbWluYW50ID49IDApIHtcbiAgICBjb25zdCBzcXJ0RGlzY3JpbWluYW50ID0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCk7XG4gICAgY29uc3QgdDEgPSAoLWIgKyBzcXJ0RGlzY3JpbWluYW50KSAvICgyICogYSk7XG4gICAgY29uc3QgdDIgPSAoLWIgLSBzcXJ0RGlzY3JpbWluYW50KSAvICgyICogYSk7XG4gICAgcmV0dXJuIFt0MSwgdDJdLmZpbHRlcigodCkgPT4gdCA+IDAgJiYgdCA8IDEpO1xuICB9XG4gIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlcml2YXRpdmVFeHRyZW1hWFkoc3gsIHN5LCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG4gIGNvbnN0IHR4ID0gY2FsY3VsYXRlRGVyaXZhdGl2ZUV4dHJlbWEoc3gsIGNwMXgsIGNwMngsIHgpO1xuICBjb25zdCB0eSA9IGNhbGN1bGF0ZURlcml2YXRpdmVFeHRyZW1hKHN5LCBjcDF5LCBjcDJ5LCB5KTtcbiAgcmV0dXJuIFsuLi50eCwgLi4udHldO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9leHRlbmRlZFBhdGgyRC50c1xudmFyIEV4dGVuZGVkUGF0aDJEID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBUaGUgbWV0aG9kcyBvZiB0aGlzIGNsYXNzIHdpbGwgbGlrZWx5IGJlIGNhbGxlZCBtYW55IHRpbWVzIHBlciBhbmltYXRpb24gZnJhbWUsXG4gICAgLy8gYW5kIGFueSBhbGxvY2F0aW9uIGNhbiB0cmlnZ2VyIGEgR0MgY3ljbGUgZHVyaW5nIGFuaW1hdGlvbiwgc28gd2UgYXR0ZW1wdFxuICAgIC8vIHRvIG1pbmltaXplIHRoZSBudW1iZXIgb2YgYWxsb2NhdGlvbnMuXG4gICAgdGhpcy5wYXRoMmQgPSBuZXcgUGF0aDJEKCk7XG4gICAgdGhpcy5wcmV2aW91c0NvbW1hbmRzID0gW107XG4gICAgdGhpcy5wcmV2aW91c1BhcmFtcyA9IFtdO1xuICAgIHRoaXMucHJldmlvdXNDbG9zZWRQYXRoID0gZmFsc2U7XG4gICAgdGhpcy5jb21tYW5kcyA9IFtdO1xuICAgIHRoaXMucGFyYW1zID0gW107XG4gICAgdGhpcy5vcGVuZWRQYXRoID0gZmFsc2U7XG4gICAgdGhpcy5jbG9zZWRQYXRoID0gZmFsc2U7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kcy5sZW5ndGggPT09IDA7XG4gIH1cbiAgaXNEaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9zZWRQYXRoICE9PSB0aGlzLnByZXZpb3VzQ2xvc2VkUGF0aCB8fCB0aGlzLnByZXZpb3VzQ29tbWFuZHMubGVuZ3RoICE9PSB0aGlzLmNvbW1hbmRzLmxlbmd0aCB8fCB0aGlzLnByZXZpb3VzUGFyYW1zLmxlbmd0aCAhPT0gdGhpcy5wYXJhbXMubGVuZ3RoIHx8IHRoaXMucHJldmlvdXNDb21tYW5kcy50b1N0cmluZygpICE9PSB0aGlzLmNvbW1hbmRzLnRvU3RyaW5nKCkgfHwgdGhpcy5wcmV2aW91c1BhcmFtcy50b1N0cmluZygpICE9PSB0aGlzLnBhcmFtcy50b1N0cmluZygpO1xuICB9XG4gIGdldFBhdGgyRCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoMmQ7XG4gIH1cbiAgbW92ZVRvKHgsIHkpIHtcbiAgICB0aGlzLm9wZW5lZFBhdGggPSB0cnVlO1xuICAgIHRoaXMucGF0aDJkLm1vdmVUbyh4LCB5KTtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goMCAvKiBNb3ZlICovKTtcbiAgICB0aGlzLnBhcmFtcy5wdXNoKHgsIHkpO1xuICB9XG4gIGxpbmVUbyh4LCB5KSB7XG4gICAgaWYgKHRoaXMub3BlbmVkUGF0aCkge1xuICAgICAgdGhpcy5wYXRoMmQubGluZVRvKHgsIHkpO1xuICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKDEgLyogTGluZSAqLyk7XG4gICAgICB0aGlzLnBhcmFtcy5wdXNoKHgsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1vdmVUbyh4LCB5KTtcbiAgICB9XG4gIH1cbiAgcmVjdCh4LCB5LCB3aWR0aDIsIGhlaWdodDIpIHtcbiAgICB0aGlzLm1vdmVUbyh4LCB5KTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgyLCB5KTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgyLCB5ICsgaGVpZ2h0Mik7XG4gICAgdGhpcy5saW5lVG8oeCwgeSArIGhlaWdodDIpO1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH1cbiAgcm91bmRSZWN0KHgsIHksIHdpZHRoMiwgaGVpZ2h0MiwgcmFkaWkpIHtcbiAgICByYWRpaSA9IE1hdGgubWluKHJhZGlpLCB3aWR0aDIgLyAyLCBoZWlnaHQyIC8gMik7XG4gICAgdGhpcy5tb3ZlVG8oeCwgeSArIHJhZGlpKTtcbiAgICB0aGlzLmFyYyh4ICsgcmFkaWksIHkgKyByYWRpaSwgcmFkaWksIE1hdGguUEksIDEuNSAqIE1hdGguUEkpO1xuICAgIHRoaXMubGluZVRvKHggKyByYWRpaSwgeSk7XG4gICAgdGhpcy5saW5lVG8oeCArIHdpZHRoMiAtIHJhZGlpLCB5KTtcbiAgICB0aGlzLmFyYyh4ICsgd2lkdGgyIC0gcmFkaWksIHkgKyByYWRpaSwgcmFkaWksIDEuNSAqIE1hdGguUEksIDIgKiBNYXRoLlBJKTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgyLCB5ICsgcmFkaWkpO1xuICAgIHRoaXMubGluZVRvKHggKyB3aWR0aDIsIHkgKyBoZWlnaHQyIC0gcmFkaWkpO1xuICAgIHRoaXMuYXJjKHggKyB3aWR0aDIgLSByYWRpaSwgeSArIGhlaWdodDIgLSByYWRpaSwgcmFkaWksIDAsIE1hdGguUEkgLyAyKTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgd2lkdGgyIC0gcmFkaWksIHkgKyBoZWlnaHQyKTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgcmFkaWksIHkgKyBoZWlnaHQyKTtcbiAgICB0aGlzLmFyYyh4ICsgK3JhZGlpLCB5ICsgaGVpZ2h0MiAtIHJhZGlpLCByYWRpaSwgTWF0aC5QSSAvIDIsIE1hdGguUEkpO1xuICAgIHRoaXMubGluZVRvKHgsIHkgKyBoZWlnaHQyIC0gcmFkaWkpO1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH1cbiAgYXJjKHgsIHksIHIsIHNBbmdsZSwgZUFuZ2xlLCBjb3VudGVyQ2xvY2t3aXNlKSB7XG4gICAgdGhpcy5vcGVuZWRQYXRoID0gdHJ1ZTtcbiAgICB0aGlzLnBhdGgyZC5hcmMoeCwgeSwgciwgc0FuZ2xlLCBlQW5nbGUsIGNvdW50ZXJDbG9ja3dpc2UpO1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCgyIC8qIEFyYyAqLyk7XG4gICAgdGhpcy5wYXJhbXMucHVzaCh4LCB5LCByLCBzQW5nbGUsIGVBbmdsZSwgY291bnRlckNsb2Nrd2lzZSA/IDEgOiAwKTtcbiAgfVxuICBjdWJpY0N1cnZlVG8oY3gxLCBjeTEsIGN4MiwgY3kyLCB4LCB5KSB7XG4gICAgaWYgKCF0aGlzLm9wZW5lZFBhdGgpIHtcbiAgICAgIHRoaXMubW92ZVRvKGN4MSwgY3kxKTtcbiAgICB9XG4gICAgdGhpcy5wYXRoMmQuYmV6aWVyQ3VydmVUbyhjeDEsIGN5MSwgY3gyLCBjeTIsIHgsIHkpO1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCgzIC8qIEN1cnZlICovKTtcbiAgICB0aGlzLnBhcmFtcy5wdXNoKGN4MSwgY3kxLCBjeDIsIGN5MiwgeCwgeSk7XG4gIH1cbiAgY2xvc2VQYXRoKCkge1xuICAgIGlmICh0aGlzLm9wZW5lZFBhdGgpIHtcbiAgICAgIHRoaXMucGF0aDJkLmNsb3NlUGF0aCgpO1xuICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKDQgLyogQ2xvc2VQYXRoICovKTtcbiAgICAgIHRoaXMub3BlbmVkUGF0aCA9IGZhbHNlO1xuICAgICAgdGhpcy5jbG9zZWRQYXRoID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgY2xlYXIodHJhY2tDaGFuZ2VzKSB7XG4gICAgaWYgKHRyYWNrQ2hhbmdlcykge1xuICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmRzID0gdGhpcy5jb21tYW5kcztcbiAgICAgIHRoaXMucHJldmlvdXNQYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgICAgIHRoaXMucHJldmlvdXNDbG9zZWRQYXRoID0gdGhpcy5jbG9zZWRQYXRoO1xuICAgIH1cbiAgICB0aGlzLnBhdGgyZCA9IG5ldyBQYXRoMkQoKTtcbiAgICB0aGlzLm9wZW5lZFBhdGggPSBmYWxzZTtcbiAgICB0aGlzLmNsb3NlZFBhdGggPSBmYWxzZTtcbiAgICB0aGlzLmNvbW1hbmRzID0gW107XG4gICAgdGhpcy5wYXJhbXMgPSBbXTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICBjb25zdCBjb21tYW5kcyA9IHRoaXMuY29tbWFuZHM7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3QgY24gPSBjb21tYW5kcy5sZW5ndGg7XG4gICAgY29uc3Qgb3ggPSAtMWU0O1xuICAgIGNvbnN0IG95ID0gLTFlNDtcbiAgICBsZXQgc3ggPSBOYU47XG4gICAgbGV0IHN5ID0gTmFOO1xuICAgIGxldCBweCA9IDA7XG4gICAgbGV0IHB5ID0gMDtcbiAgICBsZXQgaW50ZXJzZWN0aW9uQ291bnQgPSAwO1xuICAgIGZvciAobGV0IGNpID0gMCwgcGkgPSAwOyBjaSA8IGNuOyBjaSsrKSB7XG4gICAgICBzd2l0Y2ggKGNvbW1hbmRzW2NpXSkge1xuICAgICAgICBjYXNlIDAgLyogTW92ZSAqLzpcbiAgICAgICAgICBpbnRlcnNlY3Rpb25Db3VudCArPSBzZWdtZW50SW50ZXJzZWN0aW9uKHN4LCBzeSwgcHgsIHB5LCBveCwgb3ksIHgsIHkpO1xuICAgICAgICAgIHB4ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIHN4ID0gcHg7XG4gICAgICAgICAgcHkgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgc3kgPSBweTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIC8qIExpbmUgKi86XG4gICAgICAgICAgaW50ZXJzZWN0aW9uQ291bnQgKz0gc2VnbWVudEludGVyc2VjdGlvbihweCwgcHksIHBhcmFtc1twaSsrXSwgcGFyYW1zW3BpKytdLCBveCwgb3ksIHgsIHkpO1xuICAgICAgICAgIHB4ID0gcGFyYW1zW3BpIC0gMl07XG4gICAgICAgICAgcHkgPSBwYXJhbXNbcGkgLSAxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzIC8qIEN1cnZlICovOlxuICAgICAgICAgIGludGVyc2VjdGlvbkNvdW50ICs9IGN1YmljU2VnbWVudEludGVyc2VjdGlvbnMoXG4gICAgICAgICAgICBweCxcbiAgICAgICAgICAgIHB5LFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgb3gsXG4gICAgICAgICAgICBveSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5XG4gICAgICAgICAgKTtcbiAgICAgICAgICBweCA9IHBhcmFtc1twaSAtIDJdO1xuICAgICAgICAgIHB5ID0gcGFyYW1zW3BpIC0gMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBBcmMgKi86IHtcbiAgICAgICAgICBjb25zdCBjeCA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBjeSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCByID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgZW5kQW5nbGUgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgY291bnRlckNsb2Nrd2lzZSA9IEJvb2xlYW4ocGFyYW1zW3BpKytdKTtcbiAgICAgICAgICBpbnRlcnNlY3Rpb25Db3VudCArPSBhcmNJbnRlcnNlY3Rpb25zKFxuICAgICAgICAgICAgY3gsXG4gICAgICAgICAgICBjeSxcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgICAgICBjb3VudGVyQ2xvY2t3aXNlLFxuICAgICAgICAgICAgb3gsXG4gICAgICAgICAgICBveSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5XG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKHN4KSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRYID0gY3ggKyBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIHI7XG4gICAgICAgICAgICBjb25zdCBzdGFydFkgPSBjeSArIE1hdGguc2luKHN0YXJ0QW5nbGUpICogcjtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbkNvdW50ICs9IHNlZ21lbnRJbnRlcnNlY3Rpb24ocHgsIHB5LCBzdGFydFgsIHN0YXJ0WSwgb3gsIG95LCB4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHggPSBjeCArIE1hdGguY29zKGVuZEFuZ2xlKSAqIHI7XG4gICAgICAgICAgcHkgPSBjeSArIE1hdGguc2luKGVuZEFuZ2xlKSAqIHI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA0IC8qIENsb3NlUGF0aCAqLzpcbiAgICAgICAgICBpbnRlcnNlY3Rpb25Db3VudCArPSBzZWdtZW50SW50ZXJzZWN0aW9uKHN4LCBzeSwgcHgsIHB5LCBveCwgb3ksIHgsIHkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9uQ291bnQgJSAyID09PSAxO1xuICB9XG4gIGRpc3RhbmNlU3F1YXJlZCh4LCB5KSB7XG4gICAgbGV0IGJlc3QgPSBJbmZpbml0eTtcbiAgICBjb25zdCBjb21tYW5kcyA9IHRoaXMuY29tbWFuZHM7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3QgY24gPSBjb21tYW5kcy5sZW5ndGg7XG4gICAgbGV0IHN4ID0gTmFOO1xuICAgIGxldCBzeSA9IE5hTjtcbiAgICBsZXQgcHggPSAwO1xuICAgIGxldCBweSA9IDA7XG4gICAgZm9yIChsZXQgY2kgPSAwLCBwaSA9IDA7IGNpIDwgY247IGNpKyspIHtcbiAgICAgIHN3aXRjaCAoY29tbWFuZHNbY2ldKSB7XG4gICAgICAgIGNhc2UgMCAvKiBNb3ZlICovOlxuICAgICAgICAgIHB4ID0gc3ggPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgcHkgPSBzeSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIC8qIExpbmUgKi86IHtcbiAgICAgICAgICBjb25zdCBueCA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBueSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBiZXN0ID0gbGluZURpc3RhbmNlU3F1YXJlZCh4LCB5LCBweCwgcHksIG54LCBueSwgYmVzdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzIC8qIEN1cnZlICovOlxuICAgICAgICAgIGxvZ2dlcl9leHBvcnRzLmVycm9yKFwiQ29tbWFuZC5DdXJ2ZSBkaXN0YW5jZVNxdWFyZSBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBBcmMgKi86IHtcbiAgICAgICAgICBjb25zdCBjeCA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBjeSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCByID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgZW5kQW5nbGUgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3Qgc3RhcnRYID0gY3ggKyBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIHI7XG4gICAgICAgICAgY29uc3Qgc3RhcnRZID0gY3kgKyBNYXRoLnNpbihzdGFydEFuZ2xlKSAqIHI7XG4gICAgICAgICAgY29uc3QgY291bnRlckNsb2Nrd2lzZSA9IEJvb2xlYW4ocGFyYW1zW3BpKytdKTtcbiAgICAgICAgICBiZXN0ID0gbGluZURpc3RhbmNlU3F1YXJlZCh4LCB5LCBweCwgcHksIHN0YXJ0WCwgc3RhcnRZLCBiZXN0KTtcbiAgICAgICAgICBiZXN0ID0gYXJjRGlzdGFuY2VTcXVhcmVkKHgsIHksIGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNvdW50ZXJDbG9ja3dpc2UsIGJlc3QpO1xuICAgICAgICAgIHB4ID0gY3ggKyBNYXRoLmNvcyhlbmRBbmdsZSkgKiByO1xuICAgICAgICAgIHB5ID0gY3kgKyBNYXRoLnNpbihlbmRBbmdsZSkgKiByO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNCAvKiBDbG9zZVBhdGggKi86XG4gICAgICAgICAgYmVzdCA9IGxpbmVEaXN0YW5jZVNxdWFyZWQoeCwgeSwgcHgsIHB5LCBzeCwgc3ksIGJlc3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmVzdDtcbiAgfVxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2RcbiAgdG9TVkcodHJhbnNmb3JtID0gKHgsIHkpID0+ICh7IHgsIHkgfSkpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICBjb25zdCB7IGNvbW1hbmRzLCBwYXJhbXMgfSA9IHRoaXM7XG4gICAgY29uc3QgYWRkQ29tbWFuZCA9IChjb21tYW5kLCAuLi5wb2ludHMpID0+IHtcbiAgICAgIGJ1ZmZlci5wdXNoKGNvbW1hbmQpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0cmFuc2Zvcm0ocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKTtcbiAgICAgICAgYnVmZmVyLnB1c2goeCwgeSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgcGkgPSAwO1xuICAgIGZvciAoY29uc3QgY29tbWFuZCBvZiBjb21tYW5kcykge1xuICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgIGNhc2UgMCAvKiBNb3ZlICovOlxuICAgICAgICAgIGFkZENvbW1hbmQoXCJNXCIsIHBhcmFtc1twaSsrXSwgcGFyYW1zW3BpKytdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIC8qIExpbmUgKi86XG4gICAgICAgICAgYWRkQ29tbWFuZChcIkxcIiwgcGFyYW1zW3BpKytdLCBwYXJhbXNbcGkrK10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMgLyogQ3VydmUgKi86XG4gICAgICAgICAgYWRkQ29tbWFuZChcIkNcIiwgcGFyYW1zW3BpKytdLCBwYXJhbXNbcGkrK10sIHBhcmFtc1twaSsrXSwgcGFyYW1zW3BpKytdLCBwYXJhbXNbcGkrK10sIHBhcmFtc1twaSsrXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBBcmMgKi86IHtcbiAgICAgICAgICBjb25zdCBjeCA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBjeSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCByID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IEEwID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IEExID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IGNjdyA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBsZXQgc3dlZXAgPSBjY3cgPyBBMCAtIEExIDogQTEgLSBBMDtcbiAgICAgICAgICBpZiAoc3dlZXAgPCAwKSB7XG4gICAgICAgICAgICBzd2VlcCArPSBNYXRoLmNlaWwoLXN3ZWVwIC8gKDIgKiBNYXRoLlBJKSkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNjdykge1xuICAgICAgICAgICAgc3dlZXAgPSAtc3dlZXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFyY1NlY3Rpb25zID0gTWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKHN3ZWVwKSAvIChNYXRoLlBJIC8gMikpLCAxKTtcbiAgICAgICAgICBjb25zdCBzdGVwID0gc3dlZXAgLyBhcmNTZWN0aW9ucztcbiAgICAgICAgICBjb25zdCBoID0gNCAvIDMgKiBNYXRoLnRhbihzdGVwIC8gNCk7XG4gICAgICAgICAgY29uc3QgbW92ZSA9IGJ1ZmZlci5sZW5ndGggPT09IDAgPyBcIk1cIiA6IFwiTFwiO1xuICAgICAgICAgIGFkZENvbW1hbmQobW92ZSwgY3ggKyBNYXRoLmNvcyhBMCkgKiByLCBjeSArIE1hdGguc2luKEEwKSAqIHIpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJjU2VjdGlvbnM7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgYTAgPSBBMCArIHN0ZXAgKiAoaSArIDApO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBBMCArIHN0ZXAgKiAoaSArIDEpO1xuICAgICAgICAgICAgY29uc3QgclNpblN0YXJ0ID0gciAqIE1hdGguc2luKGEwKTtcbiAgICAgICAgICAgIGNvbnN0IHJDb3NTdGFydCA9IHIgKiBNYXRoLmNvcyhhMCk7XG4gICAgICAgICAgICBjb25zdCByU2luRW5kID0gciAqIE1hdGguc2luKGExKTtcbiAgICAgICAgICAgIGNvbnN0IHJDb3NFbmQgPSByICogTWF0aC5jb3MoYTEpO1xuICAgICAgICAgICAgYWRkQ29tbWFuZChcbiAgICAgICAgICAgICAgXCJDXCIsXG4gICAgICAgICAgICAgIGN4ICsgckNvc1N0YXJ0IC0gaCAqIHJTaW5TdGFydCxcbiAgICAgICAgICAgICAgY3kgKyByU2luU3RhcnQgKyBoICogckNvc1N0YXJ0LFxuICAgICAgICAgICAgICBjeCArIHJDb3NFbmQgKyBoICogclNpbkVuZCxcbiAgICAgICAgICAgICAgY3kgKyByU2luRW5kIC0gaCAqIHJDb3NFbmQsXG4gICAgICAgICAgICAgIGN4ICsgckNvc0VuZCxcbiAgICAgICAgICAgICAgY3kgKyByU2luRW5kXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDQgLyogQ2xvc2VQYXRoICovOlxuICAgICAgICAgIGJ1ZmZlci5wdXNoKFwiWlwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiIFwiKTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBjb25zdCB7IGNvbW1hbmRzLCBwYXJhbXMgfSA9IHRoaXM7XG4gICAgbGV0IFt0b3AsIGxlZnQsIHJpZ2h0LCBib3RdID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgIGxldCBbc3gsIHN5XSA9IFtOYU4sIE5hTl07XG4gICAgbGV0IFtteCwgbXldID0gW05hTiwgTmFOXTtcbiAgICBjb25zdCBqb2luUG9pbnQgPSAoeCwgeSwgdXBkYXRlc3RhcnQpID0+IHtcbiAgICAgIHRvcCA9IE1hdGgubWluKHksIHRvcCk7XG4gICAgICBsZWZ0ID0gTWF0aC5taW4oeCwgbGVmdCk7XG4gICAgICByaWdodCA9IE1hdGgubWF4KHgsIHJpZ2h0KTtcbiAgICAgIGJvdCA9IE1hdGgubWF4KHksIGJvdCk7XG4gICAgICBpZiAodXBkYXRlc3RhcnQpIHtcbiAgICAgICAgW3N4LCBzeV0gPSBbeCwgeV07XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgcGkgPSAwO1xuICAgIGZvciAoY29uc3QgY29tbWFuZCBvZiBjb21tYW5kcykge1xuICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgIGNhc2UgMCAvKiBNb3ZlICovOlxuICAgICAgICAgIGpvaW5Qb2ludChwYXJhbXNbcGkrK10sIHBhcmFtc1twaSsrXSwgdHJ1ZSk7XG4gICAgICAgICAgW214LCBteV0gPSBbc3gsIHN5XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIC8qIExpbmUgKi86XG4gICAgICAgICAgam9pblBvaW50KHBhcmFtc1twaSsrXSwgcGFyYW1zW3BpKytdLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzIC8qIEN1cnZlICovOiB7XG4gICAgICAgICAgY29uc3QgY3AxeCA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBjcDF5ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IGNwMnggPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgY3AyeSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCB4ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IHkgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgam9pblBvaW50KHgsIHksIHRydWUpO1xuICAgICAgICAgIGNvbnN0IFRzID0gY2FsY3VsYXRlRGVyaXZhdGl2ZUV4dHJlbWFYWShzeCwgc3ksIGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xuICAgICAgICAgIFRzLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHB4ID0gZXZhbHVhdGVCZXppZXIoc3gsIGNwMXgsIGNwMngsIHgsIHQpO1xuICAgICAgICAgICAgY29uc3QgcHkgPSBldmFsdWF0ZUJlemllcihzeSwgY3AxeSwgY3AyeSwgeSwgdCk7XG4gICAgICAgICAgICBqb2luUG9pbnQocHgsIHB5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIgLyogQXJjICovOiB7XG4gICAgICAgICAgY29uc3QgY3ggPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgY3kgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgciA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBsZXQgQTAgPSBub3JtYWxpemVBbmdsZTM2MChwYXJhbXNbcGkrK10pO1xuICAgICAgICAgIGxldCBBMSA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHBhcmFtc1twaSsrXSk7XG4gICAgICAgICAgY29uc3QgY2N3ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGlmIChjY3cpIHtcbiAgICAgICAgICAgIFtBMCwgQTFdID0gW0ExLCBBMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGpvaW5BbmdsZSA9IChhbmdsZTIsIHVwZGF0ZXN0YXJ0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBweCA9IGN4ICsgciAqIE1hdGguY29zKGFuZ2xlMik7XG4gICAgICAgICAgICBjb25zdCBweSA9IGN5ICsgciAqIE1hdGguc2luKGFuZ2xlMik7XG4gICAgICAgICAgICBqb2luUG9pbnQocHgsIHB5LCB1cGRhdGVzdGFydCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBqb2luQW5nbGUoQTApO1xuICAgICAgICAgIGpvaW5BbmdsZShBMSwgdHJ1ZSk7XG4gICAgICAgICAgY29uc3QgY3JpdGljYWxBbmdsZXMgPSBbMCwgTWF0aC5QSSAvIDIsIE1hdGguUEksIDMgKiBNYXRoLlBJIC8gMl07XG4gICAgICAgICAgZm9yIChjb25zdCBjcml0IG9mIGNyaXRpY2FsQW5nbGVzKSB7XG4gICAgICAgICAgICBpZiAoQTAgPCBBMSAmJiBBMCA8PSBjcml0ICYmIGNyaXQgPD0gQTEgfHwgQTAgPiBBMSAmJiAoQTAgPD0gY3JpdCB8fCBjcml0IDw9IEExKSkge1xuICAgICAgICAgICAgICBqb2luQW5nbGUoY3JpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNCAvKiBDbG9zZVBhdGggKi86XG4gICAgICAgICAgW3N4LCBzeV0gPSBbbXgsIG15XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCQm94KGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3QgLSB0b3ApO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9wYXRoLnRzXG5mdW5jdGlvbiBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24ob3B0cykge1xuICBjb25zdCB7IGNoYW5nZUNiLCBjb252ZXJ0b3IgfSA9IG9wdHMgPz8ge307XG4gIHJldHVybiBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwicGF0aFwiLCBjb252ZXJ0b3IsIGNoYW5nZUNiIH0pO1xufVxudmFyIFBhdGggPSBjbGFzcyBleHRlbmRzIFNoYXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKipcbiAgICAgKiBEZWNsYXJlIGEgcGF0aCB0byByZXRhaW4gZm9yIGxhdGVyIHJlbmRlcmluZyBhbmQgaGl0IHRlc3RpbmdcbiAgICAgKiB1c2luZyBjdXN0b20gUGF0aDJEIGNsYXNzLiBUaGluayBvZiBpdCBhcyBhIFR5cGVTY3JpcHQgdmVyc2lvblxuICAgICAqIG9mIHRoZSBuYXRpdmUgUGF0aDJEICh3aXRoIHNvbWUgZGlmZmVyZW5jZXMpIHRoYXQgd29ya3MgaW4gYWxsIGJyb3dzZXJzLlxuICAgICAqL1xuICAgIHRoaXMucGF0aCA9IG5ldyBFeHRlbmRlZFBhdGgyRCgpO1xuICAgIHRoaXMuX2NsaXBYID0gTmFOO1xuICAgIHRoaXMuX2NsaXBZID0gTmFOO1xuICAgIHRoaXMuY2xpcCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoZSBwYXRoIG9ubHkgaGFzIHRvIGJlIHVwZGF0ZWQgd2hlbiBjZXJ0YWluIGF0dHJpYnV0ZXMgY2hhbmdlLlxuICAgICAqIEZvciBleGFtcGxlLCBpZiB0cmFuc2Zvcm0gYXR0cmlidXRlcyAoc3VjaCBhcyBgdHJhbnNsYXRpb25YYClcbiAgICAgKiBhcmUgY2hhbmdlZCwgd2UgZG9uJ3QgaGF2ZSB0byB1cGRhdGUgdGhlIHBhdGguIFRoZSBgZGlydHlQYXRoYCBmbGFnXG4gICAgICogaXMgaG93IHdlIGtlZXAgdHJhY2sgaWYgdGhlIHBhdGggaGFzIHRvIGJlIHVwZGF0ZWQgb3Igbm90LlxuICAgICAqL1xuICAgIHRoaXMuX2RpcnR5UGF0aCA9IHRydWU7XG4gICAgdGhpcy5sYXN0UGl4ZWxSYXRpbyA9IE5hTjtcbiAgfVxuICBzZXQgY2xpcFgodmFsdWUpIHtcbiAgICB0aGlzLl9jbGlwWCA9IHZhbHVlO1xuICAgIHRoaXMuZGlydHlQYXRoID0gdHJ1ZTtcbiAgfVxuICBzZXQgY2xpcFkodmFsdWUpIHtcbiAgICB0aGlzLl9jbGlwWSA9IHZhbHVlO1xuICAgIHRoaXMuZGlydHlQYXRoID0gdHJ1ZTtcbiAgfVxuICBzZXQgZGlydHlQYXRoKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2RpcnR5UGF0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2RpcnR5UGF0aCA9IHZhbHVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBkaXJ0eVBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcnR5UGF0aDtcbiAgfVxuICBjaGVja1BhdGhEaXJ0eSgpIHtcbiAgICBpZiAodGhpcy5fZGlydHlQYXRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGlydHlQYXRoID0gdGhpcy5wYXRoLmlzRGlydHkoKSB8fCAodGhpcy5maWxsU2hhZG93Py5pc0RpcnR5KCkgPz8gZmFsc2UpIHx8ICh0aGlzLl9jbGlwUGF0aD8uaXNEaXJ0eSgpID8/IGZhbHNlKTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICB0aGlzLnVwZGF0ZVBhdGhJZkRpcnR5KCk7XG4gICAgcmV0dXJuIHRoaXMucGF0aC5jbG9zZWRQYXRoICYmIHRoaXMucGF0aC5pc1BvaW50SW5QYXRoKHgsIHkpO1xuICB9XG4gIGRpc3RhbmNlU3F1YXJlZCh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VTcXVhcmVkVHJhbnNmb3JtZWRQb2ludCh4LCB5KTtcbiAgfVxuICBzdmdQYXRoRGF0YSh0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLnVwZGF0ZVBhdGhJZkRpcnR5KCk7XG4gICAgcmV0dXJuIHRoaXMucGF0aC50b1NWRyh0cmFuc2Zvcm0pO1xuICB9XG4gIGRpc3RhbmNlU3F1YXJlZFRyYW5zZm9ybWVkUG9pbnQoeCwgeSkge1xuICAgIHRoaXMudXBkYXRlUGF0aElmRGlydHkoKTtcbiAgICBpZiAodGhpcy5wYXRoLmNsb3NlZFBhdGggJiYgdGhpcy5wYXRoLmlzUG9pbnRJblBhdGgoeCwgeSkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXRoLmRpc3RhbmNlU3F1YXJlZCh4LCB5KTtcbiAgfVxuICBpc0RpcnR5UGF0aCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdXBkYXRlUGF0aCgpIHtcbiAgfVxuICB1cGRhdGVQYXRoSWZEaXJ0eSgpIHtcbiAgICBpZiAodGhpcy5kaXJ0eVBhdGggfHwgdGhpcy5pc0RpcnR5UGF0aCgpKSB7XG4gICAgICB0aGlzLnVwZGF0ZVBhdGgoKTtcbiAgICAgIHRoaXMuZGlydHlQYXRoID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHByZVJlbmRlcihyZW5kZXJDdHgpIHtcbiAgICBpZiAocmVuZGVyQ3R4LmRldmljZVBpeGVsUmF0aW8gIT09IHRoaXMubGFzdFBpeGVsUmF0aW8pIHtcbiAgICAgIHRoaXMuZGlydHlQYXRoID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5sYXN0UGl4ZWxSYXRpbyA9IHJlbmRlckN0eC5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIHRoaXMudXBkYXRlUGF0aElmRGlydHkoKTtcbiAgICByZXR1cm4gc3VwZXIucHJlUmVuZGVyKHJlbmRlckN0eCwgdGhpcy5wYXRoLmNvbW1hbmRzLmxlbmd0aCk7XG4gIH1cbiAgcmVuZGVyKHJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgY3R4IH0gPSByZW5kZXJDdHg7XG4gICAgaWYgKHRoaXMuY2xpcCAmJiAhaXNOYU4odGhpcy5fY2xpcFgpICYmICFpc05hTih0aGlzLl9jbGlwWSkpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjb25zdCBtYXJnaW4gPSB0aGlzLnN0cm9rZVdpZHRoIC8gMjtcbiAgICAgIHRoaXMuX2NsaXBQYXRoID8/ICh0aGlzLl9jbGlwUGF0aCA9IG5ldyBFeHRlbmRlZFBhdGgyRCgpKTtcbiAgICAgIHRoaXMuX2NsaXBQYXRoLmNsZWFyKCk7XG4gICAgICB0aGlzLl9jbGlwUGF0aC5yZWN0KC1tYXJnaW4sIC1tYXJnaW4sIHRoaXMuX2NsaXBYICsgbWFyZ2luLCB0aGlzLl9jbGlwWSArIG1hcmdpbiArIG1hcmdpbik7XG4gICAgICBjdHguY2xpcCh0aGlzLl9jbGlwUGF0aD8uZ2V0UGF0aDJEKCkpO1xuICAgICAgaWYgKHRoaXMuX2NsaXBYID4gMCAmJiB0aGlzLl9jbGlwWSA+IDApIHtcbiAgICAgICAgdGhpcy5kcmF3UGF0aChjdHgpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY2xpcFBhdGggPSB2b2lkIDA7XG4gICAgICB0aGlzLmRyYXdQYXRoKGN0eCk7XG4gICAgfVxuICAgIHRoaXMuZmlsbFNoYWRvdz8ubWFya0NsZWFuKCk7XG4gICAgc3VwZXIucmVuZGVyKHJlbmRlckN0eCk7XG4gIH1cbiAgZHJhd1BhdGgoY3R4KSB7XG4gICAgdGhpcy5maWxsU3Ryb2tlKGN0eCwgdGhpcy5wYXRoLmdldFBhdGgyRCgpKTtcbiAgfVxuICB0b1NWRygpIHtcbiAgICBpZiAoIXRoaXMudmlzaWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlbGVtZW50MiA9IGNyZWF0ZVN2Z0VsZW1lbnQoXCJwYXRoXCIpO1xuICAgIGVsZW1lbnQyLnNldEF0dHJpYnV0ZShcImRcIiwgdGhpcy5zdmdQYXRoRGF0YSgpKTtcbiAgICB0aGlzLmFwcGx5U3ZnRmlsbEF0dHJpYnV0ZXMoZWxlbWVudDIpO1xuICAgIHRoaXMuYXBwbHlTdmdTdHJva2VBdHRyaWJ1dGVzKGVsZW1lbnQyKTtcbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudHM6IFtlbGVtZW50Ml1cbiAgICB9O1xuICB9XG59O1xuUGF0aC5jbGFzc05hbWUgPSBcIlBhdGhcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBQYXRoLnByb3RvdHlwZSwgXCJjbGlwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFBhdGgucHJvdG90eXBlLCBcImNsaXBYXCIsIDEpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFBhdGgucHJvdG90eXBlLCBcImNsaXBZXCIsIDEpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9kb20vZm9jdXNJbmRpY2F0b3IudHNcbnZhciBGb2N1c0luZGljYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc3dhcENoYWluKSB7XG4gICAgdGhpcy5zd2FwQ2hhaW4gPSBzd2FwQ2hhaW47XG4gICAgdGhpcy5kaXYgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuc3ZnID0gY3JlYXRlU3ZnRWxlbWVudChcInN2Z1wiKTtcbiAgICB0aGlzLm91dGVyUGF0aCA9IGNyZWF0ZVN2Z0VsZW1lbnQoXCJwYXRoXCIpO1xuICAgIHRoaXMuaW5uZXJQYXRoID0gY3JlYXRlU3ZnRWxlbWVudChcInBhdGhcIik7XG4gICAgdGhpcy5zdmcuYXBwZW5kKHRoaXMub3V0ZXJQYXRoKTtcbiAgICB0aGlzLnN2Zy5hcHBlbmQodGhpcy5pbm5lclBhdGgpO1xuICAgIHRoaXMub3V0ZXJQYXRoLmNsYXNzTGlzdC5hZGQoXCJhZy1jaGFydHMtZm9jdXMtc3ZnLW91dGVyLXBhdGhcIik7XG4gICAgdGhpcy5pbm5lclBhdGguY2xhc3NMaXN0LmFkZChcImFnLWNoYXJ0cy1mb2N1cy1zdmctaW5uZXItcGF0aFwiKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiYWctY2hhcnRzLWZvY3VzLWluZGljYXRvclwiKTtcbiAgICB0aGlzLmVsZW1lbnQuYXJpYUhpZGRlbiA9IFwidHJ1ZVwiO1xuICAgIHRoaXMuZWxlbWVudC5hcHBlbmQodGhpcy5zdmcpO1xuICAgIHRoaXMuc3dhcENoYWluLmFkZExpc3RlbmVyKFwic3dhcFwiLCAocGFyZW50KSA9PiB0aGlzLm9uU3dhcChwYXJlbnQpKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgfVxuICB1cGRhdGUoZm9jdXMsIHJlY3QsIGNsaXApIHtcbiAgICBpZiAocmVjdCA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChmb2N1cyBpbnN0YW5jZW9mIFBhdGgpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IChsb2NhbFgsIGxvY2FsWSkgPT4ge1xuICAgICAgICBsZXQgeyB4LCB5IH0gPSBUcmFuc2Zvcm1hYmxlLnRvQ2FudmFzUG9pbnQoZm9jdXMsIGxvY2FsWCwgbG9jYWxZKTtcbiAgICAgICAgeCAtPSByZWN0LnggPz8gMDtcbiAgICAgICAgeSAtPSByZWN0LnkgPz8gMDtcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGQgPSBmb2N1cy5zdmdQYXRoRGF0YSh0cmFuc2Zvcm0pO1xuICAgICAgdGhpcy5vdXRlclBhdGguc2V0QXR0cmlidXRlKFwiZFwiLCBkKTtcbiAgICAgIHRoaXMuaW5uZXJQYXRoLnNldEF0dHJpYnV0ZShcImRcIiwgZCk7XG4gICAgICB0aGlzLnNob3codGhpcy5zdmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgYmJveDtcbiAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgIGNvbnN0IHgwID0gTWF0aC5tYXgoZm9jdXMueCAtIHJlY3QueCwgMCk7XG4gICAgICAgIGNvbnN0IHkwID0gTWF0aC5tYXgoZm9jdXMueSAtIHJlY3QueSwgMCk7XG4gICAgICAgIGNvbnN0IHgxID0gTWF0aC5taW4oZm9jdXMueCArIGZvY3VzLndpZHRoIC0gcmVjdC54LCByZWN0LndpZHRoKTtcbiAgICAgICAgY29uc3QgeTEgPSBNYXRoLm1pbihmb2N1cy55ICsgZm9jdXMuaGVpZ2h0IC0gcmVjdC55LCByZWN0LmhlaWdodCk7XG4gICAgICAgIGJib3ggPSBuZXcgQkJveCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmJveCA9IG5ldyBCQm94KGZvY3VzLnggLSByZWN0LngsIGZvY3VzLnkgLSByZWN0LnksIGZvY3VzLndpZHRoLCBmb2N1cy5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgc2V0RWxlbWVudEJCb3godGhpcy5kaXYsIGJib3gpO1xuICAgICAgdGhpcy5zaG93KHRoaXMuZGl2KTtcbiAgICB9XG4gIH1cbiAgb25Td2FwKG5ld1BhcmVudCkge1xuICAgIGlmIChuZXdQYXJlbnQgPT09IHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmUoKTtcbiAgICBuZXdQYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLm92ZXJyaWRlRm9jdXNWaXNpYmxlKHRoaXMuZm9jdXNWaXNpYmxlKTtcbiAgfVxuICBzaG93KGNoaWxkKSB7XG4gICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZChjaGlsZCk7XG4gIH1cbiAgb3ZlcnJpZGVGb2N1c1Zpc2libGUoZm9jdXNWaXNpYmxlKSB7XG4gICAgdGhpcy5mb2N1c1Zpc2libGUgPSBmb2N1c1Zpc2libGU7XG4gICAgY29uc3Qgb3BhY2l0eSA9IHsgdHJ1ZTogXCIxXCIsIGZhbHNlOiBcIjBcIiwgdW5kZWZpbmVkOiBcIlwiIH07XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgcGFyZW50Py5zdHlsZS5zZXRQcm9wZXJ0eShcIm9wYWNpdHlcIiwgb3BhY2l0eVtgJHtmb2N1c1Zpc2libGV9YF0pO1xuICB9XG4gIC8vIEdldCB0aGUgYDpmb2N1cy12aXNpYmxlYCBDU1Mgc3RhdGUuXG4gIGlzRm9jdXNWaXNpYmxlKCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIHJldHVybiBwYXJlbnQgIT0gbnVsbCAmJiBnZXRXaW5kb3coKS5nZXRDb21wdXRlZFN0eWxlKHBhcmVudCkub3BhY2l0eSA9PT0gXCIxXCI7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2RvbS9mb2N1c1N3YXBDaGFpbi50c1xudmFyIEZvY3VzU3dhcENoYWluID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihsYWJlbDEsIGxhYmVsMiwgaWQsIGFubm91bmNlclJvbGUpIHtcbiAgICB0aGlzLmxhYmVsMSA9IGxhYmVsMTtcbiAgICB0aGlzLmxhYmVsMiA9IGxhYmVsMjtcbiAgICB0aGlzLmhhc0ZvY3VzID0gZmFsc2U7XG4gICAgdGhpcy5za2lwRGlzcGF0Y2ggPSBmYWxzZTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHtcbiAgICAgIGJsdXI6IFtdLFxuICAgICAgZm9jdXM6IFtdLFxuICAgICAgc3dhcDogW11cbiAgICB9O1xuICAgIHRoaXMub25CbHVyID0gKGUpID0+IHtcbiAgICAgIHNldEVsZW1lbnRTdHlsZShlLnRhcmdldCwgXCJwb2ludGVyLWV2ZW50c1wiLCB2b2lkIDApO1xuICAgICAgcmV0dXJuICF0aGlzLnNraXBEaXNwYXRjaCAmJiB0aGlzLmRpc3BhdGNoKFwiYmx1clwiLCBlKTtcbiAgICB9O1xuICAgIHRoaXMub25Gb2N1cyA9IChlKSA9PiB7XG4gICAgICBzZXRFbGVtZW50U3R5bGUoZS50YXJnZXQsIFwicG9pbnRlci1ldmVudHNcIiwgXCJhdXRvXCIpO1xuICAgICAgcmV0dXJuICF0aGlzLnNraXBEaXNwYXRjaCAmJiB0aGlzLmRpc3BhdGNoKFwiZm9jdXNcIiwgZSk7XG4gICAgfTtcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5sYWJlbDEsIFwiaWRcIiwgYCR7aWR9LWxhYmVsMWApO1xuICAgIHNldEF0dHJpYnV0ZSh0aGlzLmxhYmVsMiwgXCJpZFwiLCBgJHtpZH0tbGFiZWwyYCk7XG4gICAgc2V0RWxlbWVudFN0eWxlKHRoaXMubGFiZWwxLCBcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgIHNldEVsZW1lbnRTdHlsZSh0aGlzLmxhYmVsMiwgXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICB0aGlzLmFjdGl2ZUFubm91bmNlciA9IHRoaXMuY3JlYXRlQW5ub3VuY2VyKGFubm91bmNlclJvbGUpO1xuICAgIHRoaXMuaW5hY3RpdmVBbm5vdW5jZXIgPSB0aGlzLmNyZWF0ZUFubm91bmNlcihhbm5vdW5jZXJSb2xlKTtcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5hY3RpdmVBbm5vdW5jZXIsIFwidGFiaW5kZXhcIiwgMCk7XG4gICAgdGhpcy5sYWJlbDIuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJlbmRcIiwgdGhpcy5hY3RpdmVBbm5vdW5jZXIpO1xuICAgIHRoaXMubGFiZWwyLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyZW5kXCIsIHRoaXMuaW5hY3RpdmVBbm5vdW5jZXIpO1xuICAgIHRoaXMuc3dhcChcIlwiKTtcbiAgfVxuICBjcmVhdGVBbm5vdW5jZXIocm9sZSkge1xuICAgIGNvbnN0IGFubm91bmNlciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgYW5ub3VuY2VyLnJvbGUgPSByb2xlO1xuICAgIGFubm91bmNlci5jbGFzc05hbWUgPSBcImFnLWNoYXJ0cy1zd2FwY2hhaW5cIjtcbiAgICBhbm5vdW5jZXIuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5vbkJsdXIpO1xuICAgIGFubm91bmNlci5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5vbkZvY3VzKTtcbiAgICByZXR1cm4gYW5ub3VuY2VyO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBhbm5vdW5jZXIgb2YgW3RoaXMuYWN0aXZlQW5ub3VuY2VyLCB0aGlzLmluYWN0aXZlQW5ub3VuY2VyXSkge1xuICAgICAgYW5ub3VuY2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMub25CbHVyKTtcbiAgICAgIGFubm91bmNlci5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5vbkZvY3VzKTtcbiAgICAgIGFubm91bmNlci5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgZm9jdXMob3B0cykge1xuICAgIHRoaXMuZm9jdXNPcHRpb25zID0gb3B0cztcbiAgICB0aGlzLmFjdGl2ZUFubm91bmNlci5mb2N1cyhvcHRzKTtcbiAgICB0aGlzLmZvY3VzT3B0aW9ucyA9IHZvaWQgMDtcbiAgfVxuICB1cGRhdGUobmV3TGFiZWwpIHtcbiAgICB0aGlzLnNraXBEaXNwYXRjaCA9IHRydWU7XG4gICAgdGhpcy5zd2FwKG5ld0xhYmVsKTtcbiAgICBpZiAodGhpcy5oYXNGb2N1cykge1xuICAgICAgdGhpcy5hY3RpdmVBbm5vdW5jZXIuZm9jdXModGhpcy5mb2N1c09wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLnNraXBEaXNwYXRjaCA9IGZhbHNlO1xuICB9XG4gIGFkZExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKGhhbmRsZXIpO1xuICAgIGlmICh0eXBlID09PSBcInN3YXBcIikge1xuICAgICAgY29uc3Qgc3dhcEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgc3dhcEhhbmRsZXIodGhpcy5hY3RpdmVBbm5vdW5jZXIpO1xuICAgIH1cbiAgfVxuICBkaXNwYXRjaCh0eXBlLCBwYXJhbSkge1xuICAgIGlmICh0eXBlID09PSBcImZvY3VzXCIpXG4gICAgICB0aGlzLmhhc0ZvY3VzID0gdHJ1ZTtcbiAgICBlbHNlIGlmICh0eXBlID09PSBcImJsdXJcIilcbiAgICAgIHRoaXMuaGFzRm9jdXMgPSBmYWxzZTtcbiAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5mb3JFYWNoKChmbikgPT4gZm4ocGFyYW0pKTtcbiAgfVxuICBzd2FwKG5ld0xhYmVsKSB7XG4gICAgY29uc3QgdXNlclRhYkluZGV4ID0gdGhpcy5hY3RpdmVBbm5vdW5jZXIudGFiSW5kZXg7XG4gICAgdGhpcy5sYWJlbDIudGV4dENvbnRlbnQgPSBuZXdMYWJlbDtcbiAgICBbdGhpcy5pbmFjdGl2ZUFubm91bmNlciwgdGhpcy5hY3RpdmVBbm5vdW5jZXJdID0gW3RoaXMuYWN0aXZlQW5ub3VuY2VyLCB0aGlzLmluYWN0aXZlQW5ub3VuY2VyXTtcbiAgICBbdGhpcy5sYWJlbDEsIHRoaXMubGFiZWwyXSA9IFt0aGlzLmxhYmVsMiwgdGhpcy5sYWJlbDFdO1xuICAgIHNldEF0dHJpYnV0ZXModGhpcy5pbmFjdGl2ZUFubm91bmNlciwge1xuICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogdGhpcy5sYWJlbDEuaWQsXG4gICAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgICB0YWJpbmRleDogdm9pZCAwXG4gICAgfSk7XG4gICAgc2V0QXR0cmlidXRlcyh0aGlzLmFjdGl2ZUFubm91bmNlciwge1xuICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogdGhpcy5sYWJlbDEuaWQsXG4gICAgICBcImFyaWEtaGlkZGVuXCI6IGZhbHNlLFxuICAgICAgdGFiaW5kZXg6IHVzZXJUYWJJbmRleFxuICAgIH0pO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJzd2FwXCIsIHRoaXMuYWN0aXZlQW5ub3VuY2VyKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24va2V5QmluZGluZ3MudHNcbnZhciBLRVlfQklORElOR1MgPSB7XG4gIGFycm93ZG93bjogeyBiaW5kaW5nczogW3sgY29kZTogXCJBcnJvd0Rvd25cIiB9XSB9LFxuICBhcnJvd2xlZnQ6IHsgYmluZGluZ3M6IFt7IGNvZGU6IFwiQXJyb3dMZWZ0XCIgfV0gfSxcbiAgYXJyb3dyaWdodDogeyBiaW5kaW5nczogW3sgY29kZTogXCJBcnJvd1JpZ2h0XCIgfV0gfSxcbiAgYXJyb3d1cDogeyBiaW5kaW5nczogW3sgY29kZTogXCJBcnJvd1VwXCIgfV0gfSxcbiAgZGVsZXRlOiB7IGJpbmRpbmdzOiBbeyBrZXk6IFwiQmFja3NwYWNlXCIgfSwgeyBrZXk6IFwiRGVsZXRlXCIgfV0sIGFjdGl2YXRlc0ZvY3VzSW5kaWNhdG9yOiBmYWxzZSB9LFxuICByZWRvOiB7XG4gICAgYmluZGluZ3M6IFtcbiAgICAgIHsga2V5OiBcInlcIiwgY3RybE9yTWV0YTogdHJ1ZSB9LFxuICAgICAgeyBrZXk6IFwielwiLCBjdHJsT3JNZXRhOiB0cnVlLCBzaGlmdDogdHJ1ZSB9XG4gICAgXSxcbiAgICBhY3RpdmF0ZXNGb2N1c0luZGljYXRvcjogZmFsc2VcbiAgfSxcbiAgdW5kbzogeyBiaW5kaW5nczogW3sga2V5OiBcInpcIiwgY3RybE9yTWV0YTogdHJ1ZSB9XSwgYWN0aXZhdGVzRm9jdXNJbmRpY2F0b3I6IGZhbHNlIH0sXG4gIHN1Ym1pdDogeyBiaW5kaW5nczogW3sga2V5OiBcIkVudGVyXCIgfSwgeyBjb2RlOiBcIkVudGVyXCIgfSwgeyBjb2RlOiBcIlNwYWNlXCIgfV0gfSxcbiAgem9vbWluOiB7IGJpbmRpbmdzOiBbeyBrZXk6IFwiK1wiIH0sIHsgY29kZTogXCJab29tSW5cIiB9LCB7IGNvZGU6IFwiQWRkXCIgfV0sIGFjdGl2YXRlc0ZvY3VzSW5kaWNhdG9yOiBmYWxzZSB9LFxuICB6b29tb3V0OiB7IGJpbmRpbmdzOiBbeyBrZXk6IFwiLVwiIH0sIHsgY29kZTogXCJab29tT3V0XCIgfSwgeyBjb2RlOiBcIlN1YnN0cmFjdFwiIH1dLCBhY3RpdmF0ZXNGb2N1c0luZGljYXRvcjogZmFsc2UgfVxufTtcbmZ1bmN0aW9uIG1hdGNoZXNLZXlCaW5kaW5nKGUsIGJpbmRpbmdzKSB7XG4gIGZvciAoY29uc3Qga2Igb2YgYmluZGluZ3MpIHtcbiAgICBpZiAoXCJjb2RlXCIgaW4ga2IpIHtcbiAgICAgIGlmIChrYi5jb2RlID09PSBlLmNvZGUpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXRjaGVzID0ga2Iua2V5ID09PSBlLmtleSAmJiAoa2Iuc2hpZnQgPT09IHZvaWQgMCB8fCBrYi5zaGlmdCA9PT0gZS5zaGlmdEtleSkgJiYgKGtiLmN0cmxPck1ldGEgPT09IHZvaWQgMCB8fCBrYi5jdHJsT3JNZXRhID09PSBlLmN0cmxLZXkgfHwga2IuY3RybE9yTWV0YSA9PT0gZS5tZXRhS2V5KTtcbiAgICAgIGlmIChtYXRjaGVzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbWFwS2V5Ym9hcmRFdmVudFRvQWN0aW9uKGV2ZW50KSB7XG4gIGZvciAoY29uc3QgW2FjdGlvbk5hbWUsIHsgYWN0aXZhdGVzRm9jdXNJbmRpY2F0b3IgPSB0cnVlLCBiaW5kaW5ncyB9XSBvZiBPYmplY3QuZW50cmllcyhLRVlfQklORElOR1MpKSB7XG4gICAgaWYgKG1hdGNoZXNLZXlCaW5kaW5nKGV2ZW50LCBiaW5kaW5ncykpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhY3Rpb25OYW1lO1xuICAgICAgcmV0dXJuIHsgbmFtZSwgYWN0aXZhdGVzRm9jdXNJbmRpY2F0b3IgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQva2V5Ym9hcmRVdGlsLnRzXG5mdW5jdGlvbiBjb21wdXRlQ2VudGVyKHNlcmllcywgaG92ZXJSZWN0LCBwaWNrKSB7XG4gIGNvbnN0IHJlZlBvaW50ID0gZ2V0RGF0dW1SZWZQb2ludChzZXJpZXMsIHBpY2suZGF0dW0pO1xuICBpZiAocmVmUG9pbnQgIT0gbnVsbClcbiAgICByZXR1cm4geyB4OiByZWZQb2ludC5jYW52YXNYLCB5OiByZWZQb2ludC5jYW52YXNZIH07XG4gIGNvbnN0IGJib3hPclBhdGggPSBwaWNrLmJvdW5kcztcbiAgaWYgKGJib3hPclBhdGggPT0gbnVsbClcbiAgICByZXR1cm47XG4gIGlmIChiYm94T3JQYXRoIGluc3RhbmNlb2YgQkJveCkge1xuICAgIGNvbnN0IHsgeDogY2VudGVyWCwgeTogY2VudGVyWSB9ID0gYmJveE9yUGF0aC5jb21wdXRlQ2VudGVyKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvdmVyUmVjdC54ICsgY2VudGVyWCxcbiAgICAgIHk6IGhvdmVyUmVjdC55ICsgY2VudGVyWVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIFRyYW5zZm9ybWFibGUudG9DYW52YXMoYmJveE9yUGF0aCkuY29tcHV0ZUNlbnRlcigpO1xufVxuZnVuY3Rpb24gZ2V0UGlja2VkRm9jdXNCQm94KHsgYm91bmRzIH0pIHtcbiAgaWYgKGJvdW5kcyBpbnN0YW5jZW9mIEJCb3gpXG4gICAgcmV0dXJuIGJvdW5kcztcbiAgaWYgKGJvdW5kcyAhPSBudWxsKVxuICAgIHJldHVybiBUcmFuc2Zvcm1hYmxlLnRvQ2FudmFzKGJvdW5kcyk7XG4gIHJldHVybiBCQm94Lk5hTjtcbn1cbmZ1bmN0aW9uIG1ha2VLZXlib2FyZFBvaW50ZXJFdmVudChzZXJpZXMsIGhvdmVyUmVjdCwgcGljaykge1xuICBjb25zdCB7IHg6IGNhbnZhc1gsIHk6IGNhbnZhc1kgfSA9IGNvbXB1dGVDZW50ZXIoc2VyaWVzLCBob3ZlclJlY3QsIHBpY2spID8/IHt9O1xuICBpZiAoY2FudmFzWCAhPT0gdm9pZCAwICYmIGNhbnZhc1kgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwia2V5Ym9hcmRcIiwgY2FudmFzWCwgY2FudmFzWSB9O1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvcGxhY2VtZW50LnRzXG5mdW5jdGlvbiBjYWxjdWxhdGVQbGFjZW1lbnQobmF0dXJhbFdpZHRoLCBuYXR1cmFsSGVpZ2h0LCBjb250YWluZXIsIGJvdW5kcykge1xuICBsZXQgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gYm91bmRzO1xuICBpZiAobGVmdCAhPSBudWxsKSB7XG4gICAgaWYgKHdpZHRoMiAhPSBudWxsKSB7XG4gICAgICByaWdodCA9IGNvbnRhaW5lci53aWR0aCAtIGxlZnQgKyB3aWR0aDI7XG4gICAgfSBlbHNlIGlmIChyaWdodCAhPSBudWxsKSB7XG4gICAgICB3aWR0aDIgPSBjb250YWluZXIud2lkdGggLSBsZWZ0IC0gcmlnaHQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJpZ2h0ICE9IG51bGwgJiYgd2lkdGgyICE9IG51bGwpIHtcbiAgICBsZWZ0ID0gY29udGFpbmVyLndpZHRoIC0gcmlnaHQgLSB3aWR0aDI7XG4gIH1cbiAgaWYgKHRvcCAhPSBudWxsKSB7XG4gICAgaWYgKGhlaWdodDIgIT0gbnVsbCkge1xuICAgICAgYm90dG9tID0gY29udGFpbmVyLmhlaWdodCAtIHRvcCAtIGhlaWdodDI7XG4gICAgfSBlbHNlIGlmIChib3R0b20gIT0gbnVsbCkge1xuICAgICAgaGVpZ2h0MiA9IGNvbnRhaW5lci5oZWlnaHQgLSBib3R0b20gLSB0b3A7XG4gICAgfVxuICB9IGVsc2UgaWYgKGJvdHRvbSAhPSBudWxsICYmIGhlaWdodDIgIT0gbnVsbCkge1xuICAgIHRvcCA9IGNvbnRhaW5lci5oZWlnaHQgLSBib3R0b20gLSBoZWlnaHQyO1xuICB9XG4gIGlmICh3aWR0aDIgPT0gbnVsbCkge1xuICAgIGlmIChoZWlnaHQyID09IG51bGwpIHtcbiAgICAgIHdpZHRoMiA9IG5hdHVyYWxXaWR0aDtcbiAgICAgIGhlaWdodDIgPSBuYXR1cmFsSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aDIgPSBNYXRoLmNlaWwobmF0dXJhbFdpZHRoICogaGVpZ2h0MiAvIG5hdHVyYWxIZWlnaHQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChoZWlnaHQyID09IG51bGwpIHtcbiAgICBoZWlnaHQyID0gTWF0aC5jZWlsKG5hdHVyYWxIZWlnaHQgKiB3aWR0aDIgLyBuYXR1cmFsV2lkdGgpO1xuICB9XG4gIGlmIChsZWZ0ID09IG51bGwpIHtcbiAgICBpZiAocmlnaHQgPT0gbnVsbCkge1xuICAgICAgbGVmdCA9IE1hdGguZmxvb3IoKGNvbnRhaW5lci53aWR0aCAtIHdpZHRoMikgLyAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IGNvbnRhaW5lci53aWR0aCAtIHJpZ2h0IC0gd2lkdGgyO1xuICAgIH1cbiAgfVxuICBpZiAodG9wID09IG51bGwpIHtcbiAgICBpZiAoYm90dG9tID09IG51bGwpIHtcbiAgICAgIHRvcCA9IE1hdGguZmxvb3IoKGNvbnRhaW5lci5oZWlnaHQgLSBoZWlnaHQyKSAvIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3AgPSBjb250YWluZXIuaGVpZ2h0IC0gaGVpZ2h0MiAtIGJvdHRvbTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgeDogbGVmdCwgeTogdG9wLCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9zYW5pdGl6ZS50c1xudmFyIGVsZW1lbnQgPSBudWxsO1xuZnVuY3Rpb24gc2FuaXRpemVIdG1sKHRleHQyKSB7XG4gIGlmICh0ZXh0MiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHRleHQyID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgZWxlbWVudCA/PyAoZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICBlbGVtZW50LnRleHRDb250ZW50ID0gU3RyaW5nKHRleHQyKTtcbiAgcmV0dXJuIGVsZW1lbnQuaW5uZXJIVE1MO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvc2hhcGVzLnRzXG5mdW5jdGlvbiBkcmF3TWFya2VyVW5pdFBvbHlnb24ocGFyYW1zLCBtb3Zlcykge1xuICBjb25zdCB7IHBhdGgsIHNpemUgfSA9IHBhcmFtcztcbiAgY29uc3QgeyB4OiB4MCwgeTogeTAgfSA9IHBhcmFtcztcbiAgcGF0aC5jbGVhcigpO1xuICBsZXQgZGlkTW92ZSA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IFtkeCwgZHldIG9mIG1vdmVzKSB7XG4gICAgY29uc3QgeCA9IHgwICsgKGR4IC0gMC41KSAqIHNpemU7XG4gICAgY29uc3QgeSA9IHkwICsgKGR5IC0gMC41KSAqIHNpemU7XG4gICAgaWYgKGRpZE1vdmUpIHtcbiAgICAgIHBhdGgubGluZVRvKHgsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoLm1vdmVUbyh4LCB5KTtcbiAgICB9XG4gICAgZGlkTW92ZSA9IHRydWU7XG4gIH1cbiAgcGF0aC5jbG9zZVBhdGgoKTtcbn1cbnZhciBNQVJLRVJfU0hBUEVTID0ge1xuICBjaXJjbGUoeyBwYXRoLCB4LCB5LCBzaXplIH0pIHtcbiAgICBjb25zdCByID0gc2l6ZSAvIDI7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIHBhdGguYXJjKHgsIHksIHIsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9LFxuICBjcm9zcyhwYXJhbXMpIHtcbiAgICBkcmF3TWFya2VyVW5pdFBvbHlnb24ocGFyYW1zLCBbXG4gICAgICBbMC4yNSwgMF0sXG4gICAgICBbMC41LCAwLjI1XSxcbiAgICAgIFswLjc1LCAwXSxcbiAgICAgIFsxLCAwLjI1XSxcbiAgICAgIFswLjc1LCAwLjVdLFxuICAgICAgWzEsIDAuNzVdLFxuICAgICAgWzAuNzUsIDFdLFxuICAgICAgWzAuNSwgMC43NV0sXG4gICAgICBbMC4yNSwgMV0sXG4gICAgICBbMCwgMC43NV0sXG4gICAgICBbMC4yNSwgMC41XSxcbiAgICAgIFswLCAwLjI1XVxuICAgIF0pO1xuICB9LFxuICBkaWFtb25kKHBhcmFtcykge1xuICAgIGRyYXdNYXJrZXJVbml0UG9seWdvbihwYXJhbXMsIFtcbiAgICAgIFswLjUsIDBdLFxuICAgICAgWzEsIDAuNV0sXG4gICAgICBbMC41LCAxXSxcbiAgICAgIFswLCAwLjVdXG4gICAgXSk7XG4gIH0sXG4gIGhlYXJ0KHsgcGF0aCwgeCwgeSwgc2l6ZSB9KSB7XG4gICAgY29uc3QgciA9IHNpemUgLyA0O1xuICAgIHkgPSB5ICsgciAvIDI7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIHBhdGguYXJjKHggLSByLCB5IC0gciwgciwgdG9SYWRpYW5zKDEzMCksIHRvUmFkaWFucygzMzApKTtcbiAgICBwYXRoLmFyYyh4ICsgciwgeSAtIHIsIHIsIHRvUmFkaWFucygyMjApLCB0b1JhZGlhbnMoNTApKTtcbiAgICBwYXRoLmxpbmVUbyh4LCB5ICsgcik7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfSxcbiAgcGluKHsgcGF0aCwgeCwgeSwgc2l6ZTogcyB9KSB7XG4gICAgY29uc3QgY3ggPSAwLjU7XG4gICAgY29uc3QgY3kgPSAwLjU7XG4gICAgcGF0aC5tb3ZlVG8oeCArICgwLjE1NjI1IC0gY3gpICogcywgeSArICgwLjM0Mzc1IC0gY3kpICogcyk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuMTU2MjUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjE1MTQ5MSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuMzA3NzQxIC0gY3gpICogcyxcbiAgICAgIHkgKyAoMCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAgLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC42OTIyNTkgLSBjeCkgKiBzLFxuICAgICAgeSArICgwIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC44NDM3NSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuMTUxNDkxIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC44NDM3NSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuMzQzNzUgLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC44NDM3NSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNDkzODI0IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC43ODQ2MjUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjYwMDE4MSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNzE2NDYxIC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC42OTUzOTMgLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC42OTkwMDkgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjcxOTc2OSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNjgxMjcxIC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC43NDMxMDQgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjY2Mzc4NSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNzY2MTA1IC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuNjExODkzIC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC44MzQzNjcgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjU2MjIyOCAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuODk5Njk5IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC41Mjg4OTYgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjk4MDY0OCAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjUyNDA3NSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuOTkyMzU4IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC41MTI2NjMgLSBjeCkgKiBzLFxuICAgICAgeSArICgxIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC41IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMSAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjQ4NzMzNyAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDEgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjQ3NTkyNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuOTkyMzU4IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC40NzExMDQgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjk4MDY0OCAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjQ4NzMzNyAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDEgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjQ3NTkyNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuOTkyMzU4IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC40NzExMDQgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjk4MDY0OCAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjQzNzc3MiAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuODk5Njk5IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC4zODgxMDcgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjgzNDM2NyAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuMzM2MjE1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC43NjYxMDUgLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC4zMTg3MjkgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjc0MzEwNCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuMzAwOTkxIC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC43MTk3NjkgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjI4MzUzOSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNjk1MzkzIC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuMjE1Mzc1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC42MDAxODEgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjE1NjI1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC40OTM4MjQgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjE1NjI1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC4zNDM3NSAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH0sXG4gIHBsdXMocGFyYW1zKSB7XG4gICAgZHJhd01hcmtlclVuaXRQb2x5Z29uKHBhcmFtcywgW1xuICAgICAgWzEgLyAzLCAwXSxcbiAgICAgIFsyIC8gMywgMF0sXG4gICAgICBbMiAvIDMsIDEgLyAzXSxcbiAgICAgIFsxLCAxIC8gM10sXG4gICAgICBbMSwgMiAvIDNdLFxuICAgICAgWzIgLyAzLCAyIC8gM10sXG4gICAgICBbMiAvIDMsIDFdLFxuICAgICAgWzEgLyAzLCAxXSxcbiAgICAgIFsxIC8gMywgMiAvIDNdLFxuICAgICAgWzAsIDIgLyAzXSxcbiAgICAgIFswLCAxIC8gM10sXG4gICAgICBbMSAvIDMsIDEgLyAzXVxuICAgIF0pO1xuICB9LFxuICBzcXVhcmUoeyBwYXRoLCB4LCB5LCBzaXplLCBwaXhlbFJhdGlvIH0pIHtcbiAgICBjb25zdCBocyA9IHNpemUgLyAyO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBwYXRoLm1vdmVUbyhhbGlnbihwaXhlbFJhdGlvLCB4IC0gaHMpLCBhbGlnbihwaXhlbFJhdGlvLCB5IC0gaHMpKTtcbiAgICBwYXRoLmxpbmVUbyhhbGlnbihwaXhlbFJhdGlvLCB4ICsgaHMpLCBhbGlnbihwaXhlbFJhdGlvLCB5IC0gaHMpKTtcbiAgICBwYXRoLmxpbmVUbyhhbGlnbihwaXhlbFJhdGlvLCB4ICsgaHMpLCBhbGlnbihwaXhlbFJhdGlvLCB5ICsgaHMpKTtcbiAgICBwYXRoLmxpbmVUbyhhbGlnbihwaXhlbFJhdGlvLCB4IC0gaHMpLCBhbGlnbihwaXhlbFJhdGlvLCB5ICsgaHMpKTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9LFxuICBzdGFyKHsgcGF0aCwgeCwgeSwgc2l6ZSB9KSB7XG4gICAgY29uc3Qgc3Bpa2VzID0gNTtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IHNpemUgLyAyO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLyAyO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gTWF0aC5QSSAvIDI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGlrZXMgKiAyOyBpKyspIHtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IGkgJSAyID09PSAwID8gb3V0ZXJSYWRpdXMgOiBpbm5lclJhZGl1cztcbiAgICAgIGNvbnN0IGFuZ2xlMiA9IGkgKiBNYXRoLlBJIC8gc3Bpa2VzIC0gcm90YXRpb247XG4gICAgICBjb25zdCB4Q29vcmRpbmF0ZSA9IHggKyBNYXRoLmNvcyhhbmdsZTIpICogcmFkaXVzO1xuICAgICAgY29uc3QgeUNvb3JkaW5hdGUgPSB5ICsgTWF0aC5zaW4oYW5nbGUyKSAqIHJhZGl1cztcbiAgICAgIHBhdGgubGluZVRvKHhDb29yZGluYXRlLCB5Q29vcmRpbmF0ZSk7XG4gICAgfVxuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH0sXG4gIHRyaWFuZ2xlKHBhcmFtcykge1xuICAgIGRyYXdNYXJrZXJVbml0UG9seWdvbihwYXJhbXMsIFtcbiAgICAgIFswLjUsIDBdLFxuICAgICAgWzEsIDAuODddLFxuICAgICAgWzAsIDAuODddXG4gICAgXSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9tYXJrZXIudHNcbnZhciBJbnRlcm5hbE1hcmtlciA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zaGFwZSA9IFwic3F1YXJlXCI7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMuc2l6ZSA9IDEyO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyBwYXRoLCBzaGFwZSwgeCwgeSwgc2l6ZSB9ID0gdGhpcztcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gdGhpcy5sYXllck1hbmFnZXI/LmNhbnZhcz8ucGl4ZWxSYXRpbyA/PyAxO1xuICAgIGNvbnN0IGFuY2hvciA9IE1hcmtlci5hbmNob3Ioc2hhcGUpO1xuICAgIGNvbnN0IGRyYXdQYXJhbXMgPSB7XG4gICAgICBwYXRoLFxuICAgICAgeDogeCAtIChhbmNob3IueCAtIDAuNSkgKiBzaXplLFxuICAgICAgeTogeSAtIChhbmNob3IueSAtIDAuNSkgKiBzaXplLFxuICAgICAgc2l6ZSxcbiAgICAgIHBpeGVsUmF0aW9cbiAgICB9O1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBpZiAodHlwZW9mIHNoYXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBNQVJLRVJfU0hBUEVTW3NoYXBlXShkcmF3UGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzaGFwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBzaGFwZShkcmF3UGFyYW1zKTtcbiAgICB9XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgY29uc3QgeyB4LCB5LCBzaXplIH0gPSB0aGlzO1xuICAgIGNvbnN0IGFuY2hvciA9IE1hcmtlci5hbmNob3IodGhpcy5zaGFwZSk7XG4gICAgcmV0dXJuIG5ldyBCQm94KHggLSBzaXplICogYW5jaG9yLngsIHkgLSBzaXplICogYW5jaG9yLnksIHNpemUsIHNpemUpO1xuICB9XG4gIGV4ZWN1dGVGaWxsKGN0eCwgcGF0aCkge1xuICAgIGlmICghcGF0aClcbiAgICAgIHJldHVybjtcbiAgICByZXR1cm4gc3VwZXIuZXhlY3V0ZUZpbGwoY3R4LCBwYXRoKTtcbiAgfVxuICBleGVjdXRlU3Ryb2tlKGN0eCwgcGF0aCkge1xuICAgIGlmICghcGF0aClcbiAgICAgIHJldHVybjtcbiAgICByZXR1cm4gc3VwZXIuZXhlY3V0ZVN0cm9rZShjdHgsIHBhdGgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEludGVybmFsTWFya2VyLnByb3RvdHlwZSwgXCJzaGFwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBJbnRlcm5hbE1hcmtlci5wcm90b3R5cGUsIFwieFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBJbnRlcm5hbE1hcmtlci5wcm90b3R5cGUsIFwieVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbih7IGNvbnZlcnRvcjogTWF0aC5hYnMgfSlcbl0sIEludGVybmFsTWFya2VyLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xudmFyIE1hcmtlciA9IGNsYXNzIGV4dGVuZHMgUm90YXRhYmxlKFNjYWxhYmxlKFRyYW5zbGF0YWJsZShJbnRlcm5hbE1hcmtlcikpKSB7XG4gIHN0YXRpYyBhbmNob3Ioc2hhcGUpIHtcbiAgICBpZiAoc2hhcGUgPT09IFwicGluXCIpIHtcbiAgICAgIHJldHVybiB7IHg6IDAuNSwgeTogMSB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNoYXBlID09PSBcImZ1bmN0aW9uXCIgJiYgXCJhbmNob3JcIiBpbiBzaGFwZSkge1xuICAgICAgcmV0dXJuIHNoYXBlLmFuY2hvcjtcbiAgICB9XG4gICAgcmV0dXJuIHsgeDogMC41LCB5OiAwLjUgfTtcbiAgfVxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnM/LnNoYXBlICE9IG51bGwpIHtcbiAgICAgIHRoaXMuc2hhcGUgPSBvcHRpb25zLnNoYXBlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbGVnZW5kL2xlZ2VuZFN5bWJvbC50c1xuZnVuY3Rpb24gbGVnZW5kU3ltYm9sU3ZnKHN5bWJvbCwgc2l6ZSwgbGluZVNpemUgPSBzaXplICogKDUgLyAzKSkge1xuICBjb25zdCBncm91cCA9IG5ldyBHcm91cCgpO1xuICBjb25zdCBtYXJrZXJTdHJva2VXaWR0aCA9IE1hdGgubWluKHN5bWJvbC5tYXJrZXIuc3Ryb2tlV2lkdGgsIDIpO1xuICBjb25zdCBsaW5lU3Ryb2tlV2lkdGggPSBNYXRoLm1pbihzeW1ib2wubGluZT8uc3Ryb2tlV2lkdGggPz8gMCwgMik7XG4gIGNvbnN0IHdpZHRoMiA9IE1hdGgubWF4KHN5bWJvbC5tYXJrZXIuZW5hYmxlZCA9PT0gZmFsc2UgPyAwIDogc2l6ZSwgc3ltYm9sLmxpbmUgPT0gbnVsbCA/IDAgOiBsaW5lU2l6ZSk7XG4gIGNvbnN0IGhlaWdodDIgPSBNYXRoLm1heChzeW1ib2wubWFya2VyLmVuYWJsZWQgPT09IGZhbHNlID8gMCA6IHNpemUsIGxpbmVTdHJva2VXaWR0aCk7XG4gIGlmIChzeW1ib2wubGluZSAhPSBudWxsKSB7XG4gICAgY29uc3QgeyBzdHJva2U6IHN0cm9rZTIsIHN0cm9rZU9wYWNpdHksIGxpbmVEYXNoIH0gPSBzeW1ib2wubGluZTtcbiAgICBjb25zdCBsaW5lID0gbmV3IExpbmUoKTtcbiAgICBsaW5lLngxID0gMDtcbiAgICBsaW5lLnkxID0gaGVpZ2h0MiAvIDI7XG4gICAgbGluZS54MiA9IHdpZHRoMjtcbiAgICBsaW5lLnkyID0gaGVpZ2h0MiAvIDI7XG4gICAgbGluZS5zdHJva2UgPSBzdHJva2UyO1xuICAgIGxpbmUuc3Ryb2tlT3BhY2l0eSA9IHN0cm9rZU9wYWNpdHk7XG4gICAgbGluZS5zdHJva2VXaWR0aCA9IGxpbmVTdHJva2VXaWR0aDtcbiAgICBsaW5lLmxpbmVEYXNoID0gbGluZURhc2g7XG4gICAgZ3JvdXAuYXBwZW5kKGxpbmUpO1xuICB9XG4gIGlmIChzeW1ib2wubWFya2VyLmVuYWJsZWQgIT09IGZhbHNlKSB7XG4gICAgY29uc3QgeyBzaGFwZSwgZmlsbCwgZmlsbE9wYWNpdHksIHN0cm9rZTogc3Ryb2tlMiwgc3Ryb2tlT3BhY2l0eSwgbGluZURhc2gsIGxpbmVEYXNoT2Zmc2V0IH0gPSBzeW1ib2wubWFya2VyO1xuICAgIGNvbnN0IG1hcmtlciA9IG5ldyBNYXJrZXIoKTtcbiAgICBtYXJrZXIuc2hhcGUgPSBzaGFwZSA/PyBcInNxdWFyZVwiO1xuICAgIG1hcmtlci5zaXplID0gc2l6ZTtcbiAgICBtYXJrZXIuZmlsbCA9IGZpbGw7XG4gICAgbWFya2VyLmZpbGxPcGFjaXR5ID0gZmlsbE9wYWNpdHk7XG4gICAgbWFya2VyLnN0cm9rZSA9IHN0cm9rZTI7XG4gICAgbWFya2VyLnN0cm9rZU9wYWNpdHkgPSBzdHJva2VPcGFjaXR5O1xuICAgIG1hcmtlci5zdHJva2VXaWR0aCA9IG1hcmtlclN0cm9rZVdpZHRoO1xuICAgIG1hcmtlci5saW5lRGFzaCA9IGxpbmVEYXNoO1xuICAgIG1hcmtlci5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgIGNvbnN0IGFuY2hvciA9IE1hcmtlci5hbmNob3Ioc2hhcGUpO1xuICAgIGNvbnN0IHggPSB3aWR0aDIgLyAyICsgKGFuY2hvci54IC0gMC41KSAqIHNpemU7XG4gICAgY29uc3QgeSA9IGhlaWdodDIgLyAyICsgKGFuY2hvci55IC0gMC41KSAqIHNpemU7XG4gICAgY29uc3Qgc2NhbGUyID0gc2l6ZSAvIChzaXplICsgbWFya2VyU3Ryb2tlV2lkdGgpO1xuICAgIG1hcmtlci54ID0gMDtcbiAgICBtYXJrZXIueSA9IDA7XG4gICAgbWFya2VyLnRyYW5zbGF0aW9uWCA9IHg7XG4gICAgbWFya2VyLnRyYW5zbGF0aW9uWSA9IHk7XG4gICAgbWFya2VyLnNjYWxpbmdYID0gc2NhbGUyO1xuICAgIG1hcmtlci5zY2FsaW5nWSA9IHNjYWxlMjtcbiAgICBncm91cC5hcHBlbmQobWFya2VyKTtcbiAgfVxuICByZXR1cm4gR3JvdXAudG9TVkcoZ3JvdXAsIHdpZHRoMiwgaGVpZ2h0Mik7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Rvb2x0aXAvc3ByaW5nQW5pbWF0aW9uLnRzXG52YXIgTSA9IDAuMTtcbnZhciBLID0gMjAwO1xudmFyIEMgPSAxMjtcbnZhciBERUxUQSA9IDAuNTtcbnZhciBTcHJpbmdBbmltYXRpb24gPSBjbGFzcyBleHRlbmRzIExpc3RlbmVycyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy54MSA9IE5hTjtcbiAgICB0aGlzLnkxID0gTmFOO1xuICAgIHRoaXMueCA9IE5hTjtcbiAgICB0aGlzLnkgPSBOYU47XG4gICAgdGhpcy52eCA9IDA7XG4gICAgdGhpcy52eSA9IDA7XG4gICAgdGhpcy50MCA9IE5hTjtcbiAgICB0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlID0gdm9pZCAwO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMueCA9IE5hTjtcbiAgICB0aGlzLnkgPSBOYU47XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uRnJhbWVIYW5kbGUgIT0gbnVsbCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZUhhbmRsZSk7XG4gICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICB1cGRhdGUoeCwgeSkge1xuICAgIGlmIChOdW1iZXIuaXNOYU4odGhpcy54KSB8fCBOdW1iZXIuaXNOYU4odGhpcy55KSkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICB0aGlzLnZ4ID0gMDtcbiAgICAgIHRoaXMudnkgPSAwO1xuICAgICAgdGhpcy5lbWl0VXBkYXRlKCk7XG4gICAgICBpZiAodGhpcy5hbmltYXRpb25GcmFtZUhhbmRsZSAhPSBudWxsKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVIYW5kbGUpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLngxID0geDtcbiAgICB0aGlzLnkxID0geTtcbiAgICB0aGlzLnQwID0gRGF0ZS5ub3coKTtcbiAgICBpZiAodGhpcy5hbmltYXRpb25GcmFtZUhhbmRsZSA9PSBudWxsKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMub25GcmFtZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH1cbiAgb25GcmFtZSgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlID0gdm9pZCAwO1xuICAgIGNvbnN0IHsgeDEsIHkxLCB0MCB9ID0gdGhpcztcbiAgICBjb25zdCB0MSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZHQgPSB0MSAtIHQwO1xuICAgIHRoaXMudDAgPSB0MTtcbiAgICBjb25zdCBzdGVwVCA9IDFlLTM7XG4gICAgY29uc3QgaXRlcmF0aW9ucyA9IE1hdGguY2VpbChkdCAvIChzdGVwVCAqIDFlMykpIHwgMDtcbiAgICBsZXQgeyB4LCB5LCB2eCwgdnkgfSA9IHRoaXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGR4ID0geCAtIHgxO1xuICAgICAgY29uc3QgZHkgPSB5IC0geTE7XG4gICAgICBjb25zdCBheCA9IC0oSyAqIGR4ICsgQyAqIHZ4KSAvIE07XG4gICAgICBjb25zdCBheSA9IC0oSyAqIGR5ICsgQyAqIHZ5KSAvIE07XG4gICAgICB2eCArPSBheCAqIHN0ZXBUO1xuICAgICAgdnkgKz0gYXkgKiBzdGVwVDtcbiAgICAgIHggKz0gdnggKiBzdGVwVDtcbiAgICAgIHkgKz0gdnkgKiBzdGVwVDtcbiAgICB9XG4gICAgaWYgKE1hdGguaHlwb3QoeCAtIHgxLCB5IC0geTEpIDwgREVMVEEpIHtcbiAgICAgIHRoaXMueCA9IHRoaXMueDE7XG4gICAgICB0aGlzLnkgPSB0aGlzLnkxO1xuICAgICAgdGhpcy52eCA9IDA7XG4gICAgICB0aGlzLnZ5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICB0aGlzLnZ4ID0gdng7XG4gICAgICB0aGlzLnZ5ID0gdnk7XG4gICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMub25GcmFtZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0VXBkYXRlKCk7XG4gIH1cbiAgZW1pdFVwZGF0ZSgpIHtcbiAgICB0aGlzLmRpc3BhdGNoKFwidXBkYXRlXCIsIHsgdHlwZTogXCJ1cGRhdGVcIiwgeDogdGhpcy54LCB5OiB0aGlzLnkgfSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Rvb2x0aXAvdG9vbHRpcC50c1xudmFyIERFRkFVTFRfVE9PTFRJUF9DTEFTUyA9IFwiYWctY2hhcnRzLXRvb2x0aXBcIjtcbnZhciBERUZBVUxUX1RPT0xUSVBfREFSS19DTEFTUyA9IFwiYWctY2hhcnRzLXRvb2x0aXAtLWRhcmtcIjtcbmZ1bmN0aW9uIHRvb2x0aXBDb250ZW50QXJpYUxhYmVsKGNvbnRlbnQpIHtcbiAgY29uc3QgYXJpYUxhYmVsID0gW107XG4gIGlmIChjb250ZW50LnR5cGUgPT09IFwicmF3XCIpXG4gICAgcmV0dXJuIFwiXCI7XG4gIGlmIChjb250ZW50LmhlYWRpbmcgIT0gbnVsbClcbiAgICBhcmlhTGFiZWwucHVzaChjb250ZW50LmhlYWRpbmcpO1xuICBpZiAoY29udGVudC50aXRsZSAhPSBudWxsKVxuICAgIGFyaWFMYWJlbC5wdXNoKGNvbnRlbnQudGl0bGUpO1xuICBjb250ZW50LmRhdGE/LmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgYXJpYUxhYmVsLnB1c2goZGF0dW0ubGFiZWwgPz8gZGF0dW0uZmFsbGJhY2tMYWJlbCwgZGF0dW0udmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIGFyaWFMYWJlbC5qb2luKFwiOyBcIik7XG59XG5mdW5jdGlvbiBkYXRhSHRtbChsYWJlbCwgdmFsdWUsIGlubGluZSkge1xuICBsZXQgcm93SHRtbCA9IFwiXCI7XG4gIGlmIChsYWJlbCA9PSBudWxsKSB7XG4gICAgcm93SHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke0RFRkFVTFRfVE9PTFRJUF9DTEFTU30tbGFiZWxcIj4ke3Nhbml0aXplSHRtbCh2YWx1ZSl9PC9zcGFuPmA7XG4gIH0gZWxzZSB7XG4gICAgcm93SHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke0RFRkFVTFRfVE9PTFRJUF9DTEFTU30tbGFiZWxcIj4ke3Nhbml0aXplSHRtbChsYWJlbCl9PC9zcGFuPmA7XG4gICAgcm93SHRtbCArPSBcIiBcIjtcbiAgICByb3dIdG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7REVGQVVMVF9UT09MVElQX0NMQVNTfS12YWx1ZVwiPiR7c2FuaXRpemVIdG1sKHZhbHVlKX08L3NwYW4+YDtcbiAgfVxuICBjb25zdCByb3dDbGFzc05hbWVzID0gW2Ake0RFRkFVTFRfVE9PTFRJUF9DTEFTU30tcm93YF07XG4gIGlmIChpbmxpbmUpXG4gICAgcm93Q2xhc3NOYW1lcy5wdXNoKGAke0RFRkFVTFRfVE9PTFRJUF9DTEFTU30tcm93LS1pbmxpbmVgKTtcbiAgcm93SHRtbCA9IGA8ZGl2IGNsYXNzPVwiJHtyb3dDbGFzc05hbWVzLmpvaW4oXCIgXCIpfVwiPiR7cm93SHRtbH08L2Rpdj5gO1xuICByZXR1cm4gcm93SHRtbDtcbn1cbmZ1bmN0aW9uIHRvb2x0aXBDb250ZW50SHRtbChjb250ZW50KSB7XG4gIGlmIChjb250ZW50LnR5cGUgPT09IFwicmF3XCIpXG4gICAgcmV0dXJuIGNvbnRlbnQucmF3SHRtbFN0cmluZztcbiAgbGV0IGh0bWwgPSBcIlwiO1xuICBpZiAoKGNvbnRlbnQuaGVhZGluZyA9PSBudWxsIHx8IGNvbnRlbnQudGl0bGUgPT0gbnVsbCkgJiYgY29udGVudC5kYXRhPy5sZW5ndGggPT09IDEgJiYgY29udGVudC5kYXRhWzBdLmxhYmVsID09IG51bGwgJiYgY29udGVudC5kYXRhWzBdLnZhbHVlICE9IG51bGwpIHtcbiAgICBjb25zdCBkYXR1bSA9IGNvbnRlbnQuZGF0YVswXTtcbiAgICBodG1sICs9IGRhdGFIdG1sKGNvbnRlbnQuaGVhZGluZyA/PyBjb250ZW50LnRpdGxlLCBkYXR1bS52YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRhdGFJbmxpbmUgPSBjb250ZW50LnRpdGxlID09IG51bGwgJiYgY29udGVudC5kYXRhPy5sZW5ndGggPT09IDE7XG4gICAgaWYgKGNvbnRlbnQuaGVhZGluZyAhPSBudWxsKSB7XG4gICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7REVGQVVMVF9UT09MVElQX0NMQVNTfS1oZWFkaW5nXCI+JHtzYW5pdGl6ZUh0bWwoY29udGVudC5oZWFkaW5nKX08L3NwYW4+YDtcbiAgICAgIGh0bWwgKz0gXCIgXCI7XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbCA9IGNvbnRlbnQuc3ltYm9sID09IG51bGwgPyB2b2lkIDAgOiBsZWdlbmRTeW1ib2xTdmcoY29udGVudC5zeW1ib2wsIDEyKTtcbiAgICBpZiAoc3ltYm9sICE9IG51bGwgJiYgKGNvbnRlbnQudGl0bGUgIT0gbnVsbCB8fCBjb250ZW50LmRhdGE/Lmxlbmd0aCkpIHtcbiAgICAgIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtERUZBVUxUX1RPT0xUSVBfQ0xBU1N9LXN5bWJvbFwiPiR7c3ltYm9sfTwvc3Bhbj5gO1xuICAgIH1cbiAgICBpZiAoY29udGVudC50aXRsZSAhPSBudWxsKSB7XG4gICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7REVGQVVMVF9UT09MVElQX0NMQVNTfS10aXRsZVwiPiR7c2FuaXRpemVIdG1sKGNvbnRlbnQudGl0bGUpfTwvc3Bhbj5gO1xuICAgICAgaHRtbCArPSBcIiBcIjtcbiAgICB9XG4gICAgY29udGVudC5kYXRhPy5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgaHRtbCArPSBkYXRhSHRtbChkYXR1bS5sYWJlbCA/PyBkYXR1bS5mYWxsYmFja0xhYmVsLCBkYXR1bS52YWx1ZSwgZGF0YUlubGluZSk7XG4gICAgICBodG1sICs9IFwiIFwiO1xuICAgIH0pO1xuICB9XG4gIGh0bWwgPSBgPGRpdiBjbGFzcz1cIiR7REVGQVVMVF9UT09MVElQX0NMQVNTfS1jb250ZW50XCI+JHtodG1sLnRyaW1FbmQoKX08L2Rpdj5gO1xuICByZXR1cm4gaHRtbDtcbn1cbnZhciBUb29sdGlwUG9zaXRpb24gPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKiogVGhlIHR5cGUgb2YgcG9zaXRpb25pbmcgZm9yIHRoZSB0b29sdGlwLiBCeSBkZWZhdWx0LCB0aGUgdG9vbHRpcCBmb2xsb3dzIHRoZSBwb2ludGVyLiAqL1xuICAgIHRoaXMudHlwZSA9IFwicG9pbnRlclwiO1xuICAgIC8qKiBUaGUgaG9yaXpvbnRhbCBvZmZzZXQgaW4gcGl4ZWxzIGZvciB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXAuICovXG4gICAgdGhpcy54T2Zmc2V0ID0gMDtcbiAgICAvKiogVGhlIHZlcnRpY2FsIG9mZnNldCBpbiBwaXhlbHMgZm9yIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcC4gKi9cbiAgICB0aGlzLnlPZmZzZXQgPSAwO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoXG4gICAgVU5JT04oXG4gICAgICBbXG4gICAgICAgIFwicG9pbnRlclwiLFxuICAgICAgICBcIm5vZGVcIixcbiAgICAgICAgXCJ0b3BcIixcbiAgICAgICAgXCJyaWdodFwiLFxuICAgICAgICBcImJvdHRvbVwiLFxuICAgICAgICBcImxlZnRcIixcbiAgICAgICAgXCJ0b3AtbGVmdFwiLFxuICAgICAgICBcInRvcC1yaWdodFwiLFxuICAgICAgICBcImJvdHRvbS1yaWdodFwiLFxuICAgICAgICBcImJvdHRvbS1sZWZ0XCIsXG4gICAgICAgIHsgdmFsdWU6IFwic3BhcmtsaW5lXCIsIHVuZG9jdW1lbnRlZDogdHJ1ZSB9LFxuICAgICAgICB7IHZhbHVlOiBcInNwYXJrbGluZS1cIiwgdW5kb2N1bWVudGVkOiB0cnVlIH1cbiAgICAgIF0sXG4gICAgICBcImEgcG9zaXRpb24gdHlwZVwiXG4gICAgKVxuICApXG5dLCBUb29sdGlwUG9zaXRpb24ucHJvdG90eXBlLCBcInR5cGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBUb29sdGlwUG9zaXRpb24ucHJvdG90eXBlLCBcInhPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBUb29sdGlwUG9zaXRpb24ucHJvdG90eXBlLCBcInlPZmZzZXRcIiwgMik7XG52YXIgVG9vbHRpcCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5kZWxheSA9IDA7XG4gICAgdGhpcy5yYW5nZSA9IHZvaWQgMDtcbiAgICB0aGlzLndyYXBwaW5nID0gXCJoeXBoZW5hdGVcIjtcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFRvb2x0aXBQb3NpdGlvbigpO1xuICAgIHRoaXMuZGFya1RoZW1lID0gZmFsc2U7XG4gICAgdGhpcy5ib3VuZHMgPSBcImV4dGVuZGVkXCI7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5zcHJpbmdBbmltYXRpb24gPSBuZXcgU3ByaW5nQW5pbWF0aW9uKCk7XG4gICAgdGhpcy5lbmFibGVJbnRlcmFjdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMud3JhcFR5cGVzID0gW1wiYWx3YXlzXCIsIFwiaHlwaGVuYXRlXCIsIFwib24tc3BhY2VcIiwgXCJuZXZlclwiXTtcbiAgICB0aGlzLnNob3dUaW1lb3V0ID0gMDtcbiAgICB0aGlzLl9zaG93QXJyb3cgPSB0cnVlO1xuICAgIHRoaXMuX2NvbXBhY3QgPSBmYWxzZTtcbiAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5wb3NpdGlvblBhcmFtcyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaCh0aGlzLnNwcmluZ0FuaW1hdGlvbi5hZGRMaXN0ZW5lcihcInVwZGF0ZVwiLCB0aGlzLnVwZGF0ZVRvb2x0aXBQb3NpdGlvbi5iaW5kKHRoaXMpKSk7XG4gIH1cbiAgZ2V0IGludGVyYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZUludGVyYWN0aW9uO1xuICB9XG4gIHNldHVwKGRvbU1hbmFnZXIpIHtcbiAgICBpZiAoXCJ0b2dnbGVQb3BvdmVyXCIgaW4gZ2V0V2luZG93KCkuSFRNTEVsZW1lbnQucHJvdG90eXBlKSB7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBkb21NYW5hZ2VyLmFkZENoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgREVGQVVMVF9UT09MVElQX0NMQVNTKTtcbiAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJwb3BvdmVyXCIsIFwibWFudWFsXCIpO1xuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IERFRkFVTFRfVE9PTFRJUF9DTEFTUztcbiAgICB9XG4gIH1cbiAgZGVzdHJveShkb21NYW5hZ2VyKSB7XG4gICAgZG9tTWFuYWdlci5yZW1vdmVDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIERFRkFVTFRfVE9PTFRJUF9DTEFTUyk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGYpID0+IGYoKSk7XG4gIH1cbiAgaXNWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG4gIGNvbnRhaW5zKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50Py5jb250YWlucyhub2RlKSA/PyBmYWxzZTtcbiAgfVxuICB1cGRhdGVUb29sdGlwUG9zaXRpb24oKSB7XG4gICAgY29uc3QgeyBlbGVtZW50OiBlbGVtZW50MiwgcG9zaXRpb25QYXJhbXMgfSA9IHRoaXM7XG4gICAgaWYgKGVsZW1lbnQyID09IG51bGwgfHwgcG9zaXRpb25QYXJhbXMgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGNhbnZhc1JlY3QsIHJlbGF0aXZlUmVjdCwgbWV0YSB9ID0gcG9zaXRpb25QYXJhbXM7XG4gICAgY29uc3QgeyB4OiBjYW52YXNYLCB5OiBjYW52YXNZIH0gPSB0aGlzLnNwcmluZ0FuaW1hdGlvbjtcbiAgICBjb25zdCBwb3NpdGlvblR5cGUgPSBtZXRhLnBvc2l0aW9uPy50eXBlID8/IHRoaXMucG9zaXRpb24udHlwZTtcbiAgICBjb25zdCB4T2Zmc2V0ID0gbWV0YS5wb3NpdGlvbj8ueE9mZnNldCA/PyAwO1xuICAgIGNvbnN0IHlPZmZzZXQgPSBtZXRhLnBvc2l0aW9uPy55T2Zmc2V0ID8/IDA7XG4gICAgY29uc3QgbWluWCA9IHJlbGF0aXZlUmVjdC54O1xuICAgIGNvbnN0IG1pblkgPSByZWxhdGl2ZVJlY3QueTtcbiAgICBjb25zdCBtYXhYID0gcmVsYXRpdmVSZWN0LndpZHRoIC0gZWxlbWVudDIuY2xpZW50V2lkdGggLSAxICsgbWluWDtcbiAgICBjb25zdCBtYXhZID0gcmVsYXRpdmVSZWN0LmhlaWdodCAtIGVsZW1lbnQyLmNsaWVudEhlaWdodCArIG1pblk7XG4gICAgbGV0IHRvb2x0aXBCb3VuZHMgPSB0aGlzLmdldFRvb2x0aXBCb3VuZHMoeyBwb3NpdGlvblR5cGUsIGNhbnZhc1gsIGNhbnZhc1ksIHlPZmZzZXQsIHhPZmZzZXQsIGNhbnZhc1JlY3QgfSk7XG4gICAgbGV0IHBvc2l0aW9uID0gY2FsY3VsYXRlUGxhY2VtZW50KGVsZW1lbnQyLmNsaWVudFdpZHRoLCBlbGVtZW50Mi5jbGllbnRIZWlnaHQsIHJlbGF0aXZlUmVjdCwgdG9vbHRpcEJvdW5kcyk7XG4gICAgaWYgKHBvc2l0aW9uVHlwZSA9PT0gXCJzcGFya2xpbmVcIiAmJiAocG9zaXRpb24ueCA8PSBtaW5YIHx8IHBvc2l0aW9uLnggPj0gbWF4WCkpIHtcbiAgICAgIHRvb2x0aXBCb3VuZHMgPSB0aGlzLmdldFRvb2x0aXBCb3VuZHMoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwic3BhcmtsaW5lLWNvbnN0cmFpbmVkXCIsXG4gICAgICAgIGNhbnZhc1gsXG4gICAgICAgIGNhbnZhc1ksXG4gICAgICAgIHlPZmZzZXQsXG4gICAgICAgIHhPZmZzZXQsXG4gICAgICAgIGNhbnZhc1JlY3RcbiAgICAgIH0pO1xuICAgICAgcG9zaXRpb24gPSBjYWxjdWxhdGVQbGFjZW1lbnQoZWxlbWVudDIuY2xpZW50V2lkdGgsIGVsZW1lbnQyLmNsaWVudEhlaWdodCwgcmVsYXRpdmVSZWN0LCB0b29sdGlwQm91bmRzKTtcbiAgICB9XG4gICAgY29uc3QgbGVmdCA9IGNsYW1wKG1pblgsIHBvc2l0aW9uLngsIG1heFgpO1xuICAgIGNvbnN0IHRvcCA9IGNsYW1wKG1pblksIHBvc2l0aW9uLnksIG1heFkpO1xuICAgIGNvbnN0IGNvbnN0cmFpbmVkID0gbGVmdCAhPT0gcG9zaXRpb24ueCB8fCB0b3AgIT09IHBvc2l0aW9uLnk7XG4gICAgY29uc3QgZGVmYXVsdFNob3dBcnJvdyA9IChwb3NpdGlvblR5cGUgPT09IFwibm9kZVwiIHx8IHBvc2l0aW9uVHlwZSA9PT0gXCJwb2ludGVyXCIpICYmICFjb25zdHJhaW5lZCAmJiAheE9mZnNldCAmJiAheU9mZnNldDtcbiAgICBjb25zdCBzaG93QXJyb3cgPSBtZXRhLnNob3dBcnJvdyA/PyB0aGlzLnNob3dBcnJvdyA/PyBkZWZhdWx0U2hvd0Fycm93O1xuICAgIHRoaXMudXBkYXRlU2hvd0Fycm93KHNob3dBcnJvdyk7XG4gICAgdGhpcy51cGRhdGVDb21wYWN0KHBvc2l0aW9uVHlwZSA9PT0gXCJzcGFya2xpbmVcIiB8fCBwb3NpdGlvblR5cGUgPT09IFwic3BhcmtsaW5lLWNvbnN0cmFpbmVkXCIpO1xuICAgIGVsZW1lbnQyLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtsZWZ0fXB4LCAke3RvcH1weClgO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB0b29sdGlwIGF0IHRoZSBnaXZlbiBldmVudCdzIGNvb3JkaW5hdGVzLlxuICAgKiBJZiB0aGUgYGh0bWxgIHBhcmFtZXRlciBpcyBtaXNzaW5nLCBtb3ZlcyB0aGUgZXhpc3RpbmcgdG9vbHRpcCB0byB0aGUgbmV3IHBvc2l0aW9uLlxuICAgKi9cbiAgc2hvdyhib3VuZGluZ1JlY3QsIGNhbnZhc1JlY3QsIG1ldGEsIGNvbnRlbnQsIGluc3RhbnRseSA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyBlbGVtZW50OiBlbGVtZW50MiB9ID0gdGhpcztcbiAgICBpZiAoZWxlbWVudDIgIT0gbnVsbCAmJiBjb250ZW50ICE9IG51bGwpIHtcbiAgICAgIGVsZW1lbnQyLmlubmVySFRNTCA9IHRvb2x0aXBDb250ZW50SHRtbChjb250ZW50KTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQyID09IG51bGwgfHwgZWxlbWVudDIuaW5uZXJIVE1MID09PSBcIlwiKSB7XG4gICAgICB0aGlzLnRvZ2dsZShmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbGF0aXZlUmVjdCA9IHtcbiAgICAgIHg6IGJvdW5kaW5nUmVjdC54IC0gY2FudmFzUmVjdC54LFxuICAgICAgeTogYm91bmRpbmdSZWN0LnkgLSBjYW52YXNSZWN0LnksXG4gICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGluZ1JlY3QuaGVpZ2h0XG4gICAgfTtcbiAgICB0aGlzLnBvc2l0aW9uUGFyYW1zID0ge1xuICAgICAgY2FudmFzUmVjdCxcbiAgICAgIHJlbGF0aXZlUmVjdCxcbiAgICAgIG1ldGFcbiAgICB9O1xuICAgIHRoaXMuc3ByaW5nQW5pbWF0aW9uLnVwZGF0ZShtZXRhLmNhbnZhc1gsIG1ldGEuY2FudmFzWSk7XG4gICAgZWxlbWVudDIuc3R5bGUudG9wID0gYCR7Y2FudmFzUmVjdC50b3B9cHhgO1xuICAgIGVsZW1lbnQyLnN0eWxlLmxlZnQgPSBgJHtjYW52YXNSZWN0LmxlZnR9cHhgO1xuICAgIGlmIChtZXRhLmVuYWJsZUludGVyYWN0aW9uKSB7XG4gICAgICB0aGlzLmVuYWJsZUludGVyYWN0aW9uID0gdHJ1ZTtcbiAgICAgIGVsZW1lbnQyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICAgIGVsZW1lbnQyLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuYWJsZUludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgICBlbGVtZW50Mi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICBlbGVtZW50Mi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGF5ID4gMCAmJiAhaW5zdGFudGx5KSB7XG4gICAgICB0aGlzLnRvZ2dsZShmYWxzZSk7XG4gICAgICB0aGlzLnNob3dUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMudG9nZ2xlKHRydWUpO1xuICAgICAgfSwgdGhpcy5kZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9nZ2xlKHRydWUpO1xuICAgIH1cbiAgfVxuICBoaWRlKCkge1xuICAgIHRoaXMuc3ByaW5nQW5pbWF0aW9uLnJlc2V0KCk7XG4gICAgdGhpcy50b2dnbGUoZmFsc2UpO1xuICB9XG4gIHRvZ2dsZSh2aXNpYmxlKSB7XG4gICAgaWYgKCF0aGlzLmVsZW1lbnQ/LmlzQ29ubmVjdGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlO1xuICAgIGNvbnN0IHsgY2xhc3NMaXN0IH0gPSB0aGlzLmVsZW1lbnQ7XG4gICAgY29uc3QgdG9nZ2xlQ2xhc3MgPSAobmFtZSwgaW5jbHVkZSkgPT4gY2xhc3NMaXN0LnRvZ2dsZShgJHtERUZBVUxUX1RPT0xUSVBfQ0xBU1N9LS0ke25hbWV9YCwgaW5jbHVkZSk7XG4gICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5zaG93VGltZW91dCk7XG4gICAgfVxuICAgIHRvZ2dsZUNsYXNzKFwibm8taW50ZXJhY3Rpb25cIiwgIXRoaXMuZW5hYmxlSW50ZXJhY3Rpb24pO1xuICAgIHRvZ2dsZUNsYXNzKFwiYXJyb3dcIiwgdGhpcy5fc2hvd0Fycm93KTtcbiAgICB0b2dnbGVDbGFzcyhcImNvbXBhY3RcIiwgdGhpcy5fY29tcGFjdCk7XG4gICAgY2xhc3NMaXN0LnRvZ2dsZShERUZBVUxUX1RPT0xUSVBfREFSS19DTEFTUywgdGhpcy5kYXJrVGhlbWUpO1xuICAgIHRoaXMuZWxlbWVudC50b2dnbGVQb3BvdmVyKHZpc2libGUpO1xuICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBQb3NpdGlvbigpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHdyYXBUeXBlIG9mIHRoaXMud3JhcFR5cGVzKSB7XG4gICAgICBjbGFzc0xpc3QudG9nZ2xlKGAke0RFRkFVTFRfVE9PTFRJUF9DTEFTU30tLXdyYXAtJHt3cmFwVHlwZX1gLCB3cmFwVHlwZSA9PT0gdGhpcy53cmFwcGluZyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVNob3dBcnJvdyhzaG93KSB7XG4gICAgdGhpcy5fc2hvd0Fycm93ID0gc2hvdztcbiAgfVxuICB1cGRhdGVDb21wYWN0KGNvbXBhY3QpIHtcbiAgICB0aGlzLl9jb21wYWN0ID0gY29tcGFjdDtcbiAgfVxuICBnZXRUb29sdGlwQm91bmRzKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuZWxlbWVudClcbiAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB7IHBvc2l0aW9uVHlwZSwgY2FudmFzWCwgY2FudmFzWSwgeU9mZnNldCwgeE9mZnNldCwgY2FudmFzUmVjdCB9ID0gb3B0cztcbiAgICBjb25zdCB7IGNsaWVudFdpZHRoOiB0b29sdGlwV2lkdGgsIGNsaWVudEhlaWdodDogdG9vbHRpcEhlaWdodCB9ID0gdGhpcy5lbGVtZW50O1xuICAgIGNvbnN0IGJvdW5kcyA9IHsgd2lkdGg6IHRvb2x0aXBXaWR0aCwgaGVpZ2h0OiB0b29sdGlwSGVpZ2h0IH07XG4gICAgc3dpdGNoIChwb3NpdGlvblR5cGUpIHtcbiAgICAgIGNhc2UgXCJub2RlXCI6XG4gICAgICBjYXNlIFwicG9pbnRlclwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSBjYW52YXNZICsgeU9mZnNldCAtIHRvb2x0aXBIZWlnaHQgLSA4O1xuICAgICAgICBib3VuZHMubGVmdCA9IGNhbnZhc1ggKyB4T2Zmc2V0IC0gdG9vbHRpcFdpZHRoIC8gMjtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b3BcIjoge1xuICAgICAgICBib3VuZHMudG9wID0geU9mZnNldDtcbiAgICAgICAgYm91bmRzLmxlZnQgPSBjYW52YXNSZWN0LndpZHRoIC8gMiAtIHRvb2x0aXBXaWR0aCAvIDIgKyB4T2Zmc2V0O1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcInJpZ2h0XCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IGNhbnZhc1JlY3QuaGVpZ2h0IC8gMiAtIHRvb2x0aXBIZWlnaHQgLyAyICsgeU9mZnNldDtcbiAgICAgICAgYm91bmRzLmxlZnQgPSBjYW52YXNSZWN0LndpZHRoIC0gdG9vbHRpcFdpZHRoIC8gMiArIHhPZmZzZXQ7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgICBjYXNlIFwibGVmdFwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSBjYW52YXNSZWN0LmhlaWdodCAvIDIgLSB0b29sdGlwSGVpZ2h0IC8gMiArIHlPZmZzZXQ7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0geE9mZnNldDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJib3R0b21cIjoge1xuICAgICAgICBib3VuZHMudG9wID0gY2FudmFzUmVjdC5oZWlnaHQgLSB0b29sdGlwSGVpZ2h0ICsgeU9mZnNldDtcbiAgICAgICAgYm91bmRzLmxlZnQgPSBjYW52YXNSZWN0LndpZHRoIC8gMiAtIHRvb2x0aXBXaWR0aCAvIDIgKyB4T2Zmc2V0O1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvcC1sZWZ0XCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IHlPZmZzZXQ7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0geE9mZnNldDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b3AtcmlnaHRcIjoge1xuICAgICAgICBib3VuZHMudG9wID0geU9mZnNldDtcbiAgICAgICAgYm91bmRzLmxlZnQgPSBjYW52YXNSZWN0LndpZHRoIC0gdG9vbHRpcFdpZHRoICsgeE9mZnNldDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJib3R0b20tcmlnaHRcIjoge1xuICAgICAgICBib3VuZHMudG9wID0gY2FudmFzUmVjdC5oZWlnaHQgLSB0b29sdGlwSGVpZ2h0ICsgeU9mZnNldDtcbiAgICAgICAgYm91bmRzLmxlZnQgPSBjYW52YXNSZWN0LndpZHRoIC0gdG9vbHRpcFdpZHRoICsgeE9mZnNldDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJib3R0b20tbGVmdFwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSBjYW52YXNSZWN0LmhlaWdodCAtIHRvb2x0aXBIZWlnaHQgKyB5T2Zmc2V0O1xuICAgICAgICBib3VuZHMubGVmdCA9IHhPZmZzZXQ7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgICBjYXNlIFwic3BhcmtsaW5lXCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IGNhbnZhc1kgKyB5T2Zmc2V0IC0gdG9vbHRpcEhlaWdodCAvIDI7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0gY2FudmFzWCArIHhPZmZzZXQgKyA4O1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcInNwYXJrbGluZS1jb25zdHJhaW5lZFwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSBjYW52YXNZICsgeU9mZnNldCAtIHRvb2x0aXBIZWlnaHQgLyAyO1xuICAgICAgICBib3VuZHMubGVmdCA9IGNhbnZhc1ggKyB4T2Zmc2V0IC0gOCAtIHRvb2x0aXBXaWR0aDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcInNob3dBcnJvd1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcImRlbGF5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoSU5URVJBQ1RJT05fUkFOR0UsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcInJhbmdlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVEVYVF9XUkFQKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwid3JhcHBpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJkYXJrVGhlbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShVTklPTihbXCJleHRlbmRlZFwiLCBcImNhbnZhc1wiXSkpXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJib3VuZHNcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNBcmVhTWFuYWdlci50c1xudmFyIFNlcmllc0FyZWFNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMuc2VyaWVzID0gW107XG4gICAgdGhpcy5oaWdobGlnaHQgPSB7XG4gICAgICAvKiogTGFzdCByZWNlaXZlZCBldmVudCB0aGF0IHN0aWxsIG5lZWRzIHRvIGJlIGFwcGxpZWQuICovXG4gICAgICBwZW5kaW5nSG92ZXJFdmVudDogdm9pZCAwLFxuICAgICAgLyoqIExhc3QgYXBwbGllZCBldmVudC4gKi9cbiAgICAgIGFwcGxpZWRIb3ZlckV2ZW50OiB2b2lkIDAsXG4gICAgICAvKiogTGFzdCBhcHBsaWVkIGV2ZW50LCB3aGljaCBoYXMgYmVlbiB0ZW1wb3JhcmlseSBzdGFzaGVkIGR1cmluZyB0aGUgbWFpbiBjaGFydCB1cGRhdGUgY3ljbGUuICovXG4gICAgICBzdGFzaGVkSG92ZXJFdmVudDogdm9pZCAwXG4gICAgfTtcbiAgICB0aGlzLnRvb2x0aXAgPSB7XG4gICAgICBsYXN0SG92ZXI6IHZvaWQgMFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQTExeSBSZXF1aXJlbWVudHMgZm9yIFRvb2x0aXAvSGlnaGxpZ2h0IChzZWUgQUctMTMwNTEgZm9yIGRldGFpbHMpOlxuICAgICAqXG4gICAgICogICAtICAgV2hlbiB0aGUgc2VyaWVzLWFyZWEgaXMgYmx1cnJlZCwgYWx3YXlzIHRoZSBtb3VzZSB0byB1cGRhdGUgdGhlIHRvb2x0aXAvaGlnaGxpZ2h0LlxuICAgICAqXG4gICAgICogICAtICAgV2hlbiB0aGUgc2VyaWVzLWFyZWEgcmVjZWl2ZXMgYSBgZm9jdXNgIGV2ZW50LCB1c2UgYDpmb2N1cy12aXNpYmxlYCB0byBndWVzcyB0aGUgaW5wdXQgZGV2aWNlLlxuICAgICAqICAgICAgICh0aGlzIGlzIGRlY2lkZWQgYnkgdGhlIGJyb3dzZXIpLlxuICAgICAqXG4gICAgICogICAtICAgRm9yIGtleWJvYXJkIHVzZXJzLCBgZm9jdXNgIGFuZCBga2V5ZG93bmAgZXZlbnRzIGFsd2F5cyB1cGRhdGVzICYgc2hvd3MgdGhlIHRvb2x0aXAvaGlnaGxpZ2h0IG9uXG4gICAgICogICAgICAgdGhlIGN1cnJlbnRseSAob3IgbmV3bHkpIGZvY3VzZWQgZGF0dW0uXG4gICAgICpcbiAgICAgKiAgIC0gICBGb3Iga2V5Ym9hcmQgdXNlcnMsIGBtb3VzZW1vdmVgIGV2ZW50cyB1cGRhdGUgdGhlIHRvb2x0aXAvaGlnaGxpZ2h0IGlmZiBgcGlja05vZGVgIGZpbmRzIGEgbWF0Y2hcbiAgICAgKiAgICAgICBmb3IgdGhlIG1vdXNlIGV2ZW50IG9mZnNldHMuXG4gICAgICovXG4gICAgdGhpcy5ob3ZlckRldmljZSA9IFwicG9pbnRlclwiO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIFwic2Vjb25kIGxhc3RcIiBpbnB1dCBldmVudC4gSXQgY2FuIGJlIHVzZWZ1bCBmb3Iga2V5ZG93blxuICAgICAqIGV2ZW50cyB0aGF0IGZvciB3aGljaCBkb24ndCB0byBzZXQgdGhlIGlzRm9jdXNWaXNpYmxlIHN0YXRlXG4gICAgICogKGUuZy4gQmFja3NwYWNlL0RlbGV0ZSBrZXkgb24gRkMgYW5ub3RhdGlvbnMsIHNlZSBBRy0xMzA0MSkuXG4gICAgICpcbiAgICAgKiBVc2Ugd2l0aCBjYXV0aW9uISBUaGUgZm9jdXMgaW5kaWNhdG9yIG11c3QgQUxXQVlTIGJlIHZpc2libGUgZm9yXG4gICAgICoga2V5Ym9hcmQtb25seSB1c2Vycy5cbiAgICAgKi9cbiAgICB0aGlzLnByZXZpb3VzSW5wdXREZXZpY2UgPSBcImtleWJvYXJkXCI7XG4gICAgdGhpcy5mb2N1cyA9IHtcbiAgICAgIHNvcnRlZFNlcmllczogW10sXG4gICAgICBzZXJpZXM6IHZvaWQgMCxcbiAgICAgIHNlcmllc0luZGV4OiAwLFxuICAgICAgZGF0dW1JbmRleDogMCxcbiAgICAgIGRhdHVtOiB2b2lkIDBcbiAgICB9O1xuICAgIHRoaXMuaG92ZXJTY2hlZHVsZXIgPSBkZWJvdW5jZWRBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMudG9vbHRpcC5sYXN0SG92ZXIgJiYgIXRoaXMuaGlnaGxpZ2h0LnBlbmRpbmdIb3ZlckV2ZW50KVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodGhpcy5jaGFydC5nZXRVcGRhdGVUeXBlKCkgPD0gNCAvKiBTRVJJRVNfVVBEQVRFICovKSB7XG4gICAgICAgIHRoaXMuaG92ZXJTY2hlZHVsZXIuc2NoZWR1bGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0LnBlbmRpbmdIb3ZlckV2ZW50KSB7XG4gICAgICAgIHRoaXMuaGFuZGxlSG92ZXJIaWdobGlnaHQoZmFsc2UpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudG9vbHRpcC5sYXN0SG92ZXIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVIb3ZlclRvb2x0aXAodGhpcy50b29sdGlwLmxhc3RIb3ZlciwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGxhYmVsMSA9IGNoYXJ0LmN0eC5kb21NYW5hZ2VyLmFkZENoaWxkKFwic2VyaWVzLWFyZWFcIiwgXCJzZXJpZXMtYXJlYS1hcmlhLWxhYmVsMVwiKTtcbiAgICBjb25zdCBsYWJlbDIgPSBjaGFydC5jdHguZG9tTWFuYWdlci5hZGRDaGlsZChcInNlcmllcy1hcmVhXCIsIFwic2VyaWVzLWFyZWEtYXJpYS1sYWJlbDJcIik7XG4gICAgdGhpcy5zd2FwQ2hhaW4gPSBuZXcgRm9jdXNTd2FwQ2hhaW4obGFiZWwxLCBsYWJlbDIsIHRoaXMuaWQsIFwiaW1nXCIpO1xuICAgIHRoaXMuc3dhcENoYWluLmFkZExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiB0aGlzLm9uQmx1cigpKTtcbiAgICB0aGlzLnN3YXBDaGFpbi5hZGRMaXN0ZW5lcihcImZvY3VzXCIsICgpID0+IHRoaXMub25Gb2N1cygpKTtcbiAgICB0aGlzLmZvY3VzSW5kaWNhdG9yID0gbmV3IEZvY3VzSW5kaWNhdG9yKHRoaXMuc3dhcENoYWluKTtcbiAgICB0aGlzLmZvY3VzSW5kaWNhdG9yLm92ZXJyaWRlRm9jdXNWaXNpYmxlKGNoYXJ0Lm1vZGUgPT09IFwiaW50ZWdyYXRlZFwiID8gZmFsc2UgOiB2b2lkIDApO1xuICAgIGNvbnN0IHsgc2VyaWVzRHJhZ0ludGVycHJldGVyLCBzZXJpZXNXaWRnZXQsIGNvbnRhaW5lcldpZGdldCB9ID0gY2hhcnQuY3R4LndpZGdldHM7XG4gICAgc2VyaWVzV2lkZ2V0LnNldFRhYkluZGV4KC0xKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgICgpID0+IGNoYXJ0LmN0eC5kb21NYW5hZ2VyLnJlbW92ZUNoaWxkKFwic2VyaWVzLWFyZWFcIiwgXCJzZXJpZXMtYXJlYS1hcmlhLWxhYmVsMVwiKSxcbiAgICAgICgpID0+IGNoYXJ0LmN0eC5kb21NYW5hZ2VyLnJlbW92ZUNoaWxkKFwic2VyaWVzLWFyZWFcIiwgXCJzZXJpZXMtYXJlYS1hcmlhLWxhYmVsMlwiKSxcbiAgICAgIHNlcmllc1dpZGdldC5hZGRMaXN0ZW5lcihcImZvY3VzXCIsICgpID0+IHRoaXMuc3dhcENoYWluLmZvY3VzKCkpLFxuICAgICAgc2VyaWVzV2lkZ2V0LmFkZExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIChldmVudCkgPT4gdGhpcy5vbkhvdmVyKGV2ZW50KSksXG4gICAgICBzZXJpZXNXaWRnZXQuYWRkTGlzdGVuZXIoXCJ3aGVlbFwiLCAoZXZlbnQpID0+IHRoaXMub25XaGVlbChldmVudCkpLFxuICAgICAgc2VyaWVzV2lkZ2V0LmFkZExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCAoZXZlbnQpID0+IHRoaXMub25MZWF2ZShldmVudCkpLFxuICAgICAgc2VyaWVzV2lkZ2V0LmFkZExpc3RlbmVyKFwia2V5ZG93blwiLCAoZXZlbnQpID0+IHRoaXMub25LZXlEb3duKGV2ZW50KSksXG4gICAgICBzZXJpZXNXaWRnZXQuYWRkTGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCAoZXZlbnQsIGN1cnJlbnQpID0+IHRoaXMub25Db250ZXh0TWVudShldmVudCwgY3VycmVudCkpLFxuICAgICAgc2VyaWVzRHJhZ0ludGVycHJldGVyLmFkZExpc3RlbmVyKFwiZHJhZy1tb3ZlXCIsIChldmVudCkgPT4gdGhpcy5vbkRyYWdNb3ZlKGV2ZW50KSksXG4gICAgICBzZXJpZXNEcmFnSW50ZXJwcmV0ZXIuYWRkTGlzdGVuZXIoXCJjbGlja1wiLCAoZXZlbnQpID0+IHRoaXMub25DbGljayhldmVudCwgc2VyaWVzV2lkZ2V0KSksXG4gICAgICBzZXJpZXNEcmFnSW50ZXJwcmV0ZXIuYWRkTGlzdGVuZXIoXCJkYmxjbGlja1wiLCAoZXZlbnQpID0+IHRoaXMub25DbGljayhldmVudCwgc2VyaWVzV2lkZ2V0KSksXG4gICAgICBjb250YWluZXJXaWRnZXQuYWRkTGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCAoZXZlbnQsIGN1cnJlbnQpID0+IHRoaXMub25Db250ZXh0TWVudShldmVudCwgY3VycmVudCkpLFxuICAgICAgY29udGFpbmVyV2lkZ2V0LmFkZExpc3RlbmVyKFwiY2xpY2tcIiwgKGV2ZW50LCBjdXJyZW50KSA9PiB0aGlzLm9uQ2xpY2soZXZlbnQsIGN1cnJlbnQpKSxcbiAgICAgIGNvbnRhaW5lcldpZGdldC5hZGRMaXN0ZW5lcihcImRibGNsaWNrXCIsIChldmVudCwgY3VycmVudCkgPT4gdGhpcy5vbkNsaWNrKGV2ZW50LCBjdXJyZW50KSksXG4gICAgICBjaGFydC5jdHguYW5pbWF0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImFuaW1hdGlvbi1zdGFydFwiLCAoKSA9PiB0aGlzLmNsZWFyQWxsKCkpLFxuICAgICAgY2hhcnQuY3R4LmRvbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJyZXNpemVcIiwgKCkgPT4gdGhpcy5jbGVhckFsbCgpKSxcbiAgICAgIGNoYXJ0LmN0eC5oaWdobGlnaHRNYW5hZ2VyLmFkZExpc3RlbmVyKFwiaGlnaGxpZ2h0LWNoYW5nZVwiLCAoZXZlbnQpID0+IHRoaXMuY2hhbmdlSGlnaGxpZ2h0RGF0dW0oZXZlbnQpKSxcbiAgICAgIGNoYXJ0LmN0eC5sYXlvdXRNYW5hZ2VyLmFkZExpc3RlbmVyKFwibGF5b3V0OmNvbXBsZXRlXCIsIChldmVudCkgPT4gdGhpcy5sYXlvdXRDb21wbGV0ZShldmVudCkpLFxuICAgICAgY2hhcnQuY3R4LnVwZGF0ZVNlcnZpY2UuYWRkTGlzdGVuZXIoXCJwcmUtc2NlbmUtcmVuZGVyXCIsICgpID0+IHRoaXMucHJlU2NlbmVSZW5kZXIoKSksXG4gICAgICBjaGFydC5jdHgudXBkYXRlU2VydmljZS5hZGRMaXN0ZW5lcihcInVwZGF0ZS1jb21wbGV0ZVwiLCAoKSA9PiB0aGlzLnVwZGF0ZUNvbXBsZXRlKCkpLFxuICAgICAgY2hhcnQuY3R4Lnpvb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwiem9vbS1jaGFuZ2VcIiwgKCkgPT4gdGhpcy5jbGVhckFsbCgpKSxcbiAgICAgIGNoYXJ0LmN0eC56b29tTWFuYWdlci5hZGRMaXN0ZW5lcihcInpvb20tcGFuLXN0YXJ0XCIsICgpID0+IHRoaXMuY2xlYXJBbGwoKSlcbiAgICApO1xuICB9XG4gIGlzU3RhdGUoYWxsb3dlZFN0YXRlcykge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuaXNTdGF0ZShhbGxvd2VkU3RhdGVzKTtcbiAgfVxuICBpc0lnbm9yZWRUb3VjaChldmVudCkge1xuICAgIGlmIChldmVudC5kZXZpY2UgIT09IFwidG91Y2hcIiB8fCBldmVudC50eXBlID09PSBcImNsaWNrXCIpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuY2hhcnQuY3R4LmNoYXJ0U2VydmljZS50b3VjaC5kcmFnQWN0aW9uID09PSBcImhvdmVyXCIpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuY2hhcnQuY3R4LmNoYXJ0U2VydmljZS50b3VjaC5kcmFnQWN0aW9uID09PSBcImRyYWdcIikge1xuICAgICAgaWYgKHRoaXMuaXNTdGF0ZSg5IC8qIEFubm90YXRpb25zTW92ZWFibGUgKi8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZGF0YUNoYW5nZWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuaGlnaGxpZ2h0KS5zdGFzaGVkSG92ZXJFdmVudCA/PyAoX2Euc3Rhc2hlZEhvdmVyRXZlbnQgPSB0aGlzLmhpZ2hsaWdodC5hcHBsaWVkSG92ZXJFdmVudCk7XG4gICAgdGhpcy5jaGFydC5jdHgudG9vbHRpcE1hbmFnZXIucmVtb3ZlVG9vbHRpcCh0aGlzLmlkKTtcbiAgICB0aGlzLmZvY3VzSW5kaWNhdG9yLmNsZWFyKCk7XG4gICAgdGhpcy5jbGVhckhpZ2hsaWdodCgpO1xuICB9XG4gIHByZVNjZW5lUmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmhpZ2hsaWdodC5zdGFzaGVkSG92ZXJFdmVudCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmhpZ2hsaWdodC5wZW5kaW5nSG92ZXJFdmVudCA9IHRoaXMuaGlnaGxpZ2h0LnN0YXNoZWRIb3ZlckV2ZW50O1xuICAgICAgdGhpcy5oaWdobGlnaHQuc3Rhc2hlZEhvdmVyRXZlbnQgPSB2b2lkIDA7XG4gICAgICB0aGlzLmhhbmRsZUhvdmVySGlnaGxpZ2h0KHRydWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy50b29sdGlwLmxhc3RIb3ZlciAhPSBudWxsKSB7XG4gICAgICB0aGlzLmhhbmRsZUhvdmVyVG9vbHRpcCh0aGlzLnRvb2x0aXAubGFzdEhvdmVyLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlQ29tcGxldGUoKSB7XG4gICAgaWYgKHRoaXMuZm9jdXNJbmRpY2F0b3IuaXNGb2N1c1Zpc2libGUoKSAmJiB0aGlzLmlzU3RhdGUoMzQgLyogRm9jdXNhYmxlICovKSkge1xuICAgICAgdGhpcy5oYW5kbGVTZXJpZXNGb2N1cygwLCAwLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKHR5cGUsIG9wdHMpIHtcbiAgICB0aGlzLmNoYXJ0LmN0eC51cGRhdGVTZXJ2aWNlLnVwZGF0ZSh0eXBlLCBvcHRzKTtcbiAgfVxuICBzZXJpZXNDaGFuZ2VkKHNlcmllcykge1xuICAgIHRoaXMuZm9jdXMuc29ydGVkU2VyaWVzID0gWy4uLnNlcmllc10uc29ydCgoYSwgYikgPT4ge1xuICAgICAgbGV0IGZwQSA9IGEucHJvcGVydGllcy5mb2N1c1ByaW9yaXR5ID8/IEluZmluaXR5O1xuICAgICAgbGV0IGZwQiA9IGIucHJvcGVydGllcy5mb2N1c1ByaW9yaXR5ID8/IEluZmluaXR5O1xuICAgICAgaWYgKGZwQSA9PT0gZnBCKSB7XG4gICAgICAgIFtmcEEsIGZwQl0gPSBbYS5fZGVjbGFyYXRpb25PcmRlciwgYi5fZGVjbGFyYXRpb25PcmRlcl07XG4gICAgICB9XG4gICAgICBpZiAoZnBBIDwgZnBCKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAoZnBBID4gZnBCKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gICAgdGhpcy5zZXJpZXMgPSBzZXJpZXM7XG4gIH1cbiAgbGF5b3V0Q29tcGxldGUoZXZlbnQpIHtcbiAgICB0aGlzLnNlcmllc1JlY3QgPSBldmVudC5zZXJpZXMucmVjdDtcbiAgICB0aGlzLmhvdmVyUmVjdCA9IGV2ZW50LnNlcmllcy5wYWRkZWRSZWN0O1xuICAgIHRoaXMuY2hhcnQuY3R4LndpZGdldHMuc2VyaWVzV2lkZ2V0LnNldEJvdW5kcyhldmVudC5zZXJpZXMucGFkZGVkUmVjdCk7XG4gICAgdGhpcy5jaGFydC5jdHgud2lkZ2V0cy5jaGFydFdpZGdldC5zZXRCb3VuZHMoZXZlbnQuY2hhcnQpO1xuICB9XG4gIG9uQ29udGV4dE1lbnUoZXZlbnQsIGN1cnJlbnQpIHtcbiAgICBjb25zdCB7IHNvdXJjZUV2ZW50IH0gPSBldmVudDtcbiAgICBpZiAoc291cmNlRXZlbnQuY3VycmVudFRhcmdldCAhPSBjdXJyZW50LmdldEVsZW1lbnQoKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoc291cmNlRXZlbnQudGFyZ2V0ID09IHRoaXMuY2hhcnQuY3R4LndpZGdldHMuY29udGFpbmVyV2lkZ2V0LmdldEVsZW1lbnQoKSkge1xuICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgzNiAvKiBDb250ZXh0TWVudWFibGUgKi8pKSB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFg6IGNhbnZhc1gyLCBjdXJyZW50WTogY2FudmFzWTIgfSA9IGV2ZW50O1xuICAgICAgICB0aGlzLmNoYXJ0LmN0eC5jb250ZXh0TWVudVJlZ2lzdHJ5LmRpc3BhdGNoQ29udGV4dChcImFsbFwiLCB7IHNvdXJjZUV2ZW50LCBjYW52YXNYOiBjYW52YXNYMiwgY2FudmFzWTogY2FudmFzWTIgfSwge30pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcGlja2VkTm9kZTtcbiAgICBsZXQgcG9zaXRpb247XG4gICAgaWYgKHRoaXMuZm9jdXNJbmRpY2F0b3IuaXNGb2N1c1Zpc2libGUoKSkge1xuICAgICAgcGlja2VkTm9kZSA9IHRoaXMuY2hhcnQuY3R4LmhpZ2hsaWdodE1hbmFnZXIuZ2V0QWN0aXZlSGlnaGxpZ2h0KCk7XG4gICAgICBpZiAocGlja2VkTm9kZSAmJiB0aGlzLnNlcmllc1JlY3QgJiYgcGlja2VkTm9kZS5taWRQb2ludCkge1xuICAgICAgICBwb3NpdGlvbiA9IFRyYW5zZm9ybWFibGUudG9DYW52YXNQb2ludChcbiAgICAgICAgICBwaWNrZWROb2RlLnNlcmllcy5jb250ZW50R3JvdXAsXG4gICAgICAgICAgcGlja2VkTm9kZS5taWRQb2ludC54LFxuICAgICAgICAgIHBpY2tlZE5vZGUubWlkUG9pbnQueVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc1N0YXRlKDM2IC8qIENvbnRleHRNZW51YWJsZSAqLykpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5waWNrTm9kZSh7IHg6IGV2ZW50LmN1cnJlbnRYLCB5OiBldmVudC5jdXJyZW50WSB9LCBcImNvbnRleHQtbWVudVwiKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB0aGlzLmNoYXJ0LmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkKTtcbiAgICAgICAgcGlja2VkTm9kZSA9IG1hdGNoLmRhdHVtO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwaWNrZWRTZXJpZXMgPSBwaWNrZWROb2RlPy5zZXJpZXM7XG4gICAgdGhpcy5jbGVhckFsbCgpO1xuICAgIGNvbnN0IGNhbnZhc1ggPSBldmVudC5jdXJyZW50WCArIGN1cnJlbnQuY3NzTGVmdCgpO1xuICAgIGNvbnN0IGNhbnZhc1kgPSBldmVudC5jdXJyZW50WSArIGN1cnJlbnQuY3NzVG9wKCk7XG4gICAgdGhpcy5jaGFydC5jdHguY29udGV4dE1lbnVSZWdpc3RyeS5kaXNwYXRjaENvbnRleHQoXG4gICAgICBcInNlcmllcy1hcmVhXCIsXG4gICAgICB7IHNvdXJjZUV2ZW50LCBjYW52YXNYLCBjYW52YXNZIH0sXG4gICAgICB7IHBpY2tlZFNlcmllcywgcGlja2VkTm9kZSB9LFxuICAgICAgcG9zaXRpb25cbiAgICApO1xuICB9XG4gIG9uTGVhdmUoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaXNTdGF0ZSg0MSAvKiBDbGlja2FibGUgKi8pKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBldmVudC5zb3VyY2VFdmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIGlmIChyZWxhdGVkVGFyZ2V0Py5jbGFzc05hbWUgPT09IFwiYWctY2hhcnRzLXRleHQtaW5wdXRfX3RleHRhcmVhXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2hhcnQuY3R4LnRvb2x0aXBNYW5hZ2VyLmlzRW50ZXJpbmdJbnRlcmFjdGl2ZVRvb2x0aXAoZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2hhcnQuY3R4LmRvbU1hbmFnZXIudXBkYXRlQ3Vyc29yKHRoaXMuaWQpO1xuICAgIGlmICghdGhpcy5mb2N1c0luZGljYXRvci5pc0ZvY3VzVmlzaWJsZSgpKVxuICAgICAgdGhpcy5jbGVhckFsbCgpO1xuICB9XG4gIG9uV2hlZWwoX2V2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmlzU3RhdGUoNDEgLyogQ2xpY2thYmxlICovKSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmZvY3VzSW5kaWNhdG9yPy5vdmVycmlkZUZvY3VzVmlzaWJsZShmYWxzZSk7XG4gICAgdGhpcy5wcmV2aW91c0lucHV0RGV2aWNlID0gXCJwb2ludGVyXCI7XG4gIH1cbiAgb25EcmFnTW92ZShldmVudCkge1xuICAgIGlmICghdGhpcy5pc1N0YXRlKDQxIC8qIENsaWNrYWJsZSAqLykpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5mb2N1c0luZGljYXRvcj8ub3ZlcnJpZGVGb2N1c1Zpc2libGUoZmFsc2UpO1xuICAgIHRoaXMub25Ib3Zlckxpa2VFdmVudChldmVudCk7XG4gIH1cbiAgb25Ib3ZlcihldmVudCkge1xuICAgIGlmICghdGhpcy5pc1N0YXRlKDQxIC8qIENsaWNrYWJsZSAqLykpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5vbkhvdmVyTGlrZUV2ZW50KGV2ZW50KTtcbiAgfVxuICBvbkhvdmVyTGlrZUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaXNJZ25vcmVkVG91Y2goZXZlbnQpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChldmVudC5kZXZpY2UgPT09IFwidG91Y2hcIiB8fCBleGNsdWRlc1R5cGUoZXZlbnQsIFwiZHJhZy1tb3ZlXCIpKSB7XG4gICAgICB0aGlzLnRvb2x0aXAubGFzdEhvdmVyID0gZXZlbnQ7XG4gICAgfVxuICAgIGlmIChldmVudC5kZXZpY2UgPT09IFwidG91Y2hcIiAmJiB0aGlzLmNoYXJ0LmN0eC5jaGFydFNlcnZpY2UudG91Y2guZHJhZ0FjdGlvbiA9PT0gXCJob3ZlclwiKSB7XG4gICAgICBldmVudC5zb3VyY2VFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICB0aGlzLmhvdmVyRGV2aWNlID0gXCJwb2ludGVyXCI7XG4gICAgdGhpcy5wcmV2aW91c0lucHV0RGV2aWNlID0gXCJwb2ludGVyXCI7XG4gICAgdGhpcy5oaWdobGlnaHQucGVuZGluZ0hvdmVyRXZlbnQgPSBldmVudDtcbiAgICB0aGlzLmhvdmVyU2NoZWR1bGVyLnNjaGVkdWxlKCk7XG4gICAgaWYgKHRoaXMuaXNTdGF0ZSgzMiAvKiBEZWZhdWx0ICovKSkge1xuICAgICAgY29uc3QgeyBjdXJyZW50WDogeCwgY3VycmVudFk6IHkgfSA9IGV2ZW50O1xuICAgICAgY29uc3QgZm91bmQgPSB0aGlzLnBpY2tOb2RlKHsgeCwgeSB9LCBcImV2ZW50XCIpO1xuICAgICAgaWYgKGZvdW5kPy5zZXJpZXMuaGFzRXZlbnRMaXN0ZW5lcihcIm5vZGVDbGlja1wiKSB8fCBmb3VuZD8uc2VyaWVzLmhhc0V2ZW50TGlzdGVuZXIoXCJub2RlRG91YmxlQ2xpY2tcIikpIHtcbiAgICAgICAgdGhpcy5jaGFydC5jdHguZG9tTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5pZCwgXCJwb2ludGVyXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGFydC5jdHguZG9tTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5pZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uQ2xpY2soZXZlbnQsIGN1cnJlbnQpIHtcbiAgICBpZiAoZXZlbnQuZGV2aWNlID09PSBcInRvdWNoXCIgJiYgY3VycmVudCA9PT0gdGhpcy5jaGFydC5jdHgud2lkZ2V0cy5zZXJpZXNXaWRnZXQpIHtcbiAgICAgIHRoaXMuc3dhcENoYWluLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzU3RhdGUoNDEgLyogQ2xpY2thYmxlICovKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5jaGFydC5jdHgud2lkZ2V0cy5zZXJpZXNXaWRnZXQpIHtcbiAgICAgIGlmICghY3VycmVudC5nZXRFbGVtZW50KCkuY29udGFpbnMoZXZlbnQuc291cmNlRXZlbnQudGFyZ2V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChldmVudC5zb3VyY2VFdmVudC50YXJnZXQgIT0gY3VycmVudC5nZXRFbGVtZW50KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5mb2N1c0luZGljYXRvci5vdmVycmlkZUZvY3VzVmlzaWJsZShmYWxzZSk7XG4gICAgdGhpcy5vbkhvdmVyTGlrZUV2ZW50KGV2ZW50KTtcbiAgICBpZiAoIXRoaXMuaXNTdGF0ZSgzMiAvKiBEZWZhdWx0ICovKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoY3VycmVudCA9PSB0aGlzLmNoYXJ0LmN0eC53aWRnZXRzLnNlcmllc1dpZGdldCAmJiB0aGlzLmNoZWNrU2VyaWVzTm9kZUNsaWNrKGV2ZW50KSkge1xuICAgICAgdGhpcy51cGRhdGUoNCAvKiBTRVJJRVNfVVBEQVRFICovKTtcbiAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld0V2ZW50ID0geyB0eXBlOiBldmVudC50eXBlID09PSBcImNsaWNrXCIgPyBcImNsaWNrXCIgOiBcImRvdWJsZUNsaWNrXCIsIGV2ZW50OiBldmVudC5zb3VyY2VFdmVudCB9O1xuICAgIHRoaXMuY2hhcnQuZmlyZUV2ZW50KG5ld0V2ZW50KTtcbiAgfVxuICBvbkZvY3VzKCkge1xuICAgIGlmICghdGhpcy5pc1N0YXRlKDM0IC8qIEZvY3VzYWJsZSAqLykpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5ob3ZlckRldmljZSA9IHRoaXMuZm9jdXNJbmRpY2F0b3IuaXNGb2N1c1Zpc2libGUoKSA/IFwia2V5Ym9hcmRcIiA6IFwicG9pbnRlclwiO1xuICAgIHRoaXMuaGFuZGxlRm9jdXMoMCwgMCk7XG4gIH1cbiAgb25CbHVyKCkge1xuICAgIGlmICghdGhpcy5pc1N0YXRlKDM0IC8qIEZvY3VzYWJsZSAqLykpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5ob3ZlckRldmljZSA9IFwicG9pbnRlclwiO1xuICAgIHRoaXMuY2xlYXJBbGwoKTtcbiAgICB0aGlzLmZvY3VzSW5kaWNhdG9yLm92ZXJyaWRlRm9jdXNWaXNpYmxlKHZvaWQgMCk7XG4gIH1cbiAgb25LZXlEb3duKHdpZGdldEV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmlzU3RhdGUoNDMgLyogS2V5YWJsZSAqLykpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYWN0aW9uID0gbWFwS2V5Ym9hcmRFdmVudFRvQWN0aW9uKHdpZGdldEV2ZW50LnNvdXJjZUV2ZW50KTtcbiAgICBpZiAoYWN0aW9uPy5hY3RpdmF0ZXNGb2N1c0luZGljYXRvciA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZm9jdXNJbmRpY2F0b3Iub3ZlcnJpZGVGb2N1c1Zpc2libGUodGhpcy5wcmV2aW91c0lucHV0RGV2aWNlID09PSBcImtleWJvYXJkXCIpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFjdGlvbj8ubmFtZSkge1xuICAgICAgY2FzZSBcInJlZG9cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhcnQuY3R4LmNoYXJ0RXZlbnRNYW5hZ2VyLnNlcmllc0V2ZW50KFwic2VyaWVzLXJlZG9cIik7XG4gICAgICBjYXNlIFwidW5kb1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5jaGFydC5jdHguY2hhcnRFdmVudE1hbmFnZXIuc2VyaWVzRXZlbnQoXCJzZXJpZXMtdW5kb1wiKTtcbiAgICAgIGNhc2UgXCJ6b29taW5cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhcnQuY3R4LmNoYXJ0RXZlbnRNYW5hZ2VyLnNlcmllc0tleU5hdlpvb20oMSwgd2lkZ2V0RXZlbnQpO1xuICAgICAgY2FzZSBcInpvb21vdXRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhcnQuY3R4LmNoYXJ0RXZlbnRNYW5hZ2VyLnNlcmllc0tleU5hdlpvb20oLTEsIHdpZGdldEV2ZW50KTtcbiAgICAgIGNhc2UgXCJhcnJvd3VwXCI6XG4gICAgICAgIHJldHVybiB0aGlzLm9uQXJyb3coLTEsIDAsIHdpZGdldEV2ZW50KTtcbiAgICAgIGNhc2UgXCJhcnJvd2Rvd25cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMub25BcnJvdygxLCAwLCB3aWRnZXRFdmVudCk7XG4gICAgICBjYXNlIFwiYXJyb3dsZWZ0XCI6XG4gICAgICAgIHJldHVybiB0aGlzLm9uQXJyb3coMCwgLTEsIHdpZGdldEV2ZW50KTtcbiAgICAgIGNhc2UgXCJhcnJvd3JpZ2h0XCI6XG4gICAgICAgIHJldHVybiB0aGlzLm9uQXJyb3coMCwgMSwgd2lkZ2V0RXZlbnQpO1xuICAgICAgY2FzZSBcInN1Ym1pdFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5vblN1Ym1pdCh3aWRnZXRFdmVudCk7XG4gICAgfVxuICB9XG4gIG9uQXJyb3coc2VyaWVzSW5kZXhEZWx0YSwgZGF0dW1JbmRleERlbHRhLCBldmVudCkge1xuICAgIGlmICghdGhpcy5pc1N0YXRlKDM0IC8qIEZvY3VzYWJsZSAqLykpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5ob3ZlckRldmljZSA9IFwia2V5Ym9hcmRcIjtcbiAgICB0aGlzLnByZXZpb3VzSW5wdXREZXZpY2UgPSBcImtleWJvYXJkXCI7XG4gICAgdGhpcy5mb2N1c0luZGljYXRvci5vdmVycmlkZUZvY3VzVmlzaWJsZSh0cnVlKTtcbiAgICB0aGlzLmZvY3VzLnNlcmllc0luZGV4ICs9IHNlcmllc0luZGV4RGVsdGE7XG4gICAgdGhpcy5mb2N1cy5kYXR1bUluZGV4ICs9IGRhdHVtSW5kZXhEZWx0YTtcbiAgICB0aGlzLmhhbmRsZUZvY3VzKHNlcmllc0luZGV4RGVsdGEsIGRhdHVtSW5kZXhEZWx0YSk7XG4gICAgZXZlbnQuc291cmNlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmNoYXJ0LmN0eC5jaGFydEV2ZW50TWFuYWdlci5zZXJpZXNFdmVudChcInNlcmllcy1mb2N1cy1jaGFuZ2VcIik7XG4gIH1cbiAgb25TdWJtaXQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaXNTdGF0ZSgzNCAvKiBGb2N1c2FibGUgKi8pKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgc2VyaWVzLCBkYXR1bSB9ID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBzb3VyY2VFdmVudCA9IGV2ZW50LnNvdXJjZUV2ZW50O1xuICAgIGlmIChzZXJpZXMgIT09IHZvaWQgMCAmJiBkYXR1bSAhPT0gdm9pZCAwKSB7XG4gICAgICBzZXJpZXMuZmlyZU5vZGVDbGlja0V2ZW50KHNvdXJjZUV2ZW50LCBkYXR1bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hhcnQuZmlyZUV2ZW50KHtcbiAgICAgICAgdHlwZTogXCJjbGlja1wiLFxuICAgICAgICBldmVudDogc291cmNlRXZlbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzb3VyY2VFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGNoZWNrU2VyaWVzTm9kZUNsaWNrKGV2ZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5waWNrTm9kZSh7IHg6IGV2ZW50LmN1cnJlbnRYLCB5OiBldmVudC5jdXJyZW50WSB9LCBcImV2ZW50XCIpO1xuICAgIGlmIChyZXN1bHQgPT0gbnVsbClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiKSB7XG4gICAgICByZXN1bHQuc2VyaWVzLmZpcmVOb2RlQ2xpY2tFdmVudChldmVudC5zb3VyY2VFdmVudCwgcmVzdWx0LmRhdHVtKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJkYmxjbGlja1wiKSB7XG4gICAgICBldmVudC5wcmV2ZW50Wm9vbURibENsaWNrID0gcmVzdWx0LmRpc3RhbmNlID09PSAwO1xuICAgICAgcmVzdWx0LnNlcmllcy5maXJlTm9kZURvdWJsZUNsaWNrRXZlbnQoZXZlbnQuc291cmNlRXZlbnQsIHJlc3VsdC5kYXR1bSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGhhbmRsZUZvY3VzKHNlcmllc0luZGV4RGVsdGEsIGRhdHVtSW5kZXhEZWx0YSkge1xuICAgIGNvbnN0IG92ZXJsYXlGb2N1cyA9IHRoaXMuY2hhcnQub3ZlcmxheXMuZ2V0Rm9jdXNJbmZvKHRoaXMuY2hhcnQuY3R4LmxvY2FsZU1hbmFnZXIpO1xuICAgIGlmIChvdmVybGF5Rm9jdXMgPT0gbnVsbCkge1xuICAgICAgdGhpcy5oYW5kbGVTZXJpZXNGb2N1cyhzZXJpZXNJbmRleERlbHRhLCBkYXR1bUluZGV4RGVsdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvY3VzSW5kaWNhdG9yLnVwZGF0ZShvdmVybGF5Rm9jdXMucmVjdCwgdGhpcy5zZXJpZXNSZWN0LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIGhhbmRsZVNlcmllc0ZvY3VzKG90aGVySW5kZXhEZWx0YSwgZGF0dW1JbmRleERlbHRhLCByZWZyZXNoID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5jaGFydC5jaGFydFR5cGUgPT09IFwiaGllcmFyY2h5XCIgfHwgdGhpcy5jaGFydC5jaGFydFR5cGUgPT09IFwiZ2F1Z2VcIikge1xuICAgICAgdGhpcy5oYW5kbGVTb2xvU2VyaWVzRm9jdXMob3RoZXJJbmRleERlbHRhLCBkYXR1bUluZGV4RGVsdGEsIHJlZnJlc2gpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGZvY3VzLCBzZXJpZXNSZWN0IH0gPSB0aGlzO1xuICAgIGNvbnN0IHZpc2libGVTZXJpZXMgPSBmb2N1cy5zb3J0ZWRTZXJpZXMuZmlsdGVyKChzKSA9PiBzLnZpc2libGUgJiYgcy5mb2N1c2FibGUpO1xuICAgIGlmICh2aXNpYmxlU2VyaWVzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvbGRQaWNrID0ge1xuICAgICAgZGF0dW1JbmRleDogZm9jdXMuZGF0dW1JbmRleCAtIGRhdHVtSW5kZXhEZWx0YSxcbiAgICAgIG90aGVySW5kZXg6IGZvY3VzLnNlcmllc0luZGV4IC0gb3RoZXJJbmRleERlbHRhXG4gICAgfTtcbiAgICBmb2N1cy5zZXJpZXNJbmRleCA9IGNsYW1wKDAsIGZvY3VzLnNlcmllc0luZGV4LCB2aXNpYmxlU2VyaWVzLmxlbmd0aCAtIDEpO1xuICAgIGZvY3VzLnNlcmllcyA9IHZpc2libGVTZXJpZXNbZm9jdXMuc2VyaWVzSW5kZXhdO1xuICAgIGNvbnN0IHsgZGF0dW1JbmRleCwgc2VyaWVzSW5kZXg6IG90aGVySW5kZXggfSA9IGZvY3VzO1xuICAgIGNvbnN0IHBpY2sgPSBmb2N1cy5zZXJpZXMucGlja0ZvY3VzKHsgZGF0dW1JbmRleCwgZGF0dW1JbmRleERlbHRhLCBvdGhlckluZGV4LCBvdGhlckluZGV4RGVsdGEsIHNlcmllc1JlY3QgfSk7XG4gICAgdGhpcy51cGRhdGVQaWNrZWRGb2N1cyhvdGhlckluZGV4RGVsdGEsIGRhdHVtSW5kZXhEZWx0YSwgb2xkUGljaywgcGljaywgcmVmcmVzaCk7XG4gIH1cbiAgaGFuZGxlU29sb1Nlcmllc0ZvY3VzKG90aGVySW5kZXhEZWx0YSwgZGF0dW1JbmRleERlbHRhLCByZWZyZXNoKSB7XG4gICAgdGhpcy5mb2N1cy5zZXJpZXMgPSB0aGlzLmZvY3VzLnNvcnRlZFNlcmllc1swXTtcbiAgICBjb25zdCB7XG4gICAgICBmb2N1czogeyBzZXJpZXMsIHNlcmllc0luZGV4OiBvdGhlckluZGV4LCBkYXR1bUluZGV4IH0sXG4gICAgICBzZXJpZXNSZWN0XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHNlcmllcyA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG9sZFBpY2sgPSB7XG4gICAgICBkYXR1bUluZGV4OiB0aGlzLmZvY3VzLmRhdHVtSW5kZXggLSBkYXR1bUluZGV4RGVsdGEsXG4gICAgICBvdGhlckluZGV4OiB0aGlzLmZvY3VzLnNlcmllc0luZGV4IC0gb3RoZXJJbmRleERlbHRhXG4gICAgfTtcbiAgICBjb25zdCBwaWNrID0gc2VyaWVzLnBpY2tGb2N1cyh7IGRhdHVtSW5kZXgsIGRhdHVtSW5kZXhEZWx0YSwgb3RoZXJJbmRleCwgb3RoZXJJbmRleERlbHRhLCBzZXJpZXNSZWN0IH0pO1xuICAgIHRoaXMudXBkYXRlUGlja2VkRm9jdXMob3RoZXJJbmRleERlbHRhLCBkYXR1bUluZGV4RGVsdGEsIG9sZFBpY2ssIHBpY2ssIHJlZnJlc2gpO1xuICB9XG4gIHVwZGF0ZVBpY2tlZEZvY3VzKG90aGVySW5kZXhEZWx0YSwgZGF0dW1JbmRleERlbHRhLCBvbGRQaWNrLCBwaWNrLCByZWZyZXNoKSB7XG4gICAgY29uc3QgeyBmb2N1cywgaG92ZXJSZWN0IH0gPSB0aGlzO1xuICAgIGlmIChwaWNrID09PSB2b2lkIDAgfHwgZm9jdXMuc2VyaWVzID09PSB2b2lkIDAgfHwgaG92ZXJSZWN0ID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBkYXR1bSwgZGF0dW1JbmRleCwgb3RoZXJJbmRleCB9ID0gcGljaztcbiAgICBpZiAob3RoZXJJbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICBmb2N1cy5zZXJpZXNJbmRleCA9IG90aGVySW5kZXg7XG4gICAgfVxuICAgIGZvY3VzLmRhdHVtSW5kZXggPSBkYXR1bUluZGV4O1xuICAgIGZvY3VzLmRhdHVtID0gZGF0dW07XG4gICAgaWYgKHRoaXMuZm9jdXNJbmRpY2F0b3IuaXNGb2N1c1Zpc2libGUoKSkge1xuICAgICAgdGhpcy5jaGFydC5jdHguYW5pbWF0aW9uTWFuYWdlci5yZXNldCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5mb2N1c0luZGljYXRvci5pc0ZvY3VzVmlzaWJsZSgpKSB7XG4gICAgICBjb25zdCBmb2N1c0JCb3ggPSBnZXRQaWNrZWRGb2N1c0JCb3gocGljayk7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IGZvY3VzQkJveC5jb21wdXRlQ2VudGVyKCk7XG4gICAgICBpZiAoIWhvdmVyUmVjdC5jb250YWluc1BvaW50KHgsIHkpKSB7XG4gICAgICAgIGNvbnN0IHBhblN1Y2Nlc3MgPSB0aGlzLmNoYXJ0LmN0eC56b29tTWFuYWdlci5wYW5Ub0JCb3godGhpcy5pZCwgaG92ZXJSZWN0LCBmb2N1c0JCb3gpO1xuICAgICAgICBpZiAocGFuU3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZvY3VzSW5kaWNhdG9yLnVwZGF0ZShwaWNrLmJvdW5kcywgdGhpcy5zZXJpZXNSZWN0LCBwaWNrLmNsaXBGb2N1c0JveCk7XG4gICAgY29uc3Qga2V5Ym9hcmRFdmVudCA9IG1ha2VLZXlib2FyZFBvaW50ZXJFdmVudChmb2N1cy5zZXJpZXMsIGhvdmVyUmVjdCwgcGljayk7XG4gICAgaWYgKGtleWJvYXJkRXZlbnQgIT09IHZvaWQgMCAmJiB0aGlzLmhvdmVyRGV2aWNlID09PSBcImtleWJvYXJkXCIpIHtcbiAgICAgIHRoaXMudG9vbHRpcC5sYXN0SG92ZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmhpZ2hsaWdodC5hcHBsaWVkSG92ZXJFdmVudCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0LnBlbmRpbmdIb3ZlckV2ZW50ID0gdm9pZCAwO1xuICAgICAgdGhpcy5oaWdobGlnaHQuc3Rhc2hlZEhvdmVyRXZlbnQgPSB2b2lkIDA7XG4gICAgICBjb25zdCB0b29sdGlwQ29udGVudCA9IGZvY3VzLnNlcmllcy5nZXRUb29sdGlwQ29udGVudChkYXR1bSk7XG4gICAgICBjb25zdCBtZXRhID0gVG9vbHRpcE1hbmFnZXIubWFrZVRvb2x0aXBNZXRhKGtleWJvYXJkRXZlbnQsIGZvY3VzLnNlcmllcywgZGF0dW0pO1xuICAgICAgdGhpcy5jaGFydC5jdHguaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCwgZGF0dW0pO1xuICAgICAgY29uc3QgdG9vbHRpcEVuYWJsZWQgPSB0aGlzLmNoYXJ0LnRvb2x0aXAuZW5hYmxlZCAmJiBmb2N1cy5zZXJpZXMudG9vbHRpcEVuYWJsZWQ7XG4gICAgICBpZiAodG9vbHRpcEVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jaGFydC5jdHgudG9vbHRpcE1hbmFnZXIudXBkYXRlVG9vbHRpcCh0aGlzLmlkLCBtZXRhLCB0b29sdGlwQ29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNoYXJ0LmN0eC50b29sdGlwTWFuYWdlci5yZW1vdmVUb29sdGlwKHRoaXMuaWQpO1xuICAgICAgfVxuICAgICAgaWYgKCFyZWZyZXNoKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZEFubm91bmNlUGljayA9IGRhdHVtSW5kZXhEZWx0YSA9PT0gMCAmJiBvdGhlckluZGV4RGVsdGEgPT09IDAgfHwgb2xkUGljay5kYXR1bUluZGV4ICE9PSBwaWNrLmRhdHVtSW5kZXggfHwgb2xkUGljay5vdGhlckluZGV4ICE9PSAocGljay5vdGhlckluZGV4ID8/IGZvY3VzLnNlcmllc0luZGV4KTtcbiAgICAgICAgaWYgKHNob3VsZEFubm91bmNlUGljaykge1xuICAgICAgICAgIHRoaXMuc3dhcENoYWluLnVwZGF0ZSh0aGlzLmdldERhdHVtQXJpYVRleHQoZGF0dW0sIHRvb2x0aXBDb250ZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0RGF0dW1BcmlhVGV4dChkYXR1bSwgdG9vbHRpcENvbnRlbnQpIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRvb2x0aXBDb250ZW50ID09IG51bGwgPyBcIlwiIDogdG9vbHRpcENvbnRlbnRBcmlhTGFiZWwodG9vbHRpcENvbnRlbnQpO1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmN0eC5sb2NhbGVNYW5hZ2VyLnQoXCJhcmlhQW5ub3VuY2VIb3ZlckRhdHVtXCIsIHtcbiAgICAgIGRhdHVtOiBkYXR1bS5zZXJpZXMuZ2V0RGF0dW1BcmlhVGV4dD8uKGRhdHVtLCBkZXNjcmlwdGlvbikgPz8gZGVzY3JpcHRpb25cbiAgICB9KTtcbiAgfVxuICBjbGVhckhpZ2hsaWdodCgpIHtcbiAgICB0aGlzLmhpZ2hsaWdodC5wZW5kaW5nSG92ZXJFdmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmhpZ2hsaWdodC5hcHBsaWVkSG92ZXJFdmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYXJ0LmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkKTtcbiAgfVxuICBjbGVhclRvb2x0aXAoKSB7XG4gICAgdGhpcy5jaGFydC5jdHgudG9vbHRpcE1hbmFnZXIucmVtb3ZlVG9vbHRpcCh0aGlzLmlkKTtcbiAgICB0aGlzLnRvb2x0aXAubGFzdEhvdmVyID0gdm9pZCAwO1xuICB9XG4gIGNsZWFyQWxsKCkge1xuICAgIHRoaXMuY2xlYXJIaWdobGlnaHQoKTtcbiAgICB0aGlzLmNsZWFyVG9vbHRpcCgpO1xuICAgIHRoaXMuZm9jdXNJbmRpY2F0b3IuY2xlYXIoKTtcbiAgfVxuICBoYW5kbGVIb3ZlckhpZ2hsaWdodChyZWRpc3BsYXkpIHtcbiAgICB0aGlzLmhpZ2hsaWdodC5hcHBsaWVkSG92ZXJFdmVudCA9IHRoaXMuaGlnaGxpZ2h0LnBlbmRpbmdIb3ZlckV2ZW50O1xuICAgIHRoaXMuaGlnaGxpZ2h0LnBlbmRpbmdIb3ZlckV2ZW50ID0gdm9pZCAwO1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5oaWdobGlnaHQuYXBwbGllZEhvdmVyRXZlbnQ7XG4gICAgaWYgKCFldmVudCB8fCAhdGhpcy5pc1N0YXRlKDQxIC8qIENsaWNrYWJsZSAqLykpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBjdXJyZW50WCwgY3VycmVudFkgfSA9IGV2ZW50O1xuICAgIGNvbnN0IGNhbnZhc1ggPSBldmVudC5jdXJyZW50WCArICh0aGlzLmhvdmVyUmVjdD8ueCA/PyAwKTtcbiAgICBjb25zdCBjYW52YXNZID0gZXZlbnQuY3VycmVudFkgKyAodGhpcy5ob3ZlclJlY3Q/LnkgPz8gMCk7XG4gICAgaWYgKHJlZGlzcGxheSA/IHRoaXMuY2hhcnQuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNBY3RpdmUoKSA6ICF0aGlzLmhvdmVyUmVjdD8uY29udGFpbnNQb2ludChjYW52YXNYLCBjYW52YXNZKSkge1xuICAgICAgdGhpcy5jbGVhckhpZ2hsaWdodCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHJhbmdlOiByYW5nZTMgfSA9IHRoaXMuY2hhcnQuaGlnaGxpZ2h0O1xuICAgIGNvbnN0IGludGVudCA9IHJhbmdlMyA9PT0gXCJ0b29sdGlwXCIgPyBcImhpZ2hsaWdodC10b29sdGlwXCIgOiBcImhpZ2hsaWdodFwiO1xuICAgIGNvbnN0IGZvdW5kID0gdGhpcy5waWNrTm9kZSh7IHg6IGN1cnJlbnRYLCB5OiBjdXJyZW50WSB9LCBpbnRlbnQpO1xuICAgIGlmIChmb3VuZCkge1xuICAgICAgdGhpcy5jaGFydC5jdHguaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCwgZm91bmQuZGF0dW0pO1xuICAgICAgdGhpcy5ob3ZlckRldmljZSA9IFwicG9pbnRlclwiO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNoYXJ0LmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkKTtcbiAgfVxuICBoYW5kbGVIb3ZlclRvb2x0aXAoZXZlbnQsIHJlZGlzcGxheSkge1xuICAgIGlmICghdGhpcy5pc1N0YXRlKDQxIC8qIENsaWNrYWJsZSAqLykpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBjdXJyZW50WCwgY3VycmVudFkgfSA9IGV2ZW50O1xuICAgIGNvbnN0IGNhbnZhc1ggPSBjdXJyZW50WCArICh0aGlzLmhvdmVyUmVjdD8ueCA/PyAwKTtcbiAgICBjb25zdCBjYW52YXNZID0gY3VycmVudFkgKyAodGhpcy5ob3ZlclJlY3Q/LnkgPz8gMCk7XG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGV2ZW50LnNvdXJjZUV2ZW50LnRhcmdldDtcbiAgICBpZiAocmVkaXNwbGF5ID8gdGhpcy5jaGFydC5jdHguYW5pbWF0aW9uTWFuYWdlci5pc0FjdGl2ZSgpIDogIXRoaXMuaG92ZXJSZWN0Py5jb250YWluc1BvaW50KGNhbnZhc1gsIGNhbnZhc1kpKSB7XG4gICAgICBpZiAodGhpcy5ob3ZlckRldmljZSA9PSBcInBvaW50ZXJcIilcbiAgICAgICAgdGhpcy5jbGVhclRvb2x0aXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRhcmdldEVsZW1lbnQgJiYgdGhpcy5jaGFydC50b29sdGlwLmludGVyYWN0aXZlICYmIHRoaXMuY2hhcnQuY3R4LmRvbU1hbmFnZXIuaXNNYW5hZ2VkQ2hpbGRET01FbGVtZW50KHRhcmdldEVsZW1lbnQsIFwiY2FudmFzLW92ZXJsYXlcIiwgREVGQVVMVF9UT09MVElQX0NMQVNTKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwaWNrID0gdGhpcy5waWNrTm9kZSh7IHg6IGV2ZW50LmN1cnJlbnRYLCB5OiBldmVudC5jdXJyZW50WSB9LCBcInRvb2x0aXBcIik7XG4gICAgaWYgKCFwaWNrKSB7XG4gICAgICBpZiAodGhpcy5ob3ZlckRldmljZSA9PSBcInBvaW50ZXJcIilcbiAgICAgICAgdGhpcy5jbGVhclRvb2x0aXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ob3ZlckRldmljZSA9IFwicG9pbnRlclwiO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBwaWNrLnNlcmllcy5nZXRUb29sdGlwQ29udGVudChwaWNrLmRhdHVtKTtcbiAgICBjb25zdCB0b29sdGlwRW5hYmxlZCA9IHRoaXMuY2hhcnQudG9vbHRpcC5lbmFibGVkICYmIHBpY2suc2VyaWVzLnRvb2x0aXBFbmFibGVkO1xuICAgIGNvbnN0IHNob3VsZFVwZGF0ZVRvb2x0aXAgPSB0b29sdGlwRW5hYmxlZCAmJiBjb250ZW50ICE9IG51bGw7XG4gICAgaWYgKHNob3VsZFVwZGF0ZVRvb2x0aXApIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBUb29sdGlwTWFuYWdlci5tYWtlVG9vbHRpcE1ldGEoXG4gICAgICAgIHsgdHlwZTogXCJwb2ludGVybW92ZVwiLCBjYW52YXNYLCBjYW52YXNZIH0sXG4gICAgICAgIHBpY2suc2VyaWVzLFxuICAgICAgICBwaWNrLmRhdHVtXG4gICAgICApO1xuICAgICAgdGhpcy5jaGFydC5jdHgudG9vbHRpcE1hbmFnZXIudXBkYXRlVG9vbHRpcCh0aGlzLmlkLCBtZXRhLCBjb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGFydC5jdHgudG9vbHRpcE1hbmFnZXIucmVtb3ZlVG9vbHRpcCh0aGlzLmlkKTtcbiAgICB9XG4gIH1cbiAgY2hhbmdlSGlnaGxpZ2h0RGF0dW0oZXZlbnQpIHtcbiAgICBjb25zdCBzZXJpZXNUb1VwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgeyBzZXJpZXM6IG5ld1NlcmllcyA9IHZvaWQgMCwgZGF0dW06IG5ld0RhdHVtIH0gPSBldmVudC5jdXJyZW50SGlnaGxpZ2h0ID8/IHt9O1xuICAgIGNvbnN0IHsgc2VyaWVzOiBsYXN0U2VyaWVzID0gdm9pZCAwLCBkYXR1bTogbGFzdERhdHVtIH0gPSBldmVudC5wcmV2aW91c0hpZ2hsaWdodCA/PyB7fTtcbiAgICBpZiAobGFzdFNlcmllcykge1xuICAgICAgc2VyaWVzVG9VcGRhdGUuYWRkKGxhc3RTZXJpZXMpO1xuICAgIH1cbiAgICBpZiAobmV3U2VyaWVzKSB7XG4gICAgICBzZXJpZXNUb1VwZGF0ZS5hZGQobmV3U2VyaWVzKTtcbiAgICB9XG4gICAgaWYgKGxhc3RTZXJpZXM/LnByb3BlcnRpZXMuY3Vyc29yICYmIGxhc3REYXR1bSkge1xuICAgICAgdGhpcy5jaGFydC5jdHguZG9tTWFuYWdlci51cGRhdGVDdXJzb3IobGFzdFNlcmllcy5pZCk7XG4gICAgfVxuICAgIGlmIChuZXdTZXJpZXM/LnByb3BlcnRpZXMuY3Vyc29yICYmIG5ld1Nlcmllcz8ucHJvcGVydGllcy5jdXJzb3IgIT09IFwiZGVmYXVsdFwiICYmIG5ld0RhdHVtKSB7XG4gICAgICB0aGlzLmNoYXJ0LmN0eC5kb21NYW5hZ2VyLnVwZGF0ZUN1cnNvcihuZXdTZXJpZXMuaWQsIG5ld1Nlcmllcy5wcm9wZXJ0aWVzLmN1cnNvcik7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZUFsbCA9IG5ld1NlcmllcyA9PSBudWxsIHx8IGxhc3RTZXJpZXMgPT0gbnVsbDtcbiAgICBpZiAodXBkYXRlQWxsKSB7XG4gICAgICB0aGlzLnVwZGF0ZSg0IC8qIFNFUklFU19VUERBVEUgKi8pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZSg0IC8qIFNFUklFU19VUERBVEUgKi8sIHsgc2VyaWVzVG9VcGRhdGUgfSk7XG4gICAgfVxuICB9XG4gIHBpY2tOb2RlKHBvaW50LCBpbnRlbnQsIGV4YWN0TWF0Y2hPbmx5KSB7XG4gICAgY29uc3QgcmV2ZXJzZVNlcmllcyA9IFsuLi50aGlzLnNlcmllc10ucmV2ZXJzZSgpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2YgcmV2ZXJzZVNlcmllcykge1xuICAgICAgaWYgKCFzZXJpZXMudmlzaWJsZSB8fCAhc2VyaWVzLmNvbnRlbnRHcm91cC52aXNpYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBtYXRjaCwgZGlzdGFuY2U6IGRpc3RhbmNlMiB9ID0gc2VyaWVzLnBpY2tOb2RlKHBvaW50LCBpbnRlbnQsIGV4YWN0TWF0Y2hPbmx5KSA/PyB7fTtcbiAgICAgIGlmICghbWF0Y2ggfHwgZGlzdGFuY2UyID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIXJlc3VsdCB8fCByZXN1bHQuZGlzdGFuY2UgPiBkaXN0YW5jZTIpIHtcbiAgICAgICAgcmVzdWx0ID0geyBzZXJpZXMsIGRpc3RhbmNlOiBkaXN0YW5jZTIsIGRhdHVtOiBtYXRjaCB9O1xuICAgICAgfVxuICAgICAgaWYgKGRpc3RhbmNlMiA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmZ1bmN0aW9uIGV4Y2x1ZGVzVHlwZShvYmosIGV4Y2x1ZGVkKSB7XG4gIHJldHVybiBvYmoudHlwZSAhPT0gZXhjbHVkZWQ7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNMYXllck1hbmFnZXIudHNcbnZhciBTRVJJRVNfVEhSRVNIT0xEX0ZPUl9BR0dSRVNTSVZFX0xBWUVSX1JFRFVDVElPTiA9IDMwO1xudmFyIFNlcmllc0xheWVyTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2VyaWVzUm9vdCkge1xuICAgIHRoaXMuc2VyaWVzUm9vdCA9IHNlcmllc1Jvb3Q7XG4gICAgdGhpcy5ncm91cHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuc2VyaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmV4cGVjdGVkU2VyaWVzQ291bnQgPSAxO1xuICAgIHRoaXMubW9kZSA9IFwibm9ybWFsXCI7XG4gIH1cbiAgc2V0U2VyaWVzQ291bnQoY291bnQpIHtcbiAgICB0aGlzLmV4cGVjdGVkU2VyaWVzQ291bnQgPSBjb3VudDtcbiAgfVxuICByZXF1ZXN0R3JvdXAoc2VyaWVzQ29uZmlnKSB7XG4gICAgY29uc3QgeyBpbnRlcm5hbElkLCB0eXBlLCBjb250ZW50R3JvdXA6IHNlcmllc0NvbnRlbnRHcm91cCwgc2VyaWVzR3JvdXBpbmcgfSA9IHNlcmllc0NvbmZpZztcbiAgICBjb25zdCB7IGdyb3VwSW5kZXggPSBpbnRlcm5hbElkIH0gPSBzZXJpZXNHcm91cGluZyA/PyB7fTtcbiAgICBjb25zdCBzZXJpZXNJbmZvID0gdGhpcy5zZXJpZXMuZ2V0KGludGVybmFsSWQpO1xuICAgIGlmIChzZXJpZXNJbmZvICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gc2VyaWVzIGFscmVhZHkgaGFzIGFuIGFsbG9jYXRlZCBsYXllcjogJHtKU09OLnN0cmluZ2lmeShzZXJpZXNJbmZvKX1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2VyaWVzLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMubW9kZSA9IHRoaXMuZXhwZWN0ZWRTZXJpZXNDb3VudCA+PSBTRVJJRVNfVEhSRVNIT0xEX0ZPUl9BR0dSRVNTSVZFX0xBWUVSX1JFRFVDVElPTiA/IFwiYWdncmVzc2l2ZS1ncm91cGluZ1wiIDogXCJub3JtYWxcIjtcbiAgICB9XG4gICAgbGV0IGdyb3VwID0gdGhpcy5ncm91cHMuZ2V0KHR5cGUpO1xuICAgIGlmIChncm91cCA9PSBudWxsKSB7XG4gICAgICBncm91cCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICB0aGlzLmdyb3Vwcy5zZXQodHlwZSwgZ3JvdXApO1xuICAgIH1cbiAgICBjb25zdCBsb29rdXBJbmRleCA9IHRoaXMubG9va3VwSWR4KGdyb3VwSW5kZXgpO1xuICAgIGxldCBncm91cEluZm8gPSBncm91cC5nZXQobG9va3VwSW5kZXgpO1xuICAgIGlmIChncm91cEluZm8gPT0gbnVsbCkge1xuICAgICAgZ3JvdXBJbmZvID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBpZDogbG9va3VwSW5kZXgsXG4gICAgICAgIHNlcmllc0lkczogW10sXG4gICAgICAgIGdyb3VwOiB0aGlzLnNlcmllc1Jvb3QuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgbmV3IEdyb3VwKHtcbiAgICAgICAgICAgIG5hbWU6IGAke3Nlcmllc0NvbmZpZy5jb250ZW50R3JvdXAubmFtZSA/PyB0eXBlfS1tYW5hZ2VkLWxheWVyYCxcbiAgICAgICAgICAgIHpJbmRleDogc2VyaWVzQ29uZmlnLmNvbnRlbnRHcm91cC56SW5kZXgsXG4gICAgICAgICAgICAvLyBTZXQgaW4gdXBkYXRlTGF5ZXJDb21wb3NpdGluZ1xuICAgICAgICAgICAgcmVuZGVyVG9PZmZzY3JlZW5DYW52YXM6IGZhbHNlXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgfTtcbiAgICAgIGdyb3VwLnNldChsb29rdXBJbmRleCwgZ3JvdXBJbmZvKTtcbiAgICB9XG4gICAgdGhpcy5zZXJpZXMuc2V0KGludGVybmFsSWQsIHsgbGF5ZXJTdGF0ZTogZ3JvdXBJbmZvLCBzZXJpZXNDb25maWcgfSk7XG4gICAgZ3JvdXBJbmZvLnNlcmllc0lkcy5wdXNoKGludGVybmFsSWQpO1xuICAgIGdyb3VwSW5mby5ncm91cC5hcHBlbmRDaGlsZChzZXJpZXNDb250ZW50R3JvdXApO1xuICAgIHJldHVybiBncm91cEluZm8uZ3JvdXA7XG4gIH1cbiAgY2hhbmdlR3JvdXAoc2VyaWVzQ29uZmlnKSB7XG4gICAgY29uc3QgeyBpbnRlcm5hbElkLCBzZXJpZXNHcm91cGluZywgdHlwZSwgY29udGVudEdyb3VwLCBvbGRHcm91cGluZyB9ID0gc2VyaWVzQ29uZmlnO1xuICAgIGNvbnN0IHsgZ3JvdXBJbmRleCA9IGludGVybmFsSWQgfSA9IHNlcmllc0dyb3VwaW5nID8/IHt9O1xuICAgIGlmICh0aGlzLmdyb3Vwcy5nZXQodHlwZSk/LmdldChncm91cEluZGV4KT8uc2VyaWVzSWRzLmluY2x1ZGVzKGludGVybmFsSWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnNlcmllcy5oYXMoaW50ZXJuYWxJZCkpIHtcbiAgICAgIHRoaXMucmVsZWFzZUdyb3VwKHtcbiAgICAgICAgaW50ZXJuYWxJZCxcbiAgICAgICAgc2VyaWVzR3JvdXBpbmc6IG9sZEdyb3VwaW5nLFxuICAgICAgICB0eXBlLFxuICAgICAgICBjb250ZW50R3JvdXBcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnJlcXVlc3RHcm91cChzZXJpZXNDb25maWcpO1xuICB9XG4gIHJlbGVhc2VHcm91cChzZXJpZXNDb25maWcpIHtcbiAgICBjb25zdCB7IGludGVybmFsSWQsIGNvbnRlbnRHcm91cCwgdHlwZSB9ID0gc2VyaWVzQ29uZmlnO1xuICAgIGlmICghdGhpcy5zZXJpZXMuaGFzKGludGVybmFsSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIHNlcmllcyBkb2Vzbid0IGhhdmUgYW4gYWxsb2NhdGVkIGxheWVyOiAke2ludGVybmFsSWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGdyb3VwSW5mbyA9IHRoaXMuc2VyaWVzLmdldChpbnRlcm5hbElkKT8ubGF5ZXJTdGF0ZTtcbiAgICBpZiAoZ3JvdXBJbmZvKSB7XG4gICAgICBncm91cEluZm8uc2VyaWVzSWRzID0gZ3JvdXBJbmZvLnNlcmllc0lkcy5maWx0ZXIoKHYpID0+IHYgIT09IGludGVybmFsSWQpO1xuICAgICAgZ3JvdXBJbmZvLmdyb3VwLnJlbW92ZUNoaWxkKGNvbnRlbnRHcm91cCk7XG4gICAgfVxuICAgIGlmIChncm91cEluZm8/LnNlcmllc0lkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc2VyaWVzUm9vdC5yZW1vdmVDaGlsZChncm91cEluZm8uZ3JvdXApO1xuICAgICAgdGhpcy5ncm91cHMuZ2V0KGdyb3VwSW5mby50eXBlKT8uZGVsZXRlKGdyb3VwSW5mby5pZCk7XG4gICAgICB0aGlzLmdyb3Vwcy5nZXQodHlwZSk/LmRlbGV0ZShpbnRlcm5hbElkKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwSW5mbyAhPSBudWxsICYmIGdyb3VwSW5mby5zZXJpZXNJZHMubGVuZ3RoID4gMCkge1xuICAgICAgZ3JvdXBJbmZvLmdyb3VwLnpJbmRleCA9IHRoaXMuZ2V0TG93ZXN0U2VyaWVzWkluZGV4KGdyb3VwSW5mby5zZXJpZXNJZHMpO1xuICAgIH1cbiAgICB0aGlzLnNlcmllcy5kZWxldGUoaW50ZXJuYWxJZCk7XG4gIH1cbiAgdXBkYXRlTGF5ZXJDb21wb3NpdGluZygpIHtcbiAgICB0aGlzLmdyb3Vwcy5mb3JFYWNoKChncm91cHMpID0+IHtcbiAgICAgIGdyb3Vwcy5mb3JFYWNoKChncm91cEluZm8pID0+IHtcbiAgICAgICAgY29uc3QgeyBncm91cCwgc2VyaWVzSWRzIH0gPSBncm91cEluZm87XG4gICAgICAgIGxldCByZW5kZXJUb09mZnNjcmVlbkNhbnZhcztcbiAgICAgICAgaWYgKHNlcmllc0lkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZW5kZXJUb09mZnNjcmVlbkNhbnZhcyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHNlcmllc0lkcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmVuZGVyVG9PZmZzY3JlZW5DYW52YXMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHNlcmllcyA9IHRoaXMuc2VyaWVzLmdldChzZXJpZXNJZHNbMF0pO1xuICAgICAgICAgIHJlbmRlclRvT2Zmc2NyZWVuQ2FudmFzID0gc2VyaWVzPy5zZXJpZXNDb25maWcucmVuZGVyVG9PZmZzY3JlZW5DYW52YXMoKSA9PT0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBncm91cC5yZW5kZXJUb09mZnNjcmVlbkNhbnZhcyA9IHJlbmRlclRvT2Zmc2NyZWVuQ2FudmFzO1xuICAgICAgICBncm91cC56SW5kZXggPSB0aGlzLmdldExvd2VzdFNlcmllc1pJbmRleChzZXJpZXNJZHMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgbG9va3VwSWR4KGdyb3VwSW5kZXgpIHtcbiAgICBpZiAodGhpcy5tb2RlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICByZXR1cm4gZ3JvdXBJbmRleDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBncm91cEluZGV4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBncm91cEluZGV4ID0gTnVtYmVyKGdyb3VwSW5kZXguc3BsaXQoXCItXCIpLmF0KC0xKSk7XG4gICAgICBpZiAoIWdyb3VwSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmZsb29yKFxuICAgICAgY2xhbXAoMCwgZ3JvdXBJbmRleCAvIHRoaXMuZXhwZWN0ZWRTZXJpZXNDb3VudCwgMSkgKiBTRVJJRVNfVEhSRVNIT0xEX0ZPUl9BR0dSRVNTSVZFX0xBWUVSX1JFRFVDVElPTlxuICAgICk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmdyb3Vwcy5mb3JFYWNoKChncm91cHMpID0+IHtcbiAgICAgIGdyb3Vwcy5mb3JFYWNoKChncm91cEluZm8pID0+IHtcbiAgICAgICAgdGhpcy5zZXJpZXNSb290LnJlbW92ZUNoaWxkKGdyb3VwSW5mby5ncm91cCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmdyb3Vwcy5jbGVhcigpO1xuICAgIHRoaXMuc2VyaWVzLmNsZWFyKCk7XG4gIH1cbiAgZ2V0TG93ZXN0U2VyaWVzWkluZGV4KHNlcmllc0lkcykge1xuICAgIGNvbnN0IGxvd2VzdFNlcmllc1pJbmRleCA9IHNlcmllc0lkcy5yZWR1Y2UoKGN1cnJlbnRMb3dlc3QsIHNlcmllc0lkKSA9PiB7XG4gICAgICBjb25zdCBzZXJpZXMgPSB0aGlzLnNlcmllcy5nZXQoc2VyaWVzSWQpO1xuICAgICAgY29uc3QgekluZGV4ID0gc2VyaWVzPy5zZXJpZXNDb25maWcuY29udGVudEdyb3VwLnpJbmRleDtcbiAgICAgIGlmIChjdXJyZW50TG93ZXN0ID09IG51bGwgfHwgekluZGV4ID09IG51bGwpXG4gICAgICAgIHJldHVybiB6SW5kZXg7XG4gICAgICByZXR1cm4gY29tcGFyZVpJbmRleChjdXJyZW50TG93ZXN0LCB6SW5kZXgpIDw9IDAgPyBjdXJyZW50TG93ZXN0IDogekluZGV4O1xuICAgIH0sIHZvaWQgMCk7XG4gICAgcmV0dXJuIGxvd2VzdFNlcmllc1pJbmRleCA/PyAxIC8qIEFOWV9DT05URU5UICovO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90b3VjaC50c1xudmFyIFRvdWNoID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5kcmFnQWN0aW9uID0gXCJkcmFnXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShVTklPTihbXCJub25lXCIsIFwiZHJhZ1wiLCBcImhvdmVyXCJdKSlcbl0sIFRvdWNoLnByb3RvdHlwZSwgXCJkcmFnQWN0aW9uXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC91cGRhdGUvZGF0YVdpbmRvd1Byb2Nlc3Nvci50c1xudmFyIERhdGFXaW5kb3dQcm9jZXNzb3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhU2VydmljZSwgdXBkYXRlU2VydmljZSwgem9vbU1hbmFnZXIsIGFuaW1hdGlvbk1hbmFnZXIpIHtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5kYXRhU2VydmljZSA9IGRhdGFTZXJ2aWNlO1xuICAgIHRoaXMudXBkYXRlU2VydmljZSA9IHVwZGF0ZVNlcnZpY2U7XG4gICAgdGhpcy56b29tTWFuYWdlciA9IHpvb21NYW5hZ2VyO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlciA9IGFuaW1hdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5kaXJ0eVpvb20gPSBmYWxzZTtcbiAgICB0aGlzLmRpcnR5RGF0YVNvdXJjZSA9IGZhbHNlO1xuICAgIHRoaXMubGFzdEF4aXNab29tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICB0aGlzLmRhdGFTZXJ2aWNlLmFkZExpc3RlbmVyKFwiZGF0YS1zb3VyY2UtY2hhbmdlXCIsICgpID0+IHRoaXMub25EYXRhU291cmNlQ2hhbmdlKCkpLFxuICAgICAgdGhpcy5kYXRhU2VydmljZS5hZGRMaXN0ZW5lcihcImRhdGEtbG9hZFwiLCAoKSA9PiB0aGlzLm9uRGF0YUxvYWQoKSksXG4gICAgICB0aGlzLmRhdGFTZXJ2aWNlLmFkZExpc3RlbmVyKFwiZGF0YS1lcnJvclwiLCAoKSA9PiB0aGlzLm9uRGF0YUVycm9yKCkpLFxuICAgICAgdGhpcy51cGRhdGVTZXJ2aWNlLmFkZExpc3RlbmVyKFwidXBkYXRlLWNvbXBsZXRlXCIsICgpID0+IHRoaXMub25VcGRhdGVDb21wbGV0ZSgpKSxcbiAgICAgIHRoaXMuem9vbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJ6b29tLWNoYW5nZVwiLCAoKSA9PiB0aGlzLm9uWm9vbUNoYW5nZSgpKVxuICAgICk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoY2IpID0+IGNiKCkpO1xuICB9XG4gIG9uRGF0YUxvYWQoKSB7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLnNraXAoKTtcbiAgICB0aGlzLnVwZGF0ZVNlcnZpY2UudXBkYXRlKDEgLyogVVBEQVRFX0RBVEEgKi8pO1xuICB9XG4gIG9uRGF0YUVycm9yKCkge1xuICAgIHRoaXMudXBkYXRlU2VydmljZS51cGRhdGUoMyAvKiBQRVJGT1JNX0xBWU9VVCAqLyk7XG4gIH1cbiAgb25EYXRhU291cmNlQ2hhbmdlKCkge1xuICAgIHRoaXMuZGlydHlEYXRhU291cmNlID0gdHJ1ZTtcbiAgfVxuICBvblVwZGF0ZUNvbXBsZXRlKCkge1xuICAgIGlmICghdGhpcy5kaXJ0eVpvb20gJiYgIXRoaXMuZGlydHlEYXRhU291cmNlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMudXBkYXRlV2luZG93KCk7XG4gIH1cbiAgb25ab29tQ2hhbmdlKCkge1xuICAgIHRoaXMuZGlydHlab29tID0gdHJ1ZTtcbiAgfVxuICB1cGRhdGVXaW5kb3coKSB7XG4gICAgaWYgKCF0aGlzLmRhdGFTZXJ2aWNlLmlzTGF6eSgpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmdldFZhbGlkQXhpcygpO1xuICAgIGxldCB3aW5kb3cyO1xuICAgIGxldCBzaG91bGRSZWZyZXNoID0gdHJ1ZTtcbiAgICBpZiAoYXhpcykge1xuICAgICAgY29uc3Qgem9vbSA9IHRoaXMuem9vbU1hbmFnZXIuZ2V0QXhpc1pvb20oYXhpcy5pZCk7XG4gICAgICB3aW5kb3cyID0gdGhpcy5nZXRBeGlzV2luZG93KGF4aXMsIHpvb20pO1xuICAgICAgc2hvdWxkUmVmcmVzaCA9IHRoaXMuc2hvdWxkUmVmcmVzaChheGlzLCB6b29tKTtcbiAgICB9XG4gICAgdGhpcy5kaXJ0eVpvb20gPSBmYWxzZTtcbiAgICB0aGlzLmRpcnR5RGF0YVNvdXJjZSA9IGZhbHNlO1xuICAgIGlmICghc2hvdWxkUmVmcmVzaClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmRhdGFTZXJ2aWNlLmxvYWQoeyB3aW5kb3dTdGFydDogd2luZG93Mj8ubWluLCB3aW5kb3dFbmQ6IHdpbmRvdzI/Lm1heCB9KTtcbiAgfVxuICBnZXRWYWxpZEF4aXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuYXhlcy5maW5kKChheGlzKSA9PiBheGlzLnR5cGUgPT09IFwidGltZVwiKTtcbiAgfVxuICBzaG91bGRSZWZyZXNoKGF4aXMsIHpvb20pIHtcbiAgICBpZiAodGhpcy5kaXJ0eURhdGFTb3VyY2UpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuZGlydHlab29tKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGxhc3Rab29tID0gdGhpcy5sYXN0QXhpc1pvb21zLmdldChheGlzLmlkKTtcbiAgICBpZiAobGFzdFpvb20gJiYgem9vbS5taW4gPT09IGxhc3Rab29tLm1pbiAmJiB6b29tLm1heCA9PT0gbGFzdFpvb20ubWF4KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubGFzdEF4aXNab29tcy5zZXQoYXhpcy5pZCwgem9vbSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0QXhpc1dpbmRvdyhheGlzLCB6b29tKSB7XG4gICAgY29uc3QgeyBkb21haW4gfSA9IGF4aXMuc2NhbGU7XG4gICAgaWYgKCF6b29tIHx8IGRvbWFpbi5sZW5ndGggPT09IDAgfHwgaXNOYU4oTnVtYmVyKGRvbWFpblswXSkpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRpZmYyID0gTnVtYmVyKGRvbWFpblsxXSkgLSBOdW1iZXIoZG9tYWluWzBdKTtcbiAgICBjb25zdCBtaW4gPSBuZXcgRGF0ZShOdW1iZXIoZG9tYWluWzBdKSArIGRpZmYyICogem9vbS5taW4pO1xuICAgIGNvbnN0IG1heCA9IG5ldyBEYXRlKE51bWJlcihkb21haW5bMF0pICsgZGlmZjIgKiB6b29tLm1heCk7XG4gICAgcmV0dXJuIHsgbWluLCBtYXggfTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9icm93c2VyLnRzXG52YXIgaXNTYWZhcmlSZWdleHAgPSAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaTtcbnZhciBzYWZhcmlWZXJzaW9uUmVnZXhwID0gL1ZlcnNpb25cXC8oXFxkKyhcXC5cXGQrKT8pLztcbnZhciBpc0Nocm9tZVJlZ2V4cCA9IC9DaHJvbWUvO1xudmFyIGNocm9tZVZlcnNpb25SZWdleHAgPSAvQ2hyb21lXFwvKFxcZCspLztcbnZhciBpc0VkZ2UgPSAvRWRnLztcbnZhciBpc09wZXJhID0gL09QUi87XG5mdW5jdGlvbiBpc1Vuc3VwcG9ydGVkQnJvd3NlcigpIHtcbiAgY29uc3QgeyB1c2VyQWdlbnQgfSA9IGdldFdpbmRvdyhcIm5hdmlnYXRvclwiKTtcbiAgaWYgKGlzU2FmYXJpUmVnZXhwLnRlc3QodXNlckFnZW50KSkge1xuICAgIGNvbnN0IHZlcnNpb24gPSBwYXJzZUZsb2F0KHNhZmFyaVZlcnNpb25SZWdleHAuZXhlYyh1c2VyQWdlbnQpPy5bMV0gPz8gXCIwXCIpO1xuICAgIGNvbnN0IHN1cHBvcnRlZCA9IE1hdGguZmxvb3IodmVyc2lvbikgPiAxNjtcbiAgICBpZiAoIXN1cHBvcnRlZCkge1xuICAgICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoYFVuc3VwcG9ydGVkIFNhZmFyaSB2ZXJzaW9uOiAke3ZlcnNpb259OyAke3VzZXJBZ2VudH1gKTtcbiAgICB9XG4gICAgcmV0dXJuICFzdXBwb3J0ZWQ7XG4gIH0gZWxzZSBpZiAoaXNDaHJvbWVSZWdleHAudGVzdCh1c2VyQWdlbnQpICYmICFpc0VkZ2UudGVzdCh1c2VyQWdlbnQpICYmICFpc09wZXJhLnRlc3QodXNlckFnZW50KSkge1xuICAgIGNvbnN0IHZlcnNpb24gPSBwYXJzZUludChjaHJvbWVWZXJzaW9uUmVnZXhwLmV4ZWModXNlckFnZW50KT8uWzFdID8/IFwiMFwiLCAxMCk7XG4gICAgY29uc3Qgc3VwcG9ydGVkID0gdmVyc2lvbiA+IDEyNjtcbiAgICBpZiAoIXN1cHBvcnRlZCkge1xuICAgICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoYFVuc3VwcG9ydGVkIENocm9tZSB2ZXJzaW9uOiAke3ZlcnNpb259OyAke3VzZXJBZ2VudH1gKTtcbiAgICB9XG4gICAgcmV0dXJuICFzdXBwb3J0ZWQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC91cGRhdGUvb3ZlcmxheXNQcm9jZXNzb3IudHNcbnZhciB2aXNpYmxlSWdub3JlZFNlcmllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcIm1hcC1zaGFwZS1iYWNrZ3JvdW5kXCIsIFwibWFwLWxpbmUtYmFja2dyb3VuZFwiXSk7XG52YXIgT3ZlcmxheXNQcm9jZXNzb3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0TGlrZSwgb3ZlcmxheXMsIGRhdGFTZXJ2aWNlLCBsYXlvdXRNYW5hZ2VyLCBsb2NhbGVNYW5hZ2VyLCBhbmltYXRpb25NYW5hZ2VyLCBkb21NYW5hZ2VyKSB7XG4gICAgdGhpcy5jaGFydExpa2UgPSBjaGFydExpa2U7XG4gICAgdGhpcy5vdmVybGF5cyA9IG92ZXJsYXlzO1xuICAgIHRoaXMuZGF0YVNlcnZpY2UgPSBkYXRhU2VydmljZTtcbiAgICB0aGlzLmxheW91dE1hbmFnZXIgPSBsYXlvdXRNYW5hZ2VyO1xuICAgIHRoaXMubG9jYWxlTWFuYWdlciA9IGxvY2FsZU1hbmFnZXI7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyID0gYW5pbWF0aW9uTWFuYWdlcjtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBkb21NYW5hZ2VyO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMub3ZlcmxheUVsZW0gPSB0aGlzLmRvbU1hbmFnZXIuYWRkQ2hpbGQoXCJjYW52YXMtb3ZlcmxheVwiLCBcIm92ZXJsYXlcIik7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5yb2xlID0gXCJzdGF0dXNcIjtcbiAgICB0aGlzLm92ZXJsYXlFbGVtLmFyaWFBdG9taWMgPSBcImZhbHNlXCI7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5hcmlhTGl2ZSA9IFwicG9saXRlXCI7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5jbGFzc0xpc3QudG9nZ2xlKERFRkFVTFRfT1ZFUkxBWV9DTEFTUyk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2godGhpcy5sYXlvdXRNYW5hZ2VyLmFkZExpc3RlbmVyKFwibGF5b3V0OmNvbXBsZXRlXCIsIChlKSA9PiB0aGlzLm9uTGF5b3V0Q29tcGxldGUoZSkpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZVN0eWxlcyhcIm92ZXJsYXlzXCIpO1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIFwib3ZlcmxheVwiKTtcbiAgfVxuICBvbkxheW91dENvbXBsZXRlKHsgc2VyaWVzOiB7IHJlY3QgfSB9KSB7XG4gICAgY29uc3QgaXNMb2FkaW5nID0gdGhpcy5kYXRhU2VydmljZS5pc0xvYWRpbmcoKTtcbiAgICBjb25zdCBoYXNEYXRhID0gdGhpcy5jaGFydExpa2Uuc2VyaWVzLnNvbWUoKHMpID0+IHMuaGFzRGF0YSk7XG4gICAgY29uc3QgYW55U2VyaWVzVmlzaWJsZSA9IHRoaXMuY2hhcnRMaWtlLnNlcmllcy5zb21lKChzKSA9PiBzLnZpc2libGUgJiYgIXZpc2libGVJZ25vcmVkU2VyaWVzLmhhcyhzLnR5cGUpKTtcbiAgICBpZiAodGhpcy5vdmVybGF5cy5kYXJrVGhlbWUpIHtcbiAgICAgIHRoaXMub3ZlcmxheUVsZW0uY2xhc3NMaXN0LmFkZChERUZBVUxUX09WRVJMQVlfREFSS19DTEFTUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3ZlcmxheUVsZW0uY2xhc3NMaXN0LnJlbW92ZShERUZBVUxUX09WRVJMQVlfREFSS19DTEFTUyk7XG4gICAgfVxuICAgIHRoaXMub3ZlcmxheUVsZW0uc3R5bGUubGVmdCA9IGAke3JlY3QueH1weGA7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5zdHlsZS50b3AgPSBgJHtyZWN0Lnl9cHhgO1xuICAgIHRoaXMub3ZlcmxheUVsZW0uc3R5bGUud2lkdGggPSBgJHtyZWN0LndpZHRofXB4YDtcbiAgICB0aGlzLm92ZXJsYXlFbGVtLnN0eWxlLmhlaWdodCA9IGAke3JlY3QuaGVpZ2h0fXB4YDtcbiAgICBjb25zdCBsb2FkaW5nU2hvd24gPSBpc0xvYWRpbmc7XG4gICAgY29uc3Qgbm9EYXRhU2hvd24gPSAhaXNMb2FkaW5nICYmICFoYXNEYXRhO1xuICAgIGNvbnN0IG5vVmlzaWJsZVNlcmllc1Nob3duID0gaGFzRGF0YSAmJiAhYW55U2VyaWVzVmlzaWJsZTtcbiAgICBjb25zdCB1bnN1cHBvcnRlZEJyb3dzZXIgPSB0aGlzLm92ZXJsYXlzLnVuc3VwcG9ydGVkQnJvd3Nlci5lbmFibGVkICYmIGlzVW5zdXBwb3J0ZWRCcm93c2VyKCk7XG4gICAgaWYgKGxvYWRpbmdTaG93bikge1xuICAgICAgdGhpcy5zaG93T3ZlcmxheSh0aGlzLm92ZXJsYXlzLmxvYWRpbmcsIHJlY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpZGVPdmVybGF5KHRoaXMub3ZlcmxheXMubG9hZGluZyk7XG4gICAgfVxuICAgIGlmIChub0RhdGFTaG93bikge1xuICAgICAgdGhpcy5zaG93T3ZlcmxheSh0aGlzLm92ZXJsYXlzLm5vRGF0YSwgcmVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZU92ZXJsYXkodGhpcy5vdmVybGF5cy5ub0RhdGEpO1xuICAgIH1cbiAgICBpZiAobm9WaXNpYmxlU2VyaWVzU2hvd24pIHtcbiAgICAgIHRoaXMuc2hvd092ZXJsYXkodGhpcy5vdmVybGF5cy5ub1Zpc2libGVTZXJpZXMsIHJlY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpZGVPdmVybGF5KHRoaXMub3ZlcmxheXMubm9WaXNpYmxlU2VyaWVzKTtcbiAgICB9XG4gICAgaWYgKHVuc3VwcG9ydGVkQnJvd3Nlcikge1xuICAgICAgdGhpcy5zaG93T3ZlcmxheSh0aGlzLm92ZXJsYXlzLnVuc3VwcG9ydGVkQnJvd3NlciwgcmVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZU92ZXJsYXkodGhpcy5vdmVybGF5cy51bnN1cHBvcnRlZEJyb3dzZXIpO1xuICAgIH1cbiAgICBjb25zdCBzaG93biA9IGxvYWRpbmdTaG93biB8fCBub0RhdGFTaG93biB8fCBub1Zpc2libGVTZXJpZXNTaG93biB8fCB1bnN1cHBvcnRlZEJyb3dzZXI7XG4gICAgc2V0QXR0cmlidXRlKHRoaXMub3ZlcmxheUVsZW0sIFwiYXJpYS1oaWRkZW5cIiwgIXNob3duKTtcbiAgfVxuICBzaG93T3ZlcmxheShvdmVybGF5LCBzZXJpZXNSZWN0KSB7XG4gICAgaWYgKCFvdmVybGF5LmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZWxlbWVudDIgPSBvdmVybGF5LmdldEVsZW1lbnQodGhpcy5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmxvY2FsZU1hbmFnZXIsIHNlcmllc1JlY3QpO1xuICAgIHRoaXMub3ZlcmxheUVsZW0uYXBwZW5kQ2hpbGQoZWxlbWVudDIpO1xuICB9XG4gIGhpZGVPdmVybGF5KG92ZXJsYXkpIHtcbiAgICBvdmVybGF5LnJlbW92ZUVsZW1lbnQoKCkgPT4ge1xuICAgICAgdGhpcy5vdmVybGF5RWxlbS5pbm5lclRleHQgPSBcIlxceEEwXCI7XG4gICAgfSwgdGhpcy5hbmltYXRpb25NYW5hZ2VyKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY2hhcnQudHNcbnZhciBkZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcIm9wdHNcIik7XG52YXIgU2VyaWVzQXJlYSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucGFkZGluZyA9IG5ldyBQYWRkaW5nKDApO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzQXJlYS5wcm90b3R5cGUsIFwiY2xpcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFNlcmllc0FyZWEucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgMik7XG52YXIgX0NoYXJ0ID0gY2xhc3MgX0NoYXJ0IGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHJlc291cmNlcykge1xuICAgIHZhciBfYTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLnNlcmllc1Jvb3QgPSBuZXcgVHJhbnNsYXRhYmxlR3JvdXAoe1xuICAgICAgbmFtZTogYCR7dGhpcy5pZH0tc2VyaWVzLXJvb3RgLFxuICAgICAgekluZGV4OiA1IC8qIFNFUklFU19MQVlFUiAqL1xuICAgIH0pO1xuICAgIHRoaXMuYW5ub3RhdGlvblJvb3QgPSBuZXcgVHJhbnNsYXRhYmxlR3JvdXAoe1xuICAgICAgbmFtZTogYCR7dGhpcy5pZH0tYW5ub3RhdGlvbi1yb290YCxcbiAgICAgIHpJbmRleDogOSAvKiBTRVJJRVNfQU5OT1RBVElPTiAqL1xuICAgIH0pO1xuICAgIHRoaXMudGl0bGVHcm91cCA9IG5ldyBHcm91cCh7XG4gICAgICBuYW1lOiBcInRpdGxlc1wiLFxuICAgICAgekluZGV4OiAxMyAvKiBTRVJJRVNfTEFCRUwgKi9cbiAgICB9KTtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKCk7XG4gICAgdGhpcy5leHRyYURlYnVnU3RhdHMgPSB7fTtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB0aGlzLl9maXJzdEF1dG9TaXplID0gdHJ1ZTtcbiAgICB0aGlzLl9hdXRvU2l6ZU5vdGlmeSA9IG5ldyBBc3luY0F3YWl0UXVldWUoKTtcbiAgICB0aGlzLnBhZGRpbmcgPSBuZXcgUGFkZGluZygyMCk7XG4gICAgdGhpcy5zZXJpZXNBcmVhID0gbmV3IFNlcmllc0FyZWEoKTtcbiAgICB0aGlzLmtleWJvYXJkID0gbmV3IEtleWJvYXJkKCk7XG4gICAgdGhpcy50b3VjaCA9IG5ldyBUb3VjaCgpO1xuICAgIHRoaXMubW9kZSA9IFwic3RhbmRhbG9uZVwiO1xuICAgIHRoaXMuY2hhcnRDYXB0aW9ucyA9IG5ldyBDaGFydENhcHRpb25zKCk7XG4gICAgdGhpcy5zdXBwcmVzc0ZpZWxkRG90Tm90YXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Rlc3Ryb3lGbnMgPSBbXTtcbiAgICAvLyBVc2VkIHRvIHByZXZlbnQgaW5maW5pdGUgdXBkYXRlIGxvb3BzIHdoZW4gc3luY2luZyBjaGFydHMuXG4gICAgdGhpcy5za2lwU3luYyA9IGZhbHNlO1xuICAgIHRoaXMuY2hhcnRBbmltYXRpb25QaGFzZSA9IFwiaW5pdGlhbFwiO1xuICAgIHRoaXMubW9kdWxlc01hbmFnZXIgPSBuZXcgTW9kdWxlc01hbmFnZXIoKTtcbiAgICB0aGlzLnByb2Nlc3NvcnMgPSBbXTtcbiAgICB0aGlzLnF1ZXVlZFVzZXJPcHRpb25zID0gW107XG4gICAgdGhpcy5xdWV1ZWRDaGFydE9wdGlvbnMgPSBbXTtcbiAgICB0aGlzLmZpcnN0QXBwbHkgPSB0cnVlO1xuICAgIHRoaXMuX3BlbmRpbmdGYWN0b3J5VXBkYXRlc0NvdW50ID0gMDtcbiAgICB0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMgPSBmYWxzZTtcbiAgICB0aGlzLl9wZXJmb3JtVXBkYXRlTm90aWZ5ID0gbmV3IEFzeW5jQXdhaXRRdWV1ZSgpO1xuICAgIHRoaXMucGVyZm9ybVVwZGF0ZVR5cGUgPSA3IC8qIE5PTkUgKi87XG4gICAgdGhpcy5ydW5uaW5nVXBkYXRlVHlwZSA9IDcgLyogTk9ORSAqLztcbiAgICB0aGlzLnVwZGF0ZVNob3J0Y3V0Q291bnQgPSAwO1xuICAgIHRoaXMuc2VyaWVzVG9VcGRhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMudXBkYXRlTXV0ZXggPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLnVwZGF0ZVJlcXVlc3RvcnMgPSB7fTtcbiAgICB0aGlzLnBlcmZvcm1VcGRhdGVUcmlnZ2VyID0gZGVib3VuY2VkQ2FsbGJhY2soKHsgY291bnQgfSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLnVwZGF0ZU11dGV4LmFjcXVpcmUoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMucGVyZm9ybVVwZGF0ZShjb3VudCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICAgIGxvZ2dlcl9leHBvcnRzLmVycm9yKFwidXBkYXRlIGVycm9yXCIsIGVycm9yMik7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKChlKSA9PiBsb2dnZXJfZXhwb3J0cy5lcnJvck9uY2UoZSkpO1xuICAgIH0pO1xuICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVTcGxpdHMgPSB7fTtcbiAgICB0aGlzLmF4ZXMgPSBbXTtcbiAgICB0aGlzLnNlcmllcyA9IFtdO1xuICAgIHRoaXMuX2NhY2hlZERhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5vblNlcmllc05vZGVDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgdGhpcy5maXJlRXZlbnQoeyAuLi5ldmVudCwgdHlwZTogXCJzZXJpZXNOb2RlQ2xpY2tcIiB9KTtcbiAgICB9O1xuICAgIHRoaXMub25TZXJpZXNOb2RlRG91YmxlQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KHsgLi4uZXZlbnQsIHR5cGU6IFwic2VyaWVzTm9kZURvdWJsZUNsaWNrXCIgfSk7XG4gICAgfTtcbiAgICB0aGlzLm9uU2VyaWVzVmlzaWJpbGl0eUNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgdGhpcy5maXJlRXZlbnQoZXZlbnQpO1xuICAgIH07XG4gICAgdGhpcy5zZXJpZXNHcm91cGluZ0NoYW5nZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghKGV2ZW50IGluc3RhbmNlb2YgU2VyaWVzR3JvdXBpbmdDaGFuZ2VkRXZlbnQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7IHNlcmllcywgc2VyaWVzR3JvdXBpbmcsIG9sZEdyb3VwaW5nIH0gPSBldmVudDtcbiAgICAgIGlmIChzZXJpZXMuY29udGVudEdyb3VwLmlzUm9vdCgpKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLnNlcmllc0xheWVyTWFuYWdlci5jaGFuZ2VHcm91cCh7XG4gICAgICAgIGludGVybmFsSWQ6IHNlcmllcy5pbnRlcm5hbElkLFxuICAgICAgICB0eXBlOiBzZXJpZXMudHlwZSxcbiAgICAgICAgY29udGVudEdyb3VwOiBzZXJpZXMuY29udGVudEdyb3VwLFxuICAgICAgICByZW5kZXJUb09mZnNjcmVlbkNhbnZhczogKCkgPT4gc2VyaWVzLnJlbmRlclRvT2Zmc2NyZWVuQ2FudmFzKCksXG4gICAgICAgIHNlcmllc0dyb3VwaW5nLFxuICAgICAgICBvbGRHcm91cGluZ1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmNoYXJ0T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2NlbmUgPSByZXNvdXJjZXM/LnNjZW5lO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHJlc291cmNlcz8uY29udGFpbmVyID8/IG9wdGlvbnMucHJvY2Vzc2VkT3B0aW9ucy5jb250YWluZXIgPz8gdm9pZCAwO1xuICAgIGNvbnN0IHN0eWxlQ29udGFpbmVyID0gcmVzb3VyY2VzPy5zdHlsZUNvbnRhaW5lciA/PyBvcHRpb25zLnNwZWNpYWxPdmVycmlkZXMuc3R5bGVDb250YWluZXI7XG4gICAgaWYgKHNjZW5lKSB7XG4gICAgICB0aGlzLl9maXJzdEF1dG9TaXplID0gZmFsc2U7XG4gICAgICB0aGlzLl9sYXN0QXV0b1NpemUgPSBbc2NlbmUud2lkdGgsIHNjZW5lLmhlaWdodCwgc2NlbmUucGl4ZWxSYXRpb107XG4gICAgfVxuICAgIGNvbnN0IHJvb3QgPSBuZXcgR3JvdXAoeyBuYW1lOiBcInJvb3RcIiB9KTtcbiAgICByb290LnZpc2libGUgPSBmYWxzZTtcbiAgICByb290LmFwcGVuZCh0aGlzLnNlcmllc1Jvb3QpO1xuICAgIHJvb3QuYXBwZW5kKHRoaXMuYW5ub3RhdGlvblJvb3QpO1xuICAgIHJvb3QuYXBwZW5kKHRoaXMudGl0bGVHcm91cCk7XG4gICAgdGhpcy50aXRsZUdyb3VwLmFwcGVuZCh0aGlzLnRpdGxlLm5vZGUpO1xuICAgIHRoaXMudGl0bGVHcm91cC5hcHBlbmQodGhpcy5zdWJ0aXRsZS5ub2RlKTtcbiAgICB0aGlzLnRpdGxlR3JvdXAuYXBwZW5kKHRoaXMuZm9vdG5vdGUubm9kZSk7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFRvb2x0aXAoKTtcbiAgICB0aGlzLnNlcmllc0xheWVyTWFuYWdlciA9IG5ldyBTZXJpZXNMYXllck1hbmFnZXIodGhpcy5zZXJpZXNSb290KTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLnVzZXJPcHRpb25zLm1vZGUgPz8gdGhpcy5tb2RlO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4ID0gbmV3IENoYXJ0Q29udGV4dCh0aGlzLCB7XG4gICAgICBjaGFydFR5cGU6IHRoaXMuZ2V0Q2hhcnRUeXBlKCksXG4gICAgICBzY2VuZSxcbiAgICAgIHJvb3QsXG4gICAgICBjb250YWluZXIsXG4gICAgICBzdHlsZUNvbnRhaW5lcixcbiAgICAgIHN5bmNNYW5hZ2VyOiBuZXcgU3luY01hbmFnZXIodGhpcyksXG4gICAgICBmaXJlRXZlbnQ6IChldmVudCkgPT4gdGhpcy5maXJlRXZlbnQoZXZlbnQpLFxuICAgICAgdXBkYXRlQ2FsbGJhY2s6ICh0eXBlLCBvcHRzKSA9PiB0aGlzLnVwZGF0ZSh0eXBlLCBvcHRzKSxcbiAgICAgIHVwZGF0ZU11dGV4OiB0aGlzLnVwZGF0ZU11dGV4XG4gICAgfSk7XG4gICAgdGhpcy5fZGVzdHJveUZucy5wdXNoKFxuICAgICAgY3R4LmRvbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJyZXNpemVcIiwgKCkgPT4gdGhpcy5wYXJlbnRSZXNpemUoY3R4LmRvbU1hbmFnZXIuY29udGFpbmVyU2l6ZSkpXG4gICAgKTtcbiAgICB0aGlzLm92ZXJsYXlzID0gbmV3IENoYXJ0T3ZlcmxheXMoKTtcbiAgICAoX2EgPSB0aGlzLm92ZXJsYXlzLmxvYWRpbmcpLnJlbmRlcmVyID8/IChfYS5yZW5kZXJlciA9ICgpID0+IGdldExvYWRpbmdTcGlubmVyKHRoaXMub3ZlcmxheXMubG9hZGluZy5nZXRUZXh0KGN0eC5sb2NhbGVNYW5hZ2VyKSwgY3R4LmFuaW1hdGlvbk1hbmFnZXIuZGVmYXVsdER1cmF0aW9uKSk7XG4gICAgdGhpcy5wcm9jZXNzb3JzID0gW1xuICAgICAgbmV3IERhdGFXaW5kb3dQcm9jZXNzb3IodGhpcywgY3R4LmRhdGFTZXJ2aWNlLCBjdHgudXBkYXRlU2VydmljZSwgY3R4Lnpvb21NYW5hZ2VyLCBjdHguYW5pbWF0aW9uTWFuYWdlciksXG4gICAgICBuZXcgT3ZlcmxheXNQcm9jZXNzb3IoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMub3ZlcmxheXMsXG4gICAgICAgIGN0eC5kYXRhU2VydmljZSxcbiAgICAgICAgY3R4LmxheW91dE1hbmFnZXIsXG4gICAgICAgIGN0eC5sb2NhbGVNYW5hZ2VyLFxuICAgICAgICBjdHguYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgICAgY3R4LmRvbU1hbmFnZXJcbiAgICAgIClcbiAgICBdO1xuICAgIHRoaXMuaGlnaGxpZ2h0ID0gbmV3IENoYXJ0SGlnaGxpZ2h0KCk7XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgY29uc3QgbW9kdWxlQ29udGV4dCA9IHRoaXMuZ2V0TW9kdWxlQ29udGV4dCgpO1xuICAgIGN0eC5kb21NYW5hZ2VyLnNldERhdGFCb29sZWFuKFwiYW5pbWF0aW5nXCIsIGZhbHNlKTtcbiAgICB0aGlzLnNlcmllc0FyZWFNYW5hZ2VyID0gbmV3IFNlcmllc0FyZWFNYW5hZ2VyKHRoaXMuaW5pdFNlcmllc0FyZWFEZXBlbmRlbmNpZXMoKSk7XG4gICAgdGhpcy5fZGVzdHJveUZucy5wdXNoKFxuICAgICAgY3R4LmxheW91dE1hbmFnZXIucmVnaXN0ZXJFbGVtZW50KDAgLyogQ2FwdGlvbiAqLywgKGUpID0+IHtcbiAgICAgICAgZS5sYXlvdXRCb3guc2hyaW5rKHRoaXMucGFkZGluZy50b0pzb24oKSk7XG4gICAgICAgIHRoaXMuY2hhcnRDYXB0aW9ucy5wb3NpdGlvbkNhcHRpb25zKGUpO1xuICAgICAgfSksXG4gICAgICBjdHgubGF5b3V0TWFuYWdlci5hZGRMaXN0ZW5lcihcImxheW91dDpjb21wbGV0ZVwiLCAoZSkgPT4gdGhpcy5jaGFydENhcHRpb25zLnBvc2l0aW9uQWJzb2x1dGVDYXB0aW9ucyhlKSksXG4gICAgICBjdHguZGF0YVNlcnZpY2UuYWRkTGlzdGVuZXIoXCJkYXRhLWxvYWRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICB9KSxcbiAgICAgIHRoaXMudGl0bGUucmVnaXN0ZXJJbnRlcmFjdGlvbihtb2R1bGVDb250ZXh0LCBcImJlZm9yZWJlZ2luXCIpLFxuICAgICAgdGhpcy5zdWJ0aXRsZS5yZWdpc3RlckludGVyYWN0aW9uKG1vZHVsZUNvbnRleHQsIFwiYmVmb3JlYmVnaW5cIiksXG4gICAgICB0aGlzLmZvb3Rub3RlLnJlZ2lzdGVySW50ZXJhY3Rpb24obW9kdWxlQ29udGV4dCwgXCJhZnRlcmVuZFwiKSxcbiAgICAgIFdpZGdldC5hZGRXaW5kb3dFdmVudChcInBhZ2UtbGVmdFwiLCAoKSA9PiB0aGlzLmRlc3Ryb3koKSksXG4gICAgICBjdHguYW5pbWF0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImFuaW1hdGlvbi1mcmFtZVwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlKDYgLyogU0NFTkVfUkVOREVSICovKTtcbiAgICAgIH0pLFxuICAgICAgY3R4LmFuaW1hdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJhbmltYXRpb24tc3RhcnRcIiwgKCkgPT4gY3R4LmRvbU1hbmFnZXIuc2V0RGF0YUJvb2xlYW4oXCJhbmltYXRpbmdcIiwgdHJ1ZSkpLFxuICAgICAgY3R4LmFuaW1hdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJhbmltYXRpb24tc3RvcFwiLCAoKSA9PiBjdHguZG9tTWFuYWdlci5zZXREYXRhQm9vbGVhbihcImFuaW1hdGluZ1wiLCBmYWxzZSkpLFxuICAgICAgY3R4Lnpvb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwiem9vbS1jaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLnNlcmllcy5mb3JFYWNoKChzKSA9PiBzLmFuaW1hdGlvblN0YXRlPy50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKSk7XG4gICAgICAgIGNvbnN0IHNraXBBbmltYXRpb25zID0gdGhpcy5jaGFydEFuaW1hdGlvblBoYXNlICE9PSBcImluaXRpYWxcIjtcbiAgICAgICAgdGhpcy51cGRhdGUoMyAvKiBQRVJGT1JNX0xBWU9VVCAqLywgeyBmb3JjZU5vZGVEYXRhUmVmcmVzaDogdHJ1ZSwgc2tpcEFuaW1hdGlvbnMgfSk7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5wYXJlbnRSZXNpemUoY3R4LmRvbU1hbmFnZXIuY29udGFpbmVyU2l6ZSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKGVsZW1lbnQyKSB7XG4gICAgcmV0dXJuIF9DaGFydC5jaGFydHNJbnN0YW5jZXMuZ2V0KGVsZW1lbnQyKTtcbiAgfVxuICAvKiogTk9URTogVGhpcyBpcyBleHBvc2VkIGZvciB1c2UgYnkgSW50ZWdyYXRlZCBjaGFydHMgb25seS4gKi9cbiAgZ2V0IGNhbnZhc0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3R4LnNjZW5lLmNhbnZhcy5lbGVtZW50O1xuICB9XG4gIGRvd25sb2FkKGZpbGVOYW1lLCBmaWxlRm9ybWF0KSB7XG4gICAgdGhpcy5jdHguc2NlbmUuZG93bmxvYWQoZmlsZU5hbWUsIGZpbGVGb3JtYXQpO1xuICB9XG4gIGdldENhbnZhc0RhdGFVUkwoZmlsZUZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmN0eC5zY2VuZS5nZXREYXRhVVJMKGZpbGVGb3JtYXQpO1xuICB9XG4gIHRvU1ZHKCkge1xuICAgIHJldHVybiB0aGlzLmN0eC5zY2VuZS50b1NWRygpO1xuICB9XG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWVkVXNlck9wdGlvbnMuYXQoLTEpID8/IHRoaXMuY2hhcnRPcHRpb25zLnVzZXJPcHRpb25zO1xuICB9XG4gIGdldENoYXJ0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZWRDaGFydE9wdGlvbnMuYXQoLTEpID8/IHRoaXMuY2hhcnRPcHRpb25zO1xuICB9XG4gIG92ZXJyaWRlRm9jdXNWaXNpYmxlKHZpc2libGUpIHtcbiAgICB0aGlzLnNlcmllc0FyZWFNYW5hZ2VyLmZvY3VzSW5kaWNhdG9yLm92ZXJyaWRlRm9jdXNWaXNpYmxlKHZpc2libGUpO1xuICB9XG4gIGluaXRTZXJpZXNBcmVhRGVwZW5kZW5jaWVzKCkge1xuICAgIGNvbnN0IHsgY3R4LCB0b29sdGlwLCBoaWdobGlnaHQsIG92ZXJsYXlzLCBzZXJpZXNSb290LCBtb2RlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNoYXJ0VHlwZSA9IHRoaXMuZ2V0Q2hhcnRUeXBlKCk7XG4gICAgY29uc3QgZmlyZUV2ZW50ID0gdGhpcy5maXJlRXZlbnQuYmluZCh0aGlzKTtcbiAgICBjb25zdCBnZXRVcGRhdGVUeXBlID0gKCkgPT4gdGhpcy5wZXJmb3JtVXBkYXRlVHlwZTtcbiAgICByZXR1cm4geyBmaXJlRXZlbnQsIGdldFVwZGF0ZVR5cGUsIGNoYXJ0VHlwZSwgY3R4LCB0b29sdGlwLCBoaWdobGlnaHQsIG92ZXJsYXlzLCBzZXJpZXNSb290LCBtb2RlIH07XG4gIH1cbiAgZ2V0TW9kdWxlQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdHg7XG4gIH1cbiAgZ2V0Q2FwdGlvblRleHQoKSB7XG4gICAgcmV0dXJuIFt0aGlzLnRpdGxlLCB0aGlzLnN1YnRpdGxlLCB0aGlzLmZvb3Rub3RlXS5maWx0ZXIoKGNhcHRpb24pID0+IGNhcHRpb24uZW5hYmxlZCAmJiBjYXB0aW9uLnRleHQpLm1hcCgoY2FwdGlvbikgPT4gY2FwdGlvbi50ZXh0KS5qb2luKFwiLiBcIik7XG4gIH1cbiAgZ2V0QXJpYUxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLmN0eC5sb2NhbGVNYW5hZ2VyLnQoXCJhcmlhQW5ub3VuY2VDaGFydFwiLCB7IHNlcmllc0NvdW50OiB0aGlzLnNlcmllcy5sZW5ndGggfSk7XG4gIH1cbiAgcmVzZXRBbmltYXRpb25zKCkge1xuICAgIHRoaXMuY2hhcnRBbmltYXRpb25QaGFzZSA9IFwiaW5pdGlhbFwiO1xuICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIHRoaXMuc2VyaWVzKSB7XG4gICAgICBzZXJpZXMucmVzZXRBbmltYXRpb24odGhpcy5jaGFydEFuaW1hdGlvblBoYXNlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBheGlzIG9mIHRoaXMuYXhlcykge1xuICAgICAgYXhpcy5yZXNldEFuaW1hdGlvbih0aGlzLmNoYXJ0QW5pbWF0aW9uUGhhc2UpO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvblJlY3QgPSB2b2lkIDA7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5yZXNldCgpO1xuICB9XG4gIHNraXBBbmltYXRpb25zKCkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVTa2lwQW5pbWF0aW9ucyA9IHRydWU7XG4gIH1cbiAgZGV0YWNoQW5kQ2xlYXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jdHguc2NlbmUuY2xlYXIoKTtcbiAgfVxuICBkZXN0cm95KG9wdHMpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qga2VlcFRyYW5zZmVyYWJsZVJlc291cmNlcyA9IG9wdHM/LmtlZXBUcmFuc2ZlcmFibGVSZXNvdXJjZXM7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0aGlzLnBlcmZvcm1VcGRhdGVUeXBlID0gNyAvKiBOT05FICovO1xuICAgIHRoaXMuX2Rlc3Ryb3lGbnMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICAgIHRoaXMucHJvY2Vzc29ycy5mb3JFYWNoKChwKSA9PiBwLmRlc3Ryb3koKSk7XG4gICAgdGhpcy50b29sdGlwLmRlc3Ryb3kodGhpcy5jdHguZG9tTWFuYWdlcik7XG4gICAgdGhpcy5vdmVybGF5cy5kZXN0cm95KCk7XG4gICAgdGhpcy5tb2R1bGVzTWFuYWdlci5kZXN0cm95KCk7XG4gICAgaWYgKGtlZXBUcmFuc2ZlcmFibGVSZXNvdXJjZXMpIHtcbiAgICAgIHRoaXMuY3R4LnNjZW5lLnN0cmlwKCk7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIsXG4gICAgICAgIHNjZW5lOiB0aGlzLmN0eC5zY2VuZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguc2NlbmUuZGVzdHJveSgpO1xuICAgICAgdGhpcy5jb250YWluZXIgPSB2b2lkIDA7XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveVNlcmllcyh0aGlzLnNlcmllcyk7XG4gICAgdGhpcy5zZXJpZXNMYXllck1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuYXhlcy5mb3JFYWNoKChhKSA9PiBhLmRlc3Ryb3koKSk7XG4gICAgdGhpcy5heGVzID0gW107XG4gICAgdGhpcy5hbmltYXRpb25SZWN0ID0gdm9pZCAwO1xuICAgIHRoaXMuY3R4LmRlc3Ryb3koKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlcXVlc3RGYWN0b3J5VXBkYXRlKGNiKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3BlbmRpbmdGYWN0b3J5VXBkYXRlc0NvdW50Kys7XG4gICAgdGhpcy51cGRhdGVNdXRleC5hY3F1aXJlKGFzeW5jICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY2IodGhpcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZ0ZhY3RvcnlVcGRhdGVzQ291bnQtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLmNhdGNoKChlKSA9PiBsb2dnZXJfZXhwb3J0cy5lcnJvck9uY2UoZSkpO1xuICB9XG4gIHVwZGF0ZSh0eXBlID0gMCAvKiBGVUxMICovLCBvcHRzKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGZvcmNlTm9kZURhdGFSZWZyZXNoID0gZmFsc2UsXG4gICAgICBza2lwQW5pbWF0aW9ucyxcbiAgICAgIHNlcmllc1RvVXBkYXRlID0gdGhpcy5zZXJpZXMsXG4gICAgICBuZXdBbmltYXRpb25CYXRjaFxuICAgIH0gPSBvcHRzID8/IHt9O1xuICAgIHRoaXMuY3R4LndpZGdldHMuc2VyaWVzV2lkZ2V0LnNldERyYWdUb3VjaEVuYWJsZWQodGhpcy50b3VjaC5kcmFnQWN0aW9uICE9PSBcIm5vbmVcIik7XG4gICAgaWYgKGZvcmNlTm9kZURhdGFSZWZyZXNoKSB7XG4gICAgICB0aGlzLnNlcmllcy5mb3JFYWNoKChzZXJpZXMpID0+IHNlcmllcy5tYXJrTm9kZURhdGFEaXJ0eSgpKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2Ygc2VyaWVzVG9VcGRhdGUpIHtcbiAgICAgIHRoaXMuc2VyaWVzVG9VcGRhdGUuYWRkKHNlcmllcyk7XG4gICAgfVxuICAgIGlmIChza2lwQW5pbWF0aW9ucykge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobmV3QW5pbWF0aW9uQmF0Y2ggJiYgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc0FjdGl2ZSgpKSB7XG4gICAgICB0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLnNraXBTeW5jID0gb3B0cz8uc2tpcFN5bmMgPz8gZmFsc2U7XG4gICAgaWYgKHRoaXMuZGVidWcuY2hlY2soKSkge1xuICAgICAgbGV0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2sgPz8gXCI8dW5rbm93bj5cIjtcbiAgICAgIHN0YWNrID0gc3RhY2sucmVwbGFjZSgvXFwoW14pXSovZywgXCJcIik7XG4gICAgICB0aGlzLnVwZGF0ZVJlcXVlc3RvcnNbc3RhY2tdID0gdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPCB0aGlzLnBlcmZvcm1VcGRhdGVUeXBlKSB7XG4gICAgICB0aGlzLnBlcmZvcm1VcGRhdGVUeXBlID0gdHlwZTtcbiAgICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIuc2V0RGF0YUJvb2xlYW4oXCJ1cGRhdGVQZW5kaW5nXCIsIHRydWUpO1xuICAgICAgdGhpcy5wZXJmb3JtVXBkYXRlVHJpZ2dlci5zY2hlZHVsZShvcHRzPy5iYWNrT2ZmTXMpO1xuICAgIH1cbiAgfVxuICBhc3luYyBwZXJmb3JtVXBkYXRlKGNvdW50KSB7XG4gICAgY29uc3QgeyBwZXJmb3JtVXBkYXRlVHlwZSwgZXh0cmFEZWJ1Z1N0YXRzLCBfcGVyZm9ybVVwZGF0ZVNwbGl0czogc3BsaXRzLCBjdHggfSA9IHRoaXM7XG4gICAgY29uc3Qgc2VyaWVzVG9VcGRhdGUgPSBbLi4udGhpcy5zZXJpZXNUb1VwZGF0ZV07XG4gICAgdGhpcy5wZXJmb3JtVXBkYXRlVHlwZSA9IDcgLyogTk9ORSAqLztcbiAgICB0aGlzLnNlcmllc1RvVXBkYXRlLmNsZWFyKCk7XG4gICAgdGhpcy5ydW5uaW5nVXBkYXRlVHlwZSA9IHBlcmZvcm1VcGRhdGVUeXBlO1xuICAgIGlmICh0aGlzLnVwZGF0ZVNob3J0Y3V0Q291bnQgPT09IDAgJiYgcGVyZm9ybVVwZGF0ZVR5cGUgPCA2IC8qIFNDRU5FX1JFTkRFUiAqLykge1xuICAgICAgY3R4LmFuaW1hdGlvbk1hbmFnZXIuc3RhcnRCYXRjaCh0aGlzLl9wZXJmb3JtVXBkYXRlU2tpcEFuaW1hdGlvbnMpO1xuICAgICAgY3R4LmFuaW1hdGlvbk1hbmFnZXIub25CYXRjaFN0b3AoKCkgPT4gdGhpcy5jaGFydEFuaW1hdGlvblBoYXNlID0gXCJyZWFkeVwiKTtcbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyhcIkNoYXJ0LnBlcmZvcm1VcGRhdGUoKSAtIHN0YXJ0XCIsIENoYXJ0VXBkYXRlVHlwZVtwZXJmb3JtVXBkYXRlVHlwZV0pO1xuICAgIGxldCBwcmV2aW91c1NwbGl0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgc3BsaXRzLnN0YXJ0ID8/IChzcGxpdHMuc3RhcnQgPSBwcmV2aW91c1NwbGl0KTtcbiAgICBjb25zdCB1cGRhdGVTcGxpdHMgPSAoc3BsaXROYW1lKSA9PiB7XG4gICAgICBzcGxpdHNbc3BsaXROYW1lXSA/PyAoc3BsaXRzW3NwbGl0TmFtZV0gPSAwKTtcbiAgICAgIHNwbGl0c1tzcGxpdE5hbWVdICs9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJldmlvdXNTcGxpdDtcbiAgICAgIHByZXZpb3VzU3BsaXQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICAgIHN3aXRjaCAocGVyZm9ybVVwZGF0ZVR5cGUpIHtcbiAgICAgIGNhc2UgMCAvKiBGVUxMICovOlxuICAgICAgICBpZiAodGhpcy5jaGVja1VwZGF0ZVNob3J0Y3V0KDAgLyogRlVMTCAqLykpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIHRoaXMuY3R4LnVwZGF0ZVNlcnZpY2UuZGlzcGF0Y2hQcmVEb21VcGRhdGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVET00oKTtcbiAgICAgIGNhc2UgMSAvKiBVUERBVEVfREFUQSAqLzpcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tVcGRhdGVTaG9ydGN1dCgxIC8qIFVQREFURV9EQVRBICovKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgICAgIHVwZGF0ZVNwbGl0cyhcIlxcdTJCMDdcXHVGRTBGXCIpO1xuICAgICAgY2FzZSAyIC8qIFBST0NFU1NfREFUQSAqLzpcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tVcGRhdGVTaG9ydGN1dCgyIC8qIFBST0NFU1NfREFUQSAqLykpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0RhdGEoKTtcbiAgICAgICAgdGhpcy5zZXJpZXNBcmVhTWFuYWdlci5kYXRhQ2hhbmdlZCgpO1xuICAgICAgICB1cGRhdGVTcGxpdHMoXCJcXHV7MUYzRUR9XCIpO1xuICAgICAgY2FzZSAzIC8qIFBFUkZPUk1fTEFZT1VUICovOlxuICAgICAgICBhd2FpdCB0aGlzLmNoZWNrRmlyc3RBdXRvU2l6ZSgpO1xuICAgICAgICBpZiAodGhpcy5jaGVja1VwZGF0ZVNob3J0Y3V0KDMgLyogUEVSRk9STV9MQVlPVVQgKi8pKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NMYXlvdXQoKTtcbiAgICAgICAgdXBkYXRlU3BsaXRzKFwiXFx1MjMxNlwiKTtcbiAgICAgIGNhc2UgNCAvKiBTRVJJRVNfVVBEQVRFICovOiB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrVXBkYXRlU2hvcnRjdXQoNCAvKiBTRVJJRVNfVVBEQVRFICovKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVTZXJpZXMoc2VyaWVzVG9VcGRhdGUpO1xuICAgICAgICB1cGRhdGVTcGxpdHMoXCJcXHV7MUY5MTR9XCIpO1xuICAgICAgICB0aGlzLnVwZGF0ZUFyaWFMYWJlbHMoKTtcbiAgICAgICAgdGhpcy5zZXJpZXNMYXllck1hbmFnZXIudXBkYXRlTGF5ZXJDb21wb3NpdGluZygpO1xuICAgICAgfVxuICAgICAgY2FzZSA1IC8qIFBSRV9TQ0VORV9SRU5ERVIgKi86XG4gICAgICAgIGlmICh0aGlzLmNoZWNrVXBkYXRlU2hvcnRjdXQoNSAvKiBQUkVfU0NFTkVfUkVOREVSICovKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY3R4LnVwZGF0ZVNlcnZpY2UuZGlzcGF0Y2hQcmVTY2VuZVJlbmRlcigpO1xuICAgICAgICB1cGRhdGVTcGxpdHMoXCJcXHUyMTk2XCIpO1xuICAgICAgY2FzZSA2IC8qIFNDRU5FX1JFTkRFUiAqLzpcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tVcGRhdGVTaG9ydGN1dCg2IC8qIFNDRU5FX1JFTkRFUiAqLykpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGN0eC5hbmltYXRpb25NYW5hZ2VyLmVuZEJhdGNoKCk7XG4gICAgICAgIGV4dHJhRGVidWdTdGF0c1tcInVwZGF0ZVNob3J0Y3V0Q291bnRcIl0gPSB0aGlzLnVwZGF0ZVNob3J0Y3V0Q291bnQ7XG4gICAgICAgIGN0eC5zY2VuZS5yZW5kZXIoeyBkZWJ1Z1NwbGl0VGltZXM6IHNwbGl0cywgZXh0cmFEZWJ1Z1N0YXRzLCBzZXJpZXNSZWN0OiB0aGlzLnNlcmllc1JlY3QgfSk7XG4gICAgICAgIHRoaXMuZXh0cmFEZWJ1Z1N0YXRzID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNwbGl0cykpIHtcbiAgICAgICAgICBkZWxldGUgc3BsaXRzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdHguZG9tTWFuYWdlci5pbmNyZW1lbnREYXRhQ291bnRlcihcInNjZW5lUmVuZGVyc1wiKTtcbiAgICAgIGNhc2UgNyAvKiBOT05FICovOlxuICAgICAgICB0aGlzLnVwZGF0ZVNob3J0Y3V0Q291bnQgPSAwO1xuICAgICAgICB0aGlzLnVwZGF0ZVJlcXVlc3RvcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fcGVyZm9ybVVwZGF0ZVNraXBBbmltYXRpb25zID0gZmFsc2U7XG4gICAgICAgIGN0eC5hbmltYXRpb25NYW5hZ2VyLmVuZEJhdGNoKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIGN0eC51cGRhdGVTZXJ2aWNlLmRpc3BhdGNoVXBkYXRlQ29tcGxldGUoKTtcbiAgICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIuc2V0RGF0YUJvb2xlYW4oXCJ1cGRhdGVQZW5kaW5nXCIsIGZhbHNlKTtcbiAgICAgIHRoaXMucnVubmluZ1VwZGF0ZVR5cGUgPSA3IC8qIE5PTkUgKi87XG4gICAgfVxuICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVOb3RpZnkubm90aWZ5KCk7XG4gICAgY29uc3QgZW5kMiA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMuZGVidWcoXCJDaGFydC5wZXJmb3JtVXBkYXRlKCkgLSBlbmRcIiwge1xuICAgICAgY2hhcnQ6IHRoaXMsXG4gICAgICBkdXJhdGlvbk1zOiBNYXRoLnJvdW5kKChlbmQyIC0gc3BsaXRzW1wic3RhcnRcIl0pICogMTAwKSAvIDEwMCxcbiAgICAgIGNvdW50LFxuICAgICAgcGVyZm9ybVVwZGF0ZVR5cGU6IENoYXJ0VXBkYXRlVHlwZVtwZXJmb3JtVXBkYXRlVHlwZV1cbiAgICB9KTtcbiAgfVxuICB1cGRhdGVUaGVtZUNsYXNzTmFtZSgpIHtcbiAgICBjb25zdCB0aGVtZUNsYXNzTmFtZVByZWZpeCA9IFwiYWctY2hhcnRzLXRoZW1lLVwiO1xuICAgIGNvbnN0IHZhbGlkVGhlbWVDbGFzc05hbWVzID0gW2Ake3RoZW1lQ2xhc3NOYW1lUHJlZml4fWRlZmF1bHRgLCBgJHt0aGVtZUNsYXNzTmFtZVByZWZpeH1kZWZhdWx0LWRhcmtgXTtcbiAgICBsZXQgdGhlbWVDbGFzc05hbWUgPSB2YWxpZFRoZW1lQ2xhc3NOYW1lc1swXTtcbiAgICBsZXQgaXNEYXJrID0gZmFsc2U7XG4gICAgbGV0IHsgdGhlbWUgfSA9IHRoaXMuY2hhcnRPcHRpb25zLnByb2Nlc3NlZE9wdGlvbnM7XG4gICAgd2hpbGUgKHR5cGVvZiB0aGVtZSAhPT0gXCJzdHJpbmdcIiAmJiB0aGVtZSAhPSBudWxsKSB7XG4gICAgICB0aGVtZSA9IHRoZW1lLmJhc2VUaGVtZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhlbWVDbGFzc05hbWUgPSB0aGVtZS5yZXBsYWNlKFwiYWctXCIsIHRoZW1lQ2xhc3NOYW1lUHJlZml4KTtcbiAgICAgIGlzRGFyayA9IHRoZW1lLmluY2x1ZGVzKFwiLWRhcmtcIik7XG4gICAgfVxuICAgIGlmICghdmFsaWRUaGVtZUNsYXNzTmFtZXMuaW5jbHVkZXModGhlbWVDbGFzc05hbWUpKSB7XG4gICAgICB0aGVtZUNsYXNzTmFtZSA9IGlzRGFyayA/IHZhbGlkVGhlbWVDbGFzc05hbWVzWzFdIDogdmFsaWRUaGVtZUNsYXNzTmFtZXNbMF07XG4gICAgfVxuICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIuc2V0VGhlbWVDbGFzcyh0aGVtZUNsYXNzTmFtZSk7XG4gIH1cbiAgdXBkYXRlRE9NKCkge1xuICAgIHRoaXMudXBkYXRlVGhlbWVDbGFzc05hbWUoKTtcbiAgICBjb25zdCB7IGVuYWJsZWQsIHRhYkluZGV4IH0gPSB0aGlzLmtleWJvYXJkO1xuICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIuc2V0VGFiR3VhcmRJbmRleChlbmFibGVkID8gdGFiSW5kZXggPz8gMCA6IC0xKTtcbiAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnNldFRoZW1lUGFyYW1ldGVycyh0aGlzLmNoYXJ0T3B0aW9ucy50aGVtZVBhcmFtZXRlcnMpO1xuICB9XG4gIHVwZGF0ZUFyaWFMYWJlbHMoKSB7XG4gICAgdGhpcy5jdHguZG9tTWFuYWdlci51cGRhdGVDYW52YXNMYWJlbCh0aGlzLmdldEFyaWFMYWJlbCgpKTtcbiAgfVxuICBjaGVja1VwZGF0ZVNob3J0Y3V0KGNoZWNrVXBkYXRlVHlwZSkge1xuICAgIGNvbnN0IG1heFNob3J0Y3V0cyA9IDM7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMudXBkYXRlU2hvcnRjdXRDb3VudCA+IG1heFNob3J0Y3V0cykge1xuICAgICAgbG9nZ2VyX2V4cG9ydHMud2FybihcbiAgICAgICAgYGV4Y2VlZGVkIHRoZSBtYXhpbXVtIG51bWJlciBvZiBzaW11bHRhbmVvdXMgdXBkYXRlcyAoJHttYXhTaG9ydGN1dHMgKyAxfSksIGRpc2NhcmRpbmcgY2hhbmdlcyBhbmQgcmVuZGVyaW5nYCxcbiAgICAgICAgdGhpcy51cGRhdGVSZXF1ZXN0b3JzXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5wZXJmb3JtVXBkYXRlVHlwZSA8PSBjaGVja1VwZGF0ZVR5cGUpIHtcbiAgICAgIHRoaXMudXBkYXRlU2hvcnRjdXRDb3VudCsrO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyBjaGVja0ZpcnN0QXV0b1NpemUoKSB7XG4gICAgaWYgKHRoaXMud2lkdGggIT0gbnVsbCAmJiB0aGlzLmhlaWdodCAhPSBudWxsKSB7XG4gICAgfSBlbHNlIGlmICghdGhpcy5fbGFzdEF1dG9TaXplKSB7XG4gICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5fYXV0b1NpemVOb3RpZnkuYXdhaXQoNTAwKTtcbiAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICB0aGlzLmRlYnVnKFwiQ2hhcnQuY2hlY2tGaXJzdEF1dG9TaXplKCkgLSB0aW1lb3V0IGZvciBmaXJzdCBzaXplIHVwZGF0ZS5cIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uQXhpc0NoYW5nZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICBpZiAob2xkVmFsdWUgPT0gbnVsbCAmJiBuZXdWYWx1ZS5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jdHguYXhpc01hbmFnZXIudXBkYXRlQXhlcyhvbGRWYWx1ZSA/PyBbXSwgbmV3VmFsdWUpO1xuICB9XG4gIG9uU2VyaWVzQ2hhbmdlKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIGNvbnN0IHNlcmllc1RvRGVzdHJveSA9IG9sZFZhbHVlPy5maWx0ZXIoKHNlcmllcykgPT4gIW5ld1ZhbHVlLmluY2x1ZGVzKHNlcmllcykpID8/IFtdO1xuICAgIHRoaXMuZGVzdHJveVNlcmllcyhzZXJpZXNUb0Rlc3Ryb3kpO1xuICAgIHRoaXMuc2VyaWVzTGF5ZXJNYW5hZ2VyPy5zZXRTZXJpZXNDb3VudChuZXdWYWx1ZS5sZW5ndGgpO1xuICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIG5ld1ZhbHVlKSB7XG4gICAgICBpZiAob2xkVmFsdWU/LmluY2x1ZGVzKHNlcmllcykpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3Qgc2VyaWVzQ29udGVudE5vZGUgPSB0aGlzLnNlcmllc0xheWVyTWFuYWdlci5yZXF1ZXN0R3JvdXAoc2VyaWVzKTtcbiAgICAgIHNlcmllcy5hdHRhY2hTZXJpZXMoc2VyaWVzQ29udGVudE5vZGUsIHRoaXMuc2VyaWVzUm9vdCwgdGhpcy5hbm5vdGF0aW9uUm9vdCk7XG4gICAgICBjb25zdCBjaGFydCA9IHRoaXM7XG4gICAgICBzZXJpZXMuY2hhcnQgPSB7XG4gICAgICAgIGdldCBtb2RlKCkge1xuICAgICAgICAgIHJldHVybiBjaGFydC5tb2RlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaXNNaW5pQ2hhcnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgc2VyaWVzUmVjdCgpIHtcbiAgICAgICAgICByZXR1cm4gY2hhcnQuc2VyaWVzUmVjdDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNlcmllcy5yZXNldEFuaW1hdGlvbih0aGlzLmNoYXJ0QW5pbWF0aW9uUGhhc2UpO1xuICAgICAgdGhpcy5hZGRTZXJpZXNMaXN0ZW5lcnMoc2VyaWVzKTtcbiAgICAgIHNlcmllcy5hZGRDaGFydEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHRoaXMuc2VyaWVzQXJlYU1hbmFnZXI/LnNlcmllc0NoYW5nZWQobmV3VmFsdWUpO1xuICB9XG4gIGRlc3Ryb3lTZXJpZXMoYWxsU2VyaWVzKSB7XG4gICAgYWxsU2VyaWVzPy5mb3JFYWNoKChzZXJpZXMpID0+IHtcbiAgICAgIHNlcmllcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibm9kZUNsaWNrXCIsIHRoaXMub25TZXJpZXNOb2RlQ2xpY2spO1xuICAgICAgc2VyaWVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJub2RlRG91YmxlQ2xpY2tcIiwgdGhpcy5vblNlcmllc05vZGVEb3VibGVDbGljayk7XG4gICAgICBzZXJpZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImdyb3VwaW5nQ2hhbmdlZFwiLCB0aGlzLnNlcmllc0dyb3VwaW5nQ2hhbmdlZCk7XG4gICAgICBzZXJpZXMuZGVzdHJveSgpO1xuICAgICAgdGhpcy5zZXJpZXNMYXllck1hbmFnZXIucmVsZWFzZUdyb3VwKHNlcmllcyk7XG4gICAgICBzZXJpZXMuZGV0YWNoU2VyaWVzKHZvaWQgMCwgdGhpcy5zZXJpZXNSb290LCB0aGlzLmFubm90YXRpb25Sb290KTtcbiAgICAgIHNlcmllcy5jaGFydCA9IHZvaWQgMDtcbiAgICB9KTtcbiAgfVxuICBhZGRTZXJpZXNMaXN0ZW5lcnMoc2VyaWVzKSB7XG4gICAgaWYgKHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcInNlcmllc05vZGVDbGlja1wiKSkge1xuICAgICAgc2VyaWVzLmFkZEV2ZW50TGlzdGVuZXIoXCJub2RlQ2xpY2tcIiwgdGhpcy5vblNlcmllc05vZGVDbGljayk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJzZXJpZXNOb2RlRG91YmxlQ2xpY2tcIikpIHtcbiAgICAgIHNlcmllcy5hZGRFdmVudExpc3RlbmVyKFwibm9kZURvdWJsZUNsaWNrXCIsIHRoaXMub25TZXJpZXNOb2RlRG91YmxlQ2xpY2spO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNFdmVudExpc3RlbmVyKFwic2VyaWVzVmlzaWJpbGl0eUNoYW5nZVwiKSkge1xuICAgICAgc2VyaWVzLmFkZEV2ZW50TGlzdGVuZXIoXCJzZXJpZXNWaXNpYmlsaXR5Q2hhbmdlXCIsIHRoaXMub25TZXJpZXNWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICB9XG4gICAgc2VyaWVzLmFkZEV2ZW50TGlzdGVuZXIoXCJncm91cGluZ0NoYW5nZWRcIiwgdGhpcy5zZXJpZXNHcm91cGluZ0NoYW5nZWQpO1xuICB9XG4gIGFzc2lnblNlcmllc1RvQXhlcygpIHtcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgdGhpcy5heGVzKSB7XG4gICAgICBheGlzLmJvdW5kU2VyaWVzID0gdGhpcy5zZXJpZXMuZmlsdGVyKChzKSA9PiBzLmF4ZXNbYXhpcy5kaXJlY3Rpb25dID09PSBheGlzKTtcbiAgICB9XG4gIH1cbiAgYXNzaWduQXhlc1RvU2VyaWVzKCkge1xuICAgIGNvbnN0IGRpcmVjdGlvblRvQXhlc01hcCA9IGdyb3VwQnkodGhpcy5heGVzLCAoYXhpcykgPT4gYXhpcy5kaXJlY3Rpb24pO1xuICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIHRoaXMuc2VyaWVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGRpcmVjdGlvbiBvZiBzZXJpZXMuZGlyZWN0aW9ucykge1xuICAgICAgICBjb25zdCBkaXJlY3Rpb25BeGVzID0gZGlyZWN0aW9uVG9BeGVzTWFwW2RpcmVjdGlvbl07XG4gICAgICAgIGlmICghZGlyZWN0aW9uQXhlcykge1xuICAgICAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKFxuICAgICAgICAgICAgYG5vIGF2YWlsYWJsZSBheGlzIGZvciBkaXJlY3Rpb24gWyR7ZGlyZWN0aW9ufV07IGNoZWNrIHNlcmllcyBhbmQgYXhlcyBjb25maWd1cmF0aW9uLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJpZXNLZXlzID0gc2VyaWVzLmdldEtleXMoZGlyZWN0aW9uKTtcbiAgICAgICAgY29uc3QgbmV3QXhpcyA9IGRpcmVjdGlvbkF4ZXMuZmluZChcbiAgICAgICAgICAoYXhpcykgPT4gIWF4aXMua2V5cy5sZW5ndGggfHwgc2VyaWVzS2V5cy5zb21lKChrZXkpID0+IGF4aXMua2V5cy5pbmNsdWRlcyhrZXkpKVxuICAgICAgICApO1xuICAgICAgICBpZiAoIW5ld0F4aXMpIHtcbiAgICAgICAgICBsb2dnZXJfZXhwb3J0cy53YXJuT25jZShcbiAgICAgICAgICAgIGBubyBtYXRjaGluZyBheGlzIGZvciBkaXJlY3Rpb24gWyR7ZGlyZWN0aW9ufV0gYW5kIGtleXMgWyR7c2VyaWVzS2V5c31dOyBjaGVjayBzZXJpZXMgYW5kIGF4ZXMgY29uZmlndXJhdGlvbi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VyaWVzLmF4ZXNbZGlyZWN0aW9uXSA9IG5ld0F4aXM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhcmVudFJlc2l6ZShzaXplKSB7XG4gICAgaWYgKHNpemUgPT0gbnVsbCB8fCB0aGlzLndpZHRoICE9IG51bGwgJiYgdGhpcy5oZWlnaHQgIT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IHNpemU7XG4gICAgY29uc3QgeyBwaXhlbFJhdGlvIH0gPSBzaXplO1xuICAgIHdpZHRoMiA9IE1hdGguZmxvb3Iod2lkdGgyKTtcbiAgICBoZWlnaHQyID0gTWF0aC5mbG9vcihoZWlnaHQyKTtcbiAgICBpZiAod2lkdGgyID09PSAwICYmIGhlaWdodDIgPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW2F1dG9XaWR0aCA9IDAsIGF1dG9IZWlnaHQgPSAwLCBhdXRvUGl4ZWxSYXRpbyA9IDFdID0gdGhpcy5fbGFzdEF1dG9TaXplID8/IFtdO1xuICAgIGlmIChhdXRvV2lkdGggPT09IHdpZHRoMiAmJiBhdXRvSGVpZ2h0ID09PSBoZWlnaHQyICYmIGF1dG9QaXhlbFJhdGlvID09PSBwaXhlbFJhdGlvKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2xhc3RBdXRvU2l6ZSA9IFt3aWR0aDIsIGhlaWdodDIsIHBpeGVsUmF0aW9dO1xuICAgIHRoaXMucmVzaXplKFwiU2l6ZU1vbml0b3JcIiwge30pO1xuICB9XG4gIHJlc2l6ZShzb3VyY2UsIG9wdHMpIHtcbiAgICBjb25zdCB7IHNjZW5lLCBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7IGluV2lkdGgsIGluSGVpZ2h0LCBpbk1pbldpZHRoLCBpbk1pbkhlaWdodCwgaW5PdmVycmlkZURldmljZVBpeGVsUmF0aW8gfSA9IG9wdHM7XG4gICAgdGhpcy5jdHguZG9tTWFuYWdlci5zZXRTaXplT3B0aW9ucyhcbiAgICAgIGluTWluV2lkdGggPz8gdGhpcy5taW5XaWR0aCxcbiAgICAgIGluTWluSGVpZ2h0ID8/IHRoaXMubWluSGVpZ2h0LFxuICAgICAgaW5XaWR0aCA/PyB0aGlzLndpZHRoLFxuICAgICAgaW5IZWlnaHQgPz8gdGhpcy5oZWlnaHRcbiAgICApO1xuICAgIGNvbnN0IHdpZHRoMiA9IGluV2lkdGggPz8gdGhpcy53aWR0aCA/PyB0aGlzLl9sYXN0QXV0b1NpemU/LlswXTtcbiAgICBjb25zdCBoZWlnaHQyID0gaW5IZWlnaHQgPz8gdGhpcy5oZWlnaHQgPz8gdGhpcy5fbGFzdEF1dG9TaXplPy5bMV07XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IGluT3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvID8/IHRoaXMub3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvID8/IHRoaXMuX2xhc3RBdXRvU2l6ZT8uWzJdO1xuICAgIHRoaXMuZGVidWcoYENoYXJ0LnJlc2l6ZSgpIGZyb20gJHtzb3VyY2V9YCwgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIHBpeGVsUmF0aW8sIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayB9KTtcbiAgICBpZiAod2lkdGgyID09IG51bGwgfHwgaGVpZ2h0MiA9PSBudWxsIHx8ICFpc0Zpbml0ZU51bWJlcih3aWR0aDIpIHx8ICFpc0Zpbml0ZU51bWJlcihoZWlnaHQyKSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoc2NlbmUucmVzaXplKHdpZHRoMiwgaGVpZ2h0MiwgcGl4ZWxSYXRpbykpIHtcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIucmVzZXQoKTtcbiAgICAgIGxldCBza2lwQW5pbWF0aW9ucyA9IHRydWU7XG4gICAgICBpZiAoKHRoaXMud2lkdGggPT0gbnVsbCB8fCB0aGlzLmhlaWdodCA9PSBudWxsKSAmJiB0aGlzLl9maXJzdEF1dG9TaXplKSB7XG4gICAgICAgIHNraXBBbmltYXRpb25zID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZpcnN0QXV0b1NpemUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlKDMgLyogUEVSRk9STV9MQVlPVVQgKi8sIHsgZm9yY2VOb2RlRGF0YVJlZnJlc2g6IHRydWUsIHNraXBBbmltYXRpb25zIH0pO1xuICAgICAgdGhpcy5fYXV0b1NpemVOb3RpZnkubm90aWZ5KCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHVwZGF0ZURhdGEoKSB7XG4gICAgdGhpcy5zZXJpZXMuZm9yRWFjaCgocykgPT4gcy5zZXRDaGFydERhdGEodGhpcy5kYXRhKSk7XG4gICAgY29uc3QgbW9kdWxlUHJvbWlzZXMgPSB0aGlzLm1vZHVsZXNNYW5hZ2VyLm1hcE1vZHVsZXMoKG0pID0+IG0udXBkYXRlRGF0YT8uKHRoaXMuZGF0YSkpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKG1vZHVsZVByb21pc2VzKTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YSgpIHtcbiAgICBpZiAodGhpcy5zZXJpZXMuc29tZSgocykgPT4gcy5jYW5IYXZlQXhlcykpIHtcbiAgICAgIHRoaXMuYXNzaWduQXhlc1RvU2VyaWVzKCk7XG4gICAgICB0aGlzLmFzc2lnblNlcmllc1RvQXhlcygpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhQ29udHJvbGxlciA9IG5ldyBEYXRhQ29udHJvbGxlcih0aGlzLm1vZGUsIHRoaXMuc3VwcHJlc3NGaWVsZERvdE5vdGF0aW9uKTtcbiAgICBjb25zdCBzZXJpZXNQcm9taXNlcyA9IHRoaXMuc2VyaWVzLm1hcCgocykgPT4ge1xuICAgICAgcy5yZXNldERhdHVtQ2FsbGJhY2tDYWNoZSgpO1xuICAgICAgcmV0dXJuIHMucHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpO1xuICAgIH0pO1xuICAgIGNvbnN0IG1vZHVsZVByb21pc2VzID0gdGhpcy5tb2R1bGVzTWFuYWdlci5tYXBNb2R1bGVzKChtKSA9PiBtLnByb2Nlc3NEYXRhPy4oZGF0YUNvbnRyb2xsZXIpKTtcbiAgICB0aGlzLl9jYWNoZWREYXRhID0gZGF0YUNvbnRyb2xsZXIuZXhlY3V0ZSh0aGlzLl9jYWNoZWREYXRhKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbLi4uc2VyaWVzUHJvbWlzZXMsIC4uLm1vZHVsZVByb21pc2VzXSk7XG4gICAgZm9yIChjb25zdCBheGlzIG9mIHRoaXMuYXhlcykge1xuICAgICAgYXhpcy5wcm9jZXNzRGF0YSgpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUxlZ2VuZHMoKTtcbiAgfVxuICB1cGRhdGVMZWdlbmRzKGluaXRpYWxTdGF0ZUxlZ2VuZCkge1xuICAgIGZvciAoY29uc3QgeyBsZWdlbmQsIGxlZ2VuZFR5cGUgfSBvZiB0aGlzLm1vZHVsZXNNYW5hZ2VyLmxlZ2VuZHMoKSkge1xuICAgICAgaWYgKGxlZ2VuZFR5cGUgPT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgICB0aGlzLnNldENhdGVnb3J5TGVnZW5kRGF0YShpbml0aWFsU3RhdGVMZWdlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUsIGxlZ2VuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldENhdGVnb3J5TGVnZW5kRGF0YShpbml0aWFsU3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qge1xuICAgICAgY3R4OiB7IGxlZ2VuZE1hbmFnZXIsIHN0YXRlTWFuYWdlciB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGluaXRpYWxTdGF0ZSkge1xuICAgICAgdGhpcy5zZXJpZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICBjb25zdCBzZXJpZXNTdGF0ZSA9IGluaXRpYWxTdGF0ZS5maW5kKChpbml0KSA9PiBpbml0LnNlcmllc0lkID09PSBzLmlkKTtcbiAgICAgICAgcy5vbkxlZ2VuZEluaXRpYWxTdGF0ZShcImNhdGVnb3J5XCIsIHNlcmllc1N0YXRlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBsZWdlbmREYXRhID0gdGhpcy5zZXJpZXMuZmxhdE1hcCgocykgPT4ge1xuICAgICAgY29uc3Qgc2VyaWVzTGVnZW5kRGF0YSA9IHMuZ2V0TGVnZW5kRGF0YShcImNhdGVnb3J5XCIpO1xuICAgICAgbGVnZW5kTWFuYWdlci51cGRhdGVEYXRhKHMuaWQsIHNlcmllc0xlZ2VuZERhdGEpO1xuICAgICAgcmV0dXJuIHNlcmllc0xlZ2VuZERhdGE7XG4gICAgfSk7XG4gICAgaWYgKGluaXRpYWxTdGF0ZSkge1xuICAgICAgc3RhdGVNYW5hZ2VyLnNldFN0YXRlQW5kUmVzdG9yZShsZWdlbmRNYW5hZ2VyLCBpbml0aWFsU3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RlICE9PSBcImludGVncmF0ZWRcIikge1xuICAgICAgY29uc3Qgc2VyaWVzTWFya2VyRmlsbHMgPSB7fTtcbiAgICAgIGNvbnN0IHNlcmllc1R5cGVNYXAgPSBuZXcgTWFwKHRoaXMuc2VyaWVzLm1hcCgocykgPT4gW3MuaWQsIHMudHlwZV0pKTtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgc3ltYm9sOiB7IG1hcmtlciB9LFxuICAgICAgICBsYWJlbFxuICAgICAgfSBvZiBsZWdlbmREYXRhLmZpbHRlcigoZCkgPT4gIWQuaGlkZUluTGVnZW5kKSkge1xuICAgICAgICBpZiAobWFya2VyLmZpbGwgPT0gbnVsbClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3Qgc2VyaWVzVHlwZSA9IHNlcmllc1R5cGVNYXAuZ2V0KHNlcmllc0lkKTtcbiAgICAgICAgY29uc3QgbWFya2VyRmlsbCA9IHNlcmllc01hcmtlckZpbGxzW3Nlcmllc1R5cGVdID8/IChzZXJpZXNNYXJrZXJGaWxsc1tzZXJpZXNUeXBlXSA9IHt9KTtcbiAgICAgICAgbWFya2VyRmlsbFtfYSA9IGxhYmVsLnRleHRdID8/IChtYXJrZXJGaWxsW19hXSA9IG1hcmtlci5maWxsKTtcbiAgICAgICAgaWYgKG1hcmtlckZpbGxbbGFiZWwudGV4dF0gIT09IG1hcmtlci5maWxsKSB7XG4gICAgICAgICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoXG4gICAgICAgICAgICBgbGVnZW5kIGl0ZW0gJyR7bGFiZWwudGV4dH0nIGhhcyBtdWx0aXBsZSBmaWxsIGNvbG9ycywgdGhpcyBtYXkgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvdXIuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGVnZW5kTWFuYWdlci51cGRhdGUoKTtcbiAgfVxuICBzZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUsIGxlZ2VuZCkge1xuICAgIGxlZ2VuZC5kYXRhID0gdGhpcy5zZXJpZXMuZmlsdGVyKChzKSA9PiBzLnByb3BlcnRpZXMuc2hvd0luTGVnZW5kKS5mbGF0TWFwKChzKSA9PiBzLmdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkpO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NMYXlvdXQoKSB7XG4gICAgY29uc3Qgb2xkUmVjdCA9IHRoaXMuYW5pbWF0aW9uUmVjdDtcbiAgICBjb25zdCB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gdGhpcy5jdHguc2NlbmU7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHgubGF5b3V0TWFuYWdlci5jcmVhdGVDb250ZXh0KHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgYXdhaXQgdGhpcy5wZXJmb3JtTGF5b3V0KGN0eCk7XG4gICAgaWYgKG9sZFJlY3QgJiYgIXRoaXMuYW5pbWF0aW9uUmVjdD8uZXF1YWxzKG9sZFJlY3QpKSB7XG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyhcIkNoYXJ0LnBlcmZvcm1VcGRhdGUoKSAtIHNlcmllc1JlY3RcIiwgdGhpcy5zZXJpZXNSZWN0KTtcbiAgfVxuICBhc3luYyB1cGRhdGVTZXJpZXMoc2VyaWVzVG9VcGRhdGUpIHtcbiAgICBjb25zdCB7IHNlcmllc1JlY3QgfSA9IHRoaXM7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoc2VyaWVzVG9VcGRhdGUubWFwKChzZXJpZXMpID0+IHNlcmllcy51cGRhdGUoeyBzZXJpZXNSZWN0IH0pKSk7XG4gICAgdGhpcy5jdHguc2VyaWVzTGFiZWxMYXlvdXRNYW5hZ2VyLnVwZGF0ZUxhYmVscyhcbiAgICAgIHRoaXMuc2VyaWVzLmZpbHRlcigocykgPT4gcy52aXNpYmxlICYmIHMudXNlc1BsYWNlZExhYmVscyksXG4gICAgICB0aGlzLnBhZGRpbmcsXG4gICAgICB0aGlzLnNlcmllc1JlY3RcbiAgICApO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JVcGRhdGUodGltZW91dE1zID0gMWU0LCBmYWlsT25UaW1lb3V0ID0gZmFsc2UpIHtcbiAgICBjb25zdCBzdGFydDIgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB3aGlsZSAodGhpcy5fcGVuZGluZ0ZhY3RvcnlVcGRhdGVzQ291bnQgPiAwIHx8IHRoaXMucGVyZm9ybVVwZGF0ZVR5cGUgIT09IDcgLyogTk9ORSAqLyB8fCB0aGlzLnJ1bm5pbmdVcGRhdGVUeXBlICE9PSA3IC8qIE5PTkUgKi8pIHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAodGhpcy5fcGVuZGluZ0ZhY3RvcnlVcGRhdGVzQ291bnQgPiAwKSB7XG4gICAgICAgIGF3YWl0IHRoaXMudXBkYXRlTXV0ZXgud2FpdEZvckNsZWFyQWNxdWlyZVF1ZXVlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wZXJmb3JtVXBkYXRlVHlwZSAhPT0gNyAvKiBOT05FICovIHx8IHRoaXMucnVubmluZ1VwZGF0ZVR5cGUgIT09IDcgLyogTk9ORSAqLykge1xuICAgICAgICBhd2FpdCB0aGlzLl9wZXJmb3JtVXBkYXRlTm90aWZ5LmF3YWl0KCk7XG4gICAgICB9XG4gICAgICBpZiAocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydDIgPiB0aW1lb3V0TXMpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBDaGFydC53YWl0Rm9yVXBkYXRlKCkgdGltZW91dCBvZiAke3RpbWVvdXRNc30gcmVhY2hlZCAtIGZpcnN0IGNoYXJ0IHVwZGF0ZSB0YWtpbmcgdG9vIGxvbmcuYDtcbiAgICAgICAgaWYgKGZhaWxPblRpbWVvdXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0lucHV0UGVuZGluZygpKSB7XG4gICAgICAgIGF3YWl0IHBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbHRlck1pbmlDaGFydFNlcmllcyhzZXJpZXMpIHtcbiAgICByZXR1cm4gc2VyaWVzPy5maWx0ZXIoKHMpID0+IHMuc2hvd0luTWluaUNoYXJ0ICE9PSBmYWxzZSk7XG4gIH1cbiAgYXBwbHlPcHRpb25zKG5ld0NoYXJ0T3B0aW9ucykge1xuICAgIGNvbnN0IGRlbHRhT3B0aW9ucyA9IHRoaXMuZmlyc3RBcHBseSA/IG5ld0NoYXJ0T3B0aW9ucy5wcm9jZXNzZWRPcHRpb25zIDogbmV3Q2hhcnRPcHRpb25zLmRpZmZPcHRpb25zKHRoaXMuY2hhcnRPcHRpb25zKTtcbiAgICBpZiAoZGVsdGFPcHRpb25zID09IG51bGwgfHwgT2JqZWN0LmtleXMoZGVsdGFPcHRpb25zKS5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgb2xkT3B0cyA9IHRoaXMuZmlyc3RBcHBseSA/IHt9IDogdGhpcy5jaGFydE9wdGlvbnMucHJvY2Vzc2VkT3B0aW9ucztcbiAgICBjb25zdCBuZXdPcHRzID0gbmV3Q2hhcnRPcHRpb25zLnByb2Nlc3NlZE9wdGlvbnM7XG4gICAgZGVidWcoXCJDaGFydC5hcHBseU9wdGlvbnMoKSAtIGFwcGx5aW5nIGRlbHRhXCIsIGRlbHRhT3B0aW9ucyk7XG4gICAgY29uc3QgbW9kdWxlc0NoYW5nZWQgPSB0aGlzLmFwcGx5TW9kdWxlcyhuZXdPcHRzKTtcbiAgICBjb25zdCBza2lwID0gW1xuICAgICAgXCJ0eXBlXCIsXG4gICAgICBcImRhdGFcIixcbiAgICAgIFwic2VyaWVzXCIsXG4gICAgICBcImxpc3RlbmVyc1wiLFxuICAgICAgXCJwcmVzZXRcIixcbiAgICAgIFwidGhlbWVcIixcbiAgICAgIFwibGVnZW5kLmxpc3RlbmVyc1wiLFxuICAgICAgXCJuYXZpZ2F0b3IubWluaUNoYXJ0LnNlcmllc1wiLFxuICAgICAgXCJuYXZpZ2F0b3IubWluaUNoYXJ0LmxhYmVsXCIsXG4gICAgICBcImxvY2FsZS5sb2NhbGVUZXh0XCIsXG4gICAgICBcImF4ZXNcIixcbiAgICAgIFwidG9wb2xvZ3lcIixcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIFwiaW5pdGlhbFN0YXRlXCIsXG4gICAgICBcInN0eWxlQ29udGFpbmVyXCJcbiAgICBdO1xuICAgIGlmIChkZWx0YU9wdGlvbnMubGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKHRoaXMsIGRlbHRhT3B0aW9ucy5saXN0ZW5lcnMpO1xuICAgIH1cbiAgICBqc29uQXBwbHkodGhpcywgZGVsdGFPcHRpb25zLCB7IHNraXAgfSk7XG4gICAgbGV0IGZvcmNlTm9kZURhdGFSZWZyZXNoID0gZmFsc2U7XG4gICAgbGV0IHNlcmllc1N0YXR1cyA9IFwibm8tb3BcIjtcbiAgICBpZiAoZGVsdGFPcHRpb25zLnNlcmllcyAhPSBudWxsKSB7XG4gICAgICBzZXJpZXNTdGF0dXMgPSB0aGlzLmFwcGx5U2VyaWVzKHRoaXMsIGRlbHRhT3B0aW9ucy5zZXJpZXMsIG9sZE9wdHM/LnNlcmllcyk7XG4gICAgICBmb3JjZU5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChzZXJpZXNTdGF0dXMgPT09IFwicmVwbGFjZWRcIikge1xuICAgICAgdGhpcy5yZXNldEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXBwbHlBeGVzKHRoaXMsIG5ld09wdHMsIG9sZE9wdHMsIHNlcmllc1N0YXR1cywgW10pKSB7XG4gICAgICBmb3JjZU5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChkZWx0YU9wdGlvbnMuZGF0YSkge1xuICAgICAgdGhpcy5kYXRhID0gZGVsdGFPcHRpb25zLmRhdGE7XG4gICAgfVxuICAgIGlmIChkZWx0YU9wdGlvbnMubGVnZW5kPy5saXN0ZW5lcnMgJiYgdGhpcy5tb2R1bGVzTWFuYWdlci5pc0VuYWJsZWQoXCJsZWdlbmRcIikpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5sZWdlbmQubGlzdGVuZXJzLCBkZWx0YU9wdGlvbnMubGVnZW5kLmxpc3RlbmVycyk7XG4gICAgfVxuICAgIGlmIChkZWx0YU9wdGlvbnMubG9jYWxlPy5sb2NhbGVUZXh0KSB7XG4gICAgICB0aGlzLm1vZHVsZXNNYW5hZ2VyLmdldE1vZHVsZShcImxvY2FsZVwiKS5sb2NhbGVUZXh0ID0gZGVsdGFPcHRpb25zLmxvY2FsZT8ubG9jYWxlVGV4dDtcbiAgICB9XG4gICAgdGhpcy5jaGFydE9wdGlvbnMgPSBuZXdDaGFydE9wdGlvbnM7XG4gICAgY29uc3QgbmF2aWdhdG9yTW9kdWxlID0gdGhpcy5tb2R1bGVzTWFuYWdlci5nZXRNb2R1bGUoXCJuYXZpZ2F0b3JcIik7XG4gICAgY29uc3Qgem9vbU1vZHVsZSA9IHRoaXMubW9kdWxlc01hbmFnZXIuZ2V0TW9kdWxlKFwiem9vbVwiKTtcbiAgICBpZiAoIW5hdmlnYXRvck1vZHVsZT8uZW5hYmxlZCAmJiAhem9vbU1vZHVsZT8uZW5hYmxlZCkge1xuICAgICAgdGhpcy5jdHguem9vbU1hbmFnZXIudXBkYXRlWm9vbShcImNoYXJ0XCIpO1xuICAgIH1cbiAgICBjb25zdCBtaW5pQ2hhcnQgPSBuYXZpZ2F0b3JNb2R1bGU/Lm1pbmlDaGFydDtcbiAgICBjb25zdCBtaW5pQ2hhcnRTZXJpZXMgPSBuZXdPcHRzLm5hdmlnYXRvcj8ubWluaUNoYXJ0Py5zZXJpZXMgPz8gbmV3T3B0cy5zZXJpZXM7XG4gICAgaWYgKG1pbmlDaGFydD8uZW5hYmxlZCA9PT0gdHJ1ZSAmJiBtaW5pQ2hhcnRTZXJpZXMgIT0gbnVsbCkge1xuICAgICAgdGhpcy5hcHBseU1pbmlDaGFydE9wdGlvbnMobWluaUNoYXJ0LCBtaW5pQ2hhcnRTZXJpZXMsIG5ld09wdHMsIG9sZE9wdHMpO1xuICAgIH0gZWxzZSBpZiAobWluaUNoYXJ0Py5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgbWluaUNoYXJ0LnNlcmllcyA9IFtdO1xuICAgICAgbWluaUNoYXJ0LmF4ZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5jdHguYW5ub3RhdGlvbk1hbmFnZXIuc2V0QW5ub3RhdGlvblN0eWxlcyhuZXdDaGFydE9wdGlvbnMuYW5ub3RhdGlvblRoZW1lcyk7XG4gICAgZm9yY2VOb2RlRGF0YVJlZnJlc2ggfHwgKGZvcmNlTm9kZURhdGFSZWZyZXNoID0gdGhpcy5zaG91bGRGb3JjZU5vZGVEYXRhUmVmcmVzaChkZWx0YU9wdGlvbnMsIHNlcmllc1N0YXR1cykpO1xuICAgIGNvbnN0IG1ham9yQ2hhbmdlID0gZm9yY2VOb2RlRGF0YVJlZnJlc2ggfHwgbW9kdWxlc0NoYW5nZWQ7XG4gICAgY29uc3QgdXBkYXRlVHlwZSA9IG1ham9yQ2hhbmdlID8gMCAvKiBGVUxMICovIDogMyAvKiBQRVJGT1JNX0xBWU9VVCAqLztcbiAgICB0aGlzLm1heWJlUmVzZXRBbmltYXRpb25zKHNlcmllc1N0YXR1cyk7XG4gICAgaWYgKHRoaXMuc2hvdWxkQ2xlYXJMZWdlbmREYXRhKG5ld09wdHMsIG9sZE9wdHMsIHNlcmllc1N0YXR1cykpIHtcbiAgICAgIHRoaXMuY3R4LmxlZ2VuZE1hbmFnZXIuY2xlYXJEYXRhKCk7XG4gICAgfVxuICAgIHRoaXMuYXBwbHlJbml0aWFsU3RhdGUobmV3T3B0cyk7XG4gICAgZGVidWcoXCJDaGFydC5hcHBseU9wdGlvbnMoKSAtIHVwZGF0ZSB0eXBlXCIsIENoYXJ0VXBkYXRlVHlwZVt1cGRhdGVUeXBlXSwge1xuICAgICAgc2VyaWVzU3RhdHVzLFxuICAgICAgZm9yY2VOb2RlRGF0YVJlZnJlc2hcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZSh1cGRhdGVUeXBlLCB7IGZvcmNlTm9kZURhdGFSZWZyZXNoLCBuZXdBbmltYXRpb25CYXRjaDogdHJ1ZSB9KTtcbiAgICB0aGlzLmZpcnN0QXBwbHkgPSBmYWxzZTtcbiAgfVxuICBhcHBseUluaXRpYWxTdGF0ZShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhbm5vdGF0aW9uTWFuYWdlciwgY2hhcnRUeXBlT3JpZ2luYXRvciwgaGlzdG9yeU1hbmFnZXIsIHN0YXRlTWFuYWdlciwgem9vbU1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHsgaW5pdGlhbFN0YXRlIH0gPSBvcHRpb25zO1xuICAgIGlmIChcImFubm90YXRpb25zXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmFubm90YXRpb25zPy5lbmFibGVkICYmIGluaXRpYWxTdGF0ZT8uYW5ub3RhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgY29uc3QgYW5ub3RhdGlvbnMgPSBpbml0aWFsU3RhdGUuYW5ub3RhdGlvbnMubWFwKChhbm5vdGF0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGFubm90YXRpb25UaGVtZSA9IGFubm90YXRpb25NYW5hZ2VyLmdldEFubm90YXRpb25UeXBlU3R5bGVzKGFubm90YXRpb24udHlwZSk7XG4gICAgICAgIHJldHVybiBtZXJnZURlZmF1bHRzKGFubm90YXRpb24sIGFubm90YXRpb25UaGVtZSk7XG4gICAgICB9KTtcbiAgICAgIHN0YXRlTWFuYWdlci5zZXRTdGF0ZShhbm5vdGF0aW9uTWFuYWdlciwgYW5ub3RhdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoaW5pdGlhbFN0YXRlPy5jaGFydFR5cGUgIT0gbnVsbCkge1xuICAgICAgc3RhdGVNYW5hZ2VyLnNldFN0YXRlKGNoYXJ0VHlwZU9yaWdpbmF0b3IsIGluaXRpYWxTdGF0ZS5jaGFydFR5cGUpO1xuICAgIH1cbiAgICBpZiAoKG9wdGlvbnMubmF2aWdhdG9yPy5lbmFibGVkIHx8IG9wdGlvbnMuem9vbT8uZW5hYmxlZCkgJiYgaW5pdGlhbFN0YXRlPy56b29tICE9IG51bGwpIHtcbiAgICAgIHN0YXRlTWFuYWdlci5zZXRTdGF0ZSh6b29tTWFuYWdlciwgaW5pdGlhbFN0YXRlLnpvb20pO1xuICAgIH1cbiAgICBpZiAoaW5pdGlhbFN0YXRlPy5sZWdlbmQgIT0gbnVsbCkge1xuICAgICAgdGhpcy51cGRhdGVMZWdlbmRzKGluaXRpYWxTdGF0ZS5sZWdlbmQpO1xuICAgIH1cbiAgICBpZiAoaW5pdGlhbFN0YXRlICE9IG51bGwpIHtcbiAgICAgIGhpc3RvcnlNYW5hZ2VyLmNsZWFyKCk7XG4gICAgfVxuICB9XG4gIG1heWJlUmVzZXRBbmltYXRpb25zKHNlcmllc1N0YXR1cykge1xuICAgIGlmICh0aGlzLm1vZGUgIT09IFwic3RhbmRhbG9uZVwiKVxuICAgICAgcmV0dXJuO1xuICAgIHN3aXRjaCAoc2VyaWVzU3RhdHVzKSB7XG4gICAgICBjYXNlIFwic2VyaWVzLWdyb3VwaW5nLWNoYW5nZVwiOlxuICAgICAgY2FzZSBcInJlcGxhY2VkXCI6XG4gICAgICAgIHRoaXMucmVzZXRBbmltYXRpb25zKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cbiAgc2hvdWxkRm9yY2VOb2RlRGF0YVJlZnJlc2goZGVsdGFPcHRpb25zLCBzZXJpZXNTdGF0dXMpIHtcbiAgICBjb25zdCBzZXJpZXNEYXRhVXBkYXRlID0gISFkZWx0YU9wdGlvbnMuZGF0YSB8fCBzZXJpZXNTdGF0dXMgPT09IFwiZGF0YS1jaGFuZ2VcIiB8fCBzZXJpZXNTdGF0dXMgPT09IFwicmVwbGFjZWRcIjtcbiAgICBjb25zdCBsZWdlbmRLZXlzID0gbGVnZW5kUmVnaXN0cnkuZ2V0S2V5cygpO1xuICAgIGNvbnN0IG9wdGlvbnNIYXZlTGVnZW5kID0gT2JqZWN0LnZhbHVlcyhsZWdlbmRLZXlzKS5zb21lKFxuICAgICAgKGxlZ2VuZEtleSkgPT4gZGVsdGFPcHRpb25zW2xlZ2VuZEtleV0gIT0gbnVsbFxuICAgICk7XG4gICAgY29uc3Qgb3RoZXJSZWZyZXNoVXBkYXRlID0gZGVsdGFPcHRpb25zLnRpdGxlICE9IG51bGwgJiYgZGVsdGFPcHRpb25zLnN1YnRpdGxlICE9IG51bGw7XG4gICAgcmV0dXJuIHNlcmllc0RhdGFVcGRhdGUgfHwgb3B0aW9uc0hhdmVMZWdlbmQgfHwgb3RoZXJSZWZyZXNoVXBkYXRlO1xuICB9XG4gIHNob3VsZENsZWFyTGVnZW5kRGF0YShvcHRpb25zLCBvbGRPcHRzLCBzZXJpZXNTdGF0dXMpIHtcbiAgICBjb25zdCBzZXJpZXNDaGFuZ2VkID0gc2VyaWVzU3RhdHVzID09PSBcInJlcGxhY2VkXCIgfHwgc2VyaWVzU3RhdHVzID09PSBcInNlcmllcy1ncm91cGluZy1jaGFuZ2VcIiB8fCBzZXJpZXNTdGF0dXMgPT09IFwidXBkYXRlZFwiO1xuICAgIGNvbnN0IGxlZ2VuZFJlbW92ZWQgPSBvbGRPcHRzLmxlZ2VuZCAhPSBudWxsICYmIG9wdGlvbnMubGVnZW5kID09IG51bGw7XG4gICAgcmV0dXJuIHNlcmllc0NoYW5nZWQgfHwgbGVnZW5kUmVtb3ZlZDtcbiAgfVxuICBhcHBseU1pbmlDaGFydE9wdGlvbnMobWluaUNoYXJ0LCBtaW5pQ2hhcnRTZXJpZXMsIGNvbXBsZXRlT3B0aW9ucywgb2xkT3B0cykge1xuICAgIGNvbnN0IG9sZFNlcmllcyA9IG9sZE9wdHM/Lm5hdmlnYXRvcj8ubWluaUNoYXJ0Py5zZXJpZXMgPz8gb2xkT3B0cz8uc2VyaWVzO1xuICAgIGNvbnN0IG1pbmlDaGFydFNlcmllc1N0YXR1cyA9IHRoaXMuYXBwbHlTZXJpZXMoXG4gICAgICBtaW5pQ2hhcnQsXG4gICAgICB0aGlzLmZpbHRlck1pbmlDaGFydFNlcmllcyhtaW5pQ2hhcnRTZXJpZXMpLFxuICAgICAgdGhpcy5maWx0ZXJNaW5pQ2hhcnRTZXJpZXMob2xkU2VyaWVzKVxuICAgICk7XG4gICAgdGhpcy5hcHBseUF4ZXMobWluaUNoYXJ0LCBjb21wbGV0ZU9wdGlvbnMsIG9sZE9wdHMsIG1pbmlDaGFydFNlcmllc1N0YXR1cywgW1xuICAgICAgXCJheGVzW10udGlja1wiLFxuICAgICAgXCJheGVzW10udGhpY2tuZXNzXCIsXG4gICAgICBcImF4ZXNbXS50aXRsZVwiLFxuICAgICAgXCJheGVzW10uY3Jvc3NoYWlyXCIsXG4gICAgICBcImF4ZXNbXS5ncmlkTGluZVwiLFxuICAgICAgXCJheGVzW10ubGFiZWxcIlxuICAgIF0pO1xuICAgIGNvbnN0IHNlcmllcyA9IG1pbmlDaGFydC5zZXJpZXM7XG4gICAgZm9yIChjb25zdCBzIG9mIHNlcmllcykge1xuICAgICAgcy5wcm9wZXJ0aWVzLmlkID0gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBheGVzID0gbWluaUNoYXJ0LmF4ZXM7XG4gICAgY29uc3QgaG9yaXpvbnRhbEF4aXMgPSBheGVzLmZpbmQoKGF4aXMpID0+IGF4aXMuZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKTtcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgYXhlcykge1xuICAgICAgYXhpcy5uaWNlID0gZmFsc2U7XG4gICAgICBheGlzLmdyaWRMaW5lLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGF4aXMubGFiZWwuZW5hYmxlZCA9IGF4aXMgPT09IGhvcml6b250YWxBeGlzO1xuICAgICAgYXhpcy50aWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGF4aXMuaW50ZXJhY3Rpb25FbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChob3Jpem9udGFsQXhpcyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBtaW5pQ2hhcnRPcHRzID0gY29tcGxldGVPcHRpb25zLm5hdmlnYXRvcj8ubWluaUNoYXJ0O1xuICAgICAgY29uc3QgbGFiZWxPcHRpb25zID0gbWluaUNoYXJ0T3B0cz8ubGFiZWw7XG4gICAgICBjb25zdCBpbnRlcnZhbE9wdGlvbnMgPSBtaW5pQ2hhcnRPcHRzPy5sYWJlbD8uaW50ZXJ2YWw7XG4gICAgICBob3Jpem9udGFsQXhpcy5saW5lLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGhvcml6b250YWxBeGlzLmxhYmVsLnNldChcbiAgICAgICAgd2l0aG91dChsYWJlbE9wdGlvbnMsIFtcImludGVydmFsXCIsIFwicm90YXRpb25cIiwgXCJtaW5TcGFjaW5nXCIsIFwiYXV0b1JvdGF0ZVwiLCBcImF1dG9Sb3RhdGVBbmdsZVwiXSlcbiAgICAgICk7XG4gICAgICBob3Jpem9udGFsQXhpcy50aWNrLnNldChcbiAgICAgICAgd2l0aG91dChpbnRlcnZhbE9wdGlvbnMsIFtcImVuYWJsZWRcIiwgXCJ3aWR0aFwiLCBcInNpemVcIiwgXCJjb2xvclwiLCBcImludGVydmFsXCIsIFwic3RlcFwiXSlcbiAgICAgICk7XG4gICAgICBpZiAoaG9yaXpvbnRhbEF4aXMudHlwZSA9PT0gXCJncm91cGVkLWNhdGVnb3J5XCIpIHtcbiAgICAgICAgaG9yaXpvbnRhbEF4aXMubGFiZWwuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBob3Jpem9udGFsQXhpcy5sYWJlbC5yb3RhdGlvbiA9IDA7XG4gICAgICAgIGNvbnN0IHsgZGVwdGhPcHRpb25zIH0gPSBob3Jpem9udGFsQXhpcztcbiAgICAgICAgaWYgKGRlcHRoT3B0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZXB0aE9wdGlvbnMuc2V0KFt7IGxhYmVsOiB7IGVuYWJsZWQ6IHRydWUgfSB9XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkZXB0aE9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRlcHRoT3B0aW9uc1tpXS5sYWJlbC5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzdGVwID0gaW50ZXJ2YWxPcHRpb25zPy5zdGVwO1xuICAgICAgaWYgKHN0ZXAgIT0gbnVsbCkge1xuICAgICAgICBob3Jpem9udGFsQXhpcy5pbnRlcnZhbC5zdGVwID0gc3RlcDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXBwbHlNb2R1bGVzKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHR5cGU6IGNoYXJ0VHlwZSB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBsZXQgbW9kdWxlc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVSZWdpc3RyeS5ieVR5cGUoXCJyb290XCIsIFwibGVnZW5kXCIpKSB7XG4gICAgICBjb25zdCBpc0NvbmZpZ3VyZWQgPSBvcHRpb25zW21vZHVsZS5vcHRpb25zS2V5XSAhPSBudWxsO1xuICAgICAgY29uc3Qgc2hvdWxkQmVFbmFibGVkID0gaXNDb25maWd1cmVkICYmIG1vZHVsZS5jaGFydFR5cGVzLmluY2x1ZGVzKGNoYXJ0VHlwZSk7XG4gICAgICBpZiAoc2hvdWxkQmVFbmFibGVkID09PSB0aGlzLm1vZHVsZXNNYW5hZ2VyLmlzRW5hYmxlZChtb2R1bGUpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChzaG91bGRCZUVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzTWFuYWdlci5hZGRNb2R1bGUobW9kdWxlLCAobSkgPT4gbS5tb2R1bGVGYWN0b3J5KHRoaXMuZ2V0TW9kdWxlQ29udGV4dCgpKSk7XG4gICAgICAgIGlmIChtb2R1bGUudHlwZSA9PT0gXCJsZWdlbmRcIikge1xuICAgICAgICAgIHRoaXMubW9kdWxlc01hbmFnZXIuZ2V0TW9kdWxlKG1vZHVsZSk/LmF0dGFjaExlZ2VuZCh0aGlzLmN0eC5zY2VuZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1ttb2R1bGUub3B0aW9uc0tleV0gPSB0aGlzLm1vZHVsZXNNYW5hZ2VyLmdldE1vZHVsZShtb2R1bGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzTWFuYWdlci5yZW1vdmVNb2R1bGUobW9kdWxlKTtcbiAgICAgICAgZGVsZXRlIHRoaXNbbW9kdWxlLm9wdGlvbnNLZXldO1xuICAgICAgfVxuICAgICAgbW9kdWxlc0NoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbW9kdWxlc0NoYW5nZWQ7XG4gIH1cbiAgaW5pdFNlcmllc0RlY2xhcmF0aW9uT3JkZXIoc2VyaWVzKSB7XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc2VyaWVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIHNlcmllc1tpZHhdLnNldFNlcmllc0luZGV4KGlkeCk7XG4gICAgfVxuICB9XG4gIGFwcGx5U2VyaWVzKGNoYXJ0LCBvcHRTZXJpZXMsIG9sZE9wdFNlcmllcykge1xuICAgIGlmICghb3B0U2VyaWVzKSB7XG4gICAgICByZXR1cm4gXCJuby1jaGFuZ2VcIjtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2hSZXN1bHQgPSBtYXRjaFNlcmllc09wdGlvbnMoY2hhcnQuc2VyaWVzLCBvcHRTZXJpZXMsIG9sZE9wdFNlcmllcyk7XG4gICAgaWYgKG1hdGNoUmVzdWx0LnN0YXR1cyA9PT0gXCJuby1vdmVybGFwXCIpIHtcbiAgICAgIGRlYnVnKGBDaGFydC5hcHBseVNlcmllcygpIC0gY3JlYXRpbmcgbmV3IHNlcmllcyBpbnN0YW5jZXMsIHN0YXR1czogJHttYXRjaFJlc3VsdC5zdGF0dXN9YCwgbWF0Y2hSZXN1bHQpO1xuICAgICAgY29uc3QgY2hhcnRTZXJpZXMgPSBvcHRTZXJpZXMubWFwKChvcHRzKSA9PiB0aGlzLmNyZWF0ZVNlcmllcyhvcHRzKSk7XG4gICAgICB0aGlzLmluaXRTZXJpZXNEZWNsYXJhdGlvbk9yZGVyKGNoYXJ0U2VyaWVzKTtcbiAgICAgIGNoYXJ0LnNlcmllcyA9IGNoYXJ0U2VyaWVzO1xuICAgICAgcmV0dXJuIFwicmVwbGFjZWRcIjtcbiAgICB9XG4gICAgZGVidWcoYENoYXJ0LmFwcGx5U2VyaWVzKCkgLSBtYXRjaFJlc3VsdGAsIG1hdGNoUmVzdWx0KTtcbiAgICBjb25zdCBzZXJpZXNJbnN0YW5jZXMgPSBbXTtcbiAgICBsZXQgZGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICBsZXQgZ3JvdXBpbmdDaGFuZ2VkID0gZmFsc2U7XG4gICAgbGV0IGlzVXBkYXRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGNoYW5nZXMgPSBtYXRjaFJlc3VsdC5jaGFuZ2VzLnRvU29ydGVkKChhLCBiKSA9PiBhLnRhcmdldElkeCAtIGIudGFyZ2V0SWR4KTtcbiAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XG4gICAgICBncm91cGluZ0NoYW5nZWQgfHwgKGdyb3VwaW5nQ2hhbmdlZCA9IGNoYW5nZS5zdGF0dXMgPT09IFwic2VyaWVzLWdyb3VwaW5nXCIpO1xuICAgICAgZGF0YUNoYW5nZWQgfHwgKGRhdGFDaGFuZ2VkID0gY2hhbmdlLmRpZmY/LmRhdGEgIT0gbnVsbCk7XG4gICAgICBpc1VwZGF0ZWQgfHwgKGlzVXBkYXRlZCA9IGNoYW5nZS5zdGF0dXMgIT09IFwibm8tb3BcIik7XG4gICAgICBzd2l0Y2ggKGNoYW5nZS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImFkZFwiOiB7XG4gICAgICAgICAgY29uc3QgbmV3U2VyaWVzID0gdGhpcy5jcmVhdGVTZXJpZXMoY2hhbmdlLm9wdHMpO1xuICAgICAgICAgIHNlcmllc0luc3RhbmNlcy5wdXNoKG5ld1Nlcmllcyk7XG4gICAgICAgICAgZGVidWcoYENoYXJ0LmFwcGx5U2VyaWVzKCkgLSBjcmVhdGVkIG5ldyBzZXJpZXNgLCBuZXdTZXJpZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgICAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlTZXJpZXMoKSAtIHJlbW92aW5nIHNlcmllcyBhdCBwcmV2aW91cyBpZHggJHtjaGFuZ2UuaWR4fWAsIGNoYW5nZS5zZXJpZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibm8tb3BcIjpcbiAgICAgICAgICBzZXJpZXNJbnN0YW5jZXMucHVzaChjaGFuZ2Uuc2VyaWVzKTtcbiAgICAgICAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlTZXJpZXMoKSAtIG5vIGNoYW5nZSB0byBzZXJpZXMgYXQgcHJldmlvdXMgaWR4ICR7Y2hhbmdlLmlkeH1gLCBjaGFuZ2Uuc2VyaWVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNlcmllcy1ncm91cGluZ1wiOlxuICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCB7IHNlcmllcywgZGlmZjogZGlmZjIsIGlkeCB9ID0gY2hhbmdlO1xuICAgICAgICAgIGRlYnVnKGBDaGFydC5hcHBseVNlcmllcygpIC0gYXBwbHlpbmcgc2VyaWVzIGRpZmYgcHJldmlvdXMgaWR4ICR7aWR4fWAsIGRpZmYyLCBzZXJpZXMpO1xuICAgICAgICAgIHRoaXMuYXBwbHlTZXJpZXNWYWx1ZXMoc2VyaWVzLCBkaWZmMik7XG4gICAgICAgICAgc2VyaWVzLm1hcmtOb2RlRGF0YURpcnR5KCk7XG4gICAgICAgICAgc2VyaWVzSW5zdGFuY2VzLnB1c2goc2VyaWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmluaXRTZXJpZXNEZWNsYXJhdGlvbk9yZGVyKHNlcmllc0luc3RhbmNlcyk7XG4gICAgZGVidWcoYENoYXJ0LmFwcGx5U2VyaWVzKCkgLSBmaW5hbCBzZXJpZXMgaW5zdGFuY2VzYCwgc2VyaWVzSW5zdGFuY2VzKTtcbiAgICBjaGFydC5zZXJpZXMgPSBzZXJpZXNJbnN0YW5jZXM7XG4gICAgaWYgKGdyb3VwaW5nQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuIFwic2VyaWVzLWdyb3VwaW5nLWNoYW5nZVwiO1xuICAgIH1cbiAgICBpZiAoZGF0YUNoYW5nZWQpIHtcbiAgICAgIHJldHVybiBcImRhdGEtY2hhbmdlXCI7XG4gICAgfVxuICAgIHJldHVybiBpc1VwZGF0ZWQgPyBcInVwZGF0ZWRcIiA6IFwibm8tb3BcIjtcbiAgfVxuICBhcHBseUF4ZXMoY2hhcnQsIG9wdGlvbnMsIG9sZE9wdHMsIHNlcmllc1N0YXR1cywgc2tpcCA9IFtdKSB7XG4gICAgaWYgKCEoXCJheGVzXCIgaW4gb3B0aW9ucykgfHwgIW9wdGlvbnMuYXhlcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBza2lwID0gW1wiYXhlc1tdLnR5cGVcIiwgLi4uc2tpcF07XG4gICAgY29uc3QgeyBheGVzIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGZvcmNlUmVjcmVhdGUgPSBzZXJpZXNTdGF0dXMgPT09IFwicmVwbGFjZWRcIjtcbiAgICBjb25zdCBtYXRjaGluZ1R5cGVzID0gIWZvcmNlUmVjcmVhdGUgJiYgY2hhcnQuYXhlcy5sZW5ndGggPT09IGF4ZXMubGVuZ3RoICYmIGNoYXJ0LmF4ZXMuZXZlcnkoKGEsIGkpID0+IGEudHlwZSA9PT0gYXhlc1tpXS50eXBlKTtcbiAgICBpZiAobWF0Y2hpbmdUeXBlcyAmJiBpc0FnQ2FydGVzaWFuQ2hhcnRPcHRpb25zKG9sZE9wdHMpKSB7XG4gICAgICBjaGFydC5heGVzLmZvckVhY2goKGF4aXMsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzT3B0cyA9IG9sZE9wdHMuYXhlcz8uW2luZGV4XSA/PyB7fTtcbiAgICAgICAgY29uc3QgYXhpc0RpZmYgPSBqc29uRGlmZihwcmV2aW91c09wdHMsIGF4ZXNbaW5kZXhdKTtcbiAgICAgICAgZGVidWcoYENoYXJ0LmFwcGx5QXhlcygpIC0gYXBwbHlpbmcgYXhpcyBkaWZmIGlkeCAke2luZGV4fWAsIGF4aXNEaWZmKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGBheGVzWyR7aW5kZXh9XWA7XG4gICAgICAgIGpzb25BcHBseShheGlzLCBheGlzRGlmZiwgeyBwYXRoLCBza2lwIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZGVidWcoYENoYXJ0LmFwcGx5QXhlcygpIC0gY3JlYXRpbmcgbmV3IGF4ZXMgaW5zdGFuY2VzOyBzZXJpZXNTdGF0dXM6ICR7c2VyaWVzU3RhdHVzfWApO1xuICAgIGNoYXJ0LmF4ZXMgPSB0aGlzLmNyZWF0ZUF4aXMoYXhlcywgc2tpcCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY3JlYXRlU2VyaWVzKHNlcmllc09wdGlvbnMpIHtcbiAgICBjb25zdCBzZXJpZXNJbnN0YW5jZSA9IHNlcmllc1JlZ2lzdHJ5LmNyZWF0ZShzZXJpZXNPcHRpb25zLnR5cGUsIHRoaXMuZ2V0TW9kdWxlQ29udGV4dCgpKTtcbiAgICB0aGlzLmFwcGx5U2VyaWVzT3B0aW9uTW9kdWxlcyhzZXJpZXNJbnN0YW5jZSwgc2VyaWVzT3B0aW9ucyk7XG4gICAgdGhpcy5hcHBseVNlcmllc1ZhbHVlcyhzZXJpZXNJbnN0YW5jZSwgc2VyaWVzT3B0aW9ucyk7XG4gICAgcmV0dXJuIHNlcmllc0luc3RhbmNlO1xuICB9XG4gIGFwcGx5U2VyaWVzT3B0aW9uTW9kdWxlcyhzZXJpZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtb2R1bGVDb250ZXh0ID0gc2VyaWVzLmNyZWF0ZU1vZHVsZUNvbnRleHQoKTtcbiAgICBjb25zdCBtb2R1bGVNYXAgPSBzZXJpZXMuZ2V0TW9kdWxlTWFwKCk7XG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlUmVnaXN0cnkuYnlUeXBlKFwic2VyaWVzLW9wdGlvblwiKSkge1xuICAgICAgaWYgKG1vZHVsZS5vcHRpb25zS2V5IGluIG9wdGlvbnMgJiYgbW9kdWxlLnNlcmllc1R5cGVzLmluY2x1ZGVzKHNlcmllcy50eXBlKSkge1xuICAgICAgICBtb2R1bGVNYXAuYWRkTW9kdWxlKG1vZHVsZSwgKG0pID0+IG0ubW9kdWxlRmFjdG9yeShtb2R1bGVDb250ZXh0KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFwcGx5U2VyaWVzVmFsdWVzKHRhcmdldCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG1vZHVsZU1hcCA9IHRhcmdldC5nZXRNb2R1bGVNYXAoKTtcbiAgICBjb25zdCB7IHR5cGU6IF8sIGRhdGEsIGxpc3RlbmVycywgc2VyaWVzR3JvdXBpbmcsIHNob3dJbk1pbmlDaGFydDogX18sIC4uLnNlcmllc09wdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgZm9yIChjb25zdCBtb2R1bGVEZWYgb2YgRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTKSB7XG4gICAgICBpZiAobW9kdWxlRGVmLnR5cGUgIT09IFwic2VyaWVzLW9wdGlvblwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChtb2R1bGVEZWYub3B0aW9uc0tleSBpbiBzZXJpZXNPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IG1vZHVsZU1hcC5nZXRNb2R1bGUobW9kdWxlRGVmLm9wdGlvbnNLZXkpO1xuICAgICAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgICAgY29uc3QgbW9kdWxlT3B0aW9ucyA9IHNlcmllc09wdGlvbnNbbW9kdWxlRGVmLm9wdGlvbnNLZXldO1xuICAgICAgICAgIGRlbGV0ZSBzZXJpZXNPcHRpb25zW21vZHVsZURlZi5vcHRpb25zS2V5XTtcbiAgICAgICAgICBtb2R1bGUucHJvcGVydGllcy5zZXQobW9kdWxlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGFyZ2V0LnByb3BlcnRpZXMuc2V0KHNlcmllc09wdGlvbnMpO1xuICAgIGlmIChcImRhdGFcIiBpbiBvcHRpb25zKSB7XG4gICAgICB0YXJnZXQuc2V0T3B0aW9uc0RhdGEoZGF0YSk7XG4gICAgfVxuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnModGFyZ2V0LCBsaXN0ZW5lcnMpO1xuICAgIH1cbiAgICBpZiAoXCJzZXJpZXNHcm91cGluZ1wiIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChzZXJpZXNHcm91cGluZyA9PSBudWxsKSB7XG4gICAgICAgIHRhcmdldC5zZXJpZXNHcm91cGluZyA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC5zZXJpZXNHcm91cGluZyA9IHsgLi4udGFyZ2V0LnNlcmllc0dyb3VwaW5nLCAuLi5zZXJpZXNHcm91cGluZyB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjcmVhdGVBeGlzKG9wdGlvbnMsIHNraXApIHtcbiAgICBjb25zdCBuZXdBeGVzID0gW107XG4gICAgY29uc3QgbW9kdWxlQ29udGV4dCA9IHRoaXMuZ2V0TW9kdWxlQ29udGV4dCgpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBvcHRpb25zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgYXhpc09wdGlvbnMgPSBvcHRpb25zW2luZGV4XTtcbiAgICAgIGNvbnN0IGF4aXMgPSBheGlzUmVnaXN0cnkuY3JlYXRlKGF4aXNPcHRpb25zLnR5cGUsIG1vZHVsZUNvbnRleHQpO1xuICAgICAgdGhpcy5hcHBseUF4aXNNb2R1bGVzKGF4aXMsIGF4aXNPcHRpb25zKTtcbiAgICAgIGpzb25BcHBseShheGlzLCBheGlzT3B0aW9ucywgeyBwYXRoOiBgYXhlc1ske2luZGV4fV1gLCBza2lwIH0pO1xuICAgICAgbmV3QXhlcy5wdXNoKGF4aXMpO1xuICAgIH1cbiAgICBndWVzc0ludmFsaWRQb3NpdGlvbnMobmV3QXhlcyk7XG4gICAgcmV0dXJuIG5ld0F4ZXM7XG4gIH1cbiAgYXBwbHlBeGlzTW9kdWxlcyhheGlzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbW9kdWxlQ29udGV4dCA9IGF4aXMuY3JlYXRlTW9kdWxlQ29udGV4dCgpO1xuICAgIGNvbnN0IG1vZHVsZU1hcCA9IGF4aXMuZ2V0TW9kdWxlTWFwKCk7XG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlUmVnaXN0cnkuYnlUeXBlKFwiYXhpcy1vcHRpb25cIikpIHtcbiAgICAgIGNvbnN0IHNob3VsZEJlRW5hYmxlZCA9IG9wdGlvbnNbbW9kdWxlLm9wdGlvbnNLZXldICE9IG51bGw7XG4gICAgICBpZiAoc2hvdWxkQmVFbmFibGVkID09PSBtb2R1bGVNYXAuaXNFbmFibGVkKG1vZHVsZSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKHNob3VsZEJlRW5hYmxlZCkge1xuICAgICAgICBtb2R1bGVNYXAuYWRkTW9kdWxlKG1vZHVsZSwgKG0pID0+IG0ubW9kdWxlRmFjdG9yeShtb2R1bGVDb250ZXh0KSk7XG4gICAgICAgIGF4aXNbbW9kdWxlLm9wdGlvbnNLZXldID0gbW9kdWxlTWFwLmdldE1vZHVsZShtb2R1bGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kdWxlTWFwLnJlbW92ZU1vZHVsZShtb2R1bGUpO1xuICAgICAgICBkZWxldGUgYXhpc1ttb2R1bGUub3B0aW9uc0tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKHNvdXJjZSwgbGlzdGVuZXJzKSB7XG4gICAgc291cmNlLmNsZWFyRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICBmb3IgKGNvbnN0IFtwcm9wZXJ0eSwgbGlzdGVuZXJdIG9mIE9iamVjdC5lbnRyaWVzKGxpc3RlbmVycykpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVyKSkge1xuICAgICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihwcm9wZXJ0eSwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbl9DaGFydC5jaGFydHNJbnN0YW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZSh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnNldENvbnRhaW5lcih2YWx1ZSk7XG4gICAgICBfQ2hhcnQuY2hhcnRzSW5zdGFuY2VzLnNldCh2YWx1ZSwgdGhpcyk7XG4gICAgfSxcbiAgICBvbGRWYWx1ZSh2YWx1ZSkge1xuICAgICAgX0NoYXJ0LmNoYXJ0c0luc3RhbmNlcy5kZWxldGUodmFsdWUpO1xuICAgIH1cbiAgfSlcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwiY29udGFpbmVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG5ld1ZhbHVlKHZhbHVlKSB7XG4gICAgICB0aGlzLnJlc2l6ZShcIndpZHRoIG9wdGlvblwiLCB7IGluV2lkdGg6IHZhbHVlIH0pO1xuICAgIH1cbiAgfSlcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwid2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUodmFsdWUpIHtcbiAgICAgIHRoaXMucmVzaXplKFwiaGVpZ2h0IG9wdGlvblwiLCB7IGluSGVpZ2h0OiB2YWx1ZSB9KTtcbiAgICB9XG4gIH0pXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcImhlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5yZXNpemUoXCJtaW5XaWR0aCBvcHRpb25cIiwgeyBpbk1pbldpZHRoOiB2YWx1ZSB9KTtcbiAgICB9XG4gIH0pXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcIm1pbldpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG5ld1ZhbHVlKHZhbHVlKSB7XG4gICAgICB0aGlzLnJlc2l6ZShcIm1pbkhlaWdodCBvcHRpb25cIiwgeyBpbk1pbkhlaWdodDogdmFsdWUgfSk7XG4gICAgfVxuICB9KVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJtaW5IZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUodmFsdWUpIHtcbiAgICAgIHRoaXMucmVzaXplKFwib3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvIG9wdGlvblwiLCB7IGluT3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvOiB2YWx1ZSB9KTtcbiAgICB9XG4gIH0pXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcIm92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpb1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwic2VyaWVzQXJlYVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwia2V5Ym9hcmRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcInRvdWNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVU5JT04oW1wic3RhbmRhbG9uZVwiLCBcImludGVncmF0ZWRcIl0sIFwiYSBjaGFydCBtb2RlXCIpKVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJtb2RlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcImNoYXJ0Q2FwdGlvbnMudGl0bGVcIilcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwiY2hhcnRDYXB0aW9ucy5zdWJ0aXRsZVwiKVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJzdWJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJjaGFydENhcHRpb25zLmZvb3Rub3RlXCIpXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcImZvb3Rub3RlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwic3VwcHJlc3NGaWVsZERvdE5vdGF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIGNoYW5nZVZhbHVlKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgdGhpcy5vbkF4aXNDaGFuZ2UobmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICB9XG4gIH0pXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcImF4ZXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgY2hhbmdlVmFsdWUobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICB0aGlzLm9uU2VyaWVzQ2hhbmdlKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgfVxuICB9KVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJzZXJpZXNcIiwgMik7XG52YXIgQ2hhcnQgPSBfQ2hhcnQ7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL2xvZ1NjYWxlLnRzXG52YXIgbG9nRnVuY3Rpb25zID0ge1xuICAyOiAoX2Jhc2UsIHgpID0+IE1hdGgubG9nMih4KSxcbiAgW01hdGguRV06IChfYmFzZSwgeCkgPT4gTWF0aC5sb2coeCksXG4gIDEwOiAoX2Jhc2UsIHgpID0+IE1hdGgubG9nMTAoeClcbn07XG52YXIgREVGQVVMVF9MT0cgPSAoYmFzZSwgeCkgPT4gTWF0aC5sb2coeCkgLyBNYXRoLmxvZyhiYXNlKTtcbmZ1bmN0aW9uIGxvZzIoYmFzZSwgZG9tYWluLCB4KSB7XG4gIGNvbnN0IHN0YXJ0MiA9IE1hdGgubWluKC4uLmRvbWFpbik7XG4gIGNvbnN0IGZuID0gbG9nRnVuY3Rpb25zW2Jhc2VdID8/IERFRkFVTFRfTE9HO1xuICByZXR1cm4gc3RhcnQyID49IDAgPyBmbihiYXNlLCB4KSA6IC1mbihiYXNlLCAteCk7XG59XG52YXIgcG93RnVuY3Rpb25zID0ge1xuICBbTWF0aC5FXTogKF9iYXNlLCB4KSA9PiBNYXRoLmV4cCh4KSxcbiAgMTA6IChfYmFzZSwgeCkgPT4geCA+PSAwID8gMTAgKiogeCA6IDEgLyAxMCAqKiAteFxufTtcbnZhciBERUZBVUxUX1BPVyA9IChiYXNlLCB4KSA9PiBiYXNlICoqIHg7XG5mdW5jdGlvbiBwb3coYmFzZSwgZG9tYWluLCB4KSB7XG4gIGNvbnN0IHN0YXJ0MiA9IE1hdGgubWluKC4uLmRvbWFpbik7XG4gIGNvbnN0IGZuID0gcG93RnVuY3Rpb25zW2Jhc2VdID8/IERFRkFVTFRfUE9XO1xuICByZXR1cm4gc3RhcnQyID49IDAgPyBmbihiYXNlLCB4KSA6IC1mbihiYXNlLCAteCk7XG59XG52YXIgTG9nU2NhbGUgPSBjbGFzcyBleHRlbmRzIENvbnRpbnVvdXNTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGQgPSBbMSwgMTBdLCByID0gWzAsIDFdKSB7XG4gICAgc3VwZXIoZCwgcik7XG4gICAgdGhpcy50eXBlID0gXCJsb2dcIjtcbiAgICAvLyBIYW5kbGluZyA8MSBhbmQgY3Jvc3NpbmcgMCBjYXNlcyBpcyB0cmlja3ksIGVhc2llc3Qgc29sdXRpb24gaXMgdG8gZGVmYXVsdCB0byBjbGFtcGluZy5cbiAgICB0aGlzLmRlZmF1bHRDbGFtcCA9IHRydWU7XG4gICAgdGhpcy5iYXNlID0gMTA7XG4gICAgdGhpcy5sb2cgPSAoeCkgPT4gbG9nMih0aGlzLmJhc2UsIHRoaXMuZG9tYWluLCB4KTtcbiAgICB0aGlzLnBvdyA9ICh4KSA9PiBwb3codGhpcy5iYXNlLCB0aGlzLmRvbWFpbiwgeCk7XG4gIH1cbiAgdG9Eb21haW4oZCkge1xuICAgIHJldHVybiBkO1xuICB9XG4gIHRyYW5zZm9ybSh4KSB7XG4gICAgY29uc3QgW21pbiwgbWF4XSA9IGZpbmRNaW5NYXgodGhpcy5kb21haW4pO1xuICAgIGlmIChtaW4gPj0gMCAhPT0gbWF4ID49IDApXG4gICAgICByZXR1cm4gTmFOO1xuICAgIHJldHVybiBtaW4gPj0gMCA/IE1hdGgubG9nKHgpIDogLU1hdGgubG9nKC14KTtcbiAgfVxuICB0cmFuc2Zvcm1JbnZlcnQoeCkge1xuICAgIGNvbnN0IFttaW4sIG1heF0gPSBmaW5kTWluTWF4KHRoaXMuZG9tYWluKTtcbiAgICBpZiAobWluID49IDAgIT09IG1heCA+PSAwKVxuICAgICAgcmV0dXJuIE5hTjtcbiAgICByZXR1cm4gbWluID49IDAgPyBNYXRoLmV4cCh4KSA6IC1NYXRoLmV4cCgteCk7XG4gIH1cbiAgbmljZURvbWFpbihfdGlja3MsIGRvbWFpbiA9IHRoaXMuZG9tYWluKSB7XG4gICAgaWYgKGRvbWFpbi5sZW5ndGggPCAyKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHsgYmFzZSB9ID0gdGhpcztcbiAgICBjb25zdCBbZDAsIGQxXSA9IGRvbWFpbjtcbiAgICBjb25zdCByb3VuZFN0YXJ0ID0gZDAgPiBkMSA/IE1hdGguY2VpbCA6IE1hdGguZmxvb3I7XG4gICAgY29uc3Qgcm91bmRTdG9wID0gZDAgPiBkMSA/IE1hdGguZmxvb3IgOiBNYXRoLmNlaWw7XG4gICAgY29uc3QgbjAgPSBwb3coYmFzZSwgZG9tYWluLCByb3VuZFN0YXJ0KGxvZzIoYmFzZSwgZG9tYWluLCBkMCkpKTtcbiAgICBjb25zdCBuMSA9IHBvdyhiYXNlLCBkb21haW4sIHJvdW5kU3RvcChsb2cyKGJhc2UsIGRvbWFpbiwgZDEpKSk7XG4gICAgcmV0dXJuIFtuMCwgbjFdO1xuICB9XG4gIHRpY2tzKHsgaW50ZXJ2YWwsIHRpY2tDb3VudCA9IENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0VGlja0NvdW50IH0sIGRvbWFpbiA9IHRoaXMuZG9tYWluLCB2aXNpYmxlUmFuZ2UpIHtcbiAgICBpZiAoIWRvbWFpbiB8fCBkb21haW4ubGVuZ3RoIDwgMiB8fCB0aWNrQ291bnQgPCAxKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGJhc2UgPSB0aGlzLmJhc2U7XG4gICAgY29uc3QgW2QwLCBkMV0gPSBkb21haW47XG4gICAgY29uc3Qgc3RhcnQyID0gTWF0aC5taW4oZDAsIGQxKTtcbiAgICBjb25zdCBzdG9wID0gTWF0aC5tYXgoZDAsIGQxKTtcbiAgICBsZXQgcDAgPSB0aGlzLmxvZyhzdGFydDIpO1xuICAgIGxldCBwMSA9IHRoaXMubG9nKHN0b3ApO1xuICAgIGlmIChpbnRlcnZhbCkge1xuICAgICAgY29uc3QgaW5Cb3VuZHMgPSAodGljaykgPT4gdGljayA+PSBzdGFydDIgJiYgdGljayA8PSBzdG9wO1xuICAgICAgY29uc3Qgc3RlcCA9IE1hdGgubWluKE1hdGguYWJzKGludGVydmFsKSwgTWF0aC5hYnMocDEgLSBwMCkpO1xuICAgICAgY29uc3QgdGlja3MyID0gcmFuZ2UocDAsIHAxLCBzdGVwKS5tYXAodGhpcy5wb3cpLmZpbHRlcihpbkJvdW5kcyk7XG4gICAgICBpZiAoIWlzRGVuc2VJbnRlcnZhbCh0aWNrczIubGVuZ3RoLCB0aGlzLmdldFBpeGVsUmFuZ2UoKSkpIHtcbiAgICAgICAgcmV0dXJuIHRpY2tzMjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0ludGVnZXIoYmFzZSkgfHwgcDEgLSBwMCA+PSB0aWNrQ291bnQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVUaWNrcyhwMCwgcDEsIE1hdGgubWluKHAxIC0gcDAsIHRpY2tDb3VudCkpLm1hcCh0aGlzLnBvdyk7XG4gICAgfVxuICAgIGxldCB0aWNrcyA9IFtdO1xuICAgIGNvbnN0IGlzUG9zaXRpdmUgPSBzdGFydDIgPiAwO1xuICAgIHAwID0gTWF0aC5mbG9vcihwMCkgLSAxO1xuICAgIHAxID0gTWF0aC5yb3VuZChwMSkgKyAxO1xuICAgIGNvbnN0IGF2YWlsYWJsZVNwYWNpbmcgPSBmaW5kUmFuZ2VFeHRlbnQodGhpcy5yYW5nZSkgLyB0aWNrQ291bnQ7XG4gICAgbGV0IGxhc3RUaWNrUG9zaXRpb24gPSBJbmZpbml0eTtcbiAgICBmb3IgKGxldCBwID0gcDA7IHAgPD0gcDE7IHArKykge1xuICAgICAgY29uc3QgbmV4dE1hZ25pdHVkZVRpY2tQb3NpdGlvbiA9IHRoaXMuY29udmVydCh0aGlzLnBvdyhwICsgMSkpO1xuICAgICAgZm9yIChsZXQgayA9IDE7IGsgPCBiYXNlOyBrKyspIHtcbiAgICAgICAgY29uc3QgcSA9IGlzUG9zaXRpdmUgPyBrIDogYmFzZSAtIGsgKyAxO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5wb3cocCkgKiBxO1xuICAgICAgICBjb25zdCB0aWNrUG9zaXRpb24gPSB0aGlzLmNvbnZlcnQodCk7XG4gICAgICAgIGNvbnN0IHByZXZTcGFjaW5nID0gTWF0aC5hYnMobGFzdFRpY2tQb3NpdGlvbiAtIHRpY2tQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IG5leHRTcGFjaW5nID0gTWF0aC5hYnModGlja1Bvc2l0aW9uIC0gbmV4dE1hZ25pdHVkZVRpY2tQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGZpdHMgPSBwcmV2U3BhY2luZyA+PSBhdmFpbGFibGVTcGFjaW5nICYmIG5leHRTcGFjaW5nID49IGF2YWlsYWJsZVNwYWNpbmc7XG4gICAgICAgIGlmICh0ID49IHN0YXJ0MiAmJiB0IDw9IHN0b3AgJiYgKGsgPT09IDEgfHwgZml0cyB8fCB0aWNrcy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgdGlja3MucHVzaCh0KTtcbiAgICAgICAgICBsYXN0VGlja1Bvc2l0aW9uID0gdGlja1Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRpY2tzID0gZmlsdGVyVmlzaWJsZVRpY2tzKHRpY2tzLCBpc1Bvc2l0aXZlLCB2aXNpYmxlUmFuZ2UpO1xuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICB0aWNrRm9ybWF0dGVyKHsgc3BlY2lmaWVyIH0pIHtcbiAgICByZXR1cm4gc3BlY2lmaWVyICE9IG51bGwgPyBudW1iZXJGb3JtYXQoc3BlY2lmaWVyKSA6IFN0cmluZztcbiAgfVxuICBkYXR1bUZvcm1hdHRlcihwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy50aWNrRm9ybWF0dGVyKHBhcmFtcyk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3V0aWwvcXVhZHRyZWUudHNcbnZhciBRdWFkdHJlZU5lYXJlc3QgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNhcGFjaXR5LCBtYXhkZXB0aCwgYm91bmRhcnkpIHtcbiAgICB0aGlzLnJvb3QgPSBuZXcgUXVhZHRyZWVOb2RlTmVhcmVzdChjYXBhY2l0eSwgbWF4ZGVwdGgsIGJvdW5kYXJ5KTtcbiAgfVxuICBjbGVhcihib3VuZGFyeSkge1xuICAgIHRoaXMucm9vdC5jbGVhcihib3VuZGFyeSk7XG4gIH1cbiAgYWRkVmFsdWUoaGl0VGVzdGVyLCB2YWx1ZSkge1xuICAgIGNvbnN0IGVsZW0gPSB7XG4gICAgICBoaXRUZXN0ZXIsXG4gICAgICB2YWx1ZSxcbiAgICAgIGRpc3RhbmNlU3F1YXJlZDogKHgsIHkpID0+IHtcbiAgICAgICAgcmV0dXJuIGhpdFRlc3Rlci5kaXN0YW5jZVNxdWFyZWQoeCwgeSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJvb3QuYWRkRWxlbShlbGVtKTtcbiAgfVxuICBmaW5kKHgsIHkpIHtcbiAgICBjb25zdCBhcmcgPSB7IGJlc3Q6IHsgbmVhcmVzdDogdm9pZCAwLCBkaXN0YW5jZVNxdWFyZWQ6IEluZmluaXR5IH0gfTtcbiAgICB0aGlzLnJvb3QuZmluZCh4LCB5LCBhcmcpO1xuICAgIHJldHVybiBhcmcuYmVzdDtcbiAgfVxufTtcbnZhciBRdWFkdHJlZVN1YmRpdmlzaW9ucyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobncsIG5lLCBzdywgc2UpIHtcbiAgICB0aGlzLm53ID0gbnc7XG4gICAgdGhpcy5uZSA9IG5lO1xuICAgIHRoaXMuc3cgPSBzdztcbiAgICB0aGlzLnNlID0gc2U7XG4gIH1cbiAgYWRkRWxlbShlbGVtKSB7XG4gICAgdGhpcy5udy5hZGRFbGVtKGVsZW0pO1xuICAgIHRoaXMubmUuYWRkRWxlbShlbGVtKTtcbiAgICB0aGlzLnN3LmFkZEVsZW0oZWxlbSk7XG4gICAgdGhpcy5zZS5hZGRFbGVtKGVsZW0pO1xuICB9XG4gIGZpbmQoeCwgeSwgYXJnKSB7XG4gICAgdGhpcy5udy5maW5kKHgsIHksIGFyZyk7XG4gICAgdGhpcy5uZS5maW5kKHgsIHksIGFyZyk7XG4gICAgdGhpcy5zdy5maW5kKHgsIHksIGFyZyk7XG4gICAgdGhpcy5zZS5maW5kKHgsIHksIGFyZyk7XG4gIH1cbn07XG52YXIgUXVhZHRyZWVOb2RlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjYXBhY2l0eSwgbWF4ZGVwdGgsIGJvdW5kYXJ5KSB7XG4gICAgdGhpcy5jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIHRoaXMubWF4ZGVwdGggPSBtYXhkZXB0aDtcbiAgICB0aGlzLmJvdW5kYXJ5ID0gYm91bmRhcnkgPz8gQkJveC5OYU47XG4gICAgdGhpcy5lbGVtcyA9IFtdO1xuICAgIHRoaXMuc3ViZGl2aXNpb25zID0gdm9pZCAwO1xuICB9XG4gIGNsZWFyKGJvdW5kYXJ5KSB7XG4gICAgdGhpcy5lbGVtcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeTtcbiAgICB0aGlzLnN1YmRpdmlzaW9ucyA9IHZvaWQgMDtcbiAgfVxuICBhZGRFbGVtKGUpIHtcbiAgICBpZiAodGhpcy5hZGRDb25kaXRpb24oZSkpIHtcbiAgICAgIGlmICh0aGlzLnN1YmRpdmlzaW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0aGlzLm1heGRlcHRoID09PSAwIHx8IHRoaXMuZWxlbXMubGVuZ3RoIDwgdGhpcy5jYXBhY2l0eSkge1xuICAgICAgICAgIHRoaXMuZWxlbXMucHVzaChlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN1YmRpdmlkZShlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdWJkaXZpc2lvbnMuYWRkRWxlbShlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmluZCh4LCB5LCBhcmcpIHtcbiAgICBpZiAodGhpcy5maW5kQ29uZGl0aW9uKHgsIHksIGFyZykpIHtcbiAgICAgIGlmICh0aGlzLnN1YmRpdmlzaW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuZmluZEFjdGlvbih4LCB5LCBhcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdWJkaXZpc2lvbnMuZmluZCh4LCB5LCBhcmcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdWJkaXZpZGUobmV3RWxlbSkge1xuICAgIHRoaXMuc3ViZGl2aXNpb25zID0gdGhpcy5tYWtlU3ViZGl2aXNpb25zKCk7XG4gICAgZm9yIChjb25zdCBlIG9mIHRoaXMuZWxlbXMpIHtcbiAgICAgIHRoaXMuc3ViZGl2aXNpb25zLmFkZEVsZW0oZSk7XG4gICAgfVxuICAgIHRoaXMuc3ViZGl2aXNpb25zLmFkZEVsZW0obmV3RWxlbSk7XG4gICAgdGhpcy5lbGVtcy5sZW5ndGggPSAwO1xuICB9XG4gIG1ha2VTdWJkaXZpc2lvbnMoKSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IHRoaXMuYm91bmRhcnk7XG4gICAgY29uc3QgeyBjYXBhY2l0eSB9ID0gdGhpcztcbiAgICBjb25zdCBkZXB0aCA9IHRoaXMubWF4ZGVwdGggLSAxO1xuICAgIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoMiAvIDI7XG4gICAgY29uc3QgaGFsZkhlaWdodCA9IGhlaWdodDIgLyAyO1xuICAgIGNvbnN0IG53Qm91bmRhcnkgPSBuZXcgQkJveCh4LCB5LCBoYWxmV2lkdGgsIGhhbGZIZWlnaHQpO1xuICAgIGNvbnN0IG5lQm91bmRhcnkgPSBuZXcgQkJveCh4ICsgaGFsZldpZHRoLCB5LCBoYWxmV2lkdGgsIGhhbGZIZWlnaHQpO1xuICAgIGNvbnN0IHN3Qm91bmRhcnkgPSBuZXcgQkJveCh4LCB5ICsgaGFsZkhlaWdodCwgaGFsZldpZHRoLCBoYWxmSGVpZ2h0KTtcbiAgICBjb25zdCBzZUJvdW5kYXJ5ID0gbmV3IEJCb3goeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIGhhbGZXaWR0aCwgaGFsZkhlaWdodCk7XG4gICAgcmV0dXJuIG5ldyBRdWFkdHJlZVN1YmRpdmlzaW9ucyhcbiAgICAgIHRoaXMuY2hpbGQoY2FwYWNpdHksIGRlcHRoLCBud0JvdW5kYXJ5KSxcbiAgICAgIHRoaXMuY2hpbGQoY2FwYWNpdHksIGRlcHRoLCBuZUJvdW5kYXJ5KSxcbiAgICAgIHRoaXMuY2hpbGQoY2FwYWNpdHksIGRlcHRoLCBzd0JvdW5kYXJ5KSxcbiAgICAgIHRoaXMuY2hpbGQoY2FwYWNpdHksIGRlcHRoLCBzZUJvdW5kYXJ5KVxuICAgICk7XG4gIH1cbn07XG52YXIgUXVhZHRyZWVOb2RlTmVhcmVzdCA9IGNsYXNzIF9RdWFkdHJlZU5vZGVOZWFyZXN0IGV4dGVuZHMgUXVhZHRyZWVOb2RlIHtcbiAgYWRkQ29uZGl0aW9uKGUpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGUuaGl0VGVzdGVyLm1pZFBvaW50O1xuICAgIHJldHVybiB0aGlzLmJvdW5kYXJ5LmNvbnRhaW5zUG9pbnQoeCwgeSk7XG4gIH1cbiAgZmluZENvbmRpdGlvbih4LCB5LCBhcmcpIHtcbiAgICBjb25zdCB7IGJlc3QgfSA9IGFyZztcbiAgICByZXR1cm4gYmVzdC5kaXN0YW5jZVNxdWFyZWQgIT09IDAgJiYgdGhpcy5ib3VuZGFyeS5kaXN0YW5jZVNxdWFyZWQoeCwgeSkgPCBiZXN0LmRpc3RhbmNlU3F1YXJlZDtcbiAgfVxuICBmaW5kQWN0aW9uKHgsIHksIGFyZykge1xuICAgIGNvbnN0IG90aGVyID0gbmVhcmVzdFNxdWFyZWQoeCwgeSwgdGhpcy5lbGVtcywgYXJnLmJlc3QuZGlzdGFuY2VTcXVhcmVkKTtcbiAgICBpZiAob3RoZXIubmVhcmVzdCAhPT0gdm9pZCAwICYmIG90aGVyLmRpc3RhbmNlU3F1YXJlZCA8IGFyZy5iZXN0LmRpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgYXJnLmJlc3QgPSBvdGhlcjtcbiAgICB9XG4gIH1cbiAgY2hpbGQoY2FwYWNpdHksIGRlcHRoLCBib3VuZGFyeSkge1xuICAgIHJldHVybiBuZXcgX1F1YWR0cmVlTm9kZU5lYXJlc3QoY2FwYWNpdHksIGRlcHRoLCBib3VuZGFyeSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL2xpbmVhclNjYWxlLnRzXG52YXIgTGluZWFyU2NhbGUgPSBjbGFzcyBfTGluZWFyU2NhbGUgZXh0ZW5kcyBDb250aW51b3VzU2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihbMCwgMV0sIFswLCAxXSk7XG4gICAgdGhpcy50eXBlID0gXCJudW1iZXJcIjtcbiAgfVxuICBzdGF0aWMgZ2V0VGlja1N0ZXAoc3RhcnQyLCBzdG9wLCB0aWNrcykge1xuICAgIGNvbnN0IHsgaW50ZXJ2YWwsIHRpY2tDb3VudCA9IENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0VGlja0NvdW50LCBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCB9ID0gdGlja3M7XG4gICAgcmV0dXJuIGludGVydmFsID8/IHRpY2tTdGVwKHN0YXJ0Miwgc3RvcCwgdGlja0NvdW50LCBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCk7XG4gIH1cbiAgdG9Eb21haW4oZCkge1xuICAgIHJldHVybiBkO1xuICB9XG4gIHRpY2tzKHsgaW50ZXJ2YWwsIHRpY2tDb3VudCA9IENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0VGlja0NvdW50LCBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCB9LCBkb21haW4gPSB0aGlzLmRvbWFpbiwgdmlzaWJsZVJhbmdlKSB7XG4gICAgaWYgKCFkb21haW4gfHwgZG9tYWluLmxlbmd0aCA8IDIgfHwgdGlja0NvdW50IDwgMSB8fCAhZG9tYWluLmV2ZXJ5KGlzRmluaXRlKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBbZDAsIGQxXSA9IGRvbWFpbjtcbiAgICBpZiAoaW50ZXJ2YWwpIHtcbiAgICAgIGNvbnN0IHN0ZXAgPSBNYXRoLmFicyhpbnRlcnZhbCk7XG4gICAgICBpZiAoIWlzRGVuc2VJbnRlcnZhbCgoZDEgLSBkMCkgLyBzdGVwLCB0aGlzLmdldFBpeGVsUmFuZ2UoKSkpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlKGQwLCBkMSwgc3RlcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVUaWNrcyhkMCwgZDEsIHRpY2tDb3VudCwgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQsIHZpc2libGVSYW5nZSk7XG4gIH1cbiAgbmljZURvbWFpbih0aWNrcywgZG9tYWluID0gdGhpcy5kb21haW4pIHtcbiAgICBpZiAoZG9tYWluLmxlbmd0aCA8IDIpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgeyB0aWNrQ291bnQgPSBDb250aW51b3VzU2NhbGUuZGVmYXVsdFRpY2tDb3VudCB9ID0gdGlja3M7XG4gICAgbGV0IFtzdGFydDIsIHN0b3BdID0gZG9tYWluO1xuICAgIGlmICh0aWNrQ291bnQgPT09IDEpIHtcbiAgICAgIFtzdGFydDIsIHN0b3BdID0gbmljZVRpY2tzRG9tYWluKHN0YXJ0Miwgc3RvcCk7XG4gICAgfSBlbHNlIGlmICh0aWNrQ291bnQgPiAxKSB7XG4gICAgICBjb25zdCByb3VuZFN0YXJ0ID0gc3RhcnQyID4gc3RvcCA/IE1hdGguY2VpbCA6IE1hdGguZmxvb3I7XG4gICAgICBjb25zdCByb3VuZFN0b3AgPSBzdGFydDIgPiBzdG9wID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbDtcbiAgICAgIGNvbnN0IG1heEF0dGVtcHRzID0gNDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4QXR0ZW1wdHM7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2MCA9IHN0YXJ0MjtcbiAgICAgICAgY29uc3QgcHJldjEgPSBzdG9wO1xuICAgICAgICBjb25zdCBzdGVwID0gX0xpbmVhclNjYWxlLmdldFRpY2tTdGVwKHN0YXJ0Miwgc3RvcCwgdGlja3MpO1xuICAgICAgICBjb25zdCBbZDAsIGQxXSA9IGRvbWFpbjtcbiAgICAgICAgc3RhcnQyID0gcm91bmRTdGFydChkMCAvIHN0ZXApICogc3RlcDtcbiAgICAgICAgc3RvcCA9IHJvdW5kU3RvcChkMSAvIHN0ZXApICogc3RlcDtcbiAgICAgICAgaWYgKHN0YXJ0MiA9PT0gcHJldjAgJiYgc3RvcCA9PT0gcHJldjEpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbc3RhcnQyLCBzdG9wXTtcbiAgfVxuICB0aWNrRm9ybWF0dGVyKHsgdGlja3M6IHNwZWNpZmllZFRpY2tzLCBmcmFjdGlvbkRpZ2l0cywgc3BlY2lmaWVyIH0pIHtcbiAgICByZXR1cm4gc3BlY2lmaWVyICE9IG51bGwgPyB0aWNrRm9ybWF0KHNwZWNpZmllZFRpY2tzLCBzcGVjaWZpZXIpIDogKHgpID0+IGZvcm1hdFZhbHVlKHgsIGZyYWN0aW9uRGlnaXRzKTtcbiAgfVxuICBkYXR1bUZvcm1hdHRlcih7IHRpY2tzOiBzcGVjaWZpZWRUaWNrcywgZnJhY3Rpb25EaWdpdHMsIHNwZWNpZmllciB9KSB7XG4gICAgcmV0dXJuIHNwZWNpZmllciAhPSBudWxsID8gdGlja0Zvcm1hdChzcGVjaWZpZWRUaWNrcywgc3BlY2lmaWVyKSA6ICh4KSA9PiBmb3JtYXRWYWx1ZSh4LCBmcmFjdGlvbkRpZ2l0cyArIDEpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2V4dGVudC50c1xuZnVuY3Rpb24gZXh0ZW50KHZhbHVlcykge1xuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBtaW4gPSBJbmZpbml0eTtcbiAgbGV0IG1heCA9IC1JbmZpbml0eTtcbiAgZm9yIChjb25zdCBuIG9mIHZhbHVlcykge1xuICAgIGNvbnN0IHYgPSBuIGluc3RhbmNlb2YgRGF0ZSA/IG4uZ2V0VGltZSgpIDogbjtcbiAgICBpZiAodHlwZW9mIHYgIT09IFwibnVtYmVyXCIpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAodiA8IG1pbikge1xuICAgICAgbWluID0gdjtcbiAgICB9XG4gICAgaWYgKHYgPiBtYXgpIHtcbiAgICAgIG1heCA9IHY7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFttaW4sIG1heF07XG4gIHJldHVybiByZXN1bHQuZXZlcnkoaXNGaW5pdGUpID8gcmVzdWx0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGEoZCwgbWluLCBtYXgpIHtcbiAgbGV0IGNsaXBwZWQgPSBmYWxzZTtcbiAgaWYgKGQubGVuZ3RoID4gMikge1xuICAgIGQgPSBleHRlbnQoZCkgPz8gW05hTiwgTmFOXTtcbiAgfVxuICBpZiAoIWlzTmFOKG1pbikpIHtcbiAgICBjbGlwcGVkIHx8IChjbGlwcGVkID0gbWluID4gZFswXSk7XG4gICAgZCA9IFttaW4sIGRbMV1dO1xuICB9XG4gIGlmICghaXNOYU4obWF4KSkge1xuICAgIGNsaXBwZWQgfHwgKGNsaXBwZWQgPSBtYXggPCBkWzFdKTtcbiAgICBkID0gW2RbMF0sIG1heF07XG4gIH1cbiAgaWYgKGRbMF0gPiBkWzFdKSB7XG4gICAgZCA9IFtdO1xuICB9XG4gIHJldHVybiB7IGV4dGVudDogZCwgY2xpcHBlZCB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL251bWJlckF4aXMudHNcbnZhciBOdW1iZXJBeGlzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5BeGlzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4LCBzY2FsZTIgPSBuZXcgTGluZWFyU2NhbGUoKSkge1xuICAgIHN1cGVyKG1vZHVsZUN0eCwgc2NhbGUyKTtcbiAgICB0aGlzLm1pbiA9IE5hTjtcbiAgICB0aGlzLm1heCA9IE5hTjtcbiAgfVxuICBub3JtYWxpc2VEYXRhRG9tYWluKGQpIHtcbiAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZXh0ZW50OiBleHRlbnQyLCBjbGlwcGVkIH0gPSBub3JtYWxpc2VkRXh0ZW50V2l0aE1ldGFkYXRhKGQsIG1pbiwgbWF4KTtcbiAgICByZXR1cm4geyBkb21haW46IGV4dGVudDIsIGNsaXBwZWQgfTtcbiAgfVxufTtcbk51bWJlckF4aXMuY2xhc3NOYW1lID0gXCJOdW1iZXJBeGlzXCI7XG5OdW1iZXJBeGlzLnR5cGUgPSBcIm51bWJlclwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKE5VTUJFUl9PUl9OQU4sIExFU1NfVEhBTihcIm1heFwiKSkpLFxuICBEZWZhdWx0KE5hTilcbl0sIE51bWJlckF4aXMucHJvdG90eXBlLCBcIm1pblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFORChOVU1CRVJfT1JfTkFOLCBHUkVBVEVSX1RIQU4oXCJtaW5cIikpKSxcbiAgRGVmYXVsdChOYU4pXG5dLCBOdW1iZXJBeGlzLnByb3RvdHlwZSwgXCJtYXhcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvdGltZUF4aXMudHNcbnZhciBUaW1lQXhpcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuQXhpcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKG1vZHVsZUN0eCwgbmV3IFRpbWVTY2FsZSgpKTtcbiAgICB0aGlzLm1pbiA9IHZvaWQgMDtcbiAgICB0aGlzLm1heCA9IHZvaWQgMDtcbiAgfVxuICBub3JtYWxpc2VEYXRhRG9tYWluKGQpIHtcbiAgICBsZXQgeyBtaW4sIG1heCB9ID0gdGhpcztcbiAgICBsZXQgY2xpcHBlZCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgbWluID09PSBcIm51bWJlclwiKSB7XG4gICAgICBtaW4gPSBuZXcgRGF0ZShtaW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1heCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgbWF4ID0gbmV3IERhdGUobWF4KTtcbiAgICB9XG4gICAgaWYgKGQubGVuZ3RoID4gMikge1xuICAgICAgZCA9IGV4dGVudChkKT8ubWFwKCh4KSA9PiBuZXcgRGF0ZSh4KSkgPz8gW107XG4gICAgfVxuICAgIGlmIChtaW4gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBjbGlwcGVkIHx8IChjbGlwcGVkID0gbWluID4gZFswXSk7XG4gICAgICBkID0gW21pbiwgZFsxXV07XG4gICAgfVxuICAgIGlmIChtYXggaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBjbGlwcGVkIHx8IChjbGlwcGVkID0gbWF4IDwgZFsxXSk7XG4gICAgICBkID0gW2RbMF0sIG1heF07XG4gICAgfVxuICAgIGlmIChkWzBdID4gZFsxXSkge1xuICAgICAgZCA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4geyBkb21haW46IGQsIGNsaXBwZWQgfTtcbiAgfVxufTtcblRpbWVBeGlzLmNsYXNzTmFtZSA9IFwiVGltZUF4aXNcIjtcblRpbWVBeGlzLnR5cGUgPSBcInRpbWVcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFORChEQVRFX09SX0RBVEVUSU1FX01TLCBMRVNTX1RIQU4oXCJtYXhcIikpLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUaW1lQXhpcy5wcm90b3R5cGUsIFwibWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKERBVEVfT1JfREFURVRJTUVfTVMsIEdSRUFURVJfVEhBTihcIm1pblwiKSksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRpbWVBeGlzLnByb3RvdHlwZSwgXCJtYXhcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9kYXRhTW9kZWxTZXJpZXMudHNcbnZhciBEYXRhTW9kZWxTZXJpZXMgPSBjbGFzcyBleHRlbmRzIFNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jbGlwRm9jdXNCb3ggPSB0cnVlO1xuICB9XG4gIGdldFNjYWxlSW5mb3JtYXRpb24oe1xuICAgIHhTY2FsZSxcbiAgICB5U2NhbGVcbiAgfSkge1xuICAgIGNvbnN0IGlzQ29udGludW91c1ggPSBDb250aW51b3VzU2NhbGUuaXMoeFNjYWxlKTtcbiAgICBjb25zdCBpc0NvbnRpbnVvdXNZID0gQ29udGludW91c1NjYWxlLmlzKHlTY2FsZSk7XG4gICAgcmV0dXJuIHsgaXNDb250aW51b3VzWCwgaXNDb250aW51b3VzWSwgeFNjYWxlVHlwZTogeFNjYWxlPy50eXBlLCB5U2NhbGVUeXBlOiB5U2NhbGU/LnR5cGUgfTtcbiAgfVxuICBnZXRNb2R1bGVQcm9wZXJ0eURlZmluaXRpb25zKCkge1xuICAgIGNvbnN0IHhTY2FsZSA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dPy5zY2FsZTtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVNYXAubWFwTW9kdWxlcygobW9kMikgPT4gbW9kMi5nZXRQcm9wZXJ0eURlZmluaXRpb25zKHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHhTY2FsZSwgeVNjYWxlIH0pKSkuZmxhdCgpO1xuICB9XG4gIC8vIFJlcXVlc3QgZGF0YSwgYnV0IHdpdGggbWVzc2FnZSBkaXNwYXRjaGluZyB0byBzZXJpZXMtb3B0aW9ucyAobW9kdWxlcykuXG4gIGFzeW5jIHJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIGRhdGEsIG9wdHMpIHtcbiAgICBvcHRzLnByb3BzLnB1c2goLi4udGhpcy5nZXRNb2R1bGVQcm9wZXJ0eURlZmluaXRpb25zKCkpO1xuICAgIGNvbnN0IHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0gPSBhd2FpdCBkYXRhQ29udHJvbGxlci5yZXF1ZXN0KHRoaXMuaWQsIGRhdGEgPz8gW10sIG9wdHMpO1xuICAgIHRoaXMuZGF0YU1vZGVsID0gZGF0YU1vZGVsO1xuICAgIHRoaXMucHJvY2Vzc2VkRGF0YSA9IHByb2Nlc3NlZERhdGE7XG4gICAgdGhpcy5kaXNwYXRjaChcImRhdGEtcHJvY2Vzc2VkXCIsIHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0pO1xuICAgIHJldHVybiB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9O1xuICB9XG4gIGlzUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKSB7XG4gICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdHMgPSB0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmFuaW1hdGlvblZhbGlkYXRpb247XG4gICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0cykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHsgb3JkZXJlZEtleXMsIHVuaXF1ZUtleXMgfSA9IHZhbGlkYXRpb25SZXN1bHRzO1xuICAgIHJldHVybiBvcmRlcmVkS2V5cyAmJiB1bmlxdWVLZXlzO1xuICB9XG4gIGNoZWNrUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKSkge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgfVxuICB9XG4gIHBpY2tGb2N1cyhvcHRzKSB7XG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLmdldE5vZGVEYXRhKCk7XG4gICAgaWYgKG5vZGVEYXRhID09PSB2b2lkIDAgfHwgbm9kZURhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRhdHVtSW5kZXggPSB0aGlzLmNvbXB1dGVGb2N1c0RhdHVtSW5kZXgob3B0cywgbm9kZURhdGEpO1xuICAgIGlmIChkYXR1bUluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjbGlwRm9jdXNCb3ggfSA9IHRoaXM7XG4gICAgY29uc3QgZGF0dW0gPSBub2RlRGF0YVtkYXR1bUluZGV4XTtcbiAgICBjb25zdCBkZXJpdmVkT3B0cyA9IHsgLi4ub3B0cywgZGF0dW1JbmRleCB9O1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuY29tcHV0ZUZvY3VzQm91bmRzKGRlcml2ZWRPcHRzKTtcbiAgICBpZiAoYm91bmRzICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IGJvdW5kcywgY2xpcEZvY3VzQm94LCBkYXR1bSwgZGF0dW1JbmRleCB9O1xuICAgIH1cbiAgfVxuICBjb21wdXRlRm9jdXNEYXR1bUluZGV4KG9wdHMsIG5vZGVEYXRhKSB7XG4gICAgY29uc3QgaXNEYXR1bUVuYWJsZWQgPSAoZGF0dW1JbmRleDIpID0+IHtcbiAgICAgIGNvbnN0IHsgbWlzc2luZyA9IGZhbHNlLCBlbmFibGVkID0gdHJ1ZSwgZm9jdXNhYmxlID0gdHJ1ZSB9ID0gbm9kZURhdGFbZGF0dW1JbmRleDJdO1xuICAgICAgcmV0dXJuICFtaXNzaW5nICYmIGVuYWJsZWQgJiYgZm9jdXNhYmxlO1xuICAgIH07XG4gICAgY29uc3Qgc2VhcmNoQmFja3dhcmQgPSAoZGF0dW1JbmRleDIsIGRlbHRhMykgPT4ge1xuICAgICAgd2hpbGUgKGRhdHVtSW5kZXgyID49IDAgJiYgIWlzRGF0dW1FbmFibGVkKGRhdHVtSW5kZXgyKSkge1xuICAgICAgICBkYXR1bUluZGV4MiArPSBkZWx0YTM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0dW1JbmRleDIgPT09IC0xID8gdm9pZCAwIDogZGF0dW1JbmRleDI7XG4gICAgfTtcbiAgICBjb25zdCBzZWFyY2hGb3J3YXJkID0gKGRhdHVtSW5kZXgyLCBkZWx0YTMpID0+IHtcbiAgICAgIHdoaWxlIChkYXR1bUluZGV4MiA8IG5vZGVEYXRhLmxlbmd0aCAmJiAhaXNEYXR1bUVuYWJsZWQoZGF0dW1JbmRleDIpKSB7XG4gICAgICAgIGRhdHVtSW5kZXgyICs9IGRlbHRhMztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXR1bUluZGV4MiA9PT0gbm9kZURhdGEubGVuZ3RoID8gdm9pZCAwIDogZGF0dW1JbmRleDI7XG4gICAgfTtcbiAgICBsZXQgZGF0dW1JbmRleDtcbiAgICBjb25zdCBjbGFtcGVkSW5kZXggPSBjbGFtcCgwLCBvcHRzLmRhdHVtSW5kZXgsIG5vZGVEYXRhLmxlbmd0aCAtIDEpO1xuICAgIGlmIChvcHRzLmRhdHVtSW5kZXhEZWx0YSA8IDApIHtcbiAgICAgIGRhdHVtSW5kZXggPSBzZWFyY2hCYWNrd2FyZChjbGFtcGVkSW5kZXgsIG9wdHMuZGF0dW1JbmRleERlbHRhKTtcbiAgICB9IGVsc2UgaWYgKG9wdHMuZGF0dW1JbmRleERlbHRhID4gMCkge1xuICAgICAgZGF0dW1JbmRleCA9IHNlYXJjaEZvcndhcmQoY2xhbXBlZEluZGV4LCBvcHRzLmRhdHVtSW5kZXhEZWx0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdHVtSW5kZXggPSBzZWFyY2hGb3J3YXJkKGNsYW1wZWRJbmRleCwgMSkgPz8gc2VhcmNoQmFja3dhcmQoY2xhbXBlZEluZGV4LCAtMSk7XG4gICAgfVxuICAgIGlmIChkYXR1bUluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChvcHRzLmRhdHVtSW5kZXhEZWx0YSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb3B0cy5kYXR1bUluZGV4IC0gb3B0cy5kYXR1bUluZGV4RGVsdGE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkYXR1bUluZGV4O1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc1Byb3BlcnRpZXMudHNcbnZhciBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZpbGwgPSBcInJnYmEoMjU1LDI1NSwyNTUsIDAuMzMpXCI7XG4gICAgdGhpcy5zdHJva2UgPSBgcmdiYSgwLCAwLCAwLCAwLjQpYDtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExJTkVfREFTSCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbnZhciBTZXJpZXNIaWdobGlnaHRTdHlsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0hpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJkaW1PcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG52YXIgVGV4dEhpZ2hsaWdodFN0eWxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jb2xvciA9IFwiYmxhY2tcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVGV4dEhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbnZhciBIaWdobGlnaHRQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpZ2hsaWdodFByb3BlcnRpZXMucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG52YXIgSGlnaGxpZ2h0U3R5bGUgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLml0ZW0gPSBuZXcgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlKCk7XG4gICAgdGhpcy5zZXJpZXMgPSBuZXcgU2VyaWVzSGlnaGxpZ2h0U3R5bGUoKTtcbiAgICB0aGlzLnRleHQgPSBuZXcgVGV4dEhpZ2hsaWdodFN0eWxlKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBIaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwiaXRlbVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJzZXJpZXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBIaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbnZhciBTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmZvY3VzUHJpb3JpdHkgPSBJbmZpbml0eTtcbiAgICB0aGlzLnNob3dJbkxlZ2VuZCA9IHRydWU7XG4gICAgdGhpcy5jdXJzb3IgPSBcImRlZmF1bHRcIjtcbiAgICB0aGlzLm5vZGVDbGlja1JhbmdlID0gXCJleGFjdFwiO1xuICAgIHRoaXMuaGlnaGxpZ2h0ID0gbmV3IEhpZ2hsaWdodFByb3BlcnRpZXMoKTtcbiAgICB0aGlzLmhpZ2hsaWdodFN0eWxlID0gbmV3IEhpZ2hsaWdodFN0eWxlKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImlkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInZpc2libGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSRUFMX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZm9jdXNQcmlvcml0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaG93SW5MZWdlbmRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjdXJzb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShJTlRFUkFDVElPTl9SQU5HRSlcbl0sIFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm5vZGVDbGlja1JhbmdlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaGlnaGxpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaGlnaGxpZ2h0U3R5bGVcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vY2FydGVzaWFuU2VyaWVzLnRzXG52YXIgREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX0tFWVMgPSB7XG4gIFtcInhcIiAvKiBYICovXTogW1wieEtleVwiXSxcbiAgW1wieVwiIC8qIFkgKi9dOiBbXCJ5S2V5XCJdXG59O1xudmFyIERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyA9IHtcbiAgW1wieFwiIC8qIFggKi9dOiBbXCJ4TmFtZVwiXSxcbiAgW1wieVwiIC8qIFkgKi9dOiBbXCJ5TmFtZVwiXVxufTtcbnZhciBDYXJ0ZXNpYW5TZXJpZXNOb2RlRXZlbnQgPSBjbGFzcyBleHRlbmRzIFNlcmllc05vZGVFdmVudCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIG5hdGl2ZUV2ZW50LCBkYXR1bSwgc2VyaWVzKSB7XG4gICAgc3VwZXIodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpO1xuICAgIHRoaXMueEtleSA9IHNlcmllcy5wcm9wZXJ0aWVzLnhLZXk7XG4gICAgdGhpcy55S2V5ID0gc2VyaWVzLnByb3BlcnRpZXMueUtleTtcbiAgfVxufTtcbnZhciBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnBpY2tPdXRzaWRlVmlzaWJsZU1pbm9yQXhpcyA9IGZhbHNlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsZWdlbmRJdGVtTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInBpY2tPdXRzaWRlVmlzaWJsZU1pbm9yQXhpc1wiLCAyKTtcbnZhciBSRU5ERVJfVE9fT0ZGU0NSRUVOX0NBTlZBU19USFJFU0hPTEQgPSAxMDA7XG52YXIgQ2FydGVzaWFuU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBEYXRhTW9kZWxTZXJpZXMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGF0aHNQZXJTZXJpZXMgPSBbXCJwYXRoXCJdLFxuICAgIGhhc01hcmtlcnMgPSBmYWxzZSxcbiAgICBoYXNIaWdobGlnaHRlZExhYmVscyA9IGZhbHNlLFxuICAgIHBhdGhzWkluZGV4U3ViT3JkZXJPZmZzZXQgPSBbXSxcbiAgICBkYXR1bVNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uID0gdHJ1ZSxcbiAgICBtYXJrZXJTZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbiA9IHRydWUsXG4gICAgYW5pbWF0aW9uQWx3YXlzVXBkYXRlU2VsZWN0aW9ucyA9IGZhbHNlLFxuICAgIGFuaW1hdGlvblJlc2V0Rm5zLFxuICAgIGRpcmVjdGlvbktleXMsXG4gICAgZGlyZWN0aW9uTmFtZXMsXG4gICAgLi4ub3RoZXJPcHRzXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBkaXJlY3Rpb25LZXlzLFxuICAgICAgZGlyZWN0aW9uTmFtZXMsXG4gICAgICBjYW5IYXZlQXhlczogdHJ1ZSxcbiAgICAgIC4uLm90aGVyT3B0c1xuICAgIH0pO1xuICAgIHRoaXMuTm9kZUV2ZW50ID0gQ2FydGVzaWFuU2VyaWVzTm9kZUV2ZW50O1xuICAgIHRoaXMuZGF0YU5vZGVHcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tc2VyaWVzLWRhdGFOb2Rlc2AsIHpJbmRleDogMCB9KVxuICAgICk7XG4gICAgdGhpcy5tYXJrZXJHcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tc2VyaWVzLW1hcmtlcnNgLCB6SW5kZXg6IDEgfSlcbiAgICApO1xuICAgIHRoaXMubGFiZWxHcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IFRyYW5zbGF0YWJsZUdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tc2VyaWVzLWxhYmVsc2AgfSlcbiAgICApO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMubGFiZWxHcm91cCwgVGV4dCk7XG4gICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5oaWdobGlnaHROb2RlLFxuICAgICAgKCkgPT4gdGhpcy5vcHRzLmhhc01hcmtlcnMgPyBuZXcgTWFya2VyKCkgOiB0aGlzLm5vZGVGYWN0b3J5KClcbiAgICApO1xuICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMuaGlnaGxpZ2h0TGFiZWwsIFRleHQpO1xuICAgIHRoaXMuYW5ub3RhdGlvblNlbGVjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUoKTtcbiAgICBpZiAoIWRpcmVjdGlvbktleXMgfHwgIWRpcmVjdGlvbk5hbWVzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gaW5pdGlhbGlzZSBzZXJpZXMgdHlwZSAke3RoaXMudHlwZX1gKTtcbiAgICB0aGlzLm9wdHMgPSB7XG4gICAgICBwYXRoc1BlclNlcmllcyxcbiAgICAgIGhhc01hcmtlcnMsXG4gICAgICBoYXNIaWdobGlnaHRlZExhYmVscyxcbiAgICAgIHBhdGhzWkluZGV4U3ViT3JkZXJPZmZzZXQsXG4gICAgICBkaXJlY3Rpb25LZXlzLFxuICAgICAgZGlyZWN0aW9uTmFtZXMsXG4gICAgICBhbmltYXRpb25SZXNldEZucyxcbiAgICAgIGFuaW1hdGlvbkFsd2F5c1VwZGF0ZVNlbGVjdGlvbnMsXG4gICAgICBkYXR1bVNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uLFxuICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb25cbiAgICB9O1xuICAgIHRoaXMucGF0aHMgPSBwYXRoc1BlclNlcmllcy5tYXAoKHBhdGgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUGF0aCh7IG5hbWU6IGAke3RoaXMuaWR9LSR7cGF0aH1gIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuZGF0dW1TZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5kYXRhTm9kZUdyb3VwLFxuICAgICAgKCkgPT4gdGhpcy5ub2RlRmFjdG9yeSgpLFxuICAgICAgZGF0dW1TZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvblxuICAgICk7XG4gICAgdGhpcy5tYXJrZXJTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMubWFya2VyR3JvdXAsIE1hcmtlciwgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb24pO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBuZXcgU3RhdGVNYWNoaW5lKFxuICAgICAgXCJlbXB0eVwiLFxuICAgICAge1xuICAgICAgICBlbXB0eToge1xuICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIixcbiAgICAgICAgICBkaXNhYmxlOiBcImRpc2FibGVkXCJcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZHk6IHtcbiAgICAgICAgICB1cGRhdGVEYXRhOiBcIndhaXRpbmdcIixcbiAgICAgICAgICBjbGVhcjogXCJjbGVhcmluZ1wiLFxuICAgICAgICAgIGhpZ2hsaWdodDogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0KGRhdGEpLFxuICAgICAgICAgIGhpZ2hsaWdodE1hcmtlcnM6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeUhpZ2hsaWdodE1hcmtlcnMoZGF0YSksXG4gICAgICAgICAgcmVzaXplOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlSZXNpemUoZGF0YSksXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCIsXG4gICAgICAgICAgZGlzYWJsZTogXCJkaXNhYmxlZFwiXG4gICAgICAgIH0sXG4gICAgICAgIHdhaXRpbmc6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJyZWFkeVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIixcbiAgICAgICAgICBkaXNhYmxlOiBcImRpc2FibGVkXCJcbiAgICAgICAgfSxcbiAgICAgICAgZGlzYWJsZWQ6IHtcbiAgICAgICAgICB1cGRhdGU6IChkYXRhKSA9PiB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpLFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJpbmc6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJlbXB0eVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICgpID0+IHRoaXMuY2hlY2tQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpXG4gICAgKTtcbiAgfVxuICBnZXQgY29udGV4dE5vZGVEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0Tm9kZURhdGE7XG4gIH1cbiAgZ2V0Tm9kZURhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dE5vZGVEYXRhPy5ub2RlRGF0YTtcbiAgfVxuICBhdHRhY2hTZXJpZXMoc2VyaWVzQ29udGVudE5vZGUsIHNlcmllc05vZGUsIGFubm90YXRpb25Ob2RlKSB7XG4gICAgc3VwZXIuYXR0YWNoU2VyaWVzKHNlcmllc0NvbnRlbnROb2RlLCBzZXJpZXNOb2RlLCBhbm5vdGF0aW9uTm9kZSk7XG4gICAgdGhpcy5hdHRhY2hQYXRocyh0aGlzLnBhdGhzLCBzZXJpZXNOb2RlLCBhbm5vdGF0aW9uTm9kZSk7XG4gIH1cbiAgZGV0YWNoU2VyaWVzKHNlcmllc0NvbnRlbnROb2RlLCBzZXJpZXNOb2RlLCBhbm5vdGF0aW9uTm9kZSkge1xuICAgIHN1cGVyLmRldGFjaFNlcmllcyhzZXJpZXNDb250ZW50Tm9kZSwgc2VyaWVzTm9kZSwgYW5ub3RhdGlvbk5vZGUpO1xuICAgIHRoaXMuZGV0YWNoUGF0aHModGhpcy5wYXRocywgc2VyaWVzTm9kZSwgYW5ub3RhdGlvbk5vZGUpO1xuICB9XG4gIGF0dGFjaFBhdGhzKHBhdGhzLCBfc2VyaWVzTm9kZSwgX2Fubm90YXRpb25Ob2RlKSB7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChwYXRoKTtcbiAgICB9XG4gIH1cbiAgZGV0YWNoUGF0aHMocGF0aHMsIF9zZXJpZXNOb2RlLCBfYW5ub3RhdGlvbk5vZGUpIHtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgIHRoaXMuY29udGVudEdyb3VwLnJlbW92ZUNoaWxkKHBhdGgpO1xuICAgIH1cbiAgfVxuICByZW5kZXJUb09mZnNjcmVlbkNhbnZhcygpIHtcbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuZ2V0Tm9kZURhdGEoKTtcbiAgICByZXR1cm4gbm9kZURhdGEgIT0gbnVsbCAmJiBub2RlRGF0YS5sZW5ndGggPiBSRU5ERVJfVE9fT0ZGU0NSRUVOX0NBTlZBU19USFJFU0hPTEQ7XG4gIH1cbiAgcmVzZXRBbmltYXRpb24ocGhhc2UpIHtcbiAgICBpZiAocGhhc2UgPT09IFwiaW5pdGlhbFwiKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJyZXNldFwiKTtcbiAgICB9IGVsc2UgaWYgKHBoYXNlID09PSBcInJlYWR5XCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInNraXBcIik7XG4gICAgfSBlbHNlIGlmIChwaGFzZSA9PT0gXCJkaXNhYmxlZFwiKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJkaXNhYmxlXCIpO1xuICAgIH1cbiAgfVxuICBhZGRDaGFydEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgdGhpcy5jdHguY2hhcnRFdmVudE1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsZWdlbmQtaXRlbS1jbGlja1wiLCAoZXZlbnQpID0+IHRoaXMub25MZWdlbmRJdGVtQ2xpY2soZXZlbnQpKSxcbiAgICAgIHRoaXMuY3R4LmNoYXJ0RXZlbnRNYW5hZ2VyLmFkZExpc3RlbmVyKFxuICAgICAgICBcImxlZ2VuZC1pdGVtLWRvdWJsZS1jbGlja1wiLFxuICAgICAgICAoZXZlbnQpID0+IHRoaXMub25MZWdlbmRJdGVtRG91YmxlQ2xpY2soZXZlbnQpXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9jb250ZXh0Tm9kZURhdGEgPSB2b2lkIDA7XG4gIH1cbiAgdXBkYXRlKHsgc2VyaWVzUmVjdCB9KSB7XG4gICAgY29uc3QgeyB2aXNpYmxlLCBfY29udGV4dE5vZGVEYXRhOiBwcmV2aW91c0NvbnRleHREYXRhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNlcmllcyA9IHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXI/LmdldEFjdGl2ZUhpZ2hsaWdodCgpPy5zZXJpZXM7XG4gICAgY29uc3Qgc2VyaWVzSGlnaGxpZ2h0ZWQgPSBzZXJpZXMgPT09IHRoaXM7XG4gICAgY29uc3QgcmVzaXplID0gdGhpcy5jaGVja1Jlc2l6ZShzZXJpZXNSZWN0KTtcbiAgICBjb25zdCBoaWdobGlnaHRJdGVtcyA9IHRoaXMudXBkYXRlSGlnaGxpZ2h0U2VsZWN0aW9uKHNlcmllc0hpZ2hsaWdodGVkKTtcbiAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbnModmlzaWJsZSk7XG4gICAgdGhpcy51cGRhdGVOb2RlcyhoaWdobGlnaHRJdGVtcywgc2VyaWVzSGlnaGxpZ2h0ZWQsIHZpc2libGUpO1xuICAgIGNvbnN0IGFuaW1hdGlvbkRhdGEgPSB0aGlzLmdldEFuaW1hdGlvbkRhdGEoc2VyaWVzUmVjdCwgcHJldmlvdXNDb250ZXh0RGF0YSk7XG4gICAgaWYgKCFhbmltYXRpb25EYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInJlc2l6ZVwiLCBhbmltYXRpb25EYXRhKTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlXCIsIGFuaW1hdGlvbkRhdGEpO1xuICB9XG4gIHVwZGF0ZVNlbGVjdGlvbnMoYW55U2VyaWVzSXRlbUVuYWJsZWQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYW5pbWF0aW9uU2tpcFVwZGF0ZSA9ICF0aGlzLm9wdHMuYW5pbWF0aW9uQWx3YXlzVXBkYXRlU2VsZWN0aW9ucyAmJiB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGlmICghYW55U2VyaWVzSXRlbUVuYWJsZWQgJiYgYW5pbWF0aW9uU2tpcFVwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubm9kZURhdGFSZWZyZXNoICYmICF0aGlzLmlzUGF0aE9yU2VsZWN0aW9uRGlydHkoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5ub2RlRGF0YVJlZnJlc2gpIHtcbiAgICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gZmFsc2U7XG4gICAgICB0aGlzLmRlYnVnKGBDYXJ0ZXNpYW5TZXJpZXMudXBkYXRlU2VsZWN0aW9ucygpIC0gY2FsbGluZyBjcmVhdGVOb2RlRGF0YSgpIGZvcmAsIHRoaXMuaWQpO1xuICAgICAgdGhpcy5tYXJrUXVhZHRyZWVEaXJ0eSgpO1xuICAgICAgdGhpcy5fY29udGV4dE5vZGVEYXRhID0gdGhpcy5jcmVhdGVOb2RlRGF0YSgpO1xuICAgICAgY29uc3QgYW5pbWF0aW9uVmFsaWQgPSB0aGlzLmlzUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKTtcbiAgICAgIGlmICh0aGlzLl9jb250ZXh0Tm9kZURhdGEpIHtcbiAgICAgICAgKF9hID0gdGhpcy5fY29udGV4dE5vZGVEYXRhKS5hbmltYXRpb25WYWxpZCA/PyAoX2EuYW5pbWF0aW9uVmFsaWQgPSBhbmltYXRpb25WYWxpZCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gdGhpcztcbiAgICAgIGlmIChkYXRhTW9kZWwgIT09IHZvaWQgMCAmJiBwcm9jZXNzZWREYXRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaChcImRhdGEtdXBkYXRlXCIsIHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVNlcmllc1NlbGVjdGlvbnMoKTtcbiAgfVxuICB1cGRhdGVTZXJpZXNTZWxlY3Rpb25zKHNlcmllc0hpZ2hsaWdodGVkKSB7XG4gICAgY29uc3QgeyBkYXR1bVNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24sIG1hcmtlclNlbGVjdGlvbiwgcGF0aHMgfSA9IHRoaXM7XG4gICAgY29uc3QgY29udGV4dERhdGEgPSB0aGlzLl9jb250ZXh0Tm9kZURhdGE7XG4gICAgaWYgKCFjb250ZXh0RGF0YSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IG5vZGVEYXRhLCBsYWJlbERhdGEsIGl0ZW1JZCB9ID0gY29udGV4dERhdGE7XG4gICAgdGhpcy51cGRhdGVQYXRocyh7IHNlcmllc0hpZ2hsaWdodGVkLCBpdGVtSWQsIGNvbnRleHREYXRhLCBwYXRocyB9KTtcbiAgICB0aGlzLmRhdHVtU2VsZWN0aW9uID0gdGhpcy51cGRhdGVEYXR1bVNlbGVjdGlvbih7IG5vZGVEYXRhLCBkYXR1bVNlbGVjdGlvbiB9KTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uID0gdGhpcy51cGRhdGVMYWJlbFNlbGVjdGlvbih7IGxhYmVsRGF0YSwgbGFiZWxTZWxlY3Rpb24gfSkgPz8gbGFiZWxTZWxlY3Rpb247XG4gICAgaWYgKHRoaXMub3B0cy5oYXNNYXJrZXJzKSB7XG4gICAgICB0aGlzLm1hcmtlclNlbGVjdGlvbiA9IHRoaXMudXBkYXRlTWFya2VyU2VsZWN0aW9uKHsgbm9kZURhdGEsIG1hcmtlclNlbGVjdGlvbiB9KTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlTm9kZXMoaGlnaGxpZ2h0ZWRJdGVtcywgc2VyaWVzSGlnaGxpZ2h0ZWQsIGFueVNlcmllc0l0ZW1FbmFibGVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGlnaGxpZ2h0U2VsZWN0aW9uLFxuICAgICAgaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24sXG4gICAgICBvcHRzOiB7IGhhc01hcmtlcnMsIGhhc0hpZ2hsaWdodGVkTGFiZWxzIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgdmlzaWJsZSA9IHRoaXMudmlzaWJsZSAmJiB0aGlzLl9jb250ZXh0Tm9kZURhdGEgIT0gbnVsbCAmJiBhbnlTZXJpZXNJdGVtRW5hYmxlZDtcbiAgICB0aGlzLmNvbnRlbnRHcm91cC52aXNpYmxlID0gYW5pbWF0aW9uRW5hYmxlZCB8fCB2aXNpYmxlO1xuICAgIHRoaXMuaGlnaGxpZ2h0R3JvdXAudmlzaWJsZSA9IChhbmltYXRpb25FbmFibGVkIHx8IHZpc2libGUpICYmIHNlcmllc0hpZ2hsaWdodGVkO1xuICAgIGNvbnN0IG9wYWNpdHkgPSB0aGlzLmdldE9wYWNpdHkoKTtcbiAgICBpZiAoaGFzTWFya2Vycykge1xuICAgICAgdGhpcy51cGRhdGVNYXJrZXJOb2Rlcyh7XG4gICAgICAgIG1hcmtlclNlbGVjdGlvbjogaGlnaGxpZ2h0U2VsZWN0aW9uLFxuICAgICAgICBpc0hpZ2hsaWdodDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJoaWdobGlnaHRNYXJrZXJzXCIsIGhpZ2hsaWdodFNlbGVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlRGF0dW1Ob2Rlcyh7XG4gICAgICAgIGRhdHVtU2VsZWN0aW9uOiBoaWdobGlnaHRTZWxlY3Rpb24sXG4gICAgICAgIGlzSGlnaGxpZ2h0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcImhpZ2hsaWdodFwiLCBoaWdobGlnaHRTZWxlY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoaGFzSGlnaGxpZ2h0ZWRMYWJlbHMpIHtcbiAgICAgIHRoaXMudXBkYXRlTGFiZWxOb2Rlcyh7IGxhYmVsU2VsZWN0aW9uOiBoaWdobGlnaHRMYWJlbFNlbGVjdGlvbiB9KTtcbiAgICB9XG4gICAgY29uc3QgeyBkYXRhTm9kZUdyb3VwLCBtYXJrZXJHcm91cCwgZGF0dW1TZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBtYXJrZXJTZWxlY3Rpb24sIHBhdGhzLCBsYWJlbEdyb3VwIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgaXRlbUlkIH0gPSB0aGlzLmNvbnRleHROb2RlRGF0YSA/PyB7fTtcbiAgICBkYXRhTm9kZUdyb3VwLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgIGRhdGFOb2RlR3JvdXAudmlzaWJsZSA9IGFuaW1hdGlvbkVuYWJsZWQgfHwgdmlzaWJsZTtcbiAgICBsYWJlbEdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIGlmIChoYXNNYXJrZXJzKSB7XG4gICAgICBtYXJrZXJHcm91cC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgIG1hcmtlckdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIH1cbiAgICBpZiAobGFiZWxHcm91cCkge1xuICAgICAgbGFiZWxHcm91cC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVQYXRoTm9kZXMoe1xuICAgICAgc2VyaWVzSGlnaGxpZ2h0ZWQsXG4gICAgICBpdGVtSWQsXG4gICAgICBwYXRocyxcbiAgICAgIG9wYWNpdHksXG4gICAgICB2aXNpYmxlLFxuICAgICAgYW5pbWF0aW9uRW5hYmxlZFxuICAgIH0pO1xuICAgIGlmICghZGF0YU5vZGVHcm91cC52aXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRGF0dW1Ob2Rlcyh7IGRhdHVtU2VsZWN0aW9uLCBoaWdobGlnaHRlZEl0ZW1zLCBpc0hpZ2hsaWdodDogZmFsc2UgfSk7XG4gICAgaWYgKCF0aGlzLnVzZXNQbGFjZWRMYWJlbHMpIHtcbiAgICAgIHRoaXMudXBkYXRlTGFiZWxOb2Rlcyh7IGxhYmVsU2VsZWN0aW9uIH0pO1xuICAgIH1cbiAgICBpZiAoaGFzTWFya2Vycykge1xuICAgICAgdGhpcy51cGRhdGVNYXJrZXJOb2Rlcyh7IG1hcmtlclNlbGVjdGlvbiwgaXNIaWdobGlnaHQ6IGZhbHNlIH0pO1xuICAgIH1cbiAgfVxuICBnZXRIaWdobGlnaHRMYWJlbERhdGEobGFiZWxEYXRhLCBoaWdobGlnaHRlZEl0ZW0pIHtcbiAgICBjb25zdCBsYWJlbEl0ZW1zID0gbGFiZWxEYXRhLmZpbHRlcihcbiAgICAgIChsZCkgPT4gbGQuZGF0dW0gPT09IGhpZ2hsaWdodGVkSXRlbS5kYXR1bSAmJiBsZC5pdGVtSWQgPT09IGhpZ2hsaWdodGVkSXRlbS5pdGVtSWRcbiAgICApO1xuICAgIHJldHVybiBsYWJlbEl0ZW1zLmxlbmd0aCA9PT0gMCA/IHZvaWQgMCA6IGxhYmVsSXRlbXM7XG4gIH1cbiAgZ2V0SGlnaGxpZ2h0RGF0YShfbm9kZURhdGEsIGhpZ2hsaWdodGVkSXRlbSkge1xuICAgIHJldHVybiBoaWdobGlnaHRlZEl0ZW0gPyBbaGlnaGxpZ2h0ZWRJdGVtXSA6IHZvaWQgMDtcbiAgfVxuICB1cGRhdGVIaWdobGlnaHRTZWxlY3Rpb24oc2VyaWVzSGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25zdCB7IGhpZ2hsaWdodFNlbGVjdGlvbiwgaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24sIF9jb250ZXh0Tm9kZURhdGE6IGNvbnRleHROb2RlRGF0YSB9ID0gdGhpcztcbiAgICBpZiAoIWNvbnRleHROb2RlRGF0YSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBoaWdobGlnaHRlZERhdHVtID0gdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlcj8uZ2V0QWN0aXZlSGlnaGxpZ2h0KCk7XG4gICAgY29uc3QgaXRlbSA9IHNlcmllc0hpZ2hsaWdodGVkICYmIGhpZ2hsaWdodGVkRGF0dW0/LmRhdHVtID8gaGlnaGxpZ2h0ZWREYXR1bSA6IHZvaWQgMDtcbiAgICBsZXQgbGFiZWxJdGVtcztcbiAgICBsZXQgaGlnaGxpZ2h0SXRlbXM7XG4gICAgaWYgKGl0ZW0gIT0gbnVsbCkge1xuICAgICAgY29uc3QgbGFiZWxzRW5hYmxlZCA9IHRoaXMuaXNMYWJlbEVuYWJsZWQoKTtcbiAgICAgIGNvbnN0IHsgbGFiZWxEYXRhLCBub2RlRGF0YSB9ID0gY29udGV4dE5vZGVEYXRhO1xuICAgICAgaGlnaGxpZ2h0SXRlbXMgPSB0aGlzLmdldEhpZ2hsaWdodERhdGEobm9kZURhdGEsIGl0ZW0pO1xuICAgICAgbGFiZWxJdGVtcyA9IGxhYmVsc0VuYWJsZWQgPyB0aGlzLmdldEhpZ2hsaWdodExhYmVsRGF0YShsYWJlbERhdGEsIGl0ZW0pIDogdm9pZCAwO1xuICAgIH1cbiAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbiA9IHRoaXMudXBkYXRlSGlnaGxpZ2h0U2VsZWN0aW9uSXRlbSh7XG4gICAgICBpdGVtczogaGlnaGxpZ2h0SXRlbXMsXG4gICAgICBoaWdobGlnaHRTZWxlY3Rpb25cbiAgICB9KTtcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uID0gdGhpcy51cGRhdGVIaWdobGlnaHRTZWxlY3Rpb25MYWJlbCh7XG4gICAgICBpdGVtczogbGFiZWxJdGVtcyxcbiAgICAgIGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uXG4gICAgfSk7XG4gICAgcmV0dXJuIGhpZ2hsaWdodEl0ZW1zO1xuICB9XG4gIG1hcmtRdWFkdHJlZURpcnR5KCkge1xuICAgIHRoaXMucXVhZHRyZWUgPSB2b2lkIDA7XG4gIH1cbiAgKmRhdHVtTm9kZXNJdGVyKCkge1xuICAgIGZvciAoY29uc3QgeyBub2RlIH0gb2YgdGhpcy5kYXR1bVNlbGVjdGlvbikge1xuICAgICAgaWYgKG5vZGUuZGF0dW0ubWlzc2luZyA9PT0gdHJ1ZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB5aWVsZCBub2RlO1xuICAgIH1cbiAgfVxuICBnZXRRdWFkVHJlZSgpIHtcbiAgICBpZiAodGhpcy5xdWFkdHJlZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCB7IHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gdGhpcy5jdHguc2NlbmUuY2FudmFzO1xuICAgICAgY29uc3QgY2FudmFzUmVjdCA9IG5ldyBCQm94KDAsIDAsIHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgICB0aGlzLnF1YWR0cmVlID0gbmV3IFF1YWR0cmVlTmVhcmVzdCgxMDAsIDEwLCBjYW52YXNSZWN0KTtcbiAgICAgIHRoaXMuaW5pdFF1YWRUcmVlKHRoaXMucXVhZHRyZWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5xdWFkdHJlZTtcbiAgfVxuICBpbml0UXVhZFRyZWUoX3F1YWR0cmVlKSB7XG4gIH1cbiAgcGlja05vZGVFeGFjdFNoYXBlKHBvaW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIucGlja05vZGVFeGFjdFNoYXBlKHBvaW50KTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50O1xuICAgIGNvbnN0IHtcbiAgICAgIG9wdHM6IHsgaGFzTWFya2VycyB9XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IG1hdGNoO1xuICAgIGNvbnN0IHsgZGF0YU5vZGVHcm91cCwgbWFya2VyR3JvdXAgfSA9IHRoaXM7XG4gICAgbWF0Y2ggPSBkYXRhTm9kZUdyb3VwLnBpY2tOb2RlKHgsIHkpO1xuICAgIGlmICghbWF0Y2ggJiYgaGFzTWFya2Vycykge1xuICAgICAgbWF0Y2ggPSBtYXJrZXJHcm91cD8ucGlja05vZGUoeCwgeSk7XG4gICAgfVxuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5kYXR1bS5taXNzaW5nICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4geyBkYXR1bTogbWF0Y2guZGF0dW0sIGRpc3RhbmNlOiAwIH07XG4gICAgfVxuICAgIGZvciAoY29uc3QgbW9kMiBvZiB0aGlzLm1vZHVsZU1hcC5tb2R1bGVzKCkpIHtcbiAgICAgIGNvbnN0IHsgZGF0dW0gfSA9IG1vZDIucGlja05vZGVFeGFjdChwb2ludCkgPz8ge307XG4gICAgICBpZiAoZGF0dW0gPT0gbnVsbClcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoZGF0dW0/Lm1pc3NpbmcgPT09IHRydWUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcmV0dXJuIHsgZGF0dW0sIGRpc3RhbmNlOiAwIH07XG4gICAgfVxuICB9XG4gIHBpY2tOb2RlQ2xvc2VzdERhdHVtKHBvaW50KSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludDtcbiAgICBjb25zdCB7IGF4ZXMsIF9jb250ZXh0Tm9kZURhdGE6IGNvbnRleHROb2RlRGF0YSB9ID0gdGhpcztcbiAgICBpZiAoIWNvbnRleHROb2RlRGF0YSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGNvbnN0IGhpdFBvaW50ID0geyB4LCB5IH07XG4gICAgbGV0IG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgbGV0IGNsb3Nlc3REYXR1bTtcbiAgICBmb3IgKGNvbnN0IGRhdHVtIG9mIGNvbnRleHROb2RlRGF0YS5ub2RlRGF0YSkge1xuICAgICAgY29uc3QgeyBwb2ludDogeyB4OiBkYXR1bVggPSBOYU4sIHk6IGRhdHVtWSA9IE5hTiB9ID0ge30gfSA9IGRhdHVtO1xuICAgICAgaWYgKGlzTmFOKGRhdHVtWCkgfHwgaXNOYU4oZGF0dW1ZKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzSW5SYW5nZSA9IHhBeGlzPy5pblJhbmdlKGRhdHVtWCkgJiYgeUF4aXM/LmluUmFuZ2UoZGF0dW1ZKTtcbiAgICAgIGlmICghaXNJblJhbmdlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlzdGFuY2UyID0gTWF0aC5tYXgoKGhpdFBvaW50LnggLSBkYXR1bVgpICoqIDIgKyAoaGl0UG9pbnQueSAtIGRhdHVtWSkgKiogMiwgMCk7XG4gICAgICBpZiAoZGlzdGFuY2UyIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTI7XG4gICAgICAgIGNsb3Nlc3REYXR1bSA9IGRhdHVtO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IG1vZDIgb2YgdGhpcy5tb2R1bGVNYXAubW9kdWxlcygpKSB7XG4gICAgICBjb25zdCBtb2RQaWNrID0gbW9kMi5waWNrTm9kZU5lYXJlc3QocG9pbnQpO1xuICAgICAgaWYgKG1vZFBpY2sgIT09IHZvaWQgMCAmJiBtb2RQaWNrLmRpc3RhbmNlU3F1YXJlZCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgIG1pbkRpc3RhbmNlID0gbW9kUGljay5kaXN0YW5jZVNxdWFyZWQ7XG4gICAgICAgIGNsb3Nlc3REYXR1bSA9IG1vZFBpY2suZGF0dW07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xvc2VzdERhdHVtKSB7XG4gICAgICBjb25zdCBkaXN0YW5jZTIgPSBNYXRoLm1heChNYXRoLnNxcnQobWluRGlzdGFuY2UpIC0gKGNsb3Nlc3REYXR1bS5wb2ludD8uc2l6ZSA/PyAwKSwgMCk7XG4gICAgICByZXR1cm4geyBkYXR1bTogY2xvc2VzdERhdHVtLCBkaXN0YW5jZTogZGlzdGFuY2UyIH07XG4gICAgfVxuICB9XG4gIHBpY2tOb2RlTWFpbkF4aXNGaXJzdChwb2ludCwgcmVxdWlyZUNhdGVnb3J5QXhpcykge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQ7XG4gICAgY29uc3QgeyBheGVzLCBfY29udGV4dE5vZGVEYXRhOiBjb250ZXh0Tm9kZURhdGEgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBwaWNrT3V0c2lkZVZpc2libGVNaW5vckF4aXMgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAoIWNvbnRleHROb2RlRGF0YSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGNvbnN0IGRpcmVjdGlvbnMyID0gW3hBeGlzLCB5QXhpc10uZmlsdGVyKENhdGVnb3J5QXhpcy5pcykubWFwKChhKSA9PiBhLmRpcmVjdGlvbik7XG4gICAgaWYgKHJlcXVpcmVDYXRlZ29yeUF4aXMgJiYgZGlyZWN0aW9uczIubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IFttYWpvckRpcmVjdGlvbiA9IFwieFwiIC8qIFggKi9dID0gZGlyZWN0aW9uczI7XG4gICAgY29uc3QgaGl0UG9pbnRDb29yZHMgPSBbeCwgeV07XG4gICAgaWYgKG1ham9yRGlyZWN0aW9uICE9PSBcInhcIiAvKiBYICovKVxuICAgICAgaGl0UG9pbnRDb29yZHMucmV2ZXJzZSgpO1xuICAgIGNvbnN0IG1pbkRpc3RhbmNlID0gW0luZmluaXR5LCBJbmZpbml0eV07XG4gICAgbGV0IGNsb3Nlc3REYXR1bTtcbiAgICBmb3IgKGNvbnN0IGRhdHVtIG9mIGNvbnRleHROb2RlRGF0YS5ub2RlRGF0YSkge1xuICAgICAgY29uc3QgeyB4OiBkYXR1bVggPSBOYU4sIHk6IGRhdHVtWSA9IE5hTiB9ID0gZGF0dW0ucG9pbnQgPz8gZGF0dW0ubWlkUG9pbnQgPz8ge307XG4gICAgICBpZiAoaXNOYU4oZGF0dW1YKSB8fCBpc05hTihkYXR1bVkpIHx8IGRhdHVtLm1pc3NpbmcgPT09IHRydWUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdmlzaWJsZSA9IFt4QXhpcz8uaW5SYW5nZShkYXR1bVgpLCB5QXhpcz8uaW5SYW5nZShkYXR1bVkpXTtcbiAgICAgIGlmIChtYWpvckRpcmVjdGlvbiAhPT0gXCJ4XCIgLyogWCAqLykge1xuICAgICAgICB2aXNpYmxlLnJldmVyc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmlzaWJsZVswXSB8fCAhcGlja091dHNpZGVWaXNpYmxlTWlub3JBeGlzICYmICF2aXNpYmxlWzFdKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGRhdHVtUG9pbnQgPSBbZGF0dW1YLCBkYXR1bVldO1xuICAgICAgaWYgKG1ham9yRGlyZWN0aW9uICE9PSBcInhcIiAvKiBYICovKSB7XG4gICAgICAgIGRhdHVtUG9pbnQucmV2ZXJzZSgpO1xuICAgICAgfVxuICAgICAgbGV0IG5ld01pbkRpc3RhbmNlID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0dW1Qb2ludC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5hYnMoZGF0dW1Qb2ludFtpXSAtIGhpdFBvaW50Q29vcmRzW2ldKTtcbiAgICAgICAgaWYgKGRpc3QgPiBtaW5EaXN0YW5jZVtpXSkge1xuICAgICAgICAgIG5ld01pbkRpc3RhbmNlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlzdCA8IG1pbkRpc3RhbmNlW2ldKSB7XG4gICAgICAgICAgbWluRGlzdGFuY2VbaV0gPSBkaXN0O1xuICAgICAgICAgIG1pbkRpc3RhbmNlLmZpbGwoSW5maW5pdHksIGkgKyAxLCBtaW5EaXN0YW5jZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmV3TWluRGlzdGFuY2UpIHtcbiAgICAgICAgY2xvc2VzdERhdHVtID0gZGF0dW07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjbG9zZXN0RGF0dW0pIHtcbiAgICAgIGxldCBjbG9zZXN0RGlzdGFuY2VTcXVhcmVkID0gTWF0aC5tYXgoXG4gICAgICAgIG1pbkRpc3RhbmNlWzBdICoqIDIgKyBtaW5EaXN0YW5jZVsxXSAqKiAyIC0gKGNsb3Nlc3REYXR1bS5wb2ludD8uc2l6ZSA/PyAwKSxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3QgbW9kMiBvZiB0aGlzLm1vZHVsZU1hcC5tb2R1bGVzKCkpIHtcbiAgICAgICAgY29uc3QgbW9kUGljayA9IG1vZDIucGlja05vZGVNYWluQXhpc0ZpcnN0KHBvaW50KTtcbiAgICAgICAgaWYgKG1vZFBpY2sgIT09IHZvaWQgMCAmJiBtb2RQaWNrLmRpc3RhbmNlU3F1YXJlZCA8IGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQpIHtcbiAgICAgICAgICBjbG9zZXN0RGF0dW0gPSBtb2RQaWNrLmRhdHVtO1xuICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQgPSBtb2RQaWNrLmRpc3RhbmNlU3F1YXJlZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0dW06IGNsb3Nlc3REYXR1bSwgZGlzdGFuY2U6IE1hdGguc3FydChjbG9zZXN0RGlzdGFuY2VTcXVhcmVkKSB9O1xuICAgIH1cbiAgfVxuICBpc1BhdGhPclNlbGVjdGlvbkRpcnR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzaG91bGRGbGlwWFkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFdvcmthcm91bmQgLSBpdCB3b3VsZCBiZSBuaWNlIGlmIHRoaXMgZGlmZmVyZW5jZSBkaWRuJ3QgZXhpc3RcbiAga2V5c09yVmFsdWVzKHhLZXkpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCB4S2V5KTtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzZWREYXRhPy5rZXlzW2tleV0/LmdldCh0aGlzLmlkKSA/PyB0aGlzLnByb2Nlc3NlZERhdGE/LmNvbHVtbnNba2V5XSA/PyBbXTtcbiAgfVxuICB2aXNpYmxlUmFuZ2UoYXhpc0tleSwgdmlzaWJsZVJhbmdlLCBpbmRpY2VzKSB7XG4gICAgY29uc3QgeFZhbHVlcyA9IHRoaXMua2V5c09yVmFsdWVzKGF4aXNLZXkpO1xuICAgIGNvbnN0IHBpeGVsU2l6ZSA9IDA7XG4gICAgcmV0dXJuIHZpc2libGVSYW5nZUluZGljZXMoaW5kaWNlcz8ubGVuZ3RoID8/IHhWYWx1ZXMubGVuZ3RoLCB2aXNpYmxlUmFuZ2UsICh0b3BJbmRleCkgPT4ge1xuICAgICAgY29uc3QgZGF0dW1JbmRleCA9IGluZGljZXM/Llt0b3BJbmRleF0gPz8gdG9wSW5kZXg7XG4gICAgICByZXR1cm4gdGhpcy54Q29vcmRpbmF0ZVJhbmdlKHhWYWx1ZXNbZGF0dW1JbmRleF0sIHBpeGVsU2l6ZSwgZGF0dW1JbmRleCk7XG4gICAgfSk7XG4gIH1cbiAgZG9tYWluRm9yVmlzaWJsZVJhbmdlKF9kaXJlY3Rpb24sIGF4aXNLZXlzLCBjcm9zc0F4aXNLZXksIHZpc2libGVSYW5nZSwgc29ydGVkLCBpbmRpY2VzKSB7XG4gICAgY29uc3QgeyBwcm9jZXNzZWREYXRhLCBkYXRhTW9kZWwgfSA9IHRoaXM7XG4gICAgY29uc3QgW3IwLCByMV0gPSB2aXNpYmxlUmFuZ2U7XG4gICAgY29uc3QgY3Jvc3NBeGlzVmFsdWVzID0gdGhpcy5rZXlzT3JWYWx1ZXMoY3Jvc3NBeGlzS2V5KTtcbiAgICBpZiAoc29ydGVkKSB7XG4gICAgICBjb25zdCBjcm9zc0F4aXNSYW5nZSA9IHRoaXMudmlzaWJsZVJhbmdlKGNyb3NzQXhpc0tleSwgdmlzaWJsZVJhbmdlLCBpbmRpY2VzKTtcbiAgICAgIHJldHVybiBkYXRhTW9kZWwuZ2V0RG9tYWluQmV0d2VlblJhbmdlKHRoaXMsIGF4aXNLZXlzLCBjcm9zc0F4aXNSYW5nZSwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGFsbEF4aXNWYWx1ZXMgPSBheGlzS2V5cy5tYXAoKGF4aXNLZXkpID0+IHRoaXMua2V5c09yVmFsdWVzKGF4aXNLZXkpKTtcbiAgICBsZXQgYXhpc01pbiA9IEluZmluaXR5O1xuICAgIGxldCBheGlzTWF4ID0gLUluZmluaXR5O1xuICAgIGNyb3NzQXhpc1ZhbHVlcy5mb3JFYWNoKChjcm9zc0F4aXNWYWx1ZSwgaSkgPT4ge1xuICAgICAgY29uc3QgW3gwLCB4MV0gPSB0aGlzLnhDb29yZGluYXRlUmFuZ2UoY3Jvc3NBeGlzVmFsdWUsIDAsIGkpO1xuICAgICAgaWYgKHgxIDwgcjAgfHwgeDAgPiByMSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBheGlzS2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBheGlzVmFsdWUgPSBhbGxBeGlzVmFsdWVzW2pdW2ldO1xuICAgICAgICBheGlzTWluID0gTWF0aC5taW4oYXhpc01pbiwgYXhpc1ZhbHVlKTtcbiAgICAgICAgYXhpc01heCA9IE1hdGgubWF4KGF4aXNNYXgsIGF4aXNWYWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGF4aXNNaW4gPiBheGlzTWF4KVxuICAgICAgcmV0dXJuIFtOYU4sIE5hTl07XG4gICAgcmV0dXJuIFtheGlzTWluLCBheGlzTWF4XTtcbiAgfVxuICBkb21haW5Gb3JDbGlwcGVkUmFuZ2UoZGlyZWN0aW9uLCBheGlzS2V5cywgY3Jvc3NBeGlzS2V5LCBzb3J0ZWQpIHtcbiAgICBjb25zdCB7IHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCwgYXhlcyB9ID0gdGhpcztcbiAgICBjb25zdCBjcm9zc0RpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLyA/IFwieVwiIC8qIFkgKi8gOiBcInhcIiAvKiBYICovO1xuICAgIGNvbnN0IGNyb3NzQXhpc1JhbmdlID0gYXhpc0V4dGVudChheGVzW2Nyb3NzRGlyZWN0aW9uXSk7XG4gICAgaWYgKCFjcm9zc0F4aXNSYW5nZSkge1xuICAgICAgcmV0dXJuIGF4aXNLZXlzLmZsYXRNYXAoKGF4aXNLZXkpID0+IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYXhpc0tleSwgXCJ2YWx1ZVwiLCBwcm9jZXNzZWREYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGNyb3NzQXhpc1ZhbHVlcyA9IHRoaXMua2V5c09yVmFsdWVzKGNyb3NzQXhpc0tleSk7XG4gICAgaWYgKHNvcnRlZCkge1xuICAgICAgY29uc3QgY3Jvc3NSYW5nZSA9IGNsaXBwZWRSYW5nZUluZGljZXMoXG4gICAgICAgIGNyb3NzQXhpc1ZhbHVlcy5sZW5ndGgsXG4gICAgICAgIGNyb3NzQXhpc1JhbmdlLFxuICAgICAgICAoaW5kZXgpID0+IGNyb3NzQXhpc1ZhbHVlc1tpbmRleF1cbiAgICAgICk7XG4gICAgICByZXR1cm4gZGF0YU1vZGVsLmdldERvbWFpbkJldHdlZW5SYW5nZSh0aGlzLCBheGlzS2V5cywgY3Jvc3NSYW5nZSwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGFsbEF4aXNWYWx1ZXMgPSBheGlzS2V5cy5tYXAoKGF4aXNLZXkpID0+IHRoaXMua2V5c09yVmFsdWVzKGF4aXNLZXkpKTtcbiAgICBjb25zdCByYW5nZTAgPSBjcm9zc0F4aXNSYW5nZVswXS52YWx1ZU9mKCk7XG4gICAgY29uc3QgcmFuZ2UxID0gY3Jvc3NBeGlzUmFuZ2VbMV0udmFsdWVPZigpO1xuICAgIGNvbnN0IGF4aXNWYWx1ZXMgPSBbXTtcbiAgICBjcm9zc0F4aXNWYWx1ZXMuZm9yRWFjaCgoY3Jvc3NBeGlzVmFsdWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IGMgPSBjcm9zc0F4aXNWYWx1ZS52YWx1ZU9mKCk7XG4gICAgICBpZiAoYyA8IHJhbmdlMCB8fCBjID4gcmFuZ2UxKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB2YWx1ZXMgPSBhbGxBeGlzVmFsdWVzLm1hcCgodikgPT4gdltpXSk7XG4gICAgICBpZiAoYyA+PSByYW5nZTApIHtcbiAgICAgICAgYXhpc1ZhbHVlcy5wdXNoKC4uLnZhbHVlcyk7XG4gICAgICB9XG4gICAgICBpZiAoYyA8PSByYW5nZTEpIHtcbiAgICAgICAgYXhpc1ZhbHVlcy5wdXNoKC4uLnZhbHVlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGF4aXNWYWx1ZXM7XG4gIH1cbiAgY291bnRWaXNpYmxlSXRlbXMoY3Jvc3NBeGlzS2V5LCBheGlzS2V5cywgeFZpc2libGVSYW5nZSwgeVZpc2libGVSYW5nZSwgbWluVmlzaWJsZUl0ZW1zKSB7XG4gICAgY29uc3QgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSA9IHRoaXM7XG4gICAgaWYgKCFkYXRhTW9kZWwgfHwgIXByb2Nlc3NlZERhdGEpXG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgY29uc3QgY3Jvc3NWYWx1ZXMgPSB0aGlzLmtleXNPclZhbHVlcyhjcm9zc0F4aXNLZXkpO1xuICAgIGNvbnN0IGFsbEF4aXNWYWx1ZXMgPSBheGlzS2V5cy5tYXAoKGF4aXNLZXkpID0+IGRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBheGlzS2V5LCBwcm9jZXNzZWREYXRhKSk7XG4gICAgY29uc3QgY3Jvc3NBeGlzID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgY29uc3Qgc2hvdWxkRmxpcFhZID0gdGhpcy5zaG91bGRGbGlwWFkoKTtcbiAgICBjb25zdCBjcm9zc1JhbmdlID0gY3Jvc3NBeGlzLnJhbmdlO1xuICAgIGNvbnN0IHJhbmdlMyA9IGF4aXMucmFuZ2U7XG4gICAgY29uc3QgY29udmVydCA9IChkLCByLCB2KSA9PiB7XG4gICAgICByZXR1cm4gZFswXSArICh2IC0gclswXSkgLyAoclsxXSAtIHJbMF0pICogKGRbMV0gLSBkWzBdKTtcbiAgICB9O1xuICAgIGNvbnN0IGNyb3NzTWluID0gY29udmVydChjcm9zc1JhbmdlLCBjcm9zc0F4aXMudmlzaWJsZVJhbmdlLCB4VmlzaWJsZVJhbmdlWzBdKTtcbiAgICBjb25zdCBjcm9zc01heCA9IGNvbnZlcnQoY3Jvc3NSYW5nZSwgY3Jvc3NBeGlzLnZpc2libGVSYW5nZSwgeFZpc2libGVSYW5nZVsxXSk7XG4gICAgY29uc3QgYXhpc01pbiA9IGNvbnZlcnQocmFuZ2UzLCBheGlzLnZpc2libGVSYW5nZSwgc2hvdWxkRmxpcFhZID8geVZpc2libGVSYW5nZVswXSA6IHlWaXNpYmxlUmFuZ2VbMV0pO1xuICAgIGNvbnN0IGF4aXNNYXggPSBjb252ZXJ0KHJhbmdlMywgYXhpcy52aXNpYmxlUmFuZ2UsIHNob3VsZEZsaXBYWSA/IHlWaXNpYmxlUmFuZ2VbMV0gOiB5VmlzaWJsZVJhbmdlWzBdKTtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gTWF0aC5yb3VuZChcbiAgICAgICh4VmlzaWJsZVJhbmdlWzBdICsgKHhWaXNpYmxlUmFuZ2VbMV0gLSB4VmlzaWJsZVJhbmdlWzBdKSAvIDIpICogY3Jvc3NWYWx1ZXMubGVuZ3RoXG4gICAgKTtcbiAgICBjb25zdCBwaXhlbFNpemUgPSAwO1xuICAgIHJldHVybiBjb3VudEV4cGFuZGluZ1NlYXJjaCgwLCBjcm9zc1ZhbHVlcy5sZW5ndGggLSAxLCBzdGFydEluZGV4LCBtaW5WaXNpYmxlSXRlbXMsIChpbmRleCkgPT4ge1xuICAgICAgbGV0IFt4MCwgeDFdID0gdGhpcy54Q29vcmRpbmF0ZVJhbmdlKGNyb3NzVmFsdWVzW2luZGV4XSwgcGl4ZWxTaXplLCBpbmRleCk7XG4gICAgICBsZXQgW3kwLCB5MV0gPSB0aGlzLnlDb29yZGluYXRlUmFuZ2UoXG4gICAgICAgIGFsbEF4aXNWYWx1ZXMubWFwKChheGlzVmFsdWVzKSA9PiBheGlzVmFsdWVzW2luZGV4XSksXG4gICAgICAgIHBpeGVsU2l6ZSxcbiAgICAgICAgaW5kZXhcbiAgICAgICk7XG4gICAgICBpZiAoIWlzRmluaXRlTnVtYmVyKHgwKSB8fCAhaXNGaW5pdGVOdW1iZXIoeDEpIHx8ICFpc0Zpbml0ZU51bWJlcih5MCkgfHwgIWlzRmluaXRlTnVtYmVyKHkxKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkRmxpcFhZKVxuICAgICAgICBbeDAsIHgxLCB5MCwgeTFdID0gW3kwLCB5MSwgeDAsIHgxXTtcbiAgICAgIHJldHVybiB4MCA+PSBjcm9zc01pbiAmJiB4MSA8PSBjcm9zc01heCAmJiB5MCA+PSBheGlzTWluICYmIHkxIDw9IGF4aXNNYXg7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlSGlnaGxpZ2h0U2VsZWN0aW9uSXRlbShvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3B0czogeyBoYXNNYXJrZXJzIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7IGl0ZW1zLCBoaWdobGlnaHRTZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBpdGVtcyA/PyBbXTtcbiAgICBpZiAoaGFzTWFya2Vycykge1xuICAgICAgY29uc3QgbWFya2VyU2VsZWN0aW9uID0gaGlnaGxpZ2h0U2VsZWN0aW9uO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlTWFya2VyU2VsZWN0aW9uKHsgbm9kZURhdGEsIG1hcmtlclNlbGVjdGlvbiB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlRGF0dW1TZWxlY3Rpb24oe1xuICAgICAgICBub2RlRGF0YSxcbiAgICAgICAgZGF0dW1TZWxlY3Rpb246IGhpZ2hsaWdodFNlbGVjdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUhpZ2hsaWdodFNlbGVjdGlvbkxhYmVsKG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVMYWJlbFNlbGVjdGlvbih7XG4gICAgICBsYWJlbERhdGE6IG9wdHMuaXRlbXMgPz8gW10sXG4gICAgICBsYWJlbFNlbGVjdGlvbjogb3B0cy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvblxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZURhdHVtU2VsZWN0aW9uKG9wdHMpIHtcbiAgICByZXR1cm4gb3B0cy5kYXR1bVNlbGVjdGlvbjtcbiAgfVxuICB1cGRhdGVEYXR1bU5vZGVzKF9vcHRzKSB7XG4gIH1cbiAgdXBkYXRlTWFya2VyU2VsZWN0aW9uKG9wdHMpIHtcbiAgICByZXR1cm4gb3B0cy5tYXJrZXJTZWxlY3Rpb247XG4gIH1cbiAgdXBkYXRlTWFya2VyTm9kZXMoX29wdHMpIHtcbiAgfVxuICB1cGRhdGVQYXRocyhvcHRzKSB7XG4gICAgb3B0cy5wYXRocy5mb3JFYWNoKChwKSA9PiBwLnZpc2libGUgPSBmYWxzZSk7XG4gIH1cbiAgdXBkYXRlUGF0aE5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IHBhdGhzLCBvcGFjaXR5LCB2aXNpYmxlIH0gPSBvcHRzO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgcGF0aC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgIHBhdGgudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfVxuICB9XG4gIHJlc2V0UGF0aEFuaW1hdGlvbihkYXRhKSB7XG4gICAgY29uc3QgeyBwYXRoIH0gPSB0aGlzLm9wdHM/LmFuaW1hdGlvblJlc2V0Rm5zID8/IHt9O1xuICAgIGlmIChwYXRoKSB7XG4gICAgICBkYXRhLnBhdGhzLmZvckVhY2goKHBhdGhzKSA9PiB7XG4gICAgICAgIHJlc2V0TW90aW9uKFtwYXRoc10sIHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlc2V0RGF0dW1BbmltYXRpb24oZGF0YSkge1xuICAgIGNvbnN0IHsgZGF0dW0gfSA9IHRoaXMub3B0cz8uYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgaWYgKGRhdHVtKSB7XG4gICAgICByZXNldE1vdGlvbihbZGF0YS5kYXR1bVNlbGVjdGlvbl0sIGRhdHVtKTtcbiAgICB9XG4gIH1cbiAgcmVzZXRMYWJlbEFuaW1hdGlvbihkYXRhKSB7XG4gICAgY29uc3QgeyBsYWJlbCB9ID0gdGhpcy5vcHRzPy5hbmltYXRpb25SZXNldEZucyA/PyB7fTtcbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHJlc2V0TW90aW9uKFtkYXRhLmxhYmVsU2VsZWN0aW9uXSwgbGFiZWwpO1xuICAgIH1cbiAgfVxuICByZXNldE1hcmtlckFuaW1hdGlvbihkYXRhKSB7XG4gICAgY29uc3QgeyBtYXJrZXIgfSA9IHRoaXMub3B0cz8uYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgaWYgKG1hcmtlciAmJiB0aGlzLm9wdHMuaGFzTWFya2Vycykge1xuICAgICAgcmVzZXRNb3Rpb24oW2RhdGEubWFya2VyU2VsZWN0aW9uXSwgbWFya2VyKTtcbiAgICB9XG4gIH1cbiAgcmVzZXRBbGxBbmltYXRpb24oZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZCh0aGlzLmlkKTtcbiAgICB0aGlzLnJlc2V0UGF0aEFuaW1hdGlvbihkYXRhKTtcbiAgICB0aGlzLnJlc2V0RGF0dW1BbmltYXRpb24oZGF0YSk7XG4gICAgdGhpcy5yZXNldExhYmVsQW5pbWF0aW9uKGRhdGEpO1xuICAgIHRoaXMucmVzZXRNYXJrZXJBbmltYXRpb24oZGF0YSk7XG4gICAgaWYgKGRhdGEuY29udGV4dERhdGE/LmFuaW1hdGlvblZhbGlkID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgfVxuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XG4gIH1cbiAgYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0KGRhdGEpIHtcbiAgICBjb25zdCB7IGRhdHVtIH0gPSB0aGlzLm9wdHM/LmFuaW1hdGlvblJlc2V0Rm5zID8/IHt9O1xuICAgIGlmIChkYXR1bSkge1xuICAgICAgcmVzZXRNb3Rpb24oW2RhdGFdLCBkYXR1bSk7XG4gICAgfVxuICB9XG4gIGFuaW1hdGVSZWFkeUhpZ2hsaWdodE1hcmtlcnMoZGF0YSkge1xuICAgIGNvbnN0IHsgbWFya2VyIH0gPSB0aGlzLm9wdHM/LmFuaW1hdGlvblJlc2V0Rm5zID8/IHt9O1xuICAgIGlmIChtYXJrZXIpIHtcbiAgICAgIHJlc2V0TW90aW9uKFtkYXRhXSwgbWFya2VyKTtcbiAgICB9XG4gIH1cbiAgYW5pbWF0ZVJlYWR5UmVzaXplKGRhdGEpIHtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KGRhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGdldEFuaW1hdGlvbkRhdGEoc2VyaWVzUmVjdCwgcHJldmlvdXNDb250ZXh0RGF0YSkge1xuICAgIGNvbnN0IHsgX2NvbnRleHROb2RlRGF0YTogY29udGV4dERhdGEgfSA9IHRoaXM7XG4gICAgaWYgKCFjb250ZXh0RGF0YSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhbmltYXRpb25EYXRhID0ge1xuICAgICAgZGF0dW1TZWxlY3Rpb246IHRoaXMuZGF0dW1TZWxlY3Rpb24sXG4gICAgICBtYXJrZXJTZWxlY3Rpb246IHRoaXMubWFya2VyU2VsZWN0aW9uLFxuICAgICAgbGFiZWxTZWxlY3Rpb246IHRoaXMubGFiZWxTZWxlY3Rpb24sXG4gICAgICBhbm5vdGF0aW9uU2VsZWN0aW9uczogWy4uLnRoaXMuYW5ub3RhdGlvblNlbGVjdGlvbnNdLFxuICAgICAgY29udGV4dERhdGEsXG4gICAgICBwcmV2aW91c0NvbnRleHREYXRhLFxuICAgICAgcGF0aHM6IHRoaXMucGF0aHMsXG4gICAgICBzZXJpZXNSZWN0XG4gICAgfTtcbiAgICByZXR1cm4gYW5pbWF0aW9uRGF0YTtcbiAgfVxuICB1cGRhdGVMYWJlbFNlbGVjdGlvbihvcHRzKSB7XG4gICAgcmV0dXJuIG9wdHMubGFiZWxTZWxlY3Rpb247XG4gIH1cbiAgZ2V0U2NhbGluZyhzY2FsZTIpIHtcbiAgICBpZiAoc2NhbGUyIGluc3RhbmNlb2YgTG9nU2NhbGUpIHtcbiAgICAgIGNvbnN0IHsgcmFuZ2U6IHJhbmdlMywgZG9tYWluIH0gPSBzY2FsZTI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImxvZ1wiLFxuICAgICAgICBjb252ZXJ0OiAoZCkgPT4gc2NhbGUyLmNvbnZlcnQoZCksXG4gICAgICAgIGRvbWFpbjogW2RvbWFpblswXSwgZG9tYWluWzFdXSxcbiAgICAgICAgcmFuZ2U6IFtyYW5nZTNbMF0sIHJhbmdlM1sxXV1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzY2FsZTIgaW5zdGFuY2VvZiBDb250aW51b3VzU2NhbGUpIHtcbiAgICAgIGNvbnN0IHsgcmFuZ2U6IHJhbmdlMywgZG9tYWluIH0gPSBzY2FsZTI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImNvbnRpbnVvdXNcIixcbiAgICAgICAgZG9tYWluOiBbZG9tYWluWzBdLCBkb21haW5bMV1dLFxuICAgICAgICByYW5nZTogW3JhbmdlM1swXSwgcmFuZ2UzWzFdXVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHNjYWxlMiBpbnN0YW5jZW9mIEJhbmRTY2FsZSkge1xuICAgICAgY29uc3QgeyBkb21haW4gfSA9IHNjYWxlMjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgICAgICAgZG9tYWluLFxuICAgICAgICBpbnNldDogc2NhbGUyLmluc2V0LFxuICAgICAgICBzdGVwOiBzY2FsZTIuc3RlcFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgY2FsY3VsYXRlU2NhbGluZygpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGRpcmVjdGlvbiBvZiBPYmplY3QudmFsdWVzKENoYXJ0QXhpc0RpcmVjdGlvbikpIHtcbiAgICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4ZXNbZGlyZWN0aW9uXTtcbiAgICAgIGlmICghYXhpcylcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBzY2FsaW5nUmVzdWx0ID0gdGhpcy5nZXRTY2FsaW5nKGF4aXMuc2NhbGUpO1xuICAgICAgaWYgKHNjYWxpbmdSZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHRbZGlyZWN0aW9uXSA9IHNjYWxpbmdSZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5mdW5jdGlvbiBheGlzRXh0ZW50KGF4aXMpIHtcbiAgbGV0IG1pbjtcbiAgbGV0IG1heDtcbiAgaWYgKGF4aXMgaW5zdGFuY2VvZiBOdW1iZXJBeGlzICYmIChOdW1iZXIuaXNGaW5pdGUoYXhpcy5taW4pIHx8IE51bWJlci5pc0Zpbml0ZShheGlzLm1heCkpKSB7XG4gICAgbWluID0gTnVtYmVyLmlzRmluaXRlKGF4aXMubWluKSA/IGF4aXMubWluIDogdm9pZCAwO1xuICAgIG1heCA9IE51bWJlci5pc0Zpbml0ZShheGlzLm1heCkgPyBheGlzLm1heCA6IHZvaWQgMDtcbiAgfSBlbHNlIGlmIChheGlzIGluc3RhbmNlb2YgVGltZUF4aXMgJiYgKGF4aXMubWluICE9IG51bGwgfHwgYXhpcy5tYXggIT0gbnVsbCkpIHtcbiAgICAoeyBtaW4sIG1heCB9ID0gYXhpcyk7XG4gIH1cbiAgaWYgKG1pbiA9PSBudWxsICYmIG1heCA9PSBudWxsKVxuICAgIHJldHVybjtcbiAgbWluID8/IChtaW4gPSAtSW5maW5pdHkpO1xuICBtYXggPz8gKG1heCA9IEluZmluaXR5KTtcbiAgcmV0dXJuIFttaW4sIG1heF07XG59XG5mdW5jdGlvbiBjbGlwcGVkUmFuZ2VJbmRpY2VzKGxlbmd0aDIsIHJhbmdlMywgeFZhbHVlKSB7XG4gIGNvbnN0IHJhbmdlMCA9IHJhbmdlM1swXS52YWx1ZU9mKCk7XG4gIGNvbnN0IHJhbmdlMSA9IHJhbmdlM1sxXS52YWx1ZU9mKCk7XG4gIGNvbnN0IHhNaW5JbmRleCA9IGZpbmRNaW5JbmRleCgwLCBsZW5ndGgyIC0gMSwgKGluZGV4KSA9PiB7XG4gICAgY29uc3QgeCA9IHhWYWx1ZShpbmRleCk/LnZhbHVlT2YoKTtcbiAgICByZXR1cm4gIU51bWJlci5pc0Zpbml0ZSh4KSB8fCB4ID49IHJhbmdlMDtcbiAgfSk7XG4gIGxldCB4TWF4SW5kZXggPSBmaW5kTWF4SW5kZXgoMCwgbGVuZ3RoMiAtIDEsIChpbmRleCkgPT4ge1xuICAgIGNvbnN0IHggPSB4VmFsdWUoaW5kZXgpPy52YWx1ZU9mKCk7XG4gICAgcmV0dXJuICFOdW1iZXIuaXNGaW5pdGUoeCkgfHwgeCA8PSByYW5nZTE7XG4gIH0pO1xuICBpZiAoeE1pbkluZGV4ID09IG51bGwgfHwgeE1heEluZGV4ID09IG51bGwpXG4gICAgcmV0dXJuIFswLCAwXTtcbiAgeE1heEluZGV4ID0gTWF0aC5taW4oeE1heEluZGV4ICsgMSwgbGVuZ3RoMik7XG4gIHJldHVybiBbeE1pbkluZGV4LCB4TWF4SW5kZXhdO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jYXJ0ZXNpYW5DaGFydC50c1xudmFyIGRpcmVjdGlvbnMgPSBbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIl07XG52YXIgX0NhcnRlc2lhbkNoYXJ0ID0gY2xhc3MgX0NhcnRlc2lhbkNoYXJ0IGV4dGVuZHMgQ2hhcnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCByZXNvdXJjZXMpIHtcbiAgICBzdXBlcihvcHRpb25zLCByZXNvdXJjZXMpO1xuICAgIC8vIFRPRE8gc2hvdWxkIGNvbWUgZnJvbSB0aGVtZVxuICAgIC8qKiBJbnRlZ3JhdGVkIENoYXJ0cyBmZWF0dXJlIHN0YXRlIC0gbm90IHVzZWQgaW4gU3RhbmRhbG9uZSBDaGFydHMuICovXG4gICAgdGhpcy5wYWlyZWQgPSB0cnVlO1xuICAgIHRoaXMubGFzdFVwZGF0ZUNsaXBSZWN0ID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdExheW91dFdpZHRoID0gTmFOO1xuICAgIHRoaXMubGFzdExheW91dEhlaWdodCA9IE5hTjtcbiAgfVxuICBvbkF4aXNDaGFuZ2UobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgc3VwZXIub25BeGlzQ2hhbmdlKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgaWYgKHRoaXMuY3R4ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuY3R4Lnpvb21NYW5hZ2VyLnVwZGF0ZUF4ZXMobmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95U2VyaWVzKHNlcmllcykge1xuICAgIHN1cGVyLmRlc3Ryb3lTZXJpZXMoc2VyaWVzKTtcbiAgICB0aGlzLmxhc3RMYXlvdXRXaWR0aCA9IE5hTjtcbiAgICB0aGlzLmxhc3RMYXlvdXRIZWlnaHQgPSBOYU47XG4gIH1cbiAgZ2V0Q2hhcnRUeXBlKCkge1xuICAgIHJldHVybiBcImNhcnRlc2lhblwiO1xuICB9XG4gIHNldFJvb3RDbGlwUmVjdHMoY2xpcFJlY3QpIHtcbiAgICBjb25zdCB7IHNlcmllc1Jvb3QsIGFubm90YXRpb25Sb290IH0gPSB0aGlzO1xuICAgIHNlcmllc1Jvb3Quc2V0Q2xpcFJlY3QoY2xpcFJlY3QpO1xuICAgIGFubm90YXRpb25Sb290LnNldENsaXBSZWN0KGNsaXBSZWN0KTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YSgpIHtcbiAgICBhd2FpdCBzdXBlci5wcm9jZXNzRGF0YSgpO1xuICAgIGZvciAoY29uc3QgYXhpcyBvZiB0aGlzLmF4ZXMpIHtcbiAgICAgIGNvbnN0IHN5bmNlZERvbWFpbiA9IHRoaXMuZ2V0U3luY2VkRG9tYWluKGF4aXMpO1xuICAgICAgaWYgKHN5bmNlZERvbWFpbiAhPSBudWxsKSB7XG4gICAgICAgIGF4aXMuc2V0RG9tYWlucyhzeW5jZWREb21haW4pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN0eC51cGRhdGVTZXJ2aWNlLmRpc3BhdGNoUHJvY2Vzc0RhdGEoeyBzZXJpZXM6IHsgc2hvdWxkRmxpcFhZOiB0aGlzLnNob3VsZEZsaXBYWSgpIH0gfSk7XG4gIH1cbiAgcGVyZm9ybUxheW91dChjdHgpIHtcbiAgICBjb25zdCB7IHNlcmllc1Jvb3QsIGFubm90YXRpb25Sb290IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgY2xpcFNlcmllcywgc2VyaWVzUmVjdCwgdmlzaWJsZSB9ID0gdGhpcy51cGRhdGVBeGVzKGN0eC5sYXlvdXRCb3gpO1xuICAgIHRoaXMuc2VyaWVzUm9vdC52aXNpYmxlID0gdmlzaWJsZTtcbiAgICB0aGlzLnNlcmllc1JlY3QgPSBzZXJpZXNSZWN0O1xuICAgIHRoaXMuYW5pbWF0aW9uUmVjdCA9IGN0eC5sYXlvdXRCb3g7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBzZXJpZXNSZWN0O1xuICAgIGlmIChjdHgud2lkdGggIT09IHRoaXMubGFzdExheW91dFdpZHRoIHx8IGN0eC5oZWlnaHQgIT09IHRoaXMubGFzdExheW91dEhlaWdodCkge1xuICAgICAgZm9yIChjb25zdCBncm91cCBvZiBbc2VyaWVzUm9vdCwgYW5ub3RhdGlvblJvb3RdKSB7XG4gICAgICAgIGdyb3VwLnRyYW5zbGF0aW9uWCA9IE1hdGguZmxvb3IoeCk7XG4gICAgICAgIGdyb3VwLnRyYW5zbGF0aW9uWSA9IE1hdGguZmxvb3IoeSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSA9IHNlcmllc1Jvb3Q7XG4gICAgICBzdGF0aWNGcm9tVG9Nb3Rpb24oXG4gICAgICAgIHRoaXMuaWQsXG4gICAgICAgIFwic2VyaWVzUmVjdFwiLFxuICAgICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLFxuICAgICAgICBbc2VyaWVzUm9vdCwgYW5ub3RhdGlvblJvb3RdLFxuICAgICAgICB7IHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0sXG4gICAgICAgIHsgdHJhbnNsYXRpb25YOiBNYXRoLmZsb29yKHgpLCB0cmFuc2xhdGlvblk6IE1hdGguZmxvb3IoeSkgfSxcbiAgICAgICAgeyBwaGFzZTogXCJ1cGRhdGVcIiB9XG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmxhc3RMYXlvdXRXaWR0aCA9IGN0eC53aWR0aDtcbiAgICB0aGlzLmxhc3RMYXlvdXRIZWlnaHQgPSBjdHguaGVpZ2h0O1xuICAgIGNvbnN0IHNlcmllc1BhZGRlZFJlY3QgPSBzZXJpZXNSZWN0LmNsb25lKCkuZ3Jvdyh0aGlzLnNlcmllc0FyZWEucGFkZGluZyk7XG4gICAgY29uc3QgY2xpcFJlY3QgPSB0aGlzLnNlcmllc0FyZWEuY2xpcCB8fCBjbGlwU2VyaWVzID8gc2VyaWVzUGFkZGVkUmVjdCA6IHZvaWQgMDtcbiAgICBjb25zdCB7IGxhc3RVcGRhdGVDbGlwUmVjdCB9ID0gdGhpcztcbiAgICB0aGlzLmxhc3RVcGRhdGVDbGlwUmVjdCA9IGNsaXBSZWN0O1xuICAgIGlmICh0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzQWN0aXZlKCkgJiYgbGFzdFVwZGF0ZUNsaXBSZWN0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuYW5pbWF0ZSh7XG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBncm91cElkOiBcImNsaXAtcmVjdFwiLFxuICAgICAgICBwaGFzZTogXCJ1cGRhdGVcIixcbiAgICAgICAgZnJvbTogbGFzdFVwZGF0ZUNsaXBSZWN0LFxuICAgICAgICB0bzogc2VyaWVzUGFkZGVkUmVjdCxcbiAgICAgICAgb25VcGRhdGU6IChpbnRlcnBvbGF0ZWRDbGlwUmVjdCkgPT4gdGhpcy5zZXRSb290Q2xpcFJlY3RzKGludGVycG9sYXRlZENsaXBSZWN0KSxcbiAgICAgICAgb25Db21wbGV0ZTogKCkgPT4gdGhpcy5zZXRSb290Q2xpcFJlY3RzKGNsaXBSZWN0KVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Um9vdENsaXBSZWN0cyhjbGlwUmVjdCk7XG4gICAgfVxuICAgIHRoaXMuY3R4LmxheW91dE1hbmFnZXIuZW1pdExheW91dENvbXBsZXRlKGN0eCwge1xuICAgICAgYXhlczogdGhpcy5heGVzLm1hcCgoYXhpcykgPT4gYXhpcy5nZXRMYXlvdXRTdGF0ZSgpKSxcbiAgICAgIHNlcmllczoge1xuICAgICAgICB2aXNpYmxlLFxuICAgICAgICByZWN0OiBzZXJpZXNSZWN0LFxuICAgICAgICBwYWRkZWRSZWN0OiBzZXJpZXNQYWRkZWRSZWN0XG4gICAgICB9LFxuICAgICAgY2xpcFNlcmllc1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUF4ZXMobGF5b3V0Qm94KSB7XG4gICAgY29uc3QgeyBjbGlwU2VyaWVzLCBzZXJpZXNSZWN0LCBvdmVyZmxvd3MgfSA9IHRoaXMucmVzb2x2ZUF4ZXNMYXlvdXQobGF5b3V0Qm94KTtcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgdGhpcy5heGVzKSB7XG4gICAgICBheGlzLnVwZGF0ZSgpO1xuICAgICAgYXhpcy5zZXRDcm9zc0xpbmVzVmlzaWJsZSghb3ZlcmZsb3dzKTtcbiAgICAgIHRoaXMuY2xpcEF4aXMoYXhpcywgc2VyaWVzUmVjdCwgbGF5b3V0Qm94KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2xpcFNlcmllcywgc2VyaWVzUmVjdCwgdmlzaWJsZTogIW92ZXJmbG93cyB9O1xuICB9XG4gIC8vIEl0ZXJhdGl2ZWx5IHRyeSB0byByZXNvbHZlIGF4aXMgd2lkdGhzIC0gc2luY2UgWCBheGlzIHdpZHRoIGFmZmVjdHMgWSBheGlzIHJhbmdlLFxuICAvLyBhbmQgdmljZS12ZXJzYSwgd2UgbmVlZCB0byBpdGVyYXRpdmVseSB0cnkgYW5kIGZpbmQgYSBmaXQgZm9yIHRoZSBheGVzIGFuZCB0aGVpclxuICAvLyB0aWNrcy9sYWJlbHMuXG4gIHJlc29sdmVBeGVzTGF5b3V0KGxheW91dEJveCkge1xuICAgIGxldCBuZXdTdGF0ZTtcbiAgICBsZXQgcHJldlN0YXRlO1xuICAgIGxldCBpdGVyYXRpb25zID0gMDtcbiAgICBjb25zdCBtYXhJdGVyYXRpb25zID0gMTA7XG4gICAgZG8ge1xuICAgICAgcHJldlN0YXRlID0gbmV3U3RhdGUgPz8gdGhpcy5nZXREZWZhdWx0U3RhdGUoKTtcbiAgICAgIG5ld1N0YXRlID0gdGhpcy51cGRhdGVBeGVzUGFzcyhuZXcgTWFwKHByZXZTdGF0ZS5heGlzQXJlYVdpZHRocyksIGxheW91dEJveC5jbG9uZSgpKTtcbiAgICAgIGlmIChpdGVyYXRpb25zKysgPiBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm4oXCJNYXggaXRlcmF0aW9ucyByZWFjaGVkLiBVbmFibGUgdG8gc3RhYmlsaXplIGF4ZXMgbGF5b3V0LlwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoIXRoaXMuaXNMYXlvdXRTdGFibGUobmV3U3RhdGUsIHByZXZTdGF0ZSkpO1xuICAgIHRoaXMubGFzdEFyZWFXaWR0aHMgPSBuZXdTdGF0ZS5heGlzQXJlYVdpZHRocztcbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH1cbiAgdXBkYXRlQXhlc1Bhc3MoYXhpc0FyZWFXaWR0aHMsIGF4aXNBcmVhQm91bmQpIHtcbiAgICBjb25zdCBheGlzV2lkdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBwcmltYXJ5VGlja0NvdW50cyA9IHt9O1xuICAgIGxldCBvdmVyZmxvd3MgPSBmYWxzZTtcbiAgICBsZXQgY2xpcFNlcmllcyA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZGlyIG9mIGRpcmVjdGlvbnMpIHtcbiAgICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLnNlcmllc0FyZWEucGFkZGluZ1tkaXJdO1xuICAgICAgY29uc3QgYXhpcyA9IHRoaXMuYXhlcy5maW5kTGFzdCgoYSkgPT4gYS5wb3NpdGlvbiA9PT0gZGlyKTtcbiAgICAgIGlmIChheGlzKSB7XG4gICAgICAgIGF4aXMuc2VyaWVzQXJlYVBhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXhpc0FyZWFCb3VuZC5zaHJpbmsocGFkZGluZywgZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdG90YWxXaWR0aCA9IChheGlzQXJlYVdpZHRocy5nZXQoXCJsZWZ0XCIpID8/IDApICsgKGF4aXNBcmVhV2lkdGhzLmdldChcInJpZ2h0XCIpID8/IDApO1xuICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gKGF4aXNBcmVhV2lkdGhzLmdldChcInRvcFwiKSA/PyAwKSArIChheGlzQXJlYVdpZHRocy5nZXQoXCJib3R0b21cIikgPz8gMCk7XG4gICAgY29uc3QgY3Jvc3NMaW5lUGFkZGluZyA9IHRoaXMuYnVpbGRDcm9zc0xpbmVQYWRkaW5nKGF4aXNBcmVhV2lkdGhzKTtcbiAgICBpZiAoYXhpc0FyZWFCb3VuZC53aWR0aCA8PSB0b3RhbFdpZHRoICsgY3Jvc3NMaW5lUGFkZGluZy5oUGFkZGluZyB8fCBheGlzQXJlYUJvdW5kLmhlaWdodCA8PSB0b3RhbEhlaWdodCArIGNyb3NzTGluZVBhZGRpbmcudlBhZGRpbmcpIHtcbiAgICAgIG92ZXJmbG93cyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF4aXNBcmVhQm91bmQuc2hyaW5rKGNyb3NzTGluZVBhZGRpbmcpO1xuICAgIH1cbiAgICBjb25zdCBzZXJpZXNSZWN0ID0gYXhpc0FyZWFCb3VuZC5jbG9uZSgpLnNocmluayhPYmplY3QuZnJvbUVudHJpZXMoYXhpc0FyZWFXaWR0aHMpKTtcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgdGhpcy5heGVzKSB7XG4gICAgICBjb25zdCB7IHBvc2l0aW9uID0gXCJsZWZ0XCIsIGRpcmVjdGlvbiB9ID0gYXhpcztcbiAgICAgIHRoaXMuc2l6ZUF4aXMoYXhpcywgc2VyaWVzUmVjdCwgcG9zaXRpb24pO1xuICAgICAgY29uc3QgaXNWZXJ0aWNhbCA9IGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLztcbiAgICAgIGNvbnN0IHsgcHJpbWFyeVRpY2tDb3VudCwgYmJveCB9ID0gYXhpcy5jYWxjdWxhdGVMYXlvdXQoXG4gICAgICAgIGF4aXMubmljZSA/IHByaW1hcnlUaWNrQ291bnRzW2RpcmVjdGlvbl0gOiB2b2lkIDBcbiAgICAgICk7XG4gICAgICBwcmltYXJ5VGlja0NvdW50c1tkaXJlY3Rpb25dID8/IChwcmltYXJ5VGlja0NvdW50c1tkaXJlY3Rpb25dID0gcHJpbWFyeVRpY2tDb3VudCk7XG4gICAgICBjbGlwU2VyaWVzIHx8IChjbGlwU2VyaWVzID0gYXhpcy5kYXRhRG9tYWluLmNsaXBwZWQgfHwgYXhpcy52aXNpYmxlUmFuZ2VbMF0gPiAwIHx8IGF4aXMudmlzaWJsZVJhbmdlWzFdIDwgMSk7XG4gICAgICBheGlzV2lkdGhzLnNldChheGlzLmlkLCBNYXRoLmNlaWwoYXhpcy50aGlja25lc3MgPz8gKGlzVmVydGljYWwgPyBiYm94Py53aWR0aCA6IGJib3g/LmhlaWdodCkgPz8gMCkpO1xuICAgIH1cbiAgICBjb25zdCBheGlzR3JvdXBzID0gT2JqZWN0LmVudHJpZXMoZ3JvdXBCeSh0aGlzLmF4ZXMsIChheGlzKSA9PiBheGlzLnBvc2l0aW9uID8/IFwibGVmdFwiKSk7XG4gICAgY29uc3QgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIHBpeGVsUmF0aW8gfSA9IHRoaXMuY3R4LnNjZW5lO1xuICAgIGNvbnN0IG5ld0F4aXNBcmVhV2lkdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBheGlzT2Zmc2V0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbcG9zaXRpb24sIGF4ZXNdIG9mIGF4aXNHcm91cHMpIHtcbiAgICAgIGNvbnN0IGlzVmVydGljYWwgPSBwb3NpdGlvbiA9PT0gXCJsZWZ0XCIgfHwgcG9zaXRpb24gPT09IFwicmlnaHRcIjtcbiAgICAgIGxldCBjdXJyZW50T2Zmc2V0ID0gaXNWZXJ0aWNhbCA/IGhlaWdodDIgJSBwaXhlbFJhdGlvIDogd2lkdGgyICUgcGl4ZWxSYXRpbztcbiAgICAgIGxldCB0b3RhbEF4aXNXaWR0aCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGF4aXMgb2YgYXhlcykge1xuICAgICAgICBheGlzT2Zmc2V0cy5zZXQoYXhpcy5pZCwgY3VycmVudE9mZnNldCk7XG4gICAgICAgIGNvbnN0IGF4aXNUaGlja25lc3MgPSBheGlzV2lkdGhzLmdldChheGlzLmlkKSA/PyAwO1xuICAgICAgICB0b3RhbEF4aXNXaWR0aCA9IE1hdGgubWF4KHRvdGFsQXhpc1dpZHRoLCBjdXJyZW50T2Zmc2V0ICsgYXhpc1RoaWNrbmVzcyk7XG4gICAgICAgIGlmIChheGlzLmxheW91dENvbnN0cmFpbnRzLnN0YWNrZWQpIHtcbiAgICAgICAgICBjdXJyZW50T2Zmc2V0ICs9IGF4aXNUaGlja25lc3MgKyBfQ2FydGVzaWFuQ2hhcnQuQXhlc1BhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5ld0F4aXNBcmVhV2lkdGhzLnNldChwb3NpdGlvbiwgTWF0aC5jZWlsKHRvdGFsQXhpc1dpZHRoKSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW3Bvc2l0aW9uLCBheGVzXSBvZiBheGlzR3JvdXBzKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uQXhlcyh7XG4gICAgICAgIGF4ZXMsXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBheGlzV2lkdGhzLFxuICAgICAgICBheGlzT2Zmc2V0cyxcbiAgICAgICAgYXhpc0FyZWFXaWR0aHM6IG5ld0F4aXNBcmVhV2lkdGhzLFxuICAgICAgICBheGlzQm91bmQ6IGF4aXNBcmVhQm91bmQsXG4gICAgICAgIHNlcmllc1JlY3RcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyBjbGlwU2VyaWVzLCBzZXJpZXNSZWN0LCBheGlzQXJlYVdpZHRoczogbmV3QXhpc0FyZWFXaWR0aHMsIG92ZXJmbG93cyB9O1xuICB9XG4gIGJ1aWxkQ3Jvc3NMaW5lUGFkZGluZyhheGlzQXJlYVNpemUpIHtcbiAgICBjb25zdCBjcm9zc0xpbmVQYWRkaW5nID0geyB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDAsIGhQYWRkaW5nOiAwLCB2UGFkZGluZzogMCB9O1xuICAgIHRoaXMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiB7XG4gICAgICBheGlzLmNyb3NzTGluZXM/LmZvckVhY2goKGNyb3NzTGluZSkgPT4ge1xuICAgICAgICBjcm9zc0xpbmUuY2FsY3VsYXRlUGFkZGluZz8uKGNyb3NzTGluZVBhZGRpbmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBbc2lkZSwgcGFkZGluZyA9IDBdIG9mIE9iamVjdC5lbnRyaWVzKGNyb3NzTGluZVBhZGRpbmcpKSB7XG4gICAgICBjcm9zc0xpbmVQYWRkaW5nW3NpZGVdID0gTWF0aC5tYXgocGFkZGluZyAtIChheGlzQXJlYVNpemUuZ2V0KHNpZGUpID8/IDApLCAwKTtcbiAgICB9XG4gICAgY3Jvc3NMaW5lUGFkZGluZy5oUGFkZGluZyA9IGNyb3NzTGluZVBhZGRpbmcubGVmdCArIGNyb3NzTGluZVBhZGRpbmcucmlnaHQ7XG4gICAgY3Jvc3NMaW5lUGFkZGluZy52UGFkZGluZyA9IGNyb3NzTGluZVBhZGRpbmcudG9wICsgY3Jvc3NMaW5lUGFkZGluZy5ib3R0b207XG4gICAgcmV0dXJuIGNyb3NzTGluZVBhZGRpbmc7XG4gIH1cbiAgY2xhbXBUb091dHNpZGVTZXJpZXNSZWN0KHNlcmllc1JlY3QsIHZhbHVlLCBkaW1lbnNpb24sIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IGJvdW5kID0gZGltZW5zaW9uID09PSBcInhcIiA/IHNlcmllc1JlY3QueCA6IHNlcmllc1JlY3QueTtcbiAgICBjb25zdCBzaXplID0gZGltZW5zaW9uID09PSBcInhcIiA/IHNlcmllc1JlY3Qud2lkdGggOiBzZXJpZXNSZWN0LmhlaWdodDtcbiAgICByZXR1cm4gZGlyZWN0aW9uID09PSAxID8gTWF0aC5taW4odmFsdWUsIGJvdW5kICsgc2l6ZSkgOiBNYXRoLm1heCh2YWx1ZSwgYm91bmQpO1xuICB9XG4gIGdldFN5bmNlZERvbWFpbihheGlzKSB7XG4gICAgY29uc3Qgc3luY01vZHVsZSA9IHRoaXMubW9kdWxlc01hbmFnZXIuZ2V0TW9kdWxlKFwic3luY1wiKTtcbiAgICBpZiAoIXN5bmNNb2R1bGU/LmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgc3luY2VkRG9tYWluID0gc3luY01vZHVsZS5nZXRTeW5jZWREb21haW4oYXhpcyk7XG4gICAgaWYgKHN5bmNlZERvbWFpbiAmJiBheGlzLmRhdGFEb21haW4uZG9tYWluLmxlbmd0aCkge1xuICAgICAgbGV0IHNob3VsZFVwZGF0ZTtcbiAgICAgIGNvbnN0IHsgZG9tYWluIH0gPSBheGlzLnNjYWxlO1xuICAgICAgaWYgKENvbnRpbnVvdXNTY2FsZS5pcyhheGlzLnNjYWxlKSkge1xuICAgICAgICBjb25zdCBbbWluLCBtYXhdID0gZmluZE1pbk1heChzeW5jZWREb21haW4pO1xuICAgICAgICBzaG91bGRVcGRhdGUgPSBtaW4gIT09IGRvbWFpblswXSB8fCBtYXggIT09IGRvbWFpblsxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNob3VsZFVwZGF0ZSA9ICFhcnJheXNFcXVhbChzeW5jZWREb21haW4sIGRvbWFpbik7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlICYmICF0aGlzLnNraXBTeW5jKSB7XG4gICAgICAgIHN5bmNNb2R1bGUudXBkYXRlU2libGluZ3MoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN5bmNlZERvbWFpbjtcbiAgfVxuICBzaXplQXhpcyhheGlzLCBzZXJpZXNSZWN0LCBwb3NpdGlvbikge1xuICAgIGNvbnN0IGlzQ2F0ZWdvcnkgPSBheGlzIGluc3RhbmNlb2YgQ2F0ZWdvcnlBeGlzO1xuICAgIGNvbnN0IGlzTGVmdFJpZ2h0ID0gcG9zaXRpb24gPT09IFwibGVmdFwiIHx8IHBvc2l0aW9uID09PSBcInJpZ2h0XCI7XG4gICAgY29uc3QgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IHNlcmllc1JlY3Q7XG4gICAgY29uc3QgbWF4RW5kID0gaXNMZWZ0UmlnaHQgPyBoZWlnaHQyIDogd2lkdGgyO1xuICAgIGxldCBzdGFydDIgPSAwO1xuICAgIGxldCBlbmQyID0gbWF4RW5kO1xuICAgIGxldCB7IG1pbiwgbWF4IH0gPSB0aGlzLmN0eC56b29tTWFuYWdlci5nZXRBeGlzWm9vbShheGlzLmlkKTtcbiAgICBjb25zdCB7IHdpZHRoOiBheGlzV2lkdGgsIHVuaXQsIGFsaWduOiBhbGlnbjIgfSA9IGF4aXMubGF5b3V0Q29uc3RyYWludHM7XG4gICAgaWYgKHVuaXQgPT09IFwicHhcIikge1xuICAgICAgZW5kMiA9IHN0YXJ0MiArIGF4aXNXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kMiA9IGVuZDIgKiBheGlzV2lkdGggLyAxMDA7XG4gICAgfVxuICAgIGlmIChhbGlnbjIgPT09IFwiZW5kXCIpIHtcbiAgICAgIHN0YXJ0MiA9IG1heEVuZCAtIChlbmQyIC0gc3RhcnQyKTtcbiAgICAgIGVuZDIgPSBtYXhFbmQ7XG4gICAgfVxuICAgIGlmIChpc0xlZnRSaWdodCkge1xuICAgICAgaWYgKGlzQ2F0ZWdvcnkpIHtcbiAgICAgICAgW21pbiwgbWF4XSA9IFsxIC0gbWF4LCAxIC0gbWluXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFtzdGFydDIsIGVuZDJdID0gW2VuZDIsIHN0YXJ0Ml07XG4gICAgICB9XG4gICAgfVxuICAgIGF4aXMucmFuZ2UgPSBbc3RhcnQyLCBlbmQyXTtcbiAgICBheGlzLnZpc2libGVSYW5nZSA9IFttaW4sIG1heF07XG4gICAgYXhpcy5ncmlkTGVuZ3RoID0gaXNMZWZ0UmlnaHQgPyB3aWR0aDIgOiBoZWlnaHQyO1xuICB9XG4gIHBvc2l0aW9uQXhlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBheGVzLCBheGlzQm91bmQsIGF4aXNXaWR0aHMsIGF4aXNPZmZzZXRzLCBheGlzQXJlYVdpZHRocywgc2VyaWVzUmVjdCwgcG9zaXRpb24gfSA9IG9wdHM7XG4gICAgY29uc3QgYXhpc0FyZWFXaWR0aCA9IGF4aXNBcmVhV2lkdGhzLmdldChwb3NpdGlvbikgPz8gMDtcbiAgICBsZXQgbWFpbkRpbWVuc2lvbiA9IFwieFwiO1xuICAgIGxldCBtaW5vckRpbWVuc2lvbiA9IFwieVwiO1xuICAgIGxldCBkaXJlY3Rpb24gPSAxO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gXCJ0b3BcIiB8fCBwb3NpdGlvbiA9PT0gXCJib3R0b21cIikge1xuICAgICAgbWFpbkRpbWVuc2lvbiA9IFwieVwiO1xuICAgICAgbWlub3JEaW1lbnNpb24gPSBcInhcIjtcbiAgICB9XG4gICAgbGV0IGF4aXNCb3VuZE1haW5PZmZzZXQgPSBheGlzQm91bmRbbWFpbkRpbWVuc2lvbl07XG4gICAgaWYgKHBvc2l0aW9uID09PSBcInJpZ2h0XCIgfHwgcG9zaXRpb24gPT09IFwiYm90dG9tXCIpIHtcbiAgICAgIGRpcmVjdGlvbiA9IC0xO1xuICAgICAgYXhpc0JvdW5kTWFpbk9mZnNldCArPSBtYWluRGltZW5zaW9uID09PSBcInhcIiA/IGF4aXNCb3VuZC53aWR0aCA6IGF4aXNCb3VuZC5oZWlnaHQ7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXhpcyBvZiBheGVzKSB7XG4gICAgICBjb25zdCBtaW5vck9mZnNldCA9IGF4aXNBcmVhV2lkdGhzLmdldChtaW5vckRpbWVuc2lvbiA9PT0gXCJ4XCIgPyBcImxlZnRcIiA6IFwidG9wXCIpID8/IDA7XG4gICAgICBjb25zdCBheGlzVGhpY2tuZXNzID0gYXhpc1dpZHRocy5nZXQoYXhpcy5pZCkgPz8gMDtcbiAgICAgIGNvbnN0IGF4aXNPZmZzZXQgPSBheGlzT2Zmc2V0cy5nZXQoYXhpcy5pZCkgPz8gMDtcbiAgICAgIGF4aXMuZ3JpZFBhZGRpbmcgPSBheGlzQXJlYVdpZHRoIC0gYXhpc09mZnNldCAtIGF4aXNUaGlja25lc3M7XG4gICAgICBheGlzLnRyYW5zbGF0aW9uW21pbm9yRGltZW5zaW9uXSA9IGF4aXNCb3VuZFttaW5vckRpbWVuc2lvbl0gKyBtaW5vck9mZnNldDtcbiAgICAgIGF4aXMudHJhbnNsYXRpb25bbWFpbkRpbWVuc2lvbl0gPSB0aGlzLmNsYW1wVG9PdXRzaWRlU2VyaWVzUmVjdChcbiAgICAgICAgc2VyaWVzUmVjdCxcbiAgICAgICAgYXhpc0JvdW5kTWFpbk9mZnNldCArIGRpcmVjdGlvbiAqIChheGlzT2Zmc2V0ICsgYXhpc1RoaWNrbmVzcyksXG4gICAgICAgIG1haW5EaW1lbnNpb24sXG4gICAgICAgIGRpcmVjdGlvblxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgc2hvdWxkRmxpcFhZKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmllcy5ldmVyeSgoc2VyaWVzKSA9PiBzZXJpZXMgaW5zdGFuY2VvZiBDYXJ0ZXNpYW5TZXJpZXMgJiYgc2VyaWVzLnNob3VsZEZsaXBYWSgpKTtcbiAgfVxuICBnZXREZWZhdWx0U3RhdGUoKSB7XG4gICAgY29uc3QgYXhpc0FyZWFXaWR0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGlmICh0aGlzLmxhc3RBcmVhV2lkdGhzKSB7XG4gICAgICBmb3IgKGNvbnN0IHsgcG9zaXRpb24gPSBcImxlZnRcIiB9IG9mIHRoaXMuYXhlcykge1xuICAgICAgICBjb25zdCBhcmVhV2lkdGggPSB0aGlzLmxhc3RBcmVhV2lkdGhzLmdldChwb3NpdGlvbik7XG4gICAgICAgIGlmIChhcmVhV2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgIGF4aXNBcmVhV2lkdGhzLnNldChwb3NpdGlvbiwgYXJlYVdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBheGlzQXJlYVdpZHRocywgY2xpcFNlcmllczogZmFsc2UsIG92ZXJmbG93czogZmFsc2UgfTtcbiAgfVxuICBpc0xheW91dFN0YWJsZShuZXdTdGF0ZSwgcHJldlN0YXRlKSB7XG4gICAgaWYgKHByZXZTdGF0ZS5vdmVyZmxvd3MgIT09IG5ld1N0YXRlLm92ZXJmbG93cyB8fCBwcmV2U3RhdGUuY2xpcFNlcmllcyAhPT0gbmV3U3RhdGUuY2xpcFNlcmllcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBuZXdTdGF0ZS5heGlzQXJlYVdpZHRocy5rZXlzKCkpIHtcbiAgICAgIGlmICghcHJldlN0YXRlLmF4aXNBcmVhV2lkdGhzLmhhcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbcCwgd10gb2YgcHJldlN0YXRlLmF4aXNBcmVhV2lkdGhzLmVudHJpZXMoKSkge1xuICAgICAgY29uc3Qgb3RoZXJXID0gbmV3U3RhdGUuYXhpc0FyZWFXaWR0aHMuZ2V0KHApO1xuICAgICAgaWYgKCh3ICE9IG51bGwgfHwgb3RoZXJXICE9IG51bGwpICYmIHcgIT09IG90aGVyVykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNsaXBBeGlzKGF4aXMsIHNlcmllc1JlY3QsIGxheW91dEJCb3gpIHtcbiAgICBjb25zdCBncmlkTGluZVBhZGRpbmcgPSBNYXRoLmNlaWwoYXhpcy5ncmlkTGluZT8ud2lkdGggPz8gMCk7XG4gICAgY29uc3QgYXhpc0xpbmVQYWRkaW5nID0gTWF0aC5jZWlsKGF4aXMubGluZT8ud2lkdGggPz8gMCk7XG4gICAgbGV0IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSBzZXJpZXNSZWN0O1xuICAgIHdpZHRoMiArPSBheGlzLmRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLyA/IGdyaWRMaW5lUGFkZGluZyA6IGF4aXNMaW5lUGFkZGluZztcbiAgICBoZWlnaHQyICs9IGF4aXMuZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovID8gZ3JpZExpbmVQYWRkaW5nIDogYXhpc0xpbmVQYWRkaW5nO1xuICAgIGF4aXMuY2xpcEdyaWQoc2VyaWVzUmVjdC54LCBzZXJpZXNSZWN0LnksIHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgc3dpdGNoIChheGlzLnBvc2l0aW9uKSB7XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgIGF4aXMuY2xpcFRpY2tMaW5lcyhcbiAgICAgICAgICBsYXlvdXRCQm94LngsXG4gICAgICAgICAgc2VyaWVzUmVjdC55IC0gZ3JpZExpbmVQYWRkaW5nLFxuICAgICAgICAgIGxheW91dEJCb3gud2lkdGggKyBncmlkTGluZVBhZGRpbmcsXG4gICAgICAgICAgc2VyaWVzUmVjdC5oZWlnaHQgKyBncmlkTGluZVBhZGRpbmcgKiAyXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICBheGlzLmNsaXBUaWNrTGluZXMoXG4gICAgICAgICAgc2VyaWVzUmVjdC54IC0gZ3JpZExpbmVQYWRkaW5nLFxuICAgICAgICAgIGxheW91dEJCb3gueSxcbiAgICAgICAgICBzZXJpZXNSZWN0LndpZHRoICsgZ3JpZExpbmVQYWRkaW5nICogMixcbiAgICAgICAgICBsYXlvdXRCQm94LmhlaWdodCArIGdyaWRMaW5lUGFkZGluZ1xuICAgICAgICApO1xuICAgICAgICBjb25zdCB7IGxhYmVsLCBsYWJlbE5vZGVzLCBzY2FsZTogc2NhbGUyIH0gPSBheGlzO1xuICAgICAgICBpZiAoQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikgJiYgbGFiZWwuZW5hYmxlZCAmJiBsYWJlbC5hdm9pZENvbGxpc2lvbnMgJiYgbGFiZWxOb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgY29uc3Qgc29ydGVkTGFiZWxzID0gbGFiZWxOb2Rlcy50b1NvcnRlZCgoYSwgYikgPT4gYS50cmFuc2xhdGlvblkgLSBiLnRyYW5zbGF0aW9uWSk7XG4gICAgICAgICAgY29uc3QgbGFzdExhYmVsID0gc29ydGVkTGFiZWxzLmF0KC0xKTtcbiAgICAgICAgICBjb25zdCBsYXN0TGFiZWxCQm94ID0gbGFzdExhYmVsLmdldEJCb3goKTtcbiAgICAgICAgICBjb25zdCBsYXN0TGFiZWxJbkJvdW5kcyA9IHNlcmllc1JlY3QueCArIGxhc3RMYWJlbEJCb3gueSArIGxhc3RMYWJlbEJCb3guaGVpZ2h0IDw9IGxheW91dEJCb3gueCArIGxheW91dEJCb3gud2lkdGggKyB0aGlzLnBhZGRpbmcucmlnaHQ7XG4gICAgICAgICAgbGFzdExhYmVsLnZpc2libGUgPSBsYXN0TGFiZWxJbkJvdW5kcztcbiAgICAgICAgICBpZiAobGFzdExhYmVsSW5Cb3VuZHMgfHwgYXhpcy52aXNpYmxlUmFuZ2VbMF0gPiAwIHx8IGF4aXMudmlzaWJsZVJhbmdlWzFdIDwgMSkge1xuICAgICAgICAgICAgc29ydGVkTGFiZWxzWzBdLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdExhYmVsQkJveCA9IHNvcnRlZExhYmVsc1swXS5nZXRCQm94KCk7XG4gICAgICAgICAgICBzb3J0ZWRMYWJlbHNbMF0udmlzaWJsZSA9IGZpcnN0TGFiZWxCQm94LnkgPj0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuX0NhcnRlc2lhbkNoYXJ0LmNsYXNzTmFtZSA9IFwiQ2FydGVzaWFuQ2hhcnRcIjtcbl9DYXJ0ZXNpYW5DaGFydC50eXBlID0gXCJjYXJ0ZXNpYW5cIjtcbl9DYXJ0ZXNpYW5DaGFydC5BeGVzUGFkZGluZyA9IDE1O1xudmFyIENhcnRlc2lhbkNoYXJ0ID0gX0NhcnRlc2lhbkNoYXJ0O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jYXJ0ZXNpYW5DaGFydE1vZHVsZS50c1xudmFyIENhcnRlc2lhbkNoYXJ0TW9kdWxlID0ge1xuICB0eXBlOiBcImNoYXJ0XCIsXG4gIG5hbWU6IFwiY2FydGVzaWFuXCIsXG4gIGRldGVjdDogaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyxcbiAgY3JlYXRlKG9wdGlvbnMsIHJlc291cmNlcykge1xuICAgIHJldHVybiBuZXcgQ2FydGVzaWFuQ2hhcnQob3B0aW9ucywgcmVzb3VyY2VzKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY2hhcnRQcm94eS50c1xudmFyIGRlYnVnMiA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcIm9wdHNcIik7XG52YXIgX0FnQ2hhcnRJbnN0YW5jZVByb3h5ID0gY2xhc3MgX0FnQ2hhcnRJbnN0YW5jZVByb3h5IHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGZhY3RvcnlBcGksIGxpY2Vuc2VNYW5hZ2VyKSB7XG4gICAgdGhpcy5mYWN0b3J5QXBpID0gZmFjdG9yeUFwaTtcbiAgICB0aGlzLmxpY2Vuc2VNYW5hZ2VyID0gbGljZW5zZU1hbmFnZXI7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICB9XG4gIGFzeW5jIHVwZGF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRlYnVnMi5ncm91cChcIkFnQ2hhcnRJbnN0YW5jZS51cGRhdGUoKVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmZhY3RvcnlBcGkudXBkYXRlKG9wdGlvbnMsIHRoaXMpO1xuICAgICAgYXdhaXQgdGhpcy5jaGFydC53YWl0Rm9yVXBkYXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlRGVsdGEoZGVsdGFPcHRpb25zKSB7XG4gICAgcmV0dXJuIGRlYnVnMi5ncm91cChcIkFnQ2hhcnRJbnN0YW5jZS51cGRhdGVEZWx0YSgpXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuZmFjdG9yeUFwaS51cGRhdGVVc2VyRGVsdGEodGhpcywgZGVsdGFPcHRpb25zKTtcbiAgICAgIGF3YWl0IHRoaXMuY2hhcnQud2FpdEZvclVwZGF0ZSgpO1xuICAgIH0pO1xuICB9XG4gIGdldE9wdGlvbnMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGRlZXBDbG9uZSh0aGlzLmNoYXJ0LmdldE9wdGlvbnMoKSk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob3B0aW9ucykpIHtcbiAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIl9cIikpIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgd2FpdEZvclVwZGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC53YWl0Rm9yVXBkYXRlKCk7XG4gIH1cbiAgYXN5bmMgZG93bmxvYWQob3B0cykge1xuICAgIGNvbnN0IGNsb25lMiA9IGF3YWl0IHRoaXMucHJlcGFyZVJlc2l6ZWRDaGFydCh0aGlzLCBvcHRzKTtcbiAgICB0cnkge1xuICAgICAgY2xvbmUyLmNoYXJ0LmRvd25sb2FkKG9wdHM/LmZpbGVOYW1lLCBvcHRzPy5maWxlRm9ybWF0KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY2xvbmUyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX190b1NWRyhvcHRzKSB7XG4gICAgY29uc3QgY2xvbmUyID0gYXdhaXQgdGhpcy5wcmVwYXJlUmVzaXplZENoYXJ0KHRoaXMsIHsgd2lkdGg6IDYwMCwgaGVpZ2h0OiAzMDAsIC4uLm9wdHMgfSk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjbG9uZTIuY2hhcnQudG9TVkcoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY2xvbmUyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0SW1hZ2VEYXRhVVJMKG9wdHMpIHtcbiAgICBjb25zdCBjbG9uZTIgPSBhd2FpdCB0aGlzLnByZXBhcmVSZXNpemVkQ2hhcnQodGhpcywgb3B0cyk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjbG9uZTIuY2hhcnQuZ2V0Q2FudmFzRGF0YVVSTChvcHRzPy5maWxlRm9ybWF0KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY2xvbmUyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmFjdG9yeUFwaS5jYXJldGFrZXIuc2F2ZSguLi50aGlzLmdldEVuYWJsZWRPcmlnaW5hdG9ycygpKTtcbiAgfVxuICBhc3luYyBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIGNvbnN0IG9yaWdpbmF0b3JzID0gdGhpcy5nZXRFbmFibGVkT3JpZ2luYXRvcnMoKTtcbiAgICBpZiAoIW9yaWdpbmF0b3JzLmluY2x1ZGVzKHRoaXMuY2hhcnQuY3R4LmxlZ2VuZE1hbmFnZXIpKSB7XG4gICAgICBhd2FpdCB0aGlzLnNldFN0YXRlT3JpZ2luYXRvcnMoc3RhdGUsIG9yaWdpbmF0b3JzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5zZXRTdGF0ZU9yaWdpbmF0b3JzKFxuICAgICAgc3RhdGUsXG4gICAgICBvcmlnaW5hdG9ycy5maWx0ZXIoKG9yaWdpbmF0b3IpID0+IG9yaWdpbmF0b3IgIT09IHRoaXMuY2hhcnQuY3R4Lnpvb21NYW5hZ2VyKVxuICAgICk7XG4gICAgYXdhaXQgdGhpcy5zZXRTdGF0ZU9yaWdpbmF0b3JzKHN0YXRlLCBbdGhpcy5jaGFydC5jdHguem9vbU1hbmFnZXJdKTtcbiAgfVxuICByZXNldEFuaW1hdGlvbnMoKSB7XG4gICAgdGhpcy5jaGFydC5yZXNldEFuaW1hdGlvbnMoKTtcbiAgfVxuICBza2lwQW5pbWF0aW9ucygpIHtcbiAgICB0aGlzLmNoYXJ0LnNraXBBbmltYXRpb25zKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5yZWxlYXNlQ2hhcnQpIHtcbiAgICAgIHRoaXMucmVsZWFzZUNoYXJ0KCk7XG4gICAgICB0aGlzLnJlbGVhc2VDaGFydCA9IHZvaWQgMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY2hhcnQpIHtcbiAgICAgIHRoaXMuY2hhcnQucHVibGljQXBpID0gdm9pZCAwO1xuICAgICAgdGhpcy5jaGFydC5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuY2hhcnQgPSBudWxsO1xuICB9XG4gIGFzeW5jIHByZXBhcmVSZXNpemVkQ2hhcnQocHJveHksIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHsgY2hhcnQgfSA9IHByb3h5O1xuICAgIGNvbnN0IHdpZHRoMiA9IG9wdHMud2lkdGggPz8gY2hhcnQud2lkdGggPz8gY2hhcnQuY3R4LnNjZW5lLmNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQyID0gb3B0cy5oZWlnaHQgPz8gY2hhcnQuaGVpZ2h0ID8/IGNoYXJ0LmN0eC5zY2VuZS5jYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IHN0YXRlID0gcHJveHkuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBpc0VudGVycHJpc2UgPSBtb2R1bGVSZWdpc3RyeS5oYXNFbnRlcnByaXNlTW9kdWxlcygpO1xuICAgIGNvbnN0IHByb2Nlc3NlZE92ZXJyaWRlcyA9IHtcbiAgICAgIC4uLmNoYXJ0LmNoYXJ0T3B0aW9ucy5wcm9jZXNzZWRPdmVycmlkZXMsXG4gICAgICBjb250YWluZXI6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICB3aWR0aDogd2lkdGgyLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQyXG4gICAgfTtcbiAgICBpZiAob3B0cy53aWR0aCAhPSBudWxsICYmIG9wdHMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgIHByb2Nlc3NlZE92ZXJyaWRlcy5vdmVycmlkZURldmljZVBpeGVsUmF0aW8gPSAxO1xuICAgIH1cbiAgICBjb25zdCB1c2VyT3B0aW9ucyA9IGNoYXJ0LmdldE9wdGlvbnMoKTtcbiAgICBpZiAoaXNFbnRlcnByaXNlKSB7XG4gICAgICBwcm9jZXNzZWRPdmVycmlkZXMuYW5pbWF0aW9uID0geyBlbmFibGVkOiBmYWxzZSB9O1xuICAgICAgaWYgKHRoaXMubGljZW5zZU1hbmFnZXI/LmlzRGlzcGxheVdhdGVybWFyaygpKSB7XG4gICAgICAgIHByb2Nlc3NlZE92ZXJyaWRlcy5mb3JlZ3JvdW5kID0ge1xuICAgICAgICAgIHRleHQ6IHRoaXMubGljZW5zZU1hbmFnZXIuZ2V0V2F0ZXJtYXJrTWVzc2FnZSgpLFxuICAgICAgICAgIGltYWdlOiB7XG4gICAgICAgICAgICB1cmw6IGBkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNalU0SWlCb1pXbG5hSFE5SWpRd0lpQjJhV1YzUW05NFBTSXdJREFnTWpVNElEUXdJaUJtYVd4c1BTSnViMjVsSWlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpUGdvOGNHRjBhQ0JrUFNKTk1qVXVOemM1SURJNExqWTFOMGd4TXk0ek5UbE1NVEV1TVRjeklETTBMakF4TWtnMUxqWTNNamszVERFM0xqRTRNaUEzTGpBMU9UazVTREl4TGprMU0wd3pNeTQwTmpJZ016UXVNREV5U0RJM0xqazJNa3d5TlM0M056WWdNamd1TmpVM1NESTFMamMzT1ZwTk1qUXVNRFk0SURJMExqTTVOMHd4T1M0MU9EZ2dNVE11TkRNMFRERTFMakV3TnlBeU5DNHpPVGRJTWpRdU1EWTRXazAyTWk0d09USWdNVGd1T0RJelNEUTVMamd4TjFZeU15NHdPRFpJTlRZdU56YzFRelUyTGpVMU5TQXlOUzR5TWpJZ05UVXVOelUxSURJMkxqa3lOeUExTkM0ek56SWdNamd1TWpBeVF6VXlMams0T1NBeU9TNDBOellnTlRFdU1UWTJJRE13TGpFeE5TQTBPQzQ1TURrZ016QXVNVEUxUXpRM0xqWXlNaUF6TUM0eE1UVWdORFl1TkRVZ01qa3VPRGcxSURRMUxqTTVNeUF5T1M0ME1qTkRORFF1TXpVNE15QXlPQzQ1TnpneElEUXpMalF6TWpZZ01qZ3VNekV6T0NBME1pNDJPQ0F5Tnk0ME56WkROREV1T1RJM0lESTJMall6T1NBME1TNHpORFFnTWpVdU5qTXhJRFF3TGprek1TQXlOQzQwTlRORE5EQXVOVEU1SURJekxqSTNOU0EwTUM0ek1URWdNakV1T1RjZ05EQXVNekV4SURJd0xqVXpOME0wTUM0ek1URWdNVGt1TVRBMUlEUXdMalV4TmlBeE55NDRJRFF3TGprek1TQXhOaTQyTWpGRE5ERXVNelEwSURFMUxqUTBNeUEwTVM0NU1qY2dNVFF1TkRNMklEUXlMalk0SURFekxqVTVPRU0wTXk0ME16YzJJREV5TGpjMU56Y2dORFF1TXpZNU5pQXhNaTR3T1RNeUlEUTFMalF4TVNBeE1TNDJOVEZETkRZdU5EYzRJREV4TGpFNE9TQTBOeTQyTlRZZ01UQXVPVFlnTkRndU9UUTJJREV3TGprMlF6VXhMall4TWlBeE1DNDVOaUExTXk0Mk16Y2dNVEV1TmpBeUlEVTFMakF5SURFeUxqZzROVXcxT0M0eklEa3VOakEwT1RsRE5UVXVPREUzSURjdU5qWTVPVGtnTlRJdU5qYzJJRFl1TmprNU9Ua2dORGd1T0RjeUlEWXVOams1T1RsRE5EWXVOellnTmk0Mk9UazVPU0EwTkM0NE5UTWdOeTR3TXpRNU9TQTBNeTR4TlRRZ055NDNNREE1T1VNME1TNDBOVFVnT0M0ek5qYzVPU0F6T1M0NU9UZ2dPUzR6TURNNU9TQXpPQzQzT0RNZ01UQXVOVEEwUXpNM0xqVTJOeUF4TVM0M01EY2dNell1TmpNMElERXpMakUxT0NBek5TNDVOemNnTVRRdU9EVTNRek0xTGpNeE9TQXhOaTQxTlRZZ016UXVPVGswSURFNExqUTFNU0F6TkM0NU9UUWdNakF1TlRSRE16UXVPVGswSURJeUxqWXpJRE0xTGpNeU9TQXlOQzQwT1RRZ016VXVPVGsxSURJMkxqSXdOVU16Tmk0Mk5qSWdNamN1T1RFMklETTNMall3TlNBeU9TNHpOelFnTXpndU9ERTNJRE13TGpVM04wTTBNQzR3TXpJZ016RXVOemdnTkRFdU5EZzJJRE15TGpjeE15QTBNeTR4T0RnZ016TXVNemd6UXpRMExqZzRPQ0F6TkM0d05Ea2dORFl1TnpneUlETTBMak00TkNBME9DNDROeklnTXpRdU16ZzBRelV3TGprMk1TQXpOQzR6T0RRZ05USXVOelVnTXpRdU1EUTVJRFUwTGpNNUlETXpMak00TTBNMU5pNHdNekVnTXpJdU56RTJJRFUzTGpReU5pQXpNUzQzT0NBMU9DNDFOemtnTXpBdU5UYzNRelU1TGpjek15QXlPUzR6TnpRZ05qQXVOakU1SURJM0xqa3hOaUEyTVM0eU16a2dNall1TWpBMVF6WXhMamcySURJMExqUTVOQ0EyTWk0eE55QXlNaTQyTURVZ05qSXVNVGNnTWpBdU5UUkROakl1TVRZNU5pQXhPUzQ1TmpnNElEWXlMakUwTkRVZ01Ua3VNems0SURZeUxqQTVOU0F4T0M0NE1qbE1Oakl1TURreUlERTRMamd5TTFwTk1UVXhMamd4SURFMkxqazRNVU14TlRNdU5ERWdNVFF1TmpBNUlERTFOeTQwTVRrZ01UUXVNelU0SURFMU9TNHdNaklnTVRRdU16VTRWakU0TGpreFF6RTFOaTQ1TlRjZ01UZ3VPVEVnTVRVMExqazROU0F4T0M0NU9UWWdNVFV6TGpjMU55QXhPUzQ0T1RKRE1UVXlMalV5T1NBeU1DNDNPVElnTVRVeExqa3hPU0F5TVM0NU9ESWdNVFV4TGpreE9TQXlNeTQwTmpSV016TXVPVGxJTVRRMkxqazJORll4TkM0ek5UaElNVFV4TGpjek5rd3hOVEV1T0RFZ01UWXVPVGd4V2sweE5ETXVNREV4SURFMExqTTJNVll6TkM0d016RklNVE00TGpJMFRERXpPQzR4TXpFZ016RXVNRFExUXpFek55NDBOallnTXpJdU1EYzJJREV6Tmk0MU5URWdNekl1T1RJeE9TQXhNelV1TkRjeElETXpMalV3TkVNeE16UXVNemMySURNMExqQTVPU0F4TXpNdU1EWTRJRE0wTGpNNU5pQXhNekV1TlRNMklETTBMak01TmtNeE16QXVNaUF6TkM0ek9UWWdNVEk0TGprMk15QXpOQzR4TlRJZ01USTNMamd5TWlBek15NDJOamhETVRJMkxqY2dNek11TVRrMk5DQXhNalV1TmpnNUlETXlMalE1TlNBeE1qUXVPRFUxSURNeExqWXdPVU14TWpRdU1ERTRJRE13TGpjeU1pQXhNak11TXpVMElESTVMalkyTWlBeE1qSXVPRGN4SURJNExqUXlNa014TWpJdU16ZzBJREkzTGpFNE5TQXhNakl1TVRReUlESTFMamd4TVNBeE1qSXVNVFF5SURJMExqTXdORU14TWpJdU1UUXlJREl5TGpjNU9DQXhNakl1TXpnMElESXhMak0zT0NBeE1qSXVPRGN4SURJd0xqRXhOa014TWpNdU16VTNJREU0TGpnMU5DQXhNalF1TURFNElERTNMamMzTWlBeE1qUXVPRFUxSURFMkxqZzNNME14TWpVdU5qZzRJREUxTGprM05qUWdNVEkyTGpZNU9DQXhOUzR5TmpNMklERXlOeTQ0TWpJZ01UUXVOemhETVRJNExqazJNeUF4TkM0eU9ERWdNVE13TGpJd015QXhOQzR3TXpNZ01UTXhMalV6TmlBeE5DNHdNek5ETVRNekxqQTBNeUF4TkM0d016TWdNVE0wTGpNeklERTBMak14T0NBeE16VXVNemszSURFMExqZzRPRU14TXpZdU5EWXlJREUxTGpRMU9Ea2dNVE0zTGpNM05TQXhOaTR5TnpnZ01UTTRMakExTnlBeE55NHlOelpXTVRRdU16WXhTREUwTXk0d01URmFUVEV6TWk0Mk16RWdNekF1TVRNelF6RXpOQzR5TlRZZ016QXVNVE16SURFek5TNDFOamNnTWprdU5UazBJREV6Tmk0MU5qVWdNamd1TlRFeVF6RXpOeTQxTmpFZ01qY3VORE1nTVRNNExqQTJJREkxTGprNU1TQXhNemd1TURZZ01qUXVNVGsyUXpFek9DNHdOaUF5TWk0ME1ERWdNVE0zTGpVMk1TQXlNQzQ1T1NBeE16WXVOVFkxSURFNUxqZzVPVU14TXpVdU5UY2dNVGd1T0RBM0lERXpOQzR5TlRrZ01UZ3VNalU0SURFek1pNDJNekVnTVRndU1qVTRRekV6TVM0d01ETWdNVGd1TWpVNElERXlPUzQzTWprZ01UZ3VPREEwSURFeU9DNDNNelFnTVRrdU9EazVRekV5Tnk0M016Z2dNakF1T1RreklERXlOeTR5TXprZ01qSXVORE00SURFeU55NHlNemtnTWpRdU1qTXpRekV5Tnk0eU16a2dNall1TURJNElERXlOeTQzTXpVZ01qY3VORE16SURFeU9DNDNNelFnTWpndU5URTFRekV5T1M0M01qa2dNamt1TlRrMElERXpNUzR3TWpnZ016QXVNVE0ySURFek1pNDJNekVnTXpBdU1UTTJWak13TGpFek0xcE5PVE11TmprNElESTNMamczTmtNNU15NDFOemsxSURJNExqQXdNalVnT1RNdU5EVTJOQ0F5T0M0eE1qUTJJRGt6TGpNeU9TQXlPQzR5TkRKRE9URXVPVFEzSURJNUxqVXhOaUE1TUM0eE1qTWdNekF1TVRVMUlEZzNMamcyTmlBek1DNHhOVFZET0RZdU5UZ2dNekF1TVRVMUlEZzFMalF3T0NBeU9TNDVNallnT0RRdU16VWdNamt1TkRZMFF6Z3pMak14TlRVZ01qa3VNREU0T1NBNE1pNHpPRGs0SURJNExqTTFORFlnT0RFdU5qTTNJREkzTGpVeE4wTTRNQzQ0T0RRZ01qWXVOamM1SURnd0xqTXdNU0F5TlM0Mk56SWdOemt1T0RnNUlESTBMalE1TkVNM09TNDBOellnTWpNdU16RTFJRGM1TGpJMk9TQXlNaTR3TVNBM09TNHlOamtnTWpBdU5UYzRRemM1TGpJMk9TQXhPUzR4TkRVZ056a3VORGN6SURFM0xqZzBJRGM1TGpnNE9TQXhOaTQyTmpKRE9EQXVNekF4SURFMUxqUTROQ0E0TUM0NE9EUWdNVFF1TkRjMklEZ3hMall6TnlBeE15NDJNemxET0RJdU16azBPU0F4TWk0M09UZzNJRGd6TGpNeU56TWdNVEl1TVRNME1pQTROQzR6TmprZ01URXVOamt5UXpnMUxqUXpOaUF4TVM0eU15QTROaTQyTVRRZ01URWdPRGN1T1RBeklERXhRemt3TGpVM0lERXhJRGt5TGpVNU5TQXhNUzQyTkRJZ09UTXVPVGMzSURFeUxqa3lOa3c1Tnk0eU5UZ2dPUzQyTkRRNU9VTTVOQzQzTnpRZ055NDNNVEE1T1NBNU1TNDJNek1nTmk0M016azVPU0E0Tnk0NE1qa2dOaTQzTXprNU9VTTROUzQzTVRnZ05pNDNNems1T1NBNE15NDRNVEVnTnk0d056UTVPU0E0TWk0eE1USWdOeTQzTkRFNU9VTTRNQzQwTVRNZ09DNDBNRGM1T1NBM09DNDVOVFlnT1M0ek5EUTVPU0EzTnk0M05DQXhNQzQxTkRWRE56WXVOVEkxSURFeExqYzBOeUEzTlM0MU9USWdNVE11TVRrNUlEYzBMamt6TkNBeE5DNDRPVGhETnpRdU1qYzNJREUyTGpVNU55QTNNeTQ1TlRFZ01UZ3VORGt4SURjekxqazFNU0F5TUM0MU9ERkROek11T1RVeElESXlMalkzSURjMExqSTROaUF5TkM0MU16UWdOelF1T1RVeklESTJMakkwTlVNM05TNDJNVGtnTWpjdU9UVTNJRGMyTGpVMk1pQXlPUzQwTVRRZ056Y3VOemMwSURNd0xqWXhOME0zT0M0NU9TQXpNUzQ0TWlBNE1DNDBORFFnTXpJdU56VXpJRGd5TGpFME5pQXpNeTQwTWpORE9ETXVPRFExSURNMExqQTVJRGcxTGpjek9TQXpOQzQwTWpRZ09EY3VPREk1SURNMExqUXlORU00T1M0NU1Ua2dNelF1TkRJMElEa3hMamN3T0NBek5DNHdPU0E1TXk0ek5EZ2dNek11TkRJelF6azBMamN4T0NBek1pNDROalVnT1RVdU9URTRJRE15TGpFeU1TQTVOaTQ1TkRnZ016RXVNVGt4UXprM0xqRTBPU0F6TVM0d01EZ2dPVGN1TXpRNElETXdMamd4TlNBNU55NDFNemNnTXpBdU5qSk1PVE11TnpBeElESTNMamc0TlV3NU15NDJPVGdnTWpjdU9EYzJXazB4TVRBdU9EQXlJREUwTGpBeE5VTXhNRGt1TVRrNUlERTBMakF4TlNBeE1EWXVPRE0ySURFMExqUTNNU0F4TURVdU5qRXhJREUyTGpFMU9Fd3hNRFV1TlRNM0lEWXVNREUxT1RsSU1UQXdMamMyTlZZek15NDVNemxJTVRBMUxqY3lWakl5TGpZME1VTXhNRFV1TnpjeElESXhMalEyTURjZ01UQTJMakk0T0NBeU1DNHpORGc0SURFd055NHhOVGNnTVRrdU5UUTRPVU14TURndU1ESTNJREU0TGpjME9URWdNVEE1TGpFM09DQXhPQzR6TWpZMklERXhNQzR6TlRnZ01UZ3VNemMwUXpFeE15NHpPVGNnTVRndU16YzBJREV4TkM0eU5qZ2dNakV1TVRVNUlERXhOQzR5TmpnZ01qSXVOalF4VmpNekxqa3pPVWd4TVRrdU1qSXpWakl4TGpBMU9VTXhNVGt1TWpJeklESXhMakExT1NBeE1Ua3VNVFF5SURFMExqQXhOU0F4TVRBdU9EQXlJREUwTGpBeE5WcE5NVGN6TGpjMk15QXhOQzR6TlRoSU1UWTVMams1T1ZZNExqY3hORGs1U0RFMk5TNHdORGhXTVRRdU16VTRTREUyTVM0eU9EUldNVGd1T1RFMlNERTJOUzR3TkRoV016UXVNREF6U0RFMk9TNDVPVGxXTVRndU9URTJTREUzTXk0M05qTldNVFF1TXpVNFdrMHhPVEF1TnpnM0lESTFMakkyTWtNeE9UQXVNVEk1SURJMExqVXdNVFFnTVRnNUxqTXdOeUF5TXk0NE9UazBJREU0T0M0ek9EUWdNak11TlRBeFF6RTROeTQwT0RnZ01qTXVNVEUzSURFNE5pNHpNekVnTWpJdU56TXlJREU0TkM0NU5EZ2dNakl1TXpZMFF6RTROQzR4TmpVZ01qSXVNVFF6T1NBeE9ETXVNemtnTWpFdU9EazNPQ0F4T0RJdU5qSXpJREl4TGpZeU5rTXhPREl1TVRZeklESXhMalEyTWpFZ01UZ3hMamMwTVNBeU1TNHlNRFkySURFNE1TNHpPRE1nTWpBdU9EYzFRekU0TVM0eU16VWdNakF1TnpReU1TQXhPREV1TVRFNElESXdMalUzT0RrZ01UZ3hMakF6T1NBeU1DNHpPVFkwUXpFNE1DNDVOakVnTWpBdU1qRTBJREU0TUM0NU1qSWdNakF1TURFMk5pQXhPREF1T1RJM0lERTVMamd4T0VNeE9EQXVPVEkzSURFNUxqSTNNaUF4T0RFdU1UVTJJREU0TGpnME5DQXhPREV1TmpJMUlERTRMalV4UXpFNE1pNHhNakVnTVRndU1UVTJJREU0TWk0NE5qSWdNVGN1T1RjMklERTRNeTQ0TWpZZ01UY3VPVGMyUXpFNE5DNDNPU0F4Tnk0NU56WWdNVGcxTGpVNE55QXhPQzR5TURrZ01UZzJMakUwT0NBeE9DNDJOamhETVRnMkxqY3dOaUF4T1M0eE1qUWdNVGczTGpBd055QXhPUzQzTWpVZ01UZzNMakEzTWlBeU1DNDFUREU0Tnk0d09UUWdNakF1TnpneVNERTVNUzQyTXpOTU1Ua3hMall4TnlBeU1DNDBOa014T1RFdU5USXhJREU0TGpRNE5TQXhPVEF1TnpjeElERTJMamtnTVRnNUxqTTROU0F4TlM0M05VTXhPRGd1TURFeUlERTBMall4TWlBeE9EWXVNVGcxSURFMExqQXpNeUF4T0RNdU9UWXlJREUwTGpBek0wTXhPREl1TkRjM0lERTBMakF6TXlBeE9ERXVNVFF4SURFMExqSTROeUF4TnprdU9UazBJREUwTGpjNE5rTXhOemd1T0RNeElERTFMakk1TVNBeE56Y3VPVEkySURFMUxqazVOU0F4TnpjdU1qazJJREUyTGpnNE1rTXhOell1TmpjeklERTNMamMwTlRVZ01UYzJMak16T0NBeE9DNDNPRFFnTVRjMkxqTTBNU0F4T1M0NE5EbERNVGMyTGpNME1TQXlNUzR4TmpjZ01UYzJMalk1T0NBeU1pNHlORGtnTVRjM0xqTTVPU0F5TXk0d05qUkRNVGM0TGpBMklESXpMamcwTXpJZ01UYzRMamc1T0NBeU5DNDBOVE0wSURFM09TNDRORElnTWpRdU9EUTBRekU0TUM0M05EUWdNalV1TWpFMklERTRNUzQ1TWpnZ01qVXVOakEzSURFNE15NHpOakVnTWpaRE1UZzBMamd3TmlBeU5pNDBNU0F4T0RVdU9EY3lJREkyTGpjNE5TQXhPRFl1TlRNZ01qY3VNVEl6UXpFNE55NHhJREkzTGpReE5DQXhPRGN1TXpjNUlESTNMamcwTlNBeE9EY3VNemM1SURJNExqUTBORU14T0RjdU16YzVJREk1TGpBME1pQXhPRGN1TVRJeUlESTVMalEyTnlBeE9EWXVOVGsxSURJNUxqZ3pPVU14T0RZdU1EUXpJRE13TGpJeU5pQXhPRFV1TWpNM0lETXdMalF5TlNBeE9EUXVNakF4SURNd0xqUXlOVU14T0RNdU1UWTJJRE13TGpReU5TQXhPREl1TXprMElETXdMakUzTkNBeE9ERXVOelE1SURJNUxqWTNORU14T0RFdU1URXpJREk1TGpFNE1TQXhPREF1TnpjeUlESTRMalU0T1NBeE9EQXVOekVnTWpjdU9EWTBUREU0TUM0Mk9EVWdNamN1TlRneVNERTNOaTR3TVROTU1UYzJMakF5TlNBeU55NDVNREZETVRjMkxqQTJOeUF5T1M0d09UVTFJREUzTmk0ME56SWdNekF1TWpRNE55QXhOemN1TVRnNElETXhMakl3TmtNeE56Y3VPVEEzSURNeUxqRTRJREUzT0M0NE9UTWdNekl1T1RVNElERTRNQzR4TVRnZ016TXVOVEU1UXpFNE1TNHpNellnTXpRdU1EYzNJREU0TWk0M016SWdNelF1TXpZeUlERTROQzR5TmpZZ016UXVNell5UXpFNE5TNDRNREVnTXpRdU16WXlJREU0Tnk0eE1Ea2dNelF1TVRBNElERTRPQzR5TXpnZ016TXVOakE1UXpFNE9TNHpOellnTXpNdU1UQTBJREU1TUM0eU56SWdNekl1TXprMElERTVNQzQ1TURFZ016RXVORGswUXpFNU1TNDFNelFnTXpBdU5Ua3lJREU1TVM0NE5UTWdNamt1TlRVMElERTVNUzQ0TlRNZ01qZ3VOREF6UXpFNU1TNDRNamdnTWpjdU1URWdNVGt4TGpRMk5pQXlOaTR3TlRNZ01Ua3dMamMzTnlBeU5TNHlOakpJTVRrd0xqYzROMW9pSUdacGJHdzlJaU01UWpsQ09VSWlMejRLUEhCaGRHZ2daRDBpVFRJME1TNDVPRElnTWpVdU5qVTRNbFl4Tnk0M01URTNTREl5T0M0ME5ERk1Nakl3TGpRNU5DQXlOUzQyTlRneVNESTBNUzQ1T0RKYUlpQm1hV3hzUFNJak9VSTVRamxDSWk4K0NqeHdZWFJvSUdROUlrMHlOVGN1TWpNNUlEVXVPVFV3T0RGSU1qUXdMakkyTlV3eU16SXVNalUxSURFekxqZzVOek5JTWpVM0xqSXpPVlkxTGprMU1EZ3hXaUlnWm1sc2JEMGlJemxDT1VJNVFpSXZQZ284Y0dGMGFDQmtQU0pOTWpFeUxqWXhNU0F6TXk0Mk1EUTRUREl4Tmk0Mk9DQXlPUzQxTXpZeFNESXpNQzQwTVRKV016Y3VORGd5TjBneU1USXVOakV4VmpNekxqWXdORGhhSWlCbWFXeHNQU0lqT1VJNVFqbENJaTgrQ2p4d1lYUm9JR1E5SWsweU1UVXVOVGs1SURJeExqYzRNRE5JTWpJMExqTTNNa3d5TXpJdU16Z3lJREV6TGpnek16ZElNakUxTGpVNU9WWXlNUzQzT0RBeldpSWdabWxzYkQwaUl6bENPVUk1UWlJdlBnbzhjR0YwYUNCa1BTSk5NakEySURNekxqWXdORGRJTWpFeUxqWXhNVXd5TWpBdU5EazBJREkxTGpZMU9ESklNakEyVmpNekxqWXdORGRhSWlCbWFXeHNQU0lqT1VJNVFqbENJaTgrQ2p4d1lYUm9JR1E5SWsweU5EQXVNalkxSURVdU9UVXdPREZNTWpNMkxqRTVOeUF4TUM0d01UazBTREl4TUM0eU5UbFdNaTR3TnpJNE9FZ3lOREF1TWpZMVZqVXVPVFV3T0RGYUlpQm1hV3hzUFNJak9VSTVRamxDSWk4K0Nqd3ZjM1puUGdvPWAsXG4gICAgICAgICAgICB3aWR0aDogMTcwLFxuICAgICAgICAgICAgaGVpZ2h0OiAyNSxcbiAgICAgICAgICAgIHJpZ2h0OiAyNSxcbiAgICAgICAgICAgIGJvdHRvbTogNTAsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjdcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNwZWNpYWxPdmVycmlkZXMgPSB7IC4uLmNoYXJ0LmNoYXJ0T3B0aW9ucy5zcGVjaWFsT3ZlcnJpZGVzIH07XG4gICAgY29uc3Qgb3B0aW9uc01ldGFkYXRhID0geyAuLi5jaGFydC5jaGFydE9wdGlvbnMub3B0aW9uTWV0YWRhdGEgfTtcbiAgICBjb25zdCBjbG9uZVByb3h5ID0gdGhpcy5mYWN0b3J5QXBpLmNyZWF0ZSh1c2VyT3B0aW9ucywgcHJvY2Vzc2VkT3ZlcnJpZGVzLCBzcGVjaWFsT3ZlcnJpZGVzLCBvcHRpb25zTWV0YWRhdGEpO1xuICAgIGF3YWl0IGNsb25lUHJveHkuc2V0U3RhdGUoc3RhdGUpO1xuICAgIGNsb25lUHJveHkuY2hhcnQuY3R4Lnpvb21NYW5hZ2VyLnVwZGF0ZVpvb20oXCJjaGFydFByb3h5XCIsIGNoYXJ0LmN0eC56b29tTWFuYWdlci5nZXRab29tKCkpO1xuICAgIGNsb25lUHJveHkuY2hhcnQuY3R4LmxlZ2VuZE1hbmFnZXIuY2xlYXJEYXRhKCk7XG4gICAgY2xvbmVQcm94eS5jaGFydC5jdHgubGVnZW5kTWFuYWdlci51cGRhdGUoY2hhcnQuY3R4LmxlZ2VuZE1hbmFnZXIuZ2V0RGF0YSgpKTtcbiAgICBjaGFydC5zZXJpZXMuZm9yRWFjaCgoc2VyaWVzLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKCFzZXJpZXMudmlzaWJsZSkge1xuICAgICAgICBjbG9uZVByb3h5LmNoYXJ0LnNlcmllc1tpbmRleF0udmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGxlZ2VuZFBhZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBsZWdlbmQgb2YgY2hhcnQubW9kdWxlc01hbmFnZXIubGVnZW5kcygpKSB7XG4gICAgICBsZWdlbmRQYWdlcy5wdXNoKGxlZ2VuZC5sZWdlbmQucGFnaW5hdGlvbj8uY3VycmVudFBhZ2UgPz8gMCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGVnZW5kIG9mIGNsb25lUHJveHkuY2hhcnQubW9kdWxlc01hbmFnZXIubGVnZW5kcygpKSB7XG4gICAgICBjb25zdCBwYWdlID0gbGVnZW5kUGFnZXMuc2hpZnQoKSA/PyAwO1xuICAgICAgaWYgKCFsZWdlbmQubGVnZW5kLnBhZ2luYXRpb24pXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgbGVnZW5kLmxlZ2VuZC5wYWdpbmF0aW9uLnNldFBhZ2UocGFnZSk7XG4gICAgfVxuICAgIGNsb25lUHJveHkuY2hhcnQudXBkYXRlKDAgLyogRlVMTCAqLywgeyBmb3JjZU5vZGVEYXRhUmVmcmVzaDogdHJ1ZSB9KTtcbiAgICBhd2FpdCBjbG9uZVByb3h5LndhaXRGb3JVcGRhdGUoKTtcbiAgICByZXR1cm4gY2xvbmVQcm94eTtcbiAgfVxuICBnZXRFbmFibGVkT3JpZ2luYXRvcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2hhcnRPcHRpb25zOiB7IHByb2Nlc3NlZE9wdGlvbnMsIG9wdGlvbk1ldGFkYXRhIH0sXG4gICAgICBjdHg6IHsgYW5ub3RhdGlvbk1hbmFnZXIsIGNoYXJ0VHlwZU9yaWdpbmF0b3IsIHpvb21NYW5hZ2VyLCBsZWdlbmRNYW5hZ2VyIH1cbiAgICB9ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcmlnaW5hdG9ycyA9IFtdO1xuICAgIGlmIChcImFubm90YXRpb25zXCIgaW4gcHJvY2Vzc2VkT3B0aW9ucyAmJiBwcm9jZXNzZWRPcHRpb25zLmFubm90YXRpb25zPy5lbmFibGVkKSB7XG4gICAgICBvcmlnaW5hdG9ycy5wdXNoKGFubm90YXRpb25NYW5hZ2VyKTtcbiAgICB9XG4gICAgY29uc3QgaXNGaW5hbmNpYWxDaGFydCA9IG9wdGlvbk1ldGFkYXRhLnByZXNldFR5cGUgPT09IFwicHJpY2Utdm9sdW1lXCI7XG4gICAgaWYgKGlzRmluYW5jaWFsQ2hhcnQpIHtcbiAgICAgIG9yaWdpbmF0b3JzLnB1c2goY2hhcnRUeXBlT3JpZ2luYXRvcik7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzZWRPcHRpb25zLm5hdmlnYXRvcj8uZW5hYmxlZCB8fCBwcm9jZXNzZWRPcHRpb25zLnpvb20/LmVuYWJsZWQpIHtcbiAgICAgIG9yaWdpbmF0b3JzLnB1c2goem9vbU1hbmFnZXIpO1xuICAgIH1cbiAgICBpZiAoXCJsZWdlbmRcIiBpbiB0aGlzLmNoYXJ0KSB7XG4gICAgICBvcmlnaW5hdG9ycy5wdXNoKGxlZ2VuZE1hbmFnZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ2luYXRvcnM7XG4gIH1cbiAgYXN5bmMgc2V0U3RhdGVPcmlnaW5hdG9ycyhzdGF0ZSwgb3JpZ2luYXRvcnMpIHtcbiAgICB0aGlzLmZhY3RvcnlBcGkuY2FyZXRha2VyLnJlc3RvcmUoc3RhdGUsIC4uLm9yaWdpbmF0b3JzKTtcbiAgICB0aGlzLmNoYXJ0LmN0eC51cGRhdGVTZXJ2aWNlLnVwZGF0ZSgyIC8qIFBST0NFU1NfREFUQSAqLywgeyBmb3JjZU5vZGVEYXRhUmVmcmVzaDogdHJ1ZSB9KTtcbiAgICBhd2FpdCB0aGlzLmNoYXJ0LndhaXRGb3JVcGRhdGUoKTtcbiAgfVxufTtcbl9BZ0NoYXJ0SW5zdGFuY2VQcm94eS5jaGFydEluc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG9sZFZhbHVlKGNoYXJ0KSB7XG4gICAgICBpZiAoIWNoYXJ0LmRlc3Ryb3llZCkge1xuICAgICAgICBjaGFydC5wdWJsaWNBcGkgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBfQWdDaGFydEluc3RhbmNlUHJveHkuY2hhcnRJbnN0YW5jZXMuZGVsZXRlKGNoYXJ0KTtcbiAgICB9LFxuICAgIG5ld1ZhbHVlKGNoYXJ0KSB7XG4gICAgICBpZiAoIWNoYXJ0KVxuICAgICAgICByZXR1cm47XG4gICAgICBjaGFydC5wdWJsaWNBcGkgPSB0aGlzO1xuICAgICAgX0FnQ2hhcnRJbnN0YW5jZVByb3h5LmNoYXJ0SW5zdGFuY2VzLnNldChjaGFydCwgdGhpcyk7XG4gICAgfVxuICB9KVxuXSwgX0FnQ2hhcnRJbnN0YW5jZVByb3h5LnByb3RvdHlwZSwgXCJjaGFydFwiLCAyKTtcbnZhciBBZ0NoYXJ0SW5zdGFuY2VQcm94eSA9IF9BZ0NoYXJ0SW5zdGFuY2VQcm94eTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbG9jYWxlL2xvY2FsZS50c1xudmFyIExvY2FsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZU1vZHVsZUluc3RhbmNlIHtcbiAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmxvY2FsZVRleHQgPSB2b2lkIDA7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0LmN0eC5sb2NhbGVNYW5hZ2VyLnNldExvY2FsZVRleHQodGFyZ2V0LmxvY2FsZVRleHQpO1xuICB9KSxcbiAgVmFsaWRhdGUoUExBSU5fT0JKRUNULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMb2NhbGUucHJvdG90eXBlLCBcImxvY2FsZVRleHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0LmN0eC5sb2NhbGVNYW5hZ2VyLnNldExvY2FsZVRleHRGb3JtYXR0ZXIodGFyZ2V0LmdldExvY2FsZVRleHQpO1xuICB9KSxcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExvY2FsZS5wcm90b3R5cGUsIFwiZ2V0TG9jYWxlVGV4dFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbG9jYWxlL2xvY2FsZU1vZHVsZS50c1xudmFyIExvY2FsZU1vZHVsZSA9IHtcbiAgdHlwZTogXCJyb290XCIsXG4gIG9wdGlvbnNLZXk6IFwibG9jYWxlXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIiwgXCJwb2xhclwiLCBcImhpZXJhcmNoeVwiLCBcInRvcG9sb2d5XCIsIFwiZmxvdy1wcm9wb3J0aW9uXCIsIFwic3RhbmRhbG9uZVwiLCBcImdhdWdlXCJdLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgTG9jYWxlKGN0eClcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL2dyb3VwZWRDYXRlZ29yeVNjYWxlLnRzXG52YXIgR3JvdXBlZENhdGVnb3J5U2NhbGUgPSBjbGFzcyBleHRlbmRzIENhdGVnb3J5U2NhbGUge1xuICBnZXRJbmRleCh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlci5nZXRJbmRleCh2YWx1ZSkgPz8gdGhpcy5nZXRNYXRjaEluZGV4KHZhbHVlKTtcbiAgfVxuICBnZXRNYXRjaEluZGV4KHZhbHVlKSB7XG4gICAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIGNvbnN0IG1hdGNoID0gdGhpcy5fZG9tYWluLmZpbmQoKGQpID0+IEpTT04uc3RyaW5naWZ5KGQpID09PSBrZXkpO1xuICAgIGlmIChtYXRjaCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gc3VwZXIuZ2V0SW5kZXgobWF0Y2gpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9tZW1vLnRzXG52YXIgbWVtb3JpemVkRm5zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBtZW1vKHBhcmFtcywgZm5HZW5lcmF0b3IpIHtcbiAgY29uc3Qgc2VyaWFsaXNlZFBhcmFtcyA9IEpTT04uc3RyaW5naWZ5KHBhcmFtcywgbnVsbCwgMCk7XG4gIGlmICghbWVtb3JpemVkRm5zLmhhcyhmbkdlbmVyYXRvcikpIHtcbiAgICBtZW1vcml6ZWRGbnMuc2V0KGZuR2VuZXJhdG9yLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgfVxuICBpZiAoIW1lbW9yaXplZEZucy5nZXQoZm5HZW5lcmF0b3IpPy5oYXMoc2VyaWFsaXNlZFBhcmFtcykpIHtcbiAgICBtZW1vcml6ZWRGbnMuZ2V0KGZuR2VuZXJhdG9yKT8uc2V0KHNlcmlhbGlzZWRQYXJhbXMsIGZuR2VuZXJhdG9yKHBhcmFtcykpO1xuICB9XG4gIHJldHVybiBtZW1vcml6ZWRGbnMuZ2V0KGZuR2VuZXJhdG9yKT8uZ2V0KHNlcmlhbGlzZWRQYXJhbXMpO1xufVxuZnVuY3Rpb24gc2ltcGxlTWVtb3JpemUoZm4pIHtcbiAgY29uc3QgcHJpbWl0dmVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHBhcmFtc1RvS2V5cyA9ICguLi5wYXJhbXMpID0+IHtcbiAgICByZXR1cm4gcGFyYW1zLm1hcCgodikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gdjtcbiAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJzeW1ib2xcIilcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICBpZiAoIXByaW1pdHZlQ2FjaGUuaGFzKHYpKSB7XG4gICAgICAgIHByaW1pdHZlQ2FjaGUuc2V0KHYsIHsgdiB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmltaXR2ZUNhY2hlLmdldCh2KTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZW1wdHkgPSB7fTtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgcmV0dXJuICguLi5wKSA9PiB7XG4gICAgY29uc3Qga2V5cyA9IHAubGVuZ3RoID09PSAwID8gW2VtcHR5XSA6IHBhcmFtc1RvS2V5cyguLi5wKTtcbiAgICBsZXQgY3VycmVudENhY2hlID0gY2FjaGU7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cy5zbGljZSgwLCAtMSkpIHtcbiAgICAgIGlmICghY3VycmVudENhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgIGN1cnJlbnRDYWNoZS5zZXQoa2V5LCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgICB9XG4gICAgICBjdXJyZW50Q2FjaGUgPSBjdXJyZW50Q2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIGNvbnN0IGZpbmFsS2V5ID0ga2V5cy5hdCgtMSk7XG4gICAgbGV0IGNhY2hlZFZhbHVlID0gY3VycmVudENhY2hlLmdldChmaW5hbEtleSk7XG4gICAgaWYgKCFjYWNoZWRWYWx1ZSkge1xuICAgICAgY2FjaGVkVmFsdWUgPSBmbiguLi5wKTtcbiAgICAgIGN1cnJlbnRDYWNoZS5zZXQoZmluYWxLZXksIGNhY2hlZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFZhbHVlO1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL2FnZ3JlZ2F0ZUZ1bmN0aW9ucy50c1xuZnVuY3Rpb24gc3VtVmFsdWVzKHZhbHVlcywgYWNjdW11bGF0b3IgPSBbMCwgMF0pIHtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgYWNjdW11bGF0b3JbMF0gKz0gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgIGFjY3VtdWxhdG9yWzFdICs9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5mdW5jdGlvbiBzdW0oaWQsIG1hdGNoR3JvdXBJZCkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgaWQsXG4gICAgbWF0Y2hHcm91cElkczogW21hdGNoR3JvdXBJZF0sXG4gICAgdHlwZTogXCJhZ2dyZWdhdGVcIixcbiAgICBhZ2dyZWdhdGVGdW5jdGlvbjogKHZhbHVlcykgPT4gc3VtVmFsdWVzKHZhbHVlcylcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdyb3VwU3VtKGlkLCBtYXRjaEdyb3VwSWQpIHtcbiAgcmV0dXJuIHtcbiAgICBpZCxcbiAgICB0eXBlOiBcImFnZ3JlZ2F0ZVwiLFxuICAgIG1hdGNoR3JvdXBJZHM6IG1hdGNoR3JvdXBJZCA/IFttYXRjaEdyb3VwSWRdIDogdm9pZCAwLFxuICAgIGFnZ3JlZ2F0ZUZ1bmN0aW9uOiAodmFsdWVzKSA9PiBzdW1WYWx1ZXModmFsdWVzKSxcbiAgICBncm91cEFnZ3JlZ2F0ZUZ1bmN0aW9uOiAobmV4dCwgYWNjID0gWzAsIDBdKSA9PiB7XG4gICAgICBhY2NbMF0gKz0gbmV4dD8uWzBdID8/IDA7XG4gICAgICBhY2NbMV0gKz0gbmV4dD8uWzFdID8/IDA7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sXG4gICAgcm91bmQ6IHRydWVcbiAgfTtcbn1cbmZ1bmN0aW9uIHJhbmdlMihpZCwgbWF0Y2hHcm91cElkKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBpZCxcbiAgICBtYXRjaEdyb3VwSWRzOiBbbWF0Y2hHcm91cElkXSxcbiAgICB0eXBlOiBcImFnZ3JlZ2F0ZVwiLFxuICAgIGFnZ3JlZ2F0ZUZ1bmN0aW9uOiAodmFsdWVzKSA9PiBDb250aW51b3VzRG9tYWluLmV4dGVuZERvbWFpbih2YWx1ZXMpXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBncm91cENvdW50KGlkKSB7XG4gIHJldHVybiB7XG4gICAgaWQsXG4gICAgdHlwZTogXCJhZ2dyZWdhdGVcIixcbiAgICBhZ2dyZWdhdGVGdW5jdGlvbjogKCkgPT4gWzAsIDFdLFxuICAgIGdyb3VwQWdncmVnYXRlRnVuY3Rpb246IChuZXh0LCBhY2MgPSBbMCwgMF0pID0+IHtcbiAgICAgIGFjY1swXSArPSBuZXh0Py5bMF0gPz8gMDtcbiAgICAgIGFjY1sxXSArPSBuZXh0Py5bMV0gPz8gMDtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ3JvdXBBdmVyYWdlKGlkLCBtYXRjaEdyb3VwSWQpIHtcbiAgY29uc3QgZGVmID0ge1xuICAgIGlkLFxuICAgIG1hdGNoR3JvdXBJZHM6IG1hdGNoR3JvdXBJZCA/IFttYXRjaEdyb3VwSWRdIDogdm9pZCAwLFxuICAgIHR5cGU6IFwiYWdncmVnYXRlXCIsXG4gICAgYWdncmVnYXRlRnVuY3Rpb246ICh2YWx1ZXMpID0+IHN1bVZhbHVlcyh2YWx1ZXMpLFxuICAgIGdyb3VwQWdncmVnYXRlRnVuY3Rpb246IChuZXh0LCBhY2MgPSBbMCwgMCwgLTFdKSA9PiB7XG4gICAgICBhY2NbMF0gKz0gbmV4dD8uWzBdID8/IDA7XG4gICAgICBhY2NbMV0gKz0gbmV4dD8uWzFdID8/IDA7XG4gICAgICBhY2NbMl0rKztcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICBmaW5hbEZ1bmN0aW9uOiAoYWNjID0gWzAsIDAsIDBdKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhY2NbMF0gKyBhY2NbMV07XG4gICAgICBpZiAocmVzdWx0ID49IDApIHtcbiAgICAgICAgcmV0dXJuIFswLCByZXN1bHQgLyBhY2NbMl1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtyZXN1bHQgLyBhY2NbMl0sIDBdO1xuICAgIH0sXG4gICAgcm91bmQ6IHRydWVcbiAgfTtcbiAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIGFyZWEoaWQsIGFnZ0ZuLCBtYXRjaEdyb3VwSWQpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGlkLFxuICAgIG1hdGNoR3JvdXBJZHM6IG1hdGNoR3JvdXBJZCA/IFttYXRjaEdyb3VwSWRdIDogdm9pZCAwLFxuICAgIHR5cGU6IFwiYWdncmVnYXRlXCIsXG4gICAgYWdncmVnYXRlRnVuY3Rpb246ICh2YWx1ZXMsIGtleVJhbmdlID0gW10pID0+IHtcbiAgICAgIGNvbnN0IGtleVdpZHRoID0ga2V5UmFuZ2VbMV0gLSBrZXlSYW5nZVswXTtcbiAgICAgIHJldHVybiBhZ2dGbi5hZ2dyZWdhdGVGdW5jdGlvbih2YWx1ZXMpLm1hcCgodikgPT4gdiAvIGtleVdpZHRoKTtcbiAgICB9LFxuICAgIHJvdW5kOiB0cnVlXG4gIH07XG4gIGlmIChhZ2dGbi5ncm91cEFnZ3JlZ2F0ZUZ1bmN0aW9uKSB7XG4gICAgcmVzdWx0Lmdyb3VwQWdncmVnYXRlRnVuY3Rpb24gPSBhZ2dGbi5ncm91cEFnZ3JlZ2F0ZUZ1bmN0aW9uO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRlZFZhbHVlKG9ubHlQb3NpdGl2ZSkge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgcmV0dXJuIChkYXR1bSkgPT4ge1xuICAgICAgaWYgKCFpc0Zpbml0ZU51bWJlcihkYXR1bSkpIHtcbiAgICAgICAgcmV0dXJuIGRhdHVtO1xuICAgICAgfVxuICAgICAgdmFsdWUgKz0gb25seVBvc2l0aXZlID8gTWF0aC5tYXgoMCwgZGF0dW0pIDogZGF0dW07XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZSgpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIHJldHVybiAoZGF0dW0pID0+IHtcbiAgICAgIGlmICghaXNGaW5pdGVOdW1iZXIoZGF0dW0pKSB7XG4gICAgICAgIHJldHVybiBkYXR1bTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYWlsaW5nVmFsdWUgPSB2YWx1ZTtcbiAgICAgIHZhbHVlICs9IGRhdHVtO1xuICAgICAgcmV0dXJuIHRyYWlsaW5nVmFsdWU7XG4gICAgfTtcbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZGF0YS9wcm9jZXNzb3JzLnRzXG5mdW5jdGlvbiBiYXNpY0NvbnRpbnVvdXNDaGVja0RhdHVtVmFsaWRhdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0NvbnRpbnVvdXModmFsdWUpO1xufVxuZnVuY3Rpb24gYmFzaWNEaXNjcmV0ZUNoZWNrRGF0dW1WYWxpZGF0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VmFsaWRhdGlvbkZuKHNjYWxlVHlwZSkge1xuICBzd2l0Y2ggKHNjYWxlVHlwZSkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwibG9nXCI6XG4gICAgY2FzZSBcIm9yZGluYWwtdGltZVwiOlxuICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgY2FzZSBcImNvbG9yXCI6XG4gICAgICByZXR1cm4gYmFzaWNDb250aW51b3VzQ2hlY2tEYXR1bVZhbGlkYXRpb247XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBiYXNpY0Rpc2NyZXRlQ2hlY2tEYXR1bVZhbGlkYXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlVHlwZShzY2FsZVR5cGUpIHtcbiAgc3dpdGNoIChzY2FsZVR5cGUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcImxvZ1wiOlxuICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgY2FzZSBcImNvbG9yXCI6XG4gICAgICByZXR1cm4gXCJyYW5nZVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJjYXRlZ29yeVwiO1xuICB9XG59XG5mdW5jdGlvbiBrZXlQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBvcHRzID0ge30pIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHByb3BlcnR5OiBwcm9wTmFtZSxcbiAgICB0eXBlOiBcImtleVwiLFxuICAgIHZhbHVlVHlwZTogZ2V0VmFsdWVUeXBlKHNjYWxlVHlwZSksXG4gICAgdmFsaWRhdGlvbjogZ2V0VmFsaWRhdGlvbkZuKHNjYWxlVHlwZSksXG4gICAgLi4ub3B0c1xuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBvcHRzID0ge30pIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHByb3BlcnR5OiBwcm9wTmFtZSxcbiAgICB0eXBlOiBcInZhbHVlXCIsXG4gICAgdmFsdWVUeXBlOiBnZXRWYWx1ZVR5cGUoc2NhbGVUeXBlKSxcbiAgICB2YWxpZGF0aW9uOiBnZXRWYWxpZGF0aW9uRm4oc2NhbGVUeXBlKSxcbiAgICAuLi5vcHRzXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByb3dDb3VudFByb3BlcnR5KHByb3BOYW1lLCBvcHRzID0ge30pIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHByb3BlcnR5OiBwcm9wTmFtZSxcbiAgICB0eXBlOiBcInZhbHVlXCIsXG4gICAgdmFsdWVUeXBlOiBcInJhbmdlXCIsXG4gICAgbWlzc2luZ1ZhbHVlOiAxLFxuICAgIHByb2Nlc3NvcjogKCkgPT4gKCkgPT4gMSxcbiAgICAuLi5vcHRzXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByYW5nZWRWYWx1ZVByb3BlcnR5KHByb3BOYW1lLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBtaW4gPSAtSW5maW5pdHksIG1heCA9IEluZmluaXR5LCAuLi5kZWZPcHRzIH0gPSBvcHRzO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidmFsdWVcIixcbiAgICBwcm9wZXJ0eTogcHJvcE5hbWUsXG4gICAgdmFsdWVUeXBlOiBcInJhbmdlXCIsXG4gICAgdmFsaWRhdGlvbjogYmFzaWNDb250aW51b3VzQ2hlY2tEYXR1bVZhbGlkYXRpb24sXG4gICAgcHJvY2Vzc29yOiAoKSA9PiAoZGF0dW0pID0+IGlzRmluaXRlTnVtYmVyKGRhdHVtKSA/IGNsYW1wKG1pbiwgZGF0dW0sIG1heCkgOiBkYXR1bSxcbiAgICAuLi5kZWZPcHRzXG4gIH07XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IG9ubHlQb3NpdGl2ZSwgLi4uZGVmT3B0cyB9ID0gb3B0cztcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIC4uLnZhbHVlUHJvcGVydHkocHJvcE5hbWUsIHNjYWxlVHlwZSwgZGVmT3B0cyksXG4gICAgcHJvY2Vzc29yOiBhY2N1bXVsYXRlZFZhbHVlKG9ubHlQb3NpdGl2ZSlcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMgPSB7fSkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLi4udmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBvcHRzKSxcbiAgICBwcm9jZXNzb3I6IHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZSgpXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkocHJvcE5hbWUsIG1vZGUsIHN1bTIsIG9wdHMsIHNjYWxlVHlwZSkge1xuICByZXR1cm4gW1xuICAgIHZhbHVlUHJvcGVydHkocHJvcE5hbWUsIHNjYWxlVHlwZSwgb3B0cyksXG4gICAgYWNjdW11bGF0ZUdyb3VwKG9wdHMuZ3JvdXBJZCwgbW9kZSwgc3VtMiwgb3B0cy5zZXBhcmF0ZU5lZ2F0aXZlKSxcbiAgICAuLi5vcHRzLnJhbmdlSWQgIT0gbnVsbCA/IFtyYW5nZTIob3B0cy5yYW5nZUlkLCBvcHRzLmdyb3VwSWQpXSA6IFtdXG4gIF07XG59XG5mdW5jdGlvbiBncm91cFN0YWNrVmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBvcHRzKSB7XG4gIHJldHVybiBbdmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBvcHRzKSwgYWNjdW11bGF0ZVN0YWNrKG9wdHMuZ3JvdXBJZCldO1xufVxudmFyIFNNQUxMRVNUX0tFWV9JTlRFUlZBTCA9IHtcbiAgdHlwZTogXCJyZWR1Y2VyXCIsXG4gIHByb3BlcnR5OiBcInNtYWxsZXN0S2V5SW50ZXJ2YWxcIixcbiAgaW5pdGlhbFZhbHVlOiBJbmZpbml0eSxcbiAgcmVkdWNlcjogKCkgPT4ge1xuICAgIGxldCBwcmV2WCA9IE5hTjtcbiAgICByZXR1cm4gKHNtYWxsZXN0U29GYXIgPSBJbmZpbml0eSwga2V5cykgPT4ge1xuICAgICAgY29uc3QgbmV4dFggPSB0eXBlb2Yga2V5c1swXSA9PT0gXCJudW1iZXJcIiA/IGtleXNbMF0gOiBOdW1iZXIoa2V5c1swXSk7XG4gICAgICBjb25zdCBpbnRlcnZhbCA9IE1hdGguYWJzKG5leHRYIC0gcHJldlgpO1xuICAgICAgcHJldlggPSBuZXh0WDtcbiAgICAgIGlmICghaXNOYU4oaW50ZXJ2YWwpICYmIGludGVydmFsID4gMCAmJiBpbnRlcnZhbCA8IHNtYWxsZXN0U29GYXIpIHtcbiAgICAgICAgcmV0dXJuIGludGVydmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNtYWxsZXN0U29GYXI7XG4gICAgfTtcbiAgfVxufTtcbnZhciBMQVJHRVNUX0tFWV9JTlRFUlZBTCA9IHtcbiAgdHlwZTogXCJyZWR1Y2VyXCIsXG4gIHByb3BlcnR5OiBcImxhcmdlc3RLZXlJbnRlcnZhbFwiLFxuICBpbml0aWFsVmFsdWU6IC1JbmZpbml0eSxcbiAgcmVkdWNlcjogKCkgPT4ge1xuICAgIGxldCBwcmV2WCA9IE5hTjtcbiAgICByZXR1cm4gKGxhcmdlc3RTb0ZhciA9IC1JbmZpbml0eSwga2V5cykgPT4ge1xuICAgICAgY29uc3QgbmV4dFggPSB0eXBlb2Yga2V5c1swXSA9PT0gXCJudW1iZXJcIiA/IGtleXNbMF0gOiBOdW1iZXIoa2V5c1swXSk7XG4gICAgICBjb25zdCBpbnRlcnZhbCA9IE1hdGguYWJzKG5leHRYIC0gcHJldlgpO1xuICAgICAgcHJldlggPSBuZXh0WDtcbiAgICAgIGlmICghaXNOYU4oaW50ZXJ2YWwpICYmIGludGVydmFsID4gMCAmJiBpbnRlcnZhbCA+IGxhcmdlc3RTb0Zhcikge1xuICAgICAgICByZXR1cm4gaW50ZXJ2YWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFyZ2VzdFNvRmFyO1xuICAgIH07XG4gIH1cbn07XG52YXIgU09SVF9ET01BSU5fR1JPVVBTID0ge1xuICB0eXBlOiBcInByb2Nlc3NvclwiLFxuICBwcm9wZXJ0eTogXCJzb3J0ZWRHcm91cERvbWFpblwiLFxuICBjYWxjdWxhdGU6ICh7IGRvbWFpbjogeyBncm91cHMgfSB9KSA9PiBncm91cHM/LnNsaWNlKCkuc29ydCgoYSwgYikgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYVtpXSAtIGJbaV07XG4gICAgICBpZiAocmVzdWx0ICE9PSAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9KVxufTtcbmZ1bmN0aW9uIG5vcm1hbGlzZUZuQnVpbGRlcih7IG5vcm1hbGlzZVRvIH0pIHtcbiAgY29uc3Qgbm9ybWFsaXNlMiA9ICh2YWwsIGV4dGVudDIpID0+IHtcbiAgICBpZiAoZXh0ZW50MiA9PT0gMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHJlc3VsdCA9ICh2YWwgPz8gMCkgKiBub3JtYWxpc2VUbyAvIGV4dGVudDI7XG4gICAgaWYgKHJlc3VsdCA+PSAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4obm9ybWFsaXNlVG8sIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heCgtbm9ybWFsaXNlVG8sIHJlc3VsdCk7XG4gIH07XG4gIHJldHVybiAoKSA9PiAoKSA9PiAoY29sdW1ucywgdmFsdWVJbmRleGVzLCBkYXRhR3JvdXApID0+IHtcbiAgICBjb25zdCBleHRlbnQyID0gbm9ybWFsaXNlRmluZEV4dGVudChjb2x1bW5zLCB2YWx1ZUluZGV4ZXMsIGRhdGFHcm91cCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZUlkeCBvZiB2YWx1ZUluZGV4ZXMpIHtcbiAgICAgIGZvciAoY29uc3QgZGF0dW1JbmRleCBvZiBkYXRhR3JvdXAuZGF0dW1JbmRpY2VzW3ZhbHVlSWR4XSkge1xuICAgICAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW3ZhbHVlSWR4XTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb2x1bW5bZGF0dW1JbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgY29sdW1uW2RhdHVtSW5kZXhdID0gdm9pZCAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbHVtbltkYXR1bUluZGV4XSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzb25hcmpzL25vLW5lc3RlZC1mdW5jdGlvbnNcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gbm9ybWFsaXNlMih2YWx1ZSwgZXh0ZW50MikgOiB2YWx1ZS5tYXAoKHYpID0+IG5vcm1hbGlzZTIodiwgZXh0ZW50MikpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZUZpbmRFeHRlbnQoY29sdW1ucywgdmFsdWVJbmRleGVzLCBkYXRhR3JvdXApIHtcbiAgY29uc3QgdmFsdWVzRXh0ZW50ID0gWzAsIDBdO1xuICBmb3IgKGNvbnN0IHZhbHVlSWR4IG9mIHZhbHVlSW5kZXhlcykge1xuICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNbdmFsdWVJZHhdO1xuICAgIGZvciAoY29uc3QgZGF0dW1JbmRleCBvZiBkYXRhR3JvdXAuZGF0dW1JbmRpY2VzW3ZhbHVlSWR4XSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBjb2x1bW5bZGF0dW1JbmRleF07XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCB2YWx1ZUV4dGVudCA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiA/IHZhbHVlIDogTWF0aC5tYXgoLi4udmFsdWUubWFwKCh2KSA9PiB2ID8/IDApKTtcbiAgICAgIGNvbnN0IHZhbElkeCA9IHZhbHVlRXh0ZW50IDwgMCA/IDAgOiAxO1xuICAgICAgaWYgKHZhbElkeCA9PT0gMCkge1xuICAgICAgICB2YWx1ZXNFeHRlbnRbdmFsSWR4XSA9IE1hdGgubWluKHZhbHVlc0V4dGVudFt2YWxJZHhdLCB2YWx1ZUV4dGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXNFeHRlbnRbdmFsSWR4XSA9IE1hdGgubWF4KHZhbHVlc0V4dGVudFt2YWxJZHhdLCB2YWx1ZUV4dGVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLm1heChNYXRoLmFicyh2YWx1ZXNFeHRlbnRbMF0pLCB2YWx1ZXNFeHRlbnRbMV0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXNlR3JvdXBUbyhtYXRjaEdyb3VwSWRzLCBub3JtYWxpc2VUbykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZ3JvdXAtdmFsdWUtcHJvY2Vzc29yXCIsXG4gICAgbWF0Y2hHcm91cElkcyxcbiAgICBhZGp1c3Q6IG1lbW8oeyBub3JtYWxpc2VUbyB9LCBub3JtYWxpc2VGbkJ1aWxkZXIpXG4gIH07XG59XG5mdW5jdGlvbiBub3JtYWxpc2VQcm9wZXJ0eUZuQnVpbGRlcih7XG4gIG5vcm1hbGlzZVRvLFxuICB6ZXJvRG9tYWluLFxuICByYW5nZU1pbixcbiAgcmFuZ2VNYXhcbn0pIHtcbiAgY29uc3Qgbm9ybWFsaXNlU3BhbiA9IG5vcm1hbGlzZVRvWzFdIC0gbm9ybWFsaXNlVG9bMF07XG4gIGNvbnN0IG5vcm1hbGlzZTIgPSAodmFsLCBzdGFydDIsIHNwYW4pID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBub3JtYWxpc2VUb1swXSArICh2YWwgLSBzdGFydDIpIC8gc3BhbiAqIG5vcm1hbGlzZVNwYW47XG4gICAgaWYgKHNwYW4gPT09IDApIHtcbiAgICAgIHJldHVybiB6ZXJvRG9tYWluO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0ID49IG5vcm1hbGlzZVRvWzFdKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXNlVG9bMV07XG4gICAgfSBlbHNlIGlmIChyZXN1bHQgPCBub3JtYWxpc2VUb1swXSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGlzZVRvWzBdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4gKCkgPT4gKHBEYXRhLCBwSWR4KSA9PiB7XG4gICAgbGV0IFtzdGFydDIsIGVuZDJdID0gcERhdGEuZG9tYWluLnZhbHVlc1twSWR4XTtcbiAgICBpZiAocmFuZ2VNaW4gIT0gbnVsbClcbiAgICAgIHN0YXJ0MiA9IHJhbmdlTWluO1xuICAgIGlmIChyYW5nZU1heCAhPSBudWxsKVxuICAgICAgZW5kMiA9IHJhbmdlTWF4O1xuICAgIGNvbnN0IHNwYW4gPSBlbmQyIC0gc3RhcnQyO1xuICAgIHBEYXRhLmRvbWFpbi52YWx1ZXNbcElkeF0gPSBbbm9ybWFsaXNlVG9bMF0sIG5vcm1hbGlzZVRvWzFdXTtcbiAgICBjb25zdCBjb2x1bW4gPSBwRGF0YS5jb2x1bW5zW3BJZHhdO1xuICAgIGZvciAobGV0IGRhdHVtSW5kZXggPSAwOyBkYXR1bUluZGV4IDwgY29sdW1uLmxlbmd0aDsgZGF0dW1JbmRleCArPSAxKSB7XG4gICAgICBjb2x1bW5bZGF0dW1JbmRleF0gPSBub3JtYWxpc2UyKGNvbHVtbltkYXR1bUluZGV4XSwgc3RhcnQyLCBzcGFuKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBub3JtYWxpc2VQcm9wZXJ0eVRvKHByb3BlcnR5LCBub3JtYWxpc2VUbywgemVyb0RvbWFpbiwgcmFuZ2VNaW4sIHJhbmdlTWF4KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJwcm9wZXJ0eS12YWx1ZS1wcm9jZXNzb3JcIixcbiAgICBwcm9wZXJ0eSxcbiAgICBhZGp1c3Q6IG1lbW8oeyBub3JtYWxpc2VUbywgcmFuZ2VNaW4sIHJhbmdlTWF4LCB6ZXJvRG9tYWluIH0sIG5vcm1hbGlzZVByb3BlcnR5Rm5CdWlsZGVyKVxuICB9O1xufVxudmFyIEFOSU1BVElPTl9WQUxJREFUSU9OX1VOSVFVRV9LRVlTID0gMTtcbnZhciBBTklNQVRJT05fVkFMSURBVElPTl9PUkRFUkVEX0tFWVMgPSAyO1xudmFyIGFuaW1hdGlvblZhbGlkYXRpb25Qcm9jZXNzS2V5ID0gKGNvdW50LCBkZWYsIGtleVZhbHVlcywgY29sdW1uKSA9PiB7XG4gIGxldCB2YWxpZGF0aW9uID0gQU5JTUFUSU9OX1ZBTElEQVRJT05fVU5JUVVFX0tFWVMgfCBBTklNQVRJT05fVkFMSURBVElPTl9PUkRFUkVEX0tFWVM7XG4gIGlmIChkZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCIpIHtcbiAgICBpZiAoa2V5VmFsdWVzLmxlbmd0aCAhPT0gY291bnQpXG4gICAgICB2YWxpZGF0aW9uICY9IH5BTklNQVRJT05fVkFMSURBVElPTl9VTklRVUVfS0VZUztcbiAgICByZXR1cm4gdmFsaWRhdGlvbjtcbiAgfVxuICBsZXQgbGFzdFZhbHVlID0gY29sdW1uWzBdPy52YWx1ZU9mKCk7XG4gIGZvciAobGV0IGQgPSAxOyB2YWxpZGF0aW9uICE9PSAwICYmIGQgPCBjb2x1bW4ubGVuZ3RoOyBkKyspIHtcbiAgICBjb25zdCBrZXlWYWx1ZSA9IGNvbHVtbltkXT8udmFsdWVPZigpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGtleVZhbHVlKSB8fCBsYXN0VmFsdWUgPiBrZXlWYWx1ZSlcbiAgICAgIHZhbGlkYXRpb24gJj0gfkFOSU1BVElPTl9WQUxJREFUSU9OX09SREVSRURfS0VZUztcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGtleVZhbHVlKSAmJiBsYXN0VmFsdWUgPT09IGtleVZhbHVlKVxuICAgICAgdmFsaWRhdGlvbiAmPSB+QU5JTUFUSU9OX1ZBTElEQVRJT05fVU5JUVVFX0tFWVM7XG4gICAgbGFzdFZhbHVlID0ga2V5VmFsdWU7XG4gIH1cbiAgcmV0dXJuIHZhbGlkYXRpb247XG59O1xuZnVuY3Rpb24gYW5pbWF0aW9uVmFsaWRhdGlvbih2YWx1ZUtleUlkcykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicHJvY2Vzc29yXCIsXG4gICAgcHJvcGVydHk6IFwiYW5pbWF0aW9uVmFsaWRhdGlvblwiLFxuICAgIGNhbGN1bGF0ZShyZXN1bHQpIHtcbiAgICAgIGNvbnN0IHsga2V5czoga2V5c0RlZnMsIHZhbHVlczogdmFsdWVzRGVmIH0gPSByZXN1bHQuZGVmcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5wdXQ6IHsgY291bnQgfSxcbiAgICAgICAgZG9tYWluOiB7IGtleXM6IGRvbWFpbktleXMsIHZhbHVlczogZG9tYWluVmFsdWVzIH0sXG4gICAgICAgIGtleXMsXG4gICAgICAgIGNvbHVtbnNcbiAgICAgIH0gPSByZXN1bHQ7XG4gICAgICBsZXQgdmFsaWRhdGlvbiA9IEFOSU1BVElPTl9WQUxJREFUSU9OX1VOSVFVRV9LRVlTIHwgQU5JTUFUSU9OX1ZBTElEQVRJT05fT1JERVJFRF9LRVlTO1xuICAgICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyB2YWxpZGF0aW9uICE9PSAwICYmIGkgPCBrZXlzRGVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZvciAoY29uc3Qgc2NvcGUgb2Yga2V5c0RlZnNbaV0uc2NvcGVzKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uICY9IGFuaW1hdGlvblZhbGlkYXRpb25Qcm9jZXNzS2V5KFxuICAgICAgICAgICAgICBjb3VudCxcbiAgICAgICAgICAgICAga2V5c0RlZnNbaV0sXG4gICAgICAgICAgICAgIGRvbWFpbktleXNbaV0sXG4gICAgICAgICAgICAgIGtleXNbaV0uZ2V0KHNjb3BlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IHZhbGlkYXRpb24gIT09IDAgJiYgaSA8IHZhbHVlc0RlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzRGVmW2ldO1xuICAgICAgICAgIGlmICghdmFsdWVLZXlJZHM/LmluY2x1ZGVzKHZhbHVlLmlkKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIHZhbGlkYXRpb24gJj0gYW5pbWF0aW9uVmFsaWRhdGlvblByb2Nlc3NLZXkoY291bnQsIHZhbHVlLCBkb21haW5WYWx1ZXNbaV0sIGNvbHVtbnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1bmlxdWVLZXlzOiAodmFsaWRhdGlvbiAmIEFOSU1BVElPTl9WQUxJREFUSU9OX1VOSVFVRV9LRVlTKSAhPT0gMCxcbiAgICAgICAgb3JkZXJlZEtleXM6ICh2YWxpZGF0aW9uICYgQU5JTUFUSU9OX1ZBTElEQVRJT05fT1JERVJFRF9LRVlTKSAhPT0gMFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZEdyb3VwQWNjRm4oeyBtb2RlLCBzZXBhcmF0ZU5lZ2F0aXZlIH0pIHtcbiAgcmV0dXJuICgpID0+ICgpID0+IChjb2x1bW5zLCB2YWx1ZUluZGV4ZXMsIGRhdGFHcm91cCkgPT4ge1xuICAgIGNvbnN0IGFjYyA9IFswLCAwXTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlSWR4IG9mIHZhbHVlSW5kZXhlcykge1xuICAgICAgZm9yIChjb25zdCBkYXR1bUluZGV4IG9mIGRhdGFHcm91cC5kYXR1bUluZGljZXNbdmFsdWVJZHhdID8/IFtdKSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnNbdmFsdWVJZHhdO1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsID0gY29sdW1uW2RhdHVtSW5kZXhdO1xuICAgICAgICBjb25zdCBhY2NJbmRleCA9IGlzTmVnYXRpdmUoY3VycmVudFZhbCkgJiYgc2VwYXJhdGVOZWdhdGl2ZSA/IDAgOiAxO1xuICAgICAgICBpZiAoIWlzRmluaXRlTnVtYmVyKGN1cnJlbnRWYWwpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAobW9kZSA9PT0gXCJub3JtYWxcIilcbiAgICAgICAgICBhY2NbYWNjSW5kZXhdICs9IGN1cnJlbnRWYWw7XG4gICAgICAgIGNvbHVtbltkYXR1bUluZGV4XSA9IGFjY1thY2NJbmRleF07XG4gICAgICAgIGlmIChtb2RlID09PSBcInRyYWlsaW5nXCIpXG4gICAgICAgICAgYWNjW2FjY0luZGV4XSArPSBjdXJyZW50VmFsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkR3JvdXBXaW5kb3dBY2NGbih7IG1vZGUsIHN1bTogc3VtMiB9KSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29uc3QgbGFzdFZhbHVlcyA9IFtdO1xuICAgIGxldCBmaXJzdFJvdyA9IHRydWU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJldHVybiAoY29sdW1ucywgdmFsdWVJbmRleGVzLCBkYXRhR3JvdXApID0+IHtcbiAgICAgICAgbGV0IGFjYyA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWVJZHggb2YgdmFsdWVJbmRleGVzKSB7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gY29sdW1uc1t2YWx1ZUlkeF07XG4gICAgICAgICAgZm9yIChjb25zdCBkYXR1bUluZGV4IG9mIGRhdGFHcm91cC5kYXR1bUluZGljZXNbdmFsdWVJZHhdID8/IFtdKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsID0gY29sdW1uW2RhdHVtSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgbGFzdFZhbHVlID0gZmlyc3RSb3cgJiYgc3VtMiA9PT0gXCJjdXJyZW50XCIgPyAwIDogbGFzdFZhbHVlc1t2YWx1ZUlkeF07XG4gICAgICAgICAgICBsYXN0VmFsdWVzW3ZhbHVlSWR4XSA9IGN1cnJlbnRWYWw7XG4gICAgICAgICAgICBjb25zdCBzdW1WYWx1ZSA9IHN1bTIgPT09IFwiY3VycmVudFwiID8gY3VycmVudFZhbCA6IGxhc3RWYWx1ZTtcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGVOdW1iZXIoY3VycmVudFZhbCkgfHwgIWlzRmluaXRlTnVtYmVyKGxhc3RWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgY29sdW1uW2RhdHVtSW5kZXhdID0gYWNjO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgICAgIGFjYyArPSBzdW1WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbHVtbltkYXR1bUluZGV4XSA9IGFjYztcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBcInRyYWlsaW5nXCIpIHtcbiAgICAgICAgICAgICAgYWNjICs9IHN1bVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaXJzdFJvdyA9IGZhbHNlO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gYWNjdW11bGF0ZUdyb3VwKG1hdGNoR3JvdXBJZCwgbW9kZSwgc3VtMiwgc2VwYXJhdGVOZWdhdGl2ZSA9IGZhbHNlKSB7XG4gIGxldCBhZGp1c3Q7XG4gIGlmIChtb2RlLnN0YXJ0c1dpdGgoXCJ3aW5kb3dcIikpIHtcbiAgICBjb25zdCBtb2RlUGFyYW0gPSBtb2RlLmVuZHNXaXRoKFwiLXRyYWlsaW5nXCIpID8gXCJ0cmFpbGluZ1wiIDogXCJub3JtYWxcIjtcbiAgICBhZGp1c3QgPSBtZW1vKHsgbW9kZTogbW9kZVBhcmFtLCBzdW06IHN1bTIgfSwgYnVpbGRHcm91cFdpbmRvd0FjY0ZuKTtcbiAgfSBlbHNlIHtcbiAgICBhZGp1c3QgPSBtZW1vKHsgbW9kZSwgc2VwYXJhdGVOZWdhdGl2ZSB9LCBidWlsZEdyb3VwQWNjRm4pO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJncm91cC12YWx1ZS1wcm9jZXNzb3JcIixcbiAgICBtYXRjaEdyb3VwSWRzOiBbbWF0Y2hHcm91cElkXSxcbiAgICBhZGp1c3RcbiAgfTtcbn1cbmZ1bmN0aW9uIGdyb3VwU3RhY2tBY2NGbigpIHtcbiAgcmV0dXJuICgpID0+IChjb2x1bW5zLCB2YWx1ZUluZGV4ZXMsIGRhdGFHcm91cCkgPT4ge1xuICAgIGNvbnN0IGFjYyA9IG5ldyBGbG9hdDY0QXJyYXkodmFsdWVJbmRleGVzLmxlbmd0aCk7XG4gICAgbGV0IHN0YWNrQ291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgdmFsdWVJZHggb2YgdmFsdWVJbmRleGVzKSB7XG4gICAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW3ZhbHVlSWR4XTtcbiAgICAgIGZvciAoY29uc3QgZGF0dW1JbmRleCBvZiBkYXRhR3JvdXAuZGF0dW1JbmRpY2VzW3ZhbHVlSWR4XSA/PyBbXSkge1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBjb2x1bW5bZGF0dW1JbmRleF07XG4gICAgICAgIGFjY1tzdGFja0NvdW50XSA9IE51bWJlci5pc0Zpbml0ZShjdXJyZW50VmFsdWUpID8gY3VycmVudFZhbHVlIDogTmFOO1xuICAgICAgICBzdGFja0NvdW50ICs9IDE7XG4gICAgICAgIGNvbHVtbltkYXR1bUluZGV4XSA9IGFjYy5zdWJhcnJheSgwLCBzdGFja0NvdW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRlU3RhY2sobWF0Y2hHcm91cElkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJncm91cC12YWx1ZS1wcm9jZXNzb3JcIixcbiAgICBtYXRjaEdyb3VwSWRzOiBbbWF0Y2hHcm91cElkXSxcbiAgICBhZGp1c3Q6IGdyb3VwU3RhY2tBY2NGblxuICB9O1xufVxuZnVuY3Rpb24gdmFsdWVJZGVudGlmaWVyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5pZCA/PyB2YWx1ZS5wcm9wZXJ0eTtcbn1cbmZ1bmN0aW9uIHZhbHVlSW5kaWNlcyhpZCwgcHJldmlvdXNEYXRhLCBwcm9jZXNzZWREYXRhKSB7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBwcmV2aW91c1ZhbHVlcyA9IHByZXZpb3VzRGF0YS5kZWZzLnZhbHVlcztcbiAgZm9yIChsZXQgcHJldmlvdXNJbmRleCA9IDA7IHByZXZpb3VzSW5kZXggPCBwcmV2aW91c1ZhbHVlcy5sZW5ndGg7IHByZXZpb3VzSW5kZXggKz0gMSkge1xuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBwcmV2aW91c1ZhbHVlc1twcmV2aW91c0luZGV4XTtcbiAgICBpZiAocHJldmlvdXNWYWx1ZS5zY29wZXM/LmluY2x1ZGVzKGlkKSA9PT0gZmFsc2UpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCB2YWx1ZUlkID0gdmFsdWVJZGVudGlmaWVyKHByZXZpb3VzVmFsdWUpO1xuICAgIGlmIChwcm9wZXJ0aWVzLmhhcyh2YWx1ZUlkKSlcbiAgICAgIHJldHVybjtcbiAgICBwcm9wZXJ0aWVzLnNldCh2YWx1ZUlkLCBwcmV2aW91c0luZGV4KTtcbiAgfVxuICBjb25zdCBpbmRpY2VzID0gW107XG4gIGNvbnN0IG5leHRWYWx1ZXMgPSBwcm9jZXNzZWREYXRhLmRlZnMudmFsdWVzO1xuICBmb3IgKGxldCBuZXh0SW5kZXggPSAwOyBuZXh0SW5kZXggPCBuZXh0VmFsdWVzLmxlbmd0aDsgbmV4dEluZGV4ICs9IDEpIHtcbiAgICBjb25zdCBuZXh0VmFsdWUgPSBuZXh0VmFsdWVzW25leHRJbmRleF07XG4gICAgaWYgKG5leHRWYWx1ZS5zY29wZXM/LmluY2x1ZGVzKGlkKSA9PT0gZmFsc2UpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCB2YWx1ZUlkID0gdmFsdWVJZGVudGlmaWVyKG5leHRWYWx1ZSk7XG4gICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHByb3BlcnRpZXMuZ2V0KHZhbHVlSWQpO1xuICAgIGlmIChwcmV2aW91c0luZGV4ID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgcHJvcGVydGllcy5kZWxldGUodmFsdWVJZCk7XG4gICAgaW5kaWNlcy5wdXNoKHsgcHJldmlvdXNJbmRleCwgbmV4dEluZGV4IH0pO1xuICB9XG4gIGlmIChwcm9wZXJ0aWVzLnNpemUgIT09IDApXG4gICAgcmV0dXJuO1xuICByZXR1cm4gaW5kaWNlcztcbn1cbmZ1bmN0aW9uIGNvbHVtbnNFcXVhbChwcmV2aW91c0NvbHVtbnMsIG5leHRDb2x1bW5zLCBpbmRpY2VzLCBwcmV2aW91c0RhdHVtSW5kZXgsIG5leHREYXR1bUluZGV4KSB7XG4gIGZvciAoY29uc3QgeyBwcmV2aW91c0luZGV4LCBuZXh0SW5kZXggfSBvZiBpbmRpY2VzKSB7XG4gICAgY29uc3QgcHJldmlvdXNDb2x1bW4gPSBwcmV2aW91c0NvbHVtbnNbcHJldmlvdXNJbmRleF07XG4gICAgY29uc3QgbmV4dENvbHVtbiA9IG5leHRDb2x1bW5zW25leHRJbmRleF07XG4gICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzQ29sdW1uW3ByZXZpb3VzRGF0dW1JbmRleF07XG4gICAgY29uc3QgbmV4dFZhbHVlID0gbmV4dENvbHVtbltuZXh0RGF0dW1JbmRleF07XG4gICAgaWYgKHByZXZpb3VzVmFsdWUgIT09IG5leHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRpZmYoaWQsIHByZXZpb3VzRGF0YSwgdXBkYXRlTW92ZWREYXRhID0gdHJ1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicHJvY2Vzc29yXCIsXG4gICAgcHJvcGVydHk6IFwiZGlmZlwiLFxuICAgIGNhbGN1bGF0ZShwcm9jZXNzZWREYXRhLCBwcmV2aW91c1ZhbHVlKSB7XG4gICAgICBjb25zdCBtb3ZlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBhZGRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCB1cGRhdGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgcHJldmlvdXNLZXlzID0gcHJldmlvdXNEYXRhLmtleXM7XG4gICAgICBjb25zdCBrZXlzID0gcHJvY2Vzc2VkRGF0YS5rZXlzO1xuICAgICAgY29uc3QgcHJldmlvdXNDb2x1bW5zID0gcHJldmlvdXNEYXRhLmNvbHVtbnM7XG4gICAgICBjb25zdCBjb2x1bW5zID0gcHJvY2Vzc2VkRGF0YS5jb2x1bW5zO1xuICAgICAgY29uc3QgaW5kaWNlcyA9IHZhbHVlSW5kaWNlcyhpZCwgcHJldmlvdXNEYXRhLCBwcm9jZXNzZWREYXRhKTtcbiAgICAgIGlmIChpbmRpY2VzID09IG51bGwpXG4gICAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xuICAgICAgY29uc3QgbGVuZ3RoMiA9IE1hdGgubWF4KHByZXZpb3VzRGF0YS5pbnB1dC5jb3VudCwgcHJvY2Vzc2VkRGF0YS5pbnB1dC5jb3VudCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICBjb25zdCBoYXNQcmV2aW91c0RhdHVtID0gaSA8IHByZXZpb3VzRGF0YS5pbnB1dC5jb3VudDtcbiAgICAgICAgY29uc3QgaGFzRGF0dW0gPSBpIDwgcHJvY2Vzc2VkRGF0YS5pbnB1dC5jb3VudDtcbiAgICAgICAgY29uc3QgcHJldktleXMgPSBoYXNQcmV2aW91c0RhdHVtID8gZGF0dW1LZXlzKHByZXZpb3VzS2V5cywgaWQsIGkpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBwcmV2SWQgPSBwcmV2S2V5cyAhPSBudWxsID8gY3JlYXRlRGF0dW1JZChwcmV2S2V5cykgOiBcIlwiO1xuICAgICAgICBjb25zdCBkS2V5cyA9IGhhc0RhdHVtID8gZGF0dW1LZXlzKGtleXMsIGlkLCBpKSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgZGF0dW1JZCA9IGRLZXlzICE9IG51bGwgPyBjcmVhdGVEYXR1bUlkKGRLZXlzKSA6IFwiXCI7XG4gICAgICAgIGlmIChoYXNEYXR1bSAmJiBoYXNQcmV2aW91c0RhdHVtICYmIHByZXZJZCA9PT0gZGF0dW1JZCkge1xuICAgICAgICAgIGlmICghY29sdW1uc0VxdWFsKHByZXZpb3VzQ29sdW1ucywgY29sdW1ucywgaW5kaWNlcywgaSwgaSkpIHtcbiAgICAgICAgICAgIHVwZGF0ZWQuc2V0KGRhdHVtSWQsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1vdmVkSW5kZXggPSByZW1vdmVkLmdldChkYXR1bUlkKTtcbiAgICAgICAgaWYgKHJlbW92ZWRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZU1vdmVkRGF0YSB8fCAhY29sdW1uc0VxdWFsKHByZXZpb3VzQ29sdW1ucywgY29sdW1ucywgaW5kaWNlcywgcmVtb3ZlZEluZGV4LCBpKSkge1xuICAgICAgICAgICAgdXBkYXRlZC5zZXQoZGF0dW1JZCwgaSk7XG4gICAgICAgICAgICBtb3ZlZC5zZXQoZGF0dW1JZCwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlbW92ZWQuZGVsZXRlKGRhdHVtSWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc0RhdHVtKSB7XG4gICAgICAgICAgYWRkZWQuc2V0KGRhdHVtSWQsIGkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZGVkSW5kZXggPSBhZGRlZC5nZXQocHJldklkKTtcbiAgICAgICAgaWYgKGFkZGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh1cGRhdGVNb3ZlZERhdGEgfHwgIWNvbHVtbnNFcXVhbChwcmV2aW91c0NvbHVtbnMsIGNvbHVtbnMsIGluZGljZXMsIGFkZGVkSW5kZXgsIGkpKSB7XG4gICAgICAgICAgICB1cGRhdGVkLnNldChwcmV2SWQsIGkpO1xuICAgICAgICAgICAgbW92ZWQuc2V0KHByZXZJZCwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZGVkLmRlbGV0ZShwcmV2SWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc1ByZXZpb3VzRGF0dW0pIHtcbiAgICAgICAgICB1cGRhdGVkLmRlbGV0ZShwcmV2SWQpO1xuICAgICAgICAgIHJlbW92ZWQuc2V0KHByZXZJZCwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYW5nZWQgPSBhZGRlZC5zaXplID4gMCB8fCB1cGRhdGVkLnNpemUgPiAwIHx8IHJlbW92ZWQuc2l6ZSA+IDA7XG4gICAgICBjb25zdCB2YWx1ZSA9IHtcbiAgICAgICAgY2hhbmdlZCxcbiAgICAgICAgYWRkZWQ6IG5ldyBTZXQoYWRkZWQua2V5cygpKSxcbiAgICAgICAgdXBkYXRlZDogbmV3IFNldCh1cGRhdGVkLmtleXMoKSksXG4gICAgICAgIHJlbW92ZWQ6IG5ldyBTZXQocmVtb3ZlZC5rZXlzKCkpLFxuICAgICAgICBtb3ZlZDogbmV3IFNldChtb3ZlZC5rZXlzKCkpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHJldmlvdXNWYWx1ZSxcbiAgICAgICAgW2lkXTogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRGF0dW1JZChrZXlzLCAuLi5leHRyYUtleXMpIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKGlzQXJyYXkoa2V5cykpIHtcbiAgICByZXN1bHQgPSBrZXlzLm1hcCgoa2V5KSA9PiB0cmFuc2Zvcm1JbnRlZ3JhdGVkQ2F0ZWdvcnlWYWx1ZShrZXkpKS5qb2luKFwiX19fXCIpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRyYW5zZm9ybUludGVncmF0ZWRDYXRlZ29yeVZhbHVlKGtleXMpO1xuICB9XG4gIGNvbnN0IHByaW1pdGl2ZVR5cGUgPSB0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiByZXN1bHQgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHJlc3VsdCA9PT0gXCJib29sZWFuXCIgfHwgcmVzdWx0IGluc3RhbmNlb2YgRGF0ZTtcbiAgaWYgKHByaW1pdGl2ZVR5cGUgJiYgZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXN1bHQgKz0gYF9fXyR7ZXh0cmFLZXlzLmpvaW4oXCJfX19cIil9YDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL3RyZWUudHNcbnZhciBEaW1lbnNpb25zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRvcCA9IEluZmluaXR5O1xuICAgIHRoaXMucmlnaHQgPSAtSW5maW5pdHk7XG4gICAgdGhpcy5ib3R0b20gPSAtSW5maW5pdHk7XG4gICAgdGhpcy5sZWZ0ID0gSW5maW5pdHk7XG4gIH1cbiAgdXBkYXRlKHgsIHkpIHtcbiAgICBpZiAoeCA+IHRoaXMucmlnaHQpIHtcbiAgICAgIHRoaXMucmlnaHQgPSB4O1xuICAgIH1cbiAgICBpZiAoeCA8IHRoaXMubGVmdCkge1xuICAgICAgdGhpcy5sZWZ0ID0geDtcbiAgICB9XG4gICAgaWYgKHkgPiB0aGlzLmJvdHRvbSkge1xuICAgICAgdGhpcy5ib3R0b20gPSB5O1xuICAgIH1cbiAgICBpZiAoeSA8IHRoaXMudG9wKSB7XG4gICAgICB0aGlzLnRvcCA9IHk7XG4gICAgfVxuICB9XG59O1xudmFyIFRyZWVOb2RlID0gY2xhc3MgX1RyZWVOb2RlIHtcbiAgY29uc3RydWN0b3IobGFiZWwgPSBcIlwiLCBwYXJlbnQsIHJlZklkKSB7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMucmVmSWQgPSByZWZJZDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5zdWJ0cmVlTGVmdCA9IE5hTjtcbiAgICB0aGlzLnN1YnRyZWVSaWdodCA9IE5hTjtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5sZWFmQ291bnQgPSAwO1xuICAgIHRoaXMucHJlbGltID0gMDtcbiAgICB0aGlzLm1vZCA9IDA7XG4gICAgdGhpcy5hbmNlc3RvciA9IHRoaXM7XG4gICAgdGhpcy5jaGFuZ2UgPSAwO1xuICAgIHRoaXMuc2hpZnQgPSAwO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIC8vIHNjcmVlblggaXMgbWVhbnQgdG8gYmUgcmVjb21wdXRlZCBmcm9tIChsYXlvdXQpIHggd2hlbiB0aGUgdHJlZSBpcyByZXNpemVkICh3aXRob3V0IHBlcmZvcm1pbmcgYW5vdGhlciBsYXlvdXQpXG4gICAgdGhpcy5zY3JlZW5YID0gMDtcbiAgICB0aGlzLmRlcHRoID0gcGFyZW50ID8gcGFyZW50LmRlcHRoICsgMSA6IDA7XG4gIH1cbiAgaW5zZXJ0VGljayh0aWNrLCBpbmRleCkge1xuICAgIGxldCByb290ID0gdGhpcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpY2subGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhdGhQYXJ0ID0gdGlja1tpXTtcbiAgICAgIGNvbnN0IGlzTm90TGVhZiA9IGkgIT09IHRpY2subGVuZ3RoIC0gMTtcbiAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHJvb3Q7XG4gICAgICBjb25zdCBleGlzdGluZ05vZGUgPSBjaGlsZHJlbi5maW5kKChjaGlsZCkgPT4gY2hpbGQubGFiZWwgPT09IHBhdGhQYXJ0KTtcbiAgICAgIGlmIChleGlzdGluZ05vZGUgJiYgaXNOb3RMZWFmKSB7XG4gICAgICAgIHJvb3QgPSBleGlzdGluZ05vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IF9UcmVlTm9kZShwYXRoUGFydCwgcm9vdCwgaW5kZXgpO1xuICAgICAgICBub2RlLmluZGV4ID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoaXNOb3RMZWFmKSB7XG4gICAgICAgICAgcm9vdCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0TGVmdFNpYmxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXggPiAwID8gdGhpcy5wYXJlbnQ/LmNoaWxkcmVuW3RoaXMuaW5kZXggLSAxXSA6IHZvaWQgMDtcbiAgfVxuICBnZXRMZWZ0bW9zdFNpYmxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXggPiAwID8gdGhpcy5wYXJlbnQ/LmNoaWxkcmVuWzBdIDogdm9pZCAwO1xuICB9XG4gIC8vIHRyYXZlcnNlIHRoZSBsZWZ0IGNvbnRvdXIgb2YgYSBzdWJ0cmVlLCByZXR1cm4gdGhlIHN1Y2Nlc3NvciBvZiB2IG9uIHRoaXMgY29udG91clxuICBuZXh0TGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXTtcbiAgfVxuICAvLyB0cmF2ZXJzZSB0aGUgcmlnaHQgY29udG91ciBvZiBhIHN1YnRyZWUsIHJldHVybiB0aGUgc3VjY2Vzc29yIG9mIHYgb24gdGhpcyBjb250b3VyXG4gIG5leHRSaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5hdCgtMSk7XG4gIH1cbiAgZ2V0U2libGluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50Py5jaGlsZHJlbi5maWx0ZXIoKF8sIGkpID0+IGkgIT09IHRoaXMuaW5kZXgpID8/IFtdO1xuICB9XG59O1xuZnVuY3Rpb24gdGlja3NUb1RyZWUodGlja3MpIHtcbiAgY29uc3QgbWF4RGVwdGggPSB0aWNrcy5yZWR1Y2UoKGRlcHRoLCB0aWNrKSA9PiBkZXB0aCA8IHRpY2subGVuZ3RoID8gdGljay5sZW5ndGggOiBkZXB0aCwgMCk7XG4gIGNvbnN0IHJvb3QgPSBuZXcgVHJlZU5vZGUoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpXTtcbiAgICB3aGlsZSAodGljay5sZW5ndGggPCBtYXhEZXB0aCkge1xuICAgICAgdGljay5wdXNoKFwiXCIpO1xuICAgIH1cbiAgICByb290Lmluc2VydFRpY2sodGljaywgaSk7XG4gIH1cbiAgcmV0dXJuIHJvb3Q7XG59XG5mdW5jdGlvbiBtb3ZlU3VidHJlZSh3bSwgd3AsIHNoaWZ0KSB7XG4gIGNvbnN0IHN1YnRyZWVzID0gd3AuaW5kZXggLSB3bS5pbmRleDtcbiAgY29uc3QgcmF0aW8yID0gc2hpZnQgLyBzdWJ0cmVlcztcbiAgd3AuY2hhbmdlIC09IHJhdGlvMjtcbiAgd3Auc2hpZnQgKz0gc2hpZnQ7XG4gIHdtLmNoYW5nZSArPSByYXRpbzI7XG4gIHdwLnByZWxpbSArPSBzaGlmdDtcbiAgd3AubW9kICs9IHNoaWZ0O1xufVxuZnVuY3Rpb24gYW5jZXN0b3IodmltLCB2LCBkZWZhdWx0QW5jZXN0b3IpIHtcbiAgcmV0dXJuIHYuZ2V0U2libGluZ3MoKS5pbmRleE9mKHZpbS5hbmNlc3RvcikgPj0gMCA/IHZpbS5hbmNlc3RvciA6IGRlZmF1bHRBbmNlc3Rvcjtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVTaGlmdHMoeyBjaGlsZHJlbiB9KSB7XG4gIGxldCBzaGlmdCA9IDA7XG4gIGxldCBjaGFuZ2UgPSAwO1xuICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCB3ID0gY2hpbGRyZW5baV07XG4gICAgdy5wcmVsaW0gKz0gc2hpZnQ7XG4gICAgdy5tb2QgKz0gc2hpZnQ7XG4gICAgY2hhbmdlICs9IHcuY2hhbmdlO1xuICAgIHNoaWZ0ICs9IHcuc2hpZnQgKyBjaGFuZ2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcG9ydGlvbih2LCBkZWZhdWx0QW5jZXN0b3IpIHtcbiAgY29uc3QgdyA9IHYuZ2V0TGVmdFNpYmxpbmcoKTtcbiAgaWYgKHcpIHtcbiAgICBsZXQgdm9wID0gdjtcbiAgICBsZXQgdmlwID0gdjtcbiAgICBsZXQgdmltID0gdztcbiAgICBsZXQgdm9tID0gdmlwLmdldExlZnRtb3N0U2libGluZygpO1xuICAgIGxldCBzaXAgPSB2aXAubW9kO1xuICAgIGxldCBzb3AgPSB2b3AubW9kO1xuICAgIGxldCBzaW0gPSB2aW0ubW9kO1xuICAgIGxldCBzb20gPSB2b20ubW9kO1xuICAgIHdoaWxlICh2aW0ubmV4dFJpZ2h0KCkgJiYgdmlwLm5leHRMZWZ0KCkpIHtcbiAgICAgIHZpbSA9IHZpbS5uZXh0UmlnaHQoKTtcbiAgICAgIHZpcCA9IHZpcC5uZXh0TGVmdCgpO1xuICAgICAgdm9tID0gdm9tLm5leHRMZWZ0KCk7XG4gICAgICB2b3AgPSB2b3AubmV4dFJpZ2h0KCk7XG4gICAgICB2b3AuYW5jZXN0b3IgPSB2O1xuICAgICAgY29uc3Qgc2hpZnQgPSB2aW0ucHJlbGltICsgc2ltIC0gKHZpcC5wcmVsaW0gKyBzaXApICsgMTtcbiAgICAgIGlmIChzaGlmdCA+IDApIHtcbiAgICAgICAgbW92ZVN1YnRyZWUoYW5jZXN0b3IodmltLCB2LCBkZWZhdWx0QW5jZXN0b3IpLCB2LCBzaGlmdCk7XG4gICAgICAgIHNpcCArPSBzaGlmdDtcbiAgICAgICAgc29wICs9IHNoaWZ0O1xuICAgICAgfVxuICAgICAgc2ltICs9IHZpbS5tb2Q7XG4gICAgICBzaXAgKz0gdmlwLm1vZDtcbiAgICAgIHNvbSArPSB2b20ubW9kO1xuICAgICAgc29wICs9IHZvcC5tb2Q7XG4gICAgfVxuICAgIGlmICh2aW0ubmV4dFJpZ2h0KCkgJiYgIXZvcC5uZXh0UmlnaHQoKSkge1xuICAgICAgdm9wLm1vZCArPSBzaW0gLSBzb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2aXAubmV4dExlZnQoKSAmJiAhdm9tLm5leHRMZWZ0KCkpIHtcbiAgICAgICAgdm9tLm1vZCArPSBzaXAgLSBzb207XG4gICAgICB9XG4gICAgICBkZWZhdWx0QW5jZXN0b3IgPSB2O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdEFuY2VzdG9yO1xufVxuZnVuY3Rpb24gZmlyc3RXYWxrKG5vZGUpIHtcbiAgY29uc3QgeyBjaGlsZHJlbiB9ID0gbm9kZTtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGxldCBbZGVmYXVsdEFuY2VzdG9yXSA9IGNoaWxkcmVuO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGZpcnN0V2FsayhjaGlsZCk7XG4gICAgICBkZWZhdWx0QW5jZXN0b3IgPSBhcHBvcnRpb24oY2hpbGQsIGRlZmF1bHRBbmNlc3Rvcik7XG4gICAgfVxuICAgIGV4ZWN1dGVTaGlmdHMobm9kZSk7XG4gICAgY29uc3QgbWlkcG9pbnQgPSAoY2hpbGRyZW5bMF0ucHJlbGltICsgY2hpbGRyZW4uYXQoLTEpLnByZWxpbSkgLyAyO1xuICAgIGNvbnN0IGxlZnRTaWJsaW5nID0gbm9kZS5nZXRMZWZ0U2libGluZygpO1xuICAgIGlmIChsZWZ0U2libGluZykge1xuICAgICAgbm9kZS5wcmVsaW0gPSBsZWZ0U2libGluZy5wcmVsaW0gKyAxO1xuICAgICAgbm9kZS5tb2QgPSBub2RlLnByZWxpbSAtIG1pZHBvaW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnByZWxpbSA9IG1pZHBvaW50O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsZWZ0U2libGluZyA9IG5vZGUuZ2V0TGVmdFNpYmxpbmcoKTtcbiAgICBub2RlLnByZWxpbSA9IGxlZnRTaWJsaW5nID8gbGVmdFNpYmxpbmcucHJlbGltICsgMSA6IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIHNlY29uZFdhbGsodiwgbSwgbGF5b3V0KSB7XG4gIHYueCA9IHYucHJlbGltICsgbTtcbiAgdi55ID0gdi5kZXB0aDtcbiAgbGF5b3V0Lmluc2VydE5vZGUodik7XG4gIGZvciAoY29uc3QgdyBvZiB2LmNoaWxkcmVuKSB7XG4gICAgc2Vjb25kV2Fsayh3LCBtICsgdi5tb2QsIGxheW91dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRoaXJkV2Fsayh2KSB7XG4gIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHY7XG4gIGxldCBsZWFmQ291bnQgPSAwO1xuICBmb3IgKGNvbnN0IHcgb2YgY2hpbGRyZW4pIHtcbiAgICB0aGlyZFdhbGsodyk7XG4gICAgaWYgKHcuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBsZWFmQ291bnQgKz0gdy5sZWFmQ291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlYWZDb3VudCsrO1xuICAgIH1cbiAgfVxuICB2LmxlYWZDb3VudCA9IGxlYWZDb3VudDtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHYuc3VidHJlZUxlZnQgPSBjaGlsZHJlblswXS5zdWJ0cmVlTGVmdDtcbiAgICB2LnN1YnRyZWVSaWdodCA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnN1YnRyZWVSaWdodDtcbiAgICB2LnggPSAodi5zdWJ0cmVlTGVmdCArIHYuc3VidHJlZVJpZ2h0KSAvIDI7XG4gIH0gZWxzZSB7XG4gICAgdi5zdWJ0cmVlTGVmdCA9IHYueDtcbiAgICB2LnN1YnRyZWVSaWdodCA9IHYueDtcbiAgfVxufVxuZnVuY3Rpb24gdHJlZUxheW91dCh0aWNrcykge1xuICBjb25zdCBsYXlvdXQgPSBuZXcgVHJlZUxheW91dCgpO1xuICBjb25zdCByb290ID0gdGlja3NUb1RyZWUodGlja3MpO1xuICBmaXJzdFdhbGsocm9vdCk7XG4gIHNlY29uZFdhbGsocm9vdCwgLXJvb3QucHJlbGltLCBsYXlvdXQpO1xuICB0aGlyZFdhbGsocm9vdCk7XG4gIHJldHVybiBsYXlvdXQ7XG59XG52YXIgVHJlZUxheW91dCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLm5vZGVzID0gW107XG4gICAgdGhpcy5kZXB0aCA9IDA7XG4gIH1cbiAgaW5zZXJ0Tm9kZShub2RlKSB7XG4gICAgaWYgKHRoaXMuZGVwdGggPCBub2RlLmRlcHRoKSB7XG4gICAgICB0aGlzLmRlcHRoID0gbm9kZS5kZXB0aDtcbiAgICB9XG4gICAgdGhpcy5kaW1lbnNpb25zLnVwZGF0ZShub2RlLngsIG5vZGUueSk7XG4gICAgdGhpcy5ub2Rlcy5wdXNoKG5vZGUpO1xuICB9XG4gIHNjYWxpbmdYKHdpZHRoMiwgZmxpcCkge1xuICAgIGxldCBzY2FsaW5nWCA9IDE7XG4gICAgaWYgKHdpZHRoMiA+IDApIHtcbiAgICAgIGNvbnN0IHsgbGVmdCwgcmlnaHQgfSA9IHRoaXMuZGltZW5zaW9ucztcbiAgICAgIHNjYWxpbmdYID0gd2lkdGgyIC8gKHJpZ2h0IC0gbGVmdCk7XG4gICAgfVxuICAgIGlmIChmbGlwKSB7XG4gICAgICBzY2FsaW5nWCAqPSAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYWxpbmdYO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2dyb3VwZWRDYXRlZ29yeUF4aXMudHNcbnZhciBEZXB0aExhYmVsUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgRGVwdGhMYWJlbFByb3BlcnRpZXMucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEZXB0aExhYmVsUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYXZvaWRDb2xsaXNpb25zXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEZXB0aExhYmVsUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERlcHRoTGFiZWxQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9TVFlMRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRGVwdGhMYWJlbFByb3BlcnRpZXMucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfV0VJR0hULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEZXB0aExhYmVsUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUi5yZXN0cmljdCh7IG1pbjogMSB9KSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRGVwdGhMYWJlbFByb3BlcnRpZXMucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEZXB0aExhYmVsUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbnZhciBEZXB0aFRpY2tQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBEZXB0aFRpY2tQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEZXB0aFRpY2tQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRGVwdGhUaWNrUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xudmFyIERlcHRoUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgRGVwdGhMYWJlbFByb3BlcnRpZXMoKTtcbiAgICB0aGlzLnRpY2sgPSBuZXcgRGVwdGhUaWNrUHJvcGVydGllcygpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgRGVwdGhQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIERlcHRoUHJvcGVydGllcy5wcm90b3R5cGUsIFwidGlja1wiLCAyKTtcbnZhciBHcm91cGVkQ2F0ZWdvcnlBeGlzID0gY2xhc3MgZXh0ZW5kcyBDYXRlZ29yeUF4aXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcihtb2R1bGVDdHgsIG5ldyBHcm91cGVkQ2F0ZWdvcnlTY2FsZSgpKTtcbiAgICAvLyBMYWJlbCBzY2FsZSAobGFiZWxzIGFyZSBwb3NpdGlvbmVkIGJldHdlZW4gdGlja3MsIHRpY2sgY291bnQgPSBsYWJlbCBjb3VudCArIDEpLlxuICAgIC8vIFdlIGRvbid0IGNhbGwgaXMgYGxhYmVsU2NhbGVgIGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGF4ZXMuXG4gICAgdGhpcy50aWNrU2NhbGUgPSBuZXcgR3JvdXBlZENhdGVnb3J5U2NhbGUoKTtcbiAgICB0aGlzLmRlcHRoT3B0aW9ucyA9IG5ldyBQcm9wZXJ0aWVzQXJyYXkoRGVwdGhQcm9wZXJ0aWVzKTtcbiAgICB0aGlzLmluY2x1ZGVJbnZpc2libGVEb21haW5zID0gdHJ1ZTtcbiAgICB0aGlzLnRpY2tTY2FsZS5wYWRkaW5nSW5uZXIgPSAxO1xuICAgIHRoaXMudGlja1NjYWxlLnBhZGRpbmdPdXRlciA9IDA7XG4gIH1cbiAgcmVzaXplVGlja1RyZWUoKSB7XG4gICAgaWYgKCF0aGlzLnRpY2tUcmVlTGF5b3V0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbm9kZXMgfSA9IHRoaXMudGlja1RyZWVMYXlvdXQ7XG4gICAgY29uc3QgeyByYW5nZTogcmFuZ2UzLCBzdGVwLCBpbnNldCwgYmFuZHdpZHRoIH0gPSB0aGlzLnNjYWxlO1xuICAgIGNvbnN0IHdpZHRoMiA9IE1hdGguYWJzKHJhbmdlM1sxXSAtIHJhbmdlM1swXSkgLSBzdGVwO1xuICAgIGNvbnN0IHNjYWxpbmdYID0gdGhpcy50aWNrVHJlZUxheW91dC5zY2FsaW5nWCh3aWR0aDIsIHJhbmdlM1swXSA+IHJhbmdlM1sxXSk7XG4gICAgY29uc3Qgc2hpZnRYID0gaW5zZXQgKyBiYW5kd2lkdGggLyAyO1xuICAgIGxldCBvZmZzZXRYID0gMDtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgIGNvbnN0IHNjcmVlblggPSBub2RlLnggKiBzY2FsaW5nWDtcbiAgICAgIGlmIChvZmZzZXRYID4gc2NyZWVuWCkge1xuICAgICAgICBvZmZzZXRYID0gc2NyZWVuWDtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2NyZWVuWCA9IHNjcmVlblggKyBzaGlmdFg7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgbm9kZS5zY3JlZW5YIC09IG9mZnNldFg7XG4gICAgfVxuICB9XG4gIGdldERlcHRoT3B0aW9uc01hcChtYXhEZXB0aCkge1xuICAgIGNvbnN0IG9wdGlvbnNNYXAgPSBbXTtcbiAgICBjb25zdCB7IGRlcHRoT3B0aW9ucywgbGFiZWwgfSA9IHRoaXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhEZXB0aDsgaSsrKSB7XG4gICAgICBvcHRpb25zTWFwLnB1c2goXG4gICAgICAgIGRlcHRoT3B0aW9uc1tpXT8ubGFiZWwuZW5hYmxlZCA/PyBsYWJlbC5lbmFibGVkID8ge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgc3BhY2luZzogZGVwdGhPcHRpb25zW2ldPy5sYWJlbC5zcGFjaW5nID8/IGxhYmVsLnNwYWNpbmcsXG4gICAgICAgICAgbGluZUhlaWdodDogVGV4dFV0aWxzLmdldExpbmVIZWlnaHQoZGVwdGhPcHRpb25zW2ldPy5sYWJlbC5mb250U2l6ZSA/PyBsYWJlbC5mb250U2l6ZSA/PyAxMCksXG4gICAgICAgICAgYXZvaWRDb2xsaXNpb25zOiBkZXB0aE9wdGlvbnNbaV0/LmxhYmVsLmF2b2lkQ29sbGlzaW9ucyA/PyBsYWJlbC5hdm9pZENvbGxpc2lvbnNcbiAgICAgICAgfSA6IHsgZW5hYmxlZDogZmFsc2UsIHNwYWNpbmc6IDAsIGxpbmVIZWlnaHQ6IDAsIGF2b2lkQ29sbGlzaW9uczogZmFsc2UgfVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnNNYXA7XG4gIH1cbiAgdXBkYXRlQ2F0ZWdvcnlMYWJlbHMoKSB7XG4gICAgaWYgKCF0aGlzLmNvbXB1dGVkTGF5b3V0KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMudGlja0xhYmVsR3JvdXBTZWxlY3Rpb24udXBkYXRlKHRoaXMuY29tcHV0ZWRMYXlvdXQudGlja0xhYmVsTGF5b3V0KS5lYWNoKChub2RlLCBkYXR1bSkgPT4gbm9kZS5zZXRQcm9wZXJ0aWVzKGRhdHVtKSk7XG4gIH1cbiAgdXBkYXRlQXhpc0xpbmUoKSB7XG4gICAgaWYgKCF0aGlzLmNvbXB1dGVkTGF5b3V0KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMubGluZU5vZGUudmlzaWJsZSA9IHRoaXMubGluZS5lbmFibGVkO1xuICAgIHRoaXMubGluZU5vZGUuc3Ryb2tlID0gdGhpcy5saW5lLnN0cm9rZTtcbiAgICB0aGlzLmxpbmVOb2RlLnN0cm9rZVdpZHRoID0gdGhpcy5saW5lLndpZHRoO1xuICB9XG4gIGNvbXB1dGVMYXlvdXQoKSB7XG4gICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTtcbiAgICB0aGlzLnVwZGF0ZVNjYWxlKCk7XG4gICAgdGhpcy5yZXNpemVUaWNrVHJlZSgpO1xuICAgIGlmICghdGhpcy50aWNrVHJlZUxheW91dD8uZGVwdGgpIHtcbiAgICAgIHJldHVybiB7IGJib3g6IEJCb3guemVybywgc2VwYXJhdG9yTGF5b3V0OiBbXSwgdGlja0xhYmVsTGF5b3V0OiBbXSB9O1xuICAgIH1cbiAgICBjb25zdCB7IHN0ZXAgfSA9IHRoaXMuc2NhbGU7XG4gICAgY29uc3QgeyB0aXRsZSwgbGFiZWwsIHJhbmdlOiByYW5nZTMsIGRlcHRoT3B0aW9ucyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGRlcHRoOiBtYXhEZXB0aCwgbm9kZXM6IHRyZWVMYWJlbHMgfSA9IHRoaXMudGlja1RyZWVMYXlvdXQ7XG4gICAgY29uc3Qga2VlcEV2ZXJ5ID0gTWF0aC5jZWlsKGxhYmVsLmZvbnRTaXplIC8gc3RlcCk7XG4gICAgY29uc3Qgcm90YXRpb24gPSB0b1JhZGlhbnModGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5wb3NpdGlvbiA9PT0gXCJ0b3BcIiB8fCB0aGlzLnBvc2l0aW9uID09PSBcImJvdHRvbVwiO1xuICAgIGNvbnN0IHNpZGVGbGFnID0gbGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICBjb25zdCB0aWNrTGFiZWxMYXlvdXQgPSBbXTtcbiAgICBjb25zdCBsYWJlbEJCb3hlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgdGVtcFRleHQgPSBuZXcgVHJhbnNmb3JtYWJsZVRleHQoKTtcbiAgICBjb25zdCB7IGRlZmF1bHRSb3RhdGlvbiwgY29uZmlndXJlZFJvdGF0aW9uIH0gPSBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKHtcbiAgICAgIHJvdGF0aW9uOiBsYWJlbC5yb3RhdGlvbixcbiAgICAgIHBhcmFsbGVsOiBsYWJlbC5wYXJhbGxlbCxcbiAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb246IG5vcm1hbGl6ZUFuZ2xlMzYwKHJvdGF0aW9uIC0gTWF0aC5QSSAvIDIpLFxuICAgICAgcGFyYWxsZWxGbGlwUm90YXRpb246IG5vcm1hbGl6ZUFuZ2xlMzYwKHJvdGF0aW9uKVxuICAgIH0pO1xuICAgIGNvbnN0IGxhYmVsUm90YXRpb24gPSBkZWZhdWx0Um90YXRpb24gKyBjb25maWd1cmVkUm90YXRpb247XG4gICAgY29uc3Qgb3B0aW9uc01hcCA9IHRoaXMuZ2V0RGVwdGhPcHRpb25zTWFwKG1heERlcHRoKTtcbiAgICBjb25zdCBzZXRMYWJlbFByb3BzID0gKGRhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZGVwdGggPSBtYXhEZXB0aCAtIGRhdHVtLmRlcHRoO1xuICAgICAgaWYgKCFvcHRpb25zTWFwW2RlcHRoXT8uZW5hYmxlZCB8fCBpbmRleCAlIGtlZXBFdmVyeSAhPT0gMCB8fCAhaW5SYW5nZShkYXR1bS5zY3JlZW5YLCByYW5nZTMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHQyID0gdGhpcy5mb3JtYXRUaWNrKGRhdHVtLmxhYmVsLCBpbmRleCAtIDEpO1xuICAgICAgY29uc3QgbGFiZWxTdHlsZXMgPSB0aGlzLmdldExhYmVsU3R5bGVzKHsgdmFsdWU6IHRleHQyLCBkZXB0aCB9LCBkZXB0aE9wdGlvbnNbZGVwdGhdPy5sYWJlbCk7XG4gICAgICB0ZW1wVGV4dC5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgICAgLi4ubGFiZWxTdHlsZXMsXG4gICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgIHRleHRCYXNlbGluZTogbGFiZWwucGFyYWxsZWwgPyBcImhhbmdpbmdcIiA6IFwiYm90dG9tXCIsXG4gICAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgICB0cmFuc2xhdGlvblg6IDAsXG4gICAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0uc2NyZWVuWFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGxldCBtYXhMZWFmTGFiZWxXaWR0aCA9IDA7XG4gICAgY29uc3QgZGVwdGhMaW5lcyA9IHt9O1xuICAgIHRyZWVMYWJlbHMuZm9yRWFjaCgoZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBkZXB0aCA9IG1heERlcHRoIC0gZGF0dW0uZGVwdGg7XG4gICAgICBjb25zdCBub2RlTGluZXMgPSBjb3VudExpbmVzKGRhdHVtLmxhYmVsKTtcbiAgICAgIGRlcHRoTGluZXNbZGVwdGhdID8/IChkZXB0aExpbmVzW2RlcHRoXSA9IDEpO1xuICAgICAgaWYgKGRlcHRoTGluZXNbZGVwdGhdIDwgbm9kZUxpbmVzKSB7XG4gICAgICAgIGRlcHRoTGluZXNbZGVwdGhdID0gbm9kZUxpbmVzO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNWaXNpYmxlID0gc2V0TGFiZWxQcm9wcyhkYXR1bSwgaW5kZXgpO1xuICAgICAgaWYgKCFpc1Zpc2libGUgfHwgIXRlbXBUZXh0LmdldEJCb3goKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGFiZWxCQm94ZXMuc2V0KGluZGV4LCB0ZW1wVGV4dC5nZXRCQm94KCkpO1xuICAgICAgaWYgKCFkYXR1bS5sZWFmQ291bnQpIHtcbiAgICAgICAgdGVtcFRleHQucm90YXRpb24gPSBsYWJlbFJvdGF0aW9uO1xuICAgICAgICBjb25zdCB7IHdpZHRoOiB3aWR0aDMgfSA9IHRlbXBUZXh0LmdldEJCb3goKTtcbiAgICAgICAgaWYgKG1heExlYWZMYWJlbFdpZHRoIDwgd2lkdGgzKSB7XG4gICAgICAgICAgbWF4TGVhZkxhYmVsV2lkdGggPSB3aWR0aDM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBpZEdlbmVyYXRvciA9IGNyZWF0ZUlkc0dlbmVyYXRvcigpO1xuICAgIGNvbnN0IGxhYmVsWCA9IHNpZGVGbGFnICogb3B0aW9uc01hcFswXS5zcGFjaW5nO1xuICAgIGNvbnN0IHNlcGFyYXRvckRhdGEgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG5lc3RlZFBhZGRpbmcgPSAoZCkgPT4ge1xuICAgICAgbGV0IHYgPSBtYXhMZWFmTGFiZWxXaWR0aDtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGQ7IGkrKykge1xuICAgICAgICB2ICs9IG9wdGlvbnNNYXBbaV0uc3BhY2luZztcbiAgICAgICAgaWYgKGxhYmVsLm1pcnJvcmVkIHx8IGkgIT09IGQpIHtcbiAgICAgICAgICB2ICs9IGRlcHRoTGluZXNbaV0gKiBvcHRpb25zTWFwW2ldLmxpbmVIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH07XG4gICAgdHJlZUxhYmVscy5mb3JFYWNoKChkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpbmRleCA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgdmlzaWJsZSA9IHNldExhYmVsUHJvcHMoZGF0dW0sIGluZGV4KTtcbiAgICAgIGNvbnN0IGlzTGVhZiA9ICFkYXR1bS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICBjb25zdCBkZXB0aCA9IG1heERlcHRoIC0gZGF0dW0uZGVwdGg7XG4gICAgICBpZiAoZGF0dW0ucGFyZW50KSB7XG4gICAgICAgIGNvbnN0IHNlcGFyYXRvclggPSBpc0xlYWYgPyBkYXR1bS54IDogZGF0dW0ueCAtIChkYXR1bS5sZWFmQ291bnQgLSAxKSAvIDI7XG4gICAgICAgIGlmICghc2VwYXJhdG9yRGF0YS5oYXMoc2VwYXJhdG9yWCkpIHtcbiAgICAgICAgICBjb25zdCB0aWNrT3B0aW9ucyA9IHRoaXMuZGVwdGhPcHRpb25zW2RlcHRoXT8udGljaztcbiAgICAgICAgICBsZXQgdiA9IG1heExlYWZMYWJlbFdpZHRoO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGRlcHRoOyBpKyspIHtcbiAgICAgICAgICAgIHYgKz0gb3B0aW9uc01hcFtpXS5zcGFjaW5nO1xuICAgICAgICAgICAgaWYgKGkgIT09IDApIHtcbiAgICAgICAgICAgICAgdiArPSBkZXB0aExpbmVzW2ldICogb3B0aW9uc01hcFtpXS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZXBhcmF0b3JEYXRhLnNldChzZXBhcmF0b3JYLCB7XG4gICAgICAgICAgICB0aWNrU2l6ZTogdixcbiAgICAgICAgICAgIHRpY2tTdHJva2U6IHRpY2tPcHRpb25zPy5zdHJva2UsXG4gICAgICAgICAgICB0aWNrV2lkdGg6IHRpY2tPcHRpb25zPy5lbmFibGVkICE9PSBmYWxzZSA/IHRpY2tPcHRpb25zPy53aWR0aCA6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF2aXNpYmxlKVxuICAgICAgICByZXR1cm47XG4gICAgICB0ZW1wVGV4dC54ID0gbGFiZWxYO1xuICAgICAgdGVtcFRleHQueSA9IDA7XG4gICAgICBpZiAoaXNMZWFmKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoMyB9ID0gbGFiZWxCQm94ZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgY29uc3QgYW5nbGVSYXRpbyA9IGdldEFuZ2xlUmF0aW9SYWRpYW5zKGxhYmVsUm90YXRpb24pO1xuICAgICAgICB0ZW1wVGV4dC5yb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XG4gICAgICAgIHRlbXBUZXh0LnRleHRBbGlnbiA9IFwiZW5kXCI7XG4gICAgICAgIHRlbXBUZXh0LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgICAgIHRlbXBUZXh0LnJvdGF0aW9uQ2VudGVyWCA9IGxhYmVsWCAtIHdpZHRoMyAvIDI7XG4gICAgICAgIHRlbXBUZXh0LnRyYW5zbGF0aW9uWCA9IChvcHRpb25zTWFwW2RlcHRoXS5zcGFjaW5nIC0gd2lkdGgzKSAvIDIgKiBhbmdsZVJhdGlvICogc2lkZUZsYWc7XG4gICAgICAgIGlmIChsYWJlbC5taXJyb3JlZCkge1xuICAgICAgICAgIHRlbXBUZXh0LnRyYW5zbGF0aW9uWCArPSB3aWR0aDM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBUZXh0LnJvdGF0aW9uID0gaXNIb3Jpem9udGFsID8gZGVmYXVsdFJvdGF0aW9uIDogLU1hdGguUEkgLyAyO1xuICAgICAgICB0ZW1wVGV4dC5yb3RhdGlvbkNlbnRlclggPSBsYWJlbFg7XG4gICAgICAgIHRlbXBUZXh0LnRyYW5zbGF0aW9uWCA9IHNpZGVGbGFnICogbmVzdGVkUGFkZGluZyhkZXB0aCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uc01hcFtkZXB0aF0uYXZvaWRDb2xsaXNpb25zKSB7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVJhbmdlID0gaXNMZWFmID8gc3RlcCA6IGRhdHVtLmxlYWZDb3VudCAqIHN0ZXA7XG4gICAgICAgIGlmICh0ZW1wVGV4dC5nZXRCQm94KCkuaGVpZ2h0ID4gYXZhaWxhYmxlUmFuZ2UpIHtcbiAgICAgICAgICBsYWJlbEJCb3hlcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgeyB0ZXh0OiB0ZXh0MiA9IFwiXCIgfSA9IHRlbXBUZXh0O1xuICAgICAgdGlja0xhYmVsTGF5b3V0LnB1c2goe1xuICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgcmFuZ2U6IHRoaXMuc2NhbGUucmFuZ2UsXG4gICAgICAgIHRpY2tJZDogaWRHZW5lcmF0b3IodGV4dDIpLFxuICAgICAgICBmaWxsOiB0ZW1wVGV4dC5maWxsLFxuICAgICAgICBmb250RmFtaWx5OiB0ZW1wVGV4dC5mb250RmFtaWx5LFxuICAgICAgICBmb250U2l6ZTogdGVtcFRleHQuZm9udFNpemUsXG4gICAgICAgIGZvbnRTdHlsZTogdGVtcFRleHQuZm9udFN0eWxlLFxuICAgICAgICBmb250V2VpZ2h0OiB0ZW1wVGV4dC5mb250V2VpZ2h0LFxuICAgICAgICByb3RhdGlvbjogdGVtcFRleHQucm90YXRpb24sXG4gICAgICAgIHJvdGF0aW9uQ2VudGVyWDogdGVtcFRleHQucm90YXRpb25DZW50ZXJYLFxuICAgICAgICB0ZXh0QWxpZ246IHRlbXBUZXh0LnRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZW1wVGV4dC50ZXh0QmFzZWxpbmUsXG4gICAgICAgIHRyYW5zbGF0aW9uWDogdGVtcFRleHQudHJhbnNsYXRpb25YLFxuICAgICAgICB0cmFuc2xhdGlvblk6IHRlbXBUZXh0LnRyYW5zbGF0aW9uWSxcbiAgICAgICAgeDogdGVtcFRleHQueCxcbiAgICAgICAgeTogdGVtcFRleHQueVxuICAgICAgfSk7XG4gICAgICBsYWJlbEJCb3hlcy5zZXQoaW5kZXgsIFRyYW5zZm9ybWFibGUudG9DYW52YXModGVtcFRleHQpKTtcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuYWJsZWQsIHN0cm9rZTogc3Ryb2tlMiwgd2lkdGg6IHdpZHRoMiB9ID0gdGhpcy5saW5lO1xuICAgIHRoaXMubGluZU5vZGUuZGF0dW0gPSB7IHg6IDAsIHkxOiByYW5nZTNbMF0sIHkyOiByYW5nZTNbMV0gfTtcbiAgICB0aGlzLmxpbmVOb2RlLnNldFByb3BlcnRpZXMoeyBzdHJva2U6IHN0cm9rZTIsIHN0cm9rZVdpZHRoOiBlbmFibGVkID8gd2lkdGgyIDogMCB9KTtcbiAgICBjb25zdCBzZXBhcmF0b3JMYXlvdXQgPSBbLi4uc2VwYXJhdG9yRGF0YS52YWx1ZXMoKV07XG4gICAgc2VwYXJhdG9yTGF5b3V0LnB1c2goc2VwYXJhdG9yTGF5b3V0WzBdKTtcbiAgICBjb25zdCBheGlzQm94ZXMgPSBbdGhpcy5saW5lTm9kZS5nZXRCQm94KCksIG5ldyBCQm94KDAsIDAsIHNlcGFyYXRvckxheW91dFswXS50aWNrU2l6ZSAqIHNpZGVGbGFnLCAwKV07XG4gICAgaWYgKHRpdGxlLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlVGl0bGUoZmFsc2UsIHNlcGFyYXRvckxheW91dFswXS50aWNrU2l6ZSk7XG4gICAgICBheGlzQm94ZXMucHVzaCh0aXRsZS5jYXB0aW9uLm5vZGUuZ2V0QkJveCgpKTtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkQkJveCA9IEJCb3gubWVyZ2UoaXRlcmF0ZShsYWJlbEJCb3hlcy52YWx1ZXMoKSwgYXhpc0JveGVzKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJib3g6IHRoaXMuZ2V0VHJhbnNmb3JtQm94KG1lcmdlZEJCb3gpLFxuICAgICAgc2VwYXJhdG9yTGF5b3V0LFxuICAgICAgdGlja0xhYmVsTGF5b3V0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcy9yZW1vdmVzL3VwZGF0ZXMgdGhlIHNjZW5lIGdyYXBoIG5vZGVzIHRoYXQgY29uc3RpdHV0ZSB0aGUgYXhpcy5cbiAgICogU3VwcG9zZWQgdG8gYmUgY2FsbGVkIF9tYW51YWxseV8gYWZ0ZXIgY2hhbmdpbmcgX2FueV8gb2YgdGhlIGF4aXMgcHJvcGVydGllcy5cbiAgICogVGhpcyBhbGxvd3MgdG8gYnVsayBzZXQgYXhpcyBwcm9wZXJ0aWVzIGJlZm9yZSB1cGRhdGluZyB0aGUgbm9kZXMuXG4gICAqIFRoZSBub2RlIGNoYW5nZXMgbWFkZSBieSB0aGlzIG1ldGhvZCBhcmUgcmVuZGVyZWQgb24gdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lLlxuICAgKiBXZSBjb3VsZCBzY2hlZHVsZSB0aGlzIG1ldGhvZCBjYWxsIGF1dG9tYXRpY2FsbHkgb24gdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lXG4gICAqIHdoZW4gYW55IG9mIHRoZSBheGlzIHByb3BlcnRpZXMgY2hhbmdlICh0aGUgd2F5IHdlIGRvIHdoZW4gcHJvcGVydGllcyBvZiBzY2VuZSBncmFwaCdzXG4gICAqIG5vZGVzIGNoYW5nZSksIGJ1dCB0aGlzIHdpbGwgbWVhbiB0aGF0IHdlIGZpcnN0IHdhaXQgZm9yIHRoZSBuZXh0IGFuaW1hdGlvblxuICAgKiBmcmFtZSB0byBtYWtlIGNoYW5nZXMgdG8gdGhlIG5vZGVzIG9mIHRoZSBheGlzLCB0aGVuIHdhaXQgZm9yIGFub3RoZXIgYW5pbWF0aW9uXG4gICAqIGZyYW1lIHRvIHJlbmRlciB0aG9zZSBjaGFuZ2VzLiBJdCdzIG5pY2UgdG8gaGF2ZSBldmVyeXRoaW5nIHVwZGF0ZSBhdXRvbWF0aWNhbGx5LFxuICAgKiBidXQgdGhpcyBleHRyYSBsZXZlbCBvZiBhc3luYyBpbmRpcmVjdGlvbiB3aWxsIG5vdCBqdXN0IGludHJvZHVjZSBhbiB1bndhbnRlZCBkZWxheSxcbiAgICogaXQgd2lsbCBhbHNvIG1ha2UgaXQgaGFyZGVyIHRvIHJlYXNvbiBhYm91dCB0aGUgcHJvZ3JhbS5cbiAgICovXG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuY29tcHV0ZWRMYXlvdXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyB0aWNrU2NhbGUsIGdyaWRMaW5lLCBncmlkTGVuZ3RoIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgc2VwYXJhdG9yTGF5b3V0IH0gPSB0aGlzLmNvbXB1dGVkTGF5b3V0O1xuICAgIGNvbnN0IHRpY2tzRGF0YSA9IHRpY2tTY2FsZS50aWNrcyh7XG4gICAgICBuaWNlOiBmYWxzZSxcbiAgICAgIGludGVydmFsOiB2b2lkIDAsXG4gICAgICB0aWNrQ291bnQ6IHZvaWQgMCxcbiAgICAgIG1pblRpY2tDb3VudDogMCxcbiAgICAgIG1heFRpY2tDb3VudDogSW5maW5pdHlcbiAgICB9KS5tYXAoKHRpY2ssIGluZGV4KSA9PiAoe1xuICAgICAgLi4uc2VwYXJhdG9yTGF5b3V0W2luZGV4XSxcbiAgICAgIHRpY2ssXG4gICAgICB0aWNrSWQ6IGNyZWF0ZURhdHVtSWQodGljaywgaW5kZXgpLFxuICAgICAgdGlja0xhYmVsOiB0aWNrLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIC0gXCIpLFxuICAgICAgdHJhbnNsYXRpb25ZOiBNYXRoLnJvdW5kKHRpY2tTY2FsZS5jb252ZXJ0KHRpY2spKVxuICAgIH0pKTtcbiAgICB0aGlzLmdyaWRMaW5lR3JvdXBTZWxlY3Rpb24udXBkYXRlKGdyaWRMaW5lLmVuYWJsZWQgJiYgZ3JpZExlbmd0aCA/IHRpY2tzRGF0YSA6IFtdKTtcbiAgICB0aGlzLnRpY2tMaW5lR3JvdXBTZWxlY3Rpb24udXBkYXRlKHRoaXMudGljay5lbmFibGVkID8gdGlja3NEYXRhIDogW10pO1xuICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICB0aGlzLnVwZGF0ZUNhdGVnb3J5TGFiZWxzKCk7XG4gICAgdGhpcy51cGRhdGVBeGlzTGluZSgpO1xuICAgIHRoaXMudXBkYXRlR3JpZExpbmVzKCk7XG4gICAgdGhpcy51cGRhdGVUaWNrTGluZXMoKTtcbiAgICB0aGlzLnVwZGF0ZVRpdGxlKCk7XG4gICAgdGhpcy5yZXNldFNlbGVjdGlvbk5vZGVzKCk7XG4gIH1cbiAgY2FsY3VsYXRlTGF5b3V0KCkge1xuICAgIGNvbnN0IHsgc2VwYXJhdG9yTGF5b3V0LCB0aWNrTGFiZWxMYXlvdXQsIGJib3ggfSA9IHRoaXMuY29tcHV0ZUxheW91dCgpO1xuICAgIHRoaXMuY29tcHV0ZWRMYXlvdXQgPSB7IHNlcGFyYXRvckxheW91dCwgdGlja0xhYmVsTGF5b3V0IH07XG4gICAgcmV0dXJuIHsgYmJveCwgcHJpbWFyeVRpY2tDb3VudDogdm9pZCAwLCBuaWNlRG9tYWluOiB0aGlzLnNjYWxlLmRvbWFpbiB9O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBncmlkLiBUaGUgZ3JpZCBpcyBvbmx5IHZpc2libGUgaW4gY2FzZSBvZiBhIG5vbi16ZXJvIHZhbHVlLlxuICAgKi9cbiAgb25HcmlkVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICB0aGlzLmdyaWRMaW5lR3JvdXBTZWxlY3Rpb24uY2xlYXIoKTtcbiAgICB0aGlzLnRpY2tMYWJlbEdyb3VwU2VsZWN0aW9uLmNsZWFyKCk7XG4gIH1cbiAgdXBkYXRlU2NhbGUoKSB7XG4gICAgc3VwZXIudXBkYXRlU2NhbGUoKTtcbiAgICB0aGlzLnRpY2tTY2FsZS5yYW5nZSA9IHRoaXMuc2NhbGUucmFuZ2U7XG4gICAgdGhpcy5zY2FsZS5wYWRkaW5nT3V0ZXIgPSB0aGlzLnNjYWxlLnBhZGRpbmdJbm5lciAvIDI7XG4gIH1cbiAgcHJvY2Vzc0RhdGEoKSB7XG4gICAgY29uc3QgeyBkaXJlY3Rpb24gfSA9IHRoaXM7XG4gICAgY29uc3QgZmxhdERvbWFpbnMgPSB0aGlzLmJvdW5kU2VyaWVzLmZpbHRlcigocykgPT4gcy52aXNpYmxlKS5mbGF0TWFwKChzZXJpZXMpID0+IHNlcmllcy5nZXREb21haW4oZGlyZWN0aW9uKSk7XG4gICAgdGhpcy5kYXRhRG9tYWluID0geyBkb21haW46IGV4dGVudChmbGF0RG9tYWlucykgPz8gdGhpcy5maWx0ZXJEdXBsaWNhdGVBcnJheXMoZmxhdERvbWFpbnMpLCBjbGlwcGVkOiBmYWxzZSB9O1xuICAgIGlmICh0aGlzLmlzUmV2ZXJzZWQoKSkge1xuICAgICAgdGhpcy5kYXRhRG9tYWluLmRvbWFpbi5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGNvbnN0IGRvbWFpbiA9IHRoaXMuZGF0YURvbWFpbi5kb21haW4ubWFwKFxuICAgICAgKGRhdHVtKSA9PiAoXG4gICAgICAgIC8vIEhhbmRsZSBpbnRlZ3JhdGVkIGNoYXJ0cyBkYXRhIHdoZW4gcHJvdmlkZWQgYXMgYW4gb2JqZWN0XG4gICAgICAgIHRvQXJyYXkoaXNPYmplY3QoZGF0dW0pICYmIFwidmFsdWVcIiBpbiBkYXR1bSA/IGRhdHVtLnZhbHVlIDogZGF0dW0pXG4gICAgICApXG4gICAgKTtcbiAgICB0aGlzLnRpY2tUcmVlTGF5b3V0ID0gdHJlZUxheW91dChkb21haW4pO1xuICAgIGNvbnN0IG9yZGVyZWREb21haW4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy50aWNrVHJlZUxheW91dC5ub2Rlcykge1xuICAgICAgaWYgKG5vZGUubGVhZkNvdW50IHx8IG5vZGUucmVmSWQgPT0gbnVsbClcbiAgICAgICAgY29udGludWU7XG4gICAgICBvcmRlcmVkRG9tYWluLnB1c2godGhpcy5kYXRhRG9tYWluLmRvbWFpbltub2RlLnJlZklkXSk7XG4gICAgfVxuICAgIHRoaXMuc2NhbGUuZG9tYWluID0gc29ydEJhc2VkT25BcnJheSh0aGlzLmRhdGFEb21haW4uZG9tYWluLCBvcmRlcmVkRG9tYWluKTtcbiAgICB0aGlzLnRpY2tTY2FsZS5kb21haW4gPSBkb21haW4uY29uY2F0KFtbXCJcIl1dKTtcbiAgICByZXR1cm4geyBhbmltYXRhYmxlOiB0cnVlIH07XG4gIH1cbiAgdXBkYXRlR3JpZExpbmVzKCkge1xuICAgIGlmICghdGhpcy5ncmlkTGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoMiwgc3R5bGUgfSA9IHRoaXMuZ3JpZExpbmU7XG4gICAgY29uc3QgbGluZVNpemUgPSB0aGlzLmdyaWRMZW5ndGggKiAtdGhpcy5sYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIHRoaXMuZ3JpZExpbmVHcm91cFNlbGVjdGlvbi5lYWNoKChsaW5lLCBkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHsgc3Ryb2tlOiBzdHJva2UyLCBsaW5lRGFzaCB9ID0gc3R5bGVbaW5kZXggJSBzdHlsZS5sZW5ndGhdO1xuICAgICAgY29uc3QgeSA9IGRhdHVtLnRyYW5zbGF0aW9uWTtcbiAgICAgIGxpbmUudmlzaWJsZSA9IHRoaXMuaW5SYW5nZSh5KTtcbiAgICAgIGxpbmUueDEgPSAwO1xuICAgICAgbGluZS54MiA9IGxpbmVTaXplO1xuICAgICAgbGluZS55ID0geTtcbiAgICAgIGxpbmUuc3Ryb2tlID0gc3Ryb2tlMjtcbiAgICAgIGxpbmUuc3Ryb2tlV2lkdGggPSB3aWR0aDI7XG4gICAgICBsaW5lLmxpbmVEYXNoID0gbGluZURhc2g7XG4gICAgfSk7XG4gIH1cbiAgZmlsdGVyRHVwbGljYXRlQXJyYXlzKGFycmF5Mikge1xuICAgIGNvbnN0IHNlZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHJldHVybiBhcnJheTIuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBpc0FycmF5KGl0ZW0pID8gSlNPTi5zdHJpbmdpZnkoaXRlbSkgOiBpdGVtO1xuICAgICAgaWYgKHNlZW4uaGFzKGtleSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxufTtcbkdyb3VwZWRDYXRlZ29yeUF4aXMuY2xhc3NOYW1lID0gXCJHcm91cGVkQ2F0ZWdvcnlBeGlzXCI7XG5Hcm91cGVkQ2F0ZWdvcnlBeGlzLnR5cGUgPSBcImdyb3VwZWQtY2F0ZWdvcnlcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVF9BUlJBWSlcbl0sIEdyb3VwZWRDYXRlZ29yeUF4aXMucHJvdG90eXBlLCBcImRlcHRoT3B0aW9uc1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9sb2dBeGlzLnRzXG52YXIgTk9OX1pFUk9fTlVNQkVSID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoKHZhbHVlKSA9PiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT09IDAsIFwiYSBub24temVybyBudW1iZXJcIik7XG52YXIgTG9nQXhpcyA9IGNsYXNzIGV4dGVuZHMgTnVtYmVyQXhpcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKG1vZHVsZUN0eCwgbmV3IExvZ1NjYWxlKCkpO1xuICAgIHRoaXMubWluID0gTmFOO1xuICAgIHRoaXMubWF4ID0gTmFOO1xuICB9XG4gIG5vcm1hbGlzZURhdGFEb21haW4oZCkge1xuICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHRoaXM7XG4gICAgY29uc3QgeyBleHRlbnQ6IGV4dGVudDIsIGNsaXBwZWQgfSA9IG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGEoZCwgbWluLCBtYXgpO1xuICAgIGlmIChleHRlbnQyWzBdIDwgMCAmJiBleHRlbnQyWzFdID4gMCB8fCBkWzBdIDwgMCAmJiBkWzFdID4gMCkge1xuICAgICAgbG9nZ2VyX2V4cG9ydHMud2FybihcbiAgICAgICAgYFRoZSBsb2cgYXhpcyBkb21haW4gY3Jvc3NlcyB6ZXJvLCB0aGUgY2hhcnQgZGF0YSBjYW5ub3QgYmUgcmVuZGVyZWQuIFNlZSBsb2cgYXhpcyBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLmBcbiAgICAgICk7XG4gICAgICByZXR1cm4geyBkb21haW46IFtdLCBjbGlwcGVkIH07XG4gICAgfSBlbHNlIGlmIChleHRlbnQyWzBdID09PSAwIHx8IGV4dGVudDJbMV0gPT09IDAgfHwgZFswXSA9PT0gMCB8fCBkWzFdID09PSAwKSB7XG4gICAgICBsb2dnZXJfZXhwb3J0cy53YXJuKFxuICAgICAgICBgVGhlIGxvZyBheGlzIGRvbWFpbiBjb250YWlucyBhIHZhbHVlIG9mIDAsIHRoZSBjaGFydCBkYXRhIGNhbm5vdCBiZSByZW5kZXJlZC4gU2VlIGxvZyBheGlzIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgKTtcbiAgICAgIHJldHVybiB7IGRvbWFpbjogW10sIGNsaXBwZWQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZG9tYWluOiBleHRlbnQyLCBjbGlwcGVkIH07XG4gIH1cbiAgc2V0IGJhc2UodmFsdWUpIHtcbiAgICB0aGlzLnNjYWxlLmJhc2UgPSB2YWx1ZTtcbiAgfVxuICBnZXQgYmFzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZS5iYXNlO1xuICB9XG4gIGRlZmF1bHREYXR1bUZvcm1hdHRlcihkYXR1bSwgX2ZyYWN0aW9uRGlnaXRzKSB7XG4gICAgcmV0dXJuIFN0cmluZyhkYXR1bSk7XG4gIH1cbiAgZGVmYXVsdExhYmVsRm9ybWF0dGVyKGRhdHVtLCBfZnJhY3Rpb25EaWdpdHMpIHtcbiAgICByZXR1cm4gU3RyaW5nKGRhdHVtKTtcbiAgfVxufTtcbkxvZ0F4aXMuY2xhc3NOYW1lID0gXCJMb2dBeGlzXCI7XG5Mb2dBeGlzLnR5cGUgPSBcImxvZ1wiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKE5VTUJFUl9PUl9OQU4sIE5PTl9aRVJPX05VTUJFUiwgTEVTU19USEFOKFwibWF4XCIpKSksXG4gIERlZmF1bHQoTmFOKVxuXSwgTG9nQXhpcy5wcm90b3R5cGUsIFwibWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKE5VTUJFUl9PUl9OQU4sIE5PTl9aRVJPX05VTUJFUiwgR1JFQVRFUl9USEFOKFwibWluXCIpKSksXG4gIERlZmF1bHQoTmFOKVxuXSwgTG9nQXhpcy5wcm90b3R5cGUsIFwibWF4XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS91dGlsL2Nvcm5lci50c1xudmFyIGRyYXdDb3JuZXIgPSAocGF0aCwgeyB4MCwgeTAsIHgxLCB5MSwgY3gsIGN5IH0sIGNvcm5lclJhZGl1cywgbW92ZSkgPT4ge1xuICBpZiAobW92ZSkge1xuICAgIHBhdGgubW92ZVRvKHgwLCB5MCk7XG4gIH1cbiAgaWYgKHgwICE9PSB4MSB8fCB5MCAhPT0geTEpIHtcbiAgICBjb25zdCByMCA9IE1hdGguYXRhbjIoeTAgLSBjeSwgeDAgLSBjeCk7XG4gICAgY29uc3QgcjEgPSBNYXRoLmF0YW4yKHkxIC0gY3ksIHgxIC0gY3gpO1xuICAgIHBhdGguYXJjKGN4LCBjeSwgY29ybmVyUmFkaXVzLCByMCwgcjEpO1xuICB9IGVsc2Uge1xuICAgIHBhdGgubGluZVRvKHgwLCB5MCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL3JlY3QudHNcbnZhciBlcHNpbG9uID0gMWUtNjtcbnZhciBjb3JuZXJFZGdlcyA9IChsZWFkaW5nRWRnZSwgdHJhaWxpbmdFZGdlLCBsZWFkaW5nSW5zZXQsIHRyYWlsaW5nSW5zZXQsIGNvcm5lclJhZGl1cykgPT4ge1xuICBsZXQgbGVhZGluZ0NsaXBwZWQgPSBmYWxzZTtcbiAgbGV0IHRyYWlsaW5nQ2xpcHBlZCA9IGZhbHNlO1xuICBsZXQgbGVhZGluZzAgPSB0cmFpbGluZ0luc2V0IC0gTWF0aC5zcXJ0KE1hdGgubWF4KGNvcm5lclJhZGl1cyAqKiAyIC0gbGVhZGluZ0luc2V0ICoqIDIsIDApKTtcbiAgbGV0IGxlYWRpbmcxID0gMDtcbiAgbGV0IHRyYWlsaW5nMCA9IDA7XG4gIGxldCB0cmFpbGluZzEgPSBsZWFkaW5nSW5zZXQgLSBNYXRoLnNxcnQoTWF0aC5tYXgoY29ybmVyUmFkaXVzICoqIDIgLSB0cmFpbGluZ0luc2V0ICoqIDIsIDApKTtcbiAgaWYgKGxlYWRpbmcwID4gbGVhZGluZ0VkZ2UpIHtcbiAgICBsZWFkaW5nQ2xpcHBlZCA9IHRydWU7XG4gICAgbGVhZGluZzAgPSBsZWFkaW5nRWRnZTtcbiAgICBsZWFkaW5nMSA9IGxlYWRpbmdJbnNldCAtIE1hdGguc3FydChNYXRoLm1heChjb3JuZXJSYWRpdXMgKiogMiAtICh0cmFpbGluZ0luc2V0IC0gbGVhZGluZ0VkZ2UpICoqIDIpKTtcbiAgfSBlbHNlIGlmIChsZWFkaW5nMCA8IGVwc2lsb24pIHtcbiAgICBsZWFkaW5nMCA9IDA7XG4gIH1cbiAgaWYgKHRyYWlsaW5nMSA+IHRyYWlsaW5nRWRnZSkge1xuICAgIHRyYWlsaW5nQ2xpcHBlZCA9IHRydWU7XG4gICAgdHJhaWxpbmcwID0gdHJhaWxpbmdJbnNldCAtIE1hdGguc3FydChNYXRoLm1heChjb3JuZXJSYWRpdXMgKiogMiAtIChsZWFkaW5nSW5zZXQgLSB0cmFpbGluZ0VkZ2UpICoqIDIpKTtcbiAgICB0cmFpbGluZzEgPSB0cmFpbGluZ0VkZ2U7XG4gIH0gZWxzZSBpZiAodHJhaWxpbmcxIDwgZXBzaWxvbikge1xuICAgIHRyYWlsaW5nMSA9IDA7XG4gIH1cbiAgcmV0dXJuIHsgbGVhZGluZzAsIGxlYWRpbmcxLCB0cmFpbGluZzAsIHRyYWlsaW5nMSwgbGVhZGluZ0NsaXBwZWQsIHRyYWlsaW5nQ2xpcHBlZCB9O1xufTtcbnZhciBjbGlwcGVkUm91bmRSZWN0ID0gKHBhdGgsIHgsIHksIHdpZHRoMiwgaGVpZ2h0MiwgY29ybmVyUmFkaWksIGNsaXBCQm94KSA9PiB7XG4gIGxldCB7XG4gICAgdG9wTGVmdDogdG9wTGVmdENvcm5lclJhZGl1cyxcbiAgICB0b3BSaWdodDogdG9wUmlnaHRDb3JuZXJSYWRpdXMsXG4gICAgYm90dG9tUmlnaHQ6IGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzLFxuICAgIGJvdHRvbUxlZnQ6IGJvdHRvbUxlZnRDb3JuZXJSYWRpdXNcbiAgfSA9IGNvcm5lclJhZGlpO1xuICBjb25zdCBtYXhWZXJ0aWNhbENvcm5lclJhZGl1cyA9IE1hdGgubWF4KFxuICAgIHRvcExlZnRDb3JuZXJSYWRpdXMgKyBib3R0b21MZWZ0Q29ybmVyUmFkaXVzLFxuICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzICsgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXNcbiAgKTtcbiAgY29uc3QgbWF4SG9yaXpvbnRhbENvcm5lclJhZGl1cyA9IE1hdGgubWF4KFxuICAgIHRvcExlZnRDb3JuZXJSYWRpdXMgKyB0b3BSaWdodENvcm5lclJhZGl1cyxcbiAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzICsgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXNcbiAgKTtcbiAgaWYgKG1heFZlcnRpY2FsQ29ybmVyUmFkaXVzIDw9IDAgJiYgbWF4SG9yaXpvbnRhbENvcm5lclJhZGl1cyA8PSAwKSB7XG4gICAgaWYgKGNsaXBCQm94ID09IG51bGwpIHtcbiAgICAgIHBhdGgucmVjdCh4LCB5LCB3aWR0aDIsIGhlaWdodDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoLnJlY3QoY2xpcEJCb3gueCwgY2xpcEJCb3gueSwgY2xpcEJCb3gud2lkdGgsIGNsaXBCQm94LmhlaWdodCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChjbGlwQkJveCA9PSBudWxsICYmIHRvcExlZnRDb3JuZXJSYWRpdXMgPT09IHRvcFJpZ2h0Q29ybmVyUmFkaXVzICYmIHRvcExlZnRDb3JuZXJSYWRpdXMgPT09IGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzICYmIHRvcExlZnRDb3JuZXJSYWRpdXMgPT09IGJvdHRvbUxlZnRDb3JuZXJSYWRpdXMpIHtcbiAgICBwYXRoLnJvdW5kUmVjdCh4LCB5LCB3aWR0aDIsIGhlaWdodDIsIHRvcExlZnRDb3JuZXJSYWRpdXMpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAod2lkdGgyIDwgMCkge1xuICAgIHggKz0gd2lkdGgyO1xuICAgIHdpZHRoMiA9IE1hdGguYWJzKHdpZHRoMik7XG4gIH1cbiAgaWYgKGhlaWdodDIgPCAwKSB7XG4gICAgeSArPSBoZWlnaHQyO1xuICAgIGhlaWdodDIgPSBNYXRoLmFicyhoZWlnaHQyKTtcbiAgfVxuICBpZiAod2lkdGgyIDw9IDAgfHwgaGVpZ2h0MiA8PSAwKVxuICAgIHJldHVybjtcbiAgaWYgKGNsaXBCQm94ID09IG51bGwpIHtcbiAgICBjbGlwQkJveCA9IG5ldyBCQm94KHgsIHksIHdpZHRoMiwgaGVpZ2h0Mik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgeDAgPSBNYXRoLm1heCh4LCBjbGlwQkJveC54KTtcbiAgICBjb25zdCB4MSA9IE1hdGgubWluKHggKyB3aWR0aDIsIGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCk7XG4gICAgY29uc3QgeTAgPSBNYXRoLm1heCh5LCBjbGlwQkJveC55KTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWluKHkgKyBoZWlnaHQyLCBjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0KTtcbiAgICBjbGlwQkJveCA9IG5ldyBCQm94KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gIH1cbiAgY29uc3QgYm9yZGVyU2NhbGUgPSBNYXRoLm1heChtYXhWZXJ0aWNhbENvcm5lclJhZGl1cyAvIGhlaWdodDIsIG1heEhvcml6b250YWxDb3JuZXJSYWRpdXMgLyB3aWR0aDIsIDEpO1xuICBpZiAoYm9yZGVyU2NhbGUgPiAxKSB7XG4gICAgdG9wTGVmdENvcm5lclJhZGl1cyAvPSBib3JkZXJTY2FsZTtcbiAgICB0b3BSaWdodENvcm5lclJhZGl1cyAvPSBib3JkZXJTY2FsZTtcbiAgICBib3R0b21SaWdodENvcm5lclJhZGl1cyAvPSBib3JkZXJTY2FsZTtcbiAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzIC89IGJvcmRlclNjYWxlO1xuICB9XG4gIGxldCBkcmF3VG9wTGVmdENvcm5lciA9IHRydWU7XG4gIGxldCBkcmF3VG9wUmlnaHRDb3JuZXIgPSB0cnVlO1xuICBsZXQgZHJhd0JvdHRvbVJpZ2h0Q29ybmVyID0gdHJ1ZTtcbiAgbGV0IGRyYXdCb3R0b21MZWZ0Q29ybmVyID0gdHJ1ZTtcbiAgbGV0IHRvcExlZnRDb3JuZXI7XG4gIGxldCB0b3BSaWdodENvcm5lcjtcbiAgbGV0IGJvdHRvbVJpZ2h0Q29ybmVyO1xuICBsZXQgYm90dG9tTGVmdENvcm5lcjtcbiAgaWYgKGRyYXdUb3BMZWZ0Q29ybmVyKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBjb3JuZXJFZGdlcyhcbiAgICAgIGNsaXBCQm94LmhlaWdodCxcbiAgICAgIGNsaXBCQm94LndpZHRoLFxuICAgICAgTWF0aC5tYXgoeCArIHRvcExlZnRDb3JuZXJSYWRpdXMgLSBjbGlwQkJveC54LCAwKSxcbiAgICAgIE1hdGgubWF4KHkgKyB0b3BMZWZ0Q29ybmVyUmFkaXVzIC0gY2xpcEJCb3gueSwgMCksXG4gICAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzXG4gICAgKTtcbiAgICBpZiAobm9kZXMubGVhZGluZ0NsaXBwZWQpXG4gICAgICBkcmF3Qm90dG9tTGVmdENvcm5lciA9IGZhbHNlO1xuICAgIGlmIChub2Rlcy50cmFpbGluZ0NsaXBwZWQpXG4gICAgICBkcmF3VG9wUmlnaHRDb3JuZXIgPSBmYWxzZTtcbiAgICBjb25zdCB4MCA9IE1hdGgubWF4KGNsaXBCQm94LnggKyBub2Rlcy5sZWFkaW5nMSwgY2xpcEJCb3gueCk7XG4gICAgY29uc3QgeTAgPSBNYXRoLm1heChjbGlwQkJveC55ICsgbm9kZXMubGVhZGluZzAsIGNsaXBCQm94LnkpO1xuICAgIGNvbnN0IHgxID0gTWF0aC5tYXgoY2xpcEJCb3gueCArIG5vZGVzLnRyYWlsaW5nMSwgY2xpcEJCb3gueCk7XG4gICAgY29uc3QgeTEgPSBNYXRoLm1heChjbGlwQkJveC55ICsgbm9kZXMudHJhaWxpbmcwLCBjbGlwQkJveC55KTtcbiAgICBjb25zdCBjeCA9IHggKyB0b3BMZWZ0Q29ybmVyUmFkaXVzO1xuICAgIGNvbnN0IGN5ID0geSArIHRvcExlZnRDb3JuZXJSYWRpdXM7XG4gICAgdG9wTGVmdENvcm5lciA9IHsgeDAsIHkwLCB4MSwgeTEsIGN4LCBjeSB9O1xuICB9XG4gIGlmIChkcmF3VG9wUmlnaHRDb3JuZXIpIHtcbiAgICBjb25zdCBub2RlcyA9IGNvcm5lckVkZ2VzKFxuICAgICAgY2xpcEJCb3gud2lkdGgsXG4gICAgICBjbGlwQkJveC5oZWlnaHQsXG4gICAgICBNYXRoLm1heCh5ICsgdG9wUmlnaHRDb3JuZXJSYWRpdXMgLSBjbGlwQkJveC55LCAwKSxcbiAgICAgIE1hdGgubWF4KGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCAtICh4ICsgd2lkdGgyIC0gdG9wUmlnaHRDb3JuZXJSYWRpdXMpLCAwKSxcbiAgICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzXG4gICAgKTtcbiAgICBpZiAobm9kZXMubGVhZGluZ0NsaXBwZWQpXG4gICAgICBkcmF3VG9wTGVmdENvcm5lciA9IGZhbHNlO1xuICAgIGlmIChub2Rlcy50cmFpbGluZ0NsaXBwZWQpXG4gICAgICBkcmF3Qm90dG9tUmlnaHRDb3JuZXIgPSBmYWxzZTtcbiAgICBjb25zdCB4MCA9IE1hdGgubWluKGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCAtIG5vZGVzLmxlYWRpbmcwLCBjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGgpO1xuICAgIGNvbnN0IHkwID0gTWF0aC5tYXgoY2xpcEJCb3gueSArIG5vZGVzLmxlYWRpbmcxLCBjbGlwQkJveC55KTtcbiAgICBjb25zdCB4MSA9IE1hdGgubWluKGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCAtIG5vZGVzLnRyYWlsaW5nMCwgY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoKTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWF4KGNsaXBCQm94LnkgKyBub2Rlcy50cmFpbGluZzEsIGNsaXBCQm94LnkpO1xuICAgIGNvbnN0IGN4ID0geCArIHdpZHRoMiAtIHRvcFJpZ2h0Q29ybmVyUmFkaXVzO1xuICAgIGNvbnN0IGN5ID0geSArIHRvcFJpZ2h0Q29ybmVyUmFkaXVzO1xuICAgIHRvcFJpZ2h0Q29ybmVyID0geyB4MCwgeTAsIHgxLCB5MSwgY3gsIGN5IH07XG4gIH1cbiAgaWYgKGRyYXdCb3R0b21SaWdodENvcm5lcikge1xuICAgIGNvbnN0IG5vZGVzID0gY29ybmVyRWRnZXMoXG4gICAgICBjbGlwQkJveC5oZWlnaHQsXG4gICAgICBjbGlwQkJveC53aWR0aCxcbiAgICAgIE1hdGgubWF4KGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCAtICh4ICsgd2lkdGgyIC0gYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMpLCAwKSxcbiAgICAgIE1hdGgubWF4KGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQgLSAoeSArIGhlaWdodDIgLSBib3R0b21SaWdodENvcm5lclJhZGl1cyksIDApLFxuICAgICAgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXNcbiAgICApO1xuICAgIGlmIChub2Rlcy5sZWFkaW5nQ2xpcHBlZClcbiAgICAgIGRyYXdUb3BSaWdodENvcm5lciA9IGZhbHNlO1xuICAgIGlmIChub2Rlcy50cmFpbGluZ0NsaXBwZWQpXG4gICAgICBkcmF3Qm90dG9tTGVmdENvcm5lciA9IGZhbHNlO1xuICAgIGNvbnN0IHgwID0gTWF0aC5taW4oY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoIC0gbm9kZXMubGVhZGluZzEsIGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCk7XG4gICAgY29uc3QgeTAgPSBNYXRoLm1pbihjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0IC0gbm9kZXMubGVhZGluZzAsIGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQpO1xuICAgIGNvbnN0IHgxID0gTWF0aC5taW4oY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoIC0gbm9kZXMudHJhaWxpbmcxLCBjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGgpO1xuICAgIGNvbnN0IHkxID0gTWF0aC5taW4oY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCAtIG5vZGVzLnRyYWlsaW5nMCwgY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCk7XG4gICAgY29uc3QgY3ggPSB4ICsgd2lkdGgyIC0gYm90dG9tUmlnaHRDb3JuZXJSYWRpdXM7XG4gICAgY29uc3QgY3kgPSB5ICsgaGVpZ2h0MiAtIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzO1xuICAgIGJvdHRvbVJpZ2h0Q29ybmVyID0geyB4MCwgeTAsIHgxLCB5MSwgY3gsIGN5IH07XG4gIH1cbiAgaWYgKGRyYXdCb3R0b21MZWZ0Q29ybmVyKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBjb3JuZXJFZGdlcyhcbiAgICAgIGNsaXBCQm94LndpZHRoLFxuICAgICAgY2xpcEJCb3guaGVpZ2h0LFxuICAgICAgTWF0aC5tYXgoY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCAtICh5ICsgaGVpZ2h0MiAtIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXMpLCAwKSxcbiAgICAgIE1hdGgubWF4KHggKyBib3R0b21MZWZ0Q29ybmVyUmFkaXVzIC0gY2xpcEJCb3gueCwgMCksXG4gICAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzXG4gICAgKTtcbiAgICBpZiAobm9kZXMubGVhZGluZ0NsaXBwZWQpXG4gICAgICBkcmF3Qm90dG9tUmlnaHRDb3JuZXIgPSBmYWxzZTtcbiAgICBpZiAobm9kZXMudHJhaWxpbmdDbGlwcGVkKVxuICAgICAgZHJhd1RvcExlZnRDb3JuZXIgPSBmYWxzZTtcbiAgICBjb25zdCB4MCA9IE1hdGgubWF4KGNsaXBCQm94LnggKyBub2Rlcy5sZWFkaW5nMCwgY2xpcEJCb3gueCk7XG4gICAgY29uc3QgeTAgPSBNYXRoLm1pbihjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0IC0gbm9kZXMubGVhZGluZzEsIGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQpO1xuICAgIGNvbnN0IHgxID0gTWF0aC5tYXgoY2xpcEJCb3gueCArIG5vZGVzLnRyYWlsaW5nMCwgY2xpcEJCb3gueCk7XG4gICAgY29uc3QgeTEgPSBNYXRoLm1pbihjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0IC0gbm9kZXMudHJhaWxpbmcxLCBjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0KTtcbiAgICBjb25zdCBjeCA9IHggKyBib3R0b21MZWZ0Q29ybmVyUmFkaXVzO1xuICAgIGNvbnN0IGN5ID0geSArIGhlaWdodDIgLSBib3R0b21MZWZ0Q29ybmVyUmFkaXVzO1xuICAgIGJvdHRvbUxlZnRDb3JuZXIgPSB7IHgwLCB5MCwgeDEsIHkxLCBjeCwgY3kgfTtcbiAgfVxuICBsZXQgZGlkTW92ZSA9IGZhbHNlO1xuICBpZiAoZHJhd1RvcExlZnRDb3JuZXIgJiYgdG9wTGVmdENvcm5lciAhPSBudWxsKSB7XG4gICAgZHJhd0Nvcm5lcihwYXRoLCB0b3BMZWZ0Q29ybmVyLCB0b3BMZWZ0Q29ybmVyUmFkaXVzLCAhZGlkTW92ZSk7XG4gICAgZGlkTW92ZSB8fCAoZGlkTW92ZSA9IHRydWUpO1xuICB9XG4gIGlmIChkcmF3VG9wUmlnaHRDb3JuZXIgJiYgdG9wUmlnaHRDb3JuZXIgIT0gbnVsbCkge1xuICAgIGRyYXdDb3JuZXIocGF0aCwgdG9wUmlnaHRDb3JuZXIsIHRvcFJpZ2h0Q29ybmVyUmFkaXVzLCAhZGlkTW92ZSk7XG4gICAgZGlkTW92ZSB8fCAoZGlkTW92ZSA9IHRydWUpO1xuICB9XG4gIGlmIChkcmF3Qm90dG9tUmlnaHRDb3JuZXIgJiYgYm90dG9tUmlnaHRDb3JuZXIgIT0gbnVsbCkge1xuICAgIGRyYXdDb3JuZXIocGF0aCwgYm90dG9tUmlnaHRDb3JuZXIsIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzLCAhZGlkTW92ZSk7XG4gICAgZGlkTW92ZSB8fCAoZGlkTW92ZSA9IHRydWUpO1xuICB9XG4gIGlmIChkcmF3Qm90dG9tTGVmdENvcm5lciAmJiBib3R0b21MZWZ0Q29ybmVyICE9IG51bGwpIHtcbiAgICBkcmF3Q29ybmVyKHBhdGgsIGJvdHRvbUxlZnRDb3JuZXIsIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXMsICFkaWRNb3ZlKTtcbiAgfVxuICBwYXRoLmNsb3NlUGF0aCgpO1xufTtcbnZhciBSZWN0ID0gY2xhc3MgZXh0ZW5kcyBQYXRoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmJvcmRlclBhdGggPSBuZXcgRXh0ZW5kZWRQYXRoMkQoKTtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy53aWR0aCA9IDEwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMTA7XG4gICAgdGhpcy50b3BMZWZ0Q29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLnRvcFJpZ2h0Q29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuY2xpcEJCb3ggPSB2b2lkIDA7XG4gICAgdGhpcy5jcmlzcCA9IGZhbHNlO1xuICAgIHRoaXMubGFzdFVwZGF0ZVBhdGhTdHJva2VXaWR0aCA9IFNoYXBlLmRlZmF1bHRTdHlsZXMuc3Ryb2tlV2lkdGg7XG4gICAgdGhpcy5lZmZlY3RpdmVTdHJva2VXaWR0aCA9IFNoYXBlLmRlZmF1bHRTdHlsZXMuc3Ryb2tlV2lkdGg7XG4gICAgdGhpcy5oaXR0ZXN0ZXIgPSBzdXBlci5pc1BvaW50SW5QYXRoLmJpbmQodGhpcyk7XG4gICAgdGhpcy5kaXN0YW5jZUNhbGN1bGF0b3IgPSBzdXBlci5kaXN0YW5jZVNxdWFyZWRUcmFuc2Zvcm1lZFBvaW50LmJpbmQodGhpcyk7XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgcmVjdGFuZ2xlJ3Mgd2lkdGggb3IgaGVpZ2h0IGlzIGxlc3MgdGhhbiBhIHBpeGVsXG4gICAgICogYW5kIGNyaXNwIG1vZGUgaXMgb24sIHRoZSByZWN0YW5nbGUgd2lsbCBzdGlsbCBmaXQgaW50byB0aGUgcGl4ZWwsXG4gICAgICogYnV0IHdpbGwgYmUgbGVzcyBvcGFxdWUgdG8gbWFrZSBhbiBlZmZlY3Qgb2YgaG9sZGluZyBsZXNzIHNwYWNlLlxuICAgICAqL1xuICAgIHRoaXMubWljcm9QaXhlbEVmZmVjdE9wYWNpdHkgPSAxO1xuICB9XG4gIHNldCBjb3JuZXJSYWRpdXMoY29ybmVyUmFkaXVzKSB7XG4gICAgdGhpcy50b3BMZWZ0Q29ybmVyUmFkaXVzID0gY29ybmVyUmFkaXVzO1xuICAgIHRoaXMudG9wUmlnaHRDb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXM7XG4gICAgdGhpcy5ib3R0b21SaWdodENvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cztcbiAgICB0aGlzLmJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXM7XG4gIH1cbiAgaXNEaXJ0eVBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMubGFzdFVwZGF0ZVBhdGhTdHJva2VXaWR0aCAhPT0gdGhpcy5zdHJva2VXaWR0aCB8fCBCb29sZWFuKHRoaXMucGF0aC5pc0RpcnR5KCkgfHwgdGhpcy5ib3JkZXJQYXRoLmlzRGlydHkoKSk7XG4gIH1cbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXRoLFxuICAgICAgYm9yZGVyUGF0aCxcbiAgICAgIGNyaXNwLFxuICAgICAgdG9wTGVmdENvcm5lclJhZGl1czogdG9wTGVmdCxcbiAgICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzOiB0b3BSaWdodCxcbiAgICAgIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzOiBib3R0b21SaWdodCxcbiAgICAgIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXM6IGJvdHRvbUxlZnRcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgeyB4LCB5LCB3aWR0aDogdywgaGVpZ2h0OiBoLCBzdHJva2VXaWR0aCwgY2xpcEJCb3ggfSA9IHRoaXM7XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IHRoaXMubGF5ZXJNYW5hZ2VyPy5jYW52YXMucGl4ZWxSYXRpbyA/PyAxO1xuICAgIGNvbnN0IHBpeGVsU2l6ZSA9IDEgLyBwaXhlbFJhdGlvO1xuICAgIGxldCBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eSA9IDE7XG4gICAgcGF0aC5jbGVhcih0cnVlKTtcbiAgICBib3JkZXJQYXRoLmNsZWFyKHRydWUpO1xuICAgIGlmIChjcmlzcCkge1xuICAgICAgaWYgKHcgPD0gcGl4ZWxTaXplKSB7XG4gICAgICAgIG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5ICo9IHcgLyBwaXhlbFNpemU7XG4gICAgICB9XG4gICAgICBpZiAoaCA8PSBwaXhlbFNpemUpIHtcbiAgICAgICAgbWljcm9QaXhlbEVmZmVjdE9wYWNpdHkgKj0gaCAvIHBpeGVsU2l6ZTtcbiAgICAgIH1cbiAgICAgIHcgPSB0aGlzLmFsaWduKHgsIHcpO1xuICAgICAgaCA9IHRoaXMuYWxpZ24oeSwgaCk7XG4gICAgICB4ID0gdGhpcy5hbGlnbih4KTtcbiAgICAgIHkgPSB0aGlzLmFsaWduKHkpO1xuICAgICAgY2xpcEJCb3ggPSBjbGlwQkJveCAhPSBudWxsID8gbmV3IEJCb3goXG4gICAgICAgIHRoaXMuYWxpZ24oY2xpcEJCb3gueCksXG4gICAgICAgIHRoaXMuYWxpZ24oY2xpcEJCb3gueSksXG4gICAgICAgIHRoaXMuYWxpZ24oY2xpcEJCb3gueCwgY2xpcEJCb3gud2lkdGgpLFxuICAgICAgICB0aGlzLmFsaWduKGNsaXBCQm94LnksIGNsaXBCQm94LmhlaWdodClcbiAgICAgICkgOiB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChzdHJva2VXaWR0aCkge1xuICAgICAgaWYgKHcgPCBwaXhlbFNpemUpIHtcbiAgICAgICAgY29uc3QgbHggPSB4ICsgcGl4ZWxTaXplIC8gMjtcbiAgICAgICAgYm9yZGVyUGF0aC5tb3ZlVG8obHgsIHkpO1xuICAgICAgICBib3JkZXJQYXRoLmxpbmVUbyhseCwgeSArIGgpO1xuICAgICAgICBzdHJva2VXaWR0aCA9IHBpeGVsU2l6ZTtcbiAgICAgICAgdGhpcy5ib3JkZXJDbGlwUGF0aCA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSBpZiAoaCA8IHBpeGVsU2l6ZSkge1xuICAgICAgICBjb25zdCBseSA9IHkgKyBwaXhlbFNpemUgLyAyO1xuICAgICAgICBib3JkZXJQYXRoLm1vdmVUbyh4LCBseSk7XG4gICAgICAgIGJvcmRlclBhdGgubGluZVRvKHggKyB3LCBseSk7XG4gICAgICAgIHN0cm9rZVdpZHRoID0gcGl4ZWxTaXplO1xuICAgICAgICB0aGlzLmJvcmRlckNsaXBQYXRoID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIGlmIChzdHJva2VXaWR0aCA8IHcgJiYgc3Ryb2tlV2lkdGggPCBoKSB7XG4gICAgICAgIGNvbnN0IGhhbGZTdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoIC8gMjtcbiAgICAgICAgeCArPSBoYWxmU3Ryb2tlV2lkdGg7XG4gICAgICAgIHkgKz0gaGFsZlN0cm9rZVdpZHRoO1xuICAgICAgICB3IC09IHN0cm9rZVdpZHRoO1xuICAgICAgICBoIC09IHN0cm9rZVdpZHRoO1xuICAgICAgICBjb25zdCBhZGp1c3RlZENsaXBCQm94ID0gY2xpcEJCb3g/LmNsb25lKCkuc2hyaW5rKGhhbGZTdHJva2VXaWR0aCk7XG4gICAgICAgIGNvbnN0IGNvcm5lclJhZGlpID0ge1xuICAgICAgICAgIHRvcExlZnQ6IHRvcExlZnQgPiAwID8gdG9wTGVmdCAtIHN0cm9rZVdpZHRoIDogMCxcbiAgICAgICAgICB0b3BSaWdodDogdG9wUmlnaHQgPiAwID8gdG9wUmlnaHQgLSBzdHJva2VXaWR0aCA6IDAsXG4gICAgICAgICAgYm90dG9tUmlnaHQ6IGJvdHRvbVJpZ2h0ID4gMCA/IGJvdHRvbVJpZ2h0IC0gc3Ryb2tlV2lkdGggOiAwLFxuICAgICAgICAgIGJvdHRvbUxlZnQ6IGJvdHRvbUxlZnQgPiAwID8gYm90dG9tTGVmdCAtIHN0cm9rZVdpZHRoIDogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJvcmRlckNsaXBQYXRoID0gdm9pZCAwO1xuICAgICAgICBpZiAodyA+IDAgJiYgaCA+IDAgJiYgKGFkanVzdGVkQ2xpcEJCb3ggPT0gbnVsbCB8fCBhZGp1c3RlZENsaXBCQm94Py53aWR0aCA+IDAgJiYgYWRqdXN0ZWRDbGlwQkJveD8uaGVpZ2h0ID4gMCkpIHtcbiAgICAgICAgICBjbGlwcGVkUm91bmRSZWN0KHBhdGgsIHgsIHksIHcsIGgsIGNvcm5lclJhZGlpLCBhZGp1c3RlZENsaXBCQm94KTtcbiAgICAgICAgICBjbGlwcGVkUm91bmRSZWN0KGJvcmRlclBhdGgsIHgsIHksIHcsIGgsIGNvcm5lclJhZGlpLCBhZGp1c3RlZENsaXBCQm94KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib3JkZXJDbGlwUGF0aCA9IHRoaXMuYm9yZGVyQ2xpcFBhdGggPz8gbmV3IEV4dGVuZGVkUGF0aDJEKCk7XG4gICAgICAgIHRoaXMuYm9yZGVyQ2xpcFBhdGguY2xlYXIodHJ1ZSk7XG4gICAgICAgIHRoaXMuYm9yZGVyQ2xpcFBhdGgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgYm9yZGVyUGF0aC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb3JuZXJSYWRpaSA9IHsgdG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbVJpZ2h0LCBib3R0b21MZWZ0IH07XG4gICAgICB0aGlzLmJvcmRlckNsaXBQYXRoID0gdm9pZCAwO1xuICAgICAgY2xpcHBlZFJvdW5kUmVjdChwYXRoLCB4LCB5LCB3LCBoLCBjb3JuZXJSYWRpaSwgY2xpcEJCb3gpO1xuICAgIH1cbiAgICBpZiAoW3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdF0uZXZlcnkoKHIpID0+IHIgPT09IDApKSB7XG4gICAgICBjb25zdCBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgICB0aGlzLmhpdHRlc3RlciA9IGJib3guY29udGFpbnNQb2ludC5iaW5kKGJib3gpO1xuICAgICAgdGhpcy5kaXN0YW5jZVNxdWFyZWQgPSAoaGl0WCwgaGl0WSkgPT4gdGhpcy5nZXRCQm94KCkuZGlzdGFuY2VTcXVhcmVkKGhpdFgsIGhpdFkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpdHRlc3RlciA9IHN1cGVyLmlzUG9pbnRJblBhdGg7XG4gICAgICB0aGlzLmRpc3RhbmNlQ2FsY3VsYXRvciA9IHN1cGVyLmRpc3RhbmNlU3F1YXJlZFRyYW5zZm9ybWVkUG9pbnQ7XG4gICAgfVxuICAgIHRoaXMuZWZmZWN0aXZlU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICB0aGlzLmxhc3RVcGRhdGVQYXRoU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICB0aGlzLm1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5ID0gbWljcm9QaXhlbEVmZmVjdE9wYWNpdHk7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIsIGNsaXBCQm94IH0gPSB0aGlzO1xuICAgIHJldHVybiBjbGlwQkJveD8uY2xvbmUoKSA/PyBuZXcgQkJveCh4LCB5LCB3aWR0aDIsIGhlaWdodDIpO1xuICB9XG4gIGlzUG9pbnRJblBhdGgoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmhpdHRlc3Rlcih4LCB5KTtcbiAgfVxuICBnZXQgbWlkUG9pbnQoKSB7XG4gICAgcmV0dXJuIHsgeDogdGhpcy54ICsgdGhpcy53aWR0aCAvIDIsIHk6IHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMiB9O1xuICB9XG4gIGRpc3RhbmNlU3F1YXJlZCh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VDYWxjdWxhdG9yKHgsIHkpO1xuICB9XG4gIGFwcGx5RmlsbEFscGhhKGN0eCkge1xuICAgIGNvbnN0IHsgZmlsbE9wYWNpdHksIG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5LCBvcGFjaXR5IH0gPSB0aGlzO1xuICAgIGN0eC5nbG9iYWxBbHBoYSAqPSBvcGFjaXR5ICogZmlsbE9wYWNpdHkgKiBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eTtcbiAgfVxuICByZW5kZXJTdHJva2UoY3R4KSB7XG4gICAgY29uc3QgeyBzdHJva2U6IHN0cm9rZTIsIGVmZmVjdGl2ZVN0cm9rZVdpZHRoIH0gPSB0aGlzO1xuICAgIGlmIChzdHJva2UyICYmIGVmZmVjdGl2ZVN0cm9rZVdpZHRoKSB7XG4gICAgICBjb25zdCB7IGdsb2JhbEFscGhhIH0gPSBjdHg7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICAgIGxpbmVEYXNoLFxuICAgICAgICBsaW5lRGFzaE9mZnNldCxcbiAgICAgICAgbGluZUNhcCxcbiAgICAgICAgbGluZUpvaW4sXG4gICAgICAgIGJvcmRlclBhdGgsXG4gICAgICAgIGJvcmRlckNsaXBQYXRoLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eVxuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAoYm9yZGVyQ2xpcFBhdGgpIHtcbiAgICAgICAgY3R4LmNsaXAoYm9yZGVyQ2xpcFBhdGguZ2V0UGF0aDJEKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBseVN0cm9rZShjdHgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IG9wYWNpdHkgKiBzdHJva2VPcGFjaXR5ICogbWljcm9QaXhlbEVmZmVjdE9wYWNpdHk7XG4gICAgICBjdHgubGluZVdpZHRoID0gZWZmZWN0aXZlU3Ryb2tlV2lkdGg7XG4gICAgICBpZiAobGluZURhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lRGFzaE9mZnNldCkge1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lQ2FwKSB7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gbGluZUNhcDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lSm9pbikge1xuICAgICAgICBjdHgubGluZUpvaW4gPSBsaW5lSm9pbjtcbiAgICAgIH1cbiAgICAgIGN0eC5zdHJva2UoYm9yZGVyUGF0aC5nZXRQYXRoMkQoKSk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYTtcbiAgICB9XG4gIH1cbn07XG5SZWN0LmNsYXNzTmFtZSA9IFwiUmVjdFwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcInhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmVjdC5wcm90b3R5cGUsIFwieVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmVjdC5wcm90b3R5cGUsIFwidG9wTGVmdENvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJ0b3BSaWdodENvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJib3R0b21SaWdodENvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJib3R0b21MZWZ0Q29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcImNsaXBCQm94XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcImNyaXNwXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9iYWNrZ3JvdW5kL2JhY2tncm91bmQudHNcbnZhciBCYWNrZ3JvdW5kID0gY2xhc3MgZXh0ZW5kcyBCYXNlTW9kdWxlSW5zdGFuY2Uge1xuICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMucmVjdE5vZGUgPSBuZXcgUmVjdCgpO1xuICAgIHRoaXMudGV4dE5vZGUgPSBuZXcgVGV4dCgpO1xuICAgIHRoaXMuZmlsbCA9IFwid2hpdGVcIjtcbiAgICB0aGlzLm5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcbiAgICB0aGlzLm5vZGUuYXBwZW5kKFt0aGlzLnJlY3ROb2RlLCB0aGlzLnRleHROb2RlXSk7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIGN0eC5zY2VuZS5hdHRhY2hOb2RlKHRoaXMubm9kZSksXG4gICAgICBjdHgubGF5b3V0TWFuYWdlci5hZGRMaXN0ZW5lcihcImxheW91dDpjb21wbGV0ZVwiLCAoZSkgPT4gdGhpcy5vbkxheW91dENvbXBsZXRlKGUpKVxuICAgICk7XG4gIH1cbiAgY3JlYXRlTm9kZSgpIHtcbiAgICByZXR1cm4gbmV3IEdyb3VwKHsgbmFtZTogXCJiYWNrZ3JvdW5kXCIsIHpJbmRleDogMCAvKiBDSEFSVF9CQUNLR1JPVU5EICovIH0pO1xuICB9XG4gIG9uTGF5b3V0Q29tcGxldGUoZSkge1xuICAgIGNvbnN0IHsgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyIH0gPSBlLmNoYXJ0O1xuICAgIHRoaXMucmVjdE5vZGUud2lkdGggPSB3aWR0aDI7XG4gICAgdGhpcy5yZWN0Tm9kZS5oZWlnaHQgPSBoZWlnaHQyO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiLCBcInZpc2libGVcIilcbl0sIEJhY2tncm91bmQucHJvdG90eXBlLCBcInZpc2libGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwicmVjdE5vZGVcIiwgXCJmaWxsXCIpXG5dLCBCYWNrZ3JvdW5kLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYWNrZ3JvdW5kLnByb3RvdHlwZSwgXCJpbWFnZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJ0ZXh0Tm9kZVwiKVxuXSwgQmFja2dyb3VuZC5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYmFja2dyb3VuZC9iYWNrZ3JvdW5kTW9kdWxlLnRzXG52YXIgQmFja2dyb3VuZE1vZHVsZSA9IHtcbiAgdHlwZTogXCJyb290XCIsXG4gIG9wdGlvbnNLZXk6IFwiYmFja2dyb3VuZFwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiLCBcInN0YW5kYWxvbmVcIiwgXCJnYXVnZVwiXSxcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IEJhY2tncm91bmQoY3R4KVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZ3JpZExheW91dC50c1xuZnVuY3Rpb24gZ3JpZExheW91dCh7XG4gIG9yaWVudGF0aW9uLFxuICBiYm94ZXMsXG4gIG1heEhlaWdodCxcbiAgbWF4V2lkdGgsXG4gIGl0ZW1QYWRkaW5nWSA9IDAsXG4gIGl0ZW1QYWRkaW5nWCA9IDAsXG4gIGZvcmNlUmVzdWx0ID0gZmFsc2Vcbn0pIHtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgY29uc3QgcHJpbWFyeSA9IHtcbiAgICBtYXg6IGhvcml6b250YWwgPyBtYXhXaWR0aCA6IG1heEhlaWdodCxcbiAgICBmbjogaG9yaXpvbnRhbCA/IChiKSA9PiBiLndpZHRoIDogKGIpID0+IGIuaGVpZ2h0LFxuICAgIHBhZGRpbmc6IGhvcml6b250YWwgPyBpdGVtUGFkZGluZ1ggOiBpdGVtUGFkZGluZ1lcbiAgfTtcbiAgY29uc3Qgc2Vjb25kYXJ5ID0ge1xuICAgIG1heDogaG9yaXpvbnRhbCA/IG1heEhlaWdodCA6IG1heFdpZHRoLFxuICAgIGZuOiBob3Jpem9udGFsID8gKGIpID0+IGIuaGVpZ2h0IDogKGIpID0+IGIud2lkdGgsXG4gICAgcGFkZGluZzogaG9yaXpvbnRhbCA/IGl0ZW1QYWRkaW5nWSA6IGl0ZW1QYWRkaW5nWFxuICB9O1xuICBsZXQgcHJvY2Vzc2VkQkJveENvdW50ID0gMDtcbiAgY29uc3QgcmF3UGFnZXMgPSBbXTtcbiAgd2hpbGUgKHByb2Nlc3NlZEJCb3hDb3VudCA8IGJib3hlcy5sZW5ndGgpIHtcbiAgICBjb25zdCB1bnByb2Nlc3NlZEJCb3hlcyA9IGJib3hlcy5zbGljZShwcm9jZXNzZWRCQm94Q291bnQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3NCQm94ZXModW5wcm9jZXNzZWRCQm94ZXMsIHByb2Nlc3NlZEJCb3hDb3VudCwgcHJpbWFyeSwgc2Vjb25kYXJ5LCBmb3JjZVJlc3VsdCk7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJvY2Vzc2VkQkJveENvdW50ICs9IHJlc3VsdC5wcm9jZXNzZWRCQm94Q291bnQ7XG4gICAgcmF3UGFnZXMucHVzaChyZXN1bHQucGFnZUluZGljZXMpO1xuICB9XG4gIHJldHVybiBidWlsZFBhZ2VzKHJhd1BhZ2VzLCBvcmllbnRhdGlvbiwgYmJveGVzLCBpdGVtUGFkZGluZ1ksIGl0ZW1QYWRkaW5nWCk7XG59XG5mdW5jdGlvbiBwcm9jZXNzQkJveGVzKGJib3hlcywgaW5kZXhPZmZzZXQsIHByaW1hcnksIHNlY29uZGFyeSwgZm9yY2VSZXN1bHQpIHtcbiAgY29uc3QgbWluR3Vlc3MgPSAxO1xuICBsZXQgc3RhcnRpbmdHdWVzcyA9IGVzdGltYXRlU3RhcnRpbmdHdWVzcyhiYm94ZXMsIHByaW1hcnkpO1xuICBpZiAoc3RhcnRpbmdHdWVzcyA8IG1pbkd1ZXNzKSB7XG4gICAgaWYgKCFmb3JjZVJlc3VsdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGFydGluZ0d1ZXNzID0gbWluR3Vlc3M7XG4gIH1cbiAgbGV0IGd1ZXNzID0gc3RhcnRpbmdHdWVzcztcbiAgd2hpbGUgKGd1ZXNzID49IG1pbkd1ZXNzKSB7XG4gICAgY29uc3QgcGFnZUluZGljZXMgPSBjYWxjdWxhdGVQYWdlKGJib3hlcywgaW5kZXhPZmZzZXQsIGd1ZXNzLCBwcmltYXJ5LCBzZWNvbmRhcnksIGZvcmNlUmVzdWx0KTtcbiAgICBpZiAocGFnZUluZGljZXMgPT0gbnVsbCAmJiBndWVzcyA8PSBtaW5HdWVzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGFnZUluZGljZXMgPT0gbnVsbCkge1xuICAgICAgZ3Vlc3MtLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhZ2VJbmRpY2VzID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAocGFnZUluZGljZXMgPD0gbWluR3Vlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZ3Vlc3MgPSBwYWdlSW5kaWNlcyA8IGd1ZXNzICYmIHBhZ2VJbmRpY2VzID4gbWluR3Vlc3MgPyBwYWdlSW5kaWNlcyA6IGd1ZXNzO1xuICAgICAgZ3Vlc3MtLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBwcm9jZXNzZWRCQm94Q291bnQgPSBwYWdlSW5kaWNlcy5sZW5ndGggKiBwYWdlSW5kaWNlc1swXS5sZW5ndGg7XG4gICAgcmV0dXJuIHsgcHJvY2Vzc2VkQkJveENvdW50LCBwYWdlSW5kaWNlcyB9O1xuICB9XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVQYWdlKGJib3hlcywgaW5kZXhPZmZzZXQsIHByaW1hcnlDb3VudCwgcHJpbWFyeSwgc2Vjb25kYXJ5LCBmb3JjZVJlc3VsdCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IHN1bVNlY29uZGFyeSA9IDA7XG4gIGxldCBjdXJyZW50TWF4U2Vjb25kYXJ5ID0gMDtcbiAgbGV0IGN1cnJlbnRQcmltYXJ5SW5kaWNlcyA9IFtdO1xuICBjb25zdCBtYXhQcmltYXJ5VmFsdWVzID0gW107XG4gIGZvciAobGV0IGJib3hJbmRleCA9IDA7IGJib3hJbmRleCA8IGJib3hlcy5sZW5ndGg7IGJib3hJbmRleCsrKSB7XG4gICAgY29uc3QgcHJpbWFyeVZhbHVlSWR4ID0gKGJib3hJbmRleCArIHByaW1hcnlDb3VudCkgJSBwcmltYXJ5Q291bnQ7XG4gICAgaWYgKHByaW1hcnlWYWx1ZUlkeCA9PT0gMCkge1xuICAgICAgc3VtU2Vjb25kYXJ5ICs9IGN1cnJlbnRNYXhTZWNvbmRhcnk7XG4gICAgICBjdXJyZW50TWF4U2Vjb25kYXJ5ID0gMDtcbiAgICAgIGlmIChjdXJyZW50UHJpbWFyeUluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQucHVzaChjdXJyZW50UHJpbWFyeUluZGljZXMpO1xuICAgICAgfVxuICAgICAgY3VycmVudFByaW1hcnlJbmRpY2VzID0gW107XG4gICAgfVxuICAgIGNvbnN0IHByaW1hcnlWYWx1ZSA9IHByaW1hcnkuZm4oYmJveGVzW2Jib3hJbmRleF0pICsgcHJpbWFyeS5wYWRkaW5nO1xuICAgIG1heFByaW1hcnlWYWx1ZXNbcHJpbWFyeVZhbHVlSWR4XSA9IE1hdGgubWF4KG1heFByaW1hcnlWYWx1ZXNbcHJpbWFyeVZhbHVlSWR4XSA/PyAwLCBwcmltYXJ5VmFsdWUpO1xuICAgIGN1cnJlbnRNYXhTZWNvbmRhcnkgPSBNYXRoLm1heChjdXJyZW50TWF4U2Vjb25kYXJ5LCBzZWNvbmRhcnkuZm4oYmJveGVzW2Jib3hJbmRleF0pICsgc2Vjb25kYXJ5LnBhZGRpbmcpO1xuICAgIGNvbnN0IGN1cnJlbnRTZWNvbmRhcnlEaW1lbnNpb24gPSBzdW1TZWNvbmRhcnkgKyBjdXJyZW50TWF4U2Vjb25kYXJ5O1xuICAgIGNvbnN0IHJldHVyblJlc3VsdCA9ICFmb3JjZVJlc3VsdCB8fCByZXN1bHQubGVuZ3RoID4gMDtcbiAgICBpZiAoY3VycmVudFNlY29uZGFyeURpbWVuc2lvbiA+IHNlY29uZGFyeS5tYXggJiYgcmV0dXJuUmVzdWx0KSB7XG4gICAgICBjdXJyZW50UHJpbWFyeUluZGljZXMgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBzdW1QcmltYXJ5ID0gbWF4UHJpbWFyeVZhbHVlcy5yZWR1Y2UoKHN1bTIsIG5leHQpID0+IHN1bTIgKyBuZXh0LCAwKTtcbiAgICBpZiAoc3VtUHJpbWFyeSA+IHByaW1hcnkubWF4ICYmICFmb3JjZVJlc3VsdCkge1xuICAgICAgaWYgKG1heFByaW1hcnlWYWx1ZXMubGVuZ3RoIDwgcHJpbWFyeUNvdW50KSB7XG4gICAgICAgIHJldHVybiBtYXhQcmltYXJ5VmFsdWVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VycmVudFByaW1hcnlJbmRpY2VzLnB1c2goYmJveEluZGV4ICsgaW5kZXhPZmZzZXQpO1xuICB9XG4gIGlmIChjdXJyZW50UHJpbWFyeUluZGljZXMubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRQcmltYXJ5SW5kaWNlcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPiAwID8gcmVzdWx0IDogdm9pZCAwO1xufVxuZnVuY3Rpb24gYnVpbGRQYWdlcyhyYXdQYWdlcywgb3JpZW50YXRpb24sIGJib3hlcywgaXRlbVBhZGRpbmdZLCBpdGVtUGFkZGluZ1gpIHtcbiAgbGV0IG1heFBhZ2VXaWR0aCA9IDA7XG4gIGxldCBtYXhQYWdlSGVpZ2h0ID0gMDtcbiAgY29uc3QgcGFnZXMgPSByYXdQYWdlcy5tYXAoKGluZGljZXMpID0+IHtcbiAgICBpZiAob3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICBpbmRpY2VzID0gdHJhbnNwb3NlKGluZGljZXMpO1xuICAgIH1cbiAgICBsZXQgZW5kSW5kZXggPSAwO1xuICAgIGNvbnN0IGNvbHVtbnMgPSBpbmRpY2VzLm1hcCgoY29sSW5kaWNlcykgPT4ge1xuICAgICAgY29uc3QgY29sQkJveGVzID0gY29sSW5kaWNlcy5tYXAoKGJib3hJbmRleCkgPT4ge1xuICAgICAgICBlbmRJbmRleCA9IE1hdGgubWF4KGJib3hJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgICByZXR1cm4gYmJveGVzW2Jib3hJbmRleF07XG4gICAgICB9KTtcbiAgICAgIGxldCBjb2x1bW5IZWlnaHQgPSAwO1xuICAgICAgbGV0IGNvbHVtbldpZHRoID0gMDtcbiAgICAgIGNvbEJCb3hlcy5mb3JFYWNoKChiYm94KSA9PiB7XG4gICAgICAgIGNvbHVtbkhlaWdodCArPSBiYm94LmhlaWdodCArIGl0ZW1QYWRkaW5nWTtcbiAgICAgICAgY29sdW1uV2lkdGggPSBNYXRoLm1heChjb2x1bW5XaWR0aCwgYmJveC53aWR0aCArIGl0ZW1QYWRkaW5nWCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGljZXM6IGNvbEluZGljZXMsXG4gICAgICAgIGJib3hlczogY29sQkJveGVzLFxuICAgICAgICBjb2x1bW5IZWlnaHQ6IE1hdGguY2VpbChjb2x1bW5IZWlnaHQpLFxuICAgICAgICBjb2x1bW5XaWR0aDogTWF0aC5jZWlsKGNvbHVtbldpZHRoKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBsZXQgcGFnZVdpZHRoID0gMDtcbiAgICBsZXQgcGFnZUhlaWdodCA9IDA7XG4gICAgY29sdW1ucy5mb3JFYWNoKChjb2x1bW4pID0+IHtcbiAgICAgIHBhZ2VXaWR0aCArPSBjb2x1bW4uY29sdW1uV2lkdGg7XG4gICAgICBwYWdlSGVpZ2h0ID0gTWF0aC5tYXgocGFnZUhlaWdodCwgY29sdW1uLmNvbHVtbkhlaWdodCk7XG4gICAgfSk7XG4gICAgbWF4UGFnZVdpZHRoID0gTWF0aC5tYXgocGFnZVdpZHRoLCBtYXhQYWdlV2lkdGgpO1xuICAgIG1heFBhZ2VIZWlnaHQgPSBNYXRoLm1heChwYWdlSGVpZ2h0LCBtYXhQYWdlSGVpZ2h0KTtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1ucyxcbiAgICAgIHN0YXJ0SW5kZXg6IGluZGljZXNbMF1bMF0sXG4gICAgICBlbmRJbmRleCxcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHsgcGFnZXMsIG1heFBhZ2VXaWR0aCwgbWF4UGFnZUhlaWdodCB9O1xufVxuZnVuY3Rpb24gdHJhbnNwb3NlKGRhdGEpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAoY29uc3QgXyBvZiBkYXRhWzBdKSB7XG4gICAgcmVzdWx0LnB1c2goW10pO1xuICB9XG4gIGRhdGEuZm9yRWFjaCgoaW5uZXJEYXRhLCBkYXRhSWR4KSA9PiB7XG4gICAgaW5uZXJEYXRhLmZvckVhY2goKGl0ZW0sIGl0ZW1JZHgpID0+IHtcbiAgICAgIHJlc3VsdFtpdGVtSWR4XVtkYXRhSWR4XSA9IGl0ZW07XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZXN0aW1hdGVTdGFydGluZ0d1ZXNzKGJib3hlcywgcHJpbWFyeSkge1xuICBjb25zdCBuID0gYmJveGVzLmxlbmd0aDtcbiAgbGV0IHByaW1hcnlTdW0gPSAwO1xuICBmb3IgKGxldCBiYm94SW5kZXggPSAwOyBiYm94SW5kZXggPCBuOyBiYm94SW5kZXgrKykge1xuICAgIHByaW1hcnlTdW0gKz0gcHJpbWFyeS5mbihiYm94ZXNbYmJveEluZGV4XSkgKyBwcmltYXJ5LnBhZGRpbmc7XG4gICAgaWYgKHByaW1hcnlTdW0gPiBwcmltYXJ5Lm1heCkge1xuICAgICAgY29uc3QgcmF0aW8yID0gbiAvIGJib3hJbmRleDtcbiAgICAgIGlmIChyYXRpbzIgPCAyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobiAvIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJib3hJbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3BhZ2luYXRpb24vcGFnaW5hdGlvbi50c1xudmFyIFBhZ2luYXRpb25MYWJlbCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuY29sb3IgPSBcImJsYWNrXCI7XG4gICAgdGhpcy5mb250U3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5mb250V2VpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udFNpemUgPSAxMjtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBcIlZlcmRhbmEsIHNhbnMtc2VyaWZcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIFBhZ2luYXRpb25MYWJlbC5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1NUWUxFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQYWdpbmF0aW9uTGFiZWwucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfV0VJR0hULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQYWdpbmF0aW9uTGFiZWwucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQYWdpbmF0aW9uTGFiZWwucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgUGFnaW5hdGlvbkxhYmVsLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xudmFyIFBhZ2luYXRpb25NYXJrZXJTdHlsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc2l6ZSA9IDE1O1xuICAgIHRoaXMuZmlsbCA9IHZvaWQgMDtcbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gdm9pZCAwO1xuICAgIHRoaXMuc3Ryb2tlID0gdm9pZCAwO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQYWdpbmF0aW9uTWFya2VyU3R5bGUucHJvdG90eXBlLCBcInNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBhZ2luYXRpb25NYXJrZXJTdHlsZS5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQYWdpbmF0aW9uTWFya2VyU3R5bGUucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQYWdpbmF0aW9uTWFya2VyU3R5bGUucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBhZ2luYXRpb25NYXJrZXJTdHlsZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIFBhZ2luYXRpb25NYXJrZXJTdHlsZS5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbnZhciBQYWdpbmF0aW9uTWFya2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5zaGFwZSA9IFwidHJpYW5nbGVcIjtcbiAgICB0aGlzLnNpemUgPSAxNTtcbiAgICB0aGlzLnBhZGRpbmcgPSA4O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIGNoYW5nZVZhbHVlKCkge1xuICAgICAgaWYgKHRoaXMucGFyZW50Lm1hcmtlciA9PT0gdGhpcykge1xuICAgICAgICB0aGlzLnBhcmVudC5vbk1hcmtlclNoYXBlQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KVxuXSwgUGFnaW5hdGlvbk1hcmtlci5wcm90b3R5cGUsIFwic2hhcGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQYWdpbmF0aW9uTWFya2VyLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFnaW5hdGlvbk1hcmtlci5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCAyKTtcbnZhciBQYWdpbmF0aW9uID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0VXBkYXRlQ2FsbGJhY2ssIHBhZ2VVcGRhdGVDYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jaGFydFVwZGF0ZUNhbGxiYWNrID0gY2hhcnRVcGRhdGVDYWxsYmFjaztcbiAgICB0aGlzLnBhZ2VVcGRhdGVDYWxsYmFjayA9IHBhZ2VVcGRhdGVDYWxsYmFjaztcbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5tYXJrZXIgPSBuZXcgUGFnaW5hdGlvbk1hcmtlcih0aGlzKTtcbiAgICB0aGlzLmFjdGl2ZVN0eWxlID0gbmV3IFBhZ2luYXRpb25NYXJrZXJTdHlsZSgpO1xuICAgIHRoaXMuaW5hY3RpdmVTdHlsZSA9IG5ldyBQYWdpbmF0aW9uTWFya2VyU3R5bGUoKTtcbiAgICB0aGlzLmhpZ2hsaWdodFN0eWxlID0gbmV3IFBhZ2luYXRpb25NYXJrZXJTdHlsZSgpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgUGFnaW5hdGlvbkxhYmVsKCk7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBUcmFuc2xhdGFibGVHcm91cCh7IG5hbWU6IFwicGFnaW5hdGlvblwiIH0pO1xuICAgIHRoaXMubGFiZWxOb2RlID0gbmV3IFRleHQoKTtcbiAgICB0aGlzLnRvdGFsUGFnZXMgPSAwO1xuICAgIHRoaXMuY3VycmVudFBhZ2UgPSAwO1xuICAgIHRoaXMudHJhbnNsYXRpb25YID0gMDtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWSA9IDA7XG4gICAgdGhpcy5uZXh0QnV0dG9uRGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnByZXZpb3VzQnV0dG9uRGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9vcmllbnRhdGlvbiA9IFwidmVydGljYWxcIjtcbiAgICB0aGlzLm5leHRCdXR0b24gPSBuZXcgTWFya2VyKCk7XG4gICAgdGhpcy5wcmV2aW91c0J1dHRvbiA9IG5ldyBNYXJrZXIoKTtcbiAgICB0aGlzLmxhYmVsTm9kZS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgIHRleHRCYXNlbGluZTogXCJtaWRkbGVcIixcbiAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgIGZvbnRGYW1pbHk6IFwiVmVyZGFuYSwgc2Fucy1zZXJpZlwiLFxuICAgICAgZmlsbDogXCJibGFja1wiLFxuICAgICAgeTogMVxuICAgIH0pO1xuICAgIHRoaXMuZ3JvdXAuYXBwZW5kKFt0aGlzLm5leHRCdXR0b24sIHRoaXMucHJldmlvdXNCdXR0b24sIHRoaXMubGFiZWxOb2RlXSk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICB0aGlzLnVwZGF0ZU1hcmtlcnMoKTtcbiAgfVxuICBzZXQgdmlzaWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpO1xuICB9XG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG4gIHNldCBlbmFibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5fZW5hYmxlZCA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCk7XG4gIH1cbiAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gIH1cbiAgdXBkYXRlR3JvdXBWaXNpYmlsaXR5KCkge1xuICAgIHRoaXMuZ3JvdXAudmlzaWJsZSA9IHRoaXMuZW5hYmxlZCAmJiB0aGlzLnZpc2libGU7XG4gIH1cbiAgc2V0IG9yaWVudGF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fb3JpZW50YXRpb24gPSB2YWx1ZTtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOiB7XG4gICAgICAgIHRoaXMucHJldmlvdXNCdXR0b24ucm90YXRpb24gPSAtTWF0aC5QSSAvIDI7XG4gICAgICAgIHRoaXMubmV4dEJ1dHRvbi5yb3RhdGlvbiA9IE1hdGguUEkgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aGlzLnByZXZpb3VzQnV0dG9uLnJvdGF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5uZXh0QnV0dG9uLnJvdGF0aW9uID0gTWF0aC5QSTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IG9yaWVudGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbjtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy51cGRhdGVMYWJlbCgpO1xuICAgIHRoaXMudXBkYXRlUG9zaXRpb25zKCk7XG4gICAgdGhpcy5lbmFibGVPckRpc2FibGVCdXR0b25zKCk7XG4gIH1cbiAgdXBkYXRlUG9zaXRpb25zKCkge1xuICAgIHRoaXMuZ3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy50cmFuc2xhdGlvblg7XG4gICAgdGhpcy5ncm91cC50cmFuc2xhdGlvblkgPSB0aGlzLnRyYW5zbGF0aW9uWTtcbiAgICB0aGlzLnVwZGF0ZUxhYmVsUG9zaXRpb24oKTtcbiAgICB0aGlzLnVwZGF0ZU5leHRCdXR0b25Qb3NpdGlvbigpO1xuICB9XG4gIHVwZGF0ZUxhYmVsUG9zaXRpb24oKSB7XG4gICAgY29uc3QgeyBzaXplOiBtYXJrZXJTaXplLCBwYWRkaW5nOiBtYXJrZXJQYWRkaW5nIH0gPSB0aGlzLm1hcmtlcjtcbiAgICB0aGlzLm5leHRCdXR0b24uc2l6ZSA9IG1hcmtlclNpemU7XG4gICAgdGhpcy5wcmV2aW91c0J1dHRvbi5zaXplID0gbWFya2VyU2l6ZTtcbiAgICB0aGlzLmxhYmVsTm9kZS54ID0gbWFya2VyU2l6ZSAvIDIgKyBtYXJrZXJQYWRkaW5nO1xuICB9XG4gIHVwZGF0ZU5leHRCdXR0b25Qb3NpdGlvbigpIHtcbiAgICBjb25zdCBsYWJlbEJCb3ggPSB0aGlzLmxhYmVsTm9kZS5nZXRCQm94KCk7XG4gICAgdGhpcy5uZXh0QnV0dG9uLnRyYW5zbGF0aW9uWCA9IGxhYmVsQkJveC53aWR0aCArICh0aGlzLm1hcmtlci5zaXplIC8gMiArIHRoaXMubWFya2VyLnBhZGRpbmcpICogMjtcbiAgfVxuICB1cGRhdGVMYWJlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50UGFnZSxcbiAgICAgIHRvdGFsUGFnZXM6IHBhZ2VzLFxuICAgICAgbGFiZWxOb2RlLFxuICAgICAgbGFiZWw6IHsgY29sb3IsIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHkgfVxuICAgIH0gPSB0aGlzO1xuICAgIGxhYmVsTm9kZS50ZXh0ID0gYCR7Y3VycmVudFBhZ2UgKyAxfSAvICR7cGFnZXN9YDtcbiAgICBsYWJlbE5vZGUuZmlsbCA9IGNvbG9yO1xuICAgIGxhYmVsTm9kZS5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgbGFiZWxOb2RlLmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgIGxhYmVsTm9kZS5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgIGxhYmVsTm9kZS5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgfVxuICB1cGRhdGVNYXJrZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5leHRCdXR0b24sXG4gICAgICBwcmV2aW91c0J1dHRvbixcbiAgICAgIG5leHRCdXR0b25EaXNhYmxlZCxcbiAgICAgIHByZXZpb3VzQnV0dG9uRGlzYWJsZWQsXG4gICAgICBhY3RpdmVTdHlsZSxcbiAgICAgIGluYWN0aXZlU3R5bGUsXG4gICAgICBoaWdobGlnaHRTdHlsZSxcbiAgICAgIGhpZ2hsaWdodEFjdGl2ZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGJ1dHRvblN0eWxlID0gKGJ1dHRvbiwgZGlzYWJsZWQpID0+IHtcbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gaW5hY3RpdmVTdHlsZTtcbiAgICAgIH0gZWxzZSBpZiAoYnV0dG9uID09PSBoaWdobGlnaHRBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGhpZ2hsaWdodFN0eWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGl2ZVN0eWxlO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVNYXJrZXIobmV4dEJ1dHRvbiwgYnV0dG9uU3R5bGUoXCJuZXh0XCIsIG5leHRCdXR0b25EaXNhYmxlZCkpO1xuICAgIHRoaXMudXBkYXRlTWFya2VyKHByZXZpb3VzQnV0dG9uLCBidXR0b25TdHlsZShcInByZXZpb3VzXCIsIHByZXZpb3VzQnV0dG9uRGlzYWJsZWQpKTtcbiAgfVxuICB1cGRhdGVNYXJrZXIobWFya2VyLCBzdHlsZSkge1xuICAgIGNvbnN0IHsgc2hhcGUsIHNpemUgfSA9IHRoaXMubWFya2VyO1xuICAgIG1hcmtlci5zaGFwZSA9IHNoYXBlO1xuICAgIG1hcmtlci5zaXplID0gc2l6ZTtcbiAgICBtYXJrZXIuZmlsbCA9IHN0eWxlLmZpbGw7XG4gICAgbWFya2VyLmZpbGxPcGFjaXR5ID0gc3R5bGUuZmlsbE9wYWNpdHkgPz8gMTtcbiAgICBtYXJrZXIuc3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuICAgIG1hcmtlci5zdHJva2VXaWR0aCA9IHN0eWxlLnN0cm9rZVdpZHRoO1xuICAgIG1hcmtlci5zdHJva2VPcGFjaXR5ID0gc3R5bGUuc3Ryb2tlT3BhY2l0eTtcbiAgfVxuICBlbmFibGVPckRpc2FibGVCdXR0b25zKCkge1xuICAgIGNvbnN0IHsgY3VycmVudFBhZ2UsIHRvdGFsUGFnZXMgfSA9IHRoaXM7XG4gICAgY29uc3QgemVyb1BhZ2VzVG9EaXNwbGF5ID0gdG90YWxQYWdlcyA9PT0gMDtcbiAgICBjb25zdCBvbkxhc3RQYWdlID0gY3VycmVudFBhZ2UgPT09IHRvdGFsUGFnZXMgLSAxO1xuICAgIGNvbnN0IG9uRmlyc3RQYWdlID0gY3VycmVudFBhZ2UgPT09IDA7XG4gICAgdGhpcy5uZXh0QnV0dG9uRGlzYWJsZWQgPSBvbkxhc3RQYWdlIHx8IHplcm9QYWdlc1RvRGlzcGxheTtcbiAgICB0aGlzLnByZXZpb3VzQnV0dG9uRGlzYWJsZWQgPSBvbkZpcnN0UGFnZSB8fCB6ZXJvUGFnZXNUb0Rpc3BsYXk7XG4gIH1cbiAgc2V0UGFnZShwYWdlTnVtYmVyKSB7XG4gICAgcGFnZU51bWJlciA9IGNsYW1wKDAsIHBhZ2VOdW1iZXIsIE1hdGgubWF4KDAsIHRoaXMudG90YWxQYWdlcyAtIDEpKTtcbiAgICBpZiAodGhpcy5jdXJyZW50UGFnZSAhPT0gcGFnZU51bWJlcikge1xuICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IHBhZ2VOdW1iZXI7XG4gICAgICB0aGlzLm9uUGFnaW5hdGlvbkNoYW5nZWQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0Q3Vyc29yKG5vZGUpIHtcbiAgICByZXR1cm4geyBwcmV2aW91czogdGhpcy5wcmV2aW91c0J1dHRvbkRpc2FibGVkLCBuZXh0OiB0aGlzLm5leHRCdXR0b25EaXNhYmxlZCB9W25vZGVdID8gdm9pZCAwIDogXCJwb2ludGVyXCI7XG4gIH1cbiAgb25DbGljayhldmVudCwgbm9kZSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKG5vZGUgPT09IFwibmV4dFwiICYmICF0aGlzLm5leHRCdXR0b25EaXNhYmxlZCkge1xuICAgICAgdGhpcy5pbmNyZW1lbnRQYWdlKCk7XG4gICAgICB0aGlzLm9uUGFnaW5hdGlvbkNoYW5nZWQoKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUgPT09IFwicHJldmlvdXNcIiAmJiAhdGhpcy5wcmV2aW91c0J1dHRvbkRpc2FibGVkKSB7XG4gICAgICB0aGlzLmRlY3JlbWVudFBhZ2UoKTtcbiAgICAgIHRoaXMub25QYWdpbmF0aW9uQ2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICBvbk1vdXNlSG92ZXIobm9kZSkge1xuICAgIHRoaXMuaGlnaGxpZ2h0QWN0aXZlID0gbm9kZTtcbiAgICB0aGlzLnVwZGF0ZU1hcmtlcnMoKTtcbiAgICB0aGlzLmNoYXJ0VXBkYXRlQ2FsbGJhY2soNiAvKiBTQ0VORV9SRU5ERVIgKi8pO1xuICB9XG4gIG9uUGFnaW5hdGlvbkNoYW5nZWQoKSB7XG4gICAgdGhpcy5wYWdlVXBkYXRlQ2FsbGJhY2sodGhpcy5jdXJyZW50UGFnZSk7XG4gIH1cbiAgaW5jcmVtZW50UGFnZSgpIHtcbiAgICB0aGlzLmN1cnJlbnRQYWdlID0gTWF0aC5taW4odGhpcy5jdXJyZW50UGFnZSArIDEsIHRoaXMudG90YWxQYWdlcyAtIDEpO1xuICB9XG4gIGRlY3JlbWVudFBhZ2UoKSB7XG4gICAgdGhpcy5jdXJyZW50UGFnZSA9IE1hdGgubWF4KHRoaXMuY3VycmVudFBhZ2UgLSAxLCAwKTtcbiAgfVxuICBvbk1hcmtlclNoYXBlQ2hhbmdlKCkge1xuICAgIHRoaXMudXBkYXRlUG9zaXRpb25zKCk7XG4gICAgdGhpcy51cGRhdGVNYXJrZXJzKCk7XG4gICAgdGhpcy5jaGFydFVwZGF0ZUNhbGxiYWNrKDYgLyogU0NFTkVfUkVOREVSICovKTtcbiAgfVxuICBhdHRhY2hQYWdpbmF0aW9uKG5vZGUpIHtcbiAgICBub2RlLmFwcGVuZCh0aGlzLmdyb3VwKTtcbiAgfVxuICBnZXRCQm94KCkge1xuICAgIHJldHVybiB0aGlzLmdyb3VwLmdldEJCb3goKTtcbiAgfVxuICBjb21wdXRlQ1NTQm91bmRzKCkge1xuICAgIGNvbnN0IHByZXYgPSBUcmFuc2Zvcm1hYmxlLnRvQ2FudmFzKHRoaXMucHJldmlvdXNCdXR0b24pO1xuICAgIGNvbnN0IG5leHQgPSBUcmFuc2Zvcm1hYmxlLnRvQ2FudmFzKHRoaXMubmV4dEJ1dHRvbik7XG4gICAgcmV0dXJuIHsgcHJldiwgbmV4dCB9O1xuICB9XG59O1xuUGFnaW5hdGlvbi5jbGFzc05hbWUgPSBcIlBhZ2luYXRpb25cIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBhZ2luYXRpb24ucHJvdG90eXBlLCBcIm1hcmtlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBhZ2luYXRpb24ucHJvdG90eXBlLCBcImFjdGl2ZVN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGFnaW5hdGlvbi5wcm90b3R5cGUsIFwiaW5hY3RpdmVTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBhZ2luYXRpb24ucHJvdG90eXBlLCBcImhpZ2hsaWdodFN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGFnaW5hdGlvbi5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3V0aWwvY2hhbmdlRGV0ZWN0YWJsZVByb3BlcnRpZXMudHNcbnZhciBDaGFuZ2VEZXRlY3RhYmxlUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgfVxuICBtYXJrRGlydHkoKSB7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICB9XG4gIG1hcmtDbGVhbihfb3B0cykge1xuICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gIH1cbiAgaXNEaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlydHk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci91dGlsLnRzXG52YXIgTUFSS0VSX1NVUFBPUlRFRF9TSEFQRVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiY2lyY2xlXCIsXG4gIFwiY3Jvc3NcIixcbiAgXCJkaWFtb25kXCIsXG4gIFwiaGVhcnRcIixcbiAgXCJwaW5cIixcbiAgXCJwbHVzXCIsXG4gIFwic3F1YXJlXCIsXG4gIFwic3RhclwiLFxuICBcInRyaWFuZ2xlXCJcbl0pO1xuZnVuY3Rpb24gaXNTdXBwb3J0ZWRNYXJrZXJTaGFwZShzaGFwZSkge1xuICByZXR1cm4gdHlwZW9mIHNoYXBlID09PSBcInN0cmluZ1wiICYmIE1BUktFUl9TVVBQT1JURURfU0hBUEVTLmhhcyhzaGFwZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNNYXJrZXIudHNcbnZhciBNQVJLRVJfU0hBUEUgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgKHZhbHVlKSA9PiBpc1N1cHBvcnRlZE1hcmtlclNoYXBlKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIixcbiAgYGEgbWFya2VyIHNoYXBlIGtleXdvcmQgc3VjaCBhcyAnY2lyY2xlJywgJ2RpYW1vbmQnIG9yICdzcXVhcmUnIG9yIGFuIG9iamVjdCBleHRlbmRpbmcgdGhlIE1hcmtlciBjbGFzc2Bcbik7XG52YXIgU2VyaWVzTWFya2VyID0gY2xhc3MgZXh0ZW5kcyBDaGFuZ2VEZXRlY3RhYmxlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnNoYXBlID0gXCJjaXJjbGVcIjtcbiAgICB0aGlzLnNpemUgPSA2O1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5saW5lRGFzaCA9IFswXTtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgfVxuICBnZXRTdHlsZSgpIHtcbiAgICBjb25zdCB7IHNpemUsIHNoYXBlLCBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlOiBzdHJva2UyLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSwgbGluZURhc2gsIGxpbmVEYXNoT2Zmc2V0IH0gPSB0aGlzO1xuICAgIHJldHVybiB7IHNpemUsIHNoYXBlLCBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlOiBzdHJva2UyLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSwgbGluZURhc2gsIGxpbmVEYXNoT2Zmc2V0IH07XG4gIH1cbiAgZ2V0RGlhbWV0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSArIHRoaXMuc3Ryb2tlV2lkdGg7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTUFSS0VSX1NIQVBFKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJzaGFwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwic2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTyksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExJTkVfREFTSClcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwiaXRlbVN0eWxlclwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3NoYXBlVXRpbC50c1xuZnVuY3Rpb24gYXBwbHlTaGFwZVN0eWxlKHNoYXBlLCBzdHlsZSwgb3ZlcnJpZGVzKSB7XG4gIHNoYXBlLmZpbGwgPSBvdmVycmlkZXM/LmZpbGwgPz8gc3R5bGUuZmlsbDtcbiAgc2hhcGUuZmlsbE9wYWNpdHkgPSBvdmVycmlkZXM/LmZpbGxPcGFjaXR5ID8/IHN0eWxlLmZpbGxPcGFjaXR5ID8/IDE7XG4gIHNoYXBlLnN0cm9rZSA9IG92ZXJyaWRlcz8uc3Ryb2tlID8/IHN0eWxlLnN0cm9rZTtcbiAgc2hhcGUuc3Ryb2tlT3BhY2l0eSA9IG92ZXJyaWRlcz8uc3Ryb2tlT3BhY2l0eSA/PyBzdHlsZS5zdHJva2VPcGFjaXR5ID8/IDE7XG4gIHNoYXBlLnN0cm9rZVdpZHRoID0gb3ZlcnJpZGVzPy5zdHJva2VXaWR0aCA/PyBzdHlsZS5zdHJva2VXaWR0aCA/PyAwO1xuICBzaGFwZS5saW5lRGFzaCA9IG92ZXJyaWRlcz8ubGluZURhc2ggPz8gc3R5bGUubGluZURhc2g7XG4gIHNoYXBlLmxpbmVEYXNoT2Zmc2V0ID0gb3ZlcnJpZGVzPy5saW5lRGFzaE9mZnNldCA/PyBzdHlsZS5saW5lRGFzaE9mZnNldCA/PyAwO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sZWdlbmQvbGVnZW5kRE9NUHJveHkudHNcbnZhciBMZWdlbmRET01Qcm94eSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY3R4LCBpZFByZWZpeCkge1xuICAgIHRoaXMuaWRQcmVmaXggPSBpZFByZWZpeDtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBuZXcgRGVzdHJveUZucygpO1xuICAgIHRoaXMuaXRlbUxpc3QgPSBjdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlDb250YWluZXIoe1xuICAgICAgdHlwZTogXCJsaXN0XCIsXG4gICAgICBkb21NYW5hZ2VySWQ6IGAke2lkUHJlZml4fS10b29sYmFyYCxcbiAgICAgIGNsYXNzTGlzdDogW1wiYWctY2hhcnRzLXByb3h5LWxlZ2VuZC10b29sYmFyXCJdLFxuICAgICAgYXJpYUxhYmVsOiB7IGlkOiBcImFyaWFMYWJlbExlZ2VuZFwiIH1cbiAgICB9KTtcbiAgICB0aGlzLnBhZ2luYXRpb25Hcm91cCA9IGN0eC5wcm94eUludGVyYWN0aW9uU2VydmljZS5jcmVhdGVQcm94eUNvbnRhaW5lcih7XG4gICAgICB0eXBlOiBcImdyb3VwXCIsXG4gICAgICBkb21NYW5hZ2VySWQ6IGAke2lkUHJlZml4fS1wYWdpbmF0aW9uYCxcbiAgICAgIGNsYXNzTGlzdDogW1wiYWctY2hhcnRzLXByb3h5LWxlZ2VuZC1wYWdpbmF0aW9uXCJdLFxuICAgICAgYXJpYUxhYmVsOiB7IGlkOiBcImFyaWFMYWJlbExlZ2VuZFBhZ2luYXRpb25cIiB9LFxuICAgICAgYXJpYU9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIlxuICAgIH0pO1xuICAgIHRoaXMuaXRlbURlc2NyaXB0aW9uID0gY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgdGhpcy5pdGVtRGVzY3JpcHRpb24uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIHRoaXMuaXRlbURlc2NyaXB0aW9uLmlkID0gYCR7aWRQcmVmaXh9LWFyaWFEZXNjcmlwdGlvbmA7XG4gICAgdGhpcy5pdGVtRGVzY3JpcHRpb24udGV4dENvbnRlbnQgPSB0aGlzLmdldEl0ZW1BcmlhRGVzY3JpcHRpb24oY3R4LmxvY2FsZU1hbmFnZXIpO1xuICAgIHRoaXMuaXRlbUxpc3QuZ2V0RWxlbWVudCgpLmFwcGVuZCh0aGlzLml0ZW1EZXNjcmlwdGlvbik7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZGVzdHJveSgpO1xuICB9XG4gIGluaXRMZWdlbmRMaXN0KHBhcmFtcykge1xuICAgIGlmICghdGhpcy5kaXJ0eSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGN0eCwgaXRlbVNlbGVjdGlvbiwgZGF0dW1SZWFkZXIsIGl0ZW1MaXN0ZW5lciB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGxtID0gY3R4LmxvY2FsZU1hbmFnZXI7XG4gICAgY29uc3QgY291bnQgPSBpdGVtU2VsZWN0aW9uLmxlbmd0aDtcbiAgICBpdGVtU2VsZWN0aW9uLmVhY2goKG1hcmtlckxhYmVsLCBkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIG1hcmtlckxhYmVsLnByb3h5QnV0dG9uPy5kZXN0cm95KCk7XG4gICAgICBtYXJrZXJMYWJlbC5wcm94eUJ1dHRvbiA9IGN0eC5wcm94eUludGVyYWN0aW9uU2VydmljZS5jcmVhdGVQcm94eUVsZW1lbnQoe1xuICAgICAgICB0eXBlOiBcImxpc3Rzd2l0Y2hcIixcbiAgICAgICAgdGV4dENvbnRlbnQ6IHRoaXMuZ2V0SXRlbUFyaWFUZXh0KGxtLCBkYXR1bVJlYWRlci5nZXRJdGVtTGFiZWwoZGF0dW0pLCBpbmRleCwgY291bnQpLFxuICAgICAgICBhcmlhQ2hlY2tlZDogISFtYXJrZXJMYWJlbC5kYXR1bS5lbmFibGVkLFxuICAgICAgICBhcmlhRGVzY3JpYmVkQnk6IHRoaXMuaXRlbURlc2NyaXB0aW9uLmlkLFxuICAgICAgICBwYXJlbnQ6IHRoaXMuaXRlbUxpc3RcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYnV0dG9uID0gbWFya2VyTGFiZWwucHJveHlCdXR0b247XG4gICAgICBidXR0b24uYWRkTGlzdGVuZXIoXCJjbGlja1wiLCAoZXYpID0+IGl0ZW1MaXN0ZW5lci5vbkNsaWNrKGV2LnNvdXJjZUV2ZW50LCBtYXJrZXJMYWJlbC5kYXR1bSwgYnV0dG9uKSk7XG4gICAgICBidXR0b24uYWRkTGlzdGVuZXIoXCJkYmxjbGlja1wiLCAoZXYpID0+IGl0ZW1MaXN0ZW5lci5vbkRvdWJsZUNsaWNrKGV2LnNvdXJjZUV2ZW50LCBtYXJrZXJMYWJlbC5kYXR1bSkpO1xuICAgICAgYnV0dG9uLmFkZExpc3RlbmVyKFwibW91c2VlbnRlclwiLCAoZXYpID0+IGl0ZW1MaXN0ZW5lci5vbkhvdmVyKGV2LnNvdXJjZUV2ZW50LCBtYXJrZXJMYWJlbCkpO1xuICAgICAgYnV0dG9uLmFkZExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCAoKSA9PiBpdGVtTGlzdGVuZXIub25MZWF2ZSgpKTtcbiAgICAgIGJ1dHRvbi5hZGRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIChldikgPT4gaXRlbUxpc3RlbmVyLm9uQ29udGV4dENsaWNrKGV2LnNvdXJjZUV2ZW50LCBtYXJrZXJMYWJlbCkpO1xuICAgICAgYnV0dG9uLmFkZExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiBpdGVtTGlzdGVuZXIub25MZWF2ZSgpKTtcbiAgICAgIGJ1dHRvbi5hZGRMaXN0ZW5lcihcImZvY3VzXCIsIChldikgPT4gaXRlbUxpc3RlbmVyLm9uSG92ZXIoZXYuc291cmNlRXZlbnQsIG1hcmtlckxhYmVsKSk7XG4gICAgICBidXR0b24uYWRkTGlzdGVuZXIoXCJkcmFnLXN0YXJ0XCIsICgpID0+IHtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxuICB1cGRhdGUocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy52aXNpYmxlKSB7XG4gICAgICB0aGlzLmluaXRMZWdlbmRMaXN0KHBhcmFtcyk7XG4gICAgICB0aGlzLnVwZGF0ZUl0ZW1Qcm94eUJ1dHRvbnMocGFyYW1zKTtcbiAgICAgIHRoaXMudXBkYXRlUGFnaW5hdGlvblByb3h5QnV0dG9ucyhwYXJhbXMsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkocGFyYW1zLnZpc2libGUpO1xuICB9XG4gIHVwZGF0ZVZpc2liaWxpdHkodmlzaWJsZSkge1xuICAgIHRoaXMuaXRlbUxpc3Quc2V0SGlkZGVuKCF2aXNpYmxlKTtcbiAgICB0aGlzLnBhZ2luYXRpb25Hcm91cC5zZXRIaWRkZW4oIXZpc2libGUpO1xuICB9XG4gIHVwZGF0ZUl0ZW1Qcm94eUJ1dHRvbnMoeyBpdGVtU2VsZWN0aW9uLCBncm91cCwgcGFnaW5hdGlvbiwgaW50ZXJhY3RpdmUgfSkge1xuICAgIGNvbnN0IGdyb3VwQkJveCA9IFRyYW5zZm9ybWFibGUudG9DYW52YXMoZ3JvdXApO1xuICAgIHRoaXMuaXRlbUxpc3Quc2V0Qm91bmRzKGdyb3VwQkJveCk7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gTWF0aC5tYXgoLi4uaXRlbVNlbGVjdGlvbi5ub2RlcygpLm1hcCgobCkgPT4gbC5nZXRCQm94KCkuaGVpZ2h0KSk7XG4gICAgaXRlbVNlbGVjdGlvbi5lYWNoKChsLCBfZGF0dW0pID0+IHtcbiAgICAgIGlmIChsLnByb3h5QnV0dG9uKSB7XG4gICAgICAgIGNvbnN0IHZpc2libGUgPSBsLnBhZ2VJbmRleCA9PT0gcGFnaW5hdGlvbi5jdXJyZW50UGFnZTtcbiAgICAgICAgY29uc3QgeyB4LCB5LCBoZWlnaHQ6IGhlaWdodDIsIHdpZHRoOiB3aWR0aDIgfSA9IFRyYW5zZm9ybWFibGUudG9DYW52YXMobCk7XG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IChtYXhIZWlnaHQgLSBoZWlnaHQyKSAvIDI7XG4gICAgICAgIGNvbnN0IGJib3ggPSB7IHg6IHggLSBncm91cEJCb3gueCwgeTogeSAtIG1hcmdpbiAtIGdyb3VwQkJveC55LCBoZWlnaHQ6IG1heEhlaWdodCwgd2lkdGg6IHdpZHRoMiB9O1xuICAgICAgICBsLnByb3h5QnV0dG9uLnNldEN1cnNvcihcInBvaW50ZXJcIik7XG4gICAgICAgIGwucHJveHlCdXR0b24uc2V0RW5hYmxlZChpbnRlcmFjdGl2ZSAmJiB2aXNpYmxlKTtcbiAgICAgICAgbC5wcm94eUJ1dHRvbi5zZXRCb3VuZHMoYmJveCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlUGFnaW5hdGlvblByb3h5QnV0dG9ucyhwYXJhbXMsIGluaXQpIHtcbiAgICBjb25zdCB7IHBhZ2luYXRpb24gfSA9IHBhcmFtcztcbiAgICB0aGlzLnBhZ2luYXRpb25Hcm91cC5zZXRIaWRkZW4oIXBhZ2luYXRpb24udmlzaWJsZSk7XG4gICAgaWYgKGluaXQgJiYgXCJjdHhcIiBpbiBwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHsgY3R4LCBvbGRQYWdlcywgbmV3UGFnZXMgfSA9IHBhcmFtcztcbiAgICAgIGNvbnN0IG9sZE5lZWRzQnV0dG9ucyA9IChvbGRQYWdlcz8ubGVuZ3RoID8/IG5ld1BhZ2VzLmxlbmd0aCkgPiAxO1xuICAgICAgY29uc3QgbmV3TmVlZHNCdXR0b25zID0gbmV3UGFnZXMubGVuZ3RoID4gMTtcbiAgICAgIGlmIChvbGROZWVkc0J1dHRvbnMgIT09IG5ld05lZWRzQnV0dG9ucykge1xuICAgICAgICBpZiAobmV3TmVlZHNCdXR0b25zKSB7XG4gICAgICAgICAgdGhpcy5wcmV2QnV0dG9uID0gY3R4LnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLmNyZWF0ZVByb3h5RWxlbWVudCh7XG4gICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgaWQ6IGAke3RoaXMuaWRQcmVmaXh9LXByZXYtcGFnZWAsXG4gICAgICAgICAgICB0ZXh0Q29udGVudDogeyBpZDogXCJhcmlhTGFiZWxMZWdlbmRQYWdlUHJldmlvdXNcIiB9LFxuICAgICAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMucGFnaW5hdGlvbkdyb3VwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5wcmV2QnV0dG9uLmFkZExpc3RlbmVyKFwiY2xpY2tcIiwgKGV2KSA9PiB0aGlzLm9uUGFnZUJ1dHRvbihwYXJhbXMsIGV2LCBcInByZXZpb3VzXCIpKTtcbiAgICAgICAgICB0aGlzLnByZXZCdXR0b24uYWRkTGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsICgpID0+IHBhZ2luYXRpb24ub25Nb3VzZUhvdmVyKFwicHJldmlvdXNcIikpO1xuICAgICAgICAgIHRoaXMucHJldkJ1dHRvbi5hZGRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgKCkgPT4gcGFnaW5hdGlvbi5vbk1vdXNlSG92ZXIodm9pZCAwKSk7XG4gICAgICAgICAgdGhpcy5uZXh0QnV0dG9uID8/ICh0aGlzLm5leHRCdXR0b24gPSBjdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlFbGVtZW50KHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBpZDogYCR7dGhpcy5pZFByZWZpeH0tbmV4dC1wYWdlYCxcbiAgICAgICAgICAgIHRleHRDb250ZW50OiB7IGlkOiBcImFyaWFMYWJlbExlZ2VuZFBhZ2VOZXh0XCIgfSxcbiAgICAgICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICAgICAgcGFyZW50OiB0aGlzLnBhZ2luYXRpb25Hcm91cFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB0aGlzLm5leHRCdXR0b24uYWRkTGlzdGVuZXIoXCJjbGlja1wiLCAoZXYpID0+IHRoaXMub25QYWdlQnV0dG9uKHBhcmFtcywgZXYsIFwibmV4dFwiKSk7XG4gICAgICAgICAgdGhpcy5uZXh0QnV0dG9uLmFkZExpc3RlbmVyKFwibW91c2VlbnRlclwiLCAoKSA9PiBwYWdpbmF0aW9uLm9uTW91c2VIb3ZlcihcIm5leHRcIikpO1xuICAgICAgICAgIHRoaXMubmV4dEJ1dHRvbi5hZGRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgKCkgPT4gcGFnaW5hdGlvbi5vbk1vdXNlSG92ZXIodm9pZCAwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5uZXh0QnV0dG9uPy5kZXN0cm95KCk7XG4gICAgICAgICAgdGhpcy5wcmV2QnV0dG9uPy5kZXN0cm95KCk7XG4gICAgICAgICAgdGhpcy5uZXh0QnV0dG9uID0gdm9pZCAwO1xuICAgICAgICAgIHRoaXMucHJldkJ1dHRvbiA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IHByZXYsIG5leHQgfSA9IHBhZ2luYXRpb24uY29tcHV0ZUNTU0JvdW5kcygpO1xuICAgIHRoaXMucHJldkJ1dHRvbj8uc2V0Qm91bmRzKHByZXYpO1xuICAgIHRoaXMubmV4dEJ1dHRvbj8uc2V0Qm91bmRzKG5leHQpO1xuICAgIHRoaXMucHJldkJ1dHRvbj8uc2V0RW5hYmxlZChwYWdpbmF0aW9uLmN1cnJlbnRQYWdlICE9PSAwKTtcbiAgICB0aGlzLm5leHRCdXR0b24/LnNldEVuYWJsZWQocGFnaW5hdGlvbi5jdXJyZW50UGFnZSAhPT0gcGFnaW5hdGlvbi50b3RhbFBhZ2VzIC0gMSk7XG4gICAgdGhpcy5uZXh0QnV0dG9uPy5zZXRDdXJzb3IocGFnaW5hdGlvbi5nZXRDdXJzb3IoXCJuZXh0XCIpKTtcbiAgICB0aGlzLnByZXZCdXR0b24/LnNldEN1cnNvcihwYWdpbmF0aW9uLmdldEN1cnNvcihcInByZXZpb3VzXCIpKTtcbiAgfVxuICBvblBhZ2VCdXR0b24ocGFyYW1zLCBldiwgbm9kZSkge1xuICAgIHBhcmFtcy5wYWdpbmF0aW9uLm9uQ2xpY2soZXYuc291cmNlRXZlbnQsIG5vZGUpO1xuICAgIHRoaXMudXBkYXRlUGFnaW5hdGlvblByb3h5QnV0dG9ucyhwYXJhbXMsIGZhbHNlKTtcbiAgfVxuICBvbkRhdGFVcGRhdGUob2xkRGF0YSwgbmV3RGF0YSkge1xuICAgIHRoaXMuZGlydHkgPSBvbGREYXRhLmxlbmd0aCAhPT0gbmV3RGF0YS5sZW5ndGggfHwgb2xkRGF0YS5zb21lKChfdiwgaW5kZXgsIF9hKSA9PiB7XG4gICAgICBjb25zdCBbbmV3VmFsdWUsIG9sZFZhbHVlXSA9IFtuZXdEYXRhW2luZGV4XSwgb2xkRGF0YVtpbmRleF1dO1xuICAgICAgcmV0dXJuIG5ld1ZhbHVlLmlkICE9PSBvbGRWYWx1ZS5pZDtcbiAgICB9KTtcbiAgfVxuICBvbkxvY2FsZUNoYW5nZWQobG9jYWxlTWFuYWdlciwgaXRlbVNlbGVjdGlvbiwgZGF0dW1SZWFkZXIpIHtcbiAgICBjb25zdCBjb3VudCA9IGl0ZW1TZWxlY3Rpb24ubGVuZ3RoO1xuICAgIGl0ZW1TZWxlY3Rpb24uZWFjaCgoeyBwcm94eUJ1dHRvbiB9LCBkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGJ1dHRvbiA9IHByb3h5QnV0dG9uPy5nZXRFbGVtZW50KCk7XG4gICAgICBpZiAoYnV0dG9uICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bVJlYWRlci5nZXRJdGVtTGFiZWwoZGF0dW0pO1xuICAgICAgICBidXR0b24udGV4dENvbnRlbnQgPSB0aGlzLmdldEl0ZW1BcmlhVGV4dChsb2NhbGVNYW5hZ2VyLCBsYWJlbCwgaW5kZXgsIGNvdW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLml0ZW1EZXNjcmlwdGlvbi50ZXh0Q29udGVudCA9IHRoaXMuZ2V0SXRlbUFyaWFEZXNjcmlwdGlvbihsb2NhbGVNYW5hZ2VyKTtcbiAgfVxuICBvblBhZ2VDaGFuZ2UocGFyYW1zKSB7XG4gICAgdGhpcy51cGRhdGVJdGVtUHJveHlCdXR0b25zKHBhcmFtcyk7XG4gICAgdGhpcy51cGRhdGVQYWdpbmF0aW9uUHJveHlCdXR0b25zKHBhcmFtcywgZmFsc2UpO1xuICB9XG4gIGdldEl0ZW1BcmlhVGV4dChsb2NhbGVNYW5hZ2VyLCBsYWJlbCwgaW5kZXgsIGNvdW50KSB7XG4gICAgaWYgKGluZGV4ID49IDAgJiYgbGFiZWwpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgICByZXR1cm4gbG9jYWxlTWFuYWdlci50KFwiYXJpYUxhYmVsTGVnZW5kSXRlbVwiLCB7IGxhYmVsLCBpbmRleCwgY291bnQgfSk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVNYW5hZ2VyLnQoXCJhcmlhTGFiZWxMZWdlbmRJdGVtVW5rbm93blwiKTtcbiAgfVxuICBnZXRJdGVtQXJpYURlc2NyaXB0aW9uKGxvY2FsZU1hbmFnZXIpIHtcbiAgICByZXR1cm4gbG9jYWxlTWFuYWdlci50KFwiYXJpYURlc2NyaXB0aW9uTGVnZW5kSXRlbVwiKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbGVnZW5kL2xlZ2VuZEV2ZW50LnRzXG5mdW5jdGlvbiBtYWtlTGVnZW5kSXRlbUV2ZW50KHR5cGUsIGl0ZW1JZCwgc2VyaWVzSWQsIGV2ZW50KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBkZWZhdWx0UHJldmVudGVkOiBmYWxzZSxcbiAgICBhcGlFdmVudDoge1xuICAgICAgdHlwZSxcbiAgICAgIGl0ZW1JZCxcbiAgICAgIHNlcmllc0lkLFxuICAgICAgZXZlbnQsXG4gICAgICBwcmV2ZW50RGVmYXVsdDogKCkgPT4gcmVzdWx0LmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlXG4gICAgfVxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sZWdlbmQvbGVnZW5kTWFya2VyTGFiZWwudHNcbnZhciBMZWdlbmRNYXJrZXJMYWJlbCA9IGNsYXNzIGV4dGVuZHMgVHJhbnNsYXRhYmxlKEdyb3VwKSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHsgbmFtZTogXCJtYXJrZXJMYWJlbEdyb3VwXCIgfSk7XG4gICAgdGhpcy5zeW1ib2xzR3JvdXAgPSB0aGlzLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IEdyb3VwKHtcbiAgICAgICAgbmFtZTogXCJsZWdlbmQtbWFya2VyTGFiZWwtc3ltYm9sc1wiXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5sYWJlbCA9IHRoaXMuYXBwZW5kQ2hpbGQobmV3IFRleHQoKSk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IE5hTjtcbiAgICB0aGlzLnNwYWNpbmcgPSAwO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmlzQ3VzdG9tTWFya2VyID0gZmFsc2U7XG4gICAgdGhpcy5tYXJrZXIgPSB0aGlzLnN5bWJvbHNHcm91cC5hcHBlbmRDaGlsZChuZXcgTWFya2VyKHsgekluZGV4OiAxIH0pKTtcbiAgICB0aGlzLmxpbmUgPSB0aGlzLnN5bWJvbHNHcm91cC5hcHBlbmRDaGlsZChuZXcgTGluZSh7IHpJbmRleDogMCB9KSk7XG4gICAgY29uc3QgeyBsYWJlbCwgbGluZSwgc3ltYm9sc0dyb3VwIH0gPSB0aGlzO1xuICAgIGxpbmUudmlzaWJsZSA9IGZhbHNlO1xuICAgIHN5bWJvbHNHcm91cC5yZW5kZXJUb09mZnNjcmVlbkNhbnZhcyA9IHRydWU7XG4gICAgc3ltYm9sc0dyb3VwLm9wdGltaXplRm9ySW5mcmVxdWVudFJlZHJhd3MgPSB0cnVlO1xuICAgIGxhYmVsLnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgbGFiZWwuZm9udFNpemUgPSAxMjtcbiAgICBsYWJlbC5mb250RmFtaWx5ID0gXCJWZXJkYW5hLCBzYW5zLXNlcmlmXCI7XG4gICAgbGFiZWwuZmlsbCA9IFwiYmxhY2tcIjtcbiAgICBsYWJlbC55ID0gMTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnByb3h5QnV0dG9uPy5kZXN0cm95KCk7XG4gIH1cbiAgc2V0RW5hYmxlZChlbmFibGVkKSB7XG4gICAgdGhpcy5lbmFibGVkID0gZW5hYmxlZDtcbiAgICB0aGlzLnJlZnJlc2hWaXNpYmlsaXRpZXMoKTtcbiAgfVxuICByZWZyZXNoVmlzaWJpbGl0aWVzKCkge1xuICAgIGNvbnN0IG9wYWNpdHkgPSB0aGlzLmVuYWJsZWQgPyAxIDogMC41O1xuICAgIHRoaXMubGFiZWwub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgfVxuICBsYXlvdXQoKSB7XG4gICAgY29uc3QgeyBtYXJrZXIsIGxpbmUsIGxlbmd0aDogbGVuZ3RoMiwgaXNDdXN0b21NYXJrZXIgfSA9IHRoaXM7XG4gICAgbGV0IGNlbnRlclRyYW5zbGF0ZVggPSAwO1xuICAgIGxldCBjZW50ZXJUcmFuc2xhdGVZID0gMDtcbiAgICBpZiAobWFya2VyLnZpc2libGUpIHtcbiAgICAgIGNvbnN0IHsgc2l6ZSB9ID0gbWFya2VyO1xuICAgICAgY29uc3QgYW5jaG9yID0gTWFya2VyLmFuY2hvcihtYXJrZXIuc2hhcGUpO1xuICAgICAgY2VudGVyVHJhbnNsYXRlWCA9IChhbmNob3IueCAtIDAuNSkgKiBzaXplICsgbGVuZ3RoMiAvIDI7XG4gICAgICBjZW50ZXJUcmFuc2xhdGVZID0gKGFuY2hvci55IC0gMC41KSAqIHNpemU7XG4gICAgICBpZiAoaXNDdXN0b21NYXJrZXIpIHtcbiAgICAgICAgbWFya2VyLnggPSAwO1xuICAgICAgICBtYXJrZXIueSA9IDA7XG4gICAgICAgIG1hcmtlci50cmFuc2xhdGlvblggPSBjZW50ZXJUcmFuc2xhdGVYO1xuICAgICAgICBtYXJrZXIudHJhbnNsYXRpb25ZID0gY2VudGVyVHJhbnNsYXRlWTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcmtlci54ID0gY2VudGVyVHJhbnNsYXRlWDtcbiAgICAgICAgbWFya2VyLnkgPSBjZW50ZXJUcmFuc2xhdGVZO1xuICAgICAgICBtYXJrZXIudHJhbnNsYXRpb25YID0gMDtcbiAgICAgICAgbWFya2VyLnRyYW5zbGF0aW9uWSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsaW5lLnZpc2libGUpIHtcbiAgICAgIGxpbmUueDEgPSAwO1xuICAgICAgbGluZS54MiA9IGxlbmd0aDI7XG4gICAgICBsaW5lLnkxID0gMDtcbiAgICAgIGxpbmUueTIgPSAwO1xuICAgIH1cbiAgfVxuICBwcmVSZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgY29uc3Qgb3V0ID0gc3VwZXIucHJlUmVuZGVyKHJlbmRlckN0eCk7XG4gICAgdGhpcy5sYXlvdXQoKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGxheW91dExhYmVsKCkge1xuICAgIGNvbnN0IHsgbGVuZ3RoOiBsZW5ndGgyLCBzcGFjaW5nIH0gPSB0aGlzO1xuICAgIHRoaXMubGFiZWwueCA9IGxlbmd0aDIgKyBzcGFjaW5nO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIHRoaXMubGF5b3V0KCk7XG4gICAgcmV0dXJuIHN1cGVyLmNvbXB1dGVCQm94KCk7XG4gIH1cbn07XG5MZWdlbmRNYXJrZXJMYWJlbC5jbGFzc05hbWUgPSBcIk1hcmtlckxhYmVsXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5T25Xcml0ZShcImxhYmVsXCIpXG5dLCBMZWdlbmRNYXJrZXJMYWJlbC5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibGFiZWxcIilcbl0sIExlZ2VuZE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5T25Xcml0ZShcImxhYmVsXCIpXG5dLCBMZWdlbmRNYXJrZXJMYWJlbC5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibGFiZWxcIilcbl0sIExlZ2VuZE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibGFiZWxcIilcbl0sIExlZ2VuZE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJsYWJlbFwiLCBcImZpbGxcIilcbl0sIExlZ2VuZE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHRhcmdldC5sYXlvdXRMYWJlbCgpKVxuXSwgTGVnZW5kTWFya2VyTGFiZWwucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB0YXJnZXQubGF5b3V0TGFiZWwoKSlcbl0sIExlZ2VuZE1hcmtlckxhYmVsLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBMZWdlbmRNYXJrZXJMYWJlbC5wcm90b3R5cGUsIFwiaXNDdXN0b21NYXJrZXJcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2xlZ2VuZC9sZWdlbmQudHNcbnZhciBMZWdlbmRMYWJlbCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubWF4TGVuZ3RoID0gdm9pZCAwO1xuICAgIHRoaXMuY29sb3IgPSBcImJsYWNrXCI7XG4gICAgdGhpcy5mb250U3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5mb250V2VpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udFNpemUgPSAxMjtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBcIlZlcmRhbmEsIHNhbnMtc2VyaWZcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGFiZWwucHJvdG90eXBlLCBcIm1heExlbmd0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIExlZ2VuZExhYmVsLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfU1RZTEUsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZExhYmVsLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1dFSUdIVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGFiZWwucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBMZWdlbmRMYWJlbC5wcm90b3R5cGUsIFwiZm9udFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBMZWdlbmRMYWJlbC5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRMYWJlbC5wcm90b3R5cGUsIFwiZm9ybWF0dGVyXCIsIDIpO1xudmFyIExlZ2VuZE1hcmtlciA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc2hhcGUgPSB2b2lkIDA7XG4gICAgdGhpcy5zaXplID0gMTU7XG4gICAgdGhpcy5wYWRkaW5nID0gODtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE1BUktFUl9TSEFQRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTWFya2VyLnByb3RvdHlwZSwgXCJzaGFwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExlZ2VuZE1hcmtlci5wcm90b3R5cGUsIFwic2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExlZ2VuZE1hcmtlci5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTWFya2VyLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBMZWdlbmRNYXJrZXIucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG52YXIgTGVnZW5kTGluZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGluZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZExpbmUucHJvdG90eXBlLCBcImxlbmd0aFwiLCAyKTtcbnZhciBMZWdlbmRJdGVtID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wYWRkaW5nWCA9IDE2O1xuICAgIHRoaXMucGFkZGluZ1kgPSA4O1xuICAgIHRoaXMuc2hvd1Nlcmllc1N0cm9rZSA9IGZhbHNlO1xuICAgIHRoaXMubWFya2VyID0gbmV3IExlZ2VuZE1hcmtlcigpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgTGVnZW5kTGFiZWwoKTtcbiAgICB0aGlzLmxpbmUgPSBuZXcgTGVnZW5kTGluZSgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRJdGVtLnByb3RvdHlwZSwgXCJtYXhXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExlZ2VuZEl0ZW0ucHJvdG90eXBlLCBcInBhZGRpbmdYXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGVnZW5kSXRlbS5wcm90b3R5cGUsIFwicGFkZGluZ1lcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgTGVnZW5kSXRlbS5wcm90b3R5cGUsIFwic2hvd1Nlcmllc1N0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExlZ2VuZEl0ZW0ucHJvdG90eXBlLCBcIm1hcmtlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExlZ2VuZEl0ZW0ucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGVnZW5kSXRlbS5wcm90b3R5cGUsIFwibGluZVwiLCAyKTtcbnZhciBMZWdlbmRMaXN0ZW5lcnMgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGlzdGVuZXJzLnByb3RvdHlwZSwgXCJsZWdlbmRJdGVtQ2xpY2tcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGlzdGVuZXJzLnByb3RvdHlwZSwgXCJsZWdlbmRJdGVtRG91YmxlQ2xpY2tcIiwgMik7XG52YXIgSURfTEVHRU5EX1ZJU0lCSUxJVFkgPSBcImxlZ2VuZC12aXNpYmlsaXR5XCI7XG52YXIgSURfTEVHRU5EX09USEVSX1NFUklFUyA9IFwibGVnZW5kLW90aGVyLXNlcmllc1wiO1xudmFyIExlZ2VuZCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLmdyb3VwID0gbmV3IFRyYW5zbGF0YWJsZUdyb3VwKHsgbmFtZTogXCJsZWdlbmRcIiwgekluZGV4OiAxNCAvKiBMRUdFTkQgKi8gfSk7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMuZ3JvdXAsXG4gICAgICBMZWdlbmRNYXJrZXJMYWJlbFxuICAgICk7XG4gICAgdGhpcy5vbGRTaXplID0gWzAsIDBdO1xuICAgIHRoaXMucGFnZXMgPSBbXTtcbiAgICB0aGlzLm1heFBhZ2VTaXplID0gWzAsIDBdO1xuICAgIC8qKiBJdGVtIGluZGV4IHRvIHRyYWNrIG9uIHJlLXBhZ2luYXRpb24sIHNvIGN1cnJlbnQgcGFnZSB1cGRhdGVzIGFwcHJvcHJpYXRlbHkuICovXG4gICAgdGhpcy5wYWdpbmF0aW9uVHJhY2tpbmdJbmRleCA9IDA7XG4gICAgdGhpcy50cnVuY2F0ZWRJdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgIHRoaXMudG9nZ2xlU2VyaWVzID0gdHJ1ZTtcbiAgICB0aGlzLml0ZW0gPSBuZXcgTGVnZW5kSXRlbSgpO1xuICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IExlZ2VuZExpc3RlbmVycygpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5wb3NpdGlvbiA9IFwiYm90dG9tXCI7XG4gICAgdGhpcy5zcGFjaW5nID0gMjA7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5zaXplID0gWzAsIDBdO1xuICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgIHRoaXMucGFnaW5hdGlvbiA9IG5ldyBQYWdpbmF0aW9uKFxuICAgICAgKHR5cGUpID0+IGN0eC51cGRhdGVTZXJ2aWNlLnVwZGF0ZSh0eXBlKSxcbiAgICAgIChwYWdlKSA9PiB0aGlzLnVwZGF0ZVBhZ2VOdW1iZXIocGFnZSlcbiAgICApO1xuICAgIHRoaXMucGFnaW5hdGlvbi5hdHRhY2hQYWdpbmF0aW9uKHRoaXMuZ3JvdXApO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgY3R4LmNvbnRleHRNZW51UmVnaXN0cnkucmVnaXN0ZXJEZWZhdWx0QWN0aW9uKHtcbiAgICAgICAgaWQ6IElEX0xFR0VORF9WSVNJQklMSVRZLFxuICAgICAgICB0eXBlOiBcImxlZ2VuZFwiLFxuICAgICAgICBsYWJlbDogXCJjb250ZXh0TWVudVRvZ2dsZVNlcmllc1Zpc2liaWxpdHlcIixcbiAgICAgICAgYWN0aW9uOiAocGFyYW1zKSA9PiB0aGlzLmNvbnRleHRUb2dnbGVWaXNpYmlsaXR5KHBhcmFtcylcbiAgICAgIH0pLFxuICAgICAgY3R4LmNvbnRleHRNZW51UmVnaXN0cnkucmVnaXN0ZXJEZWZhdWx0QWN0aW9uKHtcbiAgICAgICAgaWQ6IElEX0xFR0VORF9PVEhFUl9TRVJJRVMsXG4gICAgICAgIHR5cGU6IFwibGVnZW5kXCIsXG4gICAgICAgIGxhYmVsOiBcImNvbnRleHRNZW51VG9nZ2xlT3RoZXJTZXJpZXNcIixcbiAgICAgICAgYWN0aW9uOiAocGFyYW1zKSA9PiB0aGlzLmNvbnRleHRUb2dnbGVPdGhlclNlcmllcyhwYXJhbXMpXG4gICAgICB9KSxcbiAgICAgIGN0eC5sZWdlbmRNYW5hZ2VyLmFkZExpc3RlbmVyKFwibGVnZW5kLWNoYW5nZVwiLCB0aGlzLm9uTGVnZW5kRGF0YUNoYW5nZS5iaW5kKHRoaXMpKVxuICAgICk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICBjdHgubGF5b3V0TWFuYWdlci5yZWdpc3RlckVsZW1lbnQoMSAvKiBMZWdlbmQgKi8sIChlKSA9PiB0aGlzLnBvc2l0aW9uTGVnZW5kKGUpKSxcbiAgICAgIGN0eC5sb2NhbGVNYW5hZ2VyLmFkZExpc3RlbmVyKFwibG9jYWxlLWNoYW5nZWRcIiwgKCkgPT4gdGhpcy5vbkxvY2FsZUNoYW5nZWQoKSksXG4gICAgICAoKSA9PiB0aGlzLmdyb3VwLnJlbW92ZSgpXG4gICAgKTtcbiAgICB0aGlzLmRvbVByb3h5ID0gbmV3IExlZ2VuZERPTVByb3h5KHRoaXMuY3R4LCB0aGlzLmlkKTtcbiAgICB0aGlzLmN0eC5oaXN0b3J5TWFuYWdlci5hZGRNZW1lbnRvT3JpZ2luYXRvcihjdHgubGVnZW5kTWFuYWdlcik7XG4gIH1cbiAgc2V0IGRhdGEodmFsdWUpIHtcbiAgICBpZiAob2JqZWN0c0VxdWFsKHZhbHVlLCB0aGlzLl9kYXRhKSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmRvbVByb3h5Lm9uRGF0YVVwZGF0ZSh0aGlzLl9kYXRhLCB2YWx1ZSk7XG4gICAgdGhpcy5fZGF0YSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCk7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgb25MZWdlbmREYXRhQ2hhbmdlKHsgbGVnZW5kRGF0YSA9IFtdIH0pIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmRhdGEgPSBsZWdlbmREYXRhLmZpbHRlcigoZGF0dW0pID0+ICFkYXR1bS5oaWRlSW5MZWdlbmQpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jdHguZG9tTWFuYWdlci5yZW1vdmVDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIGAke3RoaXMuaWR9LXRvb2xiYXJgKTtcbiAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnJlbW92ZUNoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgYCR7dGhpcy5pZH0tcGFnaW5hdGlvbmApO1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChmKSA9PiBmKCkpO1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5jbGVhcigpO1xuICAgIHRoaXMuZG9tUHJveHkuZGVzdHJveSgpO1xuICB9XG4gIGdldE9yaWVudGF0aW9uKCkge1xuICAgIGlmICh0aGlzLm9yaWVudGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcbiAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgcmV0dXJuIFwidmVydGljYWxcIjtcbiAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgcmV0dXJuIFwiaG9yaXpvbnRhbFwiO1xuICAgIH1cbiAgfVxuICBzZXQgdmlzaWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpO1xuICB9XG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG4gIHVwZGF0ZUdyb3VwVmlzaWJpbGl0eSgpIHtcbiAgICB0aGlzLmdyb3VwLnZpc2libGUgPSB0aGlzLmVuYWJsZWQgJiYgdGhpcy52aXNpYmxlICYmIHRoaXMuZGF0YS5sZW5ndGggPiAwO1xuICB9XG4gIGF0dGFjaExlZ2VuZChzY2VuZSkge1xuICAgIHNjZW5lLmFwcGVuZENoaWxkKHRoaXMuZ3JvdXApO1xuICB9XG4gIGdldEl0ZW1MYWJlbChkYXR1bSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eDogeyBjYWxsYmFja0NhY2hlIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7IGZvcm1hdHRlciB9ID0gdGhpcy5pdGVtLmxhYmVsO1xuICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgIGNvbnN0IHNlcmllc0RhdHVtID0gZGF0dW0uZGF0dW07XG4gICAgICByZXR1cm4gY2FsbGJhY2tDYWNoZS5jYWxsKGZvcm1hdHRlciwge1xuICAgICAgICBpdGVtSWQ6IGRhdHVtLml0ZW1JZCxcbiAgICAgICAgdmFsdWU6IGRhdHVtLmxhYmVsLnRleHQsXG4gICAgICAgIHNlcmllc0lkOiBkYXR1bS5zZXJpZXNJZCxcbiAgICAgICAgLi4uc2VyaWVzRGF0dW0gJiYgeyBkYXR1bTogc2VyaWVzRGF0dW0gfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkYXR1bS5sYWJlbC50ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWV0aG9kIGlzIGdpdmVuIHRoZSBkZXNpcmVkIHNpemUgb2YgdGhlIGxlZ2VuZCwgd2hpY2ggb25seSBzZXJ2ZXMgYXMgYSBoaW50LlxuICAgKiBUaGUgdmVydGljYWxseSBvcmllbnRlZCBsZWdlbmQgd2lsbCB0YWtlIGFzIG11Y2ggaG9yaXpvbnRhbCBzcGFjZSBhcyBuZWVkZWQsIGJ1dCB3aWxsXG4gICAqIHJlc3BlY3QgdGhlIGhlaWdodCBjb25zdHJhaW50cywgYW5kIHRoZSBob3Jpem9udGFsIGxlZ2VuZCB3aWxsIHRha2UgYXMgbXVjaCB2ZXJ0aWNhbFxuICAgKiBzcGFjZSBhcyBuZWVkZWQgaW4gYW4gYXR0ZW1wdCBub3QgdG8gZXhjZWVkIHRoZSBnaXZlbiB3aWR0aC5cbiAgICogQWZ0ZXIgdGhlIGxheW91dCBpcyBkb25lLCB0aGUge0BsaW5rIHNpemV9IHdpbGwgY29udGFpbiB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIGxlZ2VuZC5cbiAgICogSWYgdGhlIGFjdHVhbCBzaXplIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgYWN0dWFsIHNpemUsIHRoZSBsZWdlbmQgd2lsbCBmaXJlXG4gICAqIHRoZSAnbGF5b3V0Q2hhbmdlJyBldmVudCB0byBjb21tdW5pY2F0ZSB0aGF0IGFub3RoZXIgbGF5b3V0IGlzIG5lZWRlZCwgYW5kIHRoZSBhYm92ZVxuICAgKiBwcm9jZXNzIHNob3VsZCBiZSByZXBlYXRlZC5cbiAgICogQHBhcmFtIHdpZHRoXG4gICAqIEBwYXJhbSBoZWlnaHRcbiAgICovXG4gIGNhbGNMYXlvdXQod2lkdGgyLCBoZWlnaHQyKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFkZGluZ1gsXG4gICAgICBwYWRkaW5nWSxcbiAgICAgIGxhYmVsLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICBsYWJlbDogeyBtYXhMZW5ndGggPSBJbmZpbml0eSwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSB9XG4gICAgfSA9IHRoaXMuaXRlbTtcbiAgICBjb25zdCBkYXRhID0gWy4uLnRoaXMuZGF0YV07XG4gICAgaWYgKHRoaXMucmV2ZXJzZU9yZGVyKSB7XG4gICAgICBkYXRhLnJldmVyc2UoKTtcbiAgICB9XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLnVwZGF0ZShkYXRhKTtcbiAgICBjb25zdCBiYm94ZXMgPSBbXTtcbiAgICBjb25zdCBmb250MiA9IFRleHRVdGlscy50b0ZvbnRTdHJpbmcobGFiZWwpO1xuICAgIGNvbnN0IGl0ZW1NYXhXaWR0aFBlcmNlbnRhZ2UgPSAwLjg7XG4gICAgY29uc3QgbWF4SXRlbVdpZHRoID0gbWF4V2lkdGggPz8gd2lkdGgyICogaXRlbU1heFdpZHRoUGVyY2VudGFnZTtcbiAgICBjb25zdCBtYXJrZXJXaWR0aCA9IHRoaXMuY2FsY3VsYXRlTWFya2VyV2lkdGgoKTtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgobWFya2VyTGFiZWwsIGRhdHVtKSA9PiB7XG4gICAgICBtYXJrZXJMYWJlbC5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICBtYXJrZXJMYWJlbC5mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcbiAgICAgIG1hcmtlckxhYmVsLmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICBtYXJrZXJMYWJlbC5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgIGNvbnN0IHBhZGRlZFN5bWJvbFdpZHRoID0gdGhpcy51cGRhdGVNYXJrZXJMYWJlbChtYXJrZXJMYWJlbCwgZGF0dW0sIG1hcmtlcldpZHRoKTtcbiAgICAgIGNvbnN0IGlkID0gZGF0dW0uaXRlbUlkID8/IGRhdHVtLmlkO1xuICAgICAgY29uc3QgbGFiZWxUZXh0ID0gdGhpcy5nZXRJdGVtTGFiZWwoZGF0dW0pO1xuICAgICAgY29uc3QgdGV4dDIgPSAobGFiZWxUZXh0ID8/IFwiPHVua25vd24+XCIpLnJlcGxhY2UoL1xccj9cXG4vZywgXCIgXCIpO1xuICAgICAgbWFya2VyTGFiZWwudGV4dCA9IHRoaXMudHJ1bmNhdGUodGV4dDIsIG1heExlbmd0aCwgbWF4SXRlbVdpZHRoLCBwYWRkZWRTeW1ib2xXaWR0aCwgZm9udDIsIGlkKTtcbiAgICAgIGJib3hlcy5wdXNoKG1hcmtlckxhYmVsLmdldEJCb3goKSk7XG4gICAgfSk7XG4gICAgd2lkdGgyID0gTWF0aC5tYXgoMSwgd2lkdGgyKTtcbiAgICBoZWlnaHQyID0gTWF0aC5tYXgoMSwgaGVpZ2h0Mik7XG4gICAgaWYgKCFpc0Zpbml0ZSh3aWR0aDIpKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgY29uc3Qgb2xkU2l6ZSA9IHRoaXMub2xkU2l6ZTtcbiAgICBzaXplWzBdID0gd2lkdGgyO1xuICAgIHNpemVbMV0gPSBoZWlnaHQyO1xuICAgIGlmIChzaXplWzBdICE9PSBvbGRTaXplWzBdIHx8IHNpemVbMV0gIT09IG9sZFNpemVbMV0pIHtcbiAgICAgIG9sZFNpemVbMF0gPSBzaXplWzBdO1xuICAgICAgb2xkU2l6ZVsxXSA9IHNpemVbMV07XG4gICAgfVxuICAgIGNvbnN0IHsgcGFnZXMsIG1heFBhZ2VIZWlnaHQsIG1heFBhZ2VXaWR0aCB9ID0gdGhpcy51cGRhdGVQYWdpbmF0aW9uKGJib3hlcywgd2lkdGgyLCBoZWlnaHQyKTtcbiAgICBjb25zdCBvbGRQYWdlcyA9IHRoaXMucGFnZXM7XG4gICAgdGhpcy5wYWdlcyA9IHBhZ2VzO1xuICAgIHRoaXMubWF4UGFnZVNpemUgPSBbbWF4UGFnZVdpZHRoIC0gcGFkZGluZ1gsIG1heFBhZ2VIZWlnaHQgLSBwYWRkaW5nWV07XG4gICAgY29uc3QgcGFnZU51bWJlciA9IHRoaXMucGFnaW5hdGlvbi5jdXJyZW50UGFnZTtcbiAgICBjb25zdCBwYWdlID0gdGhpcy5wYWdlc1twYWdlTnVtYmVyXTtcbiAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPCAxIHx8ICFwYWdlKSB7XG4gICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHJldHVybiB7IG9sZFBhZ2VzIH07XG4gICAgfVxuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbnMocGFnZU51bWJlcik7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICByZXR1cm4geyBvbGRQYWdlcyB9O1xuICB9XG4gIGlzQ3VzdG9tTWFya2VyKG1hcmtlckVuYWJsZWQsIHNoYXBlKSB7XG4gICAgcmV0dXJuIG1hcmtlckVuYWJsZWQgJiYgc2hhcGUgIT09IHZvaWQgMCAmJiB0eXBlb2Ygc2hhcGUgIT09IFwic3RyaW5nXCI7XG4gIH1cbiAgY2FsY1N5bWJvbHNFbmFibGVkKHN5bWJvbCkge1xuICAgIGNvbnN0IHsgc2hvd1Nlcmllc1N0cm9rZSwgbWFya2VyIH0gPSB0aGlzLml0ZW07XG4gICAgY29uc3QgbWFya2VyRW5hYmxlZCA9ICEhbWFya2VyLmVuYWJsZWQgfHwgIXNob3dTZXJpZXNTdHJva2UgfHwgKHN5bWJvbC5tYXJrZXIuZW5hYmxlZCA/PyB0cnVlKTtcbiAgICBjb25zdCBsaW5lRW5hYmxlZCA9ICEhKHN5bWJvbC5saW5lICYmIHNob3dTZXJpZXNTdHJva2UpO1xuICAgIGNvbnN0IGlzQ3VzdG9tTWFya2VyID0gdGhpcy5pc0N1c3RvbU1hcmtlcihtYXJrZXJFbmFibGVkLCBzeW1ib2wubWFya2VyLnNoYXBlKTtcbiAgICByZXR1cm4geyBtYXJrZXJFbmFibGVkLCBsaW5lRW5hYmxlZCwgaXNDdXN0b21NYXJrZXIgfTtcbiAgfVxuICBjYWxjU3ltYm9sc0xlbmd0aHMoc3ltYm9sKSB7XG4gICAgY29uc3QgeyBtYXJrZXIsIGxpbmUgfSA9IHRoaXMuaXRlbTtcbiAgICBjb25zdCB7IG1hcmtlckVuYWJsZWQsIGxpbmVFbmFibGVkIH0gPSB0aGlzLmNhbGNTeW1ib2xzRW5hYmxlZChzeW1ib2wpO1xuICAgIGNvbnN0IHsgc3Ryb2tlV2lkdGg6IG1hcmtlclN0cm9rZVdpZHRoIH0gPSB0aGlzLmdldE1hcmtlclN0eWxlcyhzeW1ib2wpO1xuICAgIGNvbnN0IHsgc3Ryb2tlV2lkdGg6IGxpbmVTdHJva2VXaWR0aCB9ID0gbGluZUVuYWJsZWQgPyB0aGlzLmdldExpbmVTdHlsZXMoc3ltYm9sKSA6IHsgc3Ryb2tlV2lkdGg6IDAgfTtcbiAgICBsZXQgY3VzdG9tTWFya2VyU2l6ZTtcbiAgICBjb25zdCB7IHNoYXBlIH0gPSBzeW1ib2wubWFya2VyO1xuICAgIGlmICh0aGlzLmlzQ3VzdG9tTWFya2VyKG1hcmtlckVuYWJsZWQsIHNoYXBlKSkge1xuICAgICAgY29uc3QgdG1wU2hhcGUgPSBuZXcgTWFya2VyKCk7XG4gICAgICB0bXBTaGFwZS5zaGFwZSA9IHNoYXBlO1xuICAgICAgdG1wU2hhcGUudXBkYXRlUGF0aCgpO1xuICAgICAgY29uc3QgYmJveCA9IHRtcFNoYXBlLmdldEJCb3goKTtcbiAgICAgIGN1c3RvbU1hcmtlclNpemUgPSBNYXRoLm1heChiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XG4gICAgfVxuICAgIGNvbnN0IG1hcmtlckxlbmd0aCA9IG1hcmtlckVuYWJsZWQgPyBtYXJrZXIuc2l6ZSA6IDA7XG4gICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVFbmFibGVkID8gbGluZS5sZW5ndGggPz8gMjUgOiAwO1xuICAgIHJldHVybiB7IG1hcmtlckxlbmd0aCwgbWFya2VyU3Ryb2tlV2lkdGgsIGxpbmVMZW5ndGgsIGxpbmVTdHJva2VXaWR0aCwgY3VzdG9tTWFya2VyU2l6ZSB9O1xuICB9XG4gIGNhbGN1bGF0ZU1hcmtlcldpZHRoKCkge1xuICAgIGxldCBtYXJrZXJXaWR0aCA9IDA7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmVhY2goKF8sIGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCB7IHN5bWJvbCB9ID0gZGF0dW07XG4gICAgICBjb25zdCB7IG1hcmtlckxlbmd0aCwgbGluZUxlbmd0aCwgY3VzdG9tTWFya2VyU2l6ZSA9IC1JbmZpbml0eSB9ID0gdGhpcy5jYWxjU3ltYm9sc0xlbmd0aHMoc3ltYm9sKTtcbiAgICAgIG1hcmtlcldpZHRoID0gTWF0aC5tYXgobWFya2VyV2lkdGgsIGxpbmVMZW5ndGgsIGN1c3RvbU1hcmtlclNpemUsIG1hcmtlckxlbmd0aCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcmtlcldpZHRoO1xuICB9XG4gIHVwZGF0ZU1hcmtlckxhYmVsKG1hcmtlckxhYmVsLCBkYXR1bSwgbWFya2VyV2lkdGgpIHtcbiAgICBjb25zdCB7IG1hcmtlcjogaXRlbU1hcmtlciwgcGFkZGluZ1ggfSA9IHRoaXMuaXRlbTtcbiAgICBjb25zdCB7IHN5bWJvbCB9ID0gZGF0dW07XG4gICAgbGV0IHBhZGRlZFN5bWJvbFdpZHRoID0gcGFkZGluZ1g7XG4gICAgY29uc3QgeyBtYXJrZXJFbmFibGVkLCBsaW5lRW5hYmxlZCwgaXNDdXN0b21NYXJrZXIgfSA9IHRoaXMuY2FsY1N5bWJvbHNFbmFibGVkKHN5bWJvbCk7XG4gICAgY29uc3Qgc3BhY2luZyA9IGl0ZW1NYXJrZXIucGFkZGluZztcbiAgICBpZiAobWFya2VyRW5hYmxlZCB8fCBsaW5lRW5hYmxlZCkge1xuICAgICAgcGFkZGVkU3ltYm9sV2lkdGggKz0gc3BhY2luZyArIG1hcmtlcldpZHRoO1xuICAgIH1cbiAgICBjb25zdCB7IG1hcmtlciwgbGluZSB9ID0gbWFya2VyTGFiZWw7XG4gICAgbWFya2VyLnZpc2libGUgPSBtYXJrZXJFbmFibGVkO1xuICAgIGlmIChtYXJrZXIudmlzaWJsZSkge1xuICAgICAgbWFya2VyLnNoYXBlID0gaXRlbU1hcmtlci5zaGFwZSA/PyBzeW1ib2wubWFya2VyLnNoYXBlID8/IFwic3F1YXJlXCI7XG4gICAgICBtYXJrZXIuc2l6ZSA9IGl0ZW1NYXJrZXIuc2l6ZTtcbiAgICAgIGFwcGx5U2hhcGVTdHlsZShtYXJrZXIsIHRoaXMuZ2V0TWFya2VyU3R5bGVzKHN5bWJvbCkpO1xuICAgIH1cbiAgICBsaW5lLnZpc2libGUgPSBsaW5lRW5hYmxlZDtcbiAgICBpZiAobGluZS52aXNpYmxlKSB7XG4gICAgICBhcHBseVNoYXBlU3R5bGUobGluZSwgdGhpcy5nZXRMaW5lU3R5bGVzKHN5bWJvbCkpO1xuICAgIH1cbiAgICBtYXJrZXJMYWJlbC5sZW5ndGggPSBtYXJrZXJXaWR0aDtcbiAgICBtYXJrZXJMYWJlbC5zcGFjaW5nID0gc3BhY2luZztcbiAgICBtYXJrZXJMYWJlbC5pc0N1c3RvbU1hcmtlciA9IGlzQ3VzdG9tTWFya2VyO1xuICAgIHJldHVybiBwYWRkZWRTeW1ib2xXaWR0aDtcbiAgfVxuICB0cnVuY2F0ZSh0ZXh0MiwgbWF4Q2hhckxlbmd0aCwgbWF4SXRlbVdpZHRoLCBwYWRkZWRNYXJrZXJXaWR0aCwgZm9udDIsIGlkKSB7XG4gICAgbGV0IGFkZEVsbGlwc2lzID0gZmFsc2U7XG4gICAgaWYgKHRleHQyLmxlbmd0aCA+IG1heENoYXJMZW5ndGgpIHtcbiAgICAgIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKDAsIG1heENoYXJMZW5ndGgpO1xuICAgICAgYWRkRWxsaXBzaXMgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBtZWFzdXJlcjIgPSBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLmdldE1lYXN1cmVyKHsgZm9udDogZm9udDIgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gVGV4dFdyYXBwZXIudHJ1bmNhdGVMaW5lKHRleHQyLCBtZWFzdXJlcjIsIG1heEl0ZW1XaWR0aCAtIHBhZGRlZE1hcmtlcldpZHRoLCBhZGRFbGxpcHNpcyk7XG4gICAgaWYgKHJlc3VsdC5lbmRzV2l0aChUZXh0VXRpbHMuRWxsaXBzaXNDaGFyKSkge1xuICAgICAgdGhpcy50cnVuY2F0ZWRJdGVtcy5hZGQoaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRydW5jYXRlZEl0ZW1zLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdXBkYXRlUGFnaW5hdGlvbihiYm94ZXMsIHdpZHRoMiwgaGVpZ2h0Mikge1xuICAgIGNvbnN0IG9yaWVudGF0aW9uID0gdGhpcy5nZXRPcmllbnRhdGlvbigpO1xuICAgIGNvbnN0IHRyYWNraW5nSW5kZXggPSBNYXRoLm1pbih0aGlzLnBhZ2luYXRpb25UcmFja2luZ0luZGV4LCBiYm94ZXMubGVuZ3RoKTtcbiAgICB0aGlzLnBhZ2luYXRpb24ub3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgICB0aGlzLnBhZ2luYXRpb24udHJhbnNsYXRpb25YID0gMDtcbiAgICB0aGlzLnBhZ2luYXRpb24udHJhbnNsYXRpb25ZID0gMDtcbiAgICBjb25zdCB7IHBhZ2VzLCBtYXhQYWdlSGVpZ2h0LCBtYXhQYWdlV2lkdGgsIHBhZ2luYXRpb25CQm94LCBwYWdpbmF0aW9uVmVydGljYWwgfSA9IHRoaXMuY2FsY3VsYXRlUGFnaW5hdGlvbihcbiAgICAgIGJib3hlcyxcbiAgICAgIHdpZHRoMixcbiAgICAgIGhlaWdodDJcbiAgICApO1xuICAgIGNvbnN0IG5ld0N1cnJlbnRQYWdlID0gcGFnZXMuZmluZEluZGV4KChwKSA9PiBwLmVuZEluZGV4ID49IHRyYWNraW5nSW5kZXgpO1xuICAgIHRoaXMucGFnaW5hdGlvbi5jdXJyZW50UGFnZSA9IGNsYW1wKDAsIG5ld0N1cnJlbnRQYWdlLCBwYWdlcy5sZW5ndGggLSAxKTtcbiAgICBjb25zdCB7IHBhZGRpbmdYOiBpdGVtUGFkZGluZ1gsIHBhZGRpbmdZOiBpdGVtUGFkZGluZ1kgfSA9IHRoaXMuaXRlbTtcbiAgICBjb25zdCBwYWdpbmF0aW9uQ29tcG9uZW50UGFkZGluZyA9IDg7XG4gICAgY29uc3QgbGVnZW5kSXRlbXNXaWR0aCA9IG1heFBhZ2VXaWR0aCAtIGl0ZW1QYWRkaW5nWDtcbiAgICBjb25zdCBsZWdlbmRJdGVtc0hlaWdodCA9IG1heFBhZ2VIZWlnaHQgLSBpdGVtUGFkZGluZ1k7XG4gICAgbGV0IHBhZ2luYXRpb25YID0gMDtcbiAgICBsZXQgcGFnaW5hdGlvblkgPSAtcGFnaW5hdGlvbkJCb3gueSAtIHRoaXMuaXRlbS5tYXJrZXIuc2l6ZSAvIDI7XG4gICAgaWYgKHBhZ2luYXRpb25WZXJ0aWNhbCkge1xuICAgICAgcGFnaW5hdGlvblkgKz0gbGVnZW5kSXRlbXNIZWlnaHQgKyBwYWdpbmF0aW9uQ29tcG9uZW50UGFkZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFnaW5hdGlvblggKz0gLXBhZ2luYXRpb25CQm94LnggKyBsZWdlbmRJdGVtc1dpZHRoICsgcGFnaW5hdGlvbkNvbXBvbmVudFBhZGRpbmc7XG4gICAgICBwYWdpbmF0aW9uWSArPSAobGVnZW5kSXRlbXNIZWlnaHQgLSBwYWdpbmF0aW9uQkJveC5oZWlnaHQpIC8gMjtcbiAgICB9XG4gICAgdGhpcy5wYWdpbmF0aW9uLnRyYW5zbGF0aW9uWCA9IHBhZ2luYXRpb25YO1xuICAgIHRoaXMucGFnaW5hdGlvbi50cmFuc2xhdGlvblkgPSBwYWdpbmF0aW9uWTtcbiAgICB0aGlzLnBhZ2luYXRpb24udXBkYXRlKCk7XG4gICAgdGhpcy5wYWdpbmF0aW9uLnVwZGF0ZU1hcmtlcnMoKTtcbiAgICBsZXQgcGFnZUluZGV4ID0gMDtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgobWFya2VyTGFiZWwsIF8sIG5vZGVJbmRleCkgPT4ge1xuICAgICAgaWYgKG5vZGVJbmRleCA+IChwYWdlc1twYWdlSW5kZXhdPy5lbmRJbmRleCA/PyBJbmZpbml0eSkpIHtcbiAgICAgICAgcGFnZUluZGV4Kys7XG4gICAgICB9XG4gICAgICBtYXJrZXJMYWJlbC5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heFBhZ2VIZWlnaHQsXG4gICAgICBtYXhQYWdlV2lkdGgsXG4gICAgICBwYWdlc1xuICAgIH07XG4gIH1cbiAgY2FsY3VsYXRlUGFnaW5hdGlvbihiYm94ZXMsIHdpZHRoMiwgaGVpZ2h0Mikge1xuICAgIGNvbnN0IHsgcGFkZGluZ1g6IGl0ZW1QYWRkaW5nWCwgcGFkZGluZ1k6IGl0ZW1QYWRkaW5nWSB9ID0gdGhpcy5pdGVtO1xuICAgIGNvbnN0IG9yaWVudGF0aW9uID0gdGhpcy5nZXRPcmllbnRhdGlvbigpO1xuICAgIGNvbnN0IHBhZ2luYXRpb25WZXJ0aWNhbCA9IFtcImxlZnRcIiwgXCJyaWdodFwiXS5pbmNsdWRlcyh0aGlzLnBvc2l0aW9uKTtcbiAgICBsZXQgcGFnaW5hdGlvbkJCb3ggPSB0aGlzLnBhZ2luYXRpb24uZ2V0QkJveCgpO1xuICAgIGxldCBsYXN0UGFzc1BhZ2luYXRpb25CQm94ID0gbmV3IEJCb3goMCwgMCwgMCwgMCk7XG4gICAgbGV0IHBhZ2VzID0gW107XG4gICAgbGV0IG1heFBhZ2VXaWR0aCA9IDA7XG4gICAgbGV0IG1heFBhZ2VIZWlnaHQgPSAwO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgY29uc3Qgc3RhYmxlT3V0cHV0ID0gKGJib3gpID0+IHtcbiAgICAgIHJldHVybiBiYm94LndpZHRoID09PSBwYWdpbmF0aW9uQkJveC53aWR0aCAmJiBiYm94LmhlaWdodCA9PT0gcGFnaW5hdGlvbkJCb3guaGVpZ2h0O1xuICAgIH07XG4gICAgY29uc3QgZm9yY2VSZXN1bHQgPSB0aGlzLm1heFdpZHRoICE9PSB2b2lkIDAgJiYgdGhpcy5tYXhIZWlnaHQgIT09IHZvaWQgMDtcbiAgICBkbyB7XG4gICAgICBpZiAoY291bnQrKyA+IDEwKSB7XG4gICAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm4oXCJ1bmFibGUgdG8gZmluZCBzdGFibGUgbGVnZW5kIGxheW91dC5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcGFnaW5hdGlvbkJCb3ggPSBsYXN0UGFzc1BhZ2luYXRpb25CQm94O1xuICAgICAgY29uc3QgbWF4V2lkdGggPSB3aWR0aDIgLSAocGFnaW5hdGlvblZlcnRpY2FsID8gMCA6IHBhZ2luYXRpb25CQm94LndpZHRoKTtcbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IGhlaWdodDIgLSAocGFnaW5hdGlvblZlcnRpY2FsID8gcGFnaW5hdGlvbkJCb3guaGVpZ2h0IDogMCk7XG4gICAgICBjb25zdCBsYXlvdXQgPSBncmlkTGF5b3V0KHtcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGJib3hlcyxcbiAgICAgICAgbWF4SGVpZ2h0LFxuICAgICAgICBtYXhXaWR0aCxcbiAgICAgICAgaXRlbVBhZGRpbmdZLFxuICAgICAgICBpdGVtUGFkZGluZ1gsXG4gICAgICAgIGZvcmNlUmVzdWx0XG4gICAgICB9KTtcbiAgICAgIHBhZ2VzID0gbGF5b3V0Py5wYWdlcyA/PyBbXTtcbiAgICAgIG1heFBhZ2VXaWR0aCA9IGxheW91dD8ubWF4UGFnZVdpZHRoID8/IDA7XG4gICAgICBtYXhQYWdlSGVpZ2h0ID0gbGF5b3V0Py5tYXhQYWdlSGVpZ2h0ID8/IDA7XG4gICAgICBjb25zdCB0b3RhbFBhZ2VzID0gcGFnZXMubGVuZ3RoO1xuICAgICAgdGhpcy5wYWdpbmF0aW9uLnZpc2libGUgPSB0b3RhbFBhZ2VzID4gMTtcbiAgICAgIHRoaXMucGFnaW5hdGlvbi50b3RhbFBhZ2VzID0gdG90YWxQYWdlcztcbiAgICAgIHRoaXMucGFnaW5hdGlvbi51cGRhdGUoKTtcbiAgICAgIHRoaXMucGFnaW5hdGlvbi51cGRhdGVNYXJrZXJzKCk7XG4gICAgICBsYXN0UGFzc1BhZ2luYXRpb25CQm94ID0gdGhpcy5wYWdpbmF0aW9uLmdldEJCb3goKTtcbiAgICAgIGlmICghdGhpcy5wYWdpbmF0aW9uLnZpc2libGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoIXN0YWJsZU91dHB1dChsYXN0UGFzc1BhZ2luYXRpb25CQm94KSk7XG4gICAgcmV0dXJuIHsgbWF4UGFnZVdpZHRoLCBtYXhQYWdlSGVpZ2h0LCBwYWdlcywgcGFnaW5hdGlvbkJCb3g6IGxhc3RQYXNzUGFnaW5hdGlvbkJCb3gsIHBhZ2luYXRpb25WZXJ0aWNhbCB9O1xuICB9XG4gIHVwZGF0ZVBvc2l0aW9ucyhwYWdlTnVtYmVyID0gMCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGl0ZW06IHsgcGFkZGluZ1kgfSxcbiAgICAgIGl0ZW1TZWxlY3Rpb24sXG4gICAgICBwYWdlc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChwYWdlcy5sZW5ndGggPCAxIHx8ICFwYWdlc1twYWdlTnVtYmVyXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbHVtbnMsIHN0YXJ0SW5kZXg6IHZpc2libGVTdGFydCwgZW5kSW5kZXg6IHZpc2libGVFbmQgfSA9IHBhZ2VzW3BhZ2VOdW1iZXJdO1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgY29uc3QgY29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aDtcbiAgICBjb25zdCByb3dDb3VudCA9IGNvbHVtbnNbMF0uaW5kaWNlcy5sZW5ndGg7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHRoaXMuZ2V0T3JpZW50YXRpb24oKSA9PT0gXCJob3Jpem9udGFsXCI7XG4gICAgY29uc3QgaXRlbUhlaWdodCA9IGNvbHVtbnNbMF0uYmJveGVzWzBdLmhlaWdodCArIHBhZGRpbmdZO1xuICAgIGNvbnN0IHJvd1N1bUNvbHVtbldpZHRocyA9IFtdO1xuICAgIGl0ZW1TZWxlY3Rpb24uZWFjaCgobWFya2VyTGFiZWwsIF8sIGkpID0+IHtcbiAgICAgIGlmIChpIDwgdmlzaWJsZVN0YXJ0IHx8IGkgPiB2aXNpYmxlRW5kKSB7XG4gICAgICAgIG1hcmtlckxhYmVsLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZUluZGV4ID0gaSAtIHZpc2libGVTdGFydDtcbiAgICAgIGxldCBjb2x1bW5JbmRleDtcbiAgICAgIGxldCByb3dJbmRleDtcbiAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgIGNvbHVtbkluZGV4ID0gcGFnZUluZGV4ICUgY29sdW1uQ291bnQ7XG4gICAgICAgIHJvd0luZGV4ID0gTWF0aC5mbG9vcihwYWdlSW5kZXggLyBjb2x1bW5Db3VudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2x1bW5JbmRleCA9IE1hdGguZmxvb3IocGFnZUluZGV4IC8gcm93Q291bnQpO1xuICAgICAgICByb3dJbmRleCA9IHBhZ2VJbmRleCAlIHJvd0NvdW50O1xuICAgICAgfVxuICAgICAgbWFya2VyTGFiZWwudmlzaWJsZSA9IHRydWU7XG4gICAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW2NvbHVtbkluZGV4XTtcbiAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHkgPSBNYXRoLmZsb29yKGl0ZW1IZWlnaHQgKiByb3dJbmRleCk7XG4gICAgICB4ID0gTWF0aC5mbG9vcihyb3dTdW1Db2x1bW5XaWR0aHNbcm93SW5kZXhdID8/IDApO1xuICAgICAgcm93U3VtQ29sdW1uV2lkdGhzW3Jvd0luZGV4XSA9IChyb3dTdW1Db2x1bW5XaWR0aHNbcm93SW5kZXhdID8/IDApICsgY29sdW1uLmNvbHVtbldpZHRoO1xuICAgICAgbWFya2VyTGFiZWwudHJhbnNsYXRpb25YID0geDtcbiAgICAgIG1hcmtlckxhYmVsLnRyYW5zbGF0aW9uWSA9IHk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlUGFnZU51bWJlcihwYWdlTnVtYmVyKSB7XG4gICAgY29uc3QgeyBpdGVtU2VsZWN0aW9uLCBncm91cCwgcGFnaW5hdGlvbiwgcGFnZXMsIHRvZ2dsZVNlcmllczogaW50ZXJhY3RpdmUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBzdGFydEluZGV4LCBlbmRJbmRleCB9ID0gcGFnZXNbcGFnZU51bWJlcl07XG4gICAgaWYgKHN0YXJ0SW5kZXggPT09IDApIHtcbiAgICAgIHRoaXMucGFnaW5hdGlvblRyYWNraW5nSW5kZXggPSAwO1xuICAgIH0gZWxzZSBpZiAocGFnZU51bWJlciA9PT0gcGFnZXMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5wYWdpbmF0aW9uVHJhY2tpbmdJbmRleCA9IGVuZEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhZ2luYXRpb25UcmFja2luZ0luZGV4ID0gTWF0aC5mbG9vcigoc3RhcnRJbmRleCArIGVuZEluZGV4KSAvIDIpO1xuICAgIH1cbiAgICB0aGlzLnBhZ2luYXRpb24udXBkYXRlKCk7XG4gICAgdGhpcy5wYWdpbmF0aW9uLnVwZGF0ZU1hcmtlcnMoKTtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9ucyhwYWdlTnVtYmVyKTtcbiAgICB0aGlzLmRvbVByb3h5Lm9uUGFnZUNoYW5nZSh7IGl0ZW1TZWxlY3Rpb24sIGdyb3VwLCBwYWdpbmF0aW9uLCBpbnRlcmFjdGl2ZSB9KTtcbiAgICB0aGlzLmN0eC51cGRhdGVTZXJ2aWNlLnVwZGF0ZSg2IC8qIFNDRU5FX1JFTkRFUiAqLyk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxhYmVsOiB7IGNvbG9yIH1cbiAgICB9ID0gdGhpcy5pdGVtO1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChtYXJrZXJMYWJlbCwgZGF0dW0pID0+IHtcbiAgICAgIG1hcmtlckxhYmVsLnNldEVuYWJsZWQoZGF0dW0uZW5hYmxlZCk7XG4gICAgICBtYXJrZXJMYWJlbC5jb2xvciA9IGNvbG9yO1xuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlQ29udGV4dE1lbnUoKTtcbiAgfVxuICB1cGRhdGVDb250ZXh0TWVudSgpIHtcbiAgICBjb25zdCB7XG4gICAgICB0b2dnbGVTZXJpZXMsXG4gICAgICBjdHg6IHsgY29udGV4dE1lbnVSZWdpc3RyeSB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHRvZ2dsZVNlcmllcykge1xuICAgICAgY29udGV4dE1lbnVSZWdpc3RyeS5oaWRlQWN0aW9uKElEX0xFR0VORF9WSVNJQklMSVRZKTtcbiAgICAgIGNvbnRleHRNZW51UmVnaXN0cnkuaGlkZUFjdGlvbihJRF9MRUdFTkRfT1RIRVJfU0VSSUVTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dE1lbnVSZWdpc3RyeS5zaG93QWN0aW9uKElEX0xFR0VORF9WSVNJQklMSVRZKTtcbiAgICAgIGNvbnRleHRNZW51UmVnaXN0cnkuc2hvd0FjdGlvbihJRF9MRUdFTkRfT1RIRVJfU0VSSUVTKTtcbiAgICB9XG4gIH1cbiAgZ2V0TGluZVN0eWxlcyhkYXR1bSkge1xuICAgIGNvbnN0IHsgc3Ryb2tlOiBzdHJva2UyLCBzdHJva2VPcGFjaXR5ID0gMSwgc3Ryb2tlV2lkdGgsIGxpbmVEYXNoIH0gPSBkYXR1bS5saW5lID8/IHt9O1xuICAgIGNvbnN0IGRlZmF1bHRMaW5lU3Ryb2tlV2lkdGggPSBNYXRoLm1pbigyLCBzdHJva2VXaWR0aCA/PyAxKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Ryb2tlOiBzdHJva2UyLFxuICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLml0ZW0ubGluZS5zdHJva2VXaWR0aCA/PyBkZWZhdWx0TGluZVN0cm9rZVdpZHRoLFxuICAgICAgbGluZURhc2hcbiAgICB9O1xuICB9XG4gIGdldE1hcmtlclN0eWxlcyhkYXR1bSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbGwsXG4gICAgICBzdHJva2U6IHN0cm9rZTIsXG4gICAgICBzdHJva2VPcGFjaXR5ID0gMSxcbiAgICAgIGZpbGxPcGFjaXR5ID0gMSxcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgbGluZURhc2gsXG4gICAgICBsaW5lRGFzaE9mZnNldFxuICAgIH0gPSBkYXR1bS5tYXJrZXI7XG4gICAgY29uc3QgZGVmYXVsdExpbmVTdHJva2VXaWR0aCA9IE1hdGgubWluKDIsIHN0cm9rZVdpZHRoID8/IDEpO1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsLFxuICAgICAgc3Ryb2tlOiBzdHJva2UyLFxuICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuaXRlbS5tYXJrZXIuc3Ryb2tlV2lkdGggPz8gZGVmYXVsdExpbmVTdHJva2VXaWR0aCxcbiAgICAgIGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXRcbiAgICB9O1xuICB9XG4gIGNvbXB1dGVQYWdlZEJCb3goKSB7XG4gICAgY29uc3QgYWN0dWFsQkJveCA9IEdyb3VwLmNvbXB1dGVDaGlsZHJlbkJCb3godGhpcy5ncm91cC5jaGlsZHJlbigpKTtcbiAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBbbWF4UGFnZVdpZHRoLCBtYXhQYWdlSGVpZ2h0XSA9IHRoaXMubWF4UGFnZVNpemU7XG4gICAgICBhY3R1YWxCQm94LmhlaWdodCA9IE1hdGgubWF4KG1heFBhZ2VIZWlnaHQsIGFjdHVhbEJCb3guaGVpZ2h0KTtcbiAgICAgIGFjdHVhbEJCb3gud2lkdGggPSBNYXRoLm1heChtYXhQYWdlV2lkdGgsIGFjdHVhbEJCb3gud2lkdGgpO1xuICAgIH1cbiAgICByZXR1cm4gYWN0dWFsQkJveDtcbiAgfVxuICBmaW5kTm9kZShwYXJhbXMpIHtcbiAgICBjb25zdCB7IGRhdHVtLCBwcm94eUJ1dHRvbiB9ID0gdGhpcy5pdGVtU2VsZWN0aW9uLnNlbGVjdCgobWwpID0+IG1sLmRhdHVtPy5pdGVtSWQgPT09IHBhcmFtcy5pdGVtSWQpWzBdID8/IHt9O1xuICAgIGlmIChkYXR1bSA9PT0gdm9pZCAwIHx8IHByb3h5QnV0dG9uID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEFHIENoYXJ0cyAtIE1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydGllcyB7IGRhdHVtOiAke2RhdHVtfSwgcHJveHlCdXR0b246ICR7SlNPTi5zdHJpbmdpZnkocHJveHlCdXR0b24pfSB9YFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZGF0dW0sIHByb3h5QnV0dG9uIH07XG4gIH1cbiAgY29udGV4dFRvZ2dsZVZpc2liaWxpdHkocGFyYW1zKSB7XG4gICAgY29uc3QgeyBkYXR1bSwgcHJveHlCdXR0b24gfSA9IHRoaXMuZmluZE5vZGUocGFyYW1zKTtcbiAgICB0aGlzLmRvQ2xpY2socGFyYW1zLmV2ZW50LCBkYXR1bSwgcHJveHlCdXR0b24pO1xuICB9XG4gIGNvbnRleHRUb2dnbGVPdGhlclNlcmllcyhwYXJhbXMpIHtcbiAgICB0aGlzLmRvRG91YmxlQ2xpY2socGFyYW1zLmV2ZW50LCB0aGlzLmZpbmROb2RlKHBhcmFtcykuZGF0dW0pO1xuICB9XG4gIG9uQ29udGV4dENsaWNrKHNvdXJjZUV2ZW50LCBub2RlKSB7XG4gICAgY29uc3QgbGVnZW5kSXRlbSA9IG5vZGUuZGF0dW07XG4gICAgaWYgKHRoaXMucHJldmVudEhpZGluZ0FsbCAmJiB0aGlzLmNvbnRleHRNZW51RGF0dW0/LmVuYWJsZWQgJiYgdGhpcy5nZXRWaXNpYmxlSXRlbUNvdW50KCkgPD0gMSkge1xuICAgICAgdGhpcy5jdHguY29udGV4dE1lbnVSZWdpc3RyeS5kaXNhYmxlQWN0aW9uKElEX0xFR0VORF9WSVNJQklMSVRZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguY29udGV4dE1lbnVSZWdpc3RyeS5lbmFibGVBY3Rpb24oSURfTEVHRU5EX1ZJU0lCSUxJVFkpO1xuICAgIH1cbiAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IHNvdXJjZUV2ZW50O1xuICAgIGNvbnN0IHsgeDogY2FudmFzWCwgeTogY2FudmFzWSB9ID0gVHJhbnNmb3JtYWJsZS50b0NhbnZhc1BvaW50KG5vZGUsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgIHRoaXMuY3R4LmNvbnRleHRNZW51UmVnaXN0cnkuZGlzcGF0Y2hDb250ZXh0KFwibGVnZW5kXCIsIHsgc291cmNlRXZlbnQsIGNhbnZhc1gsIGNhbnZhc1kgfSwgeyBsZWdlbmRJdGVtIH0pO1xuICB9XG4gIG9uQ2xpY2soZXZlbnQsIGRhdHVtLCBwcm94eUJ1dHRvbikge1xuICAgIGlmICh0aGlzLmRvQ2xpY2soZXZlbnQsIGRhdHVtLCBwcm94eUJ1dHRvbikpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIGdldFZpc2libGVJdGVtQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3R4LmNoYXJ0U2VydmljZS5zZXJpZXMuZmxhdE1hcCgocykgPT4gcy5nZXRMZWdlbmREYXRhKFwiY2F0ZWdvcnlcIikpLmZpbHRlcigoZCkgPT4gZC5lbmFibGVkKS5sZW5ndGg7XG4gIH1cbiAgZG9DbGljayhldmVudCwgZGF0dW0sIHByb3h5QnV0dG9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGlzdGVuZXJzOiB7IGxlZ2VuZEl0ZW1DbGljayB9LFxuICAgICAgY3R4OiB7IGNoYXJ0U2VydmljZSwgaGlnaGxpZ2h0TWFuYWdlciB9LFxuICAgICAgcHJldmVudEhpZGluZ0FsbCxcbiAgICAgIHRvZ2dsZVNlcmllc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZGF0dW0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBsZWdlbmRUeXBlLCBzZXJpZXNJZCwgaXRlbUlkLCBlbmFibGVkIH0gPSBkYXR1bTtcbiAgICBjb25zdCBzZXJpZXMgPSBjaGFydFNlcnZpY2Uuc2VyaWVzLmZpbmQoKHMpID0+IHMuaWQgPT09IHNlcmllc0lkKTtcbiAgICBpZiAoIXNlcmllcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgbmV3RW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgY29uc3QgY2xpY2tFdmVudCA9IG1ha2VMZWdlbmRJdGVtRXZlbnQoXCJjbGlja1wiLCBpdGVtSWQsIHNlcmllcy5pZCwgZXZlbnQpO1xuICAgIGxlZ2VuZEl0ZW1DbGljaz8uKGNsaWNrRXZlbnQuYXBpRXZlbnQpO1xuICAgIGlmIChjbGlja0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodG9nZ2xlU2VyaWVzKSB7XG4gICAgICBuZXdFbmFibGVkID0gIWVuYWJsZWQ7XG4gICAgICBpZiAocHJldmVudEhpZGluZ0FsbCAmJiAhbmV3RW5hYmxlZCkge1xuICAgICAgICBjb25zdCBudW1WaXNpYmxlSXRlbXMgPSB0aGlzLmdldFZpc2libGVJdGVtQ291bnQoKTtcbiAgICAgICAgaWYgKG51bVZpc2libGVJdGVtcyA8IDIpIHtcbiAgICAgICAgICBuZXdFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJveHlCdXR0b24uc2V0Q2hlY2tlZChuZXdFbmFibGVkKTtcbiAgICAgIHRoaXMuY3R4LmNoYXJ0RXZlbnRNYW5hZ2VyLmxlZ2VuZEl0ZW1DbGljayhsZWdlbmRUeXBlLCBzZXJpZXMsIGl0ZW1JZCwgbmV3RW5hYmxlZCwgZGF0dW0ubGVnZW5kSXRlbU5hbWUpO1xuICAgIH1cbiAgICBpZiAobmV3RW5hYmxlZCkge1xuICAgICAgaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCwge1xuICAgICAgICBzZXJpZXMsXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgZGF0dW06IHZvaWQgMCxcbiAgICAgICAgZGF0dW1JbmRleDogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCk7XG4gICAgfVxuICAgIHRoaXMuY3R4LmxlZ2VuZE1hbmFnZXIudXBkYXRlKCk7XG4gICAgdGhpcy5jdHgudXBkYXRlU2VydmljZS51cGRhdGUoMiAvKiBQUk9DRVNTX0RBVEEgKi8sIHtcbiAgICAgIGZvcmNlTm9kZURhdGFSZWZyZXNoOiB0cnVlLFxuICAgICAgc2tpcEFuaW1hdGlvbnM6IGRhdHVtLnNraXBBbmltYXRpb25zID8/IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgb25Eb3VibGVDbGljayhldmVudCwgZGF0dW0pIHtcbiAgICBpZiAodGhpcy5kb0RvdWJsZUNsaWNrKGV2ZW50LCBkYXR1bSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIGRvRG91YmxlQ2xpY2soZXZlbnQsIGRhdHVtKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGlzdGVuZXJzOiB7IGxlZ2VuZEl0ZW1Eb3VibGVDbGljayB9LFxuICAgICAgY3R4OiB7IGNoYXJ0U2VydmljZSB9LFxuICAgICAgdG9nZ2xlU2VyaWVzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGNoYXJ0U2VydmljZS5tb2RlID09PSBcImludGVncmF0ZWRcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWRhdHVtKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgbGVnZW5kVHlwZSwgaWQsIGl0ZW1JZCwgc2VyaWVzSWQgfSA9IGRhdHVtO1xuICAgIGNvbnN0IHNlcmllcyA9IGNoYXJ0U2VydmljZS5zZXJpZXMuZmluZCgocykgPT4gcy5pZCA9PT0gaWQpO1xuICAgIGlmICghc2VyaWVzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGRvdWJsZUNsaWNrRXZlbnQgPSBtYWtlTGVnZW5kSXRlbUV2ZW50KFwiZGJsY2xpY2tcIiwgaXRlbUlkLCBzZXJpZXMuaWQsIGV2ZW50KTtcbiAgICBsZWdlbmRJdGVtRG91YmxlQ2xpY2s/Lihkb3VibGVDbGlja0V2ZW50LmFwaUV2ZW50KTtcbiAgICBpZiAoZG91YmxlQ2xpY2tFdmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRvZ2dsZVNlcmllcykge1xuICAgICAgY29uc3QgbGVnZW5kRGF0YSA9IGNoYXJ0U2VydmljZS5zZXJpZXMuZmxhdE1hcCgocykgPT4gcy5nZXRMZWdlbmREYXRhKFwiY2F0ZWdvcnlcIikpO1xuICAgICAgY29uc3QgbnVtVmlzaWJsZUl0ZW1zID0gbGVnZW5kRGF0YS5maWx0ZXIoKGQpID0+IGQuZW5hYmxlZCkubGVuZ3RoO1xuICAgICAgY29uc3QgY2xpY2tlZEl0ZW0gPSBsZWdlbmREYXRhLmZpbmQoKGQpID0+IGQuaXRlbUlkID09PSBpdGVtSWQgJiYgZC5zZXJpZXNJZCA9PT0gc2VyaWVzSWQpO1xuICAgICAgdGhpcy5jdHguY2hhcnRFdmVudE1hbmFnZXIubGVnZW5kSXRlbURvdWJsZUNsaWNrKFxuICAgICAgICBsZWdlbmRUeXBlLFxuICAgICAgICBzZXJpZXMsXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgY2xpY2tlZEl0ZW0/LmVuYWJsZWQgPz8gZmFsc2UsXG4gICAgICAgIG51bVZpc2libGVJdGVtcyxcbiAgICAgICAgY2xpY2tlZEl0ZW0/LmxlZ2VuZEl0ZW1OYW1lXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmN0eC5sZWdlbmRNYW5hZ2VyLnVwZGF0ZSgpO1xuICAgIHRoaXMuY3R4LnVwZGF0ZVNlcnZpY2UudXBkYXRlKDIgLyogUFJPQ0VTU19EQVRBICovLCB7IGZvcmNlTm9kZURhdGFSZWZyZXNoOiB0cnVlIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRvVG9vbHRpcE1ldGEoZXZlbnQsIG5vZGUpIHtcbiAgICBsZXQgbGFzdFBvaW50ZXJFdmVudDtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBGb2N1c0V2ZW50KSB7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IFRyYW5zZm9ybWFibGUudG9DYW52YXMobm9kZSkuY29tcHV0ZUNlbnRlcigpO1xuICAgICAgbGFzdFBvaW50ZXJFdmVudCA9IHsgdHlwZTogXCJrZXlib2FyZFwiLCBjYW52YXNYOiB4LCBjYW52YXNZOiB5IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IFRyYW5zZm9ybWFibGUudG9DYW52YXNQb2ludChub2RlLCBldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICAgIGxhc3RQb2ludGVyRXZlbnQgPSB7IHR5cGU6IFwicG9pbnRlcm1vdmVcIiwgY2FudmFzWDogeCwgY2FudmFzWTogeSB9O1xuICAgIH1cbiAgICBjb25zdCB7IGNhbnZhc1gsIGNhbnZhc1kgfSA9IGxhc3RQb2ludGVyRXZlbnQ7XG4gICAgcmV0dXJuIHsgY2FudmFzWCwgY2FudmFzWSwgbGFzdFBvaW50ZXJFdmVudCwgc2hvd0Fycm93OiBmYWxzZSB9O1xuICB9XG4gIG9uSG92ZXIoZXZlbnQsIG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIG9uSG92ZXIgaGFuZGxlciBjYWxsZWQgb24gZGlzYWJsZWQgbGVnZW5kXCIpO1xuICAgIHRoaXMucGFnaW5hdGlvbi5zZXRQYWdlKG5vZGUucGFnZUluZGV4KTtcbiAgICBjb25zdCBkYXR1bSA9IG5vZGUuZGF0dW07XG4gICAgY29uc3Qgc2VyaWVzID0gZGF0dW0gPyB0aGlzLmN0eC5jaGFydFNlcnZpY2Uuc2VyaWVzLmZpbmQoKHMpID0+IHMuaWQgPT09IGRhdHVtPy5pZCkgOiB2b2lkIDA7XG4gICAgaWYgKGRhdHVtICYmIHRoaXMudHJ1bmNhdGVkSXRlbXMuaGFzKGRhdHVtLml0ZW1JZCA/PyBkYXR1bS5pZCkpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLnRvVG9vbHRpcE1ldGEoZXZlbnQsIG5vZGUpO1xuICAgICAgdGhpcy5jdHgudG9vbHRpcE1hbmFnZXIudXBkYXRlVG9vbHRpcCh0aGlzLmlkLCBtZXRhLCB7XG4gICAgICAgIHR5cGU6IFwic3RydWN0dXJlZFwiLFxuICAgICAgICB0aXRsZTogdGhpcy5nZXRJdGVtTGFiZWwoZGF0dW0pXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHgudG9vbHRpcE1hbmFnZXIucmVtb3ZlVG9vbHRpcCh0aGlzLmlkKTtcbiAgICB9XG4gICAgaWYgKGRhdHVtPy5lbmFibGVkICYmIHNlcmllcykge1xuICAgICAgdGhpcy51cGRhdGVIaWdobGlnaHQoeyBzZXJpZXMsIGl0ZW1JZDogZGF0dW0/Lml0ZW1JZCwgZGF0dW06IHZvaWQgMCwgZGF0dW1JbmRleDogdm9pZCAwIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZUhpZ2hsaWdodCgpO1xuICAgIH1cbiAgfVxuICBvbkxlYXZlKCkge1xuICAgIHRoaXMuY3R4LnRvb2x0aXBNYW5hZ2VyLnJlbW92ZVRvb2x0aXAodGhpcy5pZCk7XG4gICAgdGhpcy51cGRhdGVIaWdobGlnaHQoKTtcbiAgfVxuICB1cGRhdGVIaWdobGlnaHQoZGF0dW0pIHtcbiAgICBpZiAodGhpcy5jdHguaW50ZXJhY3Rpb25NYW5hZ2VyLmlzU3RhdGUoMzIgLyogRGVmYXVsdCAqLykpIHtcbiAgICAgIHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQsIGRhdHVtKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3R4LmludGVyYWN0aW9uTWFuYWdlci5pc1N0YXRlKDIgLyogQW5pbWF0aW9uICovKSkge1xuICAgICAgdGhpcy5wZW5kaW5nSGlnaGxpZ2h0RGF0dW0gPSBkYXR1bTtcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIub25CYXRjaFN0b3AoKCkgPT4ge1xuICAgICAgICB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkLCB0aGlzLnBlbmRpbmdIaWdobGlnaHREYXR1bSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgb25Mb2NhbGVDaGFuZ2VkKCkge1xuICAgIHRoaXMuZG9tUHJveHkub25Mb2NhbGVDaGFuZ2VkKHRoaXMuY3R4LmxvY2FsZU1hbmFnZXIsIHRoaXMuaXRlbVNlbGVjdGlvbiwgdGhpcyk7XG4gIH1cbiAgcG9zaXRpb25MZWdlbmQoY3R4KSB7XG4gICAgY29uc3Qgb2xkUGFnZXMgPSB0aGlzLnBvc2l0aW9uTGVnZW5kU2NlbmUoY3R4KTtcbiAgICB0aGlzLnBvc2l0aW9uTGVnZW5kRE9NKG9sZFBhZ2VzKTtcbiAgfVxuICBwb3NpdGlvbkxlZ2VuZFNjZW5lKGN0eCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICF0aGlzLmRhdGEubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbGF5b3V0Qm94IH0gPSBjdHg7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IGxheW91dEJveDtcbiAgICBjb25zdCBbbGVnZW5kV2lkdGgsIGxlZ2VuZEhlaWdodF0gPSB0aGlzLmNhbGN1bGF0ZUxlZ2VuZERpbWVuc2lvbnMobGF5b3V0Qm94KTtcbiAgICBjb25zdCB7IG9sZFBhZ2VzIH0gPSB0aGlzLmNhbGNMYXlvdXQobGVnZW5kV2lkdGgsIGxlZ2VuZEhlaWdodCk7XG4gICAgY29uc3QgbGVnZW5kQkJveCA9IHRoaXMuY29tcHV0ZVBhZ2VkQkJveCgpO1xuICAgIGNvbnN0IGNhbGN1bGF0ZVRyYW5zbGF0aW9uUGVycGVuZGljdWxhckRpbWVuc2lvbiA9ICgpID0+IHtcbiAgICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xuICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICByZXR1cm4gaGVpZ2h0MiAtIGxlZ2VuZEJCb3guaGVpZ2h0O1xuICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gd2lkdGgyIC0gbGVnZW5kQkJveC53aWR0aDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgIGNvbnN0IGxlZ2VuZFBhZGRpbmcgPSB0aGlzLnNwYWNpbmc7XG4gICAgICBsZXQgdHJhbnNsYXRpb25YO1xuICAgICAgbGV0IHRyYW5zbGF0aW9uWTtcbiAgICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xuICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICB0cmFuc2xhdGlvblggPSAod2lkdGgyIC0gbGVnZW5kQkJveC53aWR0aCkgLyAyO1xuICAgICAgICAgIHRyYW5zbGF0aW9uWSA9IGNhbGN1bGF0ZVRyYW5zbGF0aW9uUGVycGVuZGljdWxhckRpbWVuc2lvbigpO1xuICAgICAgICAgIGxheW91dEJveC5zaHJpbmsobGVnZW5kQkJveC5oZWlnaHQgKyBsZWdlbmRQYWRkaW5nLCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdHJhbnNsYXRpb25YID0gY2FsY3VsYXRlVHJhbnNsYXRpb25QZXJwZW5kaWN1bGFyRGltZW5zaW9uKCk7XG4gICAgICAgICAgdHJhbnNsYXRpb25ZID0gKGhlaWdodDIgLSBsZWdlbmRCQm94LmhlaWdodCkgLyAyO1xuICAgICAgICAgIGxheW91dEJveC5zaHJpbmsobGVnZW5kQkJveC53aWR0aCArIGxlZ2VuZFBhZGRpbmcsIHRoaXMucG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgdGhpcy5ncm91cC50cmFuc2xhdGlvblggPSBNYXRoLmZsb29yKHggKyB0cmFuc2xhdGlvblggLSBsZWdlbmRCQm94LngpO1xuICAgICAgdGhpcy5ncm91cC50cmFuc2xhdGlvblkgPSBNYXRoLmZsb29yKHkgKyB0cmFuc2xhdGlvblkgLSBsZWdlbmRCQm94LnkpO1xuICAgIH1cbiAgICByZXR1cm4gb2xkUGFnZXM7XG4gIH1cbiAgcG9zaXRpb25MZWdlbmRET00ob2xkUGFnZXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdHgsXG4gICAgICBpdGVtU2VsZWN0aW9uLFxuICAgICAgcGFnaW5hdGlvbixcbiAgICAgIHBhZ2VzOiBuZXdQYWdlcyxcbiAgICAgIHRvZ2dsZVNlcmllcyxcbiAgICAgIGdyb3VwLFxuICAgICAgbGlzdGVuZXJzOiB7IGxlZ2VuZEl0ZW1DbGljaywgbGVnZW5kSXRlbURvdWJsZUNsaWNrIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB2aXNpYmxlID0gdGhpcy52aXNpYmxlICYmIHRoaXMuZW5hYmxlZDtcbiAgICBjb25zdCBpbnRlcmFjdGl2ZSA9IHRvZ2dsZVNlcmllcyB8fCBsZWdlbmRJdGVtRG91YmxlQ2xpY2sgIT0gbnVsbCB8fCBsZWdlbmRJdGVtQ2xpY2sgIT0gbnVsbDtcbiAgICB0aGlzLmRvbVByb3h5LnVwZGF0ZSh7XG4gICAgICB2aXNpYmxlLFxuICAgICAgaW50ZXJhY3RpdmUsXG4gICAgICBjdHgsXG4gICAgICBpdGVtU2VsZWN0aW9uLFxuICAgICAgZ3JvdXAsXG4gICAgICBwYWdpbmF0aW9uLFxuICAgICAgb2xkUGFnZXMsXG4gICAgICBuZXdQYWdlcyxcbiAgICAgIGRhdHVtUmVhZGVyOiB0aGlzLFxuICAgICAgaXRlbUxpc3RlbmVyOiB0aGlzXG4gICAgfSk7XG4gIH1cbiAgY2FsY3VsYXRlTGVnZW5kRGltZW5zaW9ucyhzaHJpbmtSZWN0KSB7XG4gICAgY29uc3QgeyB3aWR0aDogd2lkdGgyLCBoZWlnaHQ6IGhlaWdodDIgfSA9IHNocmlua1JlY3Q7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aWR0aDIgLyBoZWlnaHQyO1xuICAgIGNvbnN0IG1heENvZWZmaWNpZW50ID0gMC41O1xuICAgIGNvbnN0IG1pbkhlaWdodENvZWZmaWNpZW50ID0gMC4yO1xuICAgIGNvbnN0IG1pbldpZHRoQ29lZmZpY2llbnQgPSAwLjI1O1xuICAgIGxldCBsZWdlbmRXaWR0aCwgbGVnZW5kSGVpZ2h0O1xuICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgY2FzZSBcImJvdHRvbVwiOiB7XG4gICAgICAgIGNvbnN0IGhlaWdodENvZWZmaWNpZW50ID0gYXNwZWN0UmF0aW8gPCAxID8gTWF0aC5taW4obWF4Q29lZmZpY2llbnQsIG1pbkhlaWdodENvZWZmaWNpZW50ICogKDEgLyBhc3BlY3RSYXRpbykpIDogbWluSGVpZ2h0Q29lZmZpY2llbnQ7XG4gICAgICAgIGxlZ2VuZFdpZHRoID0gdGhpcy5tYXhXaWR0aCA/IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIHdpZHRoMikgOiB3aWR0aDI7XG4gICAgICAgIGxlZ2VuZEhlaWdodCA9IHRoaXMubWF4SGVpZ2h0ID8gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIGhlaWdodDIpIDogTWF0aC5yb3VuZChoZWlnaHQyICogaGVpZ2h0Q29lZmZpY2llbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3Qgd2lkdGhDb2VmZmljaWVudCA9IGFzcGVjdFJhdGlvID4gMSA/IE1hdGgubWluKG1heENvZWZmaWNpZW50LCBtaW5XaWR0aENvZWZmaWNpZW50ICogYXNwZWN0UmF0aW8pIDogbWluV2lkdGhDb2VmZmljaWVudDtcbiAgICAgICAgbGVnZW5kV2lkdGggPSB0aGlzLm1heFdpZHRoID8gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgd2lkdGgyKSA6IE1hdGgucm91bmQod2lkdGgyICogd2lkdGhDb2VmZmljaWVudCk7XG4gICAgICAgIGxlZ2VuZEhlaWdodCA9IHRoaXMubWF4SGVpZ2h0ID8gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIGhlaWdodDIpIDogaGVpZ2h0MjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtsZWdlbmRXaWR0aCwgbGVnZW5kSGVpZ2h0XTtcbiAgfVxufTtcbkxlZ2VuZC5jbGFzc05hbWUgPSBcIkxlZ2VuZFwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwidG9nZ2xlU2VyaWVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJwYWdpbmF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJpdGVtXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJsaXN0ZW5lcnNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0LCBuZXdWYWx1ZSwgb2xkVmFsdWUpID0+IHtcbiAgICB0YXJnZXQudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCk7XG4gICAgaWYgKG5ld1ZhbHVlID09PSBvbGRWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjdHg6IHsgbGVnZW5kTWFuYWdlciwgc3RhdGVNYW5hZ2VyIH1cbiAgICB9ID0gdGFyZ2V0O1xuICAgIGlmIChvbGRWYWx1ZSA9PT0gZmFsc2UgJiYgbmV3VmFsdWUgPT09IHRydWUpIHtcbiAgICAgIHN0YXRlTWFuYWdlci5yZXN0b3JlU3RhdGUobGVnZW5kTWFuYWdlcik7XG4gICAgfVxuICB9KSxcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSU9OKVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJtYXhXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJtYXhIZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcInJldmVyc2VPcmRlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFVOSU9OKFtcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiXSwgXCJhbiBvcmllbnRhdGlvblwiKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJvcmllbnRhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwicHJldmVudEhpZGluZ0FsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbGVnZW5kL2xlZ2VuZE1vZHVsZS50c1xudmFyIENvbW11bml0eUxlZ2VuZE1vZHVsZSA9IHtcbiAgdHlwZTogXCJsZWdlbmRcIixcbiAgb3B0aW9uc0tleTogXCJsZWdlbmRcIixcbiAgaWRlbnRpZmllcjogXCJjYXRlZ29yeVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIiwgXCJwb2xhclwiLCBcImhpZXJhcmNoeVwiLCBcInRvcG9sb2d5XCIsIFwiZmxvdy1wcm9wb3J0aW9uXCIsIFwic3RhbmRhbG9uZVwiLCBcImdhdWdlXCJdLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgTGVnZW5kKGN0eCksXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICByZW1vdmFibGU6IFwic3RhbmRhbG9uZS1vbmx5XCJcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9jb25zdGFudHMudHNcbnZhciBjb25zdGFudHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY29uc3RhbnRzX2V4cG9ydHMsIHtcbiAgQ0FSVEVTSUFOX0FYSVNfVFlQRTogKCkgPT4gQ0FSVEVTSUFOX0FYSVNfVFlQRSxcbiAgQ0FSVEVTSUFOX1BPU0lUSU9OOiAoKSA9PiBDQVJURVNJQU5fUE9TSVRJT04sXG4gIEZPTlRfU0laRTogKCkgPT4gRk9OVF9TSVpFLFxuICBGT05UX1NJWkVfUkFUSU86ICgpID0+IEZPTlRfU0laRV9SQVRJTyxcbiAgUE9MQVJfQVhJU19TSEFQRTogKCkgPT4gUE9MQVJfQVhJU19TSEFQRSxcbiAgUE9MQVJfQVhJU19UWVBFOiAoKSA9PiBQT0xBUl9BWElTX1RZUEVcbn0pO1xudmFyIEZPTlRfU0laRSA9IC8qIEBfX1BVUkVfXyAqLyAoKEZPTlRfU0laRTIpID0+IHtcbiAgRk9OVF9TSVpFMltGT05UX1NJWkUyW1wiU01BTExFU1RcIl0gPSA4XSA9IFwiU01BTExFU1RcIjtcbiAgRk9OVF9TSVpFMltGT05UX1NJWkUyW1wiU01BTExFUlwiXSA9IDEwXSA9IFwiU01BTExFUlwiO1xuICBGT05UX1NJWkUyW0ZPTlRfU0laRTJbXCJTTUFMTFwiXSA9IDEyXSA9IFwiU01BTExcIjtcbiAgRk9OVF9TSVpFMltGT05UX1NJWkUyW1wiTUVESVVNXCJdID0gMTNdID0gXCJNRURJVU1cIjtcbiAgRk9OVF9TSVpFMltGT05UX1NJWkUyW1wiTEFSR0VcIl0gPSAxNF0gPSBcIkxBUkdFXCI7XG4gIEZPTlRfU0laRTJbRk9OVF9TSVpFMltcIkxBUkdFU1RcIl0gPSAxN10gPSBcIkxBUkdFU1RcIjtcbiAgcmV0dXJuIEZPTlRfU0laRTI7XG59KShGT05UX1NJWkUgfHwge30pO1xudmFyIEZPTlRfU0laRV9SQVRJTyA9IC8qIEBfX1BVUkVfXyAqLyAoKEZPTlRfU0laRV9SQVRJTzIpID0+IHtcbiAgRk9OVF9TSVpFX1JBVElPMltGT05UX1NJWkVfUkFUSU8yW1wiU01BTExFU1RcIl0gPSAwLjY2NjY2NjY2NjY2NjY2NjZdID0gXCJTTUFMTEVTVFwiO1xuICBGT05UX1NJWkVfUkFUSU8yW0ZPTlRfU0laRV9SQVRJTzJbXCJTTUFMTEVSXCJdID0gMC44MzMzMzMzMzMzMzMzMzM0XSA9IFwiU01BTExFUlwiO1xuICBGT05UX1NJWkVfUkFUSU8yW0ZPTlRfU0laRV9SQVRJTzJbXCJTTUFMTFwiXSA9IDFdID0gXCJTTUFMTFwiO1xuICBGT05UX1NJWkVfUkFUSU8yW0ZPTlRfU0laRV9SQVRJTzJbXCJNRURJVU1cIl0gPSAxLjA4MzMzMzMzMzMzMzMzMzNdID0gXCJNRURJVU1cIjtcbiAgRk9OVF9TSVpFX1JBVElPMltGT05UX1NJWkVfUkFUSU8yW1wiTEFSR0VcIl0gPSAxLjE2NjY2NjY2NjY2NjY2NjddID0gXCJMQVJHRVwiO1xuICBGT05UX1NJWkVfUkFUSU8yW0ZPTlRfU0laRV9SQVRJTzJbXCJMQVJHRVNUXCJdID0gMS40MTY2NjY2NjY2NjY2NjY3XSA9IFwiTEFSR0VTVFwiO1xuICByZXR1cm4gRk9OVF9TSVpFX1JBVElPMjtcbn0pKEZPTlRfU0laRV9SQVRJTyB8fCB7fSk7XG52YXIgQ0FSVEVTSUFOX1BPU0lUSU9OID0gLyogQF9fUFVSRV9fICovICgoQ0FSVEVTSUFOX1BPU0lUSU9OMikgPT4ge1xuICBDQVJURVNJQU5fUE9TSVRJT04yW1wiVE9QXCJdID0gXCJ0b3BcIjtcbiAgQ0FSVEVTSUFOX1BPU0lUSU9OMltcIlJJR0hUXCJdID0gXCJyaWdodFwiO1xuICBDQVJURVNJQU5fUE9TSVRJT04yW1wiQk9UVE9NXCJdID0gXCJib3R0b21cIjtcbiAgQ0FSVEVTSUFOX1BPU0lUSU9OMltcIkxFRlRcIl0gPSBcImxlZnRcIjtcbiAgcmV0dXJuIENBUlRFU0lBTl9QT1NJVElPTjI7XG59KShDQVJURVNJQU5fUE9TSVRJT04gfHwge30pO1xudmFyIENBUlRFU0lBTl9BWElTX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gKChDQVJURVNJQU5fQVhJU19UWVBFMikgPT4ge1xuICBDQVJURVNJQU5fQVhJU19UWVBFMltcIkNBVEVHT1JZXCJdID0gXCJjYXRlZ29yeVwiO1xuICBDQVJURVNJQU5fQVhJU19UWVBFMltcIkdST1VQRURfQ0FURUdPUllcIl0gPSBcImdyb3VwZWQtY2F0ZWdvcnlcIjtcbiAgQ0FSVEVTSUFOX0FYSVNfVFlQRTJbXCJPUkRJTkFMX1RJTUVcIl0gPSBcIm9yZGluYWwtdGltZVwiO1xuICBDQVJURVNJQU5fQVhJU19UWVBFMltcIk5VTUJFUlwiXSA9IFwibnVtYmVyXCI7XG4gIENBUlRFU0lBTl9BWElTX1RZUEUyW1wiVElNRVwiXSA9IFwidGltZVwiO1xuICBDQVJURVNJQU5fQVhJU19UWVBFMltcIkxPR1wiXSA9IFwibG9nXCI7XG4gIHJldHVybiBDQVJURVNJQU5fQVhJU19UWVBFMjtcbn0pKENBUlRFU0lBTl9BWElTX1RZUEUgfHwge30pO1xudmFyIFBPTEFSX0FYSVNfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyAoKFBPTEFSX0FYSVNfVFlQRTIpID0+IHtcbiAgUE9MQVJfQVhJU19UWVBFMltcIkFOR0xFX0NBVEVHT1JZXCJdID0gXCJhbmdsZS1jYXRlZ29yeVwiO1xuICBQT0xBUl9BWElTX1RZUEUyW1wiQU5HTEVfTlVNQkVSXCJdID0gXCJhbmdsZS1udW1iZXJcIjtcbiAgUE9MQVJfQVhJU19UWVBFMltcIlJBRElVU19DQVRFR09SWVwiXSA9IFwicmFkaXVzLWNhdGVnb3J5XCI7XG4gIFBPTEFSX0FYSVNfVFlQRTJbXCJSQURJVVNfTlVNQkVSXCJdID0gXCJyYWRpdXMtbnVtYmVyXCI7XG4gIHJldHVybiBQT0xBUl9BWElTX1RZUEUyO1xufSkoUE9MQVJfQVhJU19UWVBFIHx8IHt9KTtcbnZhciBQT0xBUl9BWElTX1NIQVBFID0gLyogQF9fUFVSRV9fICovICgoUE9MQVJfQVhJU19TSEFQRTIpID0+IHtcbiAgUE9MQVJfQVhJU19TSEFQRTJbXCJDSVJDTEVcIl0gPSBcImNpcmNsZVwiO1xuICBQT0xBUl9BWElTX1NIQVBFMltcIlBPTFlHT05cIl0gPSBcInBvbHlnb25cIjtcbiAgcmV0dXJuIFBPTEFSX0FYSVNfU0hBUEUyO1xufSkoUE9MQVJfQVhJU19TSEFQRSB8fCB7fSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9zeW1ib2xzLnRzXG52YXIgc3ltYm9sc19leHBvcnRzID0ge307XG5fX2V4cG9ydChzeW1ib2xzX2V4cG9ydHMsIHtcbiAgREVGQVVMVF9BTk5PVEFUSU9OX0hBTkRMRV9GSUxMOiAoKSA9PiBERUZBVUxUX0FOTk9UQVRJT05fSEFORExFX0ZJTEwsXG4gIERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0NPTE9SOiAoKSA9PiBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19DT0xPUixcbiAgREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRElWSURFUl9TVFJPS0U6ICgpID0+IERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0RJVklERVJfU1RST0tFLFxuICBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19ET1dOX0ZJTEw6ICgpID0+IERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0RPV05fRklMTCxcbiAgREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRE9XTl9TVFJPS0U6ICgpID0+IERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0RPV05fU1RST0tFLFxuICBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19GSUxMOiAoKSA9PiBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19GSUxMLFxuICBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19TVFJPS0U6ICgpID0+IERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX1NUUk9LRSxcbiAgREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9VUjogKCkgPT4gREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9VUixcbiAgREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVDogKCkgPT4gREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVCxcbiAgREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRTogKCkgPT4gREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRSxcbiAgREVGQVVMVF9DT0xPUl9SQU5HRTogKCkgPT4gREVGQVVMVF9DT0xPUl9SQU5HRSxcbiAgREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9SX1JBTkdFOiAoKSA9PiBERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1JfUkFOR0UsXG4gIERFRkFVTFRfRklCT05BQ0NJX1NUUk9LRVM6ICgpID0+IERFRkFVTFRfRklCT05BQ0NJX1NUUk9LRVMsXG4gIERFRkFVTFRfRklOQU5DSUFMX0NIQVJUU19BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTDogKCkgPT4gREVGQVVMVF9GSU5BTkNJQUxfQ0hBUlRTX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLFxuICBERUZBVUxUX0ZJTkFOQ0lBTF9DSEFSVFNfQU5OT1RBVElPTl9DT0xPUjogKCkgPT4gREVGQVVMVF9GSU5BTkNJQUxfQ0hBUlRTX0FOTk9UQVRJT05fQ09MT1IsXG4gIERFRkFVTFRfRlVOTkVMX1NFUklFU19DT0xPUl9SQU5HRTogKCkgPT4gREVGQVVMVF9GVU5ORUxfU0VSSUVTX0NPTE9SX1JBTkdFLFxuICBERUZBVUxUX0dBVUdFX1NFUklFU19DT0xPUl9SQU5HRTogKCkgPT4gREVGQVVMVF9HQVVHRV9TRVJJRVNfQ09MT1JfUkFOR0UsXG4gIERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRDogKCkgPT4gREVGQVVMVF9HUklETElORV9FTkFCTEVELFxuICBERUZBVUxUX0hJRVJBUkNIWV9GSUxMUzogKCkgPT4gREVGQVVMVF9ISUVSQVJDSFlfRklMTFMsXG4gIERFRkFVTFRfSElFUkFSQ0hZX1NUUk9LRVM6ICgpID0+IERFRkFVTFRfSElFUkFSQ0hZX1NUUk9LRVMsXG4gIERFRkFVTFRfUE9MQVJfU0VSSUVTX1NUUk9LRTogKCkgPT4gREVGQVVMVF9QT0xBUl9TRVJJRVNfU1RST0tFLFxuICBERUZBVUxUX1NFUEFSQVRJT05fTElORVNfQ09MT1VSOiAoKSA9PiBERUZBVUxUX1NFUEFSQVRJT05fTElORVNfQ09MT1VSLFxuICBERUZBVUxUX1NIQURPV19DT0xPVVI6ICgpID0+IERFRkFVTFRfU0hBRE9XX0NPTE9VUixcbiAgREVGQVVMVF9TUEFSS0xJTkVfQ1JPU1NIQUlSX1NUUk9LRTogKCkgPT4gREVGQVVMVF9TUEFSS0xJTkVfQ1JPU1NIQUlSX1NUUk9LRSxcbiAgREVGQVVMVF9URVhUQk9YX0NPTE9SOiAoKSA9PiBERUZBVUxUX1RFWFRCT1hfQ09MT1IsXG4gIERFRkFVTFRfVEVYVEJPWF9GSUxMOiAoKSA9PiBERUZBVUxUX1RFWFRCT1hfRklMTCxcbiAgREVGQVVMVF9URVhUQk9YX1NUUk9LRTogKCkgPT4gREVGQVVMVF9URVhUQk9YX1NUUk9LRSxcbiAgREVGQVVMVF9URVhUX0FOTk9UQVRJT05fQ09MT1I6ICgpID0+IERFRkFVTFRfVEVYVF9BTk5PVEFUSU9OX0NPTE9SLFxuICBERUZBVUxUX1RPT0xCQVJfUE9TSVRJT046ICgpID0+IERFRkFVTFRfVE9PTEJBUl9QT1NJVElPTixcbiAgSVNfQ09NTVVOSVRZOiAoKSA9PiBJU19DT01NVU5JVFksXG4gIElTX0RBUktfVEhFTUU6ICgpID0+IElTX0RBUktfVEhFTUUsXG4gIElTX0VOVEVSUFJJU0U6ICgpID0+IElTX0VOVEVSUFJJU0UsXG4gIFBBTEVUVEVfQUxUX0RPV05fRklMTDogKCkgPT4gUEFMRVRURV9BTFRfRE9XTl9GSUxMLFxuICBQQUxFVFRFX0FMVF9ET1dOX1NUUk9LRTogKCkgPT4gUEFMRVRURV9BTFRfRE9XTl9TVFJPS0UsXG4gIFBBTEVUVEVfQUxUX05FVVRSQUxfRklMTDogKCkgPT4gUEFMRVRURV9BTFRfTkVVVFJBTF9GSUxMLFxuICBQQUxFVFRFX0FMVF9ORVVUUkFMX1NUUk9LRTogKCkgPT4gUEFMRVRURV9BTFRfTkVVVFJBTF9TVFJPS0UsXG4gIFBBTEVUVEVfQUxUX1VQX0ZJTEw6ICgpID0+IFBBTEVUVEVfQUxUX1VQX0ZJTEwsXG4gIFBBTEVUVEVfQUxUX1VQX1NUUk9LRTogKCkgPT4gUEFMRVRURV9BTFRfVVBfU1RST0tFLFxuICBQQUxFVFRFX0RPV05fRklMTDogKCkgPT4gUEFMRVRURV9ET1dOX0ZJTEwsXG4gIFBBTEVUVEVfRE9XTl9TVFJPS0U6ICgpID0+IFBBTEVUVEVfRE9XTl9TVFJPS0UsXG4gIFBBTEVUVEVfTkVVVFJBTF9GSUxMOiAoKSA9PiBQQUxFVFRFX05FVVRSQUxfRklMTCxcbiAgUEFMRVRURV9ORVVUUkFMX1NUUk9LRTogKCkgPT4gUEFMRVRURV9ORVVUUkFMX1NUUk9LRSxcbiAgUEFMRVRURV9VUF9GSUxMOiAoKSA9PiBQQUxFVFRFX1VQX0ZJTEwsXG4gIFBBTEVUVEVfVVBfU1RST0tFOiAoKSA9PiBQQUxFVFRFX1VQX1NUUk9LRVxufSk7XG52YXIgSVNfREFSS19USEVNRSA9IFN5bWJvbChcImlzLWRhcmstdGhlbWVcIik7XG52YXIgSVNfQ09NTVVOSVRZID0gU3ltYm9sKFwiaXMtY29tbXVuaXR5XCIpO1xudmFyIElTX0VOVEVSUFJJU0UgPSBTeW1ib2woXCJpcy1lbnRlcnByaXNlXCIpO1xudmFyIERFRkFVTFRfU0VQQVJBVElPTl9MSU5FU19DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LXNlcGFyYXRpb24tbGluZXMtY29sb3VyXCIpO1xudmFyIERFRkFVTFRfQkFDS0dST1VORF9DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LWJhY2tncm91bmQtY29sb3VyXCIpO1xudmFyIERFRkFVTFRfU0hBRE9XX0NPTE9VUiA9IFN5bWJvbChcImRlZmF1bHQtc2hhZG93LWNvbG91clwiKTtcbnZhciBERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFID0gU3ltYm9sKFwiZGVmYXVsdC1jYXB0aW9uLWxheW91dC1zdHlsZVwiKTtcbnZhciBERUZBVUxUX0NBUFRJT05fQUxJR05NRU5UID0gU3ltYm9sKFwiZGVmYXVsdC1jYXB0aW9uLWFsaWdubWVudFwiKTtcbnZhciBQQUxFVFRFX1VQX1NUUk9LRSA9IFN5bWJvbChcInBhbGV0dGUtdXAtc3Ryb2tlXCIpO1xudmFyIFBBTEVUVEVfRE9XTl9TVFJPS0UgPSBTeW1ib2woXCJwYWxldHRlLWRvd24tc3Ryb2tlXCIpO1xudmFyIFBBTEVUVEVfVVBfRklMTCA9IFN5bWJvbChcInBhbGV0dGUtdXAtZmlsbFwiKTtcbnZhciBQQUxFVFRFX0RPV05fRklMTCA9IFN5bWJvbChcInBhbGV0dGUtZG93bi1maWxsXCIpO1xudmFyIFBBTEVUVEVfTkVVVFJBTF9TVFJPS0UgPSBTeW1ib2woXCJwYWxldHRlLW5ldXRyYWwtc3Ryb2tlXCIpO1xudmFyIFBBTEVUVEVfTkVVVFJBTF9GSUxMID0gU3ltYm9sKFwicGFsZXR0ZS1uZXV0cmFsLWZpbGxcIik7XG52YXIgUEFMRVRURV9BTFRfVVBfU1RST0tFID0gU3ltYm9sKFwicGFsZXR0ZS1hbHQtdXAtc3Ryb2tlXCIpO1xudmFyIFBBTEVUVEVfQUxUX0RPV05fU1RST0tFID0gU3ltYm9sKFwicGFsZXR0ZS1hbHQtZG93bi1zdHJva2VcIik7XG52YXIgUEFMRVRURV9BTFRfVVBfRklMTCA9IFN5bWJvbChcInBhbGV0dGUtYWx0LXVwLWZpbGxcIik7XG52YXIgUEFMRVRURV9BTFRfRE9XTl9GSUxMID0gU3ltYm9sKFwicGFsZXR0ZS1hbHQtZG93bi1maWxsXCIpO1xudmFyIFBBTEVUVEVfQUxUX05FVVRSQUxfRklMTCA9IFN5bWJvbChcInBhbGV0dGUtZ3JheS1maWxsXCIpO1xudmFyIFBBTEVUVEVfQUxUX05FVVRSQUxfU1RST0tFID0gU3ltYm9sKFwicGFsZXR0ZS1ncmF5LXN0cm9rZVwiKTtcbnZhciBERUZBVUxUX1BPTEFSX1NFUklFU19TVFJPS0UgPSBTeW1ib2woXCJkZWZhdWx0LXBvbGFyLXNlcmllcy1zdHJva2VcIik7XG52YXIgREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9SX1JBTkdFID0gU3ltYm9sKFxuICBcImRlZmF1bHQtZGl2ZXJnaW5nLXNlcmllcy1jb2xvdXItcmFuZ2VcIlxuKTtcbnZhciBERUZBVUxUX0NPTE9SX1JBTkdFID0gU3ltYm9sKFwiZGVmYXVsdC1jb2xvdXItcmFuZ2VcIik7XG52YXIgREVGQVVMVF9TUEFSS0xJTkVfQ1JPU1NIQUlSX1NUUk9LRSA9IFN5bWJvbChcImRlZmF1bHQtc3BhcmtsaW5lLWNyb3NzaGFpci1zdHJva2VcIik7XG52YXIgREVGQVVMVF9HQVVHRV9TRVJJRVNfQ09MT1JfUkFOR0UgPSBTeW1ib2woXCJkZWZhdWx0LWdhdWdlLXNlcmllcy1jb2xvdXItcmFuZ2VcIik7XG52YXIgREVGQVVMVF9GVU5ORUxfU0VSSUVTX0NPTE9SX1JBTkdFID0gU3ltYm9sKFwiZGVmYXVsdC1mdW5uZWwtc2VyaWVzLWNvbG91ci1yYW5nZVwiKTtcbnZhciBERUZBVUxUX0hJRVJBUkNIWV9GSUxMUyA9IFN5bWJvbChcImRlZmF1bHQtaGllcmFyY2h5LWZpbGxzXCIpO1xudmFyIERFRkFVTFRfSElFUkFSQ0hZX1NUUk9LRVMgPSBTeW1ib2woXCJkZWZhdWx0LWhpZXJhcmNoeS1zdHJva2VzXCIpO1xudmFyIERFRkFVTFRfRklOQU5DSUFMX0NIQVJUU19BTk5PVEFUSU9OX0NPTE9SID0gU3ltYm9sKFxuICBcImRlZmF1bHQtZmluYW5jaWFsLWNoYXJ0cy1hbm5vdGF0aW9uLXN0cm9rZVwiXG4pO1xudmFyIERFRkFVTFRfRklCT05BQ0NJX1NUUk9LRVMgPSBTeW1ib2woXCJkZWZhdWx0LWhpZXJhcmNoeS1zdHJva2VzXCIpO1xudmFyIERFRkFVTFRfVEVYVF9BTk5PVEFUSU9OX0NPTE9SID0gU3ltYm9sKFwiZGVmYXVsdC10ZXh0LWFubm90YXRpb24tY29sb3JcIik7XG52YXIgREVGQVVMVF9GSU5BTkNJQUxfQ0hBUlRTX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMID0gU3ltYm9sKFxuICBcImRlZmF1bHQtZmluYW5jaWFsLWNoYXJ0cy1hbm5vdGF0aW9uLWJhY2tncm91bmQtZmlsbFwiXG4pO1xudmFyIERFRkFVTFRfQU5OT1RBVElPTl9IQU5ETEVfRklMTCA9IFN5bWJvbChcImRlZmF1bHQtYW5ub3RhdGlvbi1oYW5kbGUtZmlsbFwiKTtcbnZhciBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19GSUxMID0gU3ltYm9sKFwiZGVmYXVsdC1hbm5vdGF0aW9uLXN0YXRpc3RpY3MtZmlsbFwiKTtcbnZhciBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19TVFJPS0UgPSBTeW1ib2woXCJkZWZhdWx0LWFubm90YXRpb24tc3RhdGlzdGljcy1zdHJva2VcIik7XG52YXIgREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfQ09MT1IgPSBTeW1ib2woXCJkZWZhdWx0LWFubm90YXRpb24tc3RhdGlzdGljcy1jb2xvclwiKTtcbnZhciBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19ESVZJREVSX1NUUk9LRSA9IFN5bWJvbChcbiAgXCJkZWZhdWx0LWFubm90YXRpb24tc3RhdGlzdGljcy1kaXZpZGVyLXN0cm9rZVwiXG4pO1xudmFyIERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0RPV05fRklMTCA9IFN5bWJvbChcbiAgXCJkZWZhdWx0LWFubm90YXRpb24tc3RhdGlzdGljcy1maWxsXCJcbik7XG52YXIgREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRE9XTl9TVFJPS0UgPSBTeW1ib2woXG4gIFwiZGVmYXVsdC1hbm5vdGF0aW9uLXN0YXRpc3RpY3Mtc3Ryb2tlXCJcbik7XG52YXIgREVGQVVMVF9URVhUQk9YX0ZJTEwgPSBTeW1ib2woXCJkZWZhdWx0LXRleHRib3gtZmlsbFwiKTtcbnZhciBERUZBVUxUX1RFWFRCT1hfU1RST0tFID0gU3ltYm9sKFwiZGVmYXVsdC10ZXh0Ym94LXN0cm9rZVwiKTtcbnZhciBERUZBVUxUX1RFWFRCT1hfQ09MT1IgPSBTeW1ib2woXCJkZWZhdWx0LXRleHRib3gtY29sb3JcIik7XG52YXIgREVGQVVMVF9UT09MQkFSX1BPU0lUSU9OID0gU3ltYm9sKFwiZGVmYXVsdC10b29sYmFyLXBvc2l0aW9uXCIpO1xudmFyIERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCA9IFN5bWJvbChcImRlZmF1bHQtZ3JpZGxpbmUtZW5hYmxlZFwiKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL3V0aWwudHNcbmZ1bmN0aW9uIHN3YXBBeGlzQ29uZGl0aW9uKGF4ZXMsIHN3YXApIHtcbiAgcmV0dXJuIChzZXJpZXMpID0+IHtcbiAgICBpZiAoIXN3YXAoc2VyaWVzKSlcbiAgICAgIHJldHVybiBheGVzO1xuICAgIHJldHVybiBbXG4gICAgICB7IC4uLmF4ZXNbMF0sIHBvc2l0aW9uOiBheGVzWzFdLnBvc2l0aW9uIH0sXG4gICAgICB7IC4uLmF4ZXNbMV0sIHBvc2l0aW9uOiBheGVzWzBdLnBvc2l0aW9uIH1cbiAgICBdO1xuICB9O1xufVxuZnVuY3Rpb24gc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3RvcnkoeyB0YWtlQ29sb3JzIH0pIHtcbiAgY29uc3Qge1xuICAgIGZpbGxzOiBbZmlsbF0sXG4gICAgc3Ryb2tlczogW3N0cm9rZTJdXG4gIH0gPSB0YWtlQ29sb3JzKDEpO1xuICByZXR1cm4geyBmaWxsLCBzdHJva2U6IHN0cm9rZTIgfTtcbn1cbmZ1bmN0aW9uIG1hcmtlclBhbGV0dGVGYWN0b3J5KHBhcmFtcykge1xuICByZXR1cm4geyBtYXJrZXI6IHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5KHBhcmFtcykgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW90aW9uL3BhdGhNb3Rpb24udHNcbmZ1bmN0aW9uIHBhdGhNb3Rpb24oZ3JvdXBJZCwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIHBhdGhzLCBmbnMpIHtcbiAgY29uc3QgeyBhZGRQaGFzZUZuLCB1cGRhdGVQaGFzZUZuLCByZW1vdmVQaGFzZUZuIH0gPSBmbnM7XG4gIGNvbnN0IGFuaW1hdGUgPSAocGhhc2UsIHBhdGgsIHVwZGF0ZUZuKSA9PiB7XG4gICAgYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlKHtcbiAgICAgIGlkOiBgJHtncm91cElkfV8ke3N1YklkfV8ke3BhdGguaWR9XyR7cGhhc2V9YCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBmcm9tOiAwLFxuICAgICAgdG86IDEsXG4gICAgICBlYXNlOiBlYXNlT3V0LFxuICAgICAgY29sbGFwc2FibGU6IGZhbHNlLFxuICAgICAgb25VcGRhdGUocmF0aW8yLCBwcmVJbml0KSB7XG4gICAgICAgIGlmIChwcmVJbml0ICYmIHBoYXNlICE9PSBcInJlbW92ZWRcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBhdGgucGF0aC5jbGVhcih0cnVlKTtcbiAgICAgICAgdXBkYXRlRm4ocmF0aW8yLCBwYXRoKTtcbiAgICAgICAgcGF0aC5jaGVja1BhdGhEaXJ0eSgpO1xuICAgICAgfSxcbiAgICAgIG9uU3RvcCgpIHtcbiAgICAgICAgaWYgKHBoYXNlICE9PSBcImFkZGVkXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXRoLnBhdGguY2xlYXIodHJ1ZSk7XG4gICAgICAgIHVwZGF0ZUZuKDEsIHBhdGgpO1xuICAgICAgICBwYXRoLmNoZWNrUGF0aERpcnR5KCk7XG4gICAgICB9LFxuICAgICAgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbcGhhc2VdXG4gICAgfSk7XG4gIH07XG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGlmICghYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKSkge1xuICAgICAgYW5pbWF0ZShcInJlbW92ZWRcIiwgcGF0aCwgcmVtb3ZlUGhhc2VGbik7XG4gICAgICBhbmltYXRlKFwidXBkYXRlZFwiLCBwYXRoLCB1cGRhdGVQaGFzZUZuKTtcbiAgICB9XG4gICAgYW5pbWF0ZShcImFkZGVkXCIsIHBhdGgsIGFkZFBoYXNlRm4pO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNMYWJlbFV0aWwudHNcbmZ1bmN0aW9uIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHsgaWQgfSwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIC4uLmxhYmVsU2VsZWN0aW9ucykge1xuICBzdGF0aWNGcm9tVG9Nb3Rpb24oXG4gICAgaWQsXG4gICAgc3ViSWQsXG4gICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICBsYWJlbFNlbGVjdGlvbnMsXG4gICAgeyBvcGFjaXR5OiAwIH0sXG4gICAgeyBvcGFjaXR5OiAxIH0sXG4gICAgeyBwaGFzZTogXCJ0cmFpbGluZ1wiIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbih7IGlkIH0sIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCAuLi5sYWJlbFNlbGVjdGlvbnMpIHtcbiAgc3RhdGljRnJvbVRvTW90aW9uKFxuICAgIGlkLFxuICAgIHN1YklkLFxuICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgbGFiZWxTZWxlY3Rpb25zLFxuICAgIHsgb3BhY2l0eTogMSB9LFxuICAgIHsgb3BhY2l0eTogMCB9LFxuICAgIHsgcGhhc2U6IFwicmVtb3ZlXCIgfVxuICApO1xufVxuZnVuY3Rpb24gcmVzZXRMYWJlbEZuKF9ub2RlKSB7XG4gIHJldHVybiB7IG9wYWNpdHk6IDEgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvZHJvcFNoYWRvdy50c1xudmFyIERyb3BTaGFkb3cgPSBjbGFzcyBleHRlbmRzIENoYW5nZURldGVjdGFibGVQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuY29sb3IgPSBcInJnYmEoMCwgMCwgMCwgMC41KVwiO1xuICAgIHRoaXMueE9mZnNldCA9IDA7XG4gICAgdGhpcy55T2Zmc2V0ID0gMDtcbiAgICB0aGlzLmJsdXIgPSA1O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIERyb3BTaGFkb3cucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBEcm9wU2hhZG93LnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIERyb3BTaGFkb3cucHJvdG90eXBlLCBcInhPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBEcm9wU2hhZG93LnByb3RvdHlwZSwgXCJ5T2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgRHJvcFNoYWRvdy5wcm90b3R5cGUsIFwiYmx1clwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc1Rvb2x0aXAudHNcbnZhciBTZXJpZXNUb29sdGlwSW50ZXJhY3Rpb24gPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBTZXJpZXNUb29sdGlwSW50ZXJhY3Rpb24ucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG52YXIgU2VyaWVzVG9vbHRpcCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IG5ldyBTZXJpZXNUb29sdGlwSW50ZXJhY3Rpb24oKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFRvb2x0aXBQb3NpdGlvbigpO1xuICAgIHRoaXMucmFuZ2UgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGFzcyA9IHZvaWQgMDtcbiAgfVxuICBmb3JtYXRUb29sdGlwKGNvbnRlbnQsIHBhcmFtcykge1xuICAgIGNvbnN0IG92ZXJyaWRlcyA9IHRoaXMucmVuZGVyZXI/LihwYXJhbXMpO1xuICAgIGlmICh0eXBlb2Ygb3ZlcnJpZGVzID09PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJyYXdcIiwgcmF3SHRtbFN0cmluZzogb3ZlcnJpZGVzIH07XG4gICAgaWYgKG92ZXJyaWRlcyAhPSBudWxsKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdHJ1Y3R1cmVkXCIsIC4uLmNvbnRlbnQsIC4uLm92ZXJyaWRlcyB9O1xuICAgIHJldHVybiB7IHR5cGU6IFwic3RydWN0dXJlZFwiLCAuLi5jb250ZW50IH07XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgU2VyaWVzVG9vbHRpcC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc1Rvb2x0aXAucHJvdG90eXBlLCBcInNob3dBcnJvd1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNUb29sdGlwLnByb3RvdHlwZSwgXCJyZW5kZXJlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFNlcmllc1Rvb2x0aXAucHJvdG90eXBlLCBcImludGVyYWN0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgU2VyaWVzVG9vbHRpcC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShJTlRFUkFDVElPTl9SQU5HRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzVG9vbHRpcC5wcm90b3R5cGUsIFwicmFuZ2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc1Rvb2x0aXAucHJvdG90eXBlLCBcImNsYXNzXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2ludGVycG9sYXRpb25Qcm9wZXJ0aWVzLnRzXG52YXIgSU5URVJQT0xBVElPTl9UWVBFID0gVU5JT04oW1wibGluZWFyXCIsIFwic21vb3RoXCIsIFwic3RlcFwiXSwgXCJhIGxpbmUgc3R5bGVcIik7XG52YXIgSU5URVJQT0xBVElPTl9TVEVQX1BPU0lUSU9OID0gVU5JT04oW1wic3RhcnRcIiwgXCJtaWRkbGVcIiwgXCJlbmRcIl0pO1xudmFyIEludGVycG9sYXRpb25Qcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gXCJsaW5lYXJcIjtcbiAgICB0aGlzLnRlbnNpb24gPSAxO1xuICAgIHRoaXMucG9zaXRpb24gPSBcImVuZFwiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoSU5URVJQT0xBVElPTl9UWVBFKVxuXSwgSW50ZXJwb2xhdGlvblByb3BlcnRpZXMucHJvdG90eXBlLCBcInR5cGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIEludGVycG9sYXRpb25Qcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0ZW5zaW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoSU5URVJQT0xBVElPTl9TVEVQX1BPU0lUSU9OKVxuXSwgSW50ZXJwb2xhdGlvblByb3BlcnRpZXMucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2FyZWFTZXJpZXNQcm9wZXJ0aWVzLnRzXG52YXIgQXJlYVNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMueE5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5kZWZhdWx0Q29sb3JSYW5nZSA9IFtdO1xuICAgIHRoaXMuZmlsbCA9IFwiI2MxNjA2OFwiO1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuICAgIHRoaXMuc3Ryb2tlID0gXCIjODc0MzQ5XCI7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDI7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmxpbmVEYXNoID0gWzBdO1xuICAgIHRoaXMubGluZURhc2hPZmZzZXQgPSAwO1xuICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9IG5ldyBJbnRlcnBvbGF0aW9uUHJvcGVydGllcygpO1xuICAgIHRoaXMuc2hhZG93ID0gbmV3IERyb3BTaGFkb3coKTtcbiAgICB0aGlzLm1hcmtlciA9IG5ldyBTZXJpZXNNYXJrZXIoKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IExhYmVsKCk7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcbiAgICB0aGlzLmNvbm5lY3RNaXNzaW5nRGF0YSA9IGZhbHNlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5RmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibm9ybWFsaXplZFRvXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImRlZmF1bHRDb2xvclJhbmdlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT1IoQ09MT1JfR1JBRElFTlQsIENPTE9SX1NUUklORykpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMSU5FX0RBU0gpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaW50ZXJwb2xhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaGFkb3dcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibWFya2VyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRvb2x0aXBcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbm5lY3RNaXNzaW5nRGF0YVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9saW5lSW50ZXJwb2xhdGlvbi50c1xuZnVuY3Rpb24gc3BhblJhbmdlKHNwYW4pIHtcbiAgc3dpdGNoIChzcGFuLnR5cGUpIHtcbiAgICBjYXNlIFwibGluZWFyXCI6XG4gICAgY2FzZSBcInN0ZXBcIjpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHsgeDogc3Bhbi54MCwgeTogc3Bhbi55MCB9LFxuICAgICAgICB7IHg6IHNwYW4ueDEsIHk6IHNwYW4ueTEgfVxuICAgICAgXTtcbiAgICBjYXNlIFwiY3ViaWNcIjpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHsgeDogc3Bhbi5jcDB4LCB5OiBzcGFuLmNwMHkgfSxcbiAgICAgICAgeyB4OiBzcGFuLmNwM3gsIHk6IHNwYW4uY3AzeSB9XG4gICAgICBdO1xuICB9XG59XG5mdW5jdGlvbiBzcGFuUmFuZ2VOb3JtYWxpemVkKHNwYW4pIHtcbiAgY29uc3QgcmFuZ2UzID0gc3BhblJhbmdlKHNwYW4pO1xuICBpZiAocmFuZ2UzWzBdLnggPiByYW5nZTNbMV0ueCkge1xuICAgIHJhbmdlMy5yZXZlcnNlKCk7XG4gIH1cbiAgcmV0dXJuIHJhbmdlMztcbn1cbmZ1bmN0aW9uIGNvbGxhcHNlU3BhblRvUG9pbnQoc3BhbiwgcG9pbnQpIHtcbiAgY29uc3QgeyB4LCB5IH0gPSBwb2ludDtcbiAgc3dpdGNoIChzcGFuLnR5cGUpIHtcbiAgICBjYXNlIFwibGluZWFyXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImxpbmVhclwiLFxuICAgICAgICBtb3ZlVG86IHNwYW4ubW92ZVRvLFxuICAgICAgICB4MDogeCxcbiAgICAgICAgeTA6IHksXG4gICAgICAgIHgxOiB4LFxuICAgICAgICB5MTogeVxuICAgICAgfTtcbiAgICBjYXNlIFwic3RlcFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdGVwXCIsXG4gICAgICAgIG1vdmVUbzogc3Bhbi5tb3ZlVG8sXG4gICAgICAgIHgwOiB4LFxuICAgICAgICB5MDogeSxcbiAgICAgICAgeDE6IHgsXG4gICAgICAgIHkxOiB5LFxuICAgICAgICBzdGVwWDogeFxuICAgICAgfTtcbiAgICBjYXNlIFwiY3ViaWNcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY3ViaWNcIixcbiAgICAgICAgbW92ZVRvOiBzcGFuLm1vdmVUbyxcbiAgICAgICAgY3AweDogeCxcbiAgICAgICAgY3AweTogeSxcbiAgICAgICAgY3AxeDogeCxcbiAgICAgICAgY3AxeTogeSxcbiAgICAgICAgY3AyeDogeCxcbiAgICAgICAgY3AyeTogeSxcbiAgICAgICAgY3AzeDogeCxcbiAgICAgICAgY3AzeTogeVxuICAgICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzY2FsZVNwYW4oc3BhbiwgbmV4dFN0YXJ0LCBuZXh0RW5kKSB7XG4gIGNvbnN0IFtwcmV2U3RhcnQsIHByZXZFbmRdID0gc3BhblJhbmdlKHNwYW4pO1xuICBjb25zdCB3aWR0aFNjYWxlID0gcHJldkVuZC54ICE9PSBwcmV2U3RhcnQueCA/IChuZXh0RW5kLnggLSBuZXh0U3RhcnQueCkgLyAocHJldkVuZC54IC0gcHJldlN0YXJ0LngpIDogMDtcbiAgY29uc3QgaGVpZ2h0U2NhbGUgPSBwcmV2RW5kLnkgIT09IHByZXZTdGFydC55ID8gKG5leHRFbmQueSAtIG5leHRTdGFydC55KSAvIChwcmV2RW5kLnkgLSBwcmV2U3RhcnQueSkgOiAwO1xuICBzd2l0Y2ggKHNwYW4udHlwZSkge1xuICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibGluZWFyXCIsXG4gICAgICAgIG1vdmVUbzogc3Bhbi5tb3ZlVG8sXG4gICAgICAgIHgwOiBuZXh0U3RhcnQueCxcbiAgICAgICAgeTA6IG5leHRTdGFydC55LFxuICAgICAgICB4MTogbmV4dEVuZC54LFxuICAgICAgICB5MTogbmV4dEVuZC55XG4gICAgICB9O1xuICAgIGNhc2UgXCJjdWJpY1wiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJjdWJpY1wiLFxuICAgICAgICBtb3ZlVG86IHNwYW4ubW92ZVRvLFxuICAgICAgICBjcDB4OiBuZXh0U3RhcnQueCxcbiAgICAgICAgY3AweTogbmV4dFN0YXJ0LnksXG4gICAgICAgIGNwMXg6IG5leHRFbmQueCAtIChzcGFuLmNwMnggLSBwcmV2U3RhcnQueCkgKiB3aWR0aFNjYWxlLFxuICAgICAgICBjcDF5OiBuZXh0RW5kLnkgLSAoc3Bhbi5jcDJ5IC0gcHJldlN0YXJ0LnkpICogaGVpZ2h0U2NhbGUsXG4gICAgICAgIGNwMng6IG5leHRFbmQueCAtIChzcGFuLmNwMXggLSBwcmV2U3RhcnQueCkgKiB3aWR0aFNjYWxlLFxuICAgICAgICBjcDJ5OiBuZXh0RW5kLnkgLSAoc3Bhbi5jcDF5IC0gcHJldlN0YXJ0LnkpICogaGVpZ2h0U2NhbGUsXG4gICAgICAgIGNwM3g6IG5leHRFbmQueCxcbiAgICAgICAgY3AzeTogbmV4dEVuZC55XG4gICAgICB9O1xuICAgIGNhc2UgXCJzdGVwXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN0ZXBcIixcbiAgICAgICAgbW92ZVRvOiBzcGFuLm1vdmVUbyxcbiAgICAgICAgeDA6IG5leHRTdGFydC54LFxuICAgICAgICB5MDogbmV4dFN0YXJ0LnksXG4gICAgICAgIHgxOiBuZXh0RW5kLngsXG4gICAgICAgIHkxOiBuZXh0RW5kLnksXG4gICAgICAgIHN0ZXBYOiBuZXh0RW5kLnggLSAoc3Bhbi5zdGVwWCAtIHByZXZTdGFydC54KSAqIHdpZHRoU2NhbGVcbiAgICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGNsaXBTcGFuWChzcGFuLCB4MCwgeDEpIHtcbiAgY29uc3QgeyBtb3ZlVG8gfSA9IHNwYW47XG4gIGNvbnN0IFtzdGFydDIsIGVuZDJdID0gc3BhblJhbmdlTm9ybWFsaXplZChzcGFuKTtcbiAgY29uc3QgeyB4OiBzcGFuWDAsIHk6IHNwYW5ZMCB9ID0gc3RhcnQyO1xuICBjb25zdCB7IHg6IHNwYW5YMSwgeTogc3BhblkxIH0gPSBlbmQyO1xuICBpZiAoeDEgPCBzcGFuWDApIHtcbiAgICByZXR1cm4gcmVzY2FsZVNwYW4oc3Bhbiwgc3RhcnQyLCBzdGFydDIpO1xuICB9IGVsc2UgaWYgKHgwID4gc3BhblgxKSB7XG4gICAgcmV0dXJuIHJlc2NhbGVTcGFuKHNwYW4sIGVuZDIsIGVuZDIpO1xuICB9XG4gIHN3aXRjaCAoc3Bhbi50eXBlKSB7XG4gICAgY2FzZSBcImxpbmVhclwiOiB7XG4gICAgICBjb25zdCBtID0gc3BhblkwID09PSBzcGFuWTEgPyB2b2lkIDAgOiAoc3BhblkxIC0gc3BhblkwKSAvIChzcGFuWDEgLSBzcGFuWDApO1xuICAgICAgY29uc3QgeTAgPSBtID09IG51bGwgPyBzcGFuWTAgOiBtICogKHgwIC0gc3BhblgwKSArIHNwYW5ZMDtcbiAgICAgIGNvbnN0IHkxID0gbSA9PSBudWxsID8gc3BhblkwIDogbSAqICh4MSAtIHNwYW5YMCkgKyBzcGFuWTA7XG4gICAgICByZXR1cm4geyB0eXBlOiBcImxpbmVhclwiLCBtb3ZlVG8sIHgwLCB5MCwgeDEsIHkxIH07XG4gICAgfVxuICAgIGNhc2UgXCJzdGVwXCI6XG4gICAgICBpZiAoeDEgPD0gc3Bhbi5zdGVwWCkge1xuICAgICAgICBjb25zdCB5ID0gc3Bhbi55MDtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdGVwXCIsIG1vdmVUbywgeDAsIHkwOiB5LCB4MSwgeTE6IHksIHN0ZXBYOiB4MSB9O1xuICAgICAgfSBlbHNlIGlmICh4MCA+PSBzcGFuLnN0ZXBYKSB7XG4gICAgICAgIGNvbnN0IHkgPSBzcGFuLnkxO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInN0ZXBcIiwgbW92ZVRvLCB4MCwgeTA6IHksIHgxLCB5MTogeSwgc3RlcFg6IHgwIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IHkwLCB5MSwgc3RlcFggfSA9IHNwYW47XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwic3RlcFwiLCBtb3ZlVG8sIHgwLCB5MCwgeDEsIHkxLCBzdGVwWCB9O1xuICAgICAgfVxuICAgIGNhc2UgXCJjdWJpY1wiOiB7XG4gICAgICBjb25zdCB0MCA9IHNvbHZlQmV6aWVyKHNwYW4uY3AweCwgc3Bhbi5jcDF4LCBzcGFuLmNwMngsIHNwYW4uY3AzeCwgeDApO1xuICAgICAgbGV0IFtfdW51c2VkLCBiZXppZXJdID0gc3BsaXRCZXppZXIoXG4gICAgICAgIHNwYW4uY3AweCxcbiAgICAgICAgc3Bhbi5jcDB5LFxuICAgICAgICBzcGFuLmNwMXgsXG4gICAgICAgIHNwYW4uY3AxeSxcbiAgICAgICAgc3Bhbi5jcDJ4LFxuICAgICAgICBzcGFuLmNwMnksXG4gICAgICAgIHNwYW4uY3AzeCxcbiAgICAgICAgc3Bhbi5jcDN5LFxuICAgICAgICB0MFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHQxID0gc29sdmVCZXppZXIoYmV6aWVyWzBdLngsIGJlemllclsxXS54LCBiZXppZXJbMl0ueCwgYmV6aWVyWzNdLngsIHgxKTtcbiAgICAgIFtiZXppZXIsIF91bnVzZWRdID0gc3BsaXRCZXppZXIoXG4gICAgICAgIGJlemllclswXS54LFxuICAgICAgICBiZXppZXJbMF0ueSxcbiAgICAgICAgYmV6aWVyWzFdLngsXG4gICAgICAgIGJlemllclsxXS55LFxuICAgICAgICBiZXppZXJbMl0ueCxcbiAgICAgICAgYmV6aWVyWzJdLnksXG4gICAgICAgIGJlemllclszXS54LFxuICAgICAgICBiZXppZXJbM10ueSxcbiAgICAgICAgdDFcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImN1YmljXCIsXG4gICAgICAgIG1vdmVUbyxcbiAgICAgICAgY3AweDogYmV6aWVyWzBdLngsXG4gICAgICAgIGNwMHk6IGJlemllclswXS55LFxuICAgICAgICBjcDF4OiBiZXppZXJbMV0ueCxcbiAgICAgICAgY3AxeTogYmV6aWVyWzFdLnksXG4gICAgICAgIGNwMng6IGJlemllclsyXS54LFxuICAgICAgICBjcDJ5OiBiZXppZXJbMl0ueSxcbiAgICAgICAgY3AzeDogYmV6aWVyWzNdLngsXG4gICAgICAgIGNwM3k6IGJlemllclszXS55XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbGluZWFyUG9pbnRzKHBvaW50cykge1xuICBjb25zdCBzcGFucyA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIGxldCB4MCA9IE5hTjtcbiAgbGV0IHkwID0gTmFOO1xuICBmb3IgKGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gb2YgcG9pbnRzKSB7XG4gICAgaWYgKGkgPiAwKSB7XG4gICAgICBjb25zdCBtb3ZlVG8gPSBpID09PSAxO1xuICAgICAgc3BhbnMucHVzaCh7IHR5cGU6IFwibGluZWFyXCIsIG1vdmVUbywgeDAsIHkwLCB4MSwgeTEgfSk7XG4gICAgfVxuICAgIGkgKz0gMTtcbiAgICB4MCA9IHgxO1xuICAgIHkwID0geTE7XG4gIH1cbiAgcmV0dXJuIHNwYW5zO1xufVxudmFyIGxpbmVTdGVwcyA9IHtcbiAgc3RhcnQ6IDAsXG4gIG1pZGRsZTogMC41LFxuICBlbmQ6IDFcbn07XG5mdW5jdGlvbiBzdGVwUG9pbnRzKHBvaW50cywgcG9zaXRpb24pIHtcbiAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgbGV0IGkgPSAwO1xuICBsZXQgeDAgPSBOYU47XG4gIGxldCB5MCA9IE5hTjtcbiAgY29uc3QgcDAgPSB0eXBlb2YgcG9zaXRpb24gPT09IFwibnVtYmVyXCIgPyBwb3NpdGlvbiA6IGxpbmVTdGVwc1twb3NpdGlvbl07XG4gIGZvciAoY29uc3QgeyB4OiB4MSwgeTogeTEgfSBvZiBwb2ludHMpIHtcbiAgICBpZiAoaSA+IDApIHtcbiAgICAgIGNvbnN0IG1vdmVUbyA9IGkgPT09IDE7XG4gICAgICBjb25zdCBzdGVwWCA9IHgwICsgKHgxIC0geDApICogcDA7XG4gICAgICBzcGFucy5wdXNoKHsgdHlwZTogXCJzdGVwXCIsIG1vdmVUbywgeDAsIHkwLCB4MSwgeTEsIHN0ZXBYIH0pO1xuICAgIH1cbiAgICBpICs9IDE7XG4gICAgeDAgPSB4MTtcbiAgICB5MCA9IHkxO1xuICB9XG4gIHJldHVybiBzcGFucztcbn1cbnZhciBmbGF0bmVzc1JhdGlvID0gMC4wNTtcbmZ1bmN0aW9uIHNtb290aFBvaW50cyhpUG9pbnRzLCB0ZW5zaW9uKSB7XG4gIGNvbnN0IHBvaW50cyA9IEFycmF5LmlzQXJyYXkoaVBvaW50cykgPyBpUG9pbnRzIDogQXJyYXkuZnJvbShpUG9pbnRzKTtcbiAgaWYgKHBvaW50cy5sZW5ndGggPD0gMSlcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IGdyYWRpZW50cyA9IHBvaW50cy5tYXAoKGMsIGkpID0+IHtcbiAgICBjb25zdCBwID0gaSA9PT0gMCA/IGMgOiBwb2ludHNbaSAtIDFdO1xuICAgIGNvbnN0IG4gPSBpID09PSBwb2ludHMubGVuZ3RoIC0gMSA/IGMgOiBwb2ludHNbaSArIDFdO1xuICAgIGNvbnN0IGlzVGVybWluYWxQb2ludCA9IGkgPT09IDAgfHwgaSA9PT0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgaWYgKE1hdGguc2lnbihwLnkgLSBjLnkpID09PSBNYXRoLnNpZ24obi55IC0gYy55KSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICghaXNUZXJtaW5hbFBvaW50KSB7XG4gICAgICBjb25zdCByYW5nZTMgPSBNYXRoLmFicyhwLnkgLSBuLnkpO1xuICAgICAgY29uc3QgcHJldlJhdGlvID0gTWF0aC5hYnMoYy55IC0gcC55KSAvIHJhbmdlMztcbiAgICAgIGNvbnN0IG5leHRSYXRpbyA9IE1hdGguYWJzKGMueSAtIG4ueSkgLyByYW5nZTM7XG4gICAgICBpZiAocHJldlJhdGlvIDw9IGZsYXRuZXNzUmF0aW8gfHwgMSAtIHByZXZSYXRpbyA8PSBmbGF0bmVzc1JhdGlvIHx8IG5leHRSYXRpbyA8PSBmbGF0bmVzc1JhdGlvIHx8IDEgLSBuZXh0UmF0aW8gPD0gZmxhdG5lc3NSYXRpbykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChuLnkgLSBwLnkpIC8gKG4ueCAtIHAueCk7XG4gIH0pO1xuICBpZiAoZ3JhZGllbnRzWzFdID09PSAwKSB7XG4gICAgZ3JhZGllbnRzWzBdICo9IDI7XG4gIH1cbiAgaWYgKGdyYWRpZW50c1tncmFkaWVudHMubGVuZ3RoIC0gMl0gPT09IDApIHtcbiAgICBncmFkaWVudHNbZ3JhZGllbnRzLmxlbmd0aCAtIDFdICo9IDI7XG4gIH1cbiAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBwcmV2ID0gcG9pbnRzW2kgLSAxXTtcbiAgICBjb25zdCBwcmV2TSA9IGdyYWRpZW50c1tpIC0gMV07XG4gICAgY29uc3QgY3VyID0gcG9pbnRzW2ldO1xuICAgIGNvbnN0IGN1ck0gPSBncmFkaWVudHNbaV07XG4gICAgY29uc3QgZHggPSBjdXIueCAtIHByZXYueDtcbiAgICBjb25zdCBkeSA9IGN1ci55IC0gcHJldi55O1xuICAgIGxldCBkY3AxeCA9IGR4ICogdGVuc2lvbiAvIDM7XG4gICAgbGV0IGRjcDF5ID0gZHggKiBwcmV2TSAqIHRlbnNpb24gLyAzO1xuICAgIGxldCBkY3AyeCA9IGR4ICogdGVuc2lvbiAvIDM7XG4gICAgbGV0IGRjcDJ5ID0gZHggKiBjdXJNICogdGVuc2lvbiAvIDM7XG4gICAgaWYgKGN1ck0gPT09IDAgJiYgTWF0aC5hYnMoZGNwMXkpID4gTWF0aC5hYnMoZHkpKSB7XG4gICAgICBkY3AxeCAqPSBNYXRoLmFicyhkeSAvIGRjcDF5KTtcbiAgICAgIGRjcDF5ID0gTWF0aC5zaWduKGRjcDF5KSAqIE1hdGguYWJzKGR5KTtcbiAgICB9XG4gICAgaWYgKHByZXZNID09PSAwICYmIE1hdGguYWJzKGRjcDJ5KSA+IE1hdGguYWJzKGR5KSkge1xuICAgICAgZGNwMnggKj0gTWF0aC5hYnMoZHkgLyBkY3AyeSk7XG4gICAgICBkY3AyeSA9IE1hdGguc2lnbihkY3AyeSkgKiBNYXRoLmFicyhkeSk7XG4gICAgfVxuICAgIHNwYW5zLnB1c2goe1xuICAgICAgdHlwZTogXCJjdWJpY1wiLFxuICAgICAgbW92ZVRvOiBpID09PSAxLFxuICAgICAgY3AweDogcHJldi54LFxuICAgICAgY3AweTogcHJldi55LFxuICAgICAgY3AxeDogcHJldi54ICsgZGNwMXgsXG4gICAgICBjcDF5OiBwcmV2LnkgKyBkY3AxeSxcbiAgICAgIGNwMng6IGN1ci54IC0gZGNwMngsXG4gICAgICBjcDJ5OiBjdXIueSAtIGRjcDJ5LFxuICAgICAgY3AzeDogY3VyLngsXG4gICAgICBjcDN5OiBjdXIueVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzcGFucztcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9saW5lSW50ZXJwb2xhdGlvblBsb3R0aW5nLnRzXG5mdW5jdGlvbiBsZXJwMihhLCBiLCByYXRpbzIpIHtcbiAgcmV0dXJuIChiIC0gYSkgKiByYXRpbzIgKyBhO1xufVxuZnVuY3Rpb24gbGluZWFyU3VwZXJ0eXBlKHNwYW4sIHN0ZXBYKSB7XG4gIGNvbnN0IHsgeDAsIHkwLCB4MSwgeTEgfSA9IHNwYW47XG4gIGNvbnN0IG0gPSAoeTEgLSB5MCkgLyAoeDEgLSB4MCk7XG4gIGNvbnN0IHN0ZXBZID0gbSAqIChzdGVwWCAtIHgwKSArIHkwO1xuICByZXR1cm4ge1xuICAgIGxlZnRDcDF4OiB4MCxcbiAgICBsZWZ0Q3AxeTogeTAsXG4gICAgbGVmdENwMng6IHN0ZXBYLFxuICAgIGxlZnRDcDJ5OiBzdGVwWSxcbiAgICBzdGVwWCxcbiAgICBzdGVwWTA6IHN0ZXBZLFxuICAgIHN0ZXBZMTogc3RlcFksXG4gICAgcmlnaHRDcDF4OiBzdGVwWCxcbiAgICByaWdodENwMXk6IHN0ZXBZLFxuICAgIHJpZ2h0Q3AyeDogeDEsXG4gICAgcmlnaHRDcDJ5OiB5MVxuICB9O1xufVxuZnVuY3Rpb24gYmV6aWVyU3VwZXJ0eXBlKHNwYW4sIHN0ZXBYKSB7XG4gIGNvbnN0IHsgY3AweCwgY3AweSwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgY3AzeCwgY3AzeSB9ID0gc3BhbjtcbiAgY29uc3QgdCA9IHNvbHZlQmV6aWVyKGNwMHgsIGNwMXgsIGNwMngsIGNwM3gsIHN0ZXBYKTtcbiAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IHNwbGl0QmV6aWVyKGNwMHgsIGNwMHksIGNwMXgsIGNwMXksIGNwMngsIGNwMnksIGNwM3gsIGNwM3ksIHQpO1xuICBjb25zdCBzdGVwWSA9IGxlZnRbM10ueTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0Q3AxeDogbGVmdFsxXS54LFxuICAgIGxlZnRDcDF5OiBsZWZ0WzFdLnksXG4gICAgbGVmdENwMng6IGxlZnRbMl0ueCxcbiAgICBsZWZ0Q3AyeTogbGVmdFsyXS55LFxuICAgIHN0ZXBYLFxuICAgIHN0ZXBZMDogc3RlcFksXG4gICAgc3RlcFkxOiBzdGVwWSxcbiAgICByaWdodENwMXg6IHJpZ2h0WzFdLngsXG4gICAgcmlnaHRDcDF5OiByaWdodFsxXS55LFxuICAgIHJpZ2h0Q3AyeDogcmlnaHRbMl0ueCxcbiAgICByaWdodENwMnk6IHJpZ2h0WzJdLnlcbiAgfTtcbn1cbmZ1bmN0aW9uIHN0ZXBTdXBlcnR5cGUoc3Bhbikge1xuICBjb25zdCB7IHgwLCB5MCwgeDEsIHkxLCBzdGVwWCB9ID0gc3BhbjtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0Q3AxeDogKHgwICsgc3RlcFgpIC8gMixcbiAgICBsZWZ0Q3AxeTogeTAsXG4gICAgbGVmdENwMng6ICh4MCArIHN0ZXBYKSAvIDIsXG4gICAgbGVmdENwMnk6IHkwLFxuICAgIHN0ZXBYLFxuICAgIHN0ZXBZMDogeTAsXG4gICAgc3RlcFkxOiB5MSxcbiAgICByaWdodENwMXg6IChzdGVwWCArIHgxKSAvIDIsXG4gICAgcmlnaHRDcDF5OiB5MSxcbiAgICByaWdodENwMng6IChzdGVwWCArIHgxKSAvIDIsXG4gICAgcmlnaHRDcDJ5OiB5MVxuICB9O1xufVxuZnVuY3Rpb24gc3BhblN1cGVydHlwZShzcGFuLCBzdGVwWCkge1xuICBpZiAoc3Bhbi50eXBlID09PSBcImxpbmVhclwiKSB7XG4gICAgcmV0dXJuIGxpbmVhclN1cGVydHlwZShzcGFuLCBzdGVwWCk7XG4gIH0gZWxzZSBpZiAoc3Bhbi50eXBlID09PSBcImN1YmljXCIpIHtcbiAgICByZXR1cm4gYmV6aWVyU3VwZXJ0eXBlKHNwYW4sIHN0ZXBYKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RlcFN1cGVydHlwZShzcGFuKTtcbiAgfVxufVxuZnVuY3Rpb24gcGxvdFN0YXJ0KHBhdGgsIG1vdmVUbywgeDAsIHkwLCB4MSwgeTEsIHJldmVyc2VkKSB7XG4gIHN3aXRjaCAobW92ZVRvKSB7XG4gICAgY2FzZSAwIC8qIE1vdmVUbyAqLzpcbiAgICAgIGlmIChyZXZlcnNlZCkge1xuICAgICAgICBwYXRoLm1vdmVUbyh4MSwgeTEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aC5tb3ZlVG8oeDAsIHkwKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMSAvKiBMaW5lVG8gKi86XG4gICAgICBpZiAocmV2ZXJzZWQpIHtcbiAgICAgICAgcGF0aC5saW5lVG8oeDEsIHkxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGgubGluZVRvKHgwLCB5MCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufVxuZnVuY3Rpb24gcGxvdExpbmVhcihwYXRoLCB4MCwgeTAsIHgxLCB5MSwgcmV2ZXJzZWQpIHtcbiAgaWYgKHJldmVyc2VkKSB7XG4gICAgcGF0aC5saW5lVG8oeDAsIHkwKTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoLmxpbmVUbyh4MSwgeTEpO1xuICB9XG59XG5mdW5jdGlvbiBwbG90Q3ViaWMocGF0aCwgY3AweCwgY3AweSwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgY3AzeCwgY3AzeSwgcmV2ZXJzZWQpIHtcbiAgaWYgKHJldmVyc2VkKSB7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oY3AyeCwgY3AyeSwgY3AxeCwgY3AxeSwgY3AweCwgY3AweSk7XG4gIH0gZWxzZSB7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgY3AzeCwgY3AzeSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBsb3RTdGVwKHBhdGgsIHgwLCB5MCwgeDEsIHkxLCBzdGVwWCwgcmV2ZXJzZWQpIHtcbiAgaWYgKHJldmVyc2VkKSB7XG4gICAgcGF0aC5saW5lVG8oc3RlcFgsIHkxKTtcbiAgICBwYXRoLmxpbmVUbyhzdGVwWCwgeTApO1xuICAgIHBhdGgubGluZVRvKHgwLCB5MCk7XG4gIH0gZWxzZSB7XG4gICAgcGF0aC5saW5lVG8oc3RlcFgsIHkwKTtcbiAgICBwYXRoLmxpbmVUbyhzdGVwWCwgeTEpO1xuICAgIHBhdGgubGluZVRvKHgxLCB5MSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBsb3RTcGFuKHBhdGgsIHNwYW4sIG1vdmVUbywgcmV2ZXJzZWQpIHtcbiAgY29uc3QgW3N0YXJ0MiwgZW5kMl0gPSBzcGFuUmFuZ2Uoc3Bhbik7XG4gIHBsb3RTdGFydChwYXRoLCBtb3ZlVG8sIHN0YXJ0Mi54LCBzdGFydDIueSwgZW5kMi54LCBlbmQyLnksIHJldmVyc2VkKTtcbiAgc3dpdGNoIChzcGFuLnR5cGUpIHtcbiAgICBjYXNlIFwibGluZWFyXCI6XG4gICAgICBwbG90TGluZWFyKHBhdGgsIHNwYW4ueDAsIHNwYW4ueTAsIHNwYW4ueDEsIHNwYW4ueTEsIHJldmVyc2VkKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjdWJpY1wiOlxuICAgICAgcGxvdEN1YmljKFxuICAgICAgICBwYXRoLFxuICAgICAgICBzcGFuLmNwMHgsXG4gICAgICAgIHNwYW4uY3AweSxcbiAgICAgICAgc3Bhbi5jcDF4LFxuICAgICAgICBzcGFuLmNwMXksXG4gICAgICAgIHNwYW4uY3AyeCxcbiAgICAgICAgc3Bhbi5jcDJ5LFxuICAgICAgICBzcGFuLmNwM3gsXG4gICAgICAgIHNwYW4uY3AzeSxcbiAgICAgICAgcmV2ZXJzZWRcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic3RlcFwiOlxuICAgICAgcGxvdFN0ZXAocGF0aCwgc3Bhbi54MCwgc3Bhbi55MCwgc3Bhbi54MSwgc3Bhbi55MSwgc3Bhbi5zdGVwWCwgcmV2ZXJzZWQpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlZFNwYW5SYW5nZShhLCBiLCByYXRpbzIpIHtcbiAgY29uc3QgW2FTdGFydCwgYUVuZF0gPSBzcGFuUmFuZ2UoYSk7XG4gIGNvbnN0IFtiU3RhcnQsIGJFbmRdID0gc3BhblJhbmdlKGIpO1xuICBjb25zdCB4MCA9IGxlcnAyKGFTdGFydC54LCBiU3RhcnQueCwgcmF0aW8yKTtcbiAgY29uc3QgeTAgPSBsZXJwMihhU3RhcnQueSwgYlN0YXJ0LnksIHJhdGlvMik7XG4gIGNvbnN0IHgxID0gbGVycDIoYUVuZC54LCBiRW5kLngsIHJhdGlvMik7XG4gIGNvbnN0IHkxID0gbGVycDIoYUVuZC55LCBiRW5kLnksIHJhdGlvMik7XG4gIHJldHVybiBbXG4gICAgeyB4OiB4MCwgeTogeTAgfSxcbiAgICB7IHg6IHgxLCB5OiB5MSB9XG4gIF07XG59XG5mdW5jdGlvbiBwbG90SW50ZXJwb2xhdGVkU3BhbnMocGF0aCwgYSwgYiwgcmF0aW8yLCBtb3ZlVG8sIHJldmVyc2VkKSB7XG4gIGNvbnN0IFt7IHg6IHgwLCB5OiB5MCB9LCB7IHg6IHgxLCB5OiB5MSB9XSA9IGludGVycG9sYXRlZFNwYW5SYW5nZShhLCBiLCByYXRpbzIpO1xuICBwbG90U3RhcnQocGF0aCwgbW92ZVRvLCB4MCwgeTAsIHgxLCB5MSwgcmV2ZXJzZWQpO1xuICBpZiAoYS50eXBlID09PSBcImN1YmljXCIgJiYgYi50eXBlID09PSBcImN1YmljXCIpIHtcbiAgICBjb25zdCBjcDF4ID0gbGVycDIoYS5jcDF4LCBiLmNwMXgsIHJhdGlvMik7XG4gICAgY29uc3QgY3AxeSA9IGxlcnAyKGEuY3AxeSwgYi5jcDF5LCByYXRpbzIpO1xuICAgIGNvbnN0IGNwMnggPSBsZXJwMihhLmNwMngsIGIuY3AyeCwgcmF0aW8yKTtcbiAgICBjb25zdCBjcDJ5ID0gbGVycDIoYS5jcDJ5LCBiLmNwMnksIHJhdGlvMik7XG4gICAgcGxvdEN1YmljKHBhdGgsIHgwLCB5MCwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeDEsIHkxLCByZXZlcnNlZCk7XG4gIH0gZWxzZSBpZiAoYS50eXBlID09PSBcInN0ZXBcIiAmJiBiLnR5cGUgPT09IFwic3RlcFwiKSB7XG4gICAgY29uc3Qgc3RlcFggPSBsZXJwMihhLnN0ZXBYLCBiLnN0ZXBYLCByYXRpbzIpO1xuICAgIHBsb3RTdGVwKHBhdGgsIHgwLCB5MCwgeDEsIHkxLCBzdGVwWCwgcmV2ZXJzZWQpO1xuICB9IGVsc2UgaWYgKGEudHlwZSA9PT0gXCJsaW5lYXJcIiAmJiBiLnR5cGUgPT09IFwibGluZWFyXCIpIHtcbiAgICBwbG90TGluZWFyKHBhdGgsIHgwLCB5MCwgeDEsIHkxLCByZXZlcnNlZCk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGRlZmF1bHRTdGVwWDtcbiAgICBpZiAoYS50eXBlID09PSBcInN0ZXBcIikge1xuICAgICAgZGVmYXVsdFN0ZXBYID0gYS5zdGVwWDtcbiAgICB9IGVsc2UgaWYgKGIudHlwZSA9PT0gXCJzdGVwXCIpIHtcbiAgICAgIGRlZmF1bHRTdGVwWCA9IGIuc3RlcFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRTdGVwWCA9ICh4MCArIHgxKSAvIDI7XG4gICAgfVxuICAgIGNvbnN0IGFzID0gc3BhblN1cGVydHlwZShhLCBkZWZhdWx0U3RlcFgpO1xuICAgIGNvbnN0IGJzID0gc3BhblN1cGVydHlwZShiLCBkZWZhdWx0U3RlcFgpO1xuICAgIGNvbnN0IGxlZnRDcDF4ID0gbGVycDIoYXMubGVmdENwMXgsIGJzLmxlZnRDcDF4LCByYXRpbzIpO1xuICAgIGNvbnN0IGxlZnRDcDF5ID0gbGVycDIoYXMubGVmdENwMXksIGJzLmxlZnRDcDF5LCByYXRpbzIpO1xuICAgIGNvbnN0IGxlZnRDcDJ4ID0gbGVycDIoYXMubGVmdENwMngsIGJzLmxlZnRDcDJ4LCByYXRpbzIpO1xuICAgIGNvbnN0IGxlZnRDcDJ5ID0gbGVycDIoYXMubGVmdENwMnksIGJzLmxlZnRDcDJ5LCByYXRpbzIpO1xuICAgIGNvbnN0IHN0ZXBYID0gbGVycDIoYXMuc3RlcFgsIGJzLnN0ZXBYLCByYXRpbzIpO1xuICAgIGNvbnN0IHN0ZXBZMCA9IGxlcnAyKGFzLnN0ZXBZMCwgYnMuc3RlcFkwLCByYXRpbzIpO1xuICAgIGNvbnN0IHN0ZXBZMSA9IGxlcnAyKGFzLnN0ZXBZMSwgYnMuc3RlcFkxLCByYXRpbzIpO1xuICAgIGNvbnN0IHJpZ2h0Q3AxeCA9IGxlcnAyKGFzLnJpZ2h0Q3AxeCwgYnMucmlnaHRDcDF4LCByYXRpbzIpO1xuICAgIGNvbnN0IHJpZ2h0Q3AxeSA9IGxlcnAyKGFzLnJpZ2h0Q3AxeSwgYnMucmlnaHRDcDF5LCByYXRpbzIpO1xuICAgIGNvbnN0IHJpZ2h0Q3AyeCA9IGxlcnAyKGFzLnJpZ2h0Q3AyeCwgYnMucmlnaHRDcDJ4LCByYXRpbzIpO1xuICAgIGNvbnN0IHJpZ2h0Q3AyeSA9IGxlcnAyKGFzLnJpZ2h0Q3AyeSwgYnMucmlnaHRDcDJ5LCByYXRpbzIpO1xuICAgIGlmIChyZXZlcnNlZCkge1xuICAgICAgcGF0aC5jdWJpY0N1cnZlVG8ocmlnaHRDcDJ4LCByaWdodENwMnksIHJpZ2h0Q3AxeCwgcmlnaHRDcDF5LCBzdGVwWCwgc3RlcFkxKTtcbiAgICAgIHBhdGgubGluZVRvKHN0ZXBYLCBzdGVwWTApO1xuICAgICAgcGF0aC5jdWJpY0N1cnZlVG8obGVmdENwMngsIGxlZnRDcDJ5LCBsZWZ0Q3AxeCwgbGVmdENwMXksIHgwLCB5MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGguY3ViaWNDdXJ2ZVRvKGxlZnRDcDF4LCBsZWZ0Q3AxeSwgbGVmdENwMngsIGxlZnRDcDJ5LCBzdGVwWCwgc3RlcFkwKTtcbiAgICAgIHBhdGgubGluZVRvKHN0ZXBYLCBzdGVwWTEpO1xuICAgICAgcGF0aC5jdWJpY0N1cnZlVG8ocmlnaHRDcDF4LCByaWdodENwMXksIHJpZ2h0Q3AyeCwgcmlnaHRDcDJ5LCB4MSwgeTEpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xpbmVJbnRlcnBvbGF0aW9uVXRpbC50c1xudmFyIENvbGxhcHNlTW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKENvbGxhcHNlTW9kZTIpID0+IHtcbiAgQ29sbGFwc2VNb2RlMltDb2xsYXBzZU1vZGUyW1wiWmVyb1wiXSA9IDBdID0gXCJaZXJvXCI7XG4gIENvbGxhcHNlTW9kZTJbQ29sbGFwc2VNb2RlMltcIlNwbGl0XCJdID0gMV0gPSBcIlNwbGl0XCI7XG4gIHJldHVybiBDb2xsYXBzZU1vZGUyO1xufSkoQ29sbGFwc2VNb2RlIHx8IHt9KTtcbmZ1bmN0aW9uIGludGVncmF0ZWRDYXRlZ29yeU1hdGNoKGEsIGIpIHtcbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGEgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGIgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoXCJpZFwiIGluIGEgJiYgXCJpZFwiIGluIGIpIHtcbiAgICByZXR1cm4gYS5pZCA9PT0gYi5pZDtcbiAgfVxuICByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBzY2FsZSh2YWwsIHNjYWxpbmcpIHtcbiAgaWYgKCFzY2FsaW5nKVxuICAgIHJldHVybiBOYU47XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgdmFsID0gdmFsLmdldFRpbWUoKTtcbiAgfVxuICBpZiAoc2NhbGluZy50eXBlID09PSBcImNvbnRpbnVvdXNcIiAmJiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgY29uc3QgZG9tYWluUmF0aW8gPSAodmFsIC0gc2NhbGluZy5kb21haW5bMF0pIC8gKHNjYWxpbmcuZG9tYWluWzFdIC0gc2NhbGluZy5kb21haW5bMF0pO1xuICAgIHJldHVybiBkb21haW5SYXRpbyAqIChzY2FsaW5nLnJhbmdlWzFdIC0gc2NhbGluZy5yYW5nZVswXSkgKyBzY2FsaW5nLnJhbmdlWzBdO1xuICB9XG4gIGlmIChzY2FsaW5nLnR5cGUgPT09IFwibG9nXCIgJiYgdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBzY2FsaW5nLmNvbnZlcnQodmFsKTtcbiAgfVxuICBpZiAoc2NhbGluZy50eXBlICE9PSBcImNhdGVnb3J5XCIpXG4gICAgcmV0dXJuIE5hTjtcbiAgY29uc3QgbWF0Y2hpbmdJbmRleCA9IHNjYWxpbmcuZG9tYWluLmZpbmRJbmRleCgoZCkgPT4gZCA9PT0gdmFsKTtcbiAgaWYgKG1hdGNoaW5nSW5kZXggPj0gMCkge1xuICAgIHJldHVybiBzY2FsaW5nLmluc2V0ICsgc2NhbGluZy5zdGVwICogbWF0Y2hpbmdJbmRleDtcbiAgfVxuICBjb25zdCBtYXRjaGluZ0ludGVncmF0ZWRJbmRleCA9IHNjYWxpbmcuZG9tYWluLmZpbmRJbmRleCgoZCkgPT4gaW50ZWdyYXRlZENhdGVnb3J5TWF0Y2godmFsLCBkKSk7XG4gIGlmIChtYXRjaGluZ0ludGVncmF0ZWRJbmRleCA+PSAwKSB7XG4gICAgcmV0dXJuIHNjYWxpbmcuaW5zZXQgKyBzY2FsaW5nLnN0ZXAgKiBtYXRjaGluZ0luZGV4O1xuICB9XG4gIHJldHVybiBOYU47XG59XG5mdW5jdGlvbiB0b0F4aXNWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gdHJhbnNmb3JtSW50ZWdyYXRlZENhdGVnb3J5VmFsdWUodmFsdWUpLnZhbHVlT2YoKTtcbn1cbmZ1bmN0aW9uIGdldEF4aXNJbmRpY2VzKHsgZGF0YSB9LCB2YWx1ZXMpIHtcbiAgcmV0dXJuIGRhdGEubWFwKChkYXR1bSwgZGF0dW1JbmRleCkgPT4gKHtcbiAgICB4VmFsdWUwSW5kZXg6IHZhbHVlcy5pbmRleE9mKHRvQXhpc1ZhbHVlKGRhdHVtLnhWYWx1ZTApKSxcbiAgICB4VmFsdWUxSW5kZXg6IHZhbHVlcy5pbmRleE9mKHRvQXhpc1ZhbHVlKGRhdHVtLnhWYWx1ZTEpKSxcbiAgICBkYXR1bUluZGV4XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ2F0ZWdvcnlTb3J0aW5nKG5ld0RhdGEsIG9sZERhdGEpIHtcbiAgY29uc3Qgb2xkU2NhbGUgPSBvbGREYXRhLnNjYWxlcy54O1xuICBjb25zdCBuZXdTY2FsZSA9IG5ld0RhdGEuc2NhbGVzLng7XG4gIGlmIChvbGRTY2FsZT8udHlwZSAhPT0gXCJjYXRlZ29yeVwiIHx8IG5ld1NjYWxlPy50eXBlICE9PSBcImNhdGVnb3J5XCIpXG4gICAgcmV0dXJuIHRydWU7XG4gIGxldCB4MCA9IC1JbmZpbml0eTtcbiAgZm9yIChjb25zdCBvbGRWYWx1ZSBvZiBvbGRTY2FsZS5kb21haW4pIHtcbiAgICBjb25zdCB4ID0gc2NhbGUob2xkVmFsdWUsIG5ld1NjYWxlKTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICh4IDwgeDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDAgPSB4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQXhpc0VudHJpZXNPcmRlcihheGlzVmFsdWVzLCBkYXRhKSB7XG4gIGxldCB4MCA9IC1JbmZpbml0eTtcbiAgZm9yIChjb25zdCBheGlzVmFsdWUgb2YgYXhpc1ZhbHVlcykge1xuICAgIGNvbnN0IHggPSBzY2FsZShheGlzVmFsdWUudmFsdWUsIGRhdGEuc2NhbGVzLngpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKHggPCB4MCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB4MCA9IHg7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc3BhbkF4aXNDb250ZXh0KG5ld0RhdGEsIG9sZERhdGEpIHtcbiAgY29uc3QgYWxsQXhpc0VudHJpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IHsgeFZhbHVlMCwgeFZhbHVlMSB9IG9mIG5ld0RhdGEuZGF0YSkge1xuICAgIGNvbnN0IHhWYWx1ZTBWYWx1ZSA9IHRvQXhpc1ZhbHVlKHhWYWx1ZTApO1xuICAgIGNvbnN0IHhWYWx1ZTFWYWx1ZSA9IHRvQXhpc1ZhbHVlKHhWYWx1ZTEpO1xuICAgIGFsbEF4aXNFbnRyaWVzLnNldCh4VmFsdWUwVmFsdWUsIHhWYWx1ZTApLnNldCh4VmFsdWUxVmFsdWUsIHhWYWx1ZTEpO1xuICB9XG4gIGNvbnN0IG5ld0F4aXNFbnRyaWVzID0gQXJyYXkuZnJvbShhbGxBeGlzRW50cmllcywgKFtheGlzVmFsdWUsIHZhbHVlXSkgPT4gKHsgYXhpc1ZhbHVlLCB2YWx1ZSB9KSk7XG4gIG5ld0F4aXNFbnRyaWVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICByZXR1cm4gc2NhbGUoYS52YWx1ZSwgbmV3RGF0YS5zY2FsZXMueCkgLSBzY2FsZShiLnZhbHVlLCBuZXdEYXRhLnNjYWxlcy54KTtcbiAgfSk7XG4gIGNvbnN0IGV4Y2x1c2l2ZWx5T2xkQXhpc0VudHJpZXMgPSBbXTtcbiAgZm9yIChjb25zdCB7IHhWYWx1ZTAsIHhWYWx1ZTEgfSBvZiBvbGREYXRhLmRhdGEpIHtcbiAgICBjb25zdCB4VmFsdWUwVmFsdWUgPSB0b0F4aXNWYWx1ZSh4VmFsdWUwKTtcbiAgICBjb25zdCB4VmFsdWUxVmFsdWUgPSB0b0F4aXNWYWx1ZSh4VmFsdWUxKTtcbiAgICBpZiAoIWFsbEF4aXNFbnRyaWVzLmhhcyh4VmFsdWUwVmFsdWUpKSB7XG4gICAgICBhbGxBeGlzRW50cmllcy5zZXQoeFZhbHVlMFZhbHVlLCB4VmFsdWUwKTtcbiAgICAgIGV4Y2x1c2l2ZWx5T2xkQXhpc0VudHJpZXMucHVzaCh7IGF4aXNWYWx1ZTogeFZhbHVlMFZhbHVlLCB2YWx1ZTogeFZhbHVlMCB9KTtcbiAgICB9XG4gICAgaWYgKCFhbGxBeGlzRW50cmllcy5oYXMoeFZhbHVlMVZhbHVlKSkge1xuICAgICAgYWxsQXhpc0VudHJpZXMuc2V0KHhWYWx1ZTFWYWx1ZSwgeFZhbHVlMSk7XG4gICAgICBleGNsdXNpdmVseU9sZEF4aXNFbnRyaWVzLnB1c2goeyBheGlzVmFsdWU6IHhWYWx1ZTFWYWx1ZSwgdmFsdWU6IHhWYWx1ZTEgfSk7XG4gICAgfVxuICB9XG4gIGV4Y2x1c2l2ZWx5T2xkQXhpc0VudHJpZXMuc29ydCgoYSwgYikgPT4ge1xuICAgIHJldHVybiBzY2FsZShhLnZhbHVlLCBvbGREYXRhLnNjYWxlcy54KSAtIHNjYWxlKGIudmFsdWUsIG9sZERhdGEuc2NhbGVzLngpO1xuICB9KTtcbiAgY29uc3QgYXhpc0VudHJpZXMgPSBuZXdBeGlzRW50cmllcztcbiAgbGV0IGluc2VydGlvbkluZGV4ID0gMDtcbiAgZm9yIChjb25zdCBvbGRBeGlzRW50cmllcyBvZiBleGNsdXNpdmVseU9sZEF4aXNFbnRyaWVzKSB7XG4gICAgZm9yIChsZXQgaSA9IGF4aXNFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPiBpbnNlcnRpb25JbmRleDsgaSAtPSAxKSB7XG4gICAgICBjb25zdCBvbGRWYWx1ZVggPSBzY2FsZShvbGRBeGlzRW50cmllcy52YWx1ZSwgb2xkRGF0YS5zY2FsZXMueCk7XG4gICAgICBjb25zdCBuZXdWYWx1ZVggPSBzY2FsZShheGlzRW50cmllc1tpXS52YWx1ZSwgb2xkRGF0YS5zY2FsZXMueCk7XG4gICAgICBpZiAob2xkVmFsdWVYID4gbmV3VmFsdWVYKSB7XG4gICAgICAgIGluc2VydGlvbkluZGV4ID0gaSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBheGlzRW50cmllcy5zcGxpY2UoaW5zZXJ0aW9uSW5kZXgsIDAsIG9sZEF4aXNFbnRyaWVzKTtcbiAgICBpbnNlcnRpb25JbmRleCArPSAxO1xuICB9XG4gIGlmICghdmFsaWRhdGVBeGlzRW50cmllc09yZGVyKGF4aXNFbnRyaWVzLCBvbGREYXRhKSlcbiAgICByZXR1cm47XG4gIGNvbnN0IGF4aXNWYWx1ZXMgPSBheGlzRW50cmllcy5tYXAoKGF4aXNFbnRyeSkgPT4gYXhpc0VudHJ5LmF4aXNWYWx1ZSk7XG4gIGNvbnN0IG9sZERhdGFBeGlzSW5kaWNlcyA9IGdldEF4aXNJbmRpY2VzKG9sZERhdGEsIGF4aXNWYWx1ZXMpO1xuICBjb25zdCBuZXdEYXRhQXhpc0luZGljZXMgPSBnZXRBeGlzSW5kaWNlcyhuZXdEYXRhLCBheGlzVmFsdWVzKTtcbiAgcmV0dXJuIHsgYXhpc1ZhbHVlcywgb2xkRGF0YUF4aXNJbmRpY2VzLCBuZXdEYXRhQXhpc0luZGljZXMgfTtcbn1cbmZ1bmN0aW9uIGNsaXBTcGFuKHNwYW4sIHhWYWx1ZTBJbmRleCwgeEluZGljZXMpIHtcbiAgaWYgKHhJbmRpY2VzLnhWYWx1ZTFJbmRleCA9PT0geEluZGljZXMueFZhbHVlMEluZGV4ICsgMSlcbiAgICByZXR1cm4gc3BhbjtcbiAgY29uc3QgcmFuZ2UzID0gc3BhblJhbmdlKHNwYW4pO1xuICBjb25zdCBzdGVwID0gKHJhbmdlM1sxXS54IC0gcmFuZ2UzWzBdLngpIC8gKHhJbmRpY2VzLnhWYWx1ZTFJbmRleCAtIHhJbmRpY2VzLnhWYWx1ZTBJbmRleCk7XG4gIGNvbnN0IHN0YXJ0MiA9IHJhbmdlM1swXS54ICsgKHhWYWx1ZTBJbmRleCAtIHhJbmRpY2VzLnhWYWx1ZTBJbmRleCkgKiBzdGVwO1xuICBjb25zdCBlbmQyID0gc3RhcnQyICsgc3RlcDtcbiAgcmV0dXJuIGNsaXBTcGFuWChzcGFuLCBzdGFydDIsIGVuZDIpO1xufVxuZnVuY3Rpb24gYXhpc1plcm9TcGFuKHNwYW4sIGRhdGEpIHtcbiAgY29uc3QgW3IwLCByMV0gPSBzcGFuUmFuZ2Uoc3Bhbik7XG4gIGNvbnN0IHkwID0gc2NhbGUoMCwgZGF0YS5zY2FsZXMueSk7XG4gIHJldHVybiByZXNjYWxlU3BhbihzcGFuLCB7IHg6IHIwLngsIHk6IHkwIH0sIHsgeDogcjEueCwgeTogeTAgfSk7XG59XG5mdW5jdGlvbiBjb2xsYXBzZVNwYW5Ub01pZHBvaW50KHNwYW4pIHtcbiAgY29uc3QgW3IwLCByMV0gPSBzcGFuUmFuZ2Uoc3Bhbik7XG4gIHJldHVybiBjb2xsYXBzZVNwYW5Ub1BvaW50KHNwYW4sIHtcbiAgICB4OiAocjAueCArIHIxLngpIC8gMixcbiAgICB5OiAocjAueSArIHIxLnkpIC8gMlxuICB9KTtcbn1cbmZ1bmN0aW9uIGNvbGxhcHNlU3BhbihzcGFuLCBjb2xsYXBzZU1vZGUsIGRhdGEsIGF4aXNJbmRpY2VzLCBpbmRpY2VzLCByYW5nZTMpIHtcbiAgbGV0IHhWYWx1ZTtcbiAgbGV0IHlWYWx1ZTtcbiAgaWYgKGluZGljZXMueFZhbHVlMEluZGV4ID49IHJhbmdlMy54VmFsdWUxSW5kZXgpIHtcbiAgICBjb25zdCBkYXR1bUluZGV4ID0gYXhpc0luZGljZXMuZmluZExhc3QoKGkpID0+IGkueFZhbHVlMUluZGV4IDw9IHJhbmdlMy54VmFsdWUxSW5kZXgpPy5kYXR1bUluZGV4O1xuICAgIGNvbnN0IGRhdHVtID0gZGF0dW1JbmRleCAhPSBudWxsID8gZGF0YS5kYXRhW2RhdHVtSW5kZXhdIDogdm9pZCAwO1xuICAgIHhWYWx1ZSA9IGRhdHVtPy54VmFsdWUxO1xuICAgIHlWYWx1ZSA9IGRhdHVtPy55VmFsdWUxO1xuICB9IGVsc2UgaWYgKGluZGljZXMueFZhbHVlMEluZGV4IDw9IHJhbmdlMy54VmFsdWUwSW5kZXgpIHtcbiAgICBjb25zdCBkYXR1bUluZGV4ID0gYXhpc0luZGljZXMuZmluZCgoaSkgPT4gaS54VmFsdWUwSW5kZXggPj0gcmFuZ2UzLnhWYWx1ZTBJbmRleCk/LmRhdHVtSW5kZXg7XG4gICAgY29uc3QgZGF0dW0gPSBkYXR1bUluZGV4ICE9IG51bGwgPyBkYXRhLmRhdGFbZGF0dW1JbmRleF0gOiB2b2lkIDA7XG4gICAgeFZhbHVlID0gZGF0dW0/LnhWYWx1ZTA7XG4gICAgeVZhbHVlID0gZGF0dW0/LnlWYWx1ZTA7XG4gIH1cbiAgaWYgKHhWYWx1ZSA9PSBudWxsIHx8IHlWYWx1ZSA9PSBudWxsKSB7XG4gICAgc3dpdGNoIChjb2xsYXBzZU1vZGUpIHtcbiAgICAgIGNhc2UgMCAvKiBaZXJvICovOlxuICAgICAgICByZXR1cm4gYXhpc1plcm9TcGFuKHNwYW4sIGRhdGEpO1xuICAgICAgY2FzZSAxIC8qIFNwbGl0ICovOlxuICAgICAgICByZXR1cm4gY29sbGFwc2VTcGFuVG9NaWRwb2ludChzcGFuKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgeCA9IHNjYWxlKHhWYWx1ZSwgZGF0YS5zY2FsZXMueCk7XG4gIGNvbnN0IHkgPSBzY2FsZSh5VmFsdWUsIGRhdGEuc2NhbGVzLnkpO1xuICBjb25zdCBwb2ludCA9IHsgeCwgeSB9O1xuICByZXR1cm4gcmVzY2FsZVNwYW4oc3BhbiwgcG9pbnQsIHBvaW50KTtcbn1cbmZ1bmN0aW9uIHplcm9EYXRhU3BhbihzcGFuRGF0dW0sIHplcm9EYXRhKSB7XG4gIGlmICh6ZXJvRGF0YSA9PSBudWxsKVxuICAgIHJldHVybjtcbiAgY29uc3QgbmV3U3BhblhWYWx1ZTAgPSB0b0F4aXNWYWx1ZShzcGFuRGF0dW0ueFZhbHVlMCk7XG4gIGNvbnN0IG5ld1NwYW5YVmFsdWUxID0gdG9BeGlzVmFsdWUoc3BhbkRhdHVtLnhWYWx1ZTEpO1xuICByZXR1cm4gemVyb0RhdGEuZmluZChcbiAgICAoemVyb1NwYW5EYXR1bSkgPT4gdG9BeGlzVmFsdWUoemVyb1NwYW5EYXR1bS54VmFsdWUwKSA9PT0gbmV3U3BhblhWYWx1ZTAgJiYgdG9BeGlzVmFsdWUoemVyb1NwYW5EYXR1bS54VmFsdWUxKSA9PT0gbmV3U3BhblhWYWx1ZTFcbiAgKT8uc3Bhbjtcbn1cbmZ1bmN0aW9uIGFkZFNwYW4obmV3RGF0YSwgY29sbGFwc2VNb2RlLCBuZXdBeGlzSW5kaWNlcywgbmV3SW5kaWNlcywgb2xkWmVyb0RhdGEsIHJhbmdlMywgb3V0KSB7XG4gIGNvbnN0IG5ld1NwYW5EYXR1bSA9IG5ld0RhdGEuZGF0YVtuZXdJbmRpY2VzLmRhdHVtSW5kZXhdO1xuICBjb25zdCBuZXdTcGFuID0gbmV3U3BhbkRhdHVtLnNwYW47XG4gIGNvbnN0IHplcm9TcGFuID0gemVyb0RhdGFTcGFuKG5ld1NwYW5EYXR1bSwgb2xkWmVyb0RhdGEpO1xuICBpZiAoemVyb1NwYW4gIT0gbnVsbCkge1xuICAgIG91dC5yZW1vdmVkLnB1c2goeyBmcm9tOiB6ZXJvU3BhbiwgdG86IHplcm9TcGFuIH0pO1xuICAgIG91dC5tb3ZlZC5wdXNoKHsgZnJvbTogemVyb1NwYW4sIHRvOiBuZXdTcGFuIH0pO1xuICAgIG91dC5hZGRlZC5wdXNoKHsgZnJvbTogbmV3U3BhbiwgdG86IG5ld1NwYW4gfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgb2xkU3BhbiA9IGNvbGxhcHNlU3BhbihuZXdTcGFuLCBjb2xsYXBzZU1vZGUsIG5ld0RhdGEsIG5ld0F4aXNJbmRpY2VzLCBuZXdJbmRpY2VzLCByYW5nZTMpO1xuICAgIG91dC5hZGRlZC5wdXNoKHsgZnJvbTogb2xkU3BhbiwgdG86IG5ld1NwYW4gfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZVNwYW4ob2xkRGF0YSwgY29sbGFwc2VNb2RlLCBvbGRBeGlzSW5kaWNlcywgb2xkSW5kaWNlcywgbmV3WmVyb0RhdGEsIHJhbmdlMywgb3V0KSB7XG4gIGNvbnN0IG9sZFNwYW5EYXR1bSA9IG9sZERhdGEuZGF0YVtvbGRJbmRpY2VzLmRhdHVtSW5kZXhdO1xuICBjb25zdCBvbGRTcGFuID0gb2xkU3BhbkRhdHVtLnNwYW47XG4gIGNvbnN0IHplcm9TcGFuID0gemVyb0RhdGFTcGFuKG9sZFNwYW5EYXR1bSwgbmV3WmVyb0RhdGEpO1xuICBpZiAoemVyb1NwYW4gIT0gbnVsbCkge1xuICAgIG91dC5yZW1vdmVkLnB1c2goeyBmcm9tOiBvbGRTcGFuLCB0bzogb2xkU3BhbiB9KTtcbiAgICBvdXQubW92ZWQucHVzaCh7IGZyb206IG9sZFNwYW4sIHRvOiB6ZXJvU3BhbiB9KTtcbiAgICBvdXQuYWRkZWQucHVzaCh7IGZyb206IHplcm9TcGFuLCB0bzogemVyb1NwYW4gfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbmV3U3BhbiA9IGNvbGxhcHNlU3BhbihvbGRTcGFuLCBjb2xsYXBzZU1vZGUsIG9sZERhdGEsIG9sZEF4aXNJbmRpY2VzLCBvbGRJbmRpY2VzLCByYW5nZTMpO1xuICAgIG91dC5yZW1vdmVkLnB1c2goeyBmcm9tOiBvbGRTcGFuLCB0bzogbmV3U3BhbiB9KTtcbiAgfVxufVxuZnVuY3Rpb24gYWxpZ25TcGFuVG9Db250YWluaW5nU3BhbihzcGFuLCBheGlzVmFsdWVzLCBwcmVEYXRhLCBwb3N0RGF0YSwgcG9zdFNwYW5JbmRpY2VzKSB7XG4gIGNvbnN0IHN0YXJ0WFZhbHVlMCA9IGF4aXNWYWx1ZXNbcG9zdFNwYW5JbmRpY2VzLnhWYWx1ZTBJbmRleF07XG4gIGNvbnN0IHN0YXJ0RGF0dW0gPSBwcmVEYXRhLmRhdGEuZmluZCgoc3BhbkRhdHVtKSA9PiB0b0F4aXNWYWx1ZShzcGFuRGF0dW0ueFZhbHVlMCkgPT09IHN0YXJ0WFZhbHVlMCk7XG4gIGNvbnN0IGVuZFhWYWx1ZTEgPSBheGlzVmFsdWVzW3Bvc3RTcGFuSW5kaWNlcy54VmFsdWUxSW5kZXhdO1xuICBjb25zdCBlbmREYXR1bSA9IHByZURhdGEuZGF0YS5maW5kKChzcGFuRGF0dW0pID0+IHRvQXhpc1ZhbHVlKHNwYW5EYXR1bS54VmFsdWUxKSA9PT0gZW5kWFZhbHVlMSk7XG4gIGlmIChzdGFydERhdHVtID09IG51bGwgfHwgZW5kRGF0dW0gPT0gbnVsbClcbiAgICByZXR1cm47XG4gIGNvbnN0IFt7IHg6IHgwIH0sIHsgeDogeDEgfV0gPSBzcGFuUmFuZ2Uoc3Bhbik7XG4gIGNvbnN0IHN0YXJ0WCA9IHNjYWxlKHN0YXJ0RGF0dW0ueFZhbHVlMCwgcHJlRGF0YS5zY2FsZXMueCk7XG4gIGNvbnN0IHN0YXJ0WSA9IHNjYWxlKHN0YXJ0RGF0dW0ueVZhbHVlMCwgcHJlRGF0YS5zY2FsZXMueSk7XG4gIGNvbnN0IGVuZFggPSBzY2FsZShlbmREYXR1bS54VmFsdWUxLCBwcmVEYXRhLnNjYWxlcy54KTtcbiAgY29uc3QgZW5kWSA9IHNjYWxlKGVuZERhdHVtLnlWYWx1ZTEsIHByZURhdGEuc2NhbGVzLnkpO1xuICBsZXQgYWx0U3BhbiA9IHBvc3REYXRhLmRhdGFbcG9zdFNwYW5JbmRpY2VzLmRhdHVtSW5kZXhdLnNwYW47XG4gIGFsdFNwYW4gPSByZXNjYWxlU3BhbihhbHRTcGFuLCB7IHg6IHN0YXJ0WCwgeTogc3RhcnRZIH0sIHsgeDogZW5kWCwgeTogZW5kWSB9KTtcbiAgYWx0U3BhbiA9IGNsaXBTcGFuWChhbHRTcGFuLCB4MCwgeDEpO1xuICByZXR1cm4gYWx0U3Bhbjtcbn1cbmZ1bmN0aW9uIGFwcGVuZFNwYW5QaGFzZXMobmV3RGF0YSwgb2xkRGF0YSwgY29sbGFwc2VNb2RlLCBheGlzVmFsdWVzLCB4VmFsdWUwSW5kZXgsIG5ld0F4aXNJbmRpY2VzLCBvbGRBeGlzSW5kaWNlcywgcmFuZ2UzLCBvdXQpIHtcbiAgY29uc3QgeFZhbHVlMUluZGV4ID0geFZhbHVlMEluZGV4ICsgMTtcbiAgY29uc3Qgb2xkSW5kaWNlcyA9IG9sZEF4aXNJbmRpY2VzLmZpbmQoKGkpID0+IGkueFZhbHVlMEluZGV4IDw9IHhWYWx1ZTBJbmRleCAmJiBpLnhWYWx1ZTFJbmRleCA+PSB4VmFsdWUxSW5kZXgpO1xuICBjb25zdCBuZXdJbmRpY2VzID0gbmV3QXhpc0luZGljZXMuZmluZCgoaSkgPT4gaS54VmFsdWUwSW5kZXggPD0geFZhbHVlMEluZGV4ICYmIGkueFZhbHVlMUluZGV4ID49IHhWYWx1ZTFJbmRleCk7XG4gIGNvbnN0IG9sZFplcm9EYXRhID0gb2xkRGF0YS56ZXJvRGF0YTtcbiAgY29uc3QgbmV3WmVyb0RhdGEgPSBuZXdEYXRhLnplcm9EYXRhO1xuICBpZiAob2xkSW5kaWNlcyA9PSBudWxsICYmIG5ld0luZGljZXMgIT0gbnVsbCkge1xuICAgIGFkZFNwYW4obmV3RGF0YSwgY29sbGFwc2VNb2RlLCBuZXdBeGlzSW5kaWNlcywgbmV3SW5kaWNlcywgb2xkWmVyb0RhdGEsIHJhbmdlMywgb3V0KTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAob2xkSW5kaWNlcyAhPSBudWxsICYmIG5ld0luZGljZXMgPT0gbnVsbCkge1xuICAgIHJlbW92ZVNwYW4ob2xkRGF0YSwgY29sbGFwc2VNb2RlLCBvbGRBeGlzSW5kaWNlcywgb2xkSW5kaWNlcywgbmV3WmVyb0RhdGEsIHJhbmdlMywgb3V0KTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAob2xkSW5kaWNlcyA9PSBudWxsIHx8IG5ld0luZGljZXMgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb3JkZXJpbmc7XG4gIGlmIChvbGRJbmRpY2VzLnhWYWx1ZTBJbmRleCA9PT0gbmV3SW5kaWNlcy54VmFsdWUwSW5kZXggJiYgb2xkSW5kaWNlcy54VmFsdWUxSW5kZXggPT09IG5ld0luZGljZXMueFZhbHVlMUluZGV4KSB7XG4gICAgb3JkZXJpbmcgPSAwO1xuICB9IGVsc2UgaWYgKG9sZEluZGljZXMueFZhbHVlMEluZGV4IDw9IG5ld0luZGljZXMueFZhbHVlMEluZGV4ICYmIG9sZEluZGljZXMueFZhbHVlMUluZGV4ID49IG5ld0luZGljZXMueFZhbHVlMUluZGV4KSB7XG4gICAgb3JkZXJpbmcgPSAtMTtcbiAgfSBlbHNlIGlmIChvbGRJbmRpY2VzLnhWYWx1ZTBJbmRleCA+PSBuZXdJbmRpY2VzLnhWYWx1ZTBJbmRleCAmJiBvbGRJbmRpY2VzLnhWYWx1ZTFJbmRleCA8PSBuZXdJbmRpY2VzLnhWYWx1ZTFJbmRleCkge1xuICAgIG9yZGVyaW5nID0gMTtcbiAgfSBlbHNlIHtcbiAgICBvcmRlcmluZyA9IDA7XG4gIH1cbiAgY29uc3Qgb2xkU3BhbkRhdHVtID0gb2xkRGF0YS5kYXRhW29sZEluZGljZXMuZGF0dW1JbmRleF07XG4gIGNvbnN0IGNsaXBwZWRPbGRTcGFuT2xkU2NhbGUgPSBjbGlwU3BhbihvbGRTcGFuRGF0dW0uc3BhbiwgeFZhbHVlMEluZGV4LCBvbGRJbmRpY2VzKTtcbiAgY29uc3QgbmV3U3BhbkRhdHVtID0gbmV3RGF0YS5kYXRhW25ld0luZGljZXMuZGF0dW1JbmRleF07XG4gIGNvbnN0IGNsaXBwZWROZXdTcGFuTmV3U2NhbGUgPSBjbGlwU3BhbihuZXdTcGFuRGF0dW0uc3BhbiwgeFZhbHVlMEluZGV4LCBuZXdJbmRpY2VzKTtcbiAgaWYgKG9yZGVyaW5nID09PSAxKSB7XG4gICAgY29uc3QgY2xpcHBlZFBvc3RSZW1vdmVPbGRTcGFuT2xkU2NhbGUgPSBhbGlnblNwYW5Ub0NvbnRhaW5pbmdTcGFuKFxuICAgICAgY2xpcHBlZE9sZFNwYW5PbGRTY2FsZSxcbiAgICAgIGF4aXNWYWx1ZXMsXG4gICAgICBvbGREYXRhLFxuICAgICAgbmV3RGF0YSxcbiAgICAgIG5ld0luZGljZXNcbiAgICApO1xuICAgIGlmIChjbGlwcGVkUG9zdFJlbW92ZU9sZFNwYW5PbGRTY2FsZSAhPSBudWxsKSB7XG4gICAgICBvdXQucmVtb3ZlZC5wdXNoKHsgZnJvbTogY2xpcHBlZE9sZFNwYW5PbGRTY2FsZSwgdG86IGNsaXBwZWRQb3N0UmVtb3ZlT2xkU3Bhbk9sZFNjYWxlIH0pO1xuICAgICAgb3V0Lm1vdmVkLnB1c2goeyBmcm9tOiBjbGlwcGVkUG9zdFJlbW92ZU9sZFNwYW5PbGRTY2FsZSwgdG86IGNsaXBwZWROZXdTcGFuTmV3U2NhbGUgfSk7XG4gICAgICBvdXQuYWRkZWQucHVzaCh7IGZyb206IGNsaXBwZWROZXdTcGFuTmV3U2NhbGUsIHRvOiBjbGlwcGVkTmV3U3Bhbk5ld1NjYWxlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVTcGFuKG9sZERhdGEsIGNvbGxhcHNlTW9kZSwgb2xkQXhpc0luZGljZXMsIG9sZEluZGljZXMsIG5ld1plcm9EYXRhLCByYW5nZTMsIG91dCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9yZGVyaW5nID09PSAtMSkge1xuICAgIGNvbnN0IGNsaXBwZWRQcmVBZGRlZE5ld1NwYW5OZXdTY2FsZSA9IGFsaWduU3BhblRvQ29udGFpbmluZ1NwYW4oXG4gICAgICBjbGlwcGVkTmV3U3Bhbk5ld1NjYWxlLFxuICAgICAgYXhpc1ZhbHVlcyxcbiAgICAgIG5ld0RhdGEsXG4gICAgICBvbGREYXRhLFxuICAgICAgb2xkSW5kaWNlc1xuICAgICk7XG4gICAgaWYgKGNsaXBwZWRQcmVBZGRlZE5ld1NwYW5OZXdTY2FsZSAhPSBudWxsKSB7XG4gICAgICBvdXQucmVtb3ZlZC5wdXNoKHsgZnJvbTogY2xpcHBlZE9sZFNwYW5PbGRTY2FsZSwgdG86IGNsaXBwZWRPbGRTcGFuT2xkU2NhbGUgfSk7XG4gICAgICBvdXQubW92ZWQucHVzaCh7IGZyb206IGNsaXBwZWRPbGRTcGFuT2xkU2NhbGUsIHRvOiBjbGlwcGVkUHJlQWRkZWROZXdTcGFuTmV3U2NhbGUgfSk7XG4gICAgICBvdXQuYWRkZWQucHVzaCh7IGZyb206IGNsaXBwZWRQcmVBZGRlZE5ld1NwYW5OZXdTY2FsZSwgdG86IGNsaXBwZWROZXdTcGFuTmV3U2NhbGUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZFNwYW4obmV3RGF0YSwgY29sbGFwc2VNb2RlLCBuZXdBeGlzSW5kaWNlcywgbmV3SW5kaWNlcywgb2xkWmVyb0RhdGEsIHJhbmdlMywgb3V0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0LnJlbW92ZWQucHVzaCh7IGZyb206IGNsaXBwZWRPbGRTcGFuT2xkU2NhbGUsIHRvOiBjbGlwcGVkT2xkU3Bhbk9sZFNjYWxlIH0pO1xuICAgIG91dC5tb3ZlZC5wdXNoKHsgZnJvbTogY2xpcHBlZE9sZFNwYW5PbGRTY2FsZSwgdG86IGNsaXBwZWROZXdTcGFuTmV3U2NhbGUgfSk7XG4gICAgb3V0LmFkZGVkLnB1c2goeyBmcm9tOiBjbGlwcGVkTmV3U3Bhbk5ld1NjYWxlLCB0bzogY2xpcHBlZE5ld1NwYW5OZXdTY2FsZSB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGhhc2VBbmltYXRpb24oYXhpc0NvbnRleHQsIG5ld0RhdGEsIG9sZERhdGEsIGNvbGxhcHNlTW9kZSkge1xuICBjb25zdCBvdXQgPSB7XG4gICAgcmVtb3ZlZDogW10sXG4gICAgbW92ZWQ6IFtdLFxuICAgIGFkZGVkOiBbXVxuICB9O1xuICBjb25zdCB7IGF4aXNWYWx1ZXMsIG9sZERhdGFBeGlzSW5kaWNlcywgbmV3RGF0YUF4aXNJbmRpY2VzIH0gPSBheGlzQ29udGV4dDtcbiAgY29uc3QgcmFuZ2UzID0ge1xuICAgIHhWYWx1ZTBJbmRleDogTWF0aC5tYXgoXG4gICAgICBvbGREYXRhQXhpc0luZGljZXMuYXQoMCk/LnhWYWx1ZTBJbmRleCA/PyAtSW5maW5pdHksXG4gICAgICBuZXdEYXRhQXhpc0luZGljZXMuYXQoMCk/LnhWYWx1ZTBJbmRleCA/PyAtSW5maW5pdHlcbiAgICApLFxuICAgIHhWYWx1ZTFJbmRleDogTWF0aC5taW4oXG4gICAgICBvbGREYXRhQXhpc0luZGljZXMuYXQoLTEpPy54VmFsdWUxSW5kZXggPz8gSW5maW5pdHksXG4gICAgICBuZXdEYXRhQXhpc0luZGljZXMuYXQoLTEpPy54VmFsdWUxSW5kZXggPz8gSW5maW5pdHlcbiAgICApXG4gIH07XG4gIGZvciAobGV0IHhWYWx1ZTBJbmRleCA9IDA7IHhWYWx1ZTBJbmRleCA8IGF4aXNWYWx1ZXMubGVuZ3RoIC0gMTsgeFZhbHVlMEluZGV4ICs9IDEpIHtcbiAgICBhcHBlbmRTcGFuUGhhc2VzKFxuICAgICAgbmV3RGF0YSxcbiAgICAgIG9sZERhdGEsXG4gICAgICBjb2xsYXBzZU1vZGUsXG4gICAgICBheGlzVmFsdWVzLFxuICAgICAgeFZhbHVlMEluZGV4LFxuICAgICAgbmV3RGF0YUF4aXNJbmRpY2VzLFxuICAgICAgb2xkRGF0YUF4aXNJbmRpY2VzLFxuICAgICAgcmFuZ2UzLFxuICAgICAgb3V0XG4gICAgKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gcmVzZXRTcGFuKGRhdGEsIHNwYW5EYXR1bSwgY29sbGFwc2VNb2RlKSB7XG4gIGNvbnN0IHsgc3BhbiB9ID0gc3BhbkRhdHVtO1xuICBzd2l0Y2ggKGNvbGxhcHNlTW9kZSkge1xuICAgIGNhc2UgMCAvKiBaZXJvICovOlxuICAgICAgcmV0dXJuIHplcm9EYXRhU3BhbihzcGFuRGF0dW0sIGRhdGEuemVyb0RhdGEpID8/IGF4aXNaZXJvU3BhbihzcGFuLCBkYXRhKTtcbiAgICBjYXNlIDEgLyogU3BsaXQgKi86XG4gICAgICByZXR1cm4gY29sbGFwc2VTcGFuVG9NaWRwb2ludChzcGFuKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzZXRBbmltYXRpb24obmV3RGF0YSwgb2xkRGF0YSwgY29sbGFwc2VNb2RlKSB7XG4gIGNvbnN0IGFkZGVkID0gW107XG4gIGNvbnN0IHJlbW92ZWQgPSBbXTtcbiAgZm9yIChjb25zdCBvbGRTcGFuRGF0dW0gb2Ygb2xkRGF0YS5kYXRhKSB7XG4gICAgY29uc3Qgb2xkU3BhbiA9IG9sZFNwYW5EYXR1bS5zcGFuO1xuICAgIGNvbnN0IGNvbGxhcHNlZFNwYW4gPSByZXNldFNwYW4ob2xkRGF0YSwgb2xkU3BhbkRhdHVtLCBjb2xsYXBzZU1vZGUpO1xuICAgIHJlbW92ZWQucHVzaCh7IGZyb206IG9sZFNwYW4sIHRvOiBjb2xsYXBzZWRTcGFuIH0pO1xuICB9XG4gIGZvciAoY29uc3QgbmV3U3BhbkRhdHVtIG9mIG5ld0RhdGEuZGF0YSkge1xuICAgIGNvbnN0IG5ld1NwYW4gPSBuZXdTcGFuRGF0dW0uc3BhbjtcbiAgICBjb25zdCBjb2xsYXBzZWRTcGFuID0gcmVzZXRTcGFuKG5ld0RhdGEsIG5ld1NwYW5EYXR1bSwgY29sbGFwc2VNb2RlKTtcbiAgICBhZGRlZC5wdXNoKHsgZnJvbTogY29sbGFwc2VkU3BhbiwgdG86IG5ld1NwYW4gfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZW1vdmVkLFxuICAgIG1vdmVkOiBbXSxcbiAgICBhZGRlZFxuICB9O1xufVxuZnVuY3Rpb24gcGFpclVwU3BhbnMobmV3RGF0YSwgb2xkRGF0YSwgY29sbGFwc2VNb2RlKSB7XG4gIGlmICghdmFsaWRhdGVDYXRlZ29yeVNvcnRpbmcobmV3RGF0YSwgb2xkRGF0YSkpXG4gICAgcmV0dXJuO1xuICBjb25zdCBheGlzQ29udGV4dCA9IHNwYW5BeGlzQ29udGV4dChuZXdEYXRhLCBvbGREYXRhKTtcbiAgcmV0dXJuIGF4aXNDb250ZXh0ID09IG51bGwgPyByZXNldEFuaW1hdGlvbihuZXdEYXRhLCBvbGREYXRhLCBjb2xsYXBzZU1vZGUpIDogcGhhc2VBbmltYXRpb24oYXhpc0NvbnRleHQsIG5ld0RhdGEsIG9sZERhdGEsIGNvbGxhcHNlTW9kZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vc2NhbGluZy50c1xuZnVuY3Rpb24gaXNDb250aW51b3VzU2NhbGluZyhzY2FsaW5nKSB7XG4gIHJldHVybiBzY2FsaW5nLnR5cGUgPT09IFwiY29udGludW91c1wiIHx8IHNjYWxpbmcudHlwZSA9PT0gXCJsb2dcIjtcbn1cbmZ1bmN0aW9uIGlzQ2F0ZWdvcnlTY2FsaW5nKHNjYWxpbmcpIHtcbiAgcmV0dXJuIHNjYWxpbmcudHlwZSA9PT0gXCJjYXRlZ29yeVwiO1xufVxuZnVuY3Rpb24gYXJlU2NhbGluZ0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IHZvaWQgMCB8fCBiID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYSAhPT0gdm9pZCAwIHx8IGIgIT09IHZvaWQgMDtcbiAgfVxuICBpZiAoaXNDb250aW51b3VzU2NhbGluZyhhKSAmJiBpc0NvbnRpbnVvdXNTY2FsaW5nKGIpKSB7XG4gICAgcmV0dXJuIGEudHlwZSA9PT0gYi50eXBlICYmIGFycmF5c0VxdWFsKGEuZG9tYWluLCBiLmRvbWFpbikgJiYgYXJyYXlzRXF1YWwoYS5yYW5nZSwgYi5yYW5nZSk7XG4gIH1cbiAgaWYgKGlzQ2F0ZWdvcnlTY2FsaW5nKGEpICYmIGlzQ2F0ZWdvcnlTY2FsaW5nKGIpKSB7XG4gICAgcmV0dXJuIGEuaW5zZXQgPT09IGIuaW5zZXQgJiYgYS5zdGVwID09PSBiLnN0ZXAgJiYgYXJyYXlzRXF1YWwoYS5kb21haW4sIGIuZG9tYWluKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NjYWxlVmFsaWQoc2NhbGUyKSB7XG4gIGlmIChzY2FsZTIgPT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChzY2FsZTIudHlwZSA9PT0gXCJjYXRlZ29yeVwiKVxuICAgIHJldHVybiBzY2FsZTIuZG9tYWluLmV2ZXJ5KCh2KSA9PiB2ICE9IG51bGwpO1xuICByZXR1cm4gc2NhbGUyLmRvbWFpbi5ldmVyeSgodikgPT4gTnVtYmVyLmlzRmluaXRlKHYpIHx8IHYgaW5zdGFuY2VvZiBEYXRlKSAmJiBzY2FsZTIucmFuZ2UuZXZlcnkoKHYpID0+IE51bWJlci5pc0Zpbml0ZSh2KSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vbGluZVV0aWwudHNcbmZ1bmN0aW9uIGludGVycG9sYXRlUG9pbnRzKHBvaW50cywgaW50ZXJwb2xhdGlvbikge1xuICBsZXQgc3BhbnM7XG4gIGNvbnN0IHBvaW50c0l0ZXIgPSBwb2ludHMubWFwKChwb2ludCkgPT4gcG9pbnQucG9pbnQpO1xuICBzd2l0Y2ggKGludGVycG9sYXRpb24udHlwZSkge1xuICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICAgIHNwYW5zID0gbGluZWFyUG9pbnRzKHBvaW50c0l0ZXIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInNtb290aFwiOlxuICAgICAgc3BhbnMgPSBzbW9vdGhQb2ludHMocG9pbnRzSXRlciwgaW50ZXJwb2xhdGlvbi50ZW5zaW9uKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdGVwXCI6XG4gICAgICBzcGFucyA9IHN0ZXBQb2ludHMocG9pbnRzSXRlciwgaW50ZXJwb2xhdGlvbi5wb3NpdGlvbik7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gc3BhbnMubWFwKChzcGFuLCBpKSA9PiAoe1xuICAgIHNwYW4sXG4gICAgeFZhbHVlMDogcG9pbnRzW2ldLnhEYXR1bSxcbiAgICB5VmFsdWUwOiBwb2ludHNbaV0ueURhdHVtLFxuICAgIHhWYWx1ZTE6IHBvaW50c1tpICsgMV0ueERhdHVtLFxuICAgIHlWYWx1ZTE6IHBvaW50c1tpICsgMV0ueURhdHVtXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIHBvaW50c0VxKGEsIGIsIGRlbHRhMyA9IDFlLTMpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEueCAtIGIueCkgPCBkZWx0YTMgJiYgTWF0aC5hYnMoYS55IC0gYi55KSA8IGRlbHRhMztcbn1cbmZ1bmN0aW9uIHBsb3RMaW5lUGF0aFN0cm9rZSh7IHBhdGggfSwgc3BhbnMpIHtcbiAgbGV0IGxhc3RQb2ludDtcbiAgZm9yIChjb25zdCB7IHNwYW4gfSBvZiBzcGFucykge1xuICAgIGNvbnN0IFtzdGFydDIsIGVuZDJdID0gc3BhblJhbmdlKHNwYW4pO1xuICAgIGNvbnN0IGpvaW4gPSBsYXN0UG9pbnQgIT0gbnVsbCAmJiBwb2ludHNFcShsYXN0UG9pbnQsIHN0YXJ0MikgPyAxIC8qIExpbmVUbyAqLyA6IDAgLyogTW92ZVRvICovO1xuICAgIHBsb3RTcGFuKHBhdGgsIHNwYW4sIGpvaW4sIGZhbHNlKTtcbiAgICBsYXN0UG9pbnQgPSBlbmQyO1xuICB9XG59XG5mdW5jdGlvbiBwbG90SW50ZXJwb2xhdGVkTGluZVBhdGhTdHJva2UocmF0aW8yLCBwYXRoLCBzcGFucykge1xuICBsZXQgbGFzdFBvaW50O1xuICBmb3IgKGNvbnN0IHNwYW4gb2Ygc3BhbnMpIHtcbiAgICBjb25zdCBbc3RhcnQyLCBlbmQyXSA9IGludGVycG9sYXRlZFNwYW5SYW5nZShzcGFuLmZyb20sIHNwYW4udG8sIHJhdGlvMik7XG4gICAgY29uc3Qgam9pbiA9IGxhc3RQb2ludCAhPSBudWxsICYmIHBvaW50c0VxKGxhc3RQb2ludCwgc3RhcnQyKSA/IDEgLyogTGluZVRvICovIDogMCAvKiBNb3ZlVG8gKi87XG4gICAgcGxvdEludGVycG9sYXRlZFNwYW5zKHBhdGgucGF0aCwgc3Bhbi5mcm9tLCBzcGFuLnRvLCByYXRpbzIsIGpvaW4sIGZhbHNlKTtcbiAgICBsYXN0UG9pbnQgPSBlbmQyO1xuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlTGluZVBhdGhTdHJva2VBbmltYXRpb25GbnMoc3RhdHVzLCBzcGFucywgdmlzaWJsZVRvZ2dsZU1vZGUpIHtcbiAgY29uc3QgcmVtb3ZlUGhhc2VGbiA9IChyYXRpbzIsIHBhdGgpID0+IHBsb3RJbnRlcnBvbGF0ZWRMaW5lUGF0aFN0cm9rZShyYXRpbzIsIHBhdGgsIHNwYW5zLnJlbW92ZWQpO1xuICBjb25zdCB1cGRhdGVQaGFzZUZuID0gKHJhdGlvMiwgcGF0aCkgPT4gcGxvdEludGVycG9sYXRlZExpbmVQYXRoU3Ryb2tlKHJhdGlvMiwgcGF0aCwgc3BhbnMubW92ZWQpO1xuICBjb25zdCBhZGRQaGFzZUZuID0gKHJhdGlvMiwgcGF0aCkgPT4gcGxvdEludGVycG9sYXRlZExpbmVQYXRoU3Ryb2tlKHJhdGlvMiwgcGF0aCwgc3BhbnMuYWRkZWQpO1xuICBjb25zdCBwYXRoUHJvcGVydGllcyA9IHByZXBhcmVMaW5lUGF0aFByb3BlcnR5QW5pbWF0aW9uKHN0YXR1cywgdmlzaWJsZVRvZ2dsZU1vZGUpO1xuICByZXR1cm4geyBzdGF0dXMsIHBhdGg6IHsgYWRkUGhhc2VGbiwgdXBkYXRlUGhhc2VGbiwgcmVtb3ZlUGhhc2VGbiB9LCBwYXRoUHJvcGVydGllcyB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZUxpbmVQYXRoUHJvcGVydHlBbmltYXRpb24oc3RhdHVzLCB2aXNpYmxlVG9nZ2xlTW9kZSkge1xuICBjb25zdCBwaGFzZSA9IHZpc2libGVUb2dnbGVNb2RlID09PSBcIm5vbmVcIiA/IFwidXBkYXRlZFwiIDogc3RhdHVzO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgZnJvbUZuOiAoX3BhdGgpID0+IHtcbiAgICAgIGxldCBtaXhpbjtcbiAgICAgIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiKSB7XG4gICAgICAgIG1peGluID0geyBmaW5pc2g6IHsgdmlzaWJsZTogZmFsc2UgfSB9O1xuICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFwiYWRkZWRcIikge1xuICAgICAgICBtaXhpbiA9IHsgc3RhcnQ6IHsgdmlzaWJsZTogdHJ1ZSB9IH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaXhpbiA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbcGhhc2VdLCAuLi5taXhpbiB9O1xuICAgIH0sXG4gICAgdG9GbjogKF9wYXRoKSA9PiB7XG4gICAgICByZXR1cm4geyBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1twaGFzZV0gfTtcbiAgICB9XG4gIH07XG4gIGlmICh2aXNpYmxlVG9nZ2xlTW9kZSA9PT0gXCJmYWRlXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbUZuOiAocGF0aCkgPT4ge1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gc3RhdHVzID09PSBcImFkZGVkXCIgPyAwIDogcGF0aC5vcGFjaXR5O1xuICAgICAgICByZXR1cm4geyBvcGFjaXR5LCAuLi5yZXN1bHQuZnJvbUZuKHBhdGgpIH07XG4gICAgICB9LFxuICAgICAgdG9GbjogKHBhdGgpID0+IHtcbiAgICAgICAgY29uc3Qgb3BhY2l0eSA9IHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgPyAwIDogMTtcbiAgICAgICAgcmV0dXJuIHsgb3BhY2l0eSwgLi4ucmVzdWx0LnRvRm4ocGF0aCkgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwcmVwYXJlTGluZVBhdGhBbmltYXRpb24obmV3RGF0YSwgb2xkRGF0YSwgZGlmZjIpIHtcbiAgY29uc3QgaXNDYXRlZ29yeUJhc2VkID0gbmV3RGF0YS5zY2FsZXMueD8udHlwZSA9PT0gXCJjYXRlZ29yeVwiO1xuICBjb25zdCB3YXNDYXRlZ29yeUJhc2VkID0gb2xkRGF0YS5zY2FsZXMueD8udHlwZSA9PT0gXCJjYXRlZ29yeVwiO1xuICBpZiAoaXNDYXRlZ29yeUJhc2VkICE9PSB3YXNDYXRlZ29yeUJhc2VkIHx8ICFpc1NjYWxlVmFsaWQobmV3RGF0YS5zY2FsZXMueCkgfHwgIWlzU2NhbGVWYWxpZChvbGREYXRhLnNjYWxlcy54KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobmV3RGF0YS5zdHJva2VEYXRhID09IG51bGwgfHwgb2xkRGF0YS5zdHJva2VEYXRhID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHN0YXR1cyA9IFwidXBkYXRlZFwiO1xuICBpZiAob2xkRGF0YS52aXNpYmxlICYmICFuZXdEYXRhLnZpc2libGUpIHtcbiAgICBzdGF0dXMgPSBcInJlbW92ZWRcIjtcbiAgfSBlbHNlIGlmICghb2xkRGF0YS52aXNpYmxlICYmIG5ld0RhdGEudmlzaWJsZSkge1xuICAgIHN0YXR1cyA9IFwiYWRkZWRcIjtcbiAgfVxuICBjb25zdCBzdHJva2VTcGFucyA9IHBhaXJVcFNwYW5zKFxuICAgIHsgc2NhbGVzOiBuZXdEYXRhLnNjYWxlcywgZGF0YTogbmV3RGF0YS5zdHJva2VEYXRhLnNwYW5zIH0sXG4gICAgeyBzY2FsZXM6IG9sZERhdGEuc2NhbGVzLCBkYXRhOiBvbGREYXRhLnN0cm9rZURhdGEuc3BhbnMgfSxcbiAgICAxIC8qIFNwbGl0ICovXG4gICk7XG4gIGlmIChzdHJva2VTcGFucyA9PSBudWxsKVxuICAgIHJldHVybjtcbiAgY29uc3Qgc3Ryb2tlMiA9IHByZXBhcmVMaW5lUGF0aFN0cm9rZUFuaW1hdGlvbkZucyhzdGF0dXMsIHN0cm9rZVNwYW5zLCBcImZhZGVcIik7XG4gIGNvbnN0IGhhc01vdGlvbiA9IChkaWZmMj8uY2hhbmdlZCA/PyB0cnVlKSB8fCAhYXJlU2NhbGluZ0VxdWFsKG5ld0RhdGEuc2NhbGVzLngsIG9sZERhdGEuc2NhbGVzLngpIHx8ICFhcmVTY2FsaW5nRXF1YWwobmV3RGF0YS5zY2FsZXMueSwgb2xkRGF0YS5zY2FsZXMueSkgfHwgc3RhdHVzICE9PSBcInVwZGF0ZWRcIjtcbiAgcmV0dXJuIHsgc3RhdHVzLCBzdHJva2U6IHN0cm9rZTIsIGhhc01vdGlvbiB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2FyZWFVdGlsLnRzXG5mdW5jdGlvbiBwbG90QXJlYVBhdGhGaWxsKHsgcGF0aCB9LCB7IHNwYW5zLCBwaGFudG9tU3BhbnMgfSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgeyBzcGFuIH0gPSBzcGFuc1tpXTtcbiAgICBjb25zdCBwaGFudG9tU3BhbiA9IHBoYW50b21TcGFuc1tpXS5zcGFuO1xuICAgIHBsb3RTcGFuKHBhdGgsIHNwYW4sIDAgLyogTW92ZVRvICovLCBmYWxzZSk7XG4gICAgcGxvdFNwYW4ocGF0aCwgcGhhbnRvbVNwYW4sIDEgLyogTGluZVRvICovLCB0cnVlKTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59XG5mdW5jdGlvbiBwbG90SW50ZXJwb2xhdGVkQXJlYVNlcmllc0ZpbGxTcGFucyhyYXRpbzIsIHsgcGF0aCB9LCBzcGFucywgZmlsbFBoYW50b21TcGFucykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3Qgc3BhbiA9IHNwYW5zW2ldO1xuICAgIGNvbnN0IHJldmVyc2VkUGhhbnRvbVNwYW4gPSBmaWxsUGhhbnRvbVNwYW5zW2ldO1xuICAgIHBsb3RJbnRlcnBvbGF0ZWRTcGFucyhwYXRoLCBzcGFuLmZyb20sIHNwYW4udG8sIHJhdGlvMiwgMCAvKiBNb3ZlVG8gKi8sIGZhbHNlKTtcbiAgICBwbG90SW50ZXJwb2xhdGVkU3BhbnMocGF0aCwgcmV2ZXJzZWRQaGFudG9tU3Bhbi5mcm9tLCByZXZlcnNlZFBoYW50b21TcGFuLnRvLCByYXRpbzIsIDEgLyogTGluZVRvICovLCB0cnVlKTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlQXJlYUZpbGxBbmltYXRpb25GbnMoc3RhdHVzLCBzcGFucywgZmlsbFBoYW50b21TcGFucywgdmlzaWJsZVRvZ2dsZU1vZGUpIHtcbiAgY29uc3QgcmVtb3ZlUGhhc2VGbiA9IChyYXRpbzIsIHBhdGgpID0+IHBsb3RJbnRlcnBvbGF0ZWRBcmVhU2VyaWVzRmlsbFNwYW5zKHJhdGlvMiwgcGF0aCwgc3BhbnMucmVtb3ZlZCwgZmlsbFBoYW50b21TcGFucy5yZW1vdmVkKTtcbiAgY29uc3QgdXBkYXRlUGhhc2VGbiA9IChyYXRpbzIsIHBhdGgpID0+IHBsb3RJbnRlcnBvbGF0ZWRBcmVhU2VyaWVzRmlsbFNwYW5zKHJhdGlvMiwgcGF0aCwgc3BhbnMubW92ZWQsIGZpbGxQaGFudG9tU3BhbnMubW92ZWQpO1xuICBjb25zdCBhZGRQaGFzZUZuID0gKHJhdGlvMiwgcGF0aCkgPT4gcGxvdEludGVycG9sYXRlZEFyZWFTZXJpZXNGaWxsU3BhbnMocmF0aW8yLCBwYXRoLCBzcGFucy5hZGRlZCwgZmlsbFBoYW50b21TcGFucy5hZGRlZCk7XG4gIGNvbnN0IHBhdGhQcm9wZXJ0aWVzID0gcHJlcGFyZUxpbmVQYXRoUHJvcGVydHlBbmltYXRpb24oc3RhdHVzLCB2aXNpYmxlVG9nZ2xlTW9kZSk7XG4gIHJldHVybiB7IHN0YXR1cywgcGF0aDogeyBhZGRQaGFzZUZuLCB1cGRhdGVQaGFzZUZuLCByZW1vdmVQaGFzZUZuIH0sIHBhdGhQcm9wZXJ0aWVzIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlQXJlYVBhdGhBbmltYXRpb24obmV3RGF0YSwgb2xkRGF0YSkge1xuICBjb25zdCBpc0NhdGVnb3J5QmFzZWQgPSBuZXdEYXRhLnNjYWxlcy54Py50eXBlID09PSBcImNhdGVnb3J5XCI7XG4gIGNvbnN0IHdhc0NhdGVnb3J5QmFzZWQgPSBvbGREYXRhLnNjYWxlcy54Py50eXBlID09PSBcImNhdGVnb3J5XCI7XG4gIGlmIChpc0NhdGVnb3J5QmFzZWQgIT09IHdhc0NhdGVnb3J5QmFzZWQgfHwgIWlzU2NhbGVWYWxpZChuZXdEYXRhLnNjYWxlcy54KSB8fCAhaXNTY2FsZVZhbGlkKG9sZERhdGEuc2NhbGVzLngpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGF0dXMgPSBcInVwZGF0ZWRcIjtcbiAgaWYgKG9sZERhdGEudmlzaWJsZSAmJiAhbmV3RGF0YS52aXNpYmxlKSB7XG4gICAgc3RhdHVzID0gXCJyZW1vdmVkXCI7XG4gIH0gZWxzZSBpZiAoIW9sZERhdGEudmlzaWJsZSAmJiBuZXdEYXRhLnZpc2libGUpIHtcbiAgICBzdGF0dXMgPSBcImFkZGVkXCI7XG4gIH1cbiAgY29uc3QgZmlsbFNwYW5zID0gcGFpclVwU3BhbnMoXG4gICAgeyBzY2FsZXM6IG5ld0RhdGEuc2NhbGVzLCBkYXRhOiBuZXdEYXRhLmZpbGxEYXRhLnNwYW5zIH0sXG4gICAgeyBzY2FsZXM6IG9sZERhdGEuc2NhbGVzLCBkYXRhOiBvbGREYXRhLmZpbGxEYXRhLnNwYW5zIH0sXG4gICAgMCAvKiBaZXJvICovXG4gICk7XG4gIGlmIChmaWxsU3BhbnMgPT0gbnVsbClcbiAgICByZXR1cm47XG4gIGNvbnN0IGZpbGxQaGFudG9tU3BhbnMgPSBwYWlyVXBTcGFucyhcbiAgICB7IHNjYWxlczogbmV3RGF0YS5zY2FsZXMsIGRhdGE6IG5ld0RhdGEuZmlsbERhdGEucGhhbnRvbVNwYW5zIH0sXG4gICAgeyBzY2FsZXM6IG9sZERhdGEuc2NhbGVzLCBkYXRhOiBvbGREYXRhLmZpbGxEYXRhLnBoYW50b21TcGFucyB9LFxuICAgIDAgLyogWmVybyAqL1xuICApO1xuICBpZiAoZmlsbFBoYW50b21TcGFucyA9PSBudWxsKVxuICAgIHJldHVybjtcbiAgY29uc3Qgc3Ryb2tlU3BhbnMgPSBwYWlyVXBTcGFucyhcbiAgICB7XG4gICAgICBzY2FsZXM6IG5ld0RhdGEuc2NhbGVzLFxuICAgICAgZGF0YTogbmV3RGF0YS5zdHJva2VEYXRhLnNwYW5zLFxuICAgICAgemVyb0RhdGE6IG5ld0RhdGEuZmlsbERhdGEucGhhbnRvbVNwYW5zXG4gICAgfSxcbiAgICB7XG4gICAgICBzY2FsZXM6IG9sZERhdGEuc2NhbGVzLFxuICAgICAgZGF0YTogb2xkRGF0YS5zdHJva2VEYXRhLnNwYW5zLFxuICAgICAgemVyb0RhdGE6IG9sZERhdGEuZmlsbERhdGEucGhhbnRvbVNwYW5zXG4gICAgfSxcbiAgICAwIC8qIFplcm8gKi9cbiAgKTtcbiAgaWYgKHN0cm9rZVNwYW5zID09IG51bGwpXG4gICAgcmV0dXJuO1xuICBjb25zdCBmYWRlTW9kZSA9IFwibm9uZVwiO1xuICBjb25zdCBmaWxsID0gcHJlcGFyZUFyZWFGaWxsQW5pbWF0aW9uRm5zKHN0YXR1cywgZmlsbFNwYW5zLCBmaWxsUGhhbnRvbVNwYW5zLCBmYWRlTW9kZSk7XG4gIGNvbnN0IHN0cm9rZTIgPSBwcmVwYXJlTGluZVBhdGhTdHJva2VBbmltYXRpb25GbnMoc3RhdHVzLCBzdHJva2VTcGFucywgZmFkZU1vZGUpO1xuICByZXR1cm4geyBzdGF0dXMsIGZpbGwsIHN0cm9rZTogc3Ryb2tlMiB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL21hcmtlclV0aWwudHNcbmZ1bmN0aW9uIG1hcmtlckZhZGVJbkFuaW1hdGlvbih7IGlkIH0sIGFuaW1hdGlvbk1hbmFnZXIsIHN0YXR1cywgLi4ubWFya2VyU2VsZWN0aW9ucykge1xuICBjb25zdCBwYXJhbXMgPSB7IHBoYXNlOiBzdGF0dXMgPyBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW3N0YXR1c10gOiBcInRyYWlsaW5nXCIgfTtcbiAgc3RhdGljRnJvbVRvTW90aW9uKGlkLCBcIm1hcmtlcnNcIiwgYW5pbWF0aW9uTWFuYWdlciwgbWFya2VyU2VsZWN0aW9ucywgeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9LCBwYXJhbXMpO1xuICBtYXJrZXJTZWxlY3Rpb25zLmZvckVhY2goKHMpID0+IHMuY2xlYW51cCgpKTtcbn1cbmZ1bmN0aW9uIG1hcmtlclNjYWxlSW5BbmltYXRpb24oeyBpZCB9LCBhbmltYXRpb25NYW5hZ2VyLCAuLi5tYXJrZXJTZWxlY3Rpb25zKSB7XG4gIHN0YXRpY0Zyb21Ub01vdGlvbihcbiAgICBpZCxcbiAgICBcIm1hcmtlcnNcIixcbiAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgIG1hcmtlclNlbGVjdGlvbnMsXG4gICAgeyBzY2FsaW5nWDogMCwgc2NhbGluZ1k6IDAgfSxcbiAgICB7IHNjYWxpbmdYOiAxLCBzY2FsaW5nWTogMSB9LFxuICAgIHsgcGhhc2U6IFwiaW5pdGlhbFwiIH1cbiAgKTtcbiAgbWFya2VyU2VsZWN0aW9ucy5mb3JFYWNoKChzKSA9PiBzLmNsZWFudXAoKSk7XG59XG5mdW5jdGlvbiBtYXJrZXJTd2lwZVNjYWxlSW5BbmltYXRpb24oeyBpZCwgbm9kZURhdGFEZXBlbmRlbmNpZXMgfSwgYW5pbWF0aW9uTWFuYWdlciwgLi4ubWFya2VyU2VsZWN0aW9ucykge1xuICBjb25zdCBzZXJpZXNXaWR0aCA9IG5vZGVEYXRhRGVwZW5kZW5jaWVzLnNlcmllc1JlY3RXaWR0aDtcbiAgY29uc3QgZnJvbUZuID0gKF8sIGRhdHVtKSA9PiB7XG4gICAgY29uc3QgeCA9IGRhdHVtLm1pZFBvaW50Py54ID8/IHNlcmllc1dpZHRoO1xuICAgIGxldCBkZWxheSA9IGNsYW1wKDAsIGludmVyc2VFYXNlT3V0KHggLyBzZXJpZXNXaWR0aCksIDEpO1xuICAgIGlmIChpc05hTihkZWxheSkpIHtcbiAgICAgIGRlbGF5ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2NhbGluZ1g6IDAsIHNjYWxpbmdZOiAwLCBkZWxheSwgZHVyYXRpb246IFFVSUNLX1RSQU5TSVRJT04sIHBoYXNlOiBcImluaXRpYWxcIiB9O1xuICB9O1xuICBjb25zdCB0b0ZuID0gKCkgPT4ge1xuICAgIHJldHVybiB7IHNjYWxpbmdYOiAxLCBzY2FsaW5nWTogMSB9O1xuICB9O1xuICBmcm9tVG9Nb3Rpb24oaWQsIFwibWFya2Vyc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBtYXJrZXJTZWxlY3Rpb25zLCB7IGZyb21GbiwgdG9GbiB9KTtcbn1cbmZ1bmN0aW9uIHJlc2V0TWFya2VyRm4oX25vZGUpIHtcbiAgcmV0dXJuIHsgb3BhY2l0eTogMSwgc2NhbGluZ1g6IDEsIHNjYWxpbmdZOiAxIH07XG59XG5mdW5jdGlvbiByZXNldE1hcmtlclBvc2l0aW9uRm4oX25vZGUsIGRhdHVtKSB7XG4gIHJldHVybiB7XG4gICAgdHJhbnNsYXRpb25YOiBkYXR1bS5wb2ludD8ueCA/PyBOYU4sXG4gICAgdHJhbnNsYXRpb25ZOiBkYXR1bS5wb2ludD8ueSA/PyBOYU5cbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVNYXJrZXJGb2N1c0JvdW5kcyhzZXJpZXMsIHsgZGF0dW1JbmRleCB9KSB7XG4gIGNvbnN0IG5vZGVEYXRhID0gc2VyaWVzLmdldE5vZGVEYXRhKCk7XG4gIGlmIChub2RlRGF0YSA9PT0gdm9pZCAwKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IGRhdHVtID0gbm9kZURhdGFbZGF0dW1JbmRleF07XG4gIGNvbnN0IHsgcG9pbnQgfSA9IGRhdHVtO1xuICBpZiAoZGF0dW0gPT0gbnVsbCB8fCBwb2ludCA9PSBudWxsKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IHNpemUgPSA0ICsgKHBvaW50LmZvY3VzU2l6ZSA/PyBzZXJpZXMuZ2V0Rm9ybWF0dGVkTWFya2VyU3R5bGUoZGF0dW0pLnNpemUpO1xuICBjb25zdCByYWRpdXMgPSBzaXplIC8gMjtcbiAgY29uc3QgeCA9IGRhdHVtLnBvaW50LnggLSByYWRpdXM7XG4gIGNvbnN0IHkgPSBkYXR1bS5wb2ludC55IC0gcmFkaXVzO1xuICByZXR1cm4gVHJhbnNmb3JtYWJsZS50b0NhbnZhcyhzZXJpZXMuY29udGVudEdyb3VwLCBuZXcgQkJveCh4LCB5LCBzaXplLCBzaXplKSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vcGF0aFV0aWwudHNcbmZ1bmN0aW9uIHBhdGhTd2lwZUluQW5pbWF0aW9uKHsgaWQsIHZpc2libGUsIG5vZGVEYXRhRGVwZW5kZW5jaWVzIH0sIGFuaW1hdGlvbk1hbmFnZXIsIC4uLnBhdGhzKSB7XG4gIGNvbnN0IHsgc2VyaWVzUmVjdFdpZHRoOiB3aWR0aDIsIHNlcmllc1JlY3RIZWlnaHQ6IGhlaWdodDIgfSA9IG5vZGVEYXRhRGVwZW5kZW5jaWVzO1xuICBzdGF0aWNGcm9tVG9Nb3Rpb24oXG4gICAgaWQsXG4gICAgXCJwYXRoX3Byb3BlcnRpZXNcIixcbiAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgIHBhdGhzLFxuICAgIHsgY2xpcFg6IDAgfSxcbiAgICB7IGNsaXBYOiB3aWR0aDIgfSxcbiAgICB7XG4gICAgICBwaGFzZTogXCJpbml0aWFsXCIsXG4gICAgICBzdGFydDogeyBjbGlwOiB0cnVlLCBjbGlwWTogaGVpZ2h0MiwgdmlzaWJsZSB9LFxuICAgICAgZmluaXNoOiB7IGNsaXA6IGZhbHNlLCB2aXNpYmxlIH1cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBwYXRoRmFkZUluQW5pbWF0aW9uKHsgaWQgfSwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIHBoYXNlID0gXCJhZGRcIiwgLi4uc2VsZWN0aW9uKSB7XG4gIHN0YXRpY0Zyb21Ub01vdGlvbihpZCwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIHNlbGVjdGlvbiwgeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9LCB7IHBoYXNlIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRSZXNldFBhdGhGbihvcHRzKSB7XG4gIHJldHVybiAoX25vZGUpID0+ICh7XG4gICAgdmlzaWJsZTogb3B0cy5nZXRWaXNpYmxlKCksXG4gICAgb3BhY2l0eTogb3B0cy5nZXRPcGFjaXR5KCksXG4gICAgY2xpcFNjYWxpbmdYOiAxLFxuICAgIGNsaXA6IGZhbHNlXG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2xpcFBhdGgoeyBub2RlRGF0YURlcGVuZGVuY2llcyB9LCBwYXRoKSB7XG4gIGNvbnN0IHRvRmluaXRlID0gKHZhbHVlKSA9PiBpc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IDA7XG4gIHBhdGguY2xpcFggPSB0b0Zpbml0ZShub2RlRGF0YURlcGVuZGVuY2llcy5zZXJpZXNSZWN0V2lkdGgpO1xuICBwYXRoLmNsaXBZID0gdG9GaW5pdGUobm9kZURhdGFEZXBlbmRlbmNpZXMuc2VyaWVzUmVjdEhlaWdodCk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYXJlYVNlcmllcy50c1xudmFyIENST1NTX0ZJTFRFUl9BUkVBX0ZJTExfT1BBQ0lUWV9GQUNUT1IgPSAwLjEyNTtcbnZhciBDUk9TU19GSUxURVJfQVJFQV9TVFJPS0VfT1BBQ0lUWV9GQUNUT1IgPSAwLjI1O1xudmFyIEFyZWFTZXJpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIGRpcmVjdGlvbktleXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTLFxuICAgICAgZGlyZWN0aW9uTmFtZXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyxcbiAgICAgIHBhdGhzUGVyU2VyaWVzOiBbXCJmaWxsXCIsIFwic3Ryb2tlXCJdLFxuICAgICAgcGF0aHNaSW5kZXhTdWJPcmRlck9mZnNldDogWzAsIDFlM10sXG4gICAgICBoYXNNYXJrZXJzOiB0cnVlLFxuICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgcGlja01vZGVzOiBbMiAvKiBBWElTX0FMSUdORUQgKi8sIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9dLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHtcbiAgICAgICAgcGF0aDogYnVpbGRSZXNldFBhdGhGbih7IGdldFZpc2libGU6ICgpID0+IHRoaXMudmlzaWJsZSwgZ2V0T3BhY2l0eTogKCkgPT4gdGhpcy5nZXRPcGFjaXR5KCkgfSksXG4gICAgICAgIGxhYmVsOiByZXNldExhYmVsRm4sXG4gICAgICAgIG1hcmtlcjogKG5vZGUsIGRhdHVtKSA9PiAoeyAuLi5yZXNldE1hcmtlckZuKG5vZGUpLCAuLi5yZXNldE1hcmtlclBvc2l0aW9uRm4obm9kZSwgZGF0dW0pIH0pXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gbmV3IEFyZWFTZXJpZXNQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5jb25uZWN0c1RvWUF4aXMgPSB0cnVlO1xuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwID0gbmV3IEdyb3VwKHtcbiAgICAgIG5hbWU6IGAke3RoaXMuaWR9LWJhY2tncm91bmRgLFxuICAgICAgekluZGV4OiAwIC8qIEJBQ0tHUk9VTkQgKi9cbiAgICB9KTtcbiAgICB0aGlzLl9pc1N0YWNrZWQgPSB2b2lkIDA7XG4gIH1cbiAgZ2V0IHBpY2tNb2RlQXhpcygpIHtcbiAgICByZXR1cm4gXCJtYWluXCI7XG4gIH1cbiAgcmVuZGVyVG9PZmZzY3JlZW5DYW52YXMoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnJlbmRlclRvT2Zmc2NyZWVuQ2FudmFzKCkgfHwgdGhpcy5jb250ZXh0Tm9kZURhdGEgIT0gbnVsbCAmJiAodGhpcy5jb250ZXh0Tm9kZURhdGEuZmlsbERhdGEuc3BhbnMubGVuZ3RoID4gUkVOREVSX1RPX09GRlNDUkVFTl9DQU5WQVNfVEhSRVNIT0xEIHx8IHRoaXMuY29udGV4dE5vZGVEYXRhLnN0cm9rZURhdGEuc3BhbnMubGVuZ3RoID4gUkVOREVSX1RPX09GRlNDUkVFTl9DQU5WQVNfVEhSRVNIT0xEKTtcbiAgfVxuICBhdHRhY2hTZXJpZXMoc2VyaWVzQ29udGVudE5vZGUsIHNlcmllc05vZGUsIGFubm90YXRpb25Ob2RlKSB7XG4gICAgc3VwZXIuYXR0YWNoU2VyaWVzKHNlcmllc0NvbnRlbnROb2RlLCBzZXJpZXNOb2RlLCBhbm5vdGF0aW9uTm9kZSk7XG4gICAgc2VyaWVzQ29udGVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5iYWNrZ3JvdW5kR3JvdXApO1xuICB9XG4gIGRldGFjaFNlcmllcyhzZXJpZXNDb250ZW50Tm9kZSwgc2VyaWVzTm9kZSwgYW5ub3RhdGlvbk5vZGUpIHtcbiAgICBzdXBlci5kZXRhY2hTZXJpZXMoc2VyaWVzQ29udGVudE5vZGUsIHNlcmllc05vZGUsIGFubm90YXRpb25Ob2RlKTtcbiAgICBzZXJpZXNDb250ZW50Tm9kZT8ucmVtb3ZlQ2hpbGQodGhpcy5iYWNrZ3JvdW5kR3JvdXApO1xuICB9XG4gIGF0dGFjaFBhdGhzKFtmaWxsLCBzdHJva2UyXSkge1xuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwLmFwcGVuZENoaWxkKGZpbGwpO1xuICAgIHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKHN0cm9rZTIpO1xuICAgIHN0cm9rZTIuekluZGV4ID0gLTE7XG4gIH1cbiAgZGV0YWNoUGF0aHMoW2ZpbGwsIHN0cm9rZTJdKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAucmVtb3ZlQ2hpbGQoZmlsbCk7XG4gICAgdGhpcy5jb250ZW50R3JvdXAucmVtb3ZlQ2hpbGQoc3Ryb2tlMik7XG4gIH1cbiAgaXNTdGFja2VkKCkge1xuICAgIGNvbnN0IHN0YWNrQ291bnQgPSB0aGlzLnNlcmllc0dyb3VwaW5nPy5zdGFja0NvdW50ID8/IDE7XG4gICAgcmV0dXJuIHN0YWNrQ291bnQgPiAxO1xuICB9XG4gIHNldFNlcmllc0luZGV4KGluZGV4KSB7XG4gICAgY29uc3QgaXNTdGFja2VkID0gdGhpcy5pc1N0YWNrZWQoKTtcbiAgICBpZiAoIXN1cGVyLnNldFNlcmllc0luZGV4KGluZGV4KSAmJiB0aGlzLl9pc1N0YWNrZWQgPT09IGlzU3RhY2tlZClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLl9pc1N0YWNrZWQgPSBpc1N0YWNrZWQ7XG4gICAgaWYgKGlzU3RhY2tlZCkge1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAuekluZGV4ID0gWzAgLyogQkFDS0dST1VORCAqLywgaW5kZXhdO1xuICAgICAgdGhpcy5jb250ZW50R3JvdXAuekluZGV4ID0gWzEgLyogQU5ZX0NPTlRFTlQgKi8sIGluZGV4LCAwIC8qIEZPUkVHUk9VTkQgKi9dO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJhY2tncm91bmRHcm91cC56SW5kZXggPSBbMSAvKiBBTllfQ09OVEVOVCAqLywgaW5kZXgsIDAgLyogRk9SRUdST1VORCAqLywgMF07XG4gICAgICB0aGlzLmNvbnRlbnRHcm91cC56SW5kZXggPSBbMSAvKiBBTllfQ09OVEVOVCAqLywgaW5kZXgsIDAgLyogRk9SRUdST1VORCAqLywgMV07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XG4gICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0YSwgdmlzaWJsZSwgc2VyaWVzR3JvdXBpbmc6IHsgZ3JvdXBJbmRleCA9IHRoaXMuaWQsIHN0YWNrQ291bnQgPSAxIH0gPSB7fSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHlGaWx0ZXJLZXksIGNvbm5lY3RNaXNzaW5nRGF0YSwgbm9ybWFsaXplZFRvIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9uRW5hYmxlZCA9ICF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IHhTY2FsZSA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dPy5zY2FsZTtcbiAgICBjb25zdCB7IHhTY2FsZVR5cGUsIHlTY2FsZVR5cGUgfSA9IHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHhTY2FsZSwgeVNjYWxlIH0pO1xuICAgIGNvbnN0IGlkTWFwID0ge1xuICAgICAgdmFsdWU6IGBhcmVhLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlYCxcbiAgICAgIHZhbHVlczogYGFyZWEtc3RhY2stJHtncm91cEluZGV4fS15VmFsdWVzYCxcbiAgICAgIHN0YWNrOiBgYXJlYS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZS1zdGFja2AsXG4gICAgICBtYXJrZXI6IGBhcmVhLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlcy1tYXJrZXJgXG4gICAgfTtcbiAgICBjb25zdCBleHRyYVByb3BzID0gW107XG4gICAgaWYgKGlzRGVmaW5lZChub3JtYWxpemVkVG8pKSB7XG4gICAgICBleHRyYVByb3BzLnB1c2gobm9ybWFsaXNlR3JvdXBUbyhPYmplY3QudmFsdWVzKGlkTWFwKSwgbm9ybWFsaXplZFRvKSk7XG4gICAgfVxuICAgIGlmIChhbmltYXRpb25FbmFibGVkKSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goYW5pbWF0aW9uVmFsaWRhdGlvbigpKTtcbiAgICB9XG4gICAgY29uc3QgY29tbW9uID0geyBpbnZhbGlkVmFsdWU6IG51bGwgfTtcbiAgICBpZiAoKGlzRGVmaW5lZChub3JtYWxpemVkVG8pIHx8IGNvbm5lY3RNaXNzaW5nRGF0YSkgJiYgc3RhY2tDb3VudCA+IDEpIHtcbiAgICAgIGNvbW1vbi5pbnZhbGlkVmFsdWUgPSAwO1xuICAgIH1cbiAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgIGNvbW1vbi5mb3JjZVZhbHVlID0gMDtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCB7XG4gICAgICBwcm9wczogW1xuICAgICAgICBrZXlQcm9wZXJ0eSh4S2V5LCB4U2NhbGVUeXBlLCB7IGlkOiBcInhWYWx1ZVwiIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IGB5VmFsdWVSYXdgLCAuLi5jb21tb24gfSksXG4gICAgICAgIC4uLnlGaWx0ZXJLZXkgIT0gbnVsbCA/IFt2YWx1ZVByb3BlcnR5KHlGaWx0ZXJLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IFwieUZpbHRlclJhd1wiIH0pXSA6IFtdLFxuICAgICAgICAuLi5ncm91cFN0YWNrVmFsdWVQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7IGlkOiBgeVZhbHVlU3RhY2tgLCAuLi5jb21tb24sIGdyb3VwSWQ6IGlkTWFwLnN0YWNrIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IGB5VmFsdWVgLCAuLi5jb21tb24sIGdyb3VwSWQ6IGlkTWFwLnZhbHVlIH0pLFxuICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICBcIndpbmRvd1wiLFxuICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgIHsgaWQ6IGB5VmFsdWVFbmRgLCAuLi5jb21tb24sIGdyb3VwSWQ6IGlkTWFwLnZhbHVlcyB9LFxuICAgICAgICAgIHlTY2FsZVR5cGVcbiAgICAgICAgKSxcbiAgICAgICAgLi4uZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KFxuICAgICAgICAgIHlLZXksXG4gICAgICAgICAgXCJub3JtYWxcIixcbiAgICAgICAgICBcImN1cnJlbnRcIixcbiAgICAgICAgICB7IGlkOiBgeVZhbHVlQ3VtdWxhdGl2ZWAsIC4uLmNvbW1vbiwgZ3JvdXBJZDogaWRNYXAubWFya2VyIH0sXG4gICAgICAgICAgeVNjYWxlVHlwZVxuICAgICAgICApLFxuICAgICAgICAuLi5leHRyYVByb3BzXG4gICAgICBdLFxuICAgICAgZ3JvdXBCeUtleXM6IHRydWUsXG4gICAgICBncm91cEJ5RGF0YTogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIHhDb29yZGluYXRlUmFuZ2UoeFZhbHVlLCBwaXhlbFNpemUpIHtcbiAgICBjb25zdCB7IG1hcmtlciB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHggPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL10uc2NhbGUuY29udmVydCh4VmFsdWUpO1xuICAgIGNvbnN0IHIgPSBtYXJrZXIuZW5hYmxlZCA/IDAuNSAqIG1hcmtlci5zaXplICogcGl4ZWxTaXplIDogMDtcbiAgICByZXR1cm4gW3ggLSByLCB4ICsgcl07XG4gIH1cbiAgeUNvb3JkaW5hdGVSYW5nZSh5VmFsdWVzLCBwaXhlbFNpemUpIHtcbiAgICBjb25zdCB7IG1hcmtlciB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHkgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL10uc2NhbGUuY29udmVydCh5VmFsdWVzWzBdKTtcbiAgICBjb25zdCByID0gbWFya2VyLmVuYWJsZWQgPyAwLjUgKiBtYXJrZXIuc2l6ZSAqIHBpeGVsU2l6ZSA6IDA7XG4gICAgcmV0dXJuIFt5IC0gciwgeSArIHJdO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB7IHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCwgYXhlcyB9ID0gdGhpcztcbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLykge1xuICAgICAgY29uc3Qga2V5RGVmID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZCh0aGlzLCBgeFZhbHVlYCk7XG4gICAgICBjb25zdCBrZXlzID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeFZhbHVlYCwgXCJrZXlcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgICBpZiAoa2V5RGVmPy5kZWYudHlwZSA9PT0gXCJrZXlcIiAmJiBrZXlEZWYuZGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZXh0ZW50KGtleXMpKTtcbiAgICB9XG4gICAgY29uc3QgeUV4dGVudCA9IHRoaXMuZG9tYWluRm9yQ2xpcHBlZFJhbmdlKFwieVwiIC8qIFkgKi8sIFtcInlWYWx1ZUVuZFwiXSwgXCJ4VmFsdWVcIiwgdHJ1ZSk7XG4gICAgaWYgKHlBeGlzIGluc3RhbmNlb2YgTG9nQXhpcyB8fCB5QXhpcyBpbnN0YW5jZW9mIFRpbWVBeGlzKSB7XG4gICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudCh5RXh0ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZml4ZWRZRXh0ZW50ID0gTnVtYmVyLmlzRmluaXRlKHlFeHRlbnRbMV0gLSB5RXh0ZW50WzBdKSA/IFt5RXh0ZW50WzBdID4gMCA/IDAgOiB5RXh0ZW50WzBdLCB5RXh0ZW50WzFdIDwgMCA/IDAgOiB5RXh0ZW50WzFdXSA6IFtdO1xuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZml4ZWRZRXh0ZW50KTtcbiAgICB9XG4gIH1cbiAgZ2V0U2VyaWVzUmFuZ2UoX2RpcmVjdGlvbiwgdmlzaWJsZVJhbmdlKSB7XG4gICAgY29uc3QgW3kwLCB5MV0gPSB0aGlzLmRvbWFpbkZvclZpc2libGVSYW5nZShcInlcIiAvKiBZICovLCBbXCJ5VmFsdWVFbmRcIl0sIFwieFZhbHVlXCIsIHZpc2libGVSYW5nZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIFtNYXRoLm1pbih5MCwgMCksIE1hdGgubWF4KHkxLCAwKV07XG4gIH1cbiAgZ2V0VmlzaWJsZUl0ZW1zKHhWaXNpYmxlUmFuZ2UsIHlWaXNpYmxlUmFuZ2UsIG1pblZpc2libGVJdGVtcykge1xuICAgIHJldHVybiB0aGlzLmNvdW50VmlzaWJsZUl0ZW1zKFwieFZhbHVlXCIsIFtcInlWYWx1ZUVuZFwiXSwgeFZpc2libGVSYW5nZSwgeVZpc2libGVSYW5nZSwgbWluVmlzaWJsZUl0ZW1zKTtcbiAgfVxuICBjcmVhdGVOb2RlRGF0YSgpIHtcbiAgICBjb25zdCB7IGF4ZXMsIGRhdGEsIHByb2Nlc3NlZERhdGEsIGRhdGFNb2RlbCB9ID0gdGhpcztcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICgheEF4aXMgfHwgIXlBeGlzIHx8ICFkYXRhIHx8ICFkYXRhTW9kZWwgfHwgcHJvY2Vzc2VkRGF0YT8udHlwZSAhPT0gXCJncm91cGVkXCIgfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgeUtleSxcbiAgICAgIHhLZXksXG4gICAgICB5RmlsdGVyS2V5LFxuICAgICAgbWFya2VyLFxuICAgICAgbGFiZWwsXG4gICAgICBmaWxsOiBzZXJpZXNGaWxsLFxuICAgICAgc3Ryb2tlOiBzZXJpZXNTdHJva2UsXG4gICAgICBjb25uZWN0TWlzc2luZ0RhdGEsXG4gICAgICBpbnRlcnBvbGF0aW9uXG4gICAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IHNjYWxlOiB4U2NhbGUgfSA9IHhBeGlzO1xuICAgIGNvbnN0IHsgc2NhbGU6IHlTY2FsZSB9ID0geUF4aXM7XG4gICAgY29uc3QgeyBpc0NvbnRpbnVvdXNZIH0gPSB0aGlzLmdldFNjYWxlSW5mb3JtYXRpb24oeyB4U2NhbGUsIHlTY2FsZSB9KTtcbiAgICBjb25zdCB4T2Zmc2V0ID0gKHhTY2FsZS5iYW5kd2lkdGggPz8gMCkgLyAyO1xuICAgIGNvbnN0IHhWYWx1ZXMgPSBkYXRhTW9kZWwucmVzb2x2ZUtleXNCeUlkKHRoaXMsIFwieFZhbHVlXCIsIHByb2Nlc3NlZERhdGEpO1xuICAgIGNvbnN0IHlFbmRWYWx1ZXMgPSBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYHlWYWx1ZUVuZGAsIHByb2Nlc3NlZERhdGEpO1xuICAgIGNvbnN0IHlSYXdWYWx1ZXMgPSBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYHlWYWx1ZVJhd2AsIHByb2Nlc3NlZERhdGEpO1xuICAgIGNvbnN0IHlDdW11bGF0aXZlVmFsdWVzID0gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGB5VmFsdWVDdW11bGF0aXZlYCwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgY29uc3QgeUZpbHRlclZhbHVlcyA9IHlGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBcInlGaWx0ZXJSYXdcIiwgcHJvY2Vzc2VkRGF0YSkgOiB2b2lkIDA7XG4gICAgY29uc3QgeVN0YWNrVmFsdWVzID0gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIFwieVZhbHVlU3RhY2tcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgY29uc3QgY3JlYXRlTWFya2VyQ29vcmRpbmF0ZSA9ICh4RGF0dW0sIHlFbmQsIHJhd1lEYXR1bSkgPT4ge1xuICAgICAgbGV0IGN1cnJZO1xuICAgICAgaWYgKGlzRGVmaW5lZCh0aGlzLnByb3BlcnRpZXMubm9ybWFsaXplZFRvKSA/IGlzQ29udGludW91c1kgJiYgaXNDb250aW51b3VzKHJhd1lEYXR1bSkgOiAhaXNOYU4ocmF3WURhdHVtKSkge1xuICAgICAgICBjdXJyWSA9IHlFbmQ7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4U2NhbGUuY29udmVydCh4RGF0dW0pICsgeE9mZnNldCxcbiAgICAgICAgeTogeVNjYWxlLmNvbnZlcnQoY3VyclkpLFxuICAgICAgICBzaXplOiBtYXJrZXIuc2l6ZVxuICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IGxhYmVsRGF0YSA9IFtdO1xuICAgIGNvbnN0IG1hcmtlckRhdGEgPSBbXTtcbiAgICBjb25zdCB7IHZpc2libGVTYW1lU3RhY2tDb3VudCB9ID0gdGhpcy5jdHguc2VyaWVzU3RhdGVNYW5hZ2VyLmdldFZpc2libGVQZWVyR3JvdXBJbmRleCh0aGlzKTtcbiAgICBsZXQgY3Jvc3NGaWx0ZXJpbmcgPSBmYWxzZTtcbiAgICBjb25zdCB7IGRhdGFTb3VyY2VzIH0gPSBwcm9jZXNzZWREYXRhO1xuICAgIGNvbnN0IHJhd0RhdGEgPSBkYXRhU291cmNlcy5nZXQodGhpcy5pZCkgPz8gW107XG4gICAgZm9yIChjb25zdCB7IGRhdHVtSW5kZXggfSBvZiBkYXRhTW9kZWwuZm9yRWFjaEdyb3VwRGF0dW0odGhpcywgcHJvY2Vzc2VkRGF0YSkpIHtcbiAgICAgIGNvbnN0IHhEYXR1bSA9IHhWYWx1ZXNbZGF0dW1JbmRleF07XG4gICAgICBpZiAoeERhdHVtID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHNlcmllc0RhdHVtID0gcmF3RGF0YVtkYXR1bUluZGV4XTtcbiAgICAgIGNvbnN0IHlEYXR1bSA9IHlSYXdWYWx1ZXNbZGF0dW1JbmRleF07XG4gICAgICBjb25zdCB5VmFsdWVDdW11bGF0aXZlID0geUN1bXVsYXRpdmVWYWx1ZXNbZGF0dW1JbmRleF07XG4gICAgICBjb25zdCB5VmFsdWVFbmQgPSB5RW5kVmFsdWVzW2RhdHVtSW5kZXhdO1xuICAgICAgY29uc3QgdmFsaWRQb2ludCA9IE51bWJlci5pc0Zpbml0ZSh5RGF0dW0pO1xuICAgICAgY29uc3QgcG9pbnQgPSBjcmVhdGVNYXJrZXJDb29yZGluYXRlKHhEYXR1bSwgK3lWYWx1ZUN1bXVsYXRpdmUsIHlEYXR1bSk7XG4gICAgICBjb25zdCBzZWxlY3RlZCA9IHlGaWx0ZXJWYWx1ZXMgIT0gbnVsbCA/IHlGaWx0ZXJWYWx1ZXNbZGF0dW1JbmRleF0gPT09IHlEYXR1bSA6IHZvaWQgMDtcbiAgICAgIGlmIChzZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY3Jvc3NGaWx0ZXJpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbGlkUG9pbnQgJiYgbWFya2VyKSB7XG4gICAgICAgIG1hcmtlckRhdGEucHVzaCh7XG4gICAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgICAgICBkYXR1bTogc2VyaWVzRGF0dW0sXG4gICAgICAgICAgZGF0dW1JbmRleCxcbiAgICAgICAgICBtaWRQb2ludDogeyB4OiBwb2ludC54LCB5OiBwb2ludC55IH0sXG4gICAgICAgICAgY3VtdWxhdGl2ZVZhbHVlOiB5VmFsdWVFbmQsXG4gICAgICAgICAgeVZhbHVlOiB5RGF0dW0sXG4gICAgICAgICAgeFZhbHVlOiB4RGF0dW0sXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICB4S2V5LFxuICAgICAgICAgIHBvaW50LFxuICAgICAgICAgIGZpbGw6IG1hcmtlci5maWxsID8/IHNlcmllc0ZpbGwsXG4gICAgICAgICAgc3Ryb2tlOiBtYXJrZXIuc3Ryb2tlID8/IHNlcmllc1N0cm9rZSxcbiAgICAgICAgICBzdHJva2VXaWR0aDogbWFya2VyLnN0cm9rZVdpZHRoID8/IHRoaXMuZ2V0U3Ryb2tlV2lkdGgodGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoKSxcbiAgICAgICAgICBzZWxlY3RlZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWxpZFBvaW50ICYmIGxhYmVsKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KGxhYmVsLCB7XG4gICAgICAgICAgdmFsdWU6IHlEYXR1bSxcbiAgICAgICAgICBkYXR1bTogc2VyaWVzRGF0dW0sXG4gICAgICAgICAgeEtleSxcbiAgICAgICAgICB5S2V5LFxuICAgICAgICAgIHhOYW1lOiB0aGlzLnByb3BlcnRpZXMueE5hbWUsXG4gICAgICAgICAgeU5hbWU6IHRoaXMucHJvcGVydGllcy55TmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgbGFiZWxEYXRhLnB1c2goe1xuICAgICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICAgICAgZGF0dW06IHNlcmllc0RhdHVtLFxuICAgICAgICAgIGRhdHVtSW5kZXgsXG4gICAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgICB5OiBwb2ludC55LFxuICAgICAgICAgIGxhYmVsVGV4dFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3BhbnNGb3JQb2ludHMgPSAocG9pbnRzKSA9PiB7XG4gICAgICByZXR1cm4gcG9pbnRzLmZsYXRNYXAoKHApID0+IHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocCkgPyBpbnRlcnBvbGF0ZVBvaW50cyhwLCBpbnRlcnBvbGF0aW9uKSA6IG5ldyBBcnJheShwLnNraXApLmZpbGwobnVsbCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZVBvaW50ID0gKHhEYXR1bSwgeURhdHVtKSA9PiAoe1xuICAgICAgcG9pbnQ6IHtcbiAgICAgICAgeDogeFNjYWxlLmNvbnZlcnQoeERhdHVtKSArIHhPZmZzZXQsXG4gICAgICAgIHk6IHlTY2FsZS5jb252ZXJ0KHlEYXR1bSlcbiAgICAgIH0sXG4gICAgICB4RGF0dW0sXG4gICAgICB5RGF0dW1cbiAgICB9KTtcbiAgICBjb25zdCBnZXRTZXJpZXNTcGFucyA9IChpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgZGF0dW1JbmRleGVzOiBbcElkeCwgZGF0dW1JbmRleCwgbkluZHhdXG4gICAgICB9IG9mIGRhdGFNb2RlbC5mb3JFYWNoR3JvdXBEYXR1bVR1cGxlKHRoaXMsIHByb2Nlc3NlZERhdGEpKSB7XG4gICAgICAgIGNvbnN0IHhEYXR1bSA9IHhWYWx1ZXNbZGF0dW1JbmRleF07XG4gICAgICAgIGNvbnN0IHlWYWx1ZVN0YWNrID0geVN0YWNrVmFsdWVzW2RhdHVtSW5kZXhdO1xuICAgICAgICBjb25zdCB5RGF0dW0gPSB5VmFsdWVTdGFja1tpbmRleF07XG4gICAgICAgIGNvbnN0IHlEYXR1bUlzRmluaXRlID0gTnVtYmVyLmlzRmluaXRlKHlEYXR1bSk7XG4gICAgICAgIGlmIChjb25uZWN0TWlzc2luZ0RhdGEgJiYgIXlEYXR1bUlzRmluaXRlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBsYXN0WVZhbHVlU3RhY2sgPSBwSWR4ICE9IG51bGwgPyB5U3RhY2tWYWx1ZXNbcElkeF0gOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IG5leHRZVmFsdWVTdGFjayA9IG5JbmR4ICE9IG51bGwgPyB5U3RhY2tWYWx1ZXNbbkluZHhdIDogdm9pZCAwO1xuICAgICAgICBsZXQgeVZhbHVlRW5kQmFja3dhcmRzID0gMDtcbiAgICAgICAgbGV0IHlWYWx1ZUVuZEZvcndhcmRzID0gMDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gaW5kZXg7IGogKz0gMSkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0geVZhbHVlU3RhY2tbal07XG4gICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RXYXNGaW5pdGUgPSBsYXN0WVZhbHVlU3RhY2sgPT0gbnVsbCB8fCBOdW1iZXIuaXNGaW5pdGUobGFzdFlWYWx1ZVN0YWNrW2pdKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRXYXNGaW5pdGUgPSBuZXh0WVZhbHVlU3RhY2sgPT0gbnVsbCB8fCBOdW1iZXIuaXNGaW5pdGUobmV4dFlWYWx1ZVN0YWNrW2pdKTtcbiAgICAgICAgICAgIGlmIChsYXN0V2FzRmluaXRlKSB7XG4gICAgICAgICAgICAgIHlWYWx1ZUVuZEJhY2t3YXJkcyArPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0V2FzRmluaXRlKSB7XG4gICAgICAgICAgICAgIHlWYWx1ZUVuZEZvcndhcmRzICs9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50UG9pbnRzID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKCFjb25uZWN0TWlzc2luZ0RhdGEgJiYgKHlWYWx1ZUVuZEJhY2t3YXJkcyAhPT0geVZhbHVlRW5kRm9yd2FyZHMgfHwgIXlEYXR1bUlzRmluaXRlKSkge1xuICAgICAgICAgIGlmICgheURhdHVtSXNGaW5pdGUgJiYgQXJyYXkuaXNBcnJheShjdXJyZW50UG9pbnRzKSAmJiBjdXJyZW50UG9pbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA9IHsgc2tpcDogMSB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludEJhY2t3YXJkcyA9IGNyZWF0ZVBvaW50KHhEYXR1bSwgeVZhbHVlRW5kQmFja3dhcmRzKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50Rm9yd2FyZHMgPSBjcmVhdGVQb2ludCh4RGF0dW0sIHlWYWx1ZUVuZEZvcndhcmRzKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRQb2ludHMpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludHMucHVzaChwb2ludEJhY2t3YXJkcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRQb2ludHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjdXJyZW50UG9pbnRzLnNraXAgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHlEYXR1bUlzRmluaXRlID8gW3BvaW50Rm9yd2FyZHNdIDogeyBza2lwOiAwIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB5VmFsdWVFbmQgPSBNYXRoLm1heCh5VmFsdWVFbmRCYWNrd2FyZHMsIHlWYWx1ZUVuZEZvcndhcmRzKTtcbiAgICAgICAgICBjb25zdCBwb2ludCA9IGNyZWF0ZVBvaW50KHhEYXR1bSwgeVZhbHVlRW5kKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50UG9pbnRzKSkge1xuICAgICAgICAgICAgY3VycmVudFBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRQb2ludHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3VycmVudFBvaW50cy5za2lwICs9IDE7XG4gICAgICAgICAgICBwb2ludHMucHVzaChbcG9pbnRdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goW3BvaW50XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3BhbnNGb3JQb2ludHMocG9pbnRzKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YWNrSW5kZXggPSB0aGlzLnNlcmllc0dyb3VwaW5nPy5zdGFja0luZGV4ID8/IDA7XG4gICAgY29uc3QgZ2V0QXhpc1NwYW5zID0gKCkgPT4ge1xuICAgICAgY29uc3QgeVZhbHVlWmVyb1BvaW50cyA9IEFycmF5LmZyb20oZGF0YU1vZGVsLmZvckVhY2hHcm91cERhdHVtKHRoaXMsIHByb2Nlc3NlZERhdGEpLCAoeyBkYXR1bUluZGV4IH0pID0+IHtcbiAgICAgICAgY29uc3QgeERhdHVtID0geFZhbHVlc1tkYXR1bUluZGV4XTtcbiAgICAgICAgY29uc3QgeVZhbHVlU3RhY2sgPSB5U3RhY2tWYWx1ZXNbZGF0dW1JbmRleF07XG4gICAgICAgIGNvbnN0IHlEYXR1bSA9IHlWYWx1ZVN0YWNrW3N0YWNrSW5kZXhdO1xuICAgICAgICBpZiAoY29ubmVjdE1pc3NpbmdEYXRhICYmICFOdW1iZXIuaXNGaW5pdGUoeURhdHVtKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBjcmVhdGVQb2ludCh4RGF0dW0sIDApO1xuICAgICAgfSkuZmlsdGVyKCh4KSA9PiB4ICE9IG51bGwpO1xuICAgICAgcmV0dXJuIGludGVycG9sYXRlUG9pbnRzKHlWYWx1ZVplcm9Qb2ludHMsIGludGVycG9sYXRpb24pO1xuICAgIH07XG4gICAgY29uc3QgY3VycmVudFNlcmllc1NwYW5zID0gZ2V0U2VyaWVzU3BhbnMoc3RhY2tJbmRleCk7XG4gICAgY29uc3QgcGhhbnRvbVNwYW5zID0gY3VycmVudFNlcmllc1NwYW5zLm1hcCgoKSA9PiBudWxsKTtcbiAgICBmb3IgKGxldCBqID0gc3RhY2tJbmRleCAtIDE7IGogPj0gLTE7IGogLT0gMSkge1xuICAgICAgbGV0IHNwYW5zO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaGFudG9tU3BhbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHBoYW50b21TcGFuc1tpXSAhPSBudWxsKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBzcGFucyA/PyAoc3BhbnMgPSBqICE9PSAtMSA/IGdldFNlcmllc1NwYW5zKGopIDogZ2V0QXhpc1NwYW5zKCkpO1xuICAgICAgICBwaGFudG9tU3BhbnNbaV0gPSBzcGFuc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlsbFNwYW5zID0gY3VycmVudFNlcmllc1NwYW5zLm1hcCgoc3BhbiwgaW5kZXgpID0+IHNwYW4gPz8gcGhhbnRvbVNwYW5zW2luZGV4XSk7XG4gICAgY29uc3Qgc3Ryb2tlU3BhbnMgPSBjdXJyZW50U2VyaWVzU3BhbnMuZmlsdGVyKChzcGFuKSA9PiBzcGFuICE9IG51bGwpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICBmaWxsRGF0YTogeyBpdGVtSWQ6IHlLZXksIHNwYW5zOiBmaWxsU3BhbnMsIHBoYW50b21TcGFucyB9LFxuICAgICAgc3Ryb2tlRGF0YTogeyBpdGVtSWQ6IHlLZXksIHNwYW5zOiBzdHJva2VTcGFucyB9LFxuICAgICAgbGFiZWxEYXRhLFxuICAgICAgbm9kZURhdGE6IG1hcmtlckRhdGEsXG4gICAgICBzY2FsZXM6IHRoaXMuY2FsY3VsYXRlU2NhbGluZygpLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxuICAgICAgc3RhY2tWaXNpYmxlOiB2aXNpYmxlU2FtZVN0YWNrQ291bnQgPiAwLFxuICAgICAgY3Jvc3NGaWx0ZXJpbmdcbiAgICB9O1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG4gIGlzUGF0aE9yU2VsZWN0aW9uRGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5tYXJrZXIuaXNEaXJ0eSgpO1xuICB9XG4gIHVwZGF0ZVBhdGhOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBvcGFjaXR5LCB2aXNpYmxlLCBhbmltYXRpb25FbmFibGVkIH0gPSBvcHRzO1xuICAgIGNvbnN0IFtmaWxsLCBzdHJva2UyXSA9IG9wdHMucGF0aHM7XG4gICAgY29uc3QgY3Jvc3NGaWx0ZXJpbmcgPSB0aGlzLmNvbnRleHROb2RlRGF0YT8uY3Jvc3NGaWx0ZXJpbmcgPT09IHRydWU7XG4gICAgY29uc3Qgc3Ryb2tlV2lkdGggPSB0aGlzLmdldFN0cm9rZVdpZHRoKHRoaXMucHJvcGVydGllcy5zdHJva2VXaWR0aCk7XG4gICAgc3Ryb2tlMi5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgIGZpbGw6IHZvaWQgMCxcbiAgICAgIGxpbmVDYXA6IFwicm91bmRcIixcbiAgICAgIGxpbmVKb2luOiBcInJvdW5kXCIsXG4gICAgICBwb2ludGVyRXZlbnRzOiAxIC8qIE5vbmUgKi8sXG4gICAgICBzdHJva2U6IHRoaXMucHJvcGVydGllcy5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZU9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5zdHJva2VPcGFjaXR5ICogKGNyb3NzRmlsdGVyaW5nID8gQ1JPU1NfRklMVEVSX0FSRUFfU1RST0tFX09QQUNJVFlfRkFDVE9SIDogMSksXG4gICAgICBsaW5lRGFzaDogdGhpcy5wcm9wZXJ0aWVzLmxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IHRoaXMucHJvcGVydGllcy5saW5lRGFzaE9mZnNldCxcbiAgICAgIG9wYWNpdHksXG4gICAgICB2aXNpYmxlOiB2aXNpYmxlIHx8IGFuaW1hdGlvbkVuYWJsZWRcbiAgICB9KTtcbiAgICBjb25zdCB7IGZpbGw6IHNlcmllc0ZpbGwgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAoaXNHcmFkaWVudEZpbGwoc2VyaWVzRmlsbCkpIHtcbiAgICAgIGNvbnN0IGdyYWRpZW50RmlsbE9wdGlvbnMgPSB0aGlzLmdldEdyYWRpZW50RmlsbE9wdGlvbnMoc2VyaWVzRmlsbCwgdGhpcy5wcm9wZXJ0aWVzLmRlZmF1bHRDb2xvclJhbmdlKTtcbiAgICAgIGZpbGwuZ3JhZGllbnRGaWxsT3B0aW9ucyA9IGdyYWRpZW50RmlsbE9wdGlvbnM7XG4gICAgfVxuICAgIGZpbGwuc2V0UHJvcGVydGllcyh7XG4gICAgICBzdHJva2U6IHZvaWQgMCxcbiAgICAgIGxpbmVKb2luOiBcInJvdW5kXCIsXG4gICAgICBwb2ludGVyRXZlbnRzOiAxIC8qIE5vbmUgKi8sXG4gICAgICBmaWxsOiB0aGlzLnByb3BlcnRpZXMuZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuZmlsbE9wYWNpdHkgKiAoY3Jvc3NGaWx0ZXJpbmcgPyBDUk9TU19GSUxURVJfQVJFQV9GSUxMX09QQUNJVFlfRkFDVE9SIDogMSksXG4gICAgICBmaWxsU2hhZG93OiB0aGlzLnByb3BlcnRpZXMuc2hhZG93LFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHZpc2libGU6IHZpc2libGUgfHwgYW5pbWF0aW9uRW5hYmxlZFxuICAgIH0pO1xuICAgIHVwZGF0ZUNsaXBQYXRoKHRoaXMsIHN0cm9rZTIpO1xuICAgIHVwZGF0ZUNsaXBQYXRoKHRoaXMsIGZpbGwpO1xuICB9XG4gIHVwZGF0ZVBhdGhzKG9wdHMpIHtcbiAgICB0aGlzLnVwZGF0ZUFyZWFQYXRocyhvcHRzLnBhdGhzLCBvcHRzLmNvbnRleHREYXRhKTtcbiAgfVxuICB1cGRhdGVBcmVhUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKSB7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICBwYXRoLnZpc2libGUgPSBjb250ZXh0RGF0YS52aXNpYmxlO1xuICAgIH1cbiAgICBpZiAoY29udGV4dERhdGEudmlzaWJsZSkge1xuICAgICAgdGhpcy51cGRhdGVGaWxsUGF0aChwYXRocywgY29udGV4dERhdGEpO1xuICAgICAgdGhpcy51cGRhdGVTdHJva2VQYXRoKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgICBwYXRoLnBhdGguY2xlYXIoKTtcbiAgICAgICAgcGF0aC5tYXJrRGlydHkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdXBkYXRlRmlsbFBhdGgocGF0aHMsIGNvbnRleHREYXRhKSB7XG4gICAgY29uc3QgW2ZpbGxdID0gcGF0aHM7XG4gICAgZmlsbC5wYXRoLmNsZWFyKCk7XG4gICAgcGxvdEFyZWFQYXRoRmlsbChmaWxsLCBjb250ZXh0RGF0YS5maWxsRGF0YSk7XG4gICAgZmlsbC5tYXJrRGlydHkoKTtcbiAgfVxuICB1cGRhdGVTdHJva2VQYXRoKHBhdGhzLCBjb250ZXh0RGF0YSkge1xuICAgIGNvbnN0IHsgc3BhbnMgfSA9IGNvbnRleHREYXRhLnN0cm9rZURhdGE7XG4gICAgY29uc3QgWywgc3Ryb2tlMl0gPSBwYXRocztcbiAgICBzdHJva2UyLnBhdGguY2xlYXIoKTtcbiAgICBwbG90TGluZVBhdGhTdHJva2Uoc3Ryb2tlMiwgc3BhbnMpO1xuICAgIHN0cm9rZTIubWFya0RpcnR5KCk7XG4gIH1cbiAgdXBkYXRlTWFya2VyU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBjb25zdCB7IG5vZGVEYXRhLCBtYXJrZXJTZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgY29uc3QgbWFya2Vyc0VuYWJsZWQgPSB0aGlzLnByb3BlcnRpZXMubWFya2VyLmVuYWJsZWQgfHwgdGhpcy5jb250ZXh0Tm9kZURhdGE/LmNyb3NzRmlsdGVyaW5nID09PSB0cnVlO1xuICAgIGlmICh0aGlzLnByb3BlcnRpZXMubWFya2VyLmlzRGlydHkoKSkge1xuICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2VyU2VsZWN0aW9uLnVwZGF0ZShtYXJrZXJzRW5hYmxlZCA/IG5vZGVEYXRhIDogW10pO1xuICB9XG4gIGdldE1hcmtlckl0ZW1CYXNlU3R5bGUoaGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25zdCB7IG1hcmtlciB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGhpZ2hsaWdodFN0eWxlID0gaGlnaGxpZ2h0ZWQgPyB0aGlzLnByb3BlcnRpZXMuaGlnaGxpZ2h0U3R5bGUuaXRlbSA6IHZvaWQgMDtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbDogaGlnaGxpZ2h0U3R5bGU/LmZpbGwgPz8gbWFya2VyLmZpbGwsXG4gICAgICBmaWxsT3BhY2l0eTogaGlnaGxpZ2h0U3R5bGU/LmZpbGxPcGFjaXR5ID8/IG1hcmtlci5maWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZTogaGlnaGxpZ2h0U3R5bGU/LnN0cm9rZSA/PyBtYXJrZXIuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IGhpZ2hsaWdodFN0eWxlPy5zdHJva2VXaWR0aCA/PyBtYXJrZXIuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VPcGFjaXR5OiBoaWdobGlnaHRTdHlsZT8uc3Ryb2tlT3BhY2l0eSA/PyBtYXJrZXIuc3Ryb2tlT3BhY2l0eVxuICAgIH07XG4gIH1cbiAgZ2V0TWFya2VySXRlbVN0eWxlT3ZlcnJpZGVzKGRhdHVtSWQsIGRhdHVtLCB4VmFsdWUsIHlWYWx1ZSwgZm9ybWF0LCBoaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHsgbWFya2VyIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBpdGVtU3R5bGVyIH0gPSBtYXJrZXI7XG4gICAgaWYgKGl0ZW1TdHlsZXIgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGlkOiBzZXJpZXNJZCwgcHJvcGVydGllcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHhLZXksIHlLZXkgfSA9IHByb3BlcnRpZXM7XG4gICAgY29uc3QgeyB4RG9tYWluLCB5RG9tYWluIH0gPSB0aGlzLmNhY2hlZERhdHVtQ2FsbGJhY2soXCJkb21haW5cIiwgKCkgPT4gKHtcbiAgICAgIHhEb21haW46IHRoaXMuZ2V0U2VyaWVzRG9tYWluKFwieFwiIC8qIFggKi8pLFxuICAgICAgeURvbWFpbjogdGhpcy5nZXRTZXJpZXNEb21haW4oXCJ5XCIgLyogWSAqLylcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVkRGF0dW1DYWxsYmFjayhjcmVhdGVEYXR1bUlkKGRhdHVtSWQsIGhpZ2hsaWdodGVkID8gXCJoaWdobGlnaHRcIiA6IFwibm9kZVwiKSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIGl0ZW1TdHlsZXIoe1xuICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgLi4uZGF0dW1TdHlsZXJQcm9wZXJ0aWVzKGRhdHVtLCB4S2V5LCB5S2V5LCB4RG9tYWluLCB5RG9tYWluKSxcbiAgICAgICAgeFZhbHVlLFxuICAgICAgICB5VmFsdWUsXG4gICAgICAgIGhpZ2hsaWdodGVkLFxuICAgICAgICAuLi5mb3JtYXRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZU1hcmtlck5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgaXNIaWdobGlnaHQ6IGhpZ2hsaWdodGVkIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgbWFya2VyLCBmaWxsLCBzdHJva2U6IHN0cm9rZTIsIHN0cm9rZVdpZHRoLCBmaWxsT3BhY2l0eSwgc3Ryb2tlT3BhY2l0eSwgaGlnaGxpZ2h0U3R5bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB4RG9tYWluID0gdGhpcy5nZXRTZXJpZXNEb21haW4oXCJ4XCIgLyogWCAqLyk7XG4gICAgY29uc3QgeURvbWFpbiA9IHRoaXMuZ2V0U2VyaWVzRG9tYWluKFwieVwiIC8qIFkgKi8pO1xuICAgIGNvbnN0IGJhc2VTdHlsZSA9IG1lcmdlRGVmYXVsdHMoaGlnaGxpZ2h0ZWQgJiYgaGlnaGxpZ2h0U3R5bGUuaXRlbSwgbWFya2VyLmdldFN0eWxlKCksIHtcbiAgICAgIGZpbGwsXG4gICAgICBzdHJva2U6IHN0cm9rZTIsXG4gICAgICBzdHJva2VXaWR0aCxcbiAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlT3BhY2l0eVxuICAgIH0pO1xuICAgIG1hcmtlclNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVNYXJrZXJTdHlsZShcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbWFya2VyLFxuICAgICAgICB7IC4uLmRhdHVtU3R5bGVyUHJvcGVydGllcyhkYXR1bSwgeEtleSwgeUtleSwgeERvbWFpbiwgeURvbWFpbiksIGhpZ2hsaWdodGVkIH0sXG4gICAgICAgIGJhc2VTdHlsZSxcbiAgICAgICAgeyBzZWxlY3RlZDogZGF0dW0uc2VsZWN0ZWQgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBpZiAoIWhpZ2hsaWdodGVkKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMubWFya2VyLm1hcmtDbGVhbigpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVMYWJlbFNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgeyBsYWJlbERhdGEsIGxhYmVsU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIHJldHVybiBsYWJlbFNlbGVjdGlvbi51cGRhdGUobGFiZWxEYXRhKTtcbiAgfVxuICB1cGRhdGVMYWJlbE5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IGxhYmVsU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgZW5hYmxlZDogbGFiZWxFbmFibGVkLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCBjb2xvciB9ID0gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsO1xuICAgIGxhYmVsU2VsZWN0aW9uLmVhY2goKHRleHQyLCBkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgeyB4LCB5LCBsYWJlbFRleHQgfSA9IGRhdHVtO1xuICAgICAgaWYgKGxhYmVsVGV4dCAmJiBsYWJlbEVuYWJsZWQgJiYgdGhpcy52aXNpYmxlKSB7XG4gICAgICAgIHRleHQyLmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICAgICAgdGV4dDIuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgICAgIHRleHQyLmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgIHRleHQyLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgICB0ZXh0Mi50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB0ZXh0Mi50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xuICAgICAgICB0ZXh0Mi50ZXh0ID0gbGFiZWxUZXh0O1xuICAgICAgICB0ZXh0Mi54ID0geDtcbiAgICAgICAgdGV4dDIueSA9IHkgLSAxMDtcbiAgICAgICAgdGV4dDIuZmlsbCA9IGNvbG9yO1xuICAgICAgICB0ZXh0Mi52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQyLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRUb29sdGlwQ29udGVudChub2RlRGF0dW0pIHtcbiAgICBjb25zdCB7IGlkOiBzZXJpZXNJZCwgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhLCBheGVzLCBwcm9wZXJ0aWVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgeEtleSwgeE5hbWUsIHlLZXksIHlOYW1lLCB0b29sdGlwIH0gPSBwcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCFkYXRhTW9kZWwgfHwgIXByb2Nlc3NlZERhdGEgfHwgIXhBeGlzIHx8ICF5QXhpcylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGRhdHVtSW5kZXggfSA9IG5vZGVEYXR1bTtcbiAgICBjb25zdCBkYXR1bSA9IHByb2Nlc3NlZERhdGEuZGF0YVNvdXJjZXMuZ2V0KHRoaXMuaWQpPy5bZGF0dW1JbmRleF07XG4gICAgY29uc3QgeFZhbHVlID0gZGF0YU1vZGVsLnJlc29sdmVLZXlzQnlJZCh0aGlzLCBgeFZhbHVlYCwgcHJvY2Vzc2VkRGF0YSlbZGF0dW1JbmRleF07XG4gICAgY29uc3QgeVZhbHVlID0gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGB5VmFsdWVSYXdgLCBwcm9jZXNzZWREYXRhKVtkYXR1bUluZGV4XTtcbiAgICBpZiAoeFZhbHVlID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRNYXJrZXJJdGVtQmFzZVN0eWxlKGZhbHNlKTtcbiAgICBPYmplY3QuYXNzaWduKFxuICAgICAgZm9ybWF0LFxuICAgICAgdGhpcy5nZXRNYXJrZXJJdGVtU3R5bGVPdmVycmlkZXMoU3RyaW5nKGRhdHVtSW5kZXgpLCBkYXR1bSwgeFZhbHVlLCB5VmFsdWUsIGZvcm1hdCwgZmFsc2UpXG4gICAgKTtcbiAgICByZXR1cm4gdG9vbHRpcC5mb3JtYXRUb29sdGlwKFxuICAgICAge1xuICAgICAgICBoZWFkaW5nOiB4QXhpcy5mb3JtYXREYXR1bSh4VmFsdWUpLFxuICAgICAgICBzeW1ib2w6IHRoaXMubGVnZW5kSXRlbVN5bWJvbCgpLFxuICAgICAgICBkYXRhOiBbeyBsYWJlbDogeU5hbWUsIGZhbGxiYWNrTGFiZWw6IHlLZXksIHZhbHVlOiB5QXhpcy5mb3JtYXREYXR1bSh5VmFsdWUpIH1dXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHRpdGxlOiB5TmFtZSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlLZXksXG4gICAgICAgIHlOYW1lLFxuICAgICAgICAuLi5mb3JtYXQsXG4gICAgICAgIC4uLnRoaXMuZ2V0TW9kdWxlVG9vbHRpcFBhcmFtcygpXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBsZWdlbmRJdGVtU3ltYm9sKCkge1xuICAgIGNvbnN0IHsgZmlsbCwgc3Ryb2tlOiBzdHJva2UyLCBmaWxsT3BhY2l0eSwgc3Ryb2tlT3BhY2l0eSwgc3Ryb2tlV2lkdGgsIGxpbmVEYXNoLCBtYXJrZXIgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB1c2VBcmVhRmlsbCA9ICFtYXJrZXIuZW5hYmxlZCB8fCBtYXJrZXIuZmlsbCA9PT0gdm9pZCAwO1xuICAgIHJldHVybiB7XG4gICAgICBtYXJrZXI6IHtcbiAgICAgICAgc2hhcGU6IG1hcmtlci5zaGFwZSxcbiAgICAgICAgZmlsbDogdXNlQXJlYUZpbGwgPyBmaWxsIDogbWFya2VyLmZpbGwsXG4gICAgICAgIGZpbGxPcGFjaXR5OiB1c2VBcmVhRmlsbCA/IGZpbGxPcGFjaXR5IDogbWFya2VyLmZpbGxPcGFjaXR5LFxuICAgICAgICBzdHJva2U6IG1hcmtlci5zdHJva2UgPz8gc3Ryb2tlMixcbiAgICAgICAgc3Ryb2tlT3BhY2l0eTogbWFya2VyLnN0cm9rZU9wYWNpdHksXG4gICAgICAgIHN0cm9rZVdpZHRoOiBtYXJrZXIuc3Ryb2tlV2lkdGgsXG4gICAgICAgIGxpbmVEYXNoOiBtYXJrZXIubGluZURhc2gsXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBtYXJrZXIubGluZURhc2hPZmZzZXQsXG4gICAgICAgIGVuYWJsZWQ6IG1hcmtlci5lbmFibGVkIHx8IHN0cm9rZVdpZHRoIDw9IDBcbiAgICAgIH0sXG4gICAgICBsaW5lOiB7XG4gICAgICAgIHN0cm9rZTogc3Ryb2tlMixcbiAgICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIGxpbmVEYXNoXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgbGVnZW5kVHlwZSAhPT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgIGN0eDogeyBsZWdlbmRNYW5hZ2VyIH0sXG4gICAgICB2aXNpYmxlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB5S2V5OiBpdGVtSWQsIHlOYW1lLCBsZWdlbmRJdGVtTmFtZSwgc2hvd0luTGVnZW5kIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbGVnZW5kVHlwZSxcbiAgICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIHNlcmllc0lkLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlICYmIGxlZ2VuZE1hbmFnZXIuZ2V0SXRlbUVuYWJsZWQoeyBzZXJpZXNJZCwgaXRlbUlkIH0pLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IGxlZ2VuZEl0ZW1OYW1lID8/IHlOYW1lID8/IGl0ZW1JZFxuICAgICAgICB9LFxuICAgICAgICBzeW1ib2w6IHRoaXMubGVnZW5kSXRlbVN5bWJvbCgpLFxuICAgICAgICBsZWdlbmRJdGVtTmFtZSxcbiAgICAgICAgaGlkZUluTGVnZW5kOiAhc2hvd0luTGVnZW5kXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeShhbmltYXRpb25EYXRhKSB7XG4gICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBjb250ZXh0RGF0YSwgcGF0aHMgfSA9IGFuaW1hdGlvbkRhdGE7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICB0aGlzLnVwZGF0ZUFyZWFQYXRocyhwYXRocywgY29udGV4dERhdGEpO1xuICAgIHBhdGhTd2lwZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIC4uLnBhdGhzKTtcbiAgICByZXNldE1vdGlvbihbbWFya2VyU2VsZWN0aW9uXSwgcmVzZXRNYXJrZXJQb3NpdGlvbkZuKTtcbiAgICBtYXJrZXJTd2lwZVNjYWxlSW5BbmltYXRpb24odGhpcywgYW5pbWF0aW9uTWFuYWdlciwgbWFya2VyU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gIH1cbiAgYW5pbWF0ZVJlYWR5UmVzaXplKGFuaW1hdGlvbkRhdGEpIHtcbiAgICBjb25zdCB7IGNvbnRleHREYXRhLCBwYXRocyB9ID0gYW5pbWF0aW9uRGF0YTtcbiAgICB0aGlzLnVwZGF0ZUFyZWFQYXRocyhwYXRocywgY29udGV4dERhdGEpO1xuICAgIHN1cGVyLmFuaW1hdGVSZWFkeVJlc2l6ZShhbmltYXRpb25EYXRhKTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGFuaW1hdGlvbkRhdGEpIHtcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiwgY29udGV4dERhdGEsIHBhdGhzLCBwcmV2aW91c0NvbnRleHREYXRhIH0gPSBhbmltYXRpb25EYXRhO1xuICAgIGNvbnN0IFtmaWxsLCBzdHJva2UyXSA9IHBhdGhzO1xuICAgIGlmIChmaWxsID09IG51bGwgJiYgc3Ryb2tlMiA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucmVzZXRNYXJrZXJBbmltYXRpb24oYW5pbWF0aW9uRGF0YSk7XG4gICAgdGhpcy5yZXNldExhYmVsQW5pbWF0aW9uKGFuaW1hdGlvbkRhdGEpO1xuICAgIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMucmVzZXRQYXRoQW5pbWF0aW9uKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgdGhpcy51cGRhdGVBcmVhUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgICB9O1xuICAgIGNvbnN0IHNraXAgPSAoKSA9PiB7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICAgIHVwZGF0ZSgpO1xuICAgIH07XG4gICAgaWYgKGNvbnRleHREYXRhID09IG51bGwgfHwgcHJldmlvdXNDb250ZXh0RGF0YSA9PSBudWxsKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICAgIG1hcmtlckZhZGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCBcImFkZGVkXCIsIG1hcmtlclNlbGVjdGlvbik7XG4gICAgICBwYXRoRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiZmlsbF9wYXRoX3Byb3BlcnRpZXNcIiwgYW5pbWF0aW9uTWFuYWdlciwgXCJhZGRcIiwgZmlsbCk7XG4gICAgICBwYXRoRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwic3Ryb2tlX3BhdGhfcHJvcGVydGllc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBcImFkZFwiLCBzdHJva2UyKTtcbiAgICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbnRleHREYXRhLmNyb3NzRmlsdGVyaW5nICE9PSBwcmV2aW91c0NvbnRleHREYXRhLmNyb3NzRmlsdGVyaW5nKSB7XG4gICAgICBza2lwKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZucyA9IHByZXBhcmVBcmVhUGF0aEFuaW1hdGlvbihjb250ZXh0RGF0YSwgcHJldmlvdXNDb250ZXh0RGF0YSk7XG4gICAgaWYgKGZucyA9PT0gdm9pZCAwKSB7XG4gICAgICBza2lwKCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChmbnMuc3RhdHVzID09PSBcIm5vLW9wXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWFya2VyRmFkZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIHZvaWQgMCwgbWFya2VyU2VsZWN0aW9uKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgXCJmaWxsX3BhdGhfcHJvcGVydGllc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBbZmlsbF0sIGZucy5maWxsLnBhdGhQcm9wZXJ0aWVzKTtcbiAgICBwYXRoTW90aW9uKHRoaXMuaWQsIFwiZmlsbF9wYXRoX3VwZGF0ZVwiLCBhbmltYXRpb25NYW5hZ2VyLCBbZmlsbF0sIGZucy5maWxsLnBhdGgpO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBcInN0cm9rZV9wYXRoX3Byb3BlcnRpZXNcIiwgYW5pbWF0aW9uTWFuYWdlciwgW3N0cm9rZTJdLCBmbnMuc3Ryb2tlLnBhdGhQcm9wZXJ0aWVzKTtcbiAgICBwYXRoTW90aW9uKHRoaXMuaWQsIFwic3Ryb2tlX3BhdGhfdXBkYXRlXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFtzdHJva2UyXSwgZm5zLnN0cm9rZS5wYXRoKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlKHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgZ3JvdXBJZDogXCJyZXNldF9hZnRlcl9hbmltYXRpb25cIixcbiAgICAgIHBoYXNlOiBcInRyYWlsaW5nXCIsXG4gICAgICBmcm9tOiB7fSxcbiAgICAgIHRvOiB7fSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHRoaXMudXBkYXRlQXJlYVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSlcbiAgICB9KTtcbiAgfVxuICBpc0xhYmVsRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLmVuYWJsZWQ7XG4gIH1cbiAgbm9kZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBHcm91cCgpO1xuICB9XG4gIGdldEZvcm1hdHRlZE1hcmtlclN0eWxlKGRhdHVtKSB7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5IH0gPSBkYXR1bTtcbiAgICBjb25zdCB4RG9tYWluID0gdGhpcy5nZXRTZXJpZXNEb21haW4oXCJ4XCIgLyogWCAqLyk7XG4gICAgY29uc3QgeURvbWFpbiA9IHRoaXMuZ2V0U2VyaWVzRG9tYWluKFwieVwiIC8qIFkgKi8pO1xuICAgIHJldHVybiB0aGlzLmdldE1hcmtlclN0eWxlKHRoaXMucHJvcGVydGllcy5tYXJrZXIsIHtcbiAgICAgIC4uLmRhdHVtU3R5bGVyUHJvcGVydGllcyhkYXR1bSwgeEtleSwgeUtleSwgeERvbWFpbiwgeURvbWFpbiksXG4gICAgICBoaWdobGlnaHRlZDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGNvbXB1dGVGb2N1c0JvdW5kcyhvcHRzKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVNYXJrZXJGb2N1c0JvdW5kcyh0aGlzLCBvcHRzKTtcbiAgfVxufTtcbkFyZWFTZXJpZXMuY2xhc3NOYW1lID0gXCJBcmVhU2VyaWVzXCI7XG5BcmVhU2VyaWVzLnR5cGUgPSBcImFyZWFcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9hcmVhU2VyaWVzTW9kdWxlLnRzXG52YXIgQXJlYVNlcmllc01vZHVsZSA9IHtcbiAgdHlwZTogXCJzZXJpZXNcIixcbiAgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLFxuICBpZGVudGlmaWVyOiBcImFyZWFcIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IEFyZWFTZXJpZXMoY3R4KSxcbiAgc3RhY2thYmxlOiB0cnVlLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwibmVhcmVzdFwiIH0sXG4gIGRlZmF1bHRBeGVzOiBbXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCIgLyogTEVGVCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJjYXRlZ29yeVwiIC8qIENBVEVHT1JZICovLFxuICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIgLyogQk9UVE9NICovXG4gICAgfVxuICBdLFxuICB0aGVtZVRlbXBsYXRlOiB7XG4gICAgc2VyaWVzOiB7XG4gICAgICBub2RlQ2xpY2tSYW5nZTogXCJuZWFyZXN0XCIsXG4gICAgICB0b29sdGlwOiB7IHBvc2l0aW9uOiB7IHR5cGU6IFwibm9kZVwiIH0gfSxcbiAgICAgIGZpbGxPcGFjaXR5OiAwLjgsXG4gICAgICBzdHJva2VPcGFjaXR5OiAxLFxuICAgICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgICBsaW5lRGFzaDogWzBdLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IDAsXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX1NIQURPV19DT0xPVVIsXG4gICAgICAgIHhPZmZzZXQ6IDMsXG4gICAgICAgIHlPZmZzZXQ6IDMsXG4gICAgICAgIGJsdXI6IDVcbiAgICAgIH0sXG4gICAgICBpbnRlcnBvbGF0aW9uOiB7XG4gICAgICAgIHR5cGU6IFwibGluZWFyXCIsXG4gICAgICAgIHRlbnNpb246IDEsXG4gICAgICAgIHBvc2l0aW9uOiBcImVuZFwiXG4gICAgICB9LFxuICAgICAgbWFya2VyOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzaGFwZTogXCJjaXJjbGVcIixcbiAgICAgICAgc2l6ZTogNyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDBcbiAgICAgIH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgZm9udFNpemU6IHsgJHJlZjogXCJmb250U2l6ZVwiIH0sXG4gICAgICAgIGZvbnRGYW1pbHk6IHsgJHJlZjogXCJmb250RmFtaWx5XCIgfSxcbiAgICAgICAgZm9udFdlaWdodDogeyAkcmVmOiBcImZvbnRXZWlnaHRcIiB9LFxuICAgICAgICBjb2xvcjogeyAkcmVmOiBcInRleHRDb2xvclwiIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBhbGV0dGVGYWN0b3J5OiAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyBtYXJrZXIgfSA9IG1hcmtlclBhbGV0dGVGYWN0b3J5KHBhcmFtcyk7XG4gICAgY29uc3QgZGVmYXVsdENvbG9yUmFuZ2UgPSBwYXJhbXMudGhlbWVUZW1wbGF0ZVBhcmFtZXRlcnMuZ2V0KERFRkFVTFRfQ09MT1JfUkFOR0UpO1xuICAgIHJldHVybiB7IGZpbGw6IG1hcmtlci5maWxsLCBzdHJva2U6IG1hcmtlci5zdHJva2UsIG1hcmtlciwgZGVmYXVsdENvbG9yUmFuZ2UgfTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9xdWFkdHJlZVV0aWwudHNcbmZ1bmN0aW9uIGFkZEhpdFRlc3RlcnNUb1F1YWR0cmVlKHF1YWR0cmVlLCBoaXRUZXN0ZXJzKSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBoaXRUZXN0ZXJzKSB7XG4gICAgY29uc3QgZGF0dW0gPSBub2RlLmRhdHVtO1xuICAgIGlmIChkYXR1bSA9PT0gdm9pZCAwKSB7XG4gICAgICBsb2dnZXJfZXhwb3J0cy5lcnJvcihcInVuZGVmaW5lZCBkYXR1bVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVhZHRyZWUuYWRkVmFsdWUobm9kZSwgZGF0dW0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmluZFF1YWR0cmVlTWF0Y2goc2VyaWVzLCBwb2ludCkge1xuICBjb25zdCB7IHgsIHkgfSA9IHBvaW50O1xuICBjb25zdCB7IG5lYXJlc3QsIGRpc3RhbmNlU3F1YXJlZDogZGlzdGFuY2VTcXVhcmVkMiB9ID0gc2VyaWVzLmdldFF1YWRUcmVlKCkuZmluZCh4LCB5KTtcbiAgaWYgKG5lYXJlc3QgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7IGRhdHVtOiBuZWFyZXN0LnZhbHVlLCBkaXN0YW5jZTogTWF0aC5zcXJ0KGRpc3RhbmNlU3F1YXJlZDIpIH07XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9hYnN0cmFjdEJhclNlcmllcy50c1xudmFyIEFic3RyYWN0QmFyU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBcInZlcnRpY2FsXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShESVJFQ1RJT04pXG5dLCBBYnN0cmFjdEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCAyKTtcbnZhciBBYnN0cmFjdEJhclNlcmllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGdldCB0aGUgcG9zaXRpb24gb2YgYmFycyB3aXRoaW4gZWFjaCBncm91cC5cbiAgICAgKi9cbiAgICB0aGlzLmdyb3VwU2NhbGUgPSBuZXcgQ2F0ZWdvcnlTY2FsZSgpO1xuICAgIHRoaXMuc21hbGxlc3REYXRhSW50ZXJ2YWwgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXJnZXN0RGF0YUludGVydmFsID0gdm9pZCAwO1xuICB9XG4gIHBhZEJhbmRFeHRlbnQoa2V5cywgYWxpZ25TdGFydCkge1xuICAgIGNvbnN0IHJhdGlvMiA9IHR5cGVvZiBhbGlnblN0YXJ0ID09PSBcImJvb2xlYW5cIiA/IDEgOiAwLjU7XG4gICAgY29uc3Qgc2NhbGVQYWRkaW5nID0gaXNGaW5pdGVOdW1iZXIodGhpcy5zbWFsbGVzdERhdGFJbnRlcnZhbCkgPyB0aGlzLnNtYWxsZXN0RGF0YUludGVydmFsICogcmF0aW8yIDogMDtcbiAgICBjb25zdCBrZXlzRXh0ZW50ID0gZXh0ZW50KGtleXMpID8/IFtOYU4sIE5hTl07XG4gICAgaWYgKHR5cGVvZiBhbGlnblN0YXJ0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAga2V5c0V4dGVudFthbGlnblN0YXJ0ID8gMCA6IDFdIC09IChhbGlnblN0YXJ0ID8gMSA6IC0xKSAqIHNjYWxlUGFkZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAga2V5c0V4dGVudFswXSAtPSBzY2FsZVBhZGRpbmc7XG4gICAgICBrZXlzRXh0ZW50WzFdICs9IHNjYWxlUGFkZGluZztcbiAgICB9XG4gICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoa2V5c0V4dGVudCk7XG4gIH1cbiAgZ2V0QmFuZFNjYWxlUGFkZGluZygpIHtcbiAgICByZXR1cm4geyBpbm5lcjogMC4zLCBvdXRlcjogMC4xNSB9O1xuICB9XG4gIHNob3VsZEZsaXBYWSgpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNWZXJ0aWNhbCgpO1xuICB9XG4gIGlzVmVydGljYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5kaXJlY3Rpb24gPT09IFwidmVydGljYWxcIjtcbiAgfVxuICBnZXRCYXJEaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hvdWxkRmxpcFhZKCkgPyBcInhcIiAvKiBYICovIDogXCJ5XCIgLyogWSAqLztcbiAgfVxuICBnZXRDYXRlZ29yeURpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zaG91bGRGbGlwWFkoKSA/IFwieVwiIC8qIFkgKi8gOiBcInhcIiAvKiBYICovO1xuICB9XG4gIGdldFZhbHVlQXhpcygpIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldEJhckRpcmVjdGlvbigpO1xuICAgIHJldHVybiB0aGlzLmF4ZXNbZGlyZWN0aW9uXTtcbiAgfVxuICBnZXRDYXRlZ29yeUF4aXMoKSB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXRDYXRlZ29yeURpcmVjdGlvbigpO1xuICAgIHJldHVybiB0aGlzLmF4ZXNbZGlyZWN0aW9uXTtcbiAgfVxuICBnZXRCYW5kd2lkdGgoeEF4aXMpIHtcbiAgICByZXR1cm4gQ29udGludW91c1NjYWxlLmlzKHhBeGlzLnNjYWxlKSA/IHhBeGlzLnNjYWxlLmNhbGNCYW5kd2lkdGgodGhpcy5zbWFsbGVzdERhdGFJbnRlcnZhbCkgOiB4QXhpcy5zY2FsZS5iYW5kd2lkdGg7XG4gIH1cbiAgeENvb3JkaW5hdGVSYW5nZSh4VmFsdWUpIHtcbiAgICBjb25zdCB4QXhpcyA9IHRoaXMuYXhlc1t0aGlzLmdldENhdGVnb3J5RGlyZWN0aW9uKCldO1xuICAgIGNvbnN0IHhTY2FsZSA9IHhBeGlzLnNjYWxlO1xuICAgIGNvbnN0IGJhbmRXaWR0aCA9IHRoaXMuZ2V0QmFuZHdpZHRoKHhBeGlzKSA/PyAwO1xuICAgIGNvbnN0IGJhck9mZnNldCA9IENvbnRpbnVvdXNTY2FsZS5pcyh4U2NhbGUpID8gYmFuZFdpZHRoICogLTAuNSA6IDA7XG4gICAgY29uc3QgeCA9IHhTY2FsZS5jb252ZXJ0KHhWYWx1ZSkgKyBiYXJPZmZzZXQ7XG4gICAgcmV0dXJuIFt4LCB4ICsgYmFuZFdpZHRoXTtcbiAgfVxuICB5Q29vcmRpbmF0ZVJhbmdlKHlWYWx1ZXMpIHtcbiAgICBjb25zdCB5QXhpcyA9IHRoaXMuYXhlc1t0aGlzLmdldEJhckRpcmVjdGlvbigpXTtcbiAgICBjb25zdCB5U2NhbGUgPSB5QXhpcy5zY2FsZTtcbiAgICBjb25zdCB5cyA9IHlWYWx1ZXMubWFwKCh5VmFsdWUpID0+IHlTY2FsZS5jb252ZXJ0KHlWYWx1ZSkpO1xuICAgIGlmICh5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IHkwID0geVNjYWxlLmNvbnZlcnQoMCk7XG4gICAgICByZXR1cm4gW01hdGgubWluKHlzWzBdLCB5MCksIE1hdGgubWF4KHlzWzBdLCB5MCldO1xuICAgIH1cbiAgICByZXR1cm4gW01hdGgubWluKC4uLnlzKSwgTWF0aC5tYXgoLi4ueXMpXTtcbiAgfVxuICB1cGRhdGVHcm91cFNjYWxlKHhBeGlzKSB7XG4gICAgY29uc3QgZG9tYWluID0gW107XG4gICAgY29uc3QgeyBncm91cFNjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHhCYW5kV2lkdGggPSB0aGlzLmdldEJhbmR3aWR0aCh4QXhpcyk7XG4gICAgY29uc3QgeyBpbmRleDogZ3JvdXBJbmRleCwgdmlzaWJsZUdyb3VwQ291bnQgfSA9IHRoaXMuY3R4LnNlcmllc1N0YXRlTWFuYWdlci5nZXRWaXNpYmxlUGVlckdyb3VwSW5kZXgodGhpcyk7XG4gICAgZm9yIChsZXQgZ3JvdXBJZHggPSAwOyBncm91cElkeCA8IHZpc2libGVHcm91cENvdW50OyBncm91cElkeCsrKSB7XG4gICAgICBkb21haW4ucHVzaChTdHJpbmcoZ3JvdXBJZHgpKTtcbiAgICB9XG4gICAgZ3JvdXBTY2FsZS5kb21haW4gPSBkb21haW47XG4gICAgZ3JvdXBTY2FsZS5yYW5nZSA9IFswLCB4QmFuZFdpZHRoID8/IDBdO1xuICAgIGlmICh4QXhpcyBpbnN0YW5jZW9mIEdyb3VwZWRDYXRlZ29yeUF4aXMpIHtcbiAgICAgIGdyb3VwU2NhbGUucGFkZGluZ0lubmVyID0geEF4aXMuZ3JvdXBQYWRkaW5nSW5uZXI7XG4gICAgfSBlbHNlIGlmICh4QXhpcyBpbnN0YW5jZW9mIENhdGVnb3J5QXhpcykge1xuICAgICAgZ3JvdXBTY2FsZS5wYWRkaW5nSW5uZXIgPSB4QXhpcy5ncm91cFBhZGRpbmdJbm5lcjtcbiAgICAgIGdyb3VwU2NhbGUucm91bmQgPSBncm91cFNjYWxlLnBhZGRpbmcgIT09IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwU2NhbGUucGFkZGluZyA9IDA7XG4gICAgfVxuICAgIGNvbnN0IGJhcldpZHRoID0gZ3JvdXBTY2FsZS5iYW5kd2lkdGggPj0gMSA/IChcbiAgICAgIC8vIFBpeGVsLXJvdW5kZWQgdmFsdWUgZm9yIGxvdy12b2x1bWUgYmFyIGNoYXJ0cy5cbiAgICAgIGdyb3VwU2NhbGUuYmFuZHdpZHRoXG4gICAgKSA6IChcbiAgICAgIC8vIEhhbmRsZSBoaWdoLXZvbHVtZSBiYXIgY2hhcnRzIGdyYWNlZnVsbHkuXG4gICAgICBncm91cFNjYWxlLnJhd0JhbmR3aWR0aFxuICAgICk7XG4gICAgcmV0dXJuIHsgYmFyV2lkdGgsIGdyb3VwSW5kZXggfTtcbiAgfVxuICByZXNvbHZlS2V5RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIGlmICh0aGlzLmdldEJhckRpcmVjdGlvbigpID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICAgIHJldHVybiBcInlcIiAvKiBZICovO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwieFwiIC8qIFggKi87XG4gICAgfVxuICAgIHJldHVybiBkaXJlY3Rpb247XG4gIH1cbiAgaW5pdFF1YWRUcmVlKHF1YWR0cmVlKSB7XG4gICAgYWRkSGl0VGVzdGVyc1RvUXVhZHRyZWUocXVhZHRyZWUsIHRoaXMuZGF0dW1Ob2Rlc0l0ZXIoKSk7XG4gIH1cbiAgcGlja05vZGVDbG9zZXN0RGF0dW0ocG9pbnQpIHtcbiAgICByZXR1cm4gZmluZFF1YWR0cmVlTWF0Y2godGhpcywgcG9pbnQpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2JhclNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBCYXJTZXJpZXNMYWJlbCA9IGNsYXNzIGV4dGVuZHMgTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucGxhY2VtZW50ID0gXCJpbnNpZGUtY2VudGVyXCI7XG4gICAgdGhpcy5wYWRkaW5nID0gMDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFVOSU9OKFtcImluc2lkZS1jZW50ZXJcIiwgXCJpbnNpZGUtc3RhcnRcIiwgXCJpbnNpZGUtZW5kXCIsIFwib3V0c2lkZS1zdGFydFwiLCBcIm91dHNpZGUtZW5kXCJdLCBcImEgcGxhY2VtZW50XCIpKVxuXSwgQmFyU2VyaWVzTGFiZWwucHJvdG90eXBlLCBcInBsYWNlbWVudFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIEJhclNlcmllc0xhYmVsLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIDIpO1xudmFyIEJhclNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0QmFyU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5maWxsID0gXCIjYzE2MDY4XCI7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5zdHJva2UgPSBcIiM4NzQzNDlcIjtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuICAgIHRoaXMubGluZURhc2ggPSBbMF07XG4gICAgdGhpcy5saW5lRGFzaE9mZnNldCA9IDA7XG4gICAgdGhpcy5jb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuY3Jpc3AgPSB2b2lkIDA7XG4gICAgdGhpcy5zaGFkb3cgPSBuZXcgRHJvcFNoYWRvdygpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgQmFyU2VyaWVzTGFiZWwoKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xuICAgIHRoaXMuc3BhcmtsaW5lTW9kZSA9IGZhbHNlO1xuICAgIHRoaXMuZmFzdERhdGFQcm9jZXNzaW5nID0gZmFsc2U7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5RmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdGFja0dyb3VwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJub3JtYWxpemVkVG9cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTElORV9EQVNIKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNyaXNwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIml0ZW1TdHlsZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNoYWRvd1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzcGFya2xpbmVNb2RlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZhc3REYXRhUHJvY2Vzc2luZ1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9iYXJVdGlsLnRzXG5mdW5jdGlvbiBjaGVja0NyaXNwKHNjYWxlMiwgdmlzaWJsZVJhbmdlLCBzbWFsbGVzdERhdGFJbnRlcnZhbCwgbGFyZ2VzdERhdGFJbnRlcnZhbCkge1xuICBpZiAodmlzaWJsZVJhbmdlICE9IG51bGwpIHtcbiAgICBjb25zdCBbdmlzaWJsZU1pbiwgdmlzaWJsZU1heF0gPSB2aXNpYmxlUmFuZ2U7XG4gICAgY29uc3QgaXNab29tZWQgPSB2aXNpYmxlTWluICE9PSAwIHx8IHZpc2libGVNYXggIT09IDE7XG4gICAgaWYgKGlzWm9vbWVkKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSkge1xuICAgIGNvbnN0IHNwYWNpbmcgPSBzY2FsZTIuY2FsY0JhbmR3aWR0aChsYXJnZXN0RGF0YUludGVydmFsKSAtIHNjYWxlMi5jYWxjQmFuZHdpZHRoKHNtYWxsZXN0RGF0YUludGVydmFsKTtcbiAgICBpZiAoc3BhY2luZyA+IDAgJiYgc3BhY2luZyA8IDEpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG52YXIgaXNEYXR1bU5lZ2F0aXZlID0gKGRhdHVtKSA9PiB7XG4gIHJldHVybiBpc05lZ2F0aXZlKGRhdHVtLnlWYWx1ZSA/PyAwKTtcbn07XG5mdW5jdGlvbiBjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uKGlzVmVydGljYWwsIGF4ZXMsIG1vZGUpIHtcbiAgY29uc3QgeyBzdGFydGluZ1gsIHN0YXJ0aW5nWSB9ID0gZ2V0U3RhcnRpbmdWYWx1ZXMoaXNWZXJ0aWNhbCwgYXhlcyk7XG4gIGNvbnN0IGNhbGN1bGF0ZSA9IChkYXR1bSwgcHJldkRhdHVtKSA9PiB7XG4gICAgbGV0IHggPSBpc1ZlcnRpY2FsID8gZGF0dW0ueCA6IHN0YXJ0aW5nWDtcbiAgICBsZXQgeSA9IGlzVmVydGljYWwgPyBzdGFydGluZ1kgOiBkYXR1bS55O1xuICAgIGxldCB3aWR0aDIgPSBpc1ZlcnRpY2FsID8gZGF0dW0ud2lkdGggOiAwO1xuICAgIGxldCBoZWlnaHQyID0gaXNWZXJ0aWNhbCA/IDAgOiBkYXR1bS5oZWlnaHQ7XG4gICAgY29uc3QgeyBvcGFjaXR5ID0gMSB9ID0gZGF0dW07XG4gICAgaWYgKHByZXZEYXR1bSAmJiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpKSB7XG4gICAgICAoeyB4LCB5IH0gPSBwcmV2RGF0dW0pO1xuICAgICAgd2lkdGgyID0gaXNWZXJ0aWNhbCA/IHByZXZEYXR1bS53aWR0aCA6IDA7XG4gICAgICBoZWlnaHQyID0gaXNWZXJ0aWNhbCA/IDAgOiBwcmV2RGF0dW0uaGVpZ2h0O1xuICAgICAgaWYgKGlzVmVydGljYWwgJiYgIWlzRGF0dW1OZWdhdGl2ZShwcmV2RGF0dW0pKSB7XG4gICAgICAgIHkgKz0gcHJldkRhdHVtLmhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoIWlzVmVydGljYWwgJiYgaXNEYXR1bU5lZ2F0aXZlKHByZXZEYXR1bSkpIHtcbiAgICAgICAgeCArPSBwcmV2RGF0dW0ud2lkdGg7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBjbGlwQkJveDtcbiAgICBpZiAoZGF0dW0uY2xpcEJCb3ggPT0gbnVsbCkge1xuICAgICAgY2xpcEJCb3ggPSB2b2lkIDA7XG4gICAgfSBlbHNlIGlmIChpc0RhdHVtTmVnYXRpdmUoZGF0dW0pKSB7XG4gICAgICBjbGlwQkJveCA9IGlzVmVydGljYWwgPyBuZXcgQkJveCh4LCB5IC0gaGVpZ2h0Miwgd2lkdGgyLCBoZWlnaHQyKSA6IG5ldyBCQm94KHggLSB3aWR0aDIsIHksIHdpZHRoMiwgaGVpZ2h0Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsaXBCQm94ID0gbmV3IEJCb3goeCwgeSwgd2lkdGgyLCBoZWlnaHQyKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeCwgeSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyLCBjbGlwQkJveCwgb3BhY2l0eSB9O1xuICB9O1xuICByZXR1cm4geyBpc1ZlcnRpY2FsLCBjYWxjdWxhdGUsIG1vZGUgfTtcbn1cbmZ1bmN0aW9uIG1pZHBvaW50U3RhcnRpbmdCYXJQb3NpdGlvbihpc1ZlcnRpY2FsLCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgaXNWZXJ0aWNhbCxcbiAgICBjYWxjdWxhdGU6IChkYXR1bSkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogaXNWZXJ0aWNhbCA/IGRhdHVtLnggOiBkYXR1bS54ICsgZGF0dW0ud2lkdGggLyAyLFxuICAgICAgICB5OiBpc1ZlcnRpY2FsID8gZGF0dW0ueSArIGRhdHVtLmhlaWdodCAvIDIgOiBkYXR1bS55LFxuICAgICAgICB3aWR0aDogaXNWZXJ0aWNhbCA/IGRhdHVtLndpZHRoIDogMCxcbiAgICAgICAgaGVpZ2h0OiBpc1ZlcnRpY2FsID8gMCA6IGRhdHVtLmhlaWdodCxcbiAgICAgICAgY2xpcEJCb3g6IGRhdHVtLmNsaXBCQm94LFxuICAgICAgICBvcGFjaXR5OiBkYXR1bS5vcGFjaXR5ID8/IDFcbiAgICAgIH07XG4gICAgfSxcbiAgICBtb2RlXG4gIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zKGluaXRQb3MpIHtcbiAgY29uc3QgaXNSZW1vdmVkID0gKGRhdHVtKSA9PiBkYXR1bSA9PSBudWxsIHx8IGlzTmFOKGRhdHVtLngpIHx8IGlzTmFOKGRhdHVtLnkpO1xuICBjb25zdCBmcm9tRm4gPSAocmVjdCwgZGF0dW0sIHN0YXR1cykgPT4ge1xuICAgIGlmIChzdGF0dXMgPT09IFwidXBkYXRlZFwiICYmIGlzUmVtb3ZlZChkYXR1bSkpIHtcbiAgICAgIHN0YXR1cyA9IFwicmVtb3ZlZFwiO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcInVwZGF0ZWRcIiAmJiBpc1JlbW92ZWQocmVjdC5wcmV2aW91c0RhdHVtKSkge1xuICAgICAgc3RhdHVzID0gXCJhZGRlZFwiO1xuICAgIH1cbiAgICBsZXQgc291cmNlO1xuICAgIGlmIChzdGF0dXMgPT09IFwiYWRkZWRcIiAmJiByZWN0LnByZXZpb3VzRGF0dW0gPT0gbnVsbCAmJiBpbml0UG9zLm1vZGUgPT09IFwiZmFkZVwiKSB7XG4gICAgICBzb3VyY2UgPSB7XG4gICAgICAgIC4uLnJlc2V0QmFyU2VsZWN0aW9uc0ZuKHJlY3QsIGRhdHVtKSxcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJ1bmtub3duXCIgfHwgc3RhdHVzID09PSBcImFkZGVkXCIpIHtcbiAgICAgIHNvdXJjZSA9IGluaXRQb3MuY2FsY3VsYXRlKGRhdHVtLCByZWN0LnByZXZpb3VzRGF0dW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2UgPSB7XG4gICAgICAgIHg6IHJlY3QueCxcbiAgICAgICAgeTogcmVjdC55LFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgICAgY2xpcEJCb3g6IHJlY3QuY2xpcEJCb3gsXG4gICAgICAgIG9wYWNpdHk6IHJlY3Qub3BhY2l0eSA/PyAxXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwaGFzZSA9IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbc3RhdHVzXTtcbiAgICByZXR1cm4geyAuLi5zb3VyY2UsIHBoYXNlIH07XG4gIH07XG4gIGNvbnN0IHRvRm4gPSAocmVjdCwgZGF0dW0sIHN0YXR1cykgPT4ge1xuICAgIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiICYmIHJlY3QuZGF0dW0gPT0gbnVsbCAmJiBpbml0UG9zLm1vZGUgPT09IFwiZmFkZVwiKSB7XG4gICAgICByZXR1cm4geyAuLi5yZXNldEJhclNlbGVjdGlvbnNGbihyZWN0LCBkYXR1bSksIG9wYWNpdHk6IDAgfTtcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgfHwgaXNSZW1vdmVkKGRhdHVtKSkge1xuICAgICAgcmV0dXJuIGluaXRQb3MuY2FsY3VsYXRlKGRhdHVtLCByZWN0LnByZXZpb3VzRGF0dW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBkYXR1bS54LFxuICAgICAgICB5OiBkYXR1bS55LFxuICAgICAgICB3aWR0aDogZGF0dW0ud2lkdGgsXG4gICAgICAgIGhlaWdodDogZGF0dW0uaGVpZ2h0LFxuICAgICAgICBjbGlwQkJveDogZGF0dW0uY2xpcEJCb3gsXG4gICAgICAgIG9wYWNpdHk6IGRhdHVtLm9wYWNpdHkgPz8gMVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGFwcGx5Rm4gPSAocmVjdCwgZGF0dW0sIHN0YXR1cykgPT4ge1xuICAgIHJlY3Quc2V0UHJvcGVydGllcyhkYXR1bSk7XG4gICAgcmVjdC5jcmlzcCA9IHN0YXR1cyA9PT0gXCJlbmRcIiAmJiAocmVjdC5kYXR1bT8uY3Jpc3AgPz8gZmFsc2UpO1xuICB9O1xuICByZXR1cm4geyB0b0ZuLCBmcm9tRm4sIGFwcGx5Rm4gfTtcbn1cbmZ1bmN0aW9uIGdldFN0YXJ0aW5nVmFsdWVzKGlzVmVydGljYWwsIGF4ZXMpIHtcbiAgY29uc3QgYXhpcyA9IGF4ZXNbaXNWZXJ0aWNhbCA/IFwieVwiIC8qIFkgKi8gOiBcInhcIiAvKiBYICovXTtcbiAgbGV0IHN0YXJ0aW5nWCA9IEluZmluaXR5O1xuICBsZXQgc3RhcnRpbmdZID0gMDtcbiAgaWYgKCFheGlzKSB7XG4gICAgcmV0dXJuIHsgc3RhcnRpbmdYLCBzdGFydGluZ1kgfTtcbiAgfVxuICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgIHN0YXJ0aW5nWSA9IGF4aXMuc2NhbGUuY29udmVydChDb250aW51b3VzU2NhbGUuaXMoYXhpcy5zY2FsZSkgPyAwIDogTWF0aC5tYXgoLi4uYXhpcy5yYW5nZSkpO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0aW5nWCA9IGF4aXMuc2NhbGUuY29udmVydChDb250aW51b3VzU2NhbGUuaXMoYXhpcy5zY2FsZSkgPyAwIDogTWF0aC5taW4oLi4uYXhpcy5yYW5nZSkpO1xuICB9XG4gIHJldHVybiB7IHN0YXJ0aW5nWCwgc3RhcnRpbmdZIH07XG59XG5mdW5jdGlvbiByZXNldEJhclNlbGVjdGlvbnNGbihyZWN0LCB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiwgY2xpcEJCb3gsIG9wYWNpdHkgPSAxIH0pIHtcbiAgcmV0dXJuIHsgeCwgeSwgd2lkdGg6IHdpZHRoMiwgaGVpZ2h0OiBoZWlnaHQyLCBjbGlwQkJveCwgb3BhY2l0eSwgY3Jpc3A6IHJlY3QuZGF0dW0/LmNyaXNwID8/IGZhbHNlIH07XG59XG5mdW5jdGlvbiBjb21wdXRlQmFyRm9jdXNCb3VuZHMoc2VyaWVzLCBkYXR1bSkge1xuICBpZiAoZGF0dW0gPT09IHZvaWQgMClcbiAgICByZXR1cm4gdm9pZCAwO1xuICBjb25zdCB7IHgsIHksIHdpZHRoOiB3aWR0aDIsIGhlaWdodDogaGVpZ2h0MiB9ID0gZGF0dW07XG4gIHJldHVybiBUcmFuc2Zvcm1hYmxlLnRvQ2FudmFzKHNlcmllcy5jb250ZW50R3JvdXAsIG5ldyBCQm94KHgsIHksIHdpZHRoMiwgaGVpZ2h0MikpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xhYmVsVXRpbC50c1xuZnVuY3Rpb24gdXBkYXRlTGFiZWxOb2RlKHRleHROb2RlLCBsYWJlbCwgbGFiZWxEYXR1bSkge1xuICBpZiAobGFiZWwuZW5hYmxlZCAmJiBsYWJlbERhdHVtKSB7XG4gICAgY29uc3QgeyB4LCB5LCB0ZXh0OiB0ZXh0MiwgdGV4dEFsaWduLCB0ZXh0QmFzZWxpbmUgfSA9IGxhYmVsRGF0dW07XG4gICAgY29uc3QgeyBjb2xvcjogZmlsbCwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSB9ID0gbGFiZWw7XG4gICAgdGV4dE5vZGUuc2V0UHJvcGVydGllcyh7XG4gICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgIGZpbGwsXG4gICAgICBmb250U3R5bGUsXG4gICAgICBmb250V2VpZ2h0LFxuICAgICAgZm9udFNpemUsXG4gICAgICBmb250RmFtaWx5LFxuICAgICAgdGV4dEFsaWduLFxuICAgICAgdGV4dEJhc2VsaW5lXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGV4dE5vZGUudmlzaWJsZSA9IGZhbHNlO1xuICB9XG59XG52YXIgcGxhY2VtZW50cyA9IHtcbiAgXCJpbnNpZGUtc3RhcnRcIjogeyBpbnNpZGU6IHRydWUsIGRpcmVjdGlvbjogLTEsIHRleHRBbGlnbm1lbnQ6IDEgfSxcbiAgXCJpbnNpZGUtZW5kXCI6IHsgaW5zaWRlOiB0cnVlLCBkaXJlY3Rpb246IDEsIHRleHRBbGlnbm1lbnQ6IC0xIH0sXG4gIFwib3V0c2lkZS1zdGFydFwiOiB7IGluc2lkZTogZmFsc2UsIGRpcmVjdGlvbjogLTEsIHRleHRBbGlnbm1lbnQ6IC0xIH0sXG4gIFwib3V0c2lkZS1lbmRcIjogeyBpbnNpZGU6IGZhbHNlLCBkaXJlY3Rpb246IDEsIHRleHRBbGlnbm1lbnQ6IDEgfVxufTtcbmZ1bmN0aW9uIGFkanVzdExhYmVsUGxhY2VtZW50KHtcbiAgaXNVcHdhcmQsXG4gIGlzVmVydGljYWwsXG4gIHBsYWNlbWVudCxcbiAgcGFkZGluZyA9IDAsXG4gIHJlY3Rcbn0pIHtcbiAgbGV0IHggPSByZWN0LnggKyByZWN0LndpZHRoIC8gMjtcbiAgbGV0IHkgPSByZWN0LnkgKyByZWN0LmhlaWdodCAvIDI7XG4gIGxldCB0ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICBsZXQgdGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgaWYgKHBsYWNlbWVudCAhPT0gXCJpbnNpZGUtY2VudGVyXCIpIHtcbiAgICBjb25zdCBiYXJEaXJlY3Rpb24gPSAoaXNVcHdhcmQgPyAxIDogLTEpICogKGlzVmVydGljYWwgPyAtMSA6IDEpO1xuICAgIGNvbnN0IHsgZGlyZWN0aW9uLCB0ZXh0QWxpZ25tZW50IH0gPSBwbGFjZW1lbnRzW3BsYWNlbWVudF07XG4gICAgY29uc3QgZGlzcGxhY2VtZW50UmF0aW8gPSAoZGlyZWN0aW9uICsgMSkgKiAwLjU7XG4gICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgIGNvbnN0IHkwID0gaXNVcHdhcmQgPyByZWN0LnkgKyByZWN0LmhlaWdodCA6IHJlY3QueTtcbiAgICAgIGNvbnN0IGhlaWdodDIgPSByZWN0LmhlaWdodCAqIGJhckRpcmVjdGlvbjtcbiAgICAgIHkgPSB5MCArIGhlaWdodDIgKiBkaXNwbGFjZW1lbnRSYXRpbyArIHBhZGRpbmcgKiB0ZXh0QWxpZ25tZW50ICogYmFyRGlyZWN0aW9uO1xuICAgICAgdGV4dEJhc2VsaW5lID0gdGV4dEFsaWdubWVudCA9PT0gYmFyRGlyZWN0aW9uID8gXCJ0b3BcIiA6IFwiYm90dG9tXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHgwID0gaXNVcHdhcmQgPyByZWN0LnggOiByZWN0LnggKyByZWN0LndpZHRoO1xuICAgICAgY29uc3Qgd2lkdGgyID0gcmVjdC53aWR0aCAqIGJhckRpcmVjdGlvbjtcbiAgICAgIHggPSB4MCArIHdpZHRoMiAqIGRpc3BsYWNlbWVudFJhdGlvICsgcGFkZGluZyAqIHRleHRBbGlnbm1lbnQgKiBiYXJEaXJlY3Rpb247XG4gICAgICB0ZXh0QWxpZ24gPSB0ZXh0QWxpZ25tZW50ID09PSBiYXJEaXJlY3Rpb24gPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgeCwgeSwgdGV4dEFsaWduLCB0ZXh0QmFzZWxpbmUgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9iYXJTZXJpZXMudHNcbnZhciBYX01JTiA9IDA7XG52YXIgWF9NQVggPSAxO1xudmFyIFlfTUlOID0gMjtcbnZhciBZX01BWCA9IDM7XG52YXIgU1BBTjIgPSA0O1xudmFyIEJhclNlcmllcyA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RCYXJTZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBkaXJlY3Rpb25LZXlzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUyxcbiAgICAgIGRpcmVjdGlvbk5hbWVzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fTkFNRVMsXG4gICAgICBwaWNrTW9kZXM6IFtcbiAgICAgICAgMiAvKiBBWElTX0FMSUdORUQgKi8sXG4gICAgICAgIC8vIE9ubHkgdXNlZCBpbiBzcGFya2xpbmVNb2RlXG4gICAgICAgIDEgLyogTkVBUkVTVF9OT0RFICovLFxuICAgICAgICAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXG4gICAgICBdLFxuICAgICAgcGF0aHNQZXJTZXJpZXM6IFtdLFxuICAgICAgaGFzSGlnaGxpZ2h0ZWRMYWJlbHM6IHRydWUsXG4gICAgICBkYXR1bVNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uOiBmYWxzZSxcbiAgICAgIGFuaW1hdGlvbkFsd2F5c1VwZGF0ZVNlbGVjdGlvbnM6IHRydWUsXG4gICAgICBhbmltYXRpb25SZXNldEZuczoge1xuICAgICAgICBkYXR1bTogcmVzZXRCYXJTZWxlY3Rpb25zRm4sXG4gICAgICAgIGxhYmVsOiByZXNldExhYmVsRm5cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgQmFyU2VyaWVzUHJvcGVydGllcygpO1xuICAgIHRoaXMuY29ubmVjdHNUb1lBeGlzID0gdHJ1ZTtcbiAgICB0aGlzLmRhdGFBZ2dyZWdhdGlvbkZpbHRlcnMgPSB2b2lkIDA7XG4gIH1cbiAgZ2V0IHBpY2tNb2RlQXhpcygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnNwYXJrbGluZU1vZGUgPyBcIm1haW5cIiA6IHZvaWQgMDtcbiAgfVxuICBjcm9zc0ZpbHRlcmluZ0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy55RmlsdGVyS2V5ICE9IG51bGwgJiYgKHRoaXMuc2VyaWVzR3JvdXBpbmcgPT0gbnVsbCB8fCB0aGlzLnNlcmllc0dyb3VwaW5nLnN0YWNrSW5kZXggPT09IDApO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8ICF0aGlzLmRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCB5RmlsdGVyS2V5LCBub3JtYWxpemVkVG8sIGZhc3REYXRhUHJvY2Vzc2luZyB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgc2VyaWVzR3JvdXBpbmc6IHsgZ3JvdXBJbmRleCA9IHRoaXMuaWQgfSA9IHt9LCBkYXRhIH0gPSB0aGlzO1xuICAgIGNvbnN0IGdyb3VwQ291bnQyID0gdGhpcy5zZXJpZXNHcm91cGluZz8uZ3JvdXBDb3VudCA/PyAwO1xuICAgIGNvbnN0IHN0YWNrQ291bnQgPSB0aGlzLnNlcmllc0dyb3VwaW5nPy5zdGFja0NvdW50ID8/IDA7XG4gICAgY29uc3Qgc3RhY2tlZCA9IHN0YWNrQ291bnQgPj0gMSB8fCBub3JtYWxpemVkVG8gIT0gbnVsbDtcbiAgICBjb25zdCBncm91cGVkID0gIWZhc3REYXRhUHJvY2Vzc2luZyB8fCBncm91cENvdW50MiA+IDEgfHwgc3RhY2tlZDtcbiAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgeFNjYWxlID0gdGhpcy5nZXRDYXRlZ29yeUF4aXMoKT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5nZXRWYWx1ZUF4aXMoKT8uc2NhbGU7XG4gICAgY29uc3QgeyBpc0NvbnRpbnVvdXNYLCB4U2NhbGVUeXBlLCB5U2NhbGVUeXBlIH0gPSB0aGlzLmdldFNjYWxlSW5mb3JtYXRpb24oeyB4U2NhbGUsIHlTY2FsZSB9KTtcbiAgICBjb25zdCBzdGFja0dyb3VwTmFtZSA9IGBiYXItc3RhY2stJHtncm91cEluZGV4fS15VmFsdWVzYDtcbiAgICBjb25zdCBzdGFja0dyb3VwVHJhaWxpbmdOYW1lID0gYCR7c3RhY2tHcm91cE5hbWV9LXRyYWlsaW5nYDtcbiAgICBjb25zdCB2aXNpYmxlUHJvcHMgPSB0aGlzLnZpc2libGUgPyB7fSA6IHsgZm9yY2VWYWx1ZTogMCB9O1xuICAgIGNvbnN0IHByb3BzID0gW1xuICAgICAga2V5UHJvcGVydHkoeEtleSwgeFNjYWxlVHlwZSwgeyBpZDogXCJ4VmFsdWVcIiB9KSxcbiAgICAgIHZhbHVlUHJvcGVydHkoeUtleSwgeVNjYWxlVHlwZSwgeyBpZDogYHlWYWx1ZS1yYXdgLCBpbnZhbGlkVmFsdWU6IG51bGwsIC4uLnZpc2libGVQcm9wcyB9KVxuICAgIF07XG4gICAgaWYgKHRoaXMuY3Jvc3NGaWx0ZXJpbmdFbmFibGVkKCkpIHtcbiAgICAgIHByb3BzLnB1c2goXG4gICAgICAgIHZhbHVlUHJvcGVydHkoeUZpbHRlcktleSwgeVNjYWxlVHlwZSwge1xuICAgICAgICAgIGlkOiBgeUZpbHRlclZhbHVlYCxcbiAgICAgICAgICBpbnZhbGlkVmFsdWU6IG51bGwsXG4gICAgICAgICAgLi4udmlzaWJsZVByb3BzXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgcHJvcHMucHVzaChcbiAgICAgICAgLi4uZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KFxuICAgICAgICAgIHlLZXksXG4gICAgICAgICAgXCJub3JtYWxcIixcbiAgICAgICAgICBcImN1cnJlbnRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogYHlWYWx1ZS1lbmRgLFxuICAgICAgICAgICAgcmFuZ2VJZDogYHlWYWx1ZS1yYW5nZWAsXG4gICAgICAgICAgICBpbnZhbGlkVmFsdWU6IG51bGwsXG4gICAgICAgICAgICBtaXNzaW5nVmFsdWU6IDAsXG4gICAgICAgICAgICBncm91cElkOiBzdGFja0dyb3VwTmFtZSxcbiAgICAgICAgICAgIHNlcGFyYXRlTmVnYXRpdmU6IHRydWUsXG4gICAgICAgICAgICAuLi52aXNpYmxlUHJvcHNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHlTY2FsZVR5cGVcbiAgICAgICAgKSxcbiAgICAgICAgLi4uZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KFxuICAgICAgICAgIHlLZXksXG4gICAgICAgICAgXCJ0cmFpbGluZ1wiLFxuICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiBgeVZhbHVlLXN0YXJ0YCxcbiAgICAgICAgICAgIGludmFsaWRWYWx1ZTogbnVsbCxcbiAgICAgICAgICAgIG1pc3NpbmdWYWx1ZTogMCxcbiAgICAgICAgICAgIGdyb3VwSWQ6IHN0YWNrR3JvdXBUcmFpbGluZ05hbWUsXG4gICAgICAgICAgICBzZXBhcmF0ZU5lZ2F0aXZlOiB0cnVlLFxuICAgICAgICAgICAgLi4udmlzaWJsZVByb3BzXG4gICAgICAgICAgfSxcbiAgICAgICAgICB5U2NhbGVUeXBlXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc0NvbnRpbnVvdXNYKSB7XG4gICAgICBwcm9wcy5wdXNoKFNNQUxMRVNUX0tFWV9JTlRFUlZBTCwgTEFSR0VTVF9LRVlfSU5URVJWQUwpO1xuICAgIH1cbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIobm9ybWFsaXplZFRvKSkge1xuICAgICAgcHJvcHMucHVzaChub3JtYWxpc2VHcm91cFRvKFtzdGFja0dyb3VwTmFtZSwgc3RhY2tHcm91cFRyYWlsaW5nTmFtZV0sIE1hdGguYWJzKG5vcm1hbGl6ZWRUbykpKTtcbiAgICB9XG4gICAgaWYgKGFuaW1hdGlvbkVuYWJsZWQgJiYgdGhpcy5wcm9jZXNzZWREYXRhKSB7XG4gICAgICBwcm9wcy5wdXNoKGRpZmYodGhpcy5pZCwgdGhpcy5wcm9jZXNzZWREYXRhKSk7XG4gICAgfVxuICAgIGlmIChhbmltYXRpb25FbmFibGVkIHx8ICFncm91cGVkKSB7XG4gICAgICBwcm9wcy5wdXNoKGFuaW1hdGlvblZhbGlkYXRpb24oKSk7XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIGRhdGEsIHtcbiAgICAgIHByb3BzLFxuICAgICAgZ3JvdXBCeUtleXM6IGdyb3VwZWQsXG4gICAgICBncm91cEJ5RGF0YTogIWdyb3VwZWRcbiAgICB9KTtcbiAgICB0aGlzLmRhdGFBZ2dyZWdhdGlvbkZpbHRlcnMgPSB0aGlzLmFnZ3JlZ2F0ZURhdGEoZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhKTtcbiAgICB0aGlzLnNtYWxsZXN0RGF0YUludGVydmFsID0gcHJvY2Vzc2VkRGF0YS5yZWR1Y2VkPy5zbWFsbGVzdEtleUludGVydmFsO1xuICAgIHRoaXMubGFyZ2VzdERhdGFJbnRlcnZhbCA9IHByb2Nlc3NlZERhdGEucmVkdWNlZD8ubGFyZ2VzdEtleUludGVydmFsO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gIH1cbiAgZ2V0U2VyaWVzRG9tYWluKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHsgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsIH0gPSB0aGlzO1xuICAgIGlmIChkYXRhTW9kZWwgPT0gbnVsbCB8fCBwcm9jZXNzZWREYXRhID09IG51bGwpXG4gICAgICByZXR1cm4gW107XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gdGhpcy5nZXRDYXRlZ29yeURpcmVjdGlvbigpKSB7XG4gICAgICBjb25zdCBrZXlEZWYgPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZCeUlkKHRoaXMsIGB4VmFsdWVgKTtcbiAgICAgIGNvbnN0IGtleXMgPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGB4VmFsdWVgLCBcImtleVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgICAgIGlmIChrZXlEZWY/LmRlZi50eXBlID09PSBcImtleVwiICYmIGtleURlZi5kZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYWRCYW5kRXh0ZW50KGtleXMpO1xuICAgIH1cbiAgICBjb25zdCB5S2V5ID0gdGhpcy5kYXRhTW9kZWw/Lmhhc0NvbHVtbkJ5SWQodGhpcywgYHlWYWx1ZS1lbmRgKSA/IFwieVZhbHVlLWVuZFwiIDogXCJ5VmFsdWUtcmF3XCI7XG4gICAgbGV0IHlFeHRlbnQgPSB0aGlzLmRvbWFpbkZvckNsaXBwZWRSYW5nZShcInlcIiAvKiBZICovLCBbeUtleV0sIFwieFZhbHVlXCIsIHRydWUpO1xuICAgIGNvbnN0IHlGaWx0ZXJFeHRlbnQgPSB0aGlzLmNyb3NzRmlsdGVyaW5nRW5hYmxlZCgpID8gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeUZpbHRlclZhbHVlYCwgXCJ2YWx1ZVwiLCBwcm9jZXNzZWREYXRhKSA6IHZvaWQgMDtcbiAgICBpZiAoeUZpbHRlckV4dGVudCAhPSBudWxsKSB7XG4gICAgICB5RXh0ZW50ID0gW01hdGgubWluKHlFeHRlbnRbMF0sIHlGaWx0ZXJFeHRlbnRbMF0pLCBNYXRoLm1heCh5RXh0ZW50WzFdLCB5RmlsdGVyRXh0ZW50WzFdKV07XG4gICAgfVxuICAgIGlmICh0aGlzLmdldFZhbHVlQXhpcygpIGluc3RhbmNlb2YgTG9nQXhpcykge1xuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoeUV4dGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpeGVkWUV4dGVudCA9IE51bWJlci5pc0Zpbml0ZSh5RXh0ZW50WzFdIC0geUV4dGVudFswXSkgPyBbTWF0aC5taW4oMCwgeUV4dGVudFswXSksIE1hdGgubWF4KDAsIHlFeHRlbnRbMV0pXSA6IFtdO1xuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZml4ZWRZRXh0ZW50KTtcbiAgICB9XG4gIH1cbiAgZ2V0U2VyaWVzUmFuZ2UoX2RpcmVjdGlvbiwgdmlzaWJsZVJhbmdlKSB7XG4gICAgY29uc3QgeUtleSA9IHRoaXMuZGF0YU1vZGVsPy5oYXNDb2x1bW5CeUlkKHRoaXMsIGB5VmFsdWUtZW5kYCkgPyBcInlWYWx1ZS1lbmRcIiA6IFwieVZhbHVlLXJhd1wiO1xuICAgIGNvbnN0IFt5MCwgeTFdID0gdGhpcy5kb21haW5Gb3JWaXNpYmxlUmFuZ2UoXCJ5XCIgLyogWSAqLywgW3lLZXldLCBcInhWYWx1ZVwiLCB2aXNpYmxlUmFuZ2UsIHRydWUpO1xuICAgIHJldHVybiBbTWF0aC5taW4oeTAsIDApLCBNYXRoLm1heCh5MSwgMCldO1xuICB9XG4gIGdldFZpc2libGVJdGVtcyh4VmlzaWJsZVJhbmdlLCB5VmlzaWJsZVJhbmdlLCBtaW5WaXNpYmxlSXRlbXMpIHtcbiAgICBjb25zdCB5S2V5ID0gdGhpcy5kYXRhTW9kZWw/Lmhhc0NvbHVtbkJ5SWQodGhpcywgYHlWYWx1ZS1lbmRgKSA/IFwieVZhbHVlLWVuZFwiIDogXCJ5VmFsdWUtcmF3XCI7XG4gICAgcmV0dXJuIHRoaXMuY291bnRWaXNpYmxlSXRlbXMoXCJ4VmFsdWVcIiwgW3lLZXldLCB4VmlzaWJsZVJhbmdlLCB5VmlzaWJsZVJhbmdlLCBtaW5WaXNpYmxlSXRlbXMpO1xuICB9XG4gIGFnZ3JlZ2F0ZURhdGEoX2RhdGFNb2RlbCwgX3Byb2Nlc3NlZERhdGEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY3JlYXRlTm9kZURhdGEoKSB7XG4gICAgY29uc3QgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEsIGdyb3VwU2NhbGUsIGRhdGFBZ2dyZWdhdGlvbkZpbHRlcnMgfSA9IHRoaXM7XG4gICAgY29uc3QgeEF4aXMgPSB0aGlzLmdldENhdGVnb3J5QXhpcygpO1xuICAgIGNvbnN0IHlBeGlzID0gdGhpcy5nZXRWYWx1ZUF4aXMoKTtcbiAgICBpZiAoIWRhdGFNb2RlbCB8fCAhcHJvY2Vzc2VkRGF0YSB8fCAheEF4aXMgfHwgIXlBeGlzIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJhd0RhdGEgPSBwcm9jZXNzZWREYXRhLmRhdGFTb3VyY2VzPy5nZXQodGhpcy5pZCk7XG4gICAgaWYgKHJhd0RhdGEgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB4U2NhbGUgPSB4QXhpcy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB5QXhpcy5zY2FsZTtcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHhOYW1lLCB5TmFtZSwgbGVnZW5kSXRlbU5hbWUsIGxhYmVsIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeVJldmVyc2VkID0geUF4aXMuaXNSZXZlcnNlZCgpO1xuICAgIGNvbnN0IHsgYmFyV2lkdGgsIGdyb3VwSW5kZXg6IGdyb3VwU2NhbGVJbmRleCB9ID0gdGhpcy51cGRhdGVHcm91cFNjYWxlKHhBeGlzKTtcbiAgICBjb25zdCBncm91cE9mZnNldCA9IGdyb3VwU2NhbGUuY29udmVydChTdHJpbmcoZ3JvdXBTY2FsZUluZGV4KSk7XG4gICAgY29uc3QgYmFyT2Zmc2V0ID0gQ29udGludW91c1NjYWxlLmlzKHhTY2FsZSkgPyBiYXJXaWR0aCAqIC0wLjUgOiAwO1xuICAgIGNvbnN0IHhWYWx1ZXMgPSBkYXRhTW9kZWwucmVzb2x2ZUtleXNCeUlkKHRoaXMsIGB4VmFsdWVgLCBwcm9jZXNzZWREYXRhKTtcbiAgICBjb25zdCB5UmF3VmFsdWVzID0gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGB5VmFsdWUtcmF3YCwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgY29uc3QgeUZpbHRlclZhbHVlcyA9IHRoaXMuY3Jvc3NGaWx0ZXJpbmdFbmFibGVkKCkgPyBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYHlGaWx0ZXJWYWx1ZWAsIHByb2Nlc3NlZERhdGEpIDogdm9pZCAwO1xuICAgIGNvbnN0IGFuaW1hdGlvbkVuYWJsZWQgPSAhdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBjb25zdCB4UG9zaXRpb24gPSAoaW5kZXgpID0+IHhTY2FsZS5jb252ZXJ0KHhWYWx1ZXNbaW5kZXhdKSArIGdyb3VwT2Zmc2V0ICsgYmFyT2Zmc2V0O1xuICAgIGNvbnN0IGNyaXNwID0gdGhpcy5wcm9wZXJ0aWVzLmNyaXNwID8/IGNoZWNrQ3Jpc3AoeEF4aXM/LnNjYWxlLCB4QXhpcz8udmlzaWJsZVJhbmdlLCB0aGlzLnNtYWxsZXN0RGF0YUludGVydmFsLCB0aGlzLmxhcmdlc3REYXRhSW50ZXJ2YWwpO1xuICAgIGNvbnN0IGJib3hCb3R0b20gPSB5U2NhbGUuY29udmVydCgwKTtcbiAgICBjb25zdCBub2RlRGF0dW0gPSAoe1xuICAgICAgZGF0dW0sXG4gICAgICBkYXR1bUluZGV4LFxuICAgICAgdmFsdWVJbmRleCxcbiAgICAgIHhWYWx1ZSxcbiAgICAgIHlWYWx1ZSxcbiAgICAgIGN1bXVsYXRpdmVWYWx1ZSxcbiAgICAgIHBoYW50b20sXG4gICAgICBjdXJyWSxcbiAgICAgIHByZXZZLFxuICAgICAgeCxcbiAgICAgIHdpZHRoOiB3aWR0aDIsXG4gICAgICBpc1Bvc2l0aXZlLFxuICAgICAgeVJhbmdlLFxuICAgICAgbGFiZWxUZXh0LFxuICAgICAgb3BhY2l0eSxcbiAgICAgIGNyb3NzU2NhbGUgPSAxXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgaXNVcHdhcmQgPSBpc1Bvc2l0aXZlICE9PSB5UmV2ZXJzZWQ7XG4gICAgICBjb25zdCB5ID0geVNjYWxlLmNvbnZlcnQoY3VyclkpO1xuICAgICAgY29uc3QgYm90dG9tWSA9IHlTY2FsZS5jb252ZXJ0KHByZXZZKTtcbiAgICAgIGNvbnN0IGJib3hIZWlnaHQgPSB5U2NhbGUuY29udmVydCh5UmFuZ2UpO1xuICAgICAgY29uc3QgYmFyQWxvbmdYID0gdGhpcy5nZXRCYXJEaXJlY3Rpb24oKSA9PT0gXCJ4XCIgLyogWCAqLztcbiAgICAgIGNvbnN0IHhPZmZzZXQgPSB3aWR0aDIgKiAwLjUgKiAoMSAtIGNyb3NzU2NhbGUpO1xuICAgICAgY29uc3QgcmVjdCA9IHtcbiAgICAgICAgeDogYmFyQWxvbmdYID8gTWF0aC5taW4oeSwgYm90dG9tWSkgOiB4ICsgeE9mZnNldCxcbiAgICAgICAgeTogYmFyQWxvbmdYID8geCArIHhPZmZzZXQgOiBNYXRoLm1pbih5LCBib3R0b21ZKSxcbiAgICAgICAgd2lkdGg6IGJhckFsb25nWCA/IE1hdGguYWJzKGJvdHRvbVkgLSB5KSA6IHdpZHRoMiAqIGNyb3NzU2NhbGUsXG4gICAgICAgIGhlaWdodDogYmFyQWxvbmdYID8gd2lkdGgyICogY3Jvc3NTY2FsZSA6IE1hdGguYWJzKGJvdHRvbVkgLSB5KVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNsaXBCQm94ID0gbmV3IEJCb3gocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGJhclJlY3QgPSB7XG4gICAgICAgIHg6IGJhckFsb25nWCA/IE1hdGgubWluKGJib3hCb3R0b20sIGJib3hIZWlnaHQpIDogeCArIHhPZmZzZXQsXG4gICAgICAgIHk6IGJhckFsb25nWCA/IHggKyB4T2Zmc2V0IDogTWF0aC5taW4oYmJveEJvdHRvbSwgYmJveEhlaWdodCksXG4gICAgICAgIHdpZHRoOiBiYXJBbG9uZ1ggPyBNYXRoLmFicyhiYm94Qm90dG9tIC0gYmJveEhlaWdodCkgOiB3aWR0aDIgKiBjcm9zc1NjYWxlLFxuICAgICAgICBoZWlnaHQ6IGJhckFsb25nWCA/IHdpZHRoMiAqIGNyb3NzU2NhbGUgOiBNYXRoLmFicyhiYm94Qm90dG9tIC0gYmJveEhlaWdodClcbiAgICAgIH07XG4gICAgICBjb25zdCBsZW5ndGhSYXRpb011bHRpcGxpZXIgPSB0aGlzLnNob3VsZEZsaXBYWSgpID8gcmVjdC5oZWlnaHQgOiByZWN0LndpZHRoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICBpdGVtSWQ6IHBoYW50b20gPyBjcmVhdGVEYXR1bUlkKHlLZXksIHBoYW50b20pIDogeUtleSxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGRhdHVtSW5kZXgsXG4gICAgICAgIHZhbHVlSW5kZXgsXG4gICAgICAgIGN1bXVsYXRpdmVWYWx1ZSxcbiAgICAgICAgcGhhbnRvbSxcbiAgICAgICAgeFZhbHVlLFxuICAgICAgICB5VmFsdWUsXG4gICAgICAgIHlLZXksXG4gICAgICAgIHhLZXksXG4gICAgICAgIGNhcERlZmF1bHRzOiB7XG4gICAgICAgICAgbGVuZ3RoUmF0aW9NdWx0aXBsaWVyLFxuICAgICAgICAgIGxlbmd0aE1heDogbGVuZ3RoUmF0aW9NdWx0aXBsaWVyXG4gICAgICAgIH0sXG4gICAgICAgIHg6IGJhclJlY3QueCxcbiAgICAgICAgeTogYmFyUmVjdC55LFxuICAgICAgICB3aWR0aDogYmFyUmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBiYXJSZWN0LmhlaWdodCxcbiAgICAgICAgbWlkUG9pbnQ6IHsgeDogcmVjdC54ICsgcmVjdC53aWR0aCAvIDIsIHk6IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMiB9LFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzOiBiYXJBbG9uZ1ggIT09IGlzVXB3YXJkLFxuICAgICAgICB0b3BSaWdodENvcm5lclJhZGl1czogaXNVcHdhcmQsXG4gICAgICAgIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzOiBiYXJBbG9uZ1ggPT09IGlzVXB3YXJkLFxuICAgICAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzOiAhaXNVcHdhcmQsXG4gICAgICAgIGNsaXBCQm94LFxuICAgICAgICBjcmlzcCxcbiAgICAgICAgbGFiZWw6IGxhYmVsVGV4dCAhPSBudWxsID8ge1xuICAgICAgICAgIHRleHQ6IGxhYmVsVGV4dCxcbiAgICAgICAgICAuLi5hZGp1c3RMYWJlbFBsYWNlbWVudCh7XG4gICAgICAgICAgICBpc1Vwd2FyZCxcbiAgICAgICAgICAgIGlzVmVydGljYWw6ICFiYXJBbG9uZ1gsXG4gICAgICAgICAgICBwbGFjZW1lbnQ6IGxhYmVsLnBsYWNlbWVudCxcbiAgICAgICAgICAgIHBhZGRpbmc6IGxhYmVsLnBhZGRpbmcsXG4gICAgICAgICAgICByZWN0XG4gICAgICAgICAgfSlcbiAgICAgICAgfSA6IHZvaWQgMCxcbiAgICAgICAgbWlzc2luZzogeVZhbHVlID09IG51bGwsXG4gICAgICAgIGZvY3VzYWJsZTogIXBoYW50b21cbiAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBwaGFudG9tTm9kZXMgPSBbXTtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IGxhYmVscyA9IFtdO1xuICAgIGNvbnN0IGhhbmRsZURhdHVtID0gKGRhdHVtSW5kZXgsIHZhbHVlSW5kZXgsIHgsIHdpZHRoMiwgeVN0YXJ0LCB5RW5kLCB5UmFuZ2UsIG9wYWNpdHkpID0+IHtcbiAgICAgIGNvbnN0IHhWYWx1ZSA9IHhWYWx1ZXNbZGF0dW1JbmRleF07XG4gICAgICBpZiAoeFZhbHVlID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHlSYXdWYWx1ZSA9IHlSYXdWYWx1ZXNbZGF0dW1JbmRleF07XG4gICAgICBjb25zdCB5RmlsdGVyVmFsdWUgPSB5RmlsdGVyVmFsdWVzICE9IG51bGwgPyBOdW1iZXIoeUZpbHRlclZhbHVlc1tkYXR1bUluZGV4XSkgOiB2b2lkIDA7XG4gICAgICBjb25zdCBpc1Bvc2l0aXZlID0geVJhd1ZhbHVlID49IDAgJiYgIU9iamVjdC5pcyh5UmF3VmFsdWUsIC0wKTtcbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHlFbmQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoeUZpbHRlclZhbHVlICE9IG51bGwgJiYgIU51bWJlci5pc0Zpbml0ZSh5RmlsdGVyVmFsdWUpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBsYWJlbFRleHQgPSB5UmF3VmFsdWUgIT0gbnVsbCA/IHRoaXMuZ2V0TGFiZWxUZXh0KHRoaXMucHJvcGVydGllcy5sYWJlbCwge1xuICAgICAgICBkYXR1bTogcmF3RGF0YVtkYXR1bUluZGV4XSxcbiAgICAgICAgdmFsdWU6IHlGaWx0ZXJWYWx1ZSA/PyB5UmF3VmFsdWUsXG4gICAgICAgIHhLZXksXG4gICAgICAgIHlLZXksXG4gICAgICAgIHhOYW1lLFxuICAgICAgICB5TmFtZSxcbiAgICAgICAgbGVnZW5kSXRlbU5hbWVcbiAgICAgIH0pIDogdm9pZCAwO1xuICAgICAgY29uc3QgaW5zZXQgPSB5RmlsdGVyVmFsdWUgIT0gbnVsbCAmJiB5RmlsdGVyVmFsdWUgPiB5UmF3VmFsdWU7XG4gICAgICBjb25zdCBub2RlRGF0YSA9IG5vZGVEYXR1bSh7XG4gICAgICAgIGRhdHVtOiByYXdEYXRhW2RhdHVtSW5kZXhdLFxuICAgICAgICBkYXR1bUluZGV4LFxuICAgICAgICB2YWx1ZUluZGV4LFxuICAgICAgICB4VmFsdWUsXG4gICAgICAgIHlWYWx1ZTogeUZpbHRlclZhbHVlID8/IHlSYXdWYWx1ZSxcbiAgICAgICAgY3VtdWxhdGl2ZVZhbHVlOiB5RmlsdGVyVmFsdWUgPz8geUVuZCxcbiAgICAgICAgcGhhbnRvbTogZmFsc2UsXG4gICAgICAgIGN1cnJZOiB5RmlsdGVyVmFsdWUgIT0gbnVsbCA/IHlTdGFydCArIHlGaWx0ZXJWYWx1ZSA6IHlFbmQsXG4gICAgICAgIHByZXZZOiB5U3RhcnQsXG4gICAgICAgIHgsXG4gICAgICAgIHdpZHRoOiB3aWR0aDIsXG4gICAgICAgIGlzUG9zaXRpdmUsXG4gICAgICAgIHlSYW5nZTogTWF0aC5tYXgoeVN0YXJ0ICsgKHlGaWx0ZXJWYWx1ZSA/PyAtSW5maW5pdHkpLCB5UmFuZ2UpLFxuICAgICAgICBsYWJlbFRleHQsXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIGNyb3NzU2NhbGU6IGluc2V0ID8gMC42IDogdm9pZCAwXG4gICAgICB9KTtcbiAgICAgIG5vZGVzLnB1c2gobm9kZURhdGEpO1xuICAgICAgbGFiZWxzLnB1c2gobm9kZURhdGEpO1xuICAgICAgaWYgKHlGaWx0ZXJWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHBoYW50b21Ob2RlRGF0YSA9IG5vZGVEYXR1bSh7XG4gICAgICAgICAgZGF0dW06IHJhd0RhdGFbZGF0dW1JbmRleF0sXG4gICAgICAgICAgZGF0dW1JbmRleCxcbiAgICAgICAgICB2YWx1ZUluZGV4LFxuICAgICAgICAgIHhWYWx1ZSxcbiAgICAgICAgICB5VmFsdWU6IHlGaWx0ZXJWYWx1ZSxcbiAgICAgICAgICBjdW11bGF0aXZlVmFsdWU6IHlGaWx0ZXJWYWx1ZSxcbiAgICAgICAgICBwaGFudG9tOiB0cnVlLFxuICAgICAgICAgIGN1cnJZOiB5RW5kLFxuICAgICAgICAgIHByZXZZOiB5U3RhcnQsXG4gICAgICAgICAgeCxcbiAgICAgICAgICB3aWR0aDogd2lkdGgyLFxuICAgICAgICAgIGlzUG9zaXRpdmUsXG4gICAgICAgICAgeVJhbmdlLFxuICAgICAgICAgIGxhYmVsVGV4dDogdm9pZCAwLFxuICAgICAgICAgIG9wYWNpdHksXG4gICAgICAgICAgY3Jvc3NTY2FsZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBwaGFudG9tTm9kZXMucHVzaChwaGFudG9tTm9kZURhdGEpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgW3IwLCByMV0gPSB4U2NhbGUucmFuZ2U7XG4gICAgY29uc3QgcmFuZ2UzID0gcjEgLSByMDtcbiAgICBjb25zdCBkYXRhQWdncmVnYXRpb25GaWx0ZXIgPSBkYXRhQWdncmVnYXRpb25GaWx0ZXJzPy5maW5kKChmKSA9PiBmLm1heFJhbmdlID4gcmFuZ2UzKTtcbiAgICBpZiAocHJvY2Vzc2VkRGF0YS50eXBlID09PSBcImdyb3VwZWRcIikge1xuICAgICAgY29uc3Qgd2lkdGgyID0gYmFyV2lkdGg7XG4gICAgICBjb25zdCBzdGFja2VkID0gZGF0YU1vZGVsLmhhc0NvbHVtbkJ5SWQodGhpcywgYHlWYWx1ZS1zdGFydGApO1xuICAgICAgY29uc3QgeVN0YXJ0VmFsdWVzID0gc3RhY2tlZCA/IGRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBgeVZhbHVlLXN0YXJ0YCwgcHJvY2Vzc2VkRGF0YSkgOiB2b2lkIDA7XG4gICAgICBjb25zdCB5RW5kVmFsdWVzID0gc3RhY2tlZCA/IGRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBgeVZhbHVlLWVuZGAsIHByb2Nlc3NlZERhdGEpIDogdm9pZCAwO1xuICAgICAgY29uc3QgeVJhbmdlSW5kZXggPSBzdGFja2VkID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5VmFsdWUtcmFuZ2VgKSA6IC0xO1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIGRhdHVtSW5kZXgsXG4gICAgICAgIHZhbHVlSW5kZXgsXG4gICAgICAgIGdyb3VwOiB7IGFnZ3JlZ2F0aW9uIH1cbiAgICAgIH0gb2YgZGF0YU1vZGVsLmZvckVhY2hHcm91cERhdHVtKHRoaXMsIHByb2Nlc3NlZERhdGEpKSB7XG4gICAgICAgIGNvbnN0IHggPSB4UG9zaXRpb24oZGF0dW1JbmRleCk7XG4gICAgICAgIGNvbnN0IHlSYXdWYWx1ZSA9IHlSYXdWYWx1ZXNbZGF0dW1JbmRleF07XG4gICAgICAgIGNvbnN0IGlzUG9zaXRpdmUgPSB5UmF3VmFsdWUgPj0gMCAmJiAhT2JqZWN0LmlzKHlSYXdWYWx1ZSwgLTApO1xuICAgICAgICBjb25zdCB5U3RhcnQgPSBzdGFja2VkID8gTnVtYmVyKHlTdGFydFZhbHVlcz8uW2RhdHVtSW5kZXhdKSA6IDA7XG4gICAgICAgIGNvbnN0IHlFbmQgPSBzdGFja2VkID8gTnVtYmVyKHlFbmRWYWx1ZXM/LltkYXR1bUluZGV4XSkgOiB5UmF3VmFsdWU7XG4gICAgICAgIGxldCB5UmFuZ2UgPSB5RW5kO1xuICAgICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICAgIHlSYW5nZSA9IGFnZ3JlZ2F0aW9uW3lSYW5nZUluZGV4XVtpc1Bvc2l0aXZlID8gMSA6IDBdO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZURhdHVtKGRhdHVtSW5kZXgsIHZhbHVlSW5kZXgsIHgsIHdpZHRoMiwgeVN0YXJ0LCB5RW5kLCB5UmFuZ2UsIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YUFnZ3JlZ2F0aW9uRmlsdGVyID09IG51bGwpIHtcbiAgICAgIGNvbnN0IHdpZHRoMiA9IGJhcldpZHRoO1xuICAgICAgbGV0IFtzdGFydDIsIGVuZDJdID0gdGhpcy52aXNpYmxlUmFuZ2UoXCJ4VmFsdWVcIiwgeEF4aXMucmFuZ2UpO1xuICAgICAgaWYgKHByb2Nlc3NlZERhdGEuaW5wdXQuY291bnQgPCAxZTMpIHtcbiAgICAgICAgc3RhcnQyID0gMDtcbiAgICAgICAgZW5kMiA9IHByb2Nlc3NlZERhdGEuaW5wdXQuY291bnQ7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBkYXR1bUluZGV4ID0gc3RhcnQyOyBkYXR1bUluZGV4IDwgZW5kMjsgZGF0dW1JbmRleCArPSAxKSB7XG4gICAgICAgIGNvbnN0IHggPSB4UG9zaXRpb24oZGF0dW1JbmRleCk7XG4gICAgICAgIGNvbnN0IHlFbmQgPSBOdW1iZXIoeVJhd1ZhbHVlc1tkYXR1bUluZGV4XSk7XG4gICAgICAgIGhhbmRsZURhdHVtKGRhdHVtSW5kZXgsIDAsIHgsIHdpZHRoMiwgMCwgeUVuZCwgeUVuZCwgMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgaW5kZXhEYXRhLCBpbmRpY2VzIH0gPSBkYXRhQWdncmVnYXRpb25GaWx0ZXI7XG4gICAgICBjb25zdCBbc3RhcnQyLCBlbmQyXSA9IHRoaXMudmlzaWJsZVJhbmdlKFwieFZhbHVlXCIsIHhBeGlzLnJhbmdlLCBpbmRpY2VzKTtcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydDI7IGkgPCBlbmQyOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgYWdnSW5kZXggPSBpICogU1BBTjI7XG4gICAgICAgIGNvbnN0IHhNaW5JbmRleCA9IGluZGV4RGF0YVthZ2dJbmRleCArIFhfTUlOXTtcbiAgICAgICAgY29uc3QgeE1heEluZGV4ID0gaW5kZXhEYXRhW2FnZ0luZGV4ICsgWF9NQVhdO1xuICAgICAgICBjb25zdCB5TWluSW5kZXggPSBpbmRleERhdGFbYWdnSW5kZXggKyBZX01JTl07XG4gICAgICAgIGNvbnN0IHlNYXhJbmRleCA9IGluZGV4RGF0YVthZ2dJbmRleCArIFlfTUFYXTtcbiAgICAgICAgaWYgKHhNaW5JbmRleCA9PT0gLTEpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHggPSB4UG9zaXRpb24oKHhNaW5JbmRleCArIHhNYXhJbmRleCkgLyAyIHwgMCk7XG4gICAgICAgIGNvbnN0IHdpZHRoMiA9IE1hdGguYWJzKHhQb3NpdGlvbih4TWF4SW5kZXgpIC0geFBvc2l0aW9uKHhNaW5JbmRleCkpICsgYmFyV2lkdGg7XG4gICAgICAgIGNvbnN0IHlFbmRNYXggPSB4VmFsdWVzW3lNYXhJbmRleF0gIT0gbnVsbCA/IE51bWJlcih5UmF3VmFsdWVzW3lNYXhJbmRleF0pIDogTmFOO1xuICAgICAgICBjb25zdCB5RW5kTWluID0geFZhbHVlc1t5TWluSW5kZXhdICE9IG51bGwgPyBOdW1iZXIoeVJhd1ZhbHVlc1t5TWluSW5kZXhdKSA6IE5hTjtcbiAgICAgICAgaWYgKHlFbmRNYXggPiAwKSB7XG4gICAgICAgICAgY29uc3Qgb3BhY2l0eSA9IHlFbmRNaW4gPj0gMCA/IHlFbmRNaW4gLyB5RW5kTWF4IDogMTtcbiAgICAgICAgICBoYW5kbGVEYXR1bSh5TWF4SW5kZXgsIDAsIHgsIHdpZHRoMiwgMCwgeUVuZE1heCwgeUVuZE1heCwgb3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHlFbmRNaW4gPCAwKSB7XG4gICAgICAgICAgY29uc3Qgb3BhY2l0eSA9IHlFbmRNYXggPD0gMCA/IHlFbmRNYXggLyB5RW5kTWluIDogMTtcbiAgICAgICAgICBoYW5kbGVEYXR1bSh5TWluSW5kZXgsIDEsIHgsIHdpZHRoMiwgMCwgeUVuZE1pbiwgeUVuZE1pbiwgb3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgIG5vZGVEYXRhOiBwaGFudG9tTm9kZXMubGVuZ3RoID4gMCA/IFsuLi5waGFudG9tTm9kZXMsIC4uLm5vZGVzXSA6IG5vZGVzLFxuICAgICAgbGFiZWxEYXRhOiBsYWJlbHMsXG4gICAgICBzY2FsZXM6IHRoaXMuY2FsY3VsYXRlU2NhbGluZygpLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlIHx8IGFuaW1hdGlvbkVuYWJsZWQsXG4gICAgICBncm91cFNjYWxlOiB0aGlzLmdldFNjYWxpbmcodGhpcy5ncm91cFNjYWxlKVxuICAgIH07XG4gIH1cbiAgbm9kZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN0KCk7XG4gIH1cbiAgZ2V0SGlnaGxpZ2h0RGF0YShub2RlRGF0YSwgaGlnaGxpZ2h0ZWRJdGVtKSB7XG4gICAgY29uc3QgaGlnaGxpZ2h0SXRlbSA9IG5vZGVEYXRhLmZpbmQoXG4gICAgICAobm9kZURhdHVtKSA9PiBub2RlRGF0dW0uZGF0dW0gPT09IGhpZ2hsaWdodGVkSXRlbS5kYXR1bSAmJiAhbm9kZURhdHVtLnBoYW50b21cbiAgICApO1xuICAgIHJldHVybiBoaWdobGlnaHRJdGVtICE9IG51bGwgPyBbaGlnaGxpZ2h0SXRlbV0gOiB2b2lkIDA7XG4gIH1cbiAgdXBkYXRlRGF0dW1TZWxlY3Rpb24ob3B0cykge1xuICAgIHJldHVybiBvcHRzLmRhdHVtU2VsZWN0aW9uLnVwZGF0ZShvcHRzLm5vZGVEYXRhLCB2b2lkIDAsIChkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKSk7XG4gIH1cbiAgZ2V0SXRlbUJhc2VTdHlsZShoaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGNvcm5lclJhZGl1cyB9ID0gcHJvcGVydGllcztcbiAgICBjb25zdCBoaWdobGlnaHRTdHlsZSA9IGhpZ2hsaWdodGVkID8gcHJvcGVydGllcy5oaWdobGlnaHRTdHlsZS5pdGVtIDogdm9pZCAwO1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsOiBoaWdobGlnaHRTdHlsZT8uZmlsbCA/PyBwcm9wZXJ0aWVzLmZpbGwsXG4gICAgICBmaWxsT3BhY2l0eTogaGlnaGxpZ2h0U3R5bGU/LmZpbGxPcGFjaXR5ID8/IHByb3BlcnRpZXMuZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2U6IGhpZ2hsaWdodFN0eWxlPy5zdHJva2UgPz8gcHJvcGVydGllcy5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogaGlnaGxpZ2h0U3R5bGU/LnN0cm9rZVdpZHRoID8/IHRoaXMuZ2V0U3Ryb2tlV2lkdGgocHJvcGVydGllcy5zdHJva2VXaWR0aCksXG4gICAgICBzdHJva2VPcGFjaXR5OiBoaWdobGlnaHRTdHlsZT8uc3Ryb2tlT3BhY2l0eSA/PyBwcm9wZXJ0aWVzLnN0cm9rZU9wYWNpdHksXG4gICAgICBsaW5lRGFzaDogaGlnaGxpZ2h0U3R5bGU/LmxpbmVEYXNoID8/IHByb3BlcnRpZXMubGluZURhc2ggPz8gW10sXG4gICAgICBsaW5lRGFzaE9mZnNldDogaGlnaGxpZ2h0U3R5bGU/LmxpbmVEYXNoT2Zmc2V0ID8/IHByb3BlcnRpZXMubGluZURhc2hPZmZzZXQsXG4gICAgICBjb3JuZXJSYWRpdXNcbiAgICB9O1xuICB9XG4gIGdldEl0ZW1TdHlsZU92ZXJyaWRlcyhkYXR1bUlkLCBkYXR1bSwgeFZhbHVlLCB5VmFsdWUsIGZvcm1hdCwgaGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25zdCB7IGlkOiBzZXJpZXNJZCwgcHJvcGVydGllcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIGl0ZW1TdHlsZXIgfSA9IHByb3BlcnRpZXM7XG4gICAgaWYgKGl0ZW1TdHlsZXIgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHhEb21haW4sIHlEb21haW4gfSA9IHRoaXMuY2FjaGVkRGF0dW1DYWxsYmFjayhcImRvbWFpblwiLCAoKSA9PiAoe1xuICAgICAgeERvbWFpbjogdGhpcy5nZXRTZXJpZXNEb21haW4oXCJ4XCIgLyogWCAqLyksXG4gICAgICB5RG9tYWluOiB0aGlzLmdldFNlcmllc0RvbWFpbihcInlcIiAvKiBZICovKVxuICAgIH0pKTtcbiAgICByZXR1cm4gdGhpcy5jYWNoZWREYXR1bUNhbGxiYWNrKGNyZWF0ZURhdHVtSWQoZGF0dW1JZCwgaGlnaGxpZ2h0ZWQgPyBcImhpZ2hsaWdodFwiIDogXCJub2RlXCIpLCAoKSA9PiB7XG4gICAgICByZXR1cm4gaXRlbVN0eWxlcih7XG4gICAgICAgIHNlcmllc0lkLFxuICAgICAgICAuLi5kYXR1bVN0eWxlclByb3BlcnRpZXMoZGF0dW0sIHhLZXksIHlLZXksIHhEb21haW4sIHlEb21haW4pLFxuICAgICAgICB4VmFsdWUsXG4gICAgICAgIHlWYWx1ZSxcbiAgICAgICAgaGlnaGxpZ2h0ZWQsXG4gICAgICAgIC4uLmZvcm1hdFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlRGF0dW1Ob2RlcyhvcHRzKSB7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgc2hhZG93IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2F0ZWdvcnlBbG9uZ1ggPSB0aGlzLmdldENhdGVnb3J5RGlyZWN0aW9uKCkgPT09IFwieFwiIC8qIFggKi87XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmdldEl0ZW1CYXNlU3R5bGUob3B0cy5pc0hpZ2hsaWdodCk7XG4gICAgb3B0cy5kYXR1bVNlbGVjdGlvbi5lYWNoKChyZWN0LCBkYXR1bSkgPT4ge1xuICAgICAgY29uc3Qgb3ZlcnJpZGVzID0gdGhpcy5nZXRJdGVtU3R5bGVPdmVycmlkZXMoXG4gICAgICAgIFN0cmluZyhkYXR1bS5kYXR1bUluZGV4KSxcbiAgICAgICAgZGF0dW0uZGF0dW0sXG4gICAgICAgIGRhdHVtLnhWYWx1ZSxcbiAgICAgICAgZGF0dW0ueVZhbHVlLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgb3B0cy5pc0hpZ2hsaWdodFxuICAgICAgKTtcbiAgICAgIHJlY3Qub3BhY2l0eSA9IGRhdHVtLm9wYWNpdHkgPz8gMDtcbiAgICAgIGFwcGx5U2hhcGVTdHlsZShyZWN0LCBzdHlsZSwgb3ZlcnJpZGVzKTtcbiAgICAgIGNvbnN0IGNvcm5lclJhZGl1cyA9IG92ZXJyaWRlcz8uY29ybmVyUmFkaXVzID8/IHN0eWxlLmNvcm5lclJhZGl1cztcbiAgICAgIHJlY3QudG9wTGVmdENvcm5lclJhZGl1cyA9IGRhdHVtLnRvcExlZnRDb3JuZXJSYWRpdXMgPyBjb3JuZXJSYWRpdXMgOiAwO1xuICAgICAgcmVjdC50b3BSaWdodENvcm5lclJhZGl1cyA9IGRhdHVtLnRvcFJpZ2h0Q29ybmVyUmFkaXVzID8gY29ybmVyUmFkaXVzIDogMDtcbiAgICAgIHJlY3QuYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgPSBkYXR1bS5ib3R0b21SaWdodENvcm5lclJhZGl1cyA/IGNvcm5lclJhZGl1cyA6IDA7XG4gICAgICByZWN0LmJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgPSBkYXR1bS5ib3R0b21MZWZ0Q29ybmVyUmFkaXVzID8gY29ybmVyUmFkaXVzIDogMDtcbiAgICAgIHJlY3QudmlzaWJsZSA9IGNhdGVnb3J5QWxvbmdYID8gKGRhdHVtLmNsaXBCQm94Py53aWR0aCA/PyBkYXR1bS53aWR0aCkgPiAwIDogKGRhdHVtLmNsaXBCQm94Py5oZWlnaHQgPz8gZGF0dW0uaGVpZ2h0KSA+IDA7XG4gICAgICByZWN0LmNyaXNwID0gZGF0dW0uY3Jpc3A7XG4gICAgICByZWN0LmZpbGxTaGFkb3cgPSBzaGFkb3c7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlTGFiZWxTZWxlY3Rpb24ob3B0cykge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmlzTGFiZWxFbmFibGVkKCkgPyBvcHRzLmxhYmVsRGF0YSA6IFtdO1xuICAgIHJldHVybiBvcHRzLmxhYmVsU2VsZWN0aW9uLnVwZGF0ZShkYXRhLCAodGV4dDIpID0+IHtcbiAgICAgIHRleHQyLnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlTGFiZWxOb2RlcyhvcHRzKSB7XG4gICAgb3B0cy5sYWJlbFNlbGVjdGlvbi5lYWNoKCh0ZXh0Tm9kZSwgZGF0dW0pID0+IHtcbiAgICAgIHVwZGF0ZUxhYmVsTm9kZSh0ZXh0Tm9kZSwgdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLCBkYXR1bS5sYWJlbCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0VG9vbHRpcENvbnRlbnQobm9kZURhdHVtKSB7XG4gICAgY29uc3QgeyBpZDogc2VyaWVzSWQsIGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSwgcHJvcGVydGllcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHhLZXksIHhOYW1lLCB5S2V5LCB5TmFtZSwgbGVnZW5kSXRlbU5hbWUsIHN0YWNrR3JvdXAsIHRvb2x0aXAgfSA9IHByb3BlcnRpZXM7XG4gICAgY29uc3QgeEF4aXMgPSB0aGlzLmdldENhdGVnb3J5QXhpcygpO1xuICAgIGNvbnN0IHlBeGlzID0gdGhpcy5nZXRWYWx1ZUF4aXMoKTtcbiAgICBpZiAoIWRhdGFNb2RlbCB8fCAhcHJvY2Vzc2VkRGF0YSB8fCAheEF4aXMgfHwgIXlBeGlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0dW1JbmRleCB9ID0gbm9kZURhdHVtO1xuICAgIGNvbnN0IGRhdHVtID0gcHJvY2Vzc2VkRGF0YS5kYXRhU291cmNlcy5nZXQodGhpcy5pZCk/LltkYXR1bUluZGV4XTtcbiAgICBjb25zdCB4VmFsdWUgPSBkYXRhTW9kZWwucmVzb2x2ZUtleXNCeUlkKHRoaXMsIGB4VmFsdWVgLCBwcm9jZXNzZWREYXRhKVtkYXR1bUluZGV4XTtcbiAgICBjb25zdCB5VmFsdWUgPSBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYHlWYWx1ZS1yYXdgLCBwcm9jZXNzZWREYXRhKVtkYXR1bUluZGV4XTtcbiAgICBpZiAoeFZhbHVlID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRJdGVtQmFzZVN0eWxlKGZhbHNlKTtcbiAgICBPYmplY3QuYXNzaWduKGZvcm1hdCwgdGhpcy5nZXRJdGVtU3R5bGVPdmVycmlkZXMoU3RyaW5nKGRhdHVtSW5kZXgpLCBkYXR1bSwgeFZhbHVlLCB5VmFsdWUsIGZvcm1hdCwgZmFsc2UpKTtcbiAgICByZXR1cm4gdG9vbHRpcC5mb3JtYXRUb29sdGlwKFxuICAgICAge1xuICAgICAgICBoZWFkaW5nOiB4QXhpcy5mb3JtYXREYXR1bSh4VmFsdWUpLFxuICAgICAgICBzeW1ib2w6IHRoaXMubGVnZW5kSXRlbVN5bWJvbCgpLFxuICAgICAgICBkYXRhOiBbeyBsYWJlbDogeU5hbWUsIGZhbGxiYWNrTGFiZWw6IHlLZXksIHZhbHVlOiB5QXhpcy5mb3JtYXREYXR1bSh5VmFsdWUpIH1dXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHRpdGxlOiB5TmFtZSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlLZXksXG4gICAgICAgIHlOYW1lLFxuICAgICAgICBsZWdlbmRJdGVtTmFtZSxcbiAgICAgICAgc3RhY2tHcm91cCxcbiAgICAgICAgLi4uZm9ybWF0LFxuICAgICAgICAuLi50aGlzLmdldE1vZHVsZVRvb2x0aXBQYXJhbXMoKVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgbGVnZW5kSXRlbVN5bWJvbCgpIHtcbiAgICBjb25zdCB7IGZpbGwsIHN0cm9rZTogc3Ryb2tlMiwgc3Ryb2tlV2lkdGgsIGZpbGxPcGFjaXR5LCBzdHJva2VPcGFjaXR5LCBsaW5lRGFzaCwgbGluZURhc2hPZmZzZXQgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICByZXR1cm4ge1xuICAgICAgbWFya2VyOiB7XG4gICAgICAgIGZpbGwsXG4gICAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgICBzdHJva2U6IHN0cm9rZTIsXG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgICBsaW5lRGFzaCxcbiAgICAgICAgbGluZURhc2hPZmZzZXRcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkge1xuICAgIGNvbnN0IHsgc2hvd0luTGVnZW5kIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKGxlZ2VuZFR5cGUgIT09IFwiY2F0ZWdvcnlcIiB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBpZDogc2VyaWVzSWQsXG4gICAgICBjdHg6IHsgbGVnZW5kTWFuYWdlciB9LFxuICAgICAgdmlzaWJsZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgeUtleTogaXRlbUlkLCB5TmFtZSwgbGVnZW5kSXRlbU5hbWUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBsZWdlbmRUeXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgICAgaXRlbUlkLFxuICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSAmJiBsZWdlbmRNYW5hZ2VyLmdldEl0ZW1FbmFibGVkKHsgc2VyaWVzSWQsIGl0ZW1JZCB9KSxcbiAgICAgICAgbGFiZWw6IHsgdGV4dDogbGVnZW5kSXRlbU5hbWUgPz8geU5hbWUgPz8gaXRlbUlkIH0sXG4gICAgICAgIHN5bWJvbDogdGhpcy5sZWdlbmRJdGVtU3ltYm9sKCksXG4gICAgICAgIGxlZ2VuZEl0ZW1OYW1lLFxuICAgICAgICBoaWRlSW5MZWdlbmQ6ICFzaG93SW5MZWdlbmRcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KHsgZGF0dW1TZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBhbm5vdGF0aW9uU2VsZWN0aW9ucyB9KSB7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZUJhckFuaW1hdGlvbkZ1bmN0aW9ucyhjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uKHRoaXMuaXNWZXJ0aWNhbCgpLCB0aGlzLmF4ZXMsIFwibm9ybWFsXCIpKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgXCJub2Rlc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBbZGF0dW1TZWxlY3Rpb25dLCBmbnMpO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImFubm90YXRpb25zXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIC4uLmFubm90YXRpb25TZWxlY3Rpb25zKTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGRhdGEpIHtcbiAgICBjb25zdCB7IGRhdHVtU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiwgYW5ub3RhdGlvblNlbGVjdGlvbnMsIHByZXZpb3VzQ29udGV4dERhdGEgfSA9IGRhdGE7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xuICAgIGxldCBkYXRhRGlmZiA9IHRoaXMucHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uZGlmZj8uW3RoaXMuaWRdO1xuICAgIGlmIChkYXRhRGlmZiA9PSBudWxsICYmIHRoaXMucHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uZGlmZiAhPSBudWxsKSB7XG4gICAgICBkYXRhRGlmZiA9IHtcbiAgICAgICAgY2hhbmdlZDogdHJ1ZSxcbiAgICAgICAgYWRkZWQ6IG5ldyBTZXQoQXJyYXkuZnJvbShkYXR1bVNlbGVjdGlvbiwgKHsgZGF0dW0gfSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKSkpLFxuICAgICAgICB1cGRhdGVkOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgICByZW1vdmVkOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgICBtb3ZlZDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgbW9kZSA9IHByZXZpb3VzQ29udGV4dERhdGEgPT0gbnVsbCA/IFwiZmFkZVwiIDogXCJub3JtYWxcIjtcbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zKGNvbGxhcHNlZFN0YXJ0aW5nQmFyUG9zaXRpb24odGhpcy5pc1ZlcnRpY2FsKCksIHRoaXMuYXhlcywgbW9kZSkpO1xuICAgIGZyb21Ub01vdGlvbihcbiAgICAgIHRoaXMuaWQsXG4gICAgICBcIm5vZGVzXCIsXG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLFxuICAgICAgW2RhdHVtU2VsZWN0aW9uXSxcbiAgICAgIGZucyxcbiAgICAgIChfLCBkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKSxcbiAgICAgIGRhdGFEaWZmXG4gICAgKTtcbiAgICBjb25zdCBzY2FsaW5nQ2hhbmdlZCA9IHByZXZpb3VzQ29udGV4dERhdGEgIT0gbnVsbCAmJiAoIWFyZVNjYWxpbmdFcXVhbChkYXRhLmNvbnRleHREYXRhLnNjYWxlcy54LCBwcmV2aW91c0NvbnRleHREYXRhLnNjYWxlcy54KSB8fCAhYXJlU2NhbGluZ0VxdWFsKGRhdGEuY29udGV4dERhdGEuc2NhbGVzLnksIHByZXZpb3VzQ29udGV4dERhdGEuc2NhbGVzLnkpIHx8ICFhcmVTY2FsaW5nRXF1YWwoXG4gICAgICBkYXRhLmNvbnRleHREYXRhLmdyb3VwU2NhbGUsXG4gICAgICBkYXRhLnByZXZpb3VzQ29udGV4dERhdGEuZ3JvdXBTY2FsZVxuICAgICkpO1xuICAgIGNvbnN0IGhhc01vdGlvbiA9IChkYXRhRGlmZj8uY2hhbmdlZCA/PyBmYWxzZSkgfHwgc2NhbGluZ0NoYW5nZWQ7XG4gICAgaWYgKGhhc01vdGlvbikge1xuICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb24pO1xuICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJhbm5vdGF0aW9uc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCAuLi5hbm5vdGF0aW9uU2VsZWN0aW9ucyk7XG4gICAgfVxuICB9XG4gIGdldERhdHVtSWQoZGF0dW0pIHtcbiAgICByZXR1cm4gY3JlYXRlRGF0dW1JZChkYXR1bS54VmFsdWUsIGRhdHVtLnZhbHVlSW5kZXgsIGRhdHVtLnBoYW50b20pO1xuICB9XG4gIGlzTGFiZWxFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubGFiZWwuZW5hYmxlZDtcbiAgfVxuICBjb21wdXRlRm9jdXNCb3VuZHMoeyBkYXR1bUluZGV4IH0pIHtcbiAgICBjb25zdCBkYXR1bUJveCA9IHRoaXMuY29udGV4dE5vZGVEYXRhPy5ub2RlRGF0YVtkYXR1bUluZGV4XS5jbGlwQkJveDtcbiAgICByZXR1cm4gY29tcHV0ZUJhckZvY3VzQm91bmRzKHRoaXMsIGRhdHVtQm94KTtcbiAgfVxufTtcbkJhclNlcmllcy5jbGFzc05hbWUgPSBcIkJhclNlcmllc1wiO1xuQmFyU2VyaWVzLnR5cGUgPSBcImJhclwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2JhclNlcmllc01vZHVsZS50c1xudmFyIEJhclNlcmllc01vZHVsZSA9IHtcbiAgdHlwZTogXCJzZXJpZXNcIixcbiAgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLFxuICBpZGVudGlmaWVyOiBcImJhclwiLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgQmFyU2VyaWVzKGN0eCksXG4gIHN0YWNrYWJsZTogdHJ1ZSxcbiAgZ3JvdXBhYmxlOiB0cnVlLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwiZXhhY3RcIiB9LFxuICBkZWZhdWx0QXhlczogc3dhcEF4aXNDb25kaXRpb24oXG4gICAgW1xuICAgICAgeyB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLywgcG9zaXRpb246IFwibGVmdFwiIC8qIExFRlQgKi8gfSxcbiAgICAgIHsgdHlwZTogXCJjYXRlZ29yeVwiIC8qIENBVEVHT1JZICovLCBwb3NpdGlvbjogXCJib3R0b21cIiAvKiBCT1RUT00gKi8gfVxuICAgIF0sXG4gICAgKHNlcmllcykgPT4gc2VyaWVzPy5kaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiXG4gICksXG4gIHRoZW1lVGVtcGxhdGU6IHtcbiAgICBzZXJpZXM6IHtcbiAgICAgIGRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiLFxuICAgICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgICBzdHJva2VXaWR0aDogMCxcbiAgICAgIGxpbmVEYXNoOiBbMF0sXG4gICAgICBsaW5lRGFzaE9mZnNldDogMCxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmb250V2VpZ2h0OiB7ICRyZWY6IFwiZm9udFdlaWdodFwiIH0sXG4gICAgICAgIGZvbnRTaXplOiB7ICRyZWY6IFwiZm9udFNpemVcIiB9LFxuICAgICAgICBmb250RmFtaWx5OiB7ICRyZWY6IFwiZm9udEZhbWlseVwiIH0sXG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgJGlmOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICRvcjogW1xuICAgICAgICAgICAgICAgIHsgJGVxOiBbeyAkcGF0aDogXCIuL3BsYWNlbWVudFwiIH0sIFwib3V0c2lkZS1zdGFydFwiXSB9LFxuICAgICAgICAgICAgICAgIHsgJGVxOiBbeyAkcGF0aDogXCIuL3BsYWNlbWVudFwiIH0sIFwib3V0c2lkZS1lbmRcIl0gfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyAkcmVmOiBcInRleHRDb2xvclwiIH0sXG4gICAgICAgICAgICB7ICRyZWY6IFwiYmFja2dyb3VuZENvbG9yXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgcGxhY2VtZW50OiBcImluc2lkZS1jZW50ZXJcIlxuICAgICAgfSxcbiAgICAgIHNoYWRvdzoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfU0hBRE9XX0NPTE9VUixcbiAgICAgICAgeE9mZnNldDogMyxcbiAgICAgICAgeU9mZnNldDogMyxcbiAgICAgICAgYmx1cjogNVxuICAgICAgfSxcbiAgICAgIGVycm9yQmFyOiB7XG4gICAgICAgIGNhcDoge1xuICAgICAgICAgIGxlbmd0aFJhdGlvOiAwLjNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGFsZXR0ZUZhY3Rvcnk6IHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2J1YmJsZVNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBCdWJibGVTZXJpZXNNYXJrZXIgPSBjbGFzcyBleHRlbmRzIFNlcmllc01hcmtlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5tYXhTaXplID0gMzA7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBCdWJibGVTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcIm1heFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVJfQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEJ1YmJsZVNlcmllc01hcmtlci5wcm90b3R5cGUsIFwiZG9tYWluXCIsIDIpO1xudmFyIEJ1YmJsZVNlcmllc0xhYmVsID0gY2xhc3MgZXh0ZW5kcyBMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wbGFjZW1lbnQgPSBcInRvcFwiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTEFCRUxfUExBQ0VNRU5UKVxuXSwgQnViYmxlU2VyaWVzTGFiZWwucHJvdG90eXBlLCBcInBsYWNlbWVudFwiLCAyKTtcbnZhciBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNvbG9yUmFuZ2UgPSBbXCIjZmZmZjAwXCIsIFwiIzAwZmYwMFwiLCBcIiMwMDAwZmZcIl07XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBCdWJibGVTZXJpZXNMYWJlbCgpO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTZXJpZXNUb29sdGlwKCk7XG4gICAgLy8gTm8gdmFsaWRhdGlvbi4gTm90IGEgcGFydCBvZiB0aGUgb3B0aW9ucyBjb250cmFjdC5cbiAgICB0aGlzLm1hcmtlciA9IG5ldyBCdWJibGVTZXJpZXNNYXJrZXIoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2l6ZUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4RmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5RmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaXplRmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNpemVOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUl9BUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JEb21haW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvclJhbmdlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc2hhcGVcIilcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNoYXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zaXplXCIpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5tYXhTaXplXCIpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJtYXhTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5kb21haW5cIiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZG9tYWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5maWxsXCIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLmZpbGxPcGFjaXR5XCIpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc3Ryb2tlXCIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc3Ryb2tlV2lkdGhcIilcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zdHJva2VPcGFjaXR5XCIpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5saW5lRGFzaFwiKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLmxpbmVEYXNoT2Zmc2V0XCIpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuaXRlbVN0eWxlclwiLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpdGVtU3R5bGVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2J1YmJsZVNlcmllcy50c1xudmFyIEJ1YmJsZVNlcmllc05vZGVFdmVudCA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzTm9kZUV2ZW50IHtcbiAgY29uc3RydWN0b3IodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpIHtcbiAgICBzdXBlcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcyk7XG4gICAgdGhpcy5zaXplS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMuc2l6ZUtleTtcbiAgfVxufTtcbnZhciBCdWJibGVTZXJpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIGRpcmVjdGlvbktleXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTLFxuICAgICAgZGlyZWN0aW9uTmFtZXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyxcbiAgICAgIHBpY2tNb2RlczogW1xuICAgICAgICAyIC8qIEFYSVNfQUxJR05FRCAqLyxcbiAgICAgICAgMSAvKiBORUFSRVNUX05PREUgKi8sXG4gICAgICAgIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9cbiAgICAgIF0sXG4gICAgICBwYXRoc1BlclNlcmllczogW10sXG4gICAgICBoYXNNYXJrZXJzOiB0cnVlLFxuICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHtcbiAgICAgICAgbGFiZWw6IHJlc2V0TGFiZWxGbixcbiAgICAgICAgbWFya2VyOiByZXNldE1hcmtlckZuXG4gICAgICB9LFxuICAgICAgdXNlc1BsYWNlZExhYmVsczogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuTm9kZUV2ZW50ID0gQnViYmxlU2VyaWVzTm9kZUV2ZW50O1xuICAgIHRoaXMuY2xpcEZvY3VzQm94ID0gZmFsc2U7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gbmV3IEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLnNpemVTY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpO1xuICAgIHRoaXMuY29sb3JTY2FsZSA9IG5ldyBDb2xvclNjYWxlKCk7XG4gIH1cbiAgZ2V0IHBpY2tNb2RlQXhpcygpIHtcbiAgICByZXR1cm4gXCJtYWluLWNhdGVnb3J5XCI7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgdGhpcy5kYXRhID09IG51bGwgfHwgIXRoaXMudmlzaWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB4U2NhbGUgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXT8uc2NhbGU7XG4gICAgY29uc3QgeyB4U2NhbGVUeXBlLCB5U2NhbGVUeXBlIH0gPSB0aGlzLmdldFNjYWxlSW5mb3JtYXRpb24oeyB4U2NhbGUsIHlTY2FsZSB9KTtcbiAgICBjb25zdCBjb2xvclNjYWxlVHlwZSA9IHRoaXMuY29sb3JTY2FsZS50eXBlO1xuICAgIGNvbnN0IHNpemVTY2FsZVR5cGUgPSB0aGlzLnNpemVTY2FsZS50eXBlO1xuICAgIGNvbnN0IHtcbiAgICAgIHhLZXksXG4gICAgICB5S2V5LFxuICAgICAgc2l6ZUtleSxcbiAgICAgIHhGaWx0ZXJLZXksXG4gICAgICB5RmlsdGVyS2V5LFxuICAgICAgc2l6ZUZpbHRlcktleSxcbiAgICAgIGxhYmVsS2V5LFxuICAgICAgY29sb3JEb21haW4sXG4gICAgICBjb2xvclJhbmdlLFxuICAgICAgY29sb3JLZXksXG4gICAgICBtYXJrZXJcbiAgICB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIHRoaXMuZGF0YSwge1xuICAgICAgcHJvcHM6IFtcbiAgICAgICAgdmFsdWVQcm9wZXJ0eSh4S2V5LCB4U2NhbGVUeXBlLCB7IGlkOiBgeFZhbHVlYCB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7IGlkOiBgeVZhbHVlYCB9KSxcbiAgICAgICAgLi4ueEZpbHRlcktleSAhPSBudWxsID8gW3ZhbHVlUHJvcGVydHkoeEZpbHRlcktleSwgeFNjYWxlVHlwZSwgeyBpZDogYHhGaWx0ZXJWYWx1ZWAgfSldIDogW10sXG4gICAgICAgIC4uLnlGaWx0ZXJLZXkgIT0gbnVsbCA/IFt2YWx1ZVByb3BlcnR5KHlGaWx0ZXJLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IGB5RmlsdGVyVmFsdWVgIH0pXSA6IFtdLFxuICAgICAgICAuLi5zaXplRmlsdGVyS2V5ICE9IG51bGwgPyBbdmFsdWVQcm9wZXJ0eShzaXplRmlsdGVyS2V5LCBzaXplU2NhbGVUeXBlLCB7IGlkOiBgc2l6ZUZpbHRlclZhbHVlYCB9KV0gOiBbXSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eShzaXplS2V5LCBzaXplU2NhbGVUeXBlLCB7IGlkOiBgc2l6ZVZhbHVlYCB9KSxcbiAgICAgICAgLi4uY29sb3JLZXkgPyBbdmFsdWVQcm9wZXJ0eShjb2xvcktleSwgY29sb3JTY2FsZVR5cGUsIHsgaWQ6IGBjb2xvclZhbHVlYCB9KV0gOiBbXSxcbiAgICAgICAgLi4ubGFiZWxLZXkgPyBbdmFsdWVQcm9wZXJ0eShsYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBsYWJlbFZhbHVlYCB9KV0gOiBbXVxuICAgICAgXVxuICAgIH0pO1xuICAgIGNvbnN0IHNpemVLZXlJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHNpemVWYWx1ZWApO1xuICAgIGNvbnN0IHByb2Nlc3NlZFNpemUgPSBwcm9jZXNzZWREYXRhLmRvbWFpbi52YWx1ZXNbc2l6ZUtleUlkeF0gPz8gW107XG4gICAgdGhpcy5zaXplU2NhbGUuZG9tYWluID0gbWFya2VyLmRvbWFpbiA/IG1hcmtlci5kb21haW4gOiBwcm9jZXNzZWRTaXplO1xuICAgIGlmIChjb2xvcktleSkge1xuICAgICAgY29uc3QgY29sb3JLZXlJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGNvbG9yVmFsdWVgKTtcbiAgICAgIHRoaXMuY29sb3JTY2FsZS5kb21haW4gPSBjb2xvckRvbWFpbiA/PyBwcm9jZXNzZWREYXRhLmRvbWFpbi52YWx1ZXNbY29sb3JLZXlJZHhdID8/IFtdO1xuICAgICAgdGhpcy5jb2xvclNjYWxlLnJhbmdlID0gY29sb3JSYW5nZTtcbiAgICAgIHRoaXMuY29sb3JTY2FsZS51cGRhdGUoKTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKTtcbiAgfVxuICB4Q29vcmRpbmF0ZVJhbmdlKHhWYWx1ZSwgcGl4ZWxTaXplLCBpbmRleCkge1xuICAgIGNvbnN0IHsgcHJvcGVydGllcywgc2l6ZVNjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgc2l6ZSwgc2l6ZUtleSB9ID0gcHJvcGVydGllcztcbiAgICBjb25zdCB4ID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dLnNjYWxlLmNvbnZlcnQoeFZhbHVlKTtcbiAgICBjb25zdCBzaXplVmFsdWVzID0gc2l6ZUtleSAhPSBudWxsID8gdGhpcy5kYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYHNpemVWYWx1ZWAsIHRoaXMucHJvY2Vzc2VkRGF0YSkgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2l6ZVZhbHVlID0gc2l6ZVZhbHVlcyAhPSBudWxsID8gc2l6ZVNjYWxlLmNvbnZlcnQoc2l6ZVZhbHVlc1tpbmRleF0pIDogc2l6ZTtcbiAgICBjb25zdCByID0gMC41ICogc2l6ZVZhbHVlICogcGl4ZWxTaXplO1xuICAgIHJldHVybiBbeCAtIHIsIHggKyByXTtcbiAgfVxuICB5Q29vcmRpbmF0ZVJhbmdlKHlWYWx1ZXMsIHBpeGVsU2l6ZSwgaW5kZXgpIHtcbiAgICBjb25zdCB7IHByb3BlcnRpZXMsIHNpemVTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHNpemUsIHNpemVLZXkgfSA9IHByb3BlcnRpZXM7XG4gICAgY29uc3QgeSA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXS5zY2FsZS5jb252ZXJ0KHlWYWx1ZXNbMF0pO1xuICAgIGNvbnN0IHNpemVWYWx1ZXMgPSBzaXplS2V5ICE9IG51bGwgPyB0aGlzLmRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBgc2l6ZVZhbHVlYCwgdGhpcy5wcm9jZXNzZWREYXRhKSA6IHZvaWQgMDtcbiAgICBjb25zdCBzaXplVmFsdWUgPSBzaXplVmFsdWVzICE9IG51bGwgPyBzaXplU2NhbGUuY29udmVydChzaXplVmFsdWVzW2luZGV4XSkgOiBzaXplO1xuICAgIGNvbnN0IHIgPSAwLjUgKiBzaXplVmFsdWUgKiBwaXhlbFNpemU7XG4gICAgcmV0dXJuIFt5IC0gciwgeSArIHJdO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gdGhpcztcbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBkYXRhVmFsdWVzID0ge1xuICAgICAgW1wieFwiIC8qIFggKi9dOiBcInhWYWx1ZVwiLFxuICAgICAgW1wieVwiIC8qIFkgKi9dOiBcInlWYWx1ZVwiXG4gICAgfTtcbiAgICBjb25zdCBpZCA9IGRhdGFWYWx1ZXNbZGlyZWN0aW9uXTtcbiAgICBjb25zdCBkYXRhRGVmID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZCh0aGlzLCBpZCk7XG4gICAgY29uc3QgZG9tYWluID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBpZCwgXCJ2YWx1ZVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgICBpZiAoZGF0YURlZj8uZGVmLnR5cGUgPT09IFwidmFsdWVcIiAmJiBkYXRhRGVmPy5kZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgIHJldHVybiBkb21haW47XG4gICAgfVxuICAgIGNvbnN0IGNyb3NzRGlyZWN0aW9uID0gZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovID8gXCJ5XCIgLyogWSAqLyA6IFwieFwiIC8qIFggKi87XG4gICAgY29uc3QgY3Jvc3NJZCA9IGRhdGFWYWx1ZXNbY3Jvc3NEaXJlY3Rpb25dO1xuICAgIGNvbnN0IGV4dCA9IHRoaXMuZG9tYWluRm9yQ2xpcHBlZFJhbmdlKGRpcmVjdGlvbiwgW2lkXSwgY3Jvc3NJZCwgZmFsc2UpO1xuICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KGV4dGVudChleHQpKTtcbiAgfVxuICBnZXRTZXJpZXNSYW5nZShfZGlyZWN0aW9uLCB2aXNpYmxlUmFuZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5kb21haW5Gb3JWaXNpYmxlUmFuZ2UoXCJ5XCIgLyogWSAqLywgW1wieVZhbHVlXCJdLCBcInhWYWx1ZVwiLCB2aXNpYmxlUmFuZ2UsIGZhbHNlKTtcbiAgfVxuICBnZXRWaXNpYmxlSXRlbXMoeFZpc2libGVSYW5nZSwgeVZpc2libGVSYW5nZSwgbWluVmlzaWJsZUl0ZW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuY291bnRWaXNpYmxlSXRlbXMoXCJ4VmFsdWVcIiwgW1wieVZhbHVlXCJdLCB4VmlzaWJsZVJhbmdlLCB5VmlzaWJsZVJhbmdlLCBtaW5WaXNpYmxlSXRlbXMpO1xuICB9XG4gIGNyZWF0ZU5vZGVEYXRhKCkge1xuICAgIGNvbnN0IHsgYXhlcywgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhLCBjb2xvclNjYWxlLCBzaXplU2NhbGUsIHZpc2libGUgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgeEtleSxcbiAgICAgIHlLZXksXG4gICAgICBzaXplS2V5LFxuICAgICAgeEZpbHRlcktleSxcbiAgICAgIHlGaWx0ZXJLZXksXG4gICAgICBzaXplRmlsdGVyS2V5LFxuICAgICAgbGFiZWxLZXksXG4gICAgICB4TmFtZSxcbiAgICAgIHlOYW1lLFxuICAgICAgc2l6ZU5hbWUsXG4gICAgICBsYWJlbE5hbWUsXG4gICAgICBsYWJlbCxcbiAgICAgIGNvbG9yS2V5LFxuICAgICAgbWFya2VyXG4gICAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IHBsYWNlbWVudCB9ID0gbGFiZWw7XG4gICAgY29uc3QgYW5jaG9yID0gTWFya2VyLmFuY2hvcihtYXJrZXIuc2hhcGUpO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCEoZGF0YU1vZGVsICYmIHByb2Nlc3NlZERhdGEgJiYgdmlzaWJsZSAmJiB4QXhpcyAmJiB5QXhpcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeERhdGFWYWx1ZXMgPSBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYHhWYWx1ZWAsIHByb2Nlc3NlZERhdGEpO1xuICAgIGNvbnN0IHlEYXRhVmFsdWVzID0gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGB5VmFsdWVgLCBwcm9jZXNzZWREYXRhKTtcbiAgICBjb25zdCBzaXplRGF0YVZhbHVlcyA9IHNpemVLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBgc2l6ZVZhbHVlYCwgcHJvY2Vzc2VkRGF0YSkgOiB2b2lkIDA7XG4gICAgY29uc3QgY29sb3JEYXRhVmFsdWVzID0gY29sb3JLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBgY29sb3JWYWx1ZWAsIHByb2Nlc3NlZERhdGEpIDogdm9pZCAwO1xuICAgIGNvbnN0IGxhYmVsRGF0YVZhbHVlcyA9IGxhYmVsS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYGxhYmVsVmFsdWVgLCBwcm9jZXNzZWREYXRhKSA6IHZvaWQgMDtcbiAgICBjb25zdCB4RmlsdGVyRGF0YVZhbHVlcyA9IHhGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBgeEZpbHRlclZhbHVlYCwgcHJvY2Vzc2VkRGF0YSkgOiB2b2lkIDA7XG4gICAgY29uc3QgeUZpbHRlckRhdGFWYWx1ZXMgPSB5RmlsdGVyS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYHlGaWx0ZXJWYWx1ZWAsIHByb2Nlc3NlZERhdGEpIDogdm9pZCAwO1xuICAgIGNvbnN0IHNpemVGaWx0ZXJEYXRhVmFsdWVzID0gc2l6ZUZpbHRlcktleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGBzaXplRmlsdGVyVmFsdWVgLCBwcm9jZXNzZWREYXRhKSA6IHZvaWQgMDtcbiAgICBjb25zdCB4U2NhbGUgPSB4QXhpcy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB5QXhpcy5zY2FsZTtcbiAgICBjb25zdCB4T2Zmc2V0ID0gKHhTY2FsZS5iYW5kd2lkdGggPz8gMCkgLyAyO1xuICAgIGNvbnN0IHlPZmZzZXQgPSAoeVNjYWxlLmJhbmR3aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBbXTtcbiAgICBzaXplU2NhbGUucmFuZ2UgPSBbbWFya2VyLnNpemUsIG1hcmtlci5tYXhTaXplXTtcbiAgICBjb25zdCBmb250MiA9IGxhYmVsLmdldEZvbnQoKTtcbiAgICBjb25zdCB0ZXh0TWVhc3VyZXIgPSBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLmdldE1lYXN1cmVyKHsgZm9udDogZm9udDIgfSk7XG4gICAgcHJvY2Vzc2VkRGF0YS5kYXRhU291cmNlcy5nZXQodGhpcy5pZCk/LmZvckVhY2goKGRhdHVtLCBkYXR1bUluZGV4KSA9PiB7XG4gICAgICBjb25zdCB4RGF0dW0gPSB4RGF0YVZhbHVlc1tkYXR1bUluZGV4XTtcbiAgICAgIGNvbnN0IHlEYXR1bSA9IHlEYXRhVmFsdWVzW2RhdHVtSW5kZXhdO1xuICAgICAgY29uc3Qgc2l6ZVZhbHVlID0gc2l6ZURhdGFWYWx1ZXM/LltkYXR1bUluZGV4XTtcbiAgICAgIGNvbnN0IHggPSB4U2NhbGUuY29udmVydCh4RGF0dW0pICsgeE9mZnNldDtcbiAgICAgIGNvbnN0IHkgPSB5U2NhbGUuY29udmVydCh5RGF0dW0pICsgeU9mZnNldDtcbiAgICAgIGxldCBzZWxlY3RlZDtcbiAgICAgIGlmICh4RmlsdGVyRGF0YVZhbHVlcyAhPSBudWxsICYmIHlGaWx0ZXJEYXRhVmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgc2VsZWN0ZWQgPSB4RmlsdGVyRGF0YVZhbHVlc1tkYXR1bUluZGV4XSA9PT0geERhdHVtICYmIHlGaWx0ZXJEYXRhVmFsdWVzW2RhdHVtSW5kZXhdID09PSB5RGF0dW07XG4gICAgICAgIGlmIChzaXplRmlsdGVyRGF0YVZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgc2VsZWN0ZWQgJiYgKHNlbGVjdGVkID0gc2l6ZUZpbHRlckRhdGFWYWx1ZXNbZGF0dW1JbmRleF0gPT09IHNpemVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KGxhYmVsLCB7XG4gICAgICAgIHZhbHVlOiBsYWJlbERhdGFWYWx1ZXMgIT0gbnVsbCA/IGxhYmVsRGF0YVZhbHVlc1tkYXR1bUluZGV4XSA6IHlEYXR1bSxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHhLZXksXG4gICAgICAgIHlLZXksXG4gICAgICAgIHNpemVLZXksXG4gICAgICAgIGxhYmVsS2V5LFxuICAgICAgICB4TmFtZSxcbiAgICAgICAgeU5hbWUsXG4gICAgICAgIHNpemVOYW1lLFxuICAgICAgICBsYWJlbE5hbWVcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2l6ZSA9IHRleHRNZWFzdXJlci5tZWFzdXJlVGV4dChTdHJpbmcobGFiZWxUZXh0KSk7XG4gICAgICBjb25zdCBtYXJrZXJTaXplID0gc2l6ZVZhbHVlICE9IG51bGwgPyBzaXplU2NhbGUuY29udmVydChzaXplVmFsdWUpIDogbWFya2VyLnNpemU7XG4gICAgICBjb25zdCBmaWxsID0gY29sb3JEYXRhVmFsdWVzICE9IG51bGwgPyBjb2xvclNjYWxlLmNvbnZlcnQoY29sb3JEYXRhVmFsdWVzW2RhdHVtSW5kZXhdKSA6IHZvaWQgMDtcbiAgICAgIG5vZGVEYXRhLnB1c2goe1xuICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGRhdHVtSW5kZXgsXG4gICAgICAgIHhWYWx1ZTogeERhdHVtLFxuICAgICAgICB5VmFsdWU6IHlEYXR1bSxcbiAgICAgICAgc2l6ZVZhbHVlLFxuICAgICAgICBwb2ludDogeyB4LCB5LCBzaXplOiBtYXJrZXJTaXplIH0sXG4gICAgICAgIG1pZFBvaW50OiB7IHgsIHkgfSxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgbGFiZWw6IHsgdGV4dDogbGFiZWxUZXh0LCAuLi5zaXplIH0sXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBzZWxlY3RlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgIG5vZGVEYXRhLFxuICAgICAgbGFiZWxEYXRhOiBub2RlRGF0YSxcbiAgICAgIHNjYWxlczogdGhpcy5jYWxjdWxhdGVTY2FsaW5nKCksXG4gICAgICB2aXNpYmxlOiB0aGlzLnZpc2libGVcbiAgICB9O1xuICB9XG4gIGlzUGF0aE9yU2VsZWN0aW9uRGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5tYXJrZXIuaXNEaXJ0eSgpO1xuICB9XG4gIGdldExhYmVsRGF0YSgpIHtcbiAgICBpZiAoIXRoaXMuaXNMYWJlbEVuYWJsZWQoKSlcbiAgICAgIHJldHVybiBbXTtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0Tm9kZURhdGE/LmxhYmVsRGF0YSA/PyBbXTtcbiAgfVxuICB1cGRhdGVNYXJrZXJTZWxlY3Rpb24ob3B0cykge1xuICAgIGNvbnN0IHsgbm9kZURhdGEsIG1hcmtlclNlbGVjdGlvbiB9ID0gb3B0cztcbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5pc0RpcnR5KCkpIHtcbiAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucHJvcGVydGllcy5tYXJrZXIuZW5hYmxlZCA/IG5vZGVEYXRhIDogW107XG4gICAgcmV0dXJuIG1hcmtlclNlbGVjdGlvbi51cGRhdGUoXG4gICAgICBkYXRhLFxuICAgICAgdm9pZCAwLFxuICAgICAgKGRhdHVtKSA9PiBjcmVhdGVEYXR1bUlkKFtkYXR1bS54VmFsdWUsIGRhdHVtLnlWYWx1ZSwgZGF0dW0ubGFiZWwudGV4dF0pXG4gICAgKTtcbiAgfVxuICBnZXRNYXJrZXJJdGVtQmFzZVN0eWxlKGhpZ2hsaWdodGVkKSB7XG4gICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbWFya2VyIH0gPSBwcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGhpZ2hsaWdodFN0eWxlID0gaGlnaGxpZ2h0ZWQgPyBwcm9wZXJ0aWVzLmhpZ2hsaWdodFN0eWxlLml0ZW0gOiB2b2lkIDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGw6IGhpZ2hsaWdodFN0eWxlPy5maWxsID8/IG1hcmtlci5maWxsLFxuICAgICAgZmlsbE9wYWNpdHk6IGhpZ2hsaWdodFN0eWxlPy5maWxsT3BhY2l0eSA/PyBtYXJrZXIuZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2U6IGhpZ2hsaWdodFN0eWxlPy5zdHJva2UgPz8gbWFya2VyLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBoaWdobGlnaHRTdHlsZT8uc3Ryb2tlV2lkdGggPz8gbWFya2VyLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogaGlnaGxpZ2h0U3R5bGU/LnN0cm9rZU9wYWNpdHkgPz8gbWFya2VyLnN0cm9rZU9wYWNpdHksXG4gICAgICBsaW5lRGFzaDogaGlnaGxpZ2h0U3R5bGU/LmxpbmVEYXNoID8/IG1hcmtlci5saW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiBoaWdobGlnaHRTdHlsZT8ubGluZURhc2hPZmZzZXQgPz8gbWFya2VyLmxpbmVEYXNoT2Zmc2V0XG4gICAgfTtcbiAgfVxuICBnZXRNYXJrZXJJdGVtU3R5bGVPdmVycmlkZXMoZGF0dW1JZCwgZGF0dW0sIGZvcm1hdCwgaGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25zdCB7IGlkOiBzZXJpZXNJZCwgcHJvcGVydGllcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHNpemVLZXksIGxhYmVsS2V5LCBtYXJrZXIgfSA9IHByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBpdGVtU3R5bGVyIH0gPSBtYXJrZXI7XG4gICAgaWYgKGl0ZW1TdHlsZXIgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICByZXR1cm4gdGhpcy5jYWNoZWREYXR1bUNhbGxiYWNrKGNyZWF0ZURhdHVtSWQoZGF0dW1JZCwgaGlnaGxpZ2h0ZWQgPyBcImhpZ2hsaWdodFwiIDogXCJub2RlXCIpLCAoKSA9PiB7XG4gICAgICByZXR1cm4gaXRlbVN0eWxlcih7XG4gICAgICAgIHNlcmllc0lkLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgc2l6ZUtleSxcbiAgICAgICAgbGFiZWxLZXksXG4gICAgICAgIGhpZ2hsaWdodGVkLFxuICAgICAgICAuLi5mb3JtYXRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZU1hcmtlck5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgaXNIaWdobGlnaHQ6IGhpZ2hsaWdodGVkIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgc2l6ZUtleSwgbGFiZWxLZXksIG1hcmtlciB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgc2l6ZSwgc2hhcGUsIGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2U6IHN0cm9rZTIsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5LCBsaW5lRGFzaCwgbGluZURhc2hPZmZzZXQgfSA9IG1lcmdlRGVmYXVsdHMoaGlnaGxpZ2h0ZWQgJiYgdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodFN0eWxlLml0ZW0sIG1hcmtlci5nZXRTdHlsZSgpKTtcbiAgICBjb25zdCBiYXNlU3R5bGUgPSB7XG4gICAgICBzaXplLFxuICAgICAgc2hhcGUsXG4gICAgICBmaWxsLFxuICAgICAgZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2U6IHN0cm9rZTIsXG4gICAgICBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICBsaW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0XG4gICAgfTtcbiAgICB0aGlzLnNpemVTY2FsZS5yYW5nZSA9IFttYXJrZXIuc2l6ZSwgbWFya2VyLm1heFNpemVdO1xuICAgIG1hcmtlclNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVNYXJrZXJTdHlsZShub2RlLCBtYXJrZXIsIHsgZGF0dW0sIGhpZ2hsaWdodGVkLCB4S2V5LCB5S2V5LCBzaXplS2V5LCBsYWJlbEtleSB9LCBiYXNlU3R5bGUsIHtcbiAgICAgICAgc2VsZWN0ZWQ6IGRhdHVtLnNlbGVjdGVkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoIWhpZ2hsaWdodGVkKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMubWFya2VyLm1hcmtDbGVhbigpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQbGFjZWRMYWJlbERhdGEobGFiZWxEYXRhKSB7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbi51cGRhdGUoXG4gICAgICBsYWJlbERhdGEubWFwKCh2KSA9PiAoe1xuICAgICAgICAuLi52LmRhdHVtLFxuICAgICAgICBwb2ludDoge1xuICAgICAgICAgIHg6IHYueCxcbiAgICAgICAgICB5OiB2LnksXG4gICAgICAgICAgc2l6ZTogdi5kYXR1bS5wb2ludC5zaXplXG4gICAgICAgIH1cbiAgICAgIH0pKSxcbiAgICAgICh0ZXh0MikgPT4ge1xuICAgICAgICB0ZXh0Mi5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy51cGRhdGVMYWJlbE5vZGVzKHsgbGFiZWxTZWxlY3Rpb246IHRoaXMubGFiZWxTZWxlY3Rpb24gfSk7XG4gIH1cbiAgdXBkYXRlTGFiZWxOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBsYWJlbCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIG9wdHMubGFiZWxTZWxlY3Rpb24uZWFjaCgodGV4dDIsIGRhdHVtKSA9PiB7XG4gICAgICB0ZXh0Mi50ZXh0ID0gZGF0dW0ubGFiZWwudGV4dDtcbiAgICAgIHRleHQyLmZpbGwgPSBsYWJlbC5jb2xvcjtcbiAgICAgIHRleHQyLnggPSBkYXR1bS5wb2ludD8ueCA/PyAwO1xuICAgICAgdGV4dDIueSA9IGRhdHVtLnBvaW50Py55ID8/IDA7XG4gICAgICB0ZXh0Mi5mb250U3R5bGUgPSBsYWJlbC5mb250U3R5bGU7XG4gICAgICB0ZXh0Mi5mb250V2VpZ2h0ID0gbGFiZWwuZm9udFdlaWdodDtcbiAgICAgIHRleHQyLmZvbnRTaXplID0gbGFiZWwuZm9udFNpemU7XG4gICAgICB0ZXh0Mi5mb250RmFtaWx5ID0gbGFiZWwuZm9udEZhbWlseTtcbiAgICAgIHRleHQyLnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgdGV4dDIudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcbiAgICB9KTtcbiAgfVxuICBnZXRUb29sdGlwQ29udGVudChub2RlRGF0dW0pIHtcbiAgICBjb25zdCB7IGlkOiBzZXJpZXNJZCwgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhLCBheGVzLCBwcm9wZXJ0aWVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgeEtleSwgeE5hbWUsIHlLZXksIHlOYW1lLCBzaXplS2V5LCBzaXplTmFtZSwgbGFiZWxLZXksIGxhYmVsTmFtZSwgdGl0bGUsIHRvb2x0aXAgfSA9IHByb3BlcnRpZXM7XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIWRhdGFNb2RlbCB8fCAhcHJvY2Vzc2VkRGF0YSB8fCAheEF4aXMgfHwgIXlBeGlzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgZGF0dW1JbmRleCB9ID0gbm9kZURhdHVtO1xuICAgIGNvbnN0IGRhdHVtID0gcHJvY2Vzc2VkRGF0YS5kYXRhU291cmNlcy5nZXQodGhpcy5pZCk/LltkYXR1bUluZGV4XTtcbiAgICBjb25zdCB4VmFsdWUgPSBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYHhWYWx1ZWAsIHByb2Nlc3NlZERhdGEpW2RhdHVtSW5kZXhdO1xuICAgIGNvbnN0IHlWYWx1ZSA9IGRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBgeVZhbHVlYCwgcHJvY2Vzc2VkRGF0YSlbZGF0dW1JbmRleF07XG4gICAgaWYgKHhWYWx1ZSA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRhdGEgPSBbXG4gICAgICB7IGxhYmVsOiB4TmFtZSwgZmFsbGJhY2tMYWJlbDogeEtleSwgdmFsdWU6IHhBeGlzLmZvcm1hdERhdHVtKHhWYWx1ZSkgfSxcbiAgICAgIHsgbGFiZWw6IHlOYW1lLCBmYWxsYmFja0xhYmVsOiB5S2V5LCB2YWx1ZTogeUF4aXMuZm9ybWF0RGF0dW0oeVZhbHVlKSB9XG4gICAgXTtcbiAgICBpZiAoc2l6ZUtleSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBzaXplVmFsdWUgPSBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYHNpemVWYWx1ZWAsIHByb2Nlc3NlZERhdGEpW2RhdHVtSW5kZXhdO1xuICAgICAgZGF0YS5wdXNoKHsgbGFiZWw6IHNpemVOYW1lLCBmYWxsYmFja0xhYmVsOiBzaXplS2V5LCB2YWx1ZTogU3RyaW5nKHNpemVWYWx1ZSkgfSk7XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0TWFya2VySXRlbUJhc2VTdHlsZShmYWxzZSk7XG4gICAgT2JqZWN0LmFzc2lnbihmb3JtYXQsIHRoaXMuZ2V0TWFya2VySXRlbVN0eWxlT3ZlcnJpZGVzKFN0cmluZyhkYXR1bUluZGV4KSwgZGF0dW0sIGZvcm1hdCwgZmFsc2UpKTtcbiAgICByZXR1cm4gdG9vbHRpcC5mb3JtYXRUb29sdGlwKFxuICAgICAge1xuICAgICAgICB0aXRsZSxcbiAgICAgICAgc3ltYm9sOiB0aGlzLmxlZ2VuZEl0ZW1TeW1ib2woKSxcbiAgICAgICAgZGF0YVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2VyaWVzSWQsXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB0aXRsZTogeUtleSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlLZXksXG4gICAgICAgIHlOYW1lLFxuICAgICAgICBzaXplS2V5LFxuICAgICAgICBzaXplTmFtZSxcbiAgICAgICAgbGFiZWxLZXksXG4gICAgICAgIGxhYmVsTmFtZSxcbiAgICAgICAgLi4uZm9ybWF0LFxuICAgICAgICAuLi50aGlzLmdldE1vZHVsZVRvb2x0aXBQYXJhbXMoKVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgbGVnZW5kSXRlbVN5bWJvbCgpIHtcbiAgICBjb25zdCB7IG1hcmtlciB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgc2hhcGUsIGZpbGwsIHN0cm9rZTogc3Ryb2tlMiwgZmlsbE9wYWNpdHksIHN0cm9rZU9wYWNpdHksIHN0cm9rZVdpZHRoLCBsaW5lRGFzaCwgbGluZURhc2hPZmZzZXQgfSA9IG1hcmtlcjtcbiAgICByZXR1cm4ge1xuICAgICAgbWFya2VyOiB7XG4gICAgICAgIHNoYXBlLFxuICAgICAgICBmaWxsOiBmaWxsID8/IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuICAgICAgICBzdHJva2U6IHN0cm9rZTIgPz8gXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgbGluZURhc2gsXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKCkge1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBpZDogc2VyaWVzSWQsXG4gICAgICBjdHg6IHsgbGVnZW5kTWFuYWdlciB9LFxuICAgICAgdmlzaWJsZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgeUtleTogaXRlbUlkLCB5TmFtZSwgdGl0bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBsZWdlbmRUeXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgICAgaXRlbUlkLFxuICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSAmJiBsZWdlbmRNYW5hZ2VyLmdldEl0ZW1FbmFibGVkKHsgc2VyaWVzSWQsIGl0ZW1JZCB9KSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiB0aXRsZSA/PyB5TmFtZSA/PyBpdGVtSWRcbiAgICAgICAgfSxcbiAgICAgICAgc3ltYm9sOiB0aGlzLmxlZ2VuZEl0ZW1TeW1ib2woKVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoeyBtYXJrZXJTZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uIH0pIHtcbiAgICBtYXJrZXJTY2FsZUluQW5pbWF0aW9uKHRoaXMsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIG1hcmtlclNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb24pO1xuICB9XG4gIGlzTGFiZWxFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubGFiZWwuZW5hYmxlZDtcbiAgfVxuICBub2RlRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IEdyb3VwKCk7XG4gIH1cbiAgZ2V0Rm9ybWF0dGVkTWFya2VyU3R5bGUoZGF0dW0pIHtcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHNpemVLZXksIGxhYmVsS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWFya2VyU3R5bGUodGhpcy5wcm9wZXJ0aWVzLm1hcmtlciwge1xuICAgICAgZGF0dW0sXG4gICAgICB4S2V5LFxuICAgICAgeUtleSxcbiAgICAgIHNpemVLZXksXG4gICAgICBsYWJlbEtleSxcbiAgICAgIGhpZ2hsaWdodGVkOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGNvbXB1dGVGb2N1c0JvdW5kcyhvcHRzKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVNYXJrZXJGb2N1c0JvdW5kcyh0aGlzLCBvcHRzKTtcbiAgfVxufTtcbkJ1YmJsZVNlcmllcy5jbGFzc05hbWUgPSBcIkJ1YmJsZVNlcmllc1wiO1xuQnViYmxlU2VyaWVzLnR5cGUgPSBcImJ1YmJsZVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2J1YmJsZVNlcmllc01vZHVsZS50c1xudmFyIEJ1YmJsZVNlcmllc01vZHVsZSA9IHtcbiAgdHlwZTogXCJzZXJpZXNcIixcbiAgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLFxuICBpZGVudGlmaWVyOiBcImJ1YmJsZVwiLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgQnViYmxlU2VyaWVzKGN0eCksXG4gIHRvb2x0aXBEZWZhdWx0czogeyByYW5nZTogXCJuZWFyZXN0XCIgfSxcbiAgZGVmYXVsdEF4ZXM6IFtcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiIC8qIEJPVFRPTSAqL1xuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCIgLyogTEVGVCAqL1xuICAgIH1cbiAgXSxcbiAgdGhlbWVUZW1wbGF0ZToge1xuICAgIHNlcmllczoge1xuICAgICAgc2hhcGU6IFwiY2lyY2xlXCIsXG4gICAgICBzaXplOiA3LFxuICAgICAgbWF4U2l6ZTogMzAsXG4gICAgICBmaWxsT3BhY2l0eTogMC44LFxuICAgICAgdG9vbHRpcDogeyBwb3NpdGlvbjogeyB0eXBlOiBcIm5vZGVcIiB9IH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgZm9udFNpemU6IHsgJHJlZjogXCJmb250U2l6ZVwiIH0sXG4gICAgICAgIGZvbnRGYW1pbHk6IHsgJHJlZjogXCJmb250RmFtaWx5XCIgfSxcbiAgICAgICAgZm9udFdlaWdodDogeyAkcmVmOiBcImZvbnRXZWlnaHRcIiB9LFxuICAgICAgICBjb2xvcjogeyAkcmVmOiBcInRleHRDb2xvclwiIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBhbGV0dGVGYWN0b3J5OiBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9oaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnRzXG52YXIgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmxpbmVEYXNoID0gWzBdO1xuICAgIHRoaXMubGluZURhc2hPZmZzZXQgPSAwO1xuICAgIHRoaXMuY29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmFyZWFQbG90ID0gZmFsc2U7XG4gICAgdGhpcy5hZ2dyZWdhdGlvbiA9IFwic3VtXCI7XG4gICAgdGhpcy5zaGFkb3cgPSBuZXcgRHJvcFNoYWRvdygpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgTGFiZWwoKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMSU5FX0RBU0gpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImFyZWFQbG90XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImJpbnNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShVTklPTihbXCJjb3VudFwiLCBcInN1bVwiLCBcIm1lYW5cIl0sIFwiYSBoaXN0b2dyYW0gYWdncmVnYXRpb25cIikpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhZ2dyZWdhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYmluQ291bnRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaGFkb3dcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRvb2x0aXBcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vaGlzdG9ncmFtU2VyaWVzLnRzXG52YXIgZGVmYXVsdEJpbkNvdW50ID0gMTA7XG52YXIgSGlzdG9ncmFtU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBkaXJlY3Rpb25LZXlzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUyxcbiAgICAgIGRpcmVjdGlvbk5hbWVzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fTkFNRVMsXG4gICAgICBwaWNrTW9kZXM6IFsxIC8qIE5FQVJFU1RfTk9ERSAqLywgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL10sXG4gICAgICBkYXR1bVNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uOiBmYWxzZSxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7XG4gICAgICAgIGRhdHVtOiByZXNldEJhclNlbGVjdGlvbnNGbixcbiAgICAgICAgbGFiZWw6IHJlc2V0TGFiZWxGblxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5jYWxjdWxhdGVkQmlucyA9IFtdO1xuICB9XG4gIC8vIER1cmluZyBwcm9jZXNzRGF0YSBwaGFzZSwgdXNlZCB0byB1bmlmeSBkaWZmZXJlbnQgd2F5cyBvZiB0aGUgdXNlciBzcGVjaWZ5aW5nXG4gIC8vIHRoZSBiaW5zLiBSZXR1cm5zIGJpbnMgaW4gZm9ybWF0W1ttaW4xLCBtYXgxXSwgW21pbjIsIG1heDJdLCAuLi4gXS5cbiAgZGVyaXZlQmlucyh4RG9tYWluKSB7XG4gICAgY29uc3QgYmluU3RhcnRzID0gY3JlYXRlVGlja3MoeERvbWFpblswXSwgeERvbWFpblsxXSwgZGVmYXVsdEJpbkNvdW50KTtcbiAgICBjb25zdCBiaW5TaXplID0gdGlja1N0ZXAoeERvbWFpblswXSwgeERvbWFpblsxXSwgZGVmYXVsdEJpbkNvdW50KTtcbiAgICBjb25zdCBbZmlyc3RCaW5FbmRdID0gYmluU3RhcnRzO1xuICAgIGNvbnN0IGV4cGFuZFN0YXJ0VG9CaW4gPSAobikgPT4gW24sIG4gKyBiaW5TaXplXTtcbiAgICByZXR1cm4gW1tmaXJzdEJpbkVuZCAtIGJpblNpemUsIGZpcnN0QmluRW5kXSwgLi4uYmluU3RhcnRzLm1hcChleHBhbmRTdGFydFRvQmluKV07XG4gIH1cbiAgY2FsY3VsYXRlTmljZUJpbnMoZG9tYWluLCBiaW5Db3VudCkge1xuICAgIGNvbnN0IHN0YXJ0R3Vlc3MgPSBNYXRoLmZsb29yKGRvbWFpblswXSk7XG4gICAgY29uc3Qgc3RvcCA9IGRvbWFpblsxXTtcbiAgICBjb25zdCBzZWdtZW50cyA9IGJpbkNvdW50IHx8IDE7XG4gICAgY29uc3QgeyBzdGFydDogc3RhcnQyLCBiaW5TaXplIH0gPSB0aGlzLmNhbGN1bGF0ZU5pY2VTdGFydChzdGFydEd1ZXNzLCBzdG9wLCBzZWdtZW50cyk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QmlucyhzdGFydDIsIHN0b3AsIGJpblNpemUsIHNlZ21lbnRzKTtcbiAgfVxuICBnZXRCaW5zKHN0YXJ0Miwgc3RvcCwgc3RlcCwgY291bnQpIHtcbiAgICBjb25zdCBiaW5zID0gW107XG4gICAgY29uc3QgcHJlY2lzaW9uID0gdGhpcy5jYWxjdWxhdGVQcmVjaXNpb24oc3RlcCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhID0gTWF0aC5yb3VuZCgoc3RhcnQyICsgaSAqIHN0ZXApICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgICAgIGxldCBiID0gTWF0aC5yb3VuZCgoc3RhcnQyICsgKGkgKyAxKSAqIHN0ZXApICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgICAgIGlmIChpID09PSBjb3VudCAtIDEpIHtcbiAgICAgICAgYiA9IE1hdGgubWF4KGIsIHN0b3ApO1xuICAgICAgfVxuICAgICAgYmluc1tpXSA9IFthLCBiXTtcbiAgICB9XG4gICAgcmV0dXJuIGJpbnM7XG4gIH1cbiAgY2FsY3VsYXRlUHJlY2lzaW9uKHN0ZXApIHtcbiAgICBsZXQgcHJlY2lzaW9uID0gMTA7XG4gICAgaWYgKGlzRmluaXRlKHN0ZXApICYmIHN0ZXAgPiAwKSB7XG4gICAgICB3aGlsZSAoc3RlcCA8IDEpIHtcbiAgICAgICAgcHJlY2lzaW9uICo9IDEwO1xuICAgICAgICBzdGVwICo9IDEwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJlY2lzaW9uO1xuICB9XG4gIGNhbGN1bGF0ZU5pY2VTdGFydChhLCBiLCBzZWdtZW50cykge1xuICAgIGNvbnN0IGJpblNpemUgPSBNYXRoLmFicyhiIC0gYSkgLyBzZWdtZW50cztcbiAgICBjb25zdCBvcmRlciA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChiaW5TaXplKSk7XG4gICAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5wb3coMTAsIG9yZGVyKTtcbiAgICBjb25zdCBzdGFydDIgPSBNYXRoLmZsb29yKGEgLyBtYWduaXR1ZGUpICogbWFnbml0dWRlO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogc3RhcnQyLFxuICAgICAgYmluU2l6ZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcbiAgICBpZiAoIXRoaXMudmlzaWJsZSkge1xuICAgICAgdGhpcy5wcm9jZXNzZWREYXRhID0gdm9pZCAwO1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKTtcbiAgICB9XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBhcmVhUGxvdCwgYWdncmVnYXRpb24gfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB4U2NhbGUgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXT8uc2NhbGU7XG4gICAgY29uc3QgeyB4U2NhbGVUeXBlLCB5U2NhbGVUeXBlIH0gPSB0aGlzLmdldFNjYWxlSW5mb3JtYXRpb24oeyB5U2NhbGUsIHhTY2FsZSB9KTtcbiAgICBjb25zdCBwcm9wcyA9IFtrZXlQcm9wZXJ0eSh4S2V5LCB4U2NhbGVUeXBlKSwgU09SVF9ET01BSU5fR1JPVVBTXTtcbiAgICBpZiAoeUtleSkge1xuICAgICAgbGV0IGFnZ1Byb3AgPSBncm91cENvdW50KFwiZ3JvdXBBZ2dcIik7XG4gICAgICBpZiAoYWdncmVnYXRpb24gPT09IFwiY291bnRcIikge1xuICAgICAgfSBlbHNlIGlmIChhZ2dyZWdhdGlvbiA9PT0gXCJzdW1cIikge1xuICAgICAgICBhZ2dQcm9wID0gZ3JvdXBTdW0oXCJncm91cEFnZ1wiKTtcbiAgICAgIH0gZWxzZSBpZiAoYWdncmVnYXRpb24gPT09IFwibWVhblwiKSB7XG4gICAgICAgIGFnZ1Byb3AgPSBncm91cEF2ZXJhZ2UoXCJncm91cEFnZ1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmVhUGxvdCkge1xuICAgICAgICBhZ2dQcm9wID0gYXJlYShcImdyb3VwQWdnXCIsIGFnZ1Byb3ApO1xuICAgICAgfVxuICAgICAgcHJvcHMucHVzaCh2YWx1ZVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHsgaW52YWxpZFZhbHVlOiB2b2lkIDAgfSksIGFnZ1Byb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wcy5wdXNoKHJvd0NvdW50UHJvcGVydHkoXCJjb3VudFwiKSk7XG4gICAgICBsZXQgYWdnUHJvcCA9IGdyb3VwQ291bnQoXCJncm91cEFnZ1wiKTtcbiAgICAgIGlmIChhcmVhUGxvdCkge1xuICAgICAgICBhZ2dQcm9wID0gYXJlYShcImdyb3VwQWdnXCIsIGFnZ1Byb3ApO1xuICAgICAgfVxuICAgICAgcHJvcHMucHVzaChhZ2dQcm9wKTtcbiAgICB9XG4gICAgY29uc3QgZ3JvdXBCeUZuID0gKGRhdGFTZXQpID0+IHtcbiAgICAgIGNvbnN0IHhFeHRlbnQgPSBmaXhOdW1lcmljRXh0ZW50KGRhdGFTZXQuZG9tYWluLmtleXNbMF0pO1xuICAgICAgaWYgKHhFeHRlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRhdGFTZXQuZG9tYWluLmdyb3VwcyA9IFtdO1xuICAgICAgICByZXR1cm4gKCkgPT4gW107XG4gICAgICB9XG4gICAgICBjb25zdCBiaW5zID0gaXNOdW1iZXIodGhpcy5wcm9wZXJ0aWVzLmJpbkNvdW50KSA/IHRoaXMuY2FsY3VsYXRlTmljZUJpbnMoeEV4dGVudCwgdGhpcy5wcm9wZXJ0aWVzLmJpbkNvdW50KSA6IHRoaXMucHJvcGVydGllcy5iaW5zID8/IHRoaXMuZGVyaXZlQmlucyh4RXh0ZW50KTtcbiAgICAgIGNvbnN0IGJpbkNvdW50ID0gYmlucy5sZW5ndGg7XG4gICAgICB0aGlzLmNhbGN1bGF0ZWRCaW5zID0gWy4uLmJpbnNdO1xuICAgICAgcmV0dXJuIChrZXlzKSA9PiB7XG4gICAgICAgIGxldCB4VmFsdWUgPSBrZXlzWzBdO1xuICAgICAgICBpZiAoaXNEYXRlKHhWYWx1ZSkpIHtcbiAgICAgICAgICB4VmFsdWUgPSB4VmFsdWUuZ2V0VGltZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOdW1iZXIoeFZhbHVlKSlcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluQ291bnQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG5leHRCaW4gPSBiaW5zW2ldO1xuICAgICAgICAgIGlmICh4VmFsdWUgPj0gbmV4dEJpblswXSAmJiB4VmFsdWUgPCBuZXh0QmluWzFdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dEJpbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IGJpbkNvdW50IC0gMSAmJiB4VmFsdWUgPD0gbmV4dEJpblsxXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRCaW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBpZiAoIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCkgJiYgdGhpcy5wcm9jZXNzZWREYXRhKSB7XG4gICAgICBwcm9wcy5wdXNoKGRpZmYodGhpcy5pZCwgdGhpcy5wcm9jZXNzZWREYXRhLCBmYWxzZSkpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIHRoaXMuZGF0YSwge1xuICAgICAgcHJvcHMsXG4gICAgICBncm91cEJ5Rm5cbiAgICB9KTtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIHhDb29yZGluYXRlUmFuZ2UoKSB7XG4gICAgcmV0dXJuIFtOYU4sIE5hTl07XG4gIH1cbiAgeUNvb3JkaW5hdGVSYW5nZSgpIHtcbiAgICByZXR1cm4gW05hTiwgTmFOXTtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeyBwcm9jZXNzZWREYXRhLCBkYXRhTW9kZWwgfSA9IHRoaXM7XG4gICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICFkYXRhTW9kZWwgfHwgIXRoaXMuY2FsY3VsYXRlZEJpbnMubGVuZ3RoKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHlEb21haW4gPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGBncm91cEFnZ2AsIFwiYWdncmVnYXRlXCIsIHByb2Nlc3NlZERhdGEpO1xuICAgIGNvbnN0IHhEb21haW5NaW4gPSB0aGlzLmNhbGN1bGF0ZWRCaW5zPy5bMF1bMF07XG4gICAgY29uc3QgeERvbWFpbk1heCA9IHRoaXMuY2FsY3VsYXRlZEJpbnM/LlsodGhpcy5jYWxjdWxhdGVkQmlucz8ubGVuZ3RoID8/IDApIC0gMV1bMV07XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLykge1xuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoW3hEb21haW5NaW4sIHhEb21haW5NYXhdKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoeURvbWFpbik7XG4gIH1cbiAgZ2V0U2VyaWVzUmFuZ2UoX2RpcmVjdGlvbiwgW3IwLCByMV0pIHtcbiAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gdGhpcztcbiAgICBpZiAoIWRhdGFNb2RlbCB8fCBwcm9jZXNzZWREYXRhPy50eXBlICE9PSBcImdyb3VwZWRcIilcbiAgICAgIHJldHVybiBbTmFOLCBOYU5dO1xuICAgIGNvbnN0IHhTY2FsZSA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXS5zY2FsZTtcbiAgICBjb25zdCB5TWluID0gMDtcbiAgICBsZXQgeU1heCA9IC1JbmZpbml0eTtcbiAgICBwcm9jZXNzZWREYXRhLmdyb3Vwcy5mb3JFYWNoKCh7IGtleXMsIGFnZ3JlZ2F0aW9uIH0pID0+IHtcbiAgICAgIGNvbnN0IFtbbmVnYXRpdmVBZ2csIHBvc2l0aXZlQWdnXSA9IFswLCAwXV0gPSBhZ2dyZWdhdGlvbjtcbiAgICAgIGNvbnN0IFt4RG9tYWluTWluLCB4RG9tYWluTWF4XSA9IGtleXM7XG4gICAgICBjb25zdCBbeDAsIHgxXSA9IGZpbmRNaW5NYXgoW3hTY2FsZS5jb252ZXJ0KHhEb21haW5NaW4pLCB4U2NhbGUuY29udmVydCh4RG9tYWluTWF4KV0pO1xuICAgICAgaWYgKHgxID49IHIwICYmIHgwIDw9IHIxKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gbmVnYXRpdmVBZ2cgKyBwb3NpdGl2ZUFnZztcbiAgICAgICAgeU1heCA9IE1hdGgubWF4KHlNYXgsIHRvdGFsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoeU1pbiA+IHlNYXgpXG4gICAgICByZXR1cm4gW05hTiwgTmFOXTtcbiAgICByZXR1cm4gW3lNaW4sIHlNYXhdO1xuICB9XG4gIGNyZWF0ZU5vZGVEYXRhKCkge1xuICAgIGNvbnN0IHsgaWQ6IHNlcmllc0lkLCBheGVzLCBwcm9jZXNzZWREYXRhLCBkYXRhTW9kZWwgfSA9IHRoaXM7XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIXhBeGlzIHx8ICF5QXhpcyB8fCAhZGF0YU1vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgc2NhbGU6IHhTY2FsZSB9ID0geEF4aXM7XG4gICAgY29uc3QgeyBzY2FsZTogeVNjYWxlIH0gPSB5QXhpcztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHhOYW1lLCB5TmFtZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGxhYmVsRm9ybWF0dGVyID0gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLmZvcm1hdHRlciA/PyAoKHBhcmFtcykgPT4gU3RyaW5nKHBhcmFtcy52YWx1ZSkpO1xuICAgIGNvbnN0IG5vZGVEYXRhID0gW107XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGl0ZW1JZDogdGhpcy5wcm9wZXJ0aWVzLnlLZXkgPz8gdGhpcy5pZCxcbiAgICAgIG5vZGVEYXRhLFxuICAgICAgbGFiZWxEYXRhOiBub2RlRGF0YSxcbiAgICAgIHNjYWxlczogdGhpcy5jYWxjdWxhdGVTY2FsaW5nKCksXG4gICAgICBhbmltYXRpb25WYWxpZDogdHJ1ZSxcbiAgICAgIHZpc2libGU6IHRoaXMudmlzaWJsZVxuICAgIH07XG4gICAgaWYgKCF0aGlzLnZpc2libGUgfHwgcHJvY2Vzc2VkRGF0YSA9PSBudWxsIHx8IHByb2Nlc3NlZERhdGEudHlwZSAhPT0gXCJncm91cGVkXCIpIHtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICBwcm9jZXNzZWREYXRhLmdyb3Vwcy5mb3JFYWNoKChncm91cCwgZ3JvdXBJbmRleCkgPT4ge1xuICAgICAgY29uc3QgeyBrZXlzLCBkYXR1bUluZGljZXMsIGFnZ3JlZ2F0aW9uIH0gPSBncm91cDtcbiAgICAgIGNvbnN0IFtbbmVnYXRpdmVBZ2csIHBvc2l0aXZlQWdnXSA9IFswLCAwXV0gPSBhZ2dyZWdhdGlvbjtcbiAgICAgIGNvbnN0IGZyZXF1ZW5jeSA9IGRhdHVtSW5kaWNlcy5sZW5ndGg7XG4gICAgICBjb25zdCBkb21haW4gPSBrZXlzO1xuICAgICAgY29uc3QgW3hEb21haW5NaW4sIHhEb21haW5NYXhdID0gZG9tYWluO1xuICAgICAgY29uc3QgZGF0dW0gPSBbLi4uZGF0YU1vZGVsLmZvckVhY2hEYXR1bSh0aGlzLCBwcm9jZXNzZWREYXRhLCBncm91cCldO1xuICAgICAgY29uc3QgeE1pblB4ID0geFNjYWxlLmNvbnZlcnQoeERvbWFpbk1pbik7XG4gICAgICBjb25zdCB4TWF4UHggPSB4U2NhbGUuY29udmVydCh4RG9tYWluTWF4KTtcbiAgICAgIGNvbnN0IHRvdGFsID0gbmVnYXRpdmVBZ2cgKyBwb3NpdGl2ZUFnZztcbiAgICAgIGNvbnN0IHlaZXJvUHggPSB5U2NhbGUuY29udmVydCgwKTtcbiAgICAgIGNvbnN0IHlNYXhQeCA9IHlTY2FsZS5jb252ZXJ0KHRvdGFsKTtcbiAgICAgIGNvbnN0IHcgPSBNYXRoLmFicyh4TWF4UHggLSB4TWluUHgpO1xuICAgICAgY29uc3QgaCA9IE1hdGguYWJzKHlNYXhQeCAtIHlaZXJvUHgpO1xuICAgICAgY29uc3QgeCA9IE1hdGgubWluKHhNaW5QeCwgeE1heFB4KTtcbiAgICAgIGNvbnN0IHkgPSBNYXRoLm1pbih5WmVyb1B4LCB5TWF4UHgpO1xuICAgICAgbGV0IHNlbGVjdGlvbkRhdHVtTGFiZWwgPSB2b2lkIDA7XG4gICAgICBpZiAodG90YWwgIT09IDApIHtcbiAgICAgICAgc2VsZWN0aW9uRGF0dW1MYWJlbCA9IHtcbiAgICAgICAgICB4OiB4ICsgdyAvIDIsXG4gICAgICAgICAgeTogeSArIGggLyAyLFxuICAgICAgICAgIHRleHQ6IHRoaXMuY2FjaGVkRGF0dW1DYWxsYmFjayhcbiAgICAgICAgICAgIGNyZWF0ZURhdHVtSWQoZ3JvdXBJbmRleCwgXCJsYWJlbFwiKSxcbiAgICAgICAgICAgICgpID0+IGxhYmVsRm9ybWF0dGVyKHtcbiAgICAgICAgICAgICAgdmFsdWU6IHRvdGFsLFxuICAgICAgICAgICAgICBkYXR1bSxcbiAgICAgICAgICAgICAgc2VyaWVzSWQsXG4gICAgICAgICAgICAgIHhLZXksXG4gICAgICAgICAgICAgIHlLZXksXG4gICAgICAgICAgICAgIHhOYW1lLFxuICAgICAgICAgICAgICB5TmFtZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApID8/IFN0cmluZyh0b3RhbClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vZGVNaWRQb2ludCA9IHtcbiAgICAgICAgeDogeCArIHcgLyAyLFxuICAgICAgICB5OiB5ICsgaCAvIDJcbiAgICAgIH07XG4gICAgICBjb25zdCB5QXhpc1JldmVyc2VkID0geUF4aXMuaXNSZXZlcnNlZCgpO1xuICAgICAgbm9kZURhdGEucHVzaCh7XG4gICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgZGF0dW1JbmRleDogZ3JvdXBJbmRleCxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIC8vIHJlcXVpcmVkIGJ5IFNlcmllc05vZGVEYXR1bSwgYnV0IG1pZ2h0IG5vdCBtYWtlIHNlbnNlIGhlcmVcbiAgICAgICAgLy8gc2luY2UgZWFjaCBzZWxlY3Rpb24gaXMgYW4gYWdncmVnYXRpb24gb2YgbXVsdGlwbGUgZGF0YS5cbiAgICAgICAgYWdncmVnYXRlZFZhbHVlOiB0b3RhbCxcbiAgICAgICAgZnJlcXVlbmN5LFxuICAgICAgICBkb21haW4sXG4gICAgICAgIHlLZXksXG4gICAgICAgIHhLZXksXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHhWYWx1ZTogeE1pblB4LFxuICAgICAgICB5VmFsdWU6IHlNYXhQeCxcbiAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgbWlkUG9pbnQ6IG5vZGVNaWRQb2ludCxcbiAgICAgICAgdG9wTGVmdENvcm5lclJhZGl1czogIXlBeGlzUmV2ZXJzZWQsXG4gICAgICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzOiAheUF4aXNSZXZlcnNlZCxcbiAgICAgICAgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXM6IHlBeGlzUmV2ZXJzZWQsXG4gICAgICAgIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXM6IHlBeGlzUmV2ZXJzZWQsXG4gICAgICAgIGxhYmVsOiBzZWxlY3Rpb25EYXR1bUxhYmVsLFxuICAgICAgICBjcmlzcDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgbm9kZURhdGEuc29ydCgoYSwgYikgPT4gYS54IC0gYi54KTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuICBub2RlRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IFJlY3QoKTtcbiAgfVxuICB1cGRhdGVEYXR1bVNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgeyBub2RlRGF0YSwgZGF0dW1TZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgcmV0dXJuIGRhdHVtU2VsZWN0aW9uLnVwZGF0ZShub2RlRGF0YSwgdm9pZCAwLCAoZGF0dW0pID0+IGRhdHVtLmRvbWFpbi5qb2luKFwiX1wiKSk7XG4gIH1cbiAgZ2V0SXRlbUJhc2VTdHlsZShoaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gdGhpcztcbiAgICBjb25zdCBoaWdobGlnaHRTdHlsZSA9IGhpZ2hsaWdodGVkID8gcHJvcGVydGllcy5oaWdobGlnaHRTdHlsZS5pdGVtIDogdm9pZCAwO1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsOiBoaWdobGlnaHRTdHlsZT8uZmlsbCA/PyBwcm9wZXJ0aWVzLmZpbGwsXG4gICAgICBmaWxsT3BhY2l0eTogaGlnaGxpZ2h0U3R5bGU/LmZpbGxPcGFjaXR5ID8/IHByb3BlcnRpZXMuZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2U6IGhpZ2hsaWdodFN0eWxlPy5zdHJva2UgPz8gcHJvcGVydGllcy5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogaGlnaGxpZ2h0U3R5bGU/LnN0cm9rZVdpZHRoID8/IHRoaXMuZ2V0U3Ryb2tlV2lkdGgocHJvcGVydGllcy5zdHJva2VXaWR0aCksXG4gICAgICBzdHJva2VPcGFjaXR5OiBoaWdobGlnaHRTdHlsZT8uc3Ryb2tlT3BhY2l0eSA/PyBwcm9wZXJ0aWVzLnN0cm9rZU9wYWNpdHksXG4gICAgICBsaW5lRGFzaDogaGlnaGxpZ2h0U3R5bGU/LmxpbmVEYXNoID8/IHByb3BlcnRpZXMubGluZURhc2gsXG4gICAgICBsaW5lRGFzaE9mZnNldDogaGlnaGxpZ2h0U3R5bGU/LmxpbmVEYXNoT2Zmc2V0ID8/IHByb3BlcnRpZXMubGluZURhc2hPZmZzZXQsXG4gICAgICBjb3JuZXJSYWRpdXM6IHByb3BlcnRpZXMuY29ybmVyUmFkaXVzXG4gICAgfTtcbiAgfVxuICB1cGRhdGVEYXR1bU5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IGlzSGlnaGxpZ2h0OiBpc0RhdHVtSGlnaGxpZ2h0ZWQgfSA9IG9wdHM7XG4gICAgY29uc3QgeyBzaGFkb3cgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuZ2V0SXRlbUJhc2VTdHlsZShpc0RhdHVtSGlnaGxpZ2h0ZWQpO1xuICAgIG9wdHMuZGF0dW1TZWxlY3Rpb24uZWFjaCgocmVjdCwgZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IHsgY29ybmVyUmFkaXVzIH0gPSBzdHlsZTtcbiAgICAgIGNvbnN0IHsgdG9wTGVmdENvcm5lclJhZGl1cywgdG9wUmlnaHRDb3JuZXJSYWRpdXMsIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzLCBib3R0b21MZWZ0Q29ybmVyUmFkaXVzIH0gPSBkYXR1bTtcbiAgICAgIGFwcGx5U2hhcGVTdHlsZShyZWN0LCBzdHlsZSk7XG4gICAgICByZWN0LnRvcExlZnRDb3JuZXJSYWRpdXMgPSB0b3BMZWZ0Q29ybmVyUmFkaXVzID8gY29ybmVyUmFkaXVzIDogMDtcbiAgICAgIHJlY3QudG9wUmlnaHRDb3JuZXJSYWRpdXMgPSB0b3BSaWdodENvcm5lclJhZGl1cyA/IGNvcm5lclJhZGl1cyA6IDA7XG4gICAgICByZWN0LmJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzID0gYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgPyBjb3JuZXJSYWRpdXMgOiAwO1xuICAgICAgcmVjdC5ib3R0b21MZWZ0Q29ybmVyUmFkaXVzID0gYm90dG9tTGVmdENvcm5lclJhZGl1cyA/IGNvcm5lclJhZGl1cyA6IDA7XG4gICAgICByZWN0LmNyaXNwID0gZGF0dW0uY3Jpc3A7XG4gICAgICByZWN0LmZpbGxTaGFkb3cgPSBzaGFkb3c7XG4gICAgICByZWN0LnZpc2libGUgPSBkYXR1bS5oZWlnaHQgPiAwO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUxhYmVsU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBjb25zdCB7IGxhYmVsRGF0YSwgbGFiZWxTZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgcmV0dXJuIGxhYmVsU2VsZWN0aW9uLnVwZGF0ZShsYWJlbERhdGEsICh0ZXh0MikgPT4ge1xuICAgICAgdGV4dDIucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgICAgIHRleHQyLnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICB0ZXh0Mi50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUxhYmVsTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250RmFtaWx5LCBmb250U2l6ZSwgY29sb3IgfSA9IHRoaXMucHJvcGVydGllcy5sYWJlbDtcbiAgICBjb25zdCBsYWJlbEVuYWJsZWQgPSB0aGlzLmlzTGFiZWxFbmFibGVkKCk7XG4gICAgb3B0cy5sYWJlbFNlbGVjdGlvbi5lYWNoKCh0ZXh0MiwgZGF0dW0pID0+IHtcbiAgICAgIGlmIChsYWJlbEVuYWJsZWQgJiYgZGF0dW0/LmxhYmVsKSB7XG4gICAgICAgIHRleHQyLnRleHQgPSBkYXR1bS5sYWJlbC50ZXh0O1xuICAgICAgICB0ZXh0Mi54ID0gZGF0dW0ubGFiZWwueDtcbiAgICAgICAgdGV4dDIueSA9IGRhdHVtLmxhYmVsLnk7XG4gICAgICAgIHRleHQyLmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICAgICAgdGV4dDIuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgICAgIHRleHQyLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgICB0ZXh0Mi5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICB0ZXh0Mi5maWxsID0gY29sb3I7XG4gICAgICAgIHRleHQyLnZpc2libGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dDIudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGluaXRRdWFkVHJlZShxdWFkdHJlZSkge1xuICAgIGNvbnN0IHsgdmFsdWU6IGNoaWxkTm9kZSB9ID0gdGhpcy5jb250ZW50R3JvdXAuY2hpbGRyZW4oKS5uZXh0KCk7XG4gICAgaWYgKGNoaWxkTm9kZSkge1xuICAgICAgYWRkSGl0VGVzdGVyc1RvUXVhZHRyZWUocXVhZHRyZWUsIGNoaWxkTm9kZS5jaGlsZHJlbigpKTtcbiAgICB9XG4gIH1cbiAgcGlja05vZGVDbG9zZXN0RGF0dW0ocG9pbnQpIHtcbiAgICByZXR1cm4gZmluZFF1YWR0cmVlTWF0Y2godGhpcywgcG9pbnQpO1xuICB9XG4gIGdldFRvb2x0aXBDb250ZW50KG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgIGRhdGFNb2RlbCxcbiAgICAgIHByb2Nlc3NlZERhdGEsXG4gICAgICBheGVzLFxuICAgICAgcHJvcGVydGllcyxcbiAgICAgIGN0eDogeyBsb2NhbGVNYW5hZ2VyIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7IHhLZXksIHhOYW1lLCB5S2V5LCB5TmFtZSwgdG9vbHRpcCB9ID0gcHJvcGVydGllcztcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICghZGF0YU1vZGVsIHx8IHByb2Nlc3NlZERhdGE/LnR5cGUgIT09IFwiZ3JvdXBlZFwiIHx8ICF4QXhpcyB8fCAheUF4aXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZ3JvdXBJbmRleCA9IG5vZGVEYXR1bS5kYXR1bUluZGV4O1xuICAgIGNvbnN0IGdyb3VwID0gcHJvY2Vzc2VkRGF0YS5ncm91cHNbZ3JvdXBJbmRleF07XG4gICAgY29uc3QgeyBhZ2dyZWdhdGlvbiwgZGF0dW1JbmRpY2VzLCBrZXlzIH0gPSBncm91cDtcbiAgICBjb25zdCBbW25lZ2F0aXZlQWdnLCBwb3NpdGl2ZUFnZ10gPSBbMCwgMF1dID0gYWdncmVnYXRpb247XG4gICAgY29uc3QgZnJlcXVlbmN5ID0gZGF0dW1JbmRpY2VzLmxlbmd0aDtcbiAgICBjb25zdCBkb21haW4gPSBrZXlzO1xuICAgIGNvbnN0IFtyYW5nZU1pbiwgcmFuZ2VNYXhdID0gZG9tYWluO1xuICAgIGNvbnN0IGFnZ3JlZ2F0ZWRWYWx1ZSA9IG5lZ2F0aXZlQWdnICsgcG9zaXRpdmVBZ2c7XG4gICAgY29uc3QgZGF0dW0gPSB7XG4gICAgICBkYXRhOiBbLi4uZGF0YU1vZGVsLmZvckVhY2hEYXR1bSh0aGlzLCBwcm9jZXNzZWREYXRhLCBncm91cCldLFxuICAgICAgYWdncmVnYXRlZFZhbHVlLFxuICAgICAgZnJlcXVlbmN5LFxuICAgICAgZG9tYWluXG4gICAgfTtcbiAgICBjb25zdCBkYXRhID0gW1xuICAgICAge1xuICAgICAgICBsYWJlbDogeE5hbWUsXG4gICAgICAgIGZhbGxiYWNrTGFiZWw6IHhLZXksXG4gICAgICAgIHZhbHVlOiBgJHt4QXhpcy5mb3JtYXREYXR1bShyYW5nZU1pbil9IC0gJHt4QXhpcy5mb3JtYXREYXR1bShyYW5nZU1heCl9YFxuICAgICAgfSxcbiAgICAgIHsgbGFiZWw6IGxvY2FsZU1hbmFnZXIudChcInNlcmllc0hpc3RvZ3JhbVRvb2x0aXBGcmVxdWVuY3lcIiksIHZhbHVlOiB5QXhpcy5mb3JtYXREYXR1bShmcmVxdWVuY3kpIH1cbiAgICBdO1xuICAgIGlmICh5S2V5ICE9IG51bGwpIHtcbiAgICAgIGxldCBsYWJlbDtcbiAgICAgIHN3aXRjaCAocHJvcGVydGllcy5hZ2dyZWdhdGlvbikge1xuICAgICAgICBjYXNlIFwic3VtXCI6XG4gICAgICAgICAgbGFiZWwgPSBsb2NhbGVNYW5hZ2VyLnQoXCJzZXJpZXNIaXN0b2dyYW1Ub29sdGlwU3VtXCIsIHsgeU5hbWUgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtZWFuXCI6XG4gICAgICAgICAgbGFiZWwgPSBsb2NhbGVNYW5hZ2VyLnQoXCJzZXJpZXNIaXN0b2dyYW1Ub29sdGlwTWVhblwiLCB7IHlOYW1lIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY291bnRcIjpcbiAgICAgICAgICBsYWJlbCA9IGxvY2FsZU1hbmFnZXIudChcInNlcmllc0hpc3RvZ3JhbVRvb2x0aXBDb3VudFwiLCB7IHlOYW1lIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGF0YS5wdXNoKHsgbGFiZWwsIHZhbHVlOiB5QXhpcy5mb3JtYXREYXR1bShhZ2dyZWdhdGVkVmFsdWUpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdG9vbHRpcC5mb3JtYXRUb29sdGlwKFxuICAgICAge1xuICAgICAgICBzeW1ib2w6IHRoaXMubGVnZW5kSXRlbVN5bWJvbCgpLFxuICAgICAgICBkYXRhXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHRpdGxlOiB5TmFtZSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlLZXksXG4gICAgICAgIHlOYW1lLFxuICAgICAgICB4UmFuZ2U6IFtyYW5nZU1pbiwgcmFuZ2VNYXhdLFxuICAgICAgICBmcmVxdWVuY3ksXG4gICAgICAgIC4uLnRoaXMuZ2V0SXRlbUJhc2VTdHlsZShmYWxzZSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGxlZ2VuZEl0ZW1TeW1ib2woKSB7XG4gICAgY29uc3QgeyBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlOiBzdHJva2UyLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSwgbGluZURhc2gsIGxpbmVEYXNoT2Zmc2V0IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcmtlcjoge1xuICAgICAgICBmaWxsOiBmaWxsID8/IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuICAgICAgICBzdHJva2U6IHN0cm9rZTIgPz8gXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgbGluZURhc2gsXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBpZiAobGVnZW5kVHlwZSAhPT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgIGN0eDogeyBsZWdlbmRNYW5hZ2VyIH0sXG4gICAgICB2aXNpYmxlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB4S2V5OiBpdGVtSWQsIHlOYW1lLCBzaG93SW5MZWdlbmQgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBsZWdlbmRUeXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgICAgaXRlbUlkLFxuICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSAmJiBsZWdlbmRNYW5hZ2VyLmdldEl0ZW1FbmFibGVkKHsgc2VyaWVzSWQsIGl0ZW1JZCB9KSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiB5TmFtZSA/PyBpdGVtSWQgPz8gXCJGcmVxdWVuY3lcIlxuICAgICAgICB9LFxuICAgICAgICBzeW1ib2w6IHRoaXMubGVnZW5kSXRlbVN5bWJvbCgpLFxuICAgICAgICBoaWRlSW5MZWdlbmQ6ICFzaG93SW5MZWdlbmRcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KHsgZGF0dW1TZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uIH0pIHtcbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zKGNvbGxhcHNlZFN0YXJ0aW5nQmFyUG9zaXRpb24odHJ1ZSwgdGhpcy5heGVzLCBcIm5vcm1hbFwiKSk7XG4gICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsIFwiZGF0dW1zXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIFtkYXR1bVNlbGVjdGlvbl0sIGZucyk7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb24pO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoZGF0YSkge1xuICAgIGNvbnN0IGRhdGFEaWZmID0gdGhpcy5wcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5kaWZmPy5bdGhpcy5pZF07XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZUJhckFuaW1hdGlvbkZ1bmN0aW9ucyhjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uKHRydWUsIHRoaXMuYXhlcywgXCJub3JtYWxcIikpO1xuICAgIGZyb21Ub01vdGlvbihcbiAgICAgIHRoaXMuaWQsXG4gICAgICBcImRhdHVtc1wiLFxuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFtkYXRhLmRhdHVtU2VsZWN0aW9uXSxcbiAgICAgIGZucyxcbiAgICAgIChfLCBkYXR1bSkgPT4gY3JlYXRlRGF0dW1JZChkYXR1bS5kb21haW4pLFxuICAgICAgZGF0YURpZmZcbiAgICApO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIGRhdGEubGFiZWxTZWxlY3Rpb24pO1xuICB9XG4gIGlzTGFiZWxFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubGFiZWwuZW5hYmxlZDtcbiAgfVxuICBjb21wdXRlRm9jdXNCb3VuZHMoeyBkYXR1bUluZGV4IH0pIHtcbiAgICByZXR1cm4gY29tcHV0ZUJhckZvY3VzQm91bmRzKHRoaXMsIHRoaXMuY29udGV4dE5vZGVEYXRhPy5ub2RlRGF0YVtkYXR1bUluZGV4XSk7XG4gIH1cbn07XG5IaXN0b2dyYW1TZXJpZXMuY2xhc3NOYW1lID0gXCJIaXN0b2dyYW1TZXJpZXNcIjtcbkhpc3RvZ3JhbVNlcmllcy50eXBlID0gXCJoaXN0b2dyYW1cIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9oaXN0b2dyYW1TZXJpZXNNb2R1bGUudHNcbnZhciBIaXN0b2dyYW1TZXJpZXNNb2R1bGUgPSB7XG4gIHR5cGU6IFwic2VyaWVzXCIsXG4gIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSxcbiAgaWRlbnRpZmllcjogXCJoaXN0b2dyYW1cIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IEhpc3RvZ3JhbVNlcmllcyhjdHgpLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwiZXhhY3RcIiB9LFxuICBkZWZhdWx0QXhlczogW1xuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIgLyogTlVNQkVSICovLFxuICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIgLyogQk9UVE9NICovXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImxlZnRcIiAvKiBMRUZUICovXG4gICAgfVxuICBdLFxuICB0aGVtZVRlbXBsYXRlOiB7XG4gICAgc2VyaWVzOiB7XG4gICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgICAgIGxpbmVEYXNoOiBbMF0sXG4gICAgICBsaW5lRGFzaE9mZnNldDogMCxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmb250U2l6ZTogeyAkcmVmOiBcImZvbnRTaXplXCIgfSxcbiAgICAgICAgZm9udEZhbWlseTogeyAkcmVmOiBcImZvbnRGYW1pbHlcIiB9LFxuICAgICAgICBmb250V2VpZ2h0OiB7ICRyZWY6IFwiZm9udFdlaWdodFwiIH0sXG4gICAgICAgIGNvbG9yOiB7ICRyZWY6IFwiYmFja2dyb3VuZENvbG9yXCIgfVxuICAgICAgfSxcbiAgICAgIHNoYWRvdzoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfU0hBRE9XX0NPTE9VUixcbiAgICAgICAgeE9mZnNldDogMyxcbiAgICAgICAgeU9mZnNldDogMyxcbiAgICAgICAgYmx1cjogNVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGFsZXR0ZUZhY3Rvcnk6ICh7IHRha2VDb2xvcnMgfSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbGxzOiBbZmlsbF0sXG4gICAgICBzdHJva2VzOiBbc3Ryb2tlMl1cbiAgICB9ID0gdGFrZUNvbG9ycygxKTtcbiAgICByZXR1cm4geyBmaWxsLCBzdHJva2U6IHN0cm9rZTIgfTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9saW5lU2VyaWVzUHJvcGVydGllcy50c1xudmFyIExpbmVTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnN0cm9rZSA9IFwiIzg3NDM0OVwiO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAyO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5saW5lRGFzaCA9IFswXTtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmludGVycG9sYXRpb24gPSBuZXcgSW50ZXJwb2xhdGlvblByb3BlcnRpZXMoKTtcbiAgICB0aGlzLm1hcmtlciA9IG5ldyBTZXJpZXNNYXJrZXIoKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IExhYmVsKCk7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcbiAgICB0aGlzLmNvbm5lY3RNaXNzaW5nRGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuc3BhcmtsaW5lTW9kZSA9IGZhbHNlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5RmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3RhY2tHcm91cFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm5vcm1hbGl6ZWRUb1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRpdGxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMSU5FX0RBU0gpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaW50ZXJwb2xhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJtYXJrZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29ubmVjdE1pc3NpbmdEYXRhXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzcGFya2xpbmVNb2RlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xpbmVTZXJpZXMudHNcbnZhciBDUk9TU19GSUxURVJfTElORV9TVFJPS0VfT1BBQ0lUWV9GQUNUT1IgPSAwLjI1O1xudmFyIExpbmVTZXJpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIGRpcmVjdGlvbktleXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTLFxuICAgICAgZGlyZWN0aW9uTmFtZXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyxcbiAgICAgIGhhc01hcmtlcnM6IHRydWUsXG4gICAgICBwaWNrTW9kZXM6IFtcbiAgICAgICAgMiAvKiBBWElTX0FMSUdORUQgKi8sXG4gICAgICAgIDEgLyogTkVBUkVTVF9OT0RFICovLFxuICAgICAgICAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXG4gICAgICBdLFxuICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHtcbiAgICAgICAgcGF0aDogYnVpbGRSZXNldFBhdGhGbih7IGdldFZpc2libGU6ICgpID0+IHRoaXMudmlzaWJsZSwgZ2V0T3BhY2l0eTogKCkgPT4gdGhpcy5nZXRPcGFjaXR5KCkgfSksXG4gICAgICAgIGxhYmVsOiByZXNldExhYmVsRm4sXG4gICAgICAgIG1hcmtlcjogKG5vZGUsIGRhdHVtKSA9PiAoeyAuLi5yZXNldE1hcmtlckZuKG5vZGUpLCAuLi5yZXNldE1hcmtlclBvc2l0aW9uRm4obm9kZSwgZGF0dW0pIH0pXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jbGlwRm9jdXNCb3ggPSBmYWxzZTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgTGluZVNlcmllc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLmRhdGFBZ2dyZWdhdGlvbkZpbHRlcnMgPSB2b2lkIDA7XG4gIH1cbiAgZ2V0IHBpY2tNb2RlQXhpcygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnNwYXJrbGluZU1vZGUgPyBcIm1haW5cIiA6IFwibWFpbi1jYXRlZ29yeVwiO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XG4gICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0YSwgdmlzaWJsZSwgc2VyaWVzR3JvdXBpbmc6IHsgZ3JvdXBJbmRleCA9IHRoaXMuaWQsIHN0YWNrQ291bnQgPSAwIH0gPSB7fSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHlGaWx0ZXJLZXksIGNvbm5lY3RNaXNzaW5nRGF0YSwgbm9ybWFsaXplZFRvIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9uRW5hYmxlZCA9ICF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IHhTY2FsZSA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dPy5zY2FsZTtcbiAgICBjb25zdCB7IGlzQ29udGludW91c1gsIHhTY2FsZVR5cGUsIHlTY2FsZVR5cGUgfSA9IHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHhTY2FsZSwgeVNjYWxlIH0pO1xuICAgIGNvbnN0IHN0YWNrZWQgPSBzdGFja0NvdW50ID49IDEgfHwgbm9ybWFsaXplZFRvICE9IG51bGw7XG4gICAgY29uc3QgY29tbW9uID0geyBpbnZhbGlkVmFsdWU6IG51bGwgfTtcbiAgICBpZiAoY29ubmVjdE1pc3NpbmdEYXRhICYmIHN0YWNrZWQpIHtcbiAgICAgIGNvbW1vbi5pbnZhbGlkVmFsdWUgPSAwO1xuICAgIH1cbiAgICBpZiAoc3RhY2tlZCAmJiAhdmlzaWJsZSkge1xuICAgICAgY29tbW9uLmZvcmNlVmFsdWUgPSAwO1xuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IFtdO1xuICAgIGlmICghaXNDb250aW51b3VzWCB8fCBzdGFja2VkKSB7XG4gICAgICBwcm9wcy5wdXNoKGtleVByb3BlcnR5KHhLZXksIHhTY2FsZVR5cGUsIHsgaWQ6IFwieEtleVwiIH0pKTtcbiAgICB9XG4gICAgcHJvcHMucHVzaChcbiAgICAgIHZhbHVlUHJvcGVydHkoeEtleSwgeFNjYWxlVHlwZSwgeyBpZDogXCJ4VmFsdWVcIiB9KSxcbiAgICAgIHZhbHVlUHJvcGVydHkoeUtleSwgeVNjYWxlVHlwZSwge1xuICAgICAgICBpZDogYHlWYWx1ZVJhd2AsXG4gICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgaW52YWxpZFZhbHVlOiB2b2lkIDBcbiAgICAgIH0pXG4gICAgKTtcbiAgICBpZiAoeUZpbHRlcktleSAhPSBudWxsKSB7XG4gICAgICBwcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkoeUZpbHRlcktleSwgeVNjYWxlVHlwZSwgeyBpZDogXCJ5RmlsdGVyUmF3XCIgfSkpO1xuICAgIH1cbiAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgY29uc3QgaWRzID0gW1xuICAgICAgICBgbGluZS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZXNgLFxuICAgICAgICBgbGluZS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZXMtdHJhaWxpbmdgLFxuICAgICAgICBgbGluZS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZXMtbWFya2VyYFxuICAgICAgXTtcbiAgICAgIHByb3BzLnB1c2goXG4gICAgICAgIC4uLmdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShcbiAgICAgICAgICB5S2V5LFxuICAgICAgICAgIFwid2luZG93XCIsXG4gICAgICAgICAgXCJjdXJyZW50XCIsXG4gICAgICAgICAgeyBpZDogYHlWYWx1ZUVuZGAsIC4uLmNvbW1vbiwgZ3JvdXBJZDogaWRzWzBdIH0sXG4gICAgICAgICAgeVNjYWxlVHlwZVxuICAgICAgICApLFxuICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICBcIndpbmRvdy10cmFpbGluZ1wiLFxuICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgIHsgaWQ6IGB5VmFsdWVTdGFydGAsIC4uLmNvbW1vbiwgZ3JvdXBJZDogaWRzWzFdIH0sXG4gICAgICAgICAgeVNjYWxlVHlwZVxuICAgICAgICApLFxuICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICBcIm5vcm1hbFwiLFxuICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgIHsgaWQ6IGB5VmFsdWVDdW11bGF0aXZlYCwgLi4uY29tbW9uLCBncm91cElkOiBpZHNbMl0gfSxcbiAgICAgICAgICB5U2NhbGVUeXBlXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWZpbmVkKG5vcm1hbGl6ZWRUbykpIHtcbiAgICAgICAgcHJvcHMucHVzaChub3JtYWxpc2VHcm91cFRvKFtpZHNbMF0sIGlkc1sxXSwgaWRzWzJdXSwgbm9ybWFsaXplZFRvKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhbmltYXRpb25FbmFibGVkKSB7XG4gICAgICBwcm9wcy5wdXNoKGFuaW1hdGlvblZhbGlkYXRpb24oaXNDb250aW51b3VzWCA/IFtcInhWYWx1ZVwiXSA6IHZvaWQgMCkpO1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkRGF0YSkge1xuICAgICAgICBwcm9wcy5wdXNoKGRpZmYodGhpcy5pZCwgdGhpcy5wcm9jZXNzZWREYXRhKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIGRhdGEsIHtcbiAgICAgIHByb3BzLFxuICAgICAgZ3JvdXBCeUtleXM6IHN0YWNrZWQsXG4gICAgICBncm91cEJ5RGF0YTogIXN0YWNrZWRcbiAgICB9KTtcbiAgICB0aGlzLmRhdGFBZ2dyZWdhdGlvbkZpbHRlcnMgPSB0aGlzLmFnZ3JlZ2F0ZURhdGEoZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhKTtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIHhDb29yZGluYXRlUmFuZ2UoeFZhbHVlLCBwaXhlbFNpemUpIHtcbiAgICBjb25zdCB7IG1hcmtlciB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHggPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL10uc2NhbGUuY29udmVydCh4VmFsdWUpO1xuICAgIGNvbnN0IHIgPSBtYXJrZXIuZW5hYmxlZCA/IDAuNSAqIG1hcmtlci5zaXplICogcGl4ZWxTaXplIDogMDtcbiAgICByZXR1cm4gW3ggLSByLCB4ICsgcl07XG4gIH1cbiAgeUNvb3JkaW5hdGVSYW5nZSh5VmFsdWVzLCBwaXhlbFNpemUpIHtcbiAgICBjb25zdCB7IG1hcmtlciB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHkgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL10uc2NhbGUuY29udmVydCh5VmFsdWVzWzBdKTtcbiAgICBjb25zdCByID0gbWFya2VyLmVuYWJsZWQgPyAwLjUgKiBtYXJrZXIuc2l6ZSAqIHBpeGVsU2l6ZSA6IDA7XG4gICAgcmV0dXJuIFt5IC0gciwgeSArIHJdO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gdGhpcztcbiAgICBpZiAoIWRhdGFNb2RlbCB8fCAhcHJvY2Vzc2VkRGF0YSlcbiAgICAgIHJldHVybiBbXTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICBjb25zdCB4RGVmID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZCh0aGlzLCBgeFZhbHVlYCk7XG4gICAgICBjb25zdCBkb21haW4gPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGB4VmFsdWVgLCBcInZhbHVlXCIsIHByb2Nlc3NlZERhdGEpO1xuICAgICAgaWYgKHhEZWY/LmRlZi50eXBlID09PSBcInZhbHVlXCIgJiYgeERlZi5kZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KGV4dGVudChkb21haW4pKTtcbiAgICB9XG4gICAgY29uc3QgeUtleSA9IHRoaXMuZGF0YU1vZGVsPy5oYXNDb2x1bW5CeUlkKHRoaXMsIGB5VmFsdWVFbmRgKSA/IFwieVZhbHVlRW5kXCIgOiBcInlWYWx1ZVJhd1wiO1xuICAgIGNvbnN0IHlFeHRlbnQgPSB0aGlzLmRvbWFpbkZvckNsaXBwZWRSYW5nZShcInlcIiAvKiBZICovLCBbeUtleV0sIFwieFZhbHVlXCIsIHRydWUpO1xuICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KHlFeHRlbnQpO1xuICB9XG4gIGdldFNlcmllc1JhbmdlKF9kaXJlY3Rpb24sIHZpc2libGVSYW5nZSkge1xuICAgIGNvbnN0IHlLZXkgPSB0aGlzLmRhdGFNb2RlbD8uaGFzQ29sdW1uQnlJZCh0aGlzLCBgeVZhbHVlRW5kYCkgPyBcInlWYWx1ZUVuZFwiIDogXCJ5VmFsdWVSYXdcIjtcbiAgICByZXR1cm4gdGhpcy5kb21haW5Gb3JWaXNpYmxlUmFuZ2UoXCJ5XCIgLyogWSAqLywgW3lLZXldLCBcInhWYWx1ZVwiLCB2aXNpYmxlUmFuZ2UsIHRydWUpO1xuICB9XG4gIGdldFZpc2libGVJdGVtcyh4VmlzaWJsZVJhbmdlLCB5VmlzaWJsZVJhbmdlLCBtaW5WaXNpYmxlSXRlbXMpIHtcbiAgICBjb25zdCB5S2V5ID0gdGhpcy5kYXRhTW9kZWw/Lmhhc0NvbHVtbkJ5SWQodGhpcywgYHlWYWx1ZUVuZGApID8gXCJ5VmFsdWVFbmRcIiA6IFwieVZhbHVlUmF3XCI7XG4gICAgcmV0dXJuIHRoaXMuY291bnRWaXNpYmxlSXRlbXMoXCJ4VmFsdWVcIiwgW3lLZXldLCB4VmlzaWJsZVJhbmdlLCB5VmlzaWJsZVJhbmdlLCBtaW5WaXNpYmxlSXRlbXMpO1xuICB9XG4gIGFnZ3JlZ2F0ZURhdGEoX2RhdGFNb2RlbCwgX3Byb2Nlc3NlZERhdGEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY3JlYXRlTm9kZURhdGEoKSB7XG4gICAgY29uc3QgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEsIGF4ZXMsIGRhdGFBZ2dyZWdhdGlvbkZpbHRlcnMgfSA9IHRoaXM7XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIWRhdGFNb2RlbCB8fCAhcHJvY2Vzc2VkRGF0YSB8fCAheEF4aXMgfHwgIXlBeGlzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHhLZXksXG4gICAgICB5S2V5LFxuICAgICAgeUZpbHRlcktleSxcbiAgICAgIHhOYW1lLFxuICAgICAgeU5hbWUsXG4gICAgICBtYXJrZXIsXG4gICAgICBsYWJlbCxcbiAgICAgIGNvbm5lY3RNaXNzaW5nRGF0YSxcbiAgICAgIGludGVycG9sYXRpb24sXG4gICAgICBsZWdlbmRJdGVtTmFtZVxuICAgIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3Qgc3RhY2tlZCA9IHRoaXMuZGF0YU1vZGVsPy5oYXNDb2x1bW5CeUlkKHRoaXMsIGB5VmFsdWVFbmRgKTtcbiAgICBjb25zdCB4U2NhbGUgPSB4QXhpcy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB5QXhpcy5zY2FsZTtcbiAgICBjb25zdCB4T2Zmc2V0ID0gKHhTY2FsZS5iYW5kd2lkdGggPz8gMCkgLyAyO1xuICAgIGNvbnN0IHlPZmZzZXQgPSAoeVNjYWxlLmJhbmR3aWR0aCA/PyAwKSAvIDI7XG4gICAgY29uc3Qgc2l6ZSA9IG1hcmtlci5lbmFibGVkID8gbWFya2VyLnNpemUgOiAwO1xuICAgIGNvbnN0IHJhd0RhdGEgPSBwcm9jZXNzZWREYXRhLmRhdGFTb3VyY2VzLmdldCh0aGlzLmlkKSA/PyBbXTtcbiAgICBjb25zdCB4VmFsdWVzID0gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGB4VmFsdWVgLCBwcm9jZXNzZWREYXRhKTtcbiAgICBjb25zdCB5VmFsdWVzID0gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGB5VmFsdWVSYXdgLCBwcm9jZXNzZWREYXRhKTtcbiAgICBjb25zdCB5RW5kVmFsdWVzID0gc3RhY2tlZCA/IGRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBgeVZhbHVlRW5kYCwgcHJvY2Vzc2VkRGF0YSkgOiB2b2lkIDA7XG4gICAgY29uc3QgeUN1bXVsYXRpdmVWYWx1ZXMgPSBzdGFja2VkID8gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGB5VmFsdWVDdW11bGF0aXZlYCwgcHJvY2Vzc2VkRGF0YSkgOiB5VmFsdWVzO1xuICAgIGNvbnN0IHNlbGVjdGlvblZhbHVlcyA9IHlGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBgeUZpbHRlclJhd2AsIHByb2Nlc3NlZERhdGEpIDogdm9pZCAwO1xuICAgIGNvbnN0IHhQb3NpdGlvbiA9IChpbmRleCkgPT4geFNjYWxlLmNvbnZlcnQoeFZhbHVlc1tpbmRleF0pICsgeE9mZnNldDtcbiAgICBjb25zdCB5UG9zaXRpb24gPSAoaW5kZXgpID0+IHlTY2FsZS5jb252ZXJ0KHlDdW11bGF0aXZlVmFsdWVzW2luZGV4XSkgKyB5T2Zmc2V0O1xuICAgIGNvbnN0IGNhcERlZmF1bHRzID0ge1xuICAgICAgbGVuZ3RoUmF0aW9NdWx0aXBsaWVyOiB0aGlzLnByb3BlcnRpZXMubWFya2VyLmdldERpYW1ldGVyKCksXG4gICAgICBsZW5ndGhNYXg6IEluZmluaXR5XG4gICAgfTtcbiAgICBjb25zdCBub2RlRGF0YSA9IFtdO1xuICAgIGxldCBzcGFuUG9pbnRzO1xuICAgIGNvbnN0IGhhbmRsZURhdHVtID0gKGRhdHVtSW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGRhdHVtID0gcmF3RGF0YVtkYXR1bUluZGV4XTtcbiAgICAgIGNvbnN0IHhEYXR1bSA9IHhWYWx1ZXNbZGF0dW1JbmRleF07XG4gICAgICBjb25zdCB5RGF0dW0gPSB5VmFsdWVzW2RhdHVtSW5kZXhdO1xuICAgICAgY29uc3QgeUVuZERhdHVtID0geUVuZFZhbHVlcz8uW2RhdHVtSW5kZXhdO1xuICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBzZWxlY3Rpb25WYWx1ZXM/LltkYXR1bUluZGV4XTtcbiAgICAgIGNvbnN0IHggPSB4UG9zaXRpb24oZGF0dW1JbmRleCk7XG4gICAgICBjb25zdCB5ID0geVBvc2l0aW9uKGRhdHVtSW5kZXgpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh5RGF0dW0gIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBsYWJlbFRleHQgPSBsYWJlbC5lbmFibGVkID8gdGhpcy5nZXRMYWJlbFRleHQobGFiZWwsIHtcbiAgICAgICAgICB2YWx1ZTogeURhdHVtLFxuICAgICAgICAgIGRhdHVtLFxuICAgICAgICAgIHhLZXksXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICB4TmFtZSxcbiAgICAgICAgICB5TmFtZSxcbiAgICAgICAgICBsZWdlbmRJdGVtTmFtZVxuICAgICAgICB9KSA6IHZvaWQgMDtcbiAgICAgICAgbm9kZURhdGEucHVzaCh7XG4gICAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICAgIGRhdHVtLFxuICAgICAgICAgIGRhdHVtSW5kZXgsXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICB4S2V5LFxuICAgICAgICAgIHBvaW50OiB7IHgsIHksIHNpemUgfSxcbiAgICAgICAgICBtaWRQb2ludDogeyB4LCB5IH0sXG4gICAgICAgICAgY3VtdWxhdGl2ZVZhbHVlOiB5RW5kRGF0dW0sXG4gICAgICAgICAgeVZhbHVlOiB5RGF0dW0sXG4gICAgICAgICAgeFZhbHVlOiB4RGF0dW0sXG4gICAgICAgICAgY2FwRGVmYXVsdHMsXG4gICAgICAgICAgbGFiZWxUZXh0LFxuICAgICAgICAgIHNlbGVjdGVkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHNwYW5Qb2ludHMgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgY3VycmVudFNwYW5Qb2ludHMgPSBzcGFuUG9pbnRzW3NwYW5Qb2ludHMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoeURhdHVtICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3BhblBvaW50ID0ge1xuICAgICAgICAgIHBvaW50OiB7IHgsIHkgfSxcbiAgICAgICAgICB4RGF0dW0sXG4gICAgICAgICAgeURhdHVtXG4gICAgICAgIH07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRTcGFuUG9pbnRzKSkge1xuICAgICAgICAgIGN1cnJlbnRTcGFuUG9pbnRzLnB1c2goc3BhblBvaW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50U3BhblBvaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgY3VycmVudFNwYW5Qb2ludHMuc2tpcCArPSAxO1xuICAgICAgICAgIHNwYW5Qb2ludHMucHVzaChbc3BhblBvaW50XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3BhblBvaW50cy5wdXNoKFtzcGFuUG9pbnRdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghY29ubmVjdE1pc3NpbmdEYXRhKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRTcGFuUG9pbnRzKSB8fCBjdXJyZW50U3BhblBvaW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgc3BhblBvaW50cy5wdXNoKHsgc2tpcDogMCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50U3BhblBvaW50cy5za2lwICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IFtyMCwgcjFdID0geFNjYWxlLnJhbmdlO1xuICAgIGNvbnN0IHJhbmdlMyA9IHIxIC0gcjA7XG4gICAgY29uc3QgZGF0YUFnZ3JlZ2F0aW9uRmlsdGVyID0gZGF0YUFnZ3JlZ2F0aW9uRmlsdGVycz8uZmluZCgoZikgPT4gZi5tYXhSYW5nZSA+IHJhbmdlMyk7XG4gICAgY29uc3QgaW5kaWNlcyA9IGRhdGFBZ2dyZWdhdGlvbkZpbHRlcj8uaW5kaWNlcztcbiAgICBsZXQgW3N0YXJ0MiwgZW5kMl0gPSB0aGlzLnZpc2libGVSYW5nZShcInhWYWx1ZVwiLCB4QXhpcy5yYW5nZSwgaW5kaWNlcyk7XG4gICAgc3RhcnQyID0gTWF0aC5tYXgoc3RhcnQyIC0gMSwgMCk7XG4gICAgZW5kMiA9IE1hdGgubWluKGVuZDIgKyAxLCBpbmRpY2VzPy5sZW5ndGggPz8geFZhbHVlcy5sZW5ndGgpO1xuICAgIGlmIChwcm9jZXNzZWREYXRhLmlucHV0LmNvdW50IDwgMWUzKSB7XG4gICAgICBzdGFydDIgPSAwO1xuICAgICAgZW5kMiA9IHByb2Nlc3NlZERhdGEuaW5wdXQuY291bnQ7XG4gICAgfVxuICAgIGlmIChpbmRpY2VzID09IG51bGwpIHtcbiAgICAgIHNwYW5Qb2ludHMgPSBbXTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0MjsgaSA8IGVuZDI7IGkgKz0gMSkge1xuICAgICAgaGFuZGxlRGF0dW0oaW5kaWNlcz8uW2ldID8/IGkpO1xuICAgIH1cbiAgICBjb25zdCBzdHJva2VTcGFucyA9IHNwYW5Qb2ludHM/LmZsYXRNYXAoKHApID0+IHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHApID8gaW50ZXJwb2xhdGVQb2ludHMocCwgaW50ZXJwb2xhdGlvbikgOiBbXTtcbiAgICB9KTtcbiAgICBjb25zdCBzdHJva2VEYXRhID0gc3Ryb2tlU3BhbnMgIT0gbnVsbCA/IHsgaXRlbUlkOiB5S2V5LCBzcGFuczogc3Ryb2tlU3BhbnMgfSA6IHZvaWQgMDtcbiAgICBjb25zdCBjcm9zc0ZpbHRlcmluZyA9IHNlbGVjdGlvblZhbHVlcz8uc29tZSgoc2VsZWN0aW9uVmFsdWUsIGluZGV4KSA9PiBzZWxlY3Rpb25WYWx1ZSA9PT0geVZhbHVlc1tpbmRleF0pID8/IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICBub2RlRGF0YSxcbiAgICAgIGxhYmVsRGF0YTogbm9kZURhdGEsXG4gICAgICBzdHJva2VEYXRhLFxuICAgICAgc2NhbGVzOiB0aGlzLmNhbGN1bGF0ZVNjYWxpbmcoKSxcbiAgICAgIHZpc2libGU6IHRoaXMudmlzaWJsZSxcbiAgICAgIGNyb3NzRmlsdGVyaW5nXG4gICAgfTtcbiAgfVxuICBpc1BhdGhPclNlbGVjdGlvbkRpcnR5KCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubWFya2VyLmlzRGlydHkoKTtcbiAgfVxuICB1cGRhdGVQYXRoTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGhzOiBbbGluZU5vZGVdLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHZpc2libGUsXG4gICAgICBhbmltYXRpb25FbmFibGVkXG4gICAgfSA9IG9wdHM7XG4gICAgY29uc3QgY3Jvc3NGaWx0ZXJpbmcgPSB0aGlzLmNvbnRleHROb2RlRGF0YT8uY3Jvc3NGaWx0ZXJpbmcgPT09IHRydWU7XG4gICAgbGluZU5vZGUuc2V0UHJvcGVydGllcyh7XG4gICAgICBmaWxsOiB2b2lkIDAsXG4gICAgICBsaW5lSm9pbjogXCJyb3VuZFwiLFxuICAgICAgcG9pbnRlckV2ZW50czogMSAvKiBOb25lICovLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHN0cm9rZTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLmdldFN0cm9rZVdpZHRoKHRoaXMucHJvcGVydGllcy5zdHJva2VXaWR0aCksXG4gICAgICBzdHJva2VPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlT3BhY2l0eSAqIChjcm9zc0ZpbHRlcmluZyA/IENST1NTX0ZJTFRFUl9MSU5FX1NUUk9LRV9PUEFDSVRZX0ZBQ1RPUiA6IDEpLFxuICAgICAgbGluZURhc2g6IHRoaXMucHJvcGVydGllcy5saW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiB0aGlzLnByb3BlcnRpZXMubGluZURhc2hPZmZzZXRcbiAgICB9KTtcbiAgICBpZiAoIWFuaW1hdGlvbkVuYWJsZWQpIHtcbiAgICAgIGxpbmVOb2RlLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIH1cbiAgICB1cGRhdGVDbGlwUGF0aCh0aGlzLCBsaW5lTm9kZSk7XG4gIH1cbiAgZ2V0TWFya2VySXRlbUJhc2VTdHlsZShoaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IG1hcmtlciB9ID0gcHJvcGVydGllcztcbiAgICBjb25zdCBoaWdobGlnaHRTdHlsZSA9IGhpZ2hsaWdodGVkID8gcHJvcGVydGllcy5oaWdobGlnaHRTdHlsZS5pdGVtIDogdm9pZCAwO1xuICAgIHJldHVybiB7XG4gICAgICBzaXplOiBtYXJrZXIuc2l6ZSxcbiAgICAgIHNoYXBlOiBtYXJrZXIuc2hhcGUsXG4gICAgICBmaWxsOiBoaWdobGlnaHRTdHlsZT8uZmlsbCA/PyBtYXJrZXIuZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5OiBoaWdobGlnaHRTdHlsZT8uZmlsbE9wYWNpdHkgPz8gbWFya2VyLmZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlOiBoaWdobGlnaHRTdHlsZT8uc3Ryb2tlID8/IG1hcmtlci5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogaGlnaGxpZ2h0U3R5bGU/LnN0cm9rZVdpZHRoID8/IG1hcmtlci5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZU9wYWNpdHk6IGhpZ2hsaWdodFN0eWxlPy5zdHJva2VPcGFjaXR5ID8/IG1hcmtlci5zdHJva2VPcGFjaXR5LFxuICAgICAgbGluZURhc2g6IGhpZ2hsaWdodFN0eWxlPy5saW5lRGFzaCA/PyBtYXJrZXIubGluZURhc2gsXG4gICAgICBsaW5lRGFzaE9mZnNldDogaGlnaGxpZ2h0U3R5bGU/LmxpbmVEYXNoT2Zmc2V0ID8/IG1hcmtlci5saW5lRGFzaE9mZnNldFxuICAgIH07XG4gIH1cbiAgZ2V0TWFya2VySXRlbVN0eWxlT3ZlcnJpZGVzKGRhdHVtSWQsIGRhdHVtLCBmb3JtYXQsIGhpZ2hsaWdodGVkKSB7XG4gICAgY29uc3QgeyBpZDogc2VyaWVzSWQsIHByb3BlcnRpZXMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBtYXJrZXIgfSA9IHByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBpdGVtU3R5bGVyIH0gPSBtYXJrZXI7XG4gICAgaWYgKGl0ZW1TdHlsZXIgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICByZXR1cm4gdGhpcy5jYWNoZWREYXR1bUNhbGxiYWNrKGNyZWF0ZURhdHVtSWQoZGF0dW1JZCwgaGlnaGxpZ2h0ZWQgPyBcImhpZ2hsaWdodFwiIDogXCJub2RlXCIpLCAoKSA9PiB7XG4gICAgICBjb25zdCB4RG9tYWluID0gdGhpcy5nZXRTZXJpZXNEb21haW4oXCJ4XCIgLyogWCAqLyk7XG4gICAgICBjb25zdCB5RG9tYWluID0gdGhpcy5nZXRTZXJpZXNEb21haW4oXCJ5XCIgLyogWSAqLyk7XG4gICAgICByZXR1cm4gaXRlbVN0eWxlcih7XG4gICAgICAgIHNlcmllc0lkLFxuICAgICAgICAuLi5kYXR1bVN0eWxlclByb3BlcnRpZXMoZGF0dW0sIHhLZXksIHlLZXksIHhEb21haW4sIHlEb21haW4pLFxuICAgICAgICBoaWdobGlnaHRlZCxcbiAgICAgICAgLi4uZm9ybWF0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVNYXJrZXJTZWxlY3Rpb24ob3B0cykge1xuICAgIGxldCB7IG5vZGVEYXRhIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIGNvbnN0IG1hcmtlcnNFbmFibGVkID0gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5lbmFibGVkIHx8IHRoaXMuY29udGV4dE5vZGVEYXRhPy5jcm9zc0ZpbHRlcmluZyA9PT0gdHJ1ZTtcbiAgICBub2RlRGF0YSA9IG1hcmtlcnNFbmFibGVkID8gbm9kZURhdGEgOiBbXTtcbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5pc0RpcnR5KCkpIHtcbiAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlclNlbGVjdGlvbi51cGRhdGUobm9kZURhdGEsIHZvaWQgMCwgKGRhdHVtKSA9PiBjcmVhdGVEYXR1bUlkKGRhdHVtLnhWYWx1ZSkpO1xuICB9XG4gIHVwZGF0ZU1hcmtlck5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgaXNIaWdobGlnaHQ6IGhpZ2hsaWdodGVkIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgc3Ryb2tlOiBzdHJva2UyLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSwgbWFya2VyLCBoaWdobGlnaHRTdHlsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHhEb21haW4gPSB0aGlzLmdldFNlcmllc0RvbWFpbihcInhcIiAvKiBYICovKTtcbiAgICBjb25zdCB5RG9tYWluID0gdGhpcy5nZXRTZXJpZXNEb21haW4oXCJ5XCIgLyogWSAqLyk7XG4gICAgY29uc3QgYmFzZVN0eWxlID0gbWVyZ2VEZWZhdWx0cyhoaWdobGlnaHRlZCAmJiBoaWdobGlnaHRTdHlsZS5pdGVtLCBtYXJrZXIuZ2V0U3R5bGUoKSwge1xuICAgICAgc3Ryb2tlOiBzdHJva2UyLFxuICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VPcGFjaXR5XG4gICAgfSk7XG4gICAgY29uc3QgYXBwbHlUcmFuc2xhdGlvbiA9IHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgbWFya2VyU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZU1hcmtlclN0eWxlKFxuICAgICAgICBub2RlLFxuICAgICAgICBtYXJrZXIsXG4gICAgICAgIHsgLi4uZGF0dW1TdHlsZXJQcm9wZXJ0aWVzKGRhdHVtLCB4S2V5LCB5S2V5LCB4RG9tYWluLCB5RG9tYWluKSwgaGlnaGxpZ2h0ZWQgfSxcbiAgICAgICAgYmFzZVN0eWxlLFxuICAgICAgICB7IGFwcGx5VHJhbnNsYXRpb24sIHNlbGVjdGVkOiBkYXR1bS5zZWxlY3RlZCB9XG4gICAgICApO1xuICAgIH0pO1xuICAgIGlmICghaGlnaGxpZ2h0ZWQpIHtcbiAgICAgIG1hcmtlci5tYXJrQ2xlYW4oKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlTGFiZWxTZWxlY3Rpb24ob3B0cykge1xuICAgIHJldHVybiBvcHRzLmxhYmVsU2VsZWN0aW9uLnVwZGF0ZSh0aGlzLmlzTGFiZWxFbmFibGVkKCkgPyBvcHRzLmxhYmVsRGF0YSA6IFtdKTtcbiAgfVxuICB1cGRhdGVMYWJlbE5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IGVuYWJsZWQsIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHksIGNvbG9yIH0gPSB0aGlzLnByb3BlcnRpZXMubGFiZWw7XG4gICAgb3B0cy5sYWJlbFNlbGVjdGlvbi5lYWNoKCh0ZXh0MiwgZGF0dW0pID0+IHtcbiAgICAgIGlmIChlbmFibGVkICYmIGRhdHVtPy5sYWJlbFRleHQpIHtcbiAgICAgICAgdGV4dDIuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgICB0ZXh0Mi5mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcbiAgICAgICAgdGV4dDIuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgdGV4dDIuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICAgIHRleHQyLnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIHRleHQyLnRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XG4gICAgICAgIHRleHQyLnRleHQgPSBkYXR1bS5sYWJlbFRleHQ7XG4gICAgICAgIHRleHQyLnggPSBkYXR1bS5wb2ludC54O1xuICAgICAgICB0ZXh0Mi55ID0gZGF0dW0ucG9pbnQueSAtIDEwO1xuICAgICAgICB0ZXh0Mi5maWxsID0gY29sb3I7XG4gICAgICAgIHRleHQyLnZpc2libGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dDIudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldFRvb2x0aXBDb250ZW50KG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHsgaWQ6IHNlcmllc0lkLCBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEsIGF4ZXMsIHByb3BlcnRpZXMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB4S2V5LCB4TmFtZSwgeUtleSwgeU5hbWUsIHRvb2x0aXAgfSA9IHByb3BlcnRpZXM7XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIWRhdGFNb2RlbCB8fCAhcHJvY2Vzc2VkRGF0YSB8fCAheEF4aXMgfHwgIXlBeGlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0dW1JbmRleCB9ID0gbm9kZURhdHVtO1xuICAgIGNvbnN0IGRhdHVtID0gcHJvY2Vzc2VkRGF0YS5kYXRhU291cmNlcy5nZXQodGhpcy5pZCk/LltkYXR1bUluZGV4XTtcbiAgICBjb25zdCB4VmFsdWUgPSBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYHhWYWx1ZWAsIHByb2Nlc3NlZERhdGEpW2RhdHVtSW5kZXhdO1xuICAgIGNvbnN0IHlWYWx1ZSA9IGRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBgeVZhbHVlUmF3YCwgcHJvY2Vzc2VkRGF0YSlbZGF0dW1JbmRleF07XG4gICAgaWYgKHhWYWx1ZSA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0TWFya2VySXRlbUJhc2VTdHlsZShmYWxzZSk7XG4gICAgT2JqZWN0LmFzc2lnbihmb3JtYXQsIHRoaXMuZ2V0TWFya2VySXRlbVN0eWxlT3ZlcnJpZGVzKFN0cmluZyhkYXR1bUluZGV4KSwgZGF0dW0sIGZvcm1hdCwgZmFsc2UpKTtcbiAgICByZXR1cm4gdG9vbHRpcC5mb3JtYXRUb29sdGlwKFxuICAgICAge1xuICAgICAgICBoZWFkaW5nOiB4QXhpcy5mb3JtYXREYXR1bSh4VmFsdWUpLFxuICAgICAgICBzeW1ib2w6IHRoaXMubGVnZW5kSXRlbVN5bWJvbCgpLFxuICAgICAgICBkYXRhOiBbeyBsYWJlbDogeU5hbWUsIGZhbGxiYWNrTGFiZWw6IHlLZXksIHZhbHVlOiB5QXhpcy5mb3JtYXREYXR1bSh5VmFsdWUpIH1dXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHRpdGxlOiB5TmFtZSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlLZXksXG4gICAgICAgIHlOYW1lLFxuICAgICAgICAuLi5mb3JtYXQsXG4gICAgICAgIC4uLnRoaXMuZ2V0TW9kdWxlVG9vbHRpcFBhcmFtcygpXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBsZWdlbmRJdGVtU3ltYm9sKCkge1xuICAgIGNvbnN0IGNvbG9yMCA9IFwicmdiYSgwLCAwLCAwLCAwKVwiO1xuICAgIGNvbnN0IHsgc3Ryb2tlOiBzdHJva2UyLCBzdHJva2VPcGFjaXR5LCBzdHJva2VXaWR0aCwgbGluZURhc2gsIG1hcmtlciB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiB7XG4gICAgICBtYXJrZXI6IHtcbiAgICAgICAgc2hhcGU6IG1hcmtlci5zaGFwZSxcbiAgICAgICAgZmlsbDogbWFya2VyLmZpbGwgPz8gY29sb3IwLFxuICAgICAgICBzdHJva2U6IG1hcmtlci5zdHJva2UgPz8gc3Ryb2tlMiA/PyBjb2xvcjAsXG4gICAgICAgIGZpbGxPcGFjaXR5OiBtYXJrZXIuZmlsbE9wYWNpdHksXG4gICAgICAgIHN0cm9rZU9wYWNpdHk6IG1hcmtlci5zdHJva2VPcGFjaXR5LFxuICAgICAgICBzdHJva2VXaWR0aDogbWFya2VyLnN0cm9rZVdpZHRoLFxuICAgICAgICBsaW5lRGFzaDogbWFya2VyLmxpbmVEYXNoLFxuICAgICAgICBsaW5lRGFzaE9mZnNldDogbWFya2VyLmxpbmVEYXNoT2Zmc2V0LFxuICAgICAgICBlbmFibGVkOiBtYXJrZXIuZW5hYmxlZFxuICAgICAgfSxcbiAgICAgIGxpbmU6IHtcbiAgICAgICAgc3Ryb2tlOiBzdHJva2UyID8/IGNvbG9yMCxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIGxpbmVEYXNoXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBpZiAoISh0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpICYmIGxlZ2VuZFR5cGUgPT09IFwiY2F0ZWdvcnlcIikpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgY3R4OiB7IGxlZ2VuZE1hbmFnZXIgfSxcbiAgICAgIHZpc2libGVcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7IHlLZXk6IGl0ZW1JZCwgeU5hbWUsIHRpdGxlLCBsZWdlbmRJdGVtTmFtZSwgc2hvd0luTGVnZW5kIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbGVnZW5kVHlwZTogXCJjYXRlZ29yeVwiLFxuICAgICAgICBpZDogc2VyaWVzSWQsXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgbGVnZW5kSXRlbU5hbWUsXG4gICAgICAgIHNlcmllc0lkLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlICYmIGxlZ2VuZE1hbmFnZXIuZ2V0SXRlbUVuYWJsZWQoeyBzZXJpZXNJZCwgaXRlbUlkIH0pLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IGxlZ2VuZEl0ZW1OYW1lID8/IHRpdGxlID8/IHlOYW1lID8/IGl0ZW1JZFxuICAgICAgICB9LFxuICAgICAgICBzeW1ib2w6IHRoaXMubGVnZW5kSXRlbVN5bWJvbCgpLFxuICAgICAgICBoaWRlSW5MZWdlbmQ6ICFzaG93SW5MZWdlbmRcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIHVwZGF0ZVBhdGhzKG9wdHMpIHtcbiAgICB0aGlzLnVwZGF0ZUxpbmVQYXRocyhvcHRzLnBhdGhzLCBvcHRzLmNvbnRleHREYXRhKTtcbiAgfVxuICBwbG90Tm9kZURhdGFQb2ludHMocGF0aCwgbm9kZURhdGEpIHtcbiAgICBpZiAobm9kZURhdGEubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGluaXRpYWxQb2ludCA9IG5vZGVEYXRhWzBdLnBvaW50O1xuICAgIHBhdGgubW92ZVRvKGluaXRpYWxQb2ludC54LCBpbml0aWFsUG9pbnQueSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBub2RlRGF0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgeyB4LCB5IH0gPSBub2RlRGF0YVtpXS5wb2ludDtcbiAgICAgIHBhdGgubGluZVRvKHgsIHkpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVMaW5lUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKSB7XG4gICAgY29uc3Qgc3BhbnMgPSBjb250ZXh0RGF0YS5zdHJva2VEYXRhPy5zcGFucztcbiAgICBjb25zdCBbbGluZU5vZGVdID0gcGF0aHM7XG4gICAgbGluZU5vZGUucGF0aC5jbGVhcigpO1xuICAgIGlmIChzcGFucyAhPSBudWxsKSB7XG4gICAgICBwbG90TGluZVBhdGhTdHJva2UobGluZU5vZGUsIHNwYW5zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbG90Tm9kZURhdGFQb2ludHMobGluZU5vZGUucGF0aCwgY29udGV4dERhdGEubm9kZURhdGEpO1xuICAgIH1cbiAgICBsaW5lTm9kZS5tYXJrRGlydHkoKTtcbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeShhbmltYXRpb25EYXRhKSB7XG4gICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBhbm5vdGF0aW9uU2VsZWN0aW9ucywgY29udGV4dERhdGEsIHBhdGhzIH0gPSBhbmltYXRpb25EYXRhO1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgdGhpcy51cGRhdGVMaW5lUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgICBwYXRoU3dpcGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCAuLi5wYXRocyk7XG4gICAgcmVzZXRNb3Rpb24oW21hcmtlclNlbGVjdGlvbl0sIHJlc2V0TWFya2VyUG9zaXRpb25Gbik7XG4gICAgbWFya2VyU3dpcGVTY2FsZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIG1hcmtlclNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiYW5ub3RhdGlvbnNcIiwgYW5pbWF0aW9uTWFuYWdlciwgLi4uYW5ub3RhdGlvblNlbGVjdGlvbnMpO1xuICB9XG4gIGFuaW1hdGVSZWFkeVJlc2l6ZShhbmltYXRpb25EYXRhKSB7XG4gICAgY29uc3QgeyBjb250ZXh0RGF0YSwgcGF0aHMgfSA9IGFuaW1hdGlvbkRhdGE7XG4gICAgdGhpcy51cGRhdGVMaW5lUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgICBzdXBlci5hbmltYXRlUmVhZHlSZXNpemUoYW5pbWF0aW9uRGF0YSk7XG4gIH1cbiAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShhbmltYXRpb25EYXRhKSB7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7XG4gICAgICBtYXJrZXJTZWxlY3Rpb246IG1hcmtlclNlbGVjdGlvbnMsXG4gICAgICBsYWJlbFNlbGVjdGlvbjogbGFiZWxTZWxlY3Rpb25zLFxuICAgICAgYW5ub3RhdGlvblNlbGVjdGlvbnMsXG4gICAgICBjb250ZXh0RGF0YSxcbiAgICAgIHBhdGhzLFxuICAgICAgcHJldmlvdXNDb250ZXh0RGF0YVxuICAgIH0gPSBhbmltYXRpb25EYXRhO1xuICAgIGNvbnN0IFtwYXRoXSA9IHBhdGhzO1xuICAgIHRoaXMucmVzZXRNYXJrZXJBbmltYXRpb24oYW5pbWF0aW9uRGF0YSk7XG4gICAgdGhpcy5yZXNldExhYmVsQW5pbWF0aW9uKGFuaW1hdGlvbkRhdGEpO1xuICAgIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMucmVzZXRQYXRoQW5pbWF0aW9uKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgdGhpcy51cGRhdGVMaW5lUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgICB9O1xuICAgIGNvbnN0IHNraXAgPSAoKSA9PiB7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICAgIHVwZGF0ZSgpO1xuICAgIH07XG4gICAgaWYgKGNvbnRleHREYXRhID09IG51bGwgfHwgcHJldmlvdXNDb250ZXh0RGF0YSA9PSBudWxsKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICAgIG1hcmtlckZhZGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCBcImFkZGVkXCIsIG1hcmtlclNlbGVjdGlvbnMpO1xuICAgICAgcGF0aEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcInBhdGhfcHJvcGVydGllc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBcImFkZFwiLCBwYXRoKTtcbiAgICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9ucyk7XG4gICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImFubm90YXRpb25zXCIsIGFuaW1hdGlvbk1hbmFnZXIsIC4uLmFubm90YXRpb25TZWxlY3Rpb25zKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbnRleHREYXRhLmNyb3NzRmlsdGVyaW5nICE9PSBwcmV2aW91c0NvbnRleHREYXRhLmNyb3NzRmlsdGVyaW5nKSB7XG4gICAgICBza2lwKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZucyA9IHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbihcbiAgICAgIGNvbnRleHREYXRhLFxuICAgICAgcHJldmlvdXNDb250ZXh0RGF0YSxcbiAgICAgIHRoaXMucHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uZGlmZj8uW3RoaXMuaWRdXG4gICAgKTtcbiAgICBpZiAoZm5zID09PSB2b2lkIDApIHtcbiAgICAgIHNraXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGZucy5zdGF0dXMgPT09IFwibm8tb3BcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgXCJwYXRoX3Byb3BlcnRpZXNcIiwgYW5pbWF0aW9uTWFuYWdlciwgW3BhdGhdLCBmbnMuc3Ryb2tlLnBhdGhQcm9wZXJ0aWVzKTtcbiAgICBpZiAoZm5zLnN0YXR1cyA9PT0gXCJhZGRlZFwiKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxpbmVQYXRocyhwYXRocywgY29udGV4dERhdGEpO1xuICAgIH0gZWxzZSBpZiAoZm5zLnN0YXR1cyA9PT0gXCJyZW1vdmVkXCIpIHtcbiAgICAgIHRoaXMudXBkYXRlTGluZVBhdGhzKHBhdGhzLCBwcmV2aW91c0NvbnRleHREYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aE1vdGlvbih0aGlzLmlkLCBcInBhdGhfdXBkYXRlXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFtwYXRoXSwgZm5zLnN0cm9rZS5wYXRoKTtcbiAgICB9XG4gICAgaWYgKGZucy5oYXNNb3Rpb24pIHtcbiAgICAgIG1hcmtlckZhZGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCB2b2lkIDAsIG1hcmtlclNlbGVjdGlvbnMpO1xuICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb25zKTtcbiAgICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiYW5ub3RhdGlvbnNcIiwgYW5pbWF0aW9uTWFuYWdlciwgLi4uYW5ub3RhdGlvblNlbGVjdGlvbnMpO1xuICAgIH1cbiAgfVxuICBpc0xhYmVsRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLmVuYWJsZWQ7XG4gIH1cbiAgZ2V0QmFuZFNjYWxlUGFkZGluZygpIHtcbiAgICByZXR1cm4geyBpbm5lcjogMSwgb3V0ZXI6IDAuMSB9O1xuICB9XG4gIG5vZGVGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgR3JvdXAoKTtcbiAgfVxuICBnZXRGb3JtYXR0ZWRNYXJrZXJTdHlsZShkYXR1bSkge1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHhEb21haW4gPSB0aGlzLmdldFNlcmllc0RvbWFpbihcInhcIiAvKiBYICovKTtcbiAgICBjb25zdCB5RG9tYWluID0gdGhpcy5nZXRTZXJpZXNEb21haW4oXCJ5XCIgLyogWSAqLyk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWFya2VyU3R5bGUodGhpcy5wcm9wZXJ0aWVzLm1hcmtlciwge1xuICAgICAgLi4uZGF0dW1TdHlsZXJQcm9wZXJ0aWVzKGRhdHVtLCB4S2V5LCB5S2V5LCB4RG9tYWluLCB5RG9tYWluKSxcbiAgICAgIGhpZ2hsaWdodGVkOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgY29tcHV0ZUZvY3VzQm91bmRzKG9wdHMpIHtcbiAgICByZXR1cm4gY29tcHV0ZU1hcmtlckZvY3VzQm91bmRzKHRoaXMsIG9wdHMpO1xuICB9XG59O1xuTGluZVNlcmllcy5jbGFzc05hbWUgPSBcIkxpbmVTZXJpZXNcIjtcbkxpbmVTZXJpZXMudHlwZSA9IFwibGluZVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xpbmVTZXJpZXNNb2R1bGUudHNcbnZhciBMaW5lU2VyaWVzTW9kdWxlID0ge1xuICB0eXBlOiBcInNlcmllc1wiLFxuICBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sXG4gIGlkZW50aWZpZXI6IFwibGluZVwiLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgTGluZVNlcmllcyhjdHgpLFxuICBzdGFja2FibGU6IHRydWUsXG4gIHRvb2x0aXBEZWZhdWx0czogeyByYW5nZTogXCJuZWFyZXN0XCIgfSxcbiAgZGVmYXVsdEF4ZXM6IFtcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImxlZnRcIiAvKiBMRUZUICovXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImNhdGVnb3J5XCIgLyogQ0FURUdPUlkgKi8sXG4gICAgICBwb3NpdGlvbjogXCJib3R0b21cIiAvKiBCT1RUT00gKi9cbiAgICB9XG4gIF0sXG4gIHRoZW1lVGVtcGxhdGU6IHtcbiAgICBzZXJpZXM6IHtcbiAgICAgIHRvb2x0aXA6IHsgcG9zaXRpb246IHsgdHlwZTogXCJub2RlXCIgfSB9LFxuICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICBzdHJva2VPcGFjaXR5OiAxLFxuICAgICAgbGluZURhc2g6IFswXSxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxuICAgICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgICB0eXBlOiBcImxpbmVhclwiLFxuICAgICAgICB0ZW5zaW9uOiAxLFxuICAgICAgICBwb3NpdGlvbjogXCJlbmRcIlxuICAgICAgfSxcbiAgICAgIG1hcmtlcjoge1xuICAgICAgICBzaGFwZTogXCJjaXJjbGVcIixcbiAgICAgICAgc2l6ZTogNyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDBcbiAgICAgIH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgZm9udFNpemU6IHsgJHJlZjogXCJmb250U2l6ZVwiIH0sXG4gICAgICAgIGZvbnRGYW1pbHk6IHsgJHJlZjogXCJmb250RmFtaWx5XCIgfSxcbiAgICAgICAgZm9udFdlaWdodDogeyAkcmVmOiBcImZvbnRXZWlnaHRcIiB9LFxuICAgICAgICBjb2xvcjogeyAkcmVmOiBcInRleHRDb2xvclwiIH1cbiAgICAgIH0sXG4gICAgICBlcnJvckJhcjoge1xuICAgICAgICBjYXA6IHtcbiAgICAgICAgICBsZW5ndGhSYXRpbzogMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwYWxldHRlRmFjdG9yeTogKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgbWFya2VyIH0gPSBtYXJrZXJQYWxldHRlRmFjdG9yeShwYXJhbXMpO1xuICAgIHJldHVybiB7IHN0cm9rZTogbWFya2VyLmZpbGwsIG1hcmtlciB9O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL3NjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnRzXG52YXIgU2NhdHRlclNlcmllc0xhYmVsID0gY2xhc3MgZXh0ZW5kcyBMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wbGFjZW1lbnQgPSBcInRvcFwiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTEFCRUxfUExBQ0VNRU5UKVxuXSwgU2NhdHRlclNlcmllc0xhYmVsLnByb3RvdHlwZSwgXCJwbGFjZW1lbnRcIiwgMik7XG52YXIgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuY29sb3JSYW5nZSA9IFtcIiNmZmZmMDBcIiwgXCIjMDBmZjAwXCIsIFwiIzAwMDBmZlwiXTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IFNjYXR0ZXJTZXJpZXNMYWJlbCgpO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTZXJpZXNUb29sdGlwKCk7XG4gICAgLy8gTm8gdmFsaWRhdGlvbi4gTm90IGEgcGFydCBvZiB0aGUgb3B0aW9ucyBjb250cmFjdC5cbiAgICB0aGlzLm1hcmtlciA9IG5ldyBTZXJpZXNNYXJrZXIoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieEZpbHRlcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlGaWx0ZXJLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSX0FSUkFZLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JEb21haW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JSYW5nZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRpdGxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zaGFwZVwiKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNoYXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zaXplXCIpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuZmlsbFwiKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLmZpbGxPcGFjaXR5XCIpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnN0cm9rZVwiKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc3Ryb2tlV2lkdGhcIilcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc3Ryb2tlT3BhY2l0eVwiKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLmxpbmVEYXNoXCIpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLmxpbmVEYXNoT2Zmc2V0XCIpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLml0ZW1TdHlsZXJcIiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIml0ZW1TdHlsZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9zY2F0dGVyU2VyaWVzLnRzXG52YXIgU2NhdHRlclNlcmllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgZGlyZWN0aW9uS2V5czogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX0tFWVMsXG4gICAgICBkaXJlY3Rpb25OYW1lczogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX05BTUVTLFxuICAgICAgcGlja01vZGVzOiBbXG4gICAgICAgIDIgLyogQVhJU19BTElHTkVEICovLFxuICAgICAgICAxIC8qIE5FQVJFU1RfTk9ERSAqLyxcbiAgICAgICAgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL1xuICAgICAgXSxcbiAgICAgIHBhdGhzUGVyU2VyaWVzOiBbXSxcbiAgICAgIGhhc01hcmtlcnM6IHRydWUsXG4gICAgICBtYXJrZXJTZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbjogZmFsc2UsXG4gICAgICBhbmltYXRpb25SZXNldEZuczoge1xuICAgICAgICBtYXJrZXI6IHJlc2V0TWFya2VyRm4sXG4gICAgICAgIGxhYmVsOiByZXNldExhYmVsRm5cbiAgICAgIH0sXG4gICAgICB1c2VzUGxhY2VkTGFiZWxzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jbGlwRm9jdXNCb3ggPSBmYWxzZTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLmNvbG9yU2NhbGUgPSBuZXcgQ29sb3JTY2FsZSgpO1xuICB9XG4gIGdldCBwaWNrTW9kZUF4aXMoKSB7XG4gICAgcmV0dXJuIFwibWFpbi1jYXRlZ29yeVwiO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8IHRoaXMuZGF0YSA9PSBudWxsIHx8ICF0aGlzLnZpc2libGUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeFNjYWxlID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dPy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHsgeFNjYWxlVHlwZSwgeVNjYWxlVHlwZSB9ID0gdGhpcy5nZXRTY2FsZUluZm9ybWF0aW9uKHsgeFNjYWxlLCB5U2NhbGUgfSk7XG4gICAgY29uc3QgY29sb3JTY2FsZVR5cGUgPSB0aGlzLmNvbG9yU2NhbGUudHlwZTtcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHhGaWx0ZXJLZXksIHlGaWx0ZXJLZXksIGxhYmVsS2V5LCBjb2xvcktleSwgY29sb3JEb21haW4sIGNvbG9yUmFuZ2UgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gYXdhaXQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCB0aGlzLmRhdGEsIHtcbiAgICAgIHByb3BzOiBbXG4gICAgICAgIHZhbHVlUHJvcGVydHkoeEtleSwgeFNjYWxlVHlwZSwgeyBpZDogYHhWYWx1ZWAgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkoeUtleSwgeVNjYWxlVHlwZSwgeyBpZDogYHlWYWx1ZWAgfSksXG4gICAgICAgIC4uLnhGaWx0ZXJLZXkgIT0gbnVsbCA/IFt2YWx1ZVByb3BlcnR5KHhGaWx0ZXJLZXksIHhTY2FsZVR5cGUsIHsgaWQ6IFwieEZpbHRlclZhbHVlXCIgfSldIDogW10sXG4gICAgICAgIC4uLnlGaWx0ZXJLZXkgIT0gbnVsbCA/IFt2YWx1ZVByb3BlcnR5KHlGaWx0ZXJLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IFwieUZpbHRlclZhbHVlXCIgfSldIDogW10sXG4gICAgICAgIC4uLmNvbG9yS2V5ID8gW3ZhbHVlUHJvcGVydHkoY29sb3JLZXksIGNvbG9yU2NhbGVUeXBlLCB7IGlkOiBgY29sb3JWYWx1ZWAgfSldIDogW10sXG4gICAgICAgIC4uLmxhYmVsS2V5ID8gW3ZhbHVlUHJvcGVydHkobGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgbGFiZWxWYWx1ZWAgfSldIDogW11cbiAgICAgIF1cbiAgICB9KTtcbiAgICBpZiAoY29sb3JLZXkpIHtcbiAgICAgIGNvbnN0IGNvbG9yS2V5SWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBjb2xvclZhbHVlYCk7XG4gICAgICB0aGlzLmNvbG9yU2NhbGUuZG9tYWluID0gY29sb3JEb21haW4gPz8gcHJvY2Vzc2VkRGF0YS5kb21haW4udmFsdWVzW2NvbG9yS2V5SWR4XSA/PyBbXTtcbiAgICAgIHRoaXMuY29sb3JTY2FsZS5yYW5nZSA9IGNvbG9yUmFuZ2U7XG4gICAgICB0aGlzLmNvbG9yU2NhbGUudXBkYXRlKCk7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gIH1cbiAgeENvb3JkaW5hdGVSYW5nZSh4VmFsdWUsIHBpeGVsU2l6ZSkge1xuICAgIGNvbnN0IHggPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL10uc2NhbGUuY29udmVydCh4VmFsdWUpO1xuICAgIGNvbnN0IHIgPSAwLjUgKiB0aGlzLnByb3BlcnRpZXMuc2l6ZSAqIHBpeGVsU2l6ZTtcbiAgICByZXR1cm4gW3ggLSByLCB4ICsgcl07XG4gIH1cbiAgeUNvb3JkaW5hdGVSYW5nZSh5VmFsdWVzLCBwaXhlbFNpemUpIHtcbiAgICBjb25zdCB5ID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dLnNjYWxlLmNvbnZlcnQoeVZhbHVlc1swXSk7XG4gICAgY29uc3QgciA9IDAuNSAqIHRoaXMucHJvcGVydGllcy5zaXplICogcGl4ZWxTaXplO1xuICAgIHJldHVybiBbeSAtIHIsIHkgKyByXTtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSA9IHRoaXM7XG4gICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICFkYXRhTW9kZWwpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgZGF0YVZhbHVlcyA9IHtcbiAgICAgIFtcInhcIiAvKiBYICovXTogXCJ4VmFsdWVcIixcbiAgICAgIFtcInlcIiAvKiBZICovXTogXCJ5VmFsdWVcIlxuICAgIH07XG4gICAgY29uc3QgaWQgPSBkYXRhVmFsdWVzW2RpcmVjdGlvbl07XG4gICAgY29uc3QgZGF0YURlZiA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQodGhpcywgaWQpO1xuICAgIGNvbnN0IGRvbWFpbiA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgaWQsIFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgaWYgKGRhdGFEZWY/LmRlZi50eXBlID09PSBcInZhbHVlXCIgJiYgZGF0YURlZj8uZGVmLnZhbHVlVHlwZSA9PT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICByZXR1cm4gZG9tYWluO1xuICAgIH1cbiAgICBjb25zdCBjcm9zc0RpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLyA/IFwieVwiIC8qIFkgKi8gOiBcInhcIiAvKiBYICovO1xuICAgIGNvbnN0IGNyb3NzSWQgPSBkYXRhVmFsdWVzW2Nyb3NzRGlyZWN0aW9uXTtcbiAgICBjb25zdCBleHQgPSB0aGlzLmRvbWFpbkZvckNsaXBwZWRSYW5nZShkaXJlY3Rpb24sIFtpZF0sIGNyb3NzSWQsIGZhbHNlKTtcbiAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChleHRlbnQoZXh0KSk7XG4gIH1cbiAgZ2V0U2VyaWVzUmFuZ2UoX2RpcmVjdGlvbiwgdmlzaWJsZVJhbmdlKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9tYWluRm9yVmlzaWJsZVJhbmdlKFwieVwiIC8qIFkgKi8sIFtcInlWYWx1ZVwiXSwgXCJ4VmFsdWVcIiwgdmlzaWJsZVJhbmdlLCBmYWxzZSk7XG4gIH1cbiAgZ2V0VmlzaWJsZUl0ZW1zKHhWaXNpYmxlUmFuZ2UsIHlWaXNpYmxlUmFuZ2UsIG1pblZpc2libGVJdGVtcykge1xuICAgIHJldHVybiB0aGlzLmNvdW50VmlzaWJsZUl0ZW1zKFwieFZhbHVlXCIsIFtcInlWYWx1ZVwiXSwgeFZpc2libGVSYW5nZSwgeVZpc2libGVSYW5nZSwgbWluVmlzaWJsZUl0ZW1zKTtcbiAgfVxuICBjcmVhdGVOb2RlRGF0YSgpIHtcbiAgICBjb25zdCB7IGF4ZXMsIGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSwgY29sb3JTY2FsZSwgdmlzaWJsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHhGaWx0ZXJLZXksIHlGaWx0ZXJLZXksIGxhYmVsS2V5LCBjb2xvcktleSwgeE5hbWUsIHlOYW1lLCBsYWJlbE5hbWUsIG1hcmtlciwgbGFiZWwgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IHBsYWNlbWVudCB9ID0gbGFiZWw7XG4gICAgY29uc3QgYW5jaG9yID0gTWFya2VyLmFuY2hvcihtYXJrZXIuc2hhcGUpO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCEoZGF0YU1vZGVsICYmIHByb2Nlc3NlZERhdGEgJiYgdmlzaWJsZSAmJiB4QXhpcyAmJiB5QXhpcykpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeERhdGFWYWx1ZXMgPSBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYHhWYWx1ZWAsIHByb2Nlc3NlZERhdGEpO1xuICAgIGNvbnN0IHlEYXRhVmFsdWVzID0gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGB5VmFsdWVgLCBwcm9jZXNzZWREYXRhKTtcbiAgICBjb25zdCBjb2xvckRhdGFWYWx1ZXMgPSBjb2xvcktleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGBjb2xvclZhbHVlYCwgcHJvY2Vzc2VkRGF0YSkgOiB2b2lkIDA7XG4gICAgY29uc3QgbGFiZWxEYXRhVmFsdWVzID0gbGFiZWxLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBgbGFiZWxWYWx1ZWAsIHByb2Nlc3NlZERhdGEpIDogdm9pZCAwO1xuICAgIGNvbnN0IHhGaWx0ZXJEYXRhVmFsdWVzID0geEZpbHRlcktleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGB4RmlsdGVyVmFsdWVgLCBwcm9jZXNzZWREYXRhKSA6IHZvaWQgMDtcbiAgICBjb25zdCB5RmlsdGVyRGF0YVZhbHVlcyA9IHlGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBgeUZpbHRlclZhbHVlYCwgcHJvY2Vzc2VkRGF0YSkgOiB2b2lkIDA7XG4gICAgY29uc3QgeFNjYWxlID0geEF4aXMuc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0geUF4aXMuc2NhbGU7XG4gICAgY29uc3QgeE9mZnNldCA9ICh4U2NhbGUuYmFuZHdpZHRoID8/IDApIC8gMjtcbiAgICBjb25zdCB5T2Zmc2V0ID0gKHlTY2FsZS5iYW5kd2lkdGggPz8gMCkgLyAyO1xuICAgIGNvbnN0IG5vZGVEYXRhID0gW107XG4gICAgY29uc3QgZm9udDIgPSBsYWJlbC5nZXRGb250KCk7XG4gICAgY29uc3QgdGV4dE1lYXN1cmVyID0gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5nZXRNZWFzdXJlcih7IGZvbnQ6IGZvbnQyIH0pO1xuICAgIGNvbnN0IHJhd0RhdGEgPSBwcm9jZXNzZWREYXRhLmRhdGFTb3VyY2VzLmdldCh0aGlzLmlkKSA/PyBbXTtcbiAgICByYXdEYXRhLmZvckVhY2goKGRhdHVtLCBkYXR1bUluZGV4KSA9PiB7XG4gICAgICBjb25zdCB4RGF0dW0gPSB4RGF0YVZhbHVlc1tkYXR1bUluZGV4XTtcbiAgICAgIGNvbnN0IHlEYXR1bSA9IHlEYXRhVmFsdWVzW2RhdHVtSW5kZXhdO1xuICAgICAgY29uc3QgeCA9IHhTY2FsZS5jb252ZXJ0KHhEYXR1bSkgKyB4T2Zmc2V0O1xuICAgICAgY29uc3QgeSA9IHlTY2FsZS5jb252ZXJ0KHlEYXR1bSkgKyB5T2Zmc2V0O1xuICAgICAgY29uc3Qgc2VsZWN0ZWQgPSB4RmlsdGVyRGF0YVZhbHVlcyAhPSBudWxsICYmIHlGaWx0ZXJEYXRhVmFsdWVzICE9IG51bGwgPyB4RmlsdGVyRGF0YVZhbHVlc1tkYXR1bUluZGV4XSA9PT0geERhdHVtICYmIHlGaWx0ZXJEYXRhVmFsdWVzW2RhdHVtSW5kZXhdID09PSB5RGF0dW0gOiB2b2lkIDA7XG4gICAgICBjb25zdCBsYWJlbFRleHQgPSB0aGlzLmdldExhYmVsVGV4dChsYWJlbCwge1xuICAgICAgICB2YWx1ZTogbGFiZWxEYXRhVmFsdWVzICE9IG51bGwgPyBsYWJlbERhdGFWYWx1ZXM/LltkYXR1bUluZGV4XSA6IHlEYXR1bSxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHhLZXksXG4gICAgICAgIHlLZXksXG4gICAgICAgIGxhYmVsS2V5LFxuICAgICAgICB4TmFtZSxcbiAgICAgICAgeU5hbWUsXG4gICAgICAgIGxhYmVsTmFtZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBzaXplID0gdGV4dE1lYXN1cmVyLm1lYXN1cmVUZXh0KGxhYmVsVGV4dCk7XG4gICAgICBjb25zdCBmaWxsID0gY29sb3JEYXRhVmFsdWVzICE9IG51bGwgPyBjb2xvclNjYWxlLmNvbnZlcnQoY29sb3JEYXRhVmFsdWVzW2RhdHVtSW5kZXhdKSA6IHZvaWQgMDtcbiAgICAgIG5vZGVEYXRhLnB1c2goe1xuICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGRhdHVtSW5kZXgsXG4gICAgICAgIHhWYWx1ZTogeERhdHVtLFxuICAgICAgICB5VmFsdWU6IHlEYXR1bSxcbiAgICAgICAgY2FwRGVmYXVsdHM6IHsgbGVuZ3RoUmF0aW9NdWx0aXBsaWVyOiBtYXJrZXIuZ2V0RGlhbWV0ZXIoKSwgbGVuZ3RoTWF4OiBJbmZpbml0eSB9LFxuICAgICAgICBwb2ludDogeyB4LCB5LCBzaXplOiBtYXJrZXIuc2l6ZSB9LFxuICAgICAgICBtaWRQb2ludDogeyB4LCB5IH0sXG4gICAgICAgIGZpbGwsXG4gICAgICAgIGxhYmVsOiB7IHRleHQ6IGxhYmVsVGV4dCwgLi4uc2l6ZSB9LFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgc2VsZWN0ZWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICBub2RlRGF0YSxcbiAgICAgIGxhYmVsRGF0YTogbm9kZURhdGEsXG4gICAgICBzY2FsZXM6IHRoaXMuY2FsY3VsYXRlU2NhbGluZygpLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlXG4gICAgfTtcbiAgfVxuICBpc1BhdGhPclNlbGVjdGlvbkRpcnR5KCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubWFya2VyLmlzRGlydHkoKTtcbiAgfVxuICBnZXRMYWJlbERhdGEoKSB7XG4gICAgaWYgKCF0aGlzLmlzTGFiZWxFbmFibGVkKCkpXG4gICAgICByZXR1cm4gW107XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dE5vZGVEYXRhPy5sYWJlbERhdGEgPz8gW107XG4gIH1cbiAgdXBkYXRlTWFya2VyU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBjb25zdCB7IG5vZGVEYXRhLCBtYXJrZXJTZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgaWYgKHRoaXMucHJvcGVydGllcy5tYXJrZXIuaXNEaXJ0eSgpKSB7XG4gICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJTZWxlY3Rpb24udXBkYXRlKHRoaXMucHJvcGVydGllcy5tYXJrZXIuZW5hYmxlZCA/IG5vZGVEYXRhIDogW10pO1xuICB9XG4gIGdldE1hcmtlckl0ZW1CYXNlU3R5bGUoaGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25zdCB7IHByb3BlcnRpZXMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBtYXJrZXIgfSA9IHByb3BlcnRpZXM7XG4gICAgY29uc3QgaGlnaGxpZ2h0U3R5bGUgPSBoaWdobGlnaHRlZCA/IHByb3BlcnRpZXMuaGlnaGxpZ2h0U3R5bGUuaXRlbSA6IHZvaWQgMDtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbDogaGlnaGxpZ2h0U3R5bGU/LmZpbGwgPz8gbWFya2VyLmZpbGwsXG4gICAgICBmaWxsT3BhY2l0eTogaGlnaGxpZ2h0U3R5bGU/LmZpbGxPcGFjaXR5ID8/IG1hcmtlci5maWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZTogaGlnaGxpZ2h0U3R5bGU/LnN0cm9rZSA/PyBtYXJrZXIuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IGhpZ2hsaWdodFN0eWxlPy5zdHJva2VXaWR0aCA/PyBtYXJrZXIuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VPcGFjaXR5OiBoaWdobGlnaHRTdHlsZT8uc3Ryb2tlT3BhY2l0eSA/PyBtYXJrZXIuc3Ryb2tlT3BhY2l0eSxcbiAgICAgIGxpbmVEYXNoOiBoaWdobGlnaHRTdHlsZT8ubGluZURhc2ggPz8gbWFya2VyLmxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IGhpZ2hsaWdodFN0eWxlPy5saW5lRGFzaE9mZnNldCA/PyBtYXJrZXIubGluZURhc2hPZmZzZXRcbiAgICB9O1xuICB9XG4gIGdldE1hcmtlckl0ZW1TdHlsZU92ZXJyaWRlcyhkYXR1bUlkLCBkYXR1bSwgZm9ybWF0LCBoaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHsgaWQ6IHNlcmllc0lkLCBwcm9wZXJ0aWVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgbGFiZWxLZXksIG1hcmtlciB9ID0gcHJvcGVydGllcztcbiAgICBjb25zdCB7IGl0ZW1TdHlsZXIgfSA9IG1hcmtlcjtcbiAgICBpZiAoaXRlbVN0eWxlciA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLmNhY2hlZERhdHVtQ2FsbGJhY2soY3JlYXRlRGF0dW1JZChkYXR1bUlkLCBoaWdobGlnaHRlZCA/IFwiaGlnaGxpZ2h0XCIgOiBcIm5vZGVcIiksICgpID0+IHtcbiAgICAgIHJldHVybiBpdGVtU3R5bGVyKHtcbiAgICAgICAgc2VyaWVzSWQsXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB4S2V5LFxuICAgICAgICB5S2V5LFxuICAgICAgICBsYWJlbEtleSxcbiAgICAgICAgaGlnaGxpZ2h0ZWQsXG4gICAgICAgIC4uLmZvcm1hdFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlTWFya2VyTm9kZXMob3B0cykge1xuICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uLCBpc0hpZ2hsaWdodDogaGlnaGxpZ2h0ZWQgfSA9IG9wdHM7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBsYWJlbEtleSwgbWFya2VyLCBoaWdobGlnaHRTdHlsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGJhc2VTdHlsZSA9IG1lcmdlRGVmYXVsdHMoaGlnaGxpZ2h0ZWQgJiYgaGlnaGxpZ2h0U3R5bGUuaXRlbSwgbWFya2VyLmdldFN0eWxlKCkpO1xuICAgIG1hcmtlclNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVNYXJrZXJTdHlsZShub2RlLCBtYXJrZXIsIHsgZGF0dW0sIGhpZ2hsaWdodGVkLCB4S2V5LCB5S2V5LCBsYWJlbEtleSB9LCBiYXNlU3R5bGUsIHtcbiAgICAgICAgc2VsZWN0ZWQ6IGRhdHVtLnNlbGVjdGVkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoIWhpZ2hsaWdodGVkKSB7XG4gICAgICBtYXJrZXIubWFya0NsZWFuKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBsYWNlZExhYmVsRGF0YShsYWJlbERhdGEpIHtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uLnVwZGF0ZShcbiAgICAgIGxhYmVsRGF0YS5tYXAoKHYpID0+ICh7XG4gICAgICAgIC4uLnYuZGF0dW0sXG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgeDogdi54LFxuICAgICAgICAgIHk6IHYueSxcbiAgICAgICAgICBzaXplOiB2LmRhdHVtLnBvaW50LnNpemVcbiAgICAgICAgfVxuICAgICAgfSkpLFxuICAgICAgKHRleHQyKSA9PiB7XG4gICAgICAgIHRleHQyLnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLnVwZGF0ZUxhYmVsTm9kZXMoeyBsYWJlbFNlbGVjdGlvbjogdGhpcy5sYWJlbFNlbGVjdGlvbiB9KTtcbiAgfVxuICB1cGRhdGVMYWJlbE5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IGxhYmVsIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgb3B0cy5sYWJlbFNlbGVjdGlvbi5lYWNoKCh0ZXh0MiwgZGF0dW0pID0+IHtcbiAgICAgIHRleHQyLnRleHQgPSBkYXR1bS5sYWJlbC50ZXh0O1xuICAgICAgdGV4dDIuZmlsbCA9IGxhYmVsLmNvbG9yO1xuICAgICAgdGV4dDIueCA9IGRhdHVtLnBvaW50Py54ID8/IDA7XG4gICAgICB0ZXh0Mi55ID0gZGF0dW0ucG9pbnQ/LnkgPz8gMDtcbiAgICAgIHRleHQyLmZvbnRTdHlsZSA9IGxhYmVsLmZvbnRTdHlsZTtcbiAgICAgIHRleHQyLmZvbnRXZWlnaHQgPSBsYWJlbC5mb250V2VpZ2h0O1xuICAgICAgdGV4dDIuZm9udFNpemUgPSBsYWJlbC5mb250U2l6ZTtcbiAgICAgIHRleHQyLmZvbnRGYW1pbHkgPSBsYWJlbC5mb250RmFtaWx5O1xuICAgICAgdGV4dDIudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICB0ZXh0Mi50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuICAgIH0pO1xuICB9XG4gIGdldFRvb2x0aXBDb250ZW50KG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHsgaWQ6IHNlcmllc0lkLCBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEsIGF4ZXMsIHByb3BlcnRpZXMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB4S2V5LCB4TmFtZSwgeUtleSwgeU5hbWUsIGxhYmVsS2V5LCBsYWJlbE5hbWUsIHRpdGxlLCB0b29sdGlwIH0gPSBwcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCFkYXRhTW9kZWwgfHwgIXByb2Nlc3NlZERhdGEgfHwgIXhBeGlzIHx8ICF5QXhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGRhdHVtSW5kZXggfSA9IG5vZGVEYXR1bTtcbiAgICBjb25zdCBkYXR1bSA9IHByb2Nlc3NlZERhdGEuZGF0YVNvdXJjZXMuZ2V0KHRoaXMuaWQpPy5bZGF0dW1JbmRleF07XG4gICAgY29uc3QgeFZhbHVlID0gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGB4VmFsdWVgLCBwcm9jZXNzZWREYXRhKVtkYXR1bUluZGV4XTtcbiAgICBjb25zdCB5VmFsdWUgPSBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYHlWYWx1ZWAsIHByb2Nlc3NlZERhdGEpW2RhdHVtSW5kZXhdO1xuICAgIGlmICh4VmFsdWUgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmdldE1hcmtlckl0ZW1CYXNlU3R5bGUoZmFsc2UpO1xuICAgIE9iamVjdC5hc3NpZ24oZm9ybWF0LCB0aGlzLmdldE1hcmtlckl0ZW1TdHlsZU92ZXJyaWRlcyhTdHJpbmcoZGF0dW1JbmRleCksIGRhdHVtLCBmb3JtYXQsIGZhbHNlKSk7XG4gICAgcmV0dXJuIHRvb2x0aXAuZm9ybWF0VG9vbHRpcChcbiAgICAgIHtcbiAgICAgICAgc3ltYm9sOiB0aGlzLmxlZ2VuZEl0ZW1TeW1ib2woKSxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGRhdGE6IFtcbiAgICAgICAgICB7IGxhYmVsOiB4TmFtZSwgZmFsbGJhY2tMYWJlbDogeEtleSwgdmFsdWU6IHhBeGlzLmZvcm1hdERhdHVtKHhWYWx1ZSkgfSxcbiAgICAgICAgICB7IGxhYmVsOiB5TmFtZSwgZmFsbGJhY2tMYWJlbDogeUtleSwgdmFsdWU6IHlBeGlzLmZvcm1hdERhdHVtKHlWYWx1ZSkgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHRpdGxlOiB5TmFtZSxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlLZXksXG4gICAgICAgIHlOYW1lLFxuICAgICAgICBsYWJlbEtleSxcbiAgICAgICAgbGFiZWxOYW1lLFxuICAgICAgICAuLi5mb3JtYXQsXG4gICAgICAgIC4uLnRoaXMuZ2V0TW9kdWxlVG9vbHRpcFBhcmFtcygpXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBsZWdlbmRJdGVtU3ltYm9sKCkge1xuICAgIGNvbnN0IHsgc2hhcGUsIGZpbGwsIHN0cm9rZTogc3Ryb2tlMiwgZmlsbE9wYWNpdHksIHN0cm9rZU9wYWNpdHksIHN0cm9rZVdpZHRoLCBsaW5lRGFzaCwgbGluZURhc2hPZmZzZXQgfSA9IHRoaXMucHJvcGVydGllcy5tYXJrZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcmtlcjoge1xuICAgICAgICBzaGFwZSxcbiAgICAgICAgZmlsbDogZmlsbCA/PyBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgICAgc3Ryb2tlOiBzdHJva2UyID8/IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuICAgICAgICBmaWxsT3BhY2l0eSxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIGxpbmVEYXNoLFxuICAgICAgICBsaW5lRGFzaE9mZnNldFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSB7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8IGxlZ2VuZFR5cGUgIT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7IHlLZXk6IGl0ZW1JZCwgeU5hbWUsIHRpdGxlLCBzaG93SW5MZWdlbmQgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7XG4gICAgICBpZDogc2VyaWVzSWQsXG4gICAgICBjdHg6IHsgbGVnZW5kTWFuYWdlciB9LFxuICAgICAgdmlzaWJsZVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGxlZ2VuZFR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIHNlcmllc0lkLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlICYmIGxlZ2VuZE1hbmFnZXIuZ2V0SXRlbUVuYWJsZWQoeyBzZXJpZXNJZCwgaXRlbUlkIH0pLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IHRpdGxlID8/IHlOYW1lID8/IGl0ZW1JZFxuICAgICAgICB9LFxuICAgICAgICBzeW1ib2w6IHRoaXMubGVnZW5kSXRlbVN5bWJvbCgpLFxuICAgICAgICBoaWRlSW5MZWdlbmQ6ICFzaG93SW5MZWdlbmRcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpIHtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24sIGFubm90YXRpb25TZWxlY3Rpb25zIH0gPSBkYXRhO1xuICAgIG1hcmtlclNjYWxlSW5BbmltYXRpb24odGhpcywgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbWFya2VyU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJhbm5vdGF0aW9uc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCAuLi5hbm5vdGF0aW9uU2VsZWN0aW9ucyk7XG4gIH1cbiAgaXNMYWJlbEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5sYWJlbC5lbmFibGVkO1xuICB9XG4gIG5vZGVGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgR3JvdXAoKTtcbiAgfVxuICBnZXRGb3JtYXR0ZWRNYXJrZXJTdHlsZShkYXR1bSkge1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgbGFiZWxLZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICByZXR1cm4gdGhpcy5nZXRNYXJrZXJTdHlsZSh0aGlzLnByb3BlcnRpZXMubWFya2VyLCB7IGRhdHVtLCB4S2V5LCB5S2V5LCBsYWJlbEtleSwgaGlnaGxpZ2h0ZWQ6IHRydWUgfSk7XG4gIH1cbiAgY29tcHV0ZUZvY3VzQm91bmRzKG9wdHMpIHtcbiAgICByZXR1cm4gY29tcHV0ZU1hcmtlckZvY3VzQm91bmRzKHRoaXMsIG9wdHMpO1xuICB9XG59O1xuU2NhdHRlclNlcmllcy5jbGFzc05hbWUgPSBcIlNjYXR0ZXJTZXJpZXNcIjtcblNjYXR0ZXJTZXJpZXMudHlwZSA9IFwic2NhdHRlclwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL3NjYXR0ZXJTZXJpZXNNb2R1bGUudHNcbnZhciBTY2F0dGVyU2VyaWVzTW9kdWxlID0ge1xuICB0eXBlOiBcInNlcmllc1wiLFxuICBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sXG4gIGlkZW50aWZpZXI6IFwic2NhdHRlclwiLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgU2NhdHRlclNlcmllcyhjdHgpLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwibmVhcmVzdFwiIH0sXG4gIGRlZmF1bHRBeGVzOiBbXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJib3R0b21cIiAvKiBCT1RUT00gKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIgLyogTlVNQkVSICovLFxuICAgICAgcG9zaXRpb246IFwibGVmdFwiIC8qIExFRlQgKi9cbiAgICB9XG4gIF0sXG4gIHRoZW1lVGVtcGxhdGU6IHtcbiAgICBzZXJpZXM6IHtcbiAgICAgIHNoYXBlOiBcImNpcmNsZVwiLFxuICAgICAgc2l6ZTogNyxcbiAgICAgIGZpbGxPcGFjaXR5OiAwLjgsXG4gICAgICB0b29sdGlwOiB7IHBvc2l0aW9uOiB7IHR5cGU6IFwibm9kZVwiIH0gfSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmb250U2l6ZTogeyAkcmVmOiBcImZvbnRTaXplXCIgfSxcbiAgICAgICAgZm9udEZhbWlseTogeyAkcmVmOiBcImZvbnRGYW1pbHlcIiB9LFxuICAgICAgICBmb250V2VpZ2h0OiB7ICRyZWY6IFwiZm9udFdlaWdodFwiIH0sXG4gICAgICAgIGNvbG9yOiB7ICRyZWY6IFwidGV4dENvbG9yXCIgfVxuICAgICAgfSxcbiAgICAgIGVycm9yQmFyOiB7XG4gICAgICAgIGNhcDoge1xuICAgICAgICAgIGxlbmd0aFJhdGlvOiAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBhbGV0dGVGYWN0b3J5OiBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2VjdG9yQm94LnRzXG52YXIgU2VjdG9yQm94ID0gY2xhc3MgX1NlY3RvckJveCB7XG4gIGNvbnN0cnVjdG9yKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMpIHtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgIHRoaXMuZW5kQW5nbGUgPSBlbmRBbmdsZTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXM7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IF9TZWN0b3JCb3goc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyk7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnRBbmdsZSA9PT0gb3RoZXIuc3RhcnRBbmdsZSAmJiB0aGlzLmVuZEFuZ2xlID09PSBvdGhlci5lbmRBbmdsZSAmJiB0aGlzLmlubmVyUmFkaXVzID09PSBvdGhlci5pbm5lclJhZGl1cyAmJiB0aGlzLm91dGVyUmFkaXVzID09PSBvdGhlci5vdXRlclJhZGl1cztcbiAgfVxuICBbaW50ZXJwb2xhdGVdKG90aGVyLCBkKSB7XG4gICAgcmV0dXJuIG5ldyBfU2VjdG9yQm94KFxuICAgICAgdGhpcy5zdGFydEFuZ2xlICogKDEgLSBkKSArIG90aGVyLnN0YXJ0QW5nbGUgKiBkLFxuICAgICAgdGhpcy5lbmRBbmdsZSAqICgxIC0gZCkgKyBvdGhlci5lbmRBbmdsZSAqIGQsXG4gICAgICB0aGlzLmlubmVyUmFkaXVzICogKDEgLSBkKSArIG90aGVyLmlubmVyUmFkaXVzICogZCxcbiAgICAgIHRoaXMub3V0ZXJSYWRpdXMgKiAoMSAtIGQpICsgb3RoZXIub3V0ZXJSYWRpdXMgKiBkXG4gICAgKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvdXRpbC9zZWN0b3IudHNcbmZ1bmN0aW9uIHNlY3RvckJveCh7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSkge1xuICBsZXQgeDAgPSBJbmZpbml0eTtcbiAgbGV0IHkwID0gSW5maW5pdHk7XG4gIGxldCB4MSA9IC1JbmZpbml0eTtcbiAgbGV0IHkxID0gLUluZmluaXR5O1xuICBjb25zdCBhZGRQb2ludCA9ICh4LCB5KSA9PiB7XG4gICAgeDAgPSBNYXRoLm1pbih4LCB4MCk7XG4gICAgeTAgPSBNYXRoLm1pbih5LCB5MCk7XG4gICAgeDEgPSBNYXRoLm1heCh4LCB4MSk7XG4gICAgeTEgPSBNYXRoLm1heCh5LCB5MSk7XG4gIH07XG4gIGFkZFBvaW50KGlubmVyUmFkaXVzICogTWF0aC5jb3Moc3RhcnRBbmdsZSksIGlubmVyUmFkaXVzICogTWF0aC5zaW4oc3RhcnRBbmdsZSkpO1xuICBhZGRQb2ludChpbm5lclJhZGl1cyAqIE1hdGguY29zKGVuZEFuZ2xlKSwgaW5uZXJSYWRpdXMgKiBNYXRoLnNpbihlbmRBbmdsZSkpO1xuICBhZGRQb2ludChvdXRlclJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpLCBvdXRlclJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpKTtcbiAgYWRkUG9pbnQob3V0ZXJSYWRpdXMgKiBNYXRoLmNvcyhlbmRBbmdsZSksIG91dGVyUmFkaXVzICogTWF0aC5zaW4oZW5kQW5nbGUpKTtcbiAgaWYgKGlzQmV0d2VlbkFuZ2xlcygwLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICBhZGRQb2ludChvdXRlclJhZGl1cywgMCk7XG4gIH1cbiAgaWYgKGlzQmV0d2VlbkFuZ2xlcyhNYXRoLlBJICogMC41LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICBhZGRQb2ludCgwLCBvdXRlclJhZGl1cyk7XG4gIH1cbiAgaWYgKGlzQmV0d2VlbkFuZ2xlcyhNYXRoLlBJLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICBhZGRQb2ludCgtb3V0ZXJSYWRpdXMsIDApO1xuICB9XG4gIGlmIChpc0JldHdlZW5BbmdsZXMoTWF0aC5QSSAqIDEuNSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgYWRkUG9pbnQoMCwgLW91dGVyUmFkaXVzKTtcbiAgfVxuICByZXR1cm4gbmV3IEJCb3goeDAsIHkwLCB4MSAtIHgwLCB5MSAtIHkwKTtcbn1cbmZ1bmN0aW9uIGlzUG9pbnRJblNlY3Rvcih4LCB5LCBzZWN0b3IpIHtcbiAgY29uc3QgcmFkaXVzID0gTWF0aC5zcXJ0KE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikpO1xuICBjb25zdCB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gc2VjdG9yO1xuICBpZiAoc2VjdG9yLnN0YXJ0QW5nbGUgPT09IHNlY3Rvci5lbmRBbmdsZSB8fCByYWRpdXMgPCBNYXRoLm1pbihpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMpIHx8IHJhZGl1cyA+IE1hdGgubWF4KGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZUFuZ2xlMTgwKHNlY3Rvci5zdGFydEFuZ2xlKTtcbiAgY29uc3QgZW5kQW5nbGUgPSBub3JtYWxpemVBbmdsZTE4MChzZWN0b3IuZW5kQW5nbGUpO1xuICBjb25zdCBhbmdsZTIgPSBNYXRoLmF0YW4yKHksIHgpO1xuICByZXR1cm4gc3RhcnRBbmdsZSA8IGVuZEFuZ2xlID8gYW5nbGUyIDw9IGVuZEFuZ2xlICYmIGFuZ2xlMiA+PSBzdGFydEFuZ2xlIDogYW5nbGUyIDw9IGVuZEFuZ2xlICYmIGFuZ2xlMiA+PSAtTWF0aC5QSSB8fCBhbmdsZTIgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZTIgPD0gTWF0aC5QSTtcbn1cbmZ1bmN0aW9uIGxpbmVDb2xsaWRlc1NlY3RvcihsaW5lLCBzZWN0b3IpIHtcbiAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSBzZWN0b3I7XG4gIGNvbnN0IG91dGVyU3RhcnQgPSB7IHg6IG91dGVyUmFkaXVzICogTWF0aC5jb3Moc3RhcnRBbmdsZSksIHk6IG91dGVyUmFkaXVzICogTWF0aC5zaW4oc3RhcnRBbmdsZSkgfTtcbiAgY29uc3Qgb3V0ZXJFbmQgPSB7IHg6IG91dGVyUmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpLCB5OiBvdXRlclJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKSB9O1xuICBjb25zdCBpbm5lclN0YXJ0ID0gaW5uZXJSYWRpdXMgPT09IDAgPyB7IHg6IDAsIHk6IDAgfSA6IHsgeDogaW5uZXJSYWRpdXMgKiBNYXRoLmNvcyhzdGFydEFuZ2xlKSwgeTogaW5uZXJSYWRpdXMgKiBNYXRoLnNpbihzdGFydEFuZ2xlKSB9O1xuICBjb25zdCBpbm5lckVuZCA9IGlubmVyUmFkaXVzID09PSAwID8geyB4OiAwLCB5OiAwIH0gOiB7IHg6IGlubmVyUmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpLCB5OiBpbm5lclJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKSB9O1xuICByZXR1cm4gc2VnbWVudEludGVyc2VjdGlvbihcbiAgICBsaW5lLnN0YXJ0LngsXG4gICAgbGluZS5zdGFydC55LFxuICAgIGxpbmUuZW5kLngsXG4gICAgbGluZS5lbmQueSxcbiAgICBvdXRlclN0YXJ0LngsXG4gICAgb3V0ZXJTdGFydC55LFxuICAgIGlubmVyU3RhcnQueCxcbiAgICBpbm5lclN0YXJ0LnlcbiAgKSB8fCBzZWdtZW50SW50ZXJzZWN0aW9uKFxuICAgIGxpbmUuc3RhcnQueCxcbiAgICBsaW5lLnN0YXJ0LnksXG4gICAgbGluZS5lbmQueCxcbiAgICBsaW5lLmVuZC55LFxuICAgIG91dGVyRW5kLngsXG4gICAgb3V0ZXJFbmQueSxcbiAgICBpbm5lckVuZC54LFxuICAgIGlubmVyRW5kLnlcbiAgKSB8fCBhcmNJbnRlcnNlY3Rpb25zKFxuICAgIDAsXG4gICAgMCxcbiAgICBvdXRlclJhZGl1cyxcbiAgICBzdGFydEFuZ2xlLFxuICAgIGVuZEFuZ2xlLFxuICAgIHRydWUsXG4gICAgbGluZS5zdGFydC54LFxuICAgIGxpbmUuc3RhcnQueSxcbiAgICBsaW5lLmVuZC54LFxuICAgIGxpbmUuZW5kLnlcbiAgKTtcbn1cbmZ1bmN0aW9uIGJveENvbGxpZGVzU2VjdG9yKGJveCwgc2VjdG9yKSB7XG4gIGNvbnN0IHRvcExlZnQgPSB7IHg6IGJveC54LCB5OiBib3gueSB9O1xuICBjb25zdCB0b3BSaWdodCA9IHsgeDogYm94LnggKyBib3gud2lkdGgsIHk6IGJveC55IH07XG4gIGNvbnN0IGJvdHRvbUxlZnQgPSB7IHg6IGJveC54LCB5OiBib3gueSArIGJveC5oZWlnaHQgfTtcbiAgY29uc3QgYm90dG9tUmlnaHQgPSB7IHg6IGJveC54ICsgYm94LndpZHRoLCB5OiBib3gueSArIGJveC5oZWlnaHQgfTtcbiAgcmV0dXJuIGxpbmVDb2xsaWRlc1NlY3Rvcih7IHN0YXJ0OiB0b3BMZWZ0LCBlbmQ6IHRvcFJpZ2h0IH0sIHNlY3RvcikgfHwgbGluZUNvbGxpZGVzU2VjdG9yKHsgc3RhcnQ6IGJvdHRvbUxlZnQsIGVuZDogYm90dG9tUmlnaHQgfSwgc2VjdG9yKTtcbn1cbmZ1bmN0aW9uIHJhZGlpU2NhbGluZ0ZhY3RvcihyLCBzd2VlcCwgYSwgYikge1xuICBpZiAoYSA9PT0gMCAmJiBiID09PSAwKVxuICAgIHJldHVybiAwO1xuICBjb25zdCBmczEgPSBNYXRoLmFzaW4oTWF0aC5hYnMoMSAqIGEpIC8gKHIgKyAxICogYSkpICsgTWF0aC5hc2luKE1hdGguYWJzKDEgKiBiKSAvIChyICsgMSAqIGIpKSAtIHN3ZWVwO1xuICBpZiAoZnMxIDwgMClcbiAgICByZXR1cm4gMTtcbiAgbGV0IHN0YXJ0MiA9IDA7XG4gIGxldCBlbmQyID0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcbiAgICBjb25zdCBzID0gKHN0YXJ0MiArIGVuZDIpIC8gMjtcbiAgICBjb25zdCBmcyA9IE1hdGguYXNpbihNYXRoLmFicyhzICogYSkgLyAociArIHMgKiBhKSkgKyBNYXRoLmFzaW4oTWF0aC5hYnMocyAqIGIpIC8gKHIgKyBzICogYikpIC0gc3dlZXA7XG4gICAgaWYgKGZzIDwgMCkge1xuICAgICAgc3RhcnQyID0gcztcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kMiA9IHM7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFydDI7XG59XG52YXIgZGVsdGEyID0gMWUtNjtcbmZ1bmN0aW9uIGNsb2Nrd2lzZUFuZ2xlKGFuZ2xlMiwgcmVsYXRpdmVUb1N0YXJ0QW5nbGUpIHtcbiAgaWYgKGFuZ2xlQmV0d2VlbihhbmdsZTIsIHJlbGF0aXZlVG9TdGFydEFuZ2xlKSA8IGRlbHRhMikge1xuICAgIHJldHVybiByZWxhdGl2ZVRvU3RhcnRBbmdsZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9ybWFsaXplQW5nbGUzNjAoYW5nbGUyIC0gcmVsYXRpdmVUb1N0YXJ0QW5nbGUpICsgcmVsYXRpdmVUb1N0YXJ0QW5nbGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsb2Nrd2lzZUFuZ2xlcyhzdGFydEFuZ2xlLCBlbmRBbmdsZSwgcmVsYXRpdmVUb1N0YXJ0QW5nbGUgPSAwKSB7XG4gIGNvbnN0IGZ1bGxQaWUgPSBNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpID49IDIgKiBNYXRoLlBJO1xuICBjb25zdCBzd2VlcEFuZ2xlID0gZnVsbFBpZSA/IDIgKiBNYXRoLlBJIDogbm9ybWFsaXplQW5nbGUzNjAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgc3RhcnRBbmdsZSA9IGNsb2Nrd2lzZUFuZ2xlKHN0YXJ0QW5nbGUsIHJlbGF0aXZlVG9TdGFydEFuZ2xlKTtcbiAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgc3dlZXBBbmdsZTtcbiAgcmV0dXJuIHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUgfTtcbn1cbmZ1bmN0aW9uIGFyY1JhZGlhbExpbmVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbGlwQW5nbGUpIHtcbiAgY29uc3Qgc2luQSA9IE1hdGguc2luKGNsaXBBbmdsZSk7XG4gIGNvbnN0IGNvc0EgPSBNYXRoLmNvcyhjbGlwQW5nbGUpO1xuICBjb25zdCBjID0gY3ggKiogMiArIGN5ICoqIDIgLSByICoqIDI7XG4gIGxldCBwMHg7XG4gIGxldCBwMHk7XG4gIGxldCBwMXg7XG4gIGxldCBwMXk7XG4gIGlmIChjb3NBID4gMC41KSB7XG4gICAgY29uc3QgdGFuQSA9IHNpbkEgLyBjb3NBO1xuICAgIGNvbnN0IGEgPSAxICsgdGFuQSAqKiAyO1xuICAgIGNvbnN0IGIgPSAtMiAqIChjeCArIGN5ICogdGFuQSk7XG4gICAgY29uc3QgZCA9IGIgKiogMiAtIDQgKiBhICogYztcbiAgICBpZiAoZCA8IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeDAgPSAoLWIgKyBNYXRoLnNxcnQoZCkpIC8gKDIgKiBhKTtcbiAgICBjb25zdCB4MSA9ICgtYiAtIE1hdGguc3FydChkKSkgLyAoMiAqIGEpO1xuICAgIHAweCA9IHgwO1xuICAgIHAweSA9IHgwICogdGFuQTtcbiAgICBwMXggPSB4MTtcbiAgICBwMXkgPSB4MSAqIHRhbkE7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY290QSA9IGNvc0EgLyBzaW5BO1xuICAgIGNvbnN0IGEgPSAxICsgY290QSAqKiAyO1xuICAgIGNvbnN0IGIgPSAtMiAqIChjeSArIGN4ICogY290QSk7XG4gICAgY29uc3QgZCA9IGIgKiogMiAtIDQgKiBhICogYztcbiAgICBpZiAoZCA8IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeTAgPSAoLWIgKyBNYXRoLnNxcnQoZCkpIC8gKDIgKiBhKTtcbiAgICBjb25zdCB5MSA9ICgtYiAtIE1hdGguc3FydChkKSkgLyAoMiAqIGEpO1xuICAgIHAweCA9IHkwICogY290QTtcbiAgICBwMHkgPSB5MDtcbiAgICBwMXggPSB5MSAqIGNvdEE7XG4gICAgcDF5ID0geTE7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXNlZFggPSBjb3NBO1xuICBjb25zdCBub3JtYWxpc2VkWSA9IHNpbkE7XG4gIGNvbnN0IHAwRG90Tm9ybWFsaXplZCA9IHAweCAqIG5vcm1hbGlzZWRYICsgcDB5ICogbm9ybWFsaXNlZFk7XG4gIGNvbnN0IHAxRG90Tm9ybWFsaXplZCA9IHAxeCAqIG5vcm1hbGlzZWRYICsgcDF5ICogbm9ybWFsaXNlZFk7XG4gIGNvbnN0IGEwID0gcDBEb3ROb3JtYWxpemVkID4gMCA/IGNsb2Nrd2lzZUFuZ2xlKE1hdGguYXRhbjIocDB5IC0gY3ksIHAweCAtIGN4KSwgc3RhcnRBbmdsZSkgOiBOYU47XG4gIGNvbnN0IGExID0gcDFEb3ROb3JtYWxpemVkID4gMCA/IGNsb2Nrd2lzZUFuZ2xlKE1hdGguYXRhbjIocDF5IC0gY3ksIHAxeCAtIGN4KSwgc3RhcnRBbmdsZSkgOiBOYU47XG4gIGlmIChhMCA+PSBzdGFydEFuZ2xlICYmIGEwIDw9IGVuZEFuZ2xlKSB7XG4gICAgcmV0dXJuIGEwO1xuICB9IGVsc2UgaWYgKGExID49IHN0YXJ0QW5nbGUgJiYgYTEgPD0gZW5kQW5nbGUpIHtcbiAgICByZXR1cm4gYTE7XG4gIH1cbn1cbmZ1bmN0aW9uIGFyY0NpcmNsZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNpcmNsZVIpIHtcbiAgY29uc3QgZCA9IE1hdGguaHlwb3QoY3gsIGN5KTtcbiAgY29uc3QgZDEgPSAoZCAqKiAyIC0gciAqKiAyICsgY2lyY2xlUiAqKiAyKSAvICgyICogZCk7XG4gIGNvbnN0IGQyID0gZCAtIGQxO1xuICBjb25zdCB0aGV0YSA9IE1hdGguYXRhbjIoY3ksIGN4KTtcbiAgY29uc3QgZGVsdGFUaGV0YSA9IE1hdGguYWNvcygtZDIgLyByKTtcbiAgY29uc3QgYTAgPSBjbG9ja3dpc2VBbmdsZSh0aGV0YSArIGRlbHRhVGhldGEsIHN0YXJ0QW5nbGUpO1xuICBjb25zdCBhMSA9IGNsb2Nrd2lzZUFuZ2xlKHRoZXRhIC0gZGVsdGFUaGV0YSwgc3RhcnRBbmdsZSk7XG4gIGlmIChhMCA+PSBzdGFydEFuZ2xlICYmIGEwIDw9IGVuZEFuZ2xlKSB7XG4gICAgcmV0dXJuIGEwO1xuICB9IGVsc2UgaWYgKGExID49IHN0YXJ0QW5nbGUgJiYgYTEgPD0gZW5kQW5nbGUpIHtcbiAgICByZXR1cm4gYTE7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvc2VjdG9yLnRzXG52YXIgQXJjID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjeCwgY3ksIHIsIGEwLCBhMSkge1xuICAgIHRoaXMuY3ggPSBjeDtcbiAgICB0aGlzLmN5ID0gY3k7XG4gICAgdGhpcy5yID0gcjtcbiAgICB0aGlzLmEwID0gYTA7XG4gICAgdGhpcy5hMSA9IGExO1xuICAgIGlmICh0aGlzLmEwID49IHRoaXMuYTEpIHtcbiAgICAgIHRoaXMuYTAgPSBOYU47XG4gICAgICB0aGlzLmExID0gTmFOO1xuICAgIH1cbiAgfVxuICBpc1ZhbGlkKCkge1xuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodGhpcy5hMCkgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMuYTEpO1xuICB9XG4gIHBvaW50QXQoYSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB0aGlzLmN4ICsgdGhpcy5yICogTWF0aC5jb3MoYSksXG4gICAgICB5OiB0aGlzLmN5ICsgdGhpcy5yICogTWF0aC5zaW4oYSlcbiAgICB9O1xuICB9XG4gIGNsaXBTdGFydChhKSB7XG4gICAgaWYgKGEgPT0gbnVsbCB8fCAhdGhpcy5pc1ZhbGlkKCkgfHwgYSA8IHRoaXMuYTApXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5hMCA9IGE7XG4gICAgaWYgKE51bWJlci5pc05hTihhKSB8fCB0aGlzLmEwID49IHRoaXMuYTEpIHtcbiAgICAgIHRoaXMuYTAgPSBOYU47XG4gICAgICB0aGlzLmExID0gTmFOO1xuICAgIH1cbiAgfVxuICBjbGlwRW5kKGEpIHtcbiAgICBpZiAoYSA9PSBudWxsIHx8ICF0aGlzLmlzVmFsaWQoKSB8fCBhID4gdGhpcy5hMSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmExID0gYTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGEpIHx8IHRoaXMuYTAgPj0gdGhpcy5hMSkge1xuICAgICAgdGhpcy5hMCA9IE5hTjtcbiAgICAgIHRoaXMuYTEgPSBOYU47XG4gICAgfVxuICB9XG59O1xudmFyIFNlY3RvciA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jZW50ZXJYID0gMDtcbiAgICB0aGlzLmNlbnRlclkgPSAwO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSAxMDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gMjA7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gMDtcbiAgICB0aGlzLmVuZEFuZ2xlID0gTWF0aC5QSSAqIDI7XG4gICAgdGhpcy5jbGlwU2VjdG9yID0gdm9pZCAwO1xuICAgIHRoaXMuY29uY2VudHJpY0VkZ2VJbnNldCA9IDA7XG4gICAgdGhpcy5yYWRpYWxFZGdlSW5zZXQgPSAwO1xuICAgIHRoaXMuc3RhcnRPdXRlckNvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5lbmRPdXRlckNvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5zdGFydElubmVyQ29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmVuZElubmVyQ29ybmVyUmFkaXVzID0gMDtcbiAgfVxuICBzZXQgaW5zZXQodmFsdWUpIHtcbiAgICB0aGlzLmNvbmNlbnRyaWNFZGdlSW5zZXQgPSB2YWx1ZTtcbiAgICB0aGlzLnJhZGlhbEVkZ2VJbnNldCA9IHZhbHVlO1xuICB9XG4gIHNldCBjb3JuZXJSYWRpdXModmFsdWUpIHtcbiAgICB0aGlzLnN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgPSB2YWx1ZTtcbiAgICB0aGlzLmVuZE91dGVyQ29ybmVyUmFkaXVzID0gdmFsdWU7XG4gICAgdGhpcy5zdGFydElubmVyQ29ybmVyUmFkaXVzID0gdmFsdWU7XG4gICAgdGhpcy5lbmRJbm5lckNvcm5lclJhZGl1cyA9IHZhbHVlO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIHJldHVybiBzZWN0b3JCb3godGhpcykudHJhbnNsYXRlKHRoaXMuY2VudGVyWCwgdGhpcy5jZW50ZXJZKTtcbiAgfVxuICBub3JtYWxpemVkUmFkaWkoKSB7XG4gICAgY29uc3QgeyBjb25jZW50cmljRWRnZUluc2V0IH0gPSB0aGlzO1xuICAgIGxldCB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gdGhpcztcbiAgICBpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzID4gMCA/IGlubmVyUmFkaXVzICsgY29uY2VudHJpY0VkZ2VJbnNldCA6IDA7XG4gICAgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChvdXRlclJhZGl1cyAtIGNvbmNlbnRyaWNFZGdlSW5zZXQsIDApO1xuICAgIHJldHVybiB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9O1xuICB9XG4gIG5vcm1hbGl6ZWRDbGlwU2VjdG9yKCkge1xuICAgIGNvbnN0IHsgY2xpcFNlY3RvciB9ID0gdGhpcztcbiAgICBpZiAoY2xpcFNlY3RvciA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUgfSA9IGNsb2Nrd2lzZUFuZ2xlcyh0aGlzLnN0YXJ0QW5nbGUsIHRoaXMuZW5kQW5nbGUpO1xuICAgIGNvbnN0IHsgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSB0aGlzLm5vcm1hbGl6ZWRSYWRpaSgpO1xuICAgIGNvbnN0IGNsaXBBbmdsZXMgPSBjbG9ja3dpc2VBbmdsZXMoY2xpcFNlY3Rvci5zdGFydEFuZ2xlLCBjbGlwU2VjdG9yLmVuZEFuZ2xlLCBzdGFydEFuZ2xlKTtcbiAgICByZXR1cm4gbmV3IFNlY3RvckJveChcbiAgICAgIE1hdGgubWF4KHN0YXJ0QW5nbGUsIGNsaXBBbmdsZXMuc3RhcnRBbmdsZSksXG4gICAgICBNYXRoLm1pbihlbmRBbmdsZSwgY2xpcEFuZ2xlcy5lbmRBbmdsZSksXG4gICAgICBNYXRoLm1heChpbm5lclJhZGl1cywgY2xpcFNlY3Rvci5pbm5lclJhZGl1cyksXG4gICAgICBNYXRoLm1pbihvdXRlclJhZGl1cywgY2xpcFNlY3Rvci5vdXRlclJhZGl1cylcbiAgICApO1xuICB9XG4gIGdldEFuZ2xlT2Zmc2V0KHJhZGl1cykge1xuICAgIHJldHVybiByYWRpdXMgPiAwID8gdGhpcy5yYWRpYWxFZGdlSW5zZXQgLyByYWRpdXMgOiAwO1xuICB9XG4gIGFyYyhyLCBhbmdsZVN3ZWVwLCBhMCwgYTEsIG91dGVyQXJjLCBpbm5lckFyYywgc3RhcnQyLCBpbm5lcikge1xuICAgIGlmIChyIDw9IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSB9ID0gY2xvY2t3aXNlQW5nbGVzKHRoaXMuc3RhcnRBbmdsZSwgdGhpcy5lbmRBbmdsZSk7XG4gICAgY29uc3QgeyBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHRoaXMubm9ybWFsaXplZFJhZGlpKCk7XG4gICAgY29uc3QgY2xpcFNlY3RvciA9IHRoaXMubm9ybWFsaXplZENsaXBTZWN0b3IoKTtcbiAgICBpZiAoaW5uZXIgJiYgaW5uZXJSYWRpdXMgPD0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhbmdsZU9mZnNldCA9IGlubmVyID8gdGhpcy5nZXRBbmdsZU9mZnNldChpbm5lclJhZGl1cyArIHIpIDogdGhpcy5nZXRBbmdsZU9mZnNldChvdXRlclJhZGl1cyAtIHIpO1xuICAgIGNvbnN0IGFuZ2xlMiA9IHN0YXJ0MiA/IHN0YXJ0QW5nbGUgKyBhbmdsZU9mZnNldCArIGFuZ2xlU3dlZXAgOiBlbmRBbmdsZSAtIGFuZ2xlT2Zmc2V0IC0gYW5nbGVTd2VlcDtcbiAgICBjb25zdCByYWRpdXMgPSBpbm5lciA/IGlubmVyUmFkaXVzICsgciA6IG91dGVyUmFkaXVzIC0gcjtcbiAgICBjb25zdCBjeCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlMik7XG4gICAgY29uc3QgY3kgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZTIpO1xuICAgIGlmIChjbGlwU2VjdG9yICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGRlbHRhMyA9IDFlLTY7XG4gICAgICBpZiAoIXN0YXJ0MiAmJiAhKGFuZ2xlMiA+PSBzdGFydEFuZ2xlIC0gZGVsdGEzICYmIGFuZ2xlMiA8PSBjbGlwU2VjdG9yLmVuZEFuZ2xlIC0gZGVsdGEzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHN0YXJ0MiAmJiAhKGFuZ2xlMiA+PSBjbGlwU2VjdG9yLnN0YXJ0QW5nbGUgKyBkZWx0YTMgJiYgYW5nbGUyIDw9IGVuZEFuZ2xlIC0gZGVsdGEzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGlubmVyICYmIHJhZGl1cyA8IGNsaXBTZWN0b3IuaW5uZXJSYWRpdXMgLSBkZWx0YTMpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICghaW5uZXIgJiYgcmFkaXVzID4gY2xpcFNlY3Rvci5vdXRlclJhZGl1cyArIGRlbHRhMylcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhcmMgPSBuZXcgQXJjKGN4LCBjeSwgciwgYTAsIGExKTtcbiAgICBpZiAoY2xpcFNlY3RvciAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXIpIHtcbiAgICAgICAgYXJjLmNsaXBTdGFydChhcmNSYWRpYWxMaW5lSW50ZXJzZWN0aW9uQW5nbGUoY3gsIGN5LCByLCBhMCwgYTEsIGNsaXBTZWN0b3IuZW5kQW5nbGUpKTtcbiAgICAgICAgYXJjLmNsaXBFbmQoYXJjUmFkaWFsTGluZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLnN0YXJ0QW5nbGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyYy5jbGlwU3RhcnQoYXJjUmFkaWFsTGluZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLnN0YXJ0QW5nbGUpKTtcbiAgICAgICAgYXJjLmNsaXBFbmQoYXJjUmFkaWFsTGluZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLmVuZEFuZ2xlKSk7XG4gICAgICB9XG4gICAgICBsZXQgY2lyY2xlQ2xpcFN0YXJ0O1xuICAgICAgbGV0IGNpcmNsZUNsaXBFbmQ7XG4gICAgICBpZiAoc3RhcnQyKSB7XG4gICAgICAgIGNpcmNsZUNsaXBTdGFydCA9IGFyY0NpcmNsZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLmlubmVyUmFkaXVzKTtcbiAgICAgICAgY2lyY2xlQ2xpcEVuZCA9IGFyY0NpcmNsZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLm91dGVyUmFkaXVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNpcmNsZUNsaXBTdGFydCA9IGFyY0NpcmNsZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLm91dGVyUmFkaXVzKTtcbiAgICAgICAgY2lyY2xlQ2xpcEVuZCA9IGFyY0NpcmNsZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLmlubmVyUmFkaXVzKTtcbiAgICAgIH1cbiAgICAgIGFyYy5jbGlwU3RhcnQoY2lyY2xlQ2xpcFN0YXJ0KTtcbiAgICAgIGFyYy5jbGlwRW5kKGNpcmNsZUNsaXBFbmQpO1xuICAgICAgaWYgKGNpcmNsZUNsaXBTdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSBhcmMucG9pbnRBdChjaXJjbGVDbGlwU3RhcnQpO1xuICAgICAgICBjb25zdCB0aGV0YTIgPSBjbG9ja3dpc2VBbmdsZShNYXRoLmF0YW4yKHkyLCB4MiksIHN0YXJ0QW5nbGUpO1xuICAgICAgICBpZiAoc3RhcnQyKSB7XG4gICAgICAgICAgaW5uZXJBcmM/LmNsaXBTdGFydCh0aGV0YTIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dGVyQXJjLmNsaXBFbmQodGhldGEyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNpcmNsZUNsaXBFbmQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gYXJjLnBvaW50QXQoY2lyY2xlQ2xpcEVuZCk7XG4gICAgICAgIGNvbnN0IHRoZXRhMiA9IGNsb2Nrd2lzZUFuZ2xlKE1hdGguYXRhbjIoeTIsIHgyKSwgc3RhcnRBbmdsZSk7XG4gICAgICAgIGlmIChzdGFydDIpIHtcbiAgICAgICAgICBvdXRlckFyYy5jbGlwU3RhcnQodGhldGEyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbm5lckFyYz8uY2xpcEVuZCh0aGV0YTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjbGlwU2VjdG9yICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSBhcmMucG9pbnRBdCgoYXJjLmEwICsgYXJjLmExKSAvIDIpO1xuICAgICAgaWYgKCFpc1BvaW50SW5TZWN0b3IoeDIsIHkyLCBjbGlwU2VjdG9yKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHgsIHkgfSA9IGFyYy5wb2ludEF0KHN0YXJ0MiA9PT0gaW5uZXIgPyBhcmMuYTAgOiBhcmMuYTEpO1xuICAgIGNvbnN0IHRoZXRhID0gY2xvY2t3aXNlQW5nbGUoTWF0aC5hdGFuMih5LCB4KSwgc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgcmFkaWFsQXJjID0gaW5uZXIgPyBpbm5lckFyYyA6IG91dGVyQXJjO1xuICAgIGlmIChzdGFydDIpIHtcbiAgICAgIHJhZGlhbEFyYz8uY2xpcFN0YXJ0KHRoZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFkaWFsQXJjPy5jbGlwRW5kKHRoZXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyYztcbiAgfVxuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IGRlbHRhMyA9IDFlLTY7XG4gICAgY29uc3QgeyBwYXRoLCBjZW50ZXJYLCBjZW50ZXJZLCBjb25jZW50cmljRWRnZUluc2V0LCByYWRpYWxFZGdlSW5zZXQgfSA9IHRoaXM7XG4gICAgbGV0IHsgc3RhcnRPdXRlckNvcm5lclJhZGl1cywgZW5kT3V0ZXJDb3JuZXJSYWRpdXMsIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMsIGVuZElubmVyQ29ybmVyUmFkaXVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUgfSA9IGNsb2Nrd2lzZUFuZ2xlcyh0aGlzLnN0YXJ0QW5nbGUsIHRoaXMuZW5kQW5nbGUpO1xuICAgIGNvbnN0IHsgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSB0aGlzLm5vcm1hbGl6ZWRSYWRpaSgpO1xuICAgIGNvbnN0IGNsaXBTZWN0b3IgPSB0aGlzLm5vcm1hbGl6ZWRDbGlwU2VjdG9yKCk7XG4gICAgY29uc3Qgc3dlZXBBbmdsZSA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgICBjb25zdCBmdWxsUGllID0gc3dlZXBBbmdsZSA+PSAyICogTWF0aC5QSSAtIGRlbHRhMztcbiAgICBwYXRoLmNsZWFyKCk7XG4gICAgaWYgKGlubmVyUmFkaXVzID09PSAwICYmIG91dGVyUmFkaXVzID09PSAwIHx8IGlubmVyUmFkaXVzID4gb3V0ZXJSYWRpdXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKChjbGlwU2VjdG9yPy5zdGFydEFuZ2xlID8/IHN0YXJ0QW5nbGUpID09PSAoY2xpcFNlY3Rvcj8uZW5kQW5nbGUgPz8gZW5kQW5nbGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChmdWxsUGllICYmIHRoaXMuY2xpcFNlY3RvciA9PSBudWxsICYmIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgPT09IDAgJiYgZW5kT3V0ZXJDb3JuZXJSYWRpdXMgPT09IDAgJiYgc3RhcnRJbm5lckNvcm5lclJhZGl1cyA9PT0gMCAmJiBlbmRJbm5lckNvcm5lclJhZGl1cyA9PT0gMCkge1xuICAgICAgcGF0aC5tb3ZlVG8oY2VudGVyWCArIG91dGVyUmFkaXVzICogTWF0aC5jb3Moc3RhcnRBbmdsZSksIGNlbnRlclkgKyBvdXRlclJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpKTtcbiAgICAgIHBhdGguYXJjKGNlbnRlclgsIGNlbnRlclksIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgICBpZiAoaW5uZXJSYWRpdXMgPiBjb25jZW50cmljRWRnZUluc2V0KSB7XG4gICAgICAgIHBhdGgubW92ZVRvKGNlbnRlclggKyBpbm5lclJhZGl1cyAqIE1hdGguY29zKGVuZEFuZ2xlKSwgY2VudGVyWSArIGlubmVyUmFkaXVzICogTWF0aC5zaW4oZW5kQW5nbGUpKTtcbiAgICAgICAgcGF0aC5hcmMoY2VudGVyWCwgY2VudGVyWSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlLCBzdGFydEFuZ2xlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0aGlzLmNsaXBTZWN0b3IgPT0gbnVsbCAmJiBNYXRoLmFicyhpbm5lclJhZGl1cyAtIG91dGVyUmFkaXVzKSA8IDFlLTYpIHtcbiAgICAgIHBhdGguYXJjKGNlbnRlclgsIGNlbnRlclksIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZmFsc2UpO1xuICAgICAgcGF0aC5hcmMoY2VudGVyWCwgY2VudGVyWSwgb3V0ZXJSYWRpdXMsIGVuZEFuZ2xlLCBzdGFydEFuZ2xlLCB0cnVlKTtcbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlubmVyQW5nbGVPZmZzZXQgPSB0aGlzLmdldEFuZ2xlT2Zmc2V0KGlubmVyUmFkaXVzKTtcbiAgICBjb25zdCBvdXRlckFuZ2xlT2Zmc2V0ID0gdGhpcy5nZXRBbmdsZU9mZnNldChvdXRlclJhZGl1cyk7XG4gICAgY29uc3Qgb3V0ZXJBbmdsZUV4Y2VlZGVkID0gc3dlZXBBbmdsZSA8IDIgKiBvdXRlckFuZ2xlT2Zmc2V0O1xuICAgIGlmIChvdXRlckFuZ2xlRXhjZWVkZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaGFzSW5uZXJTd2VlcCA9IChjbGlwU2VjdG9yPy5pbm5lclJhZGl1cyA/PyBpbm5lclJhZGl1cykgPiBjb25jZW50cmljRWRnZUluc2V0O1xuICAgIGNvbnN0IGlubmVyQW5nbGVFeGNlZWRlZCA9IGlubmVyUmFkaXVzIDwgY29uY2VudHJpY0VkZ2VJbnNldCB8fCBzd2VlcEFuZ2xlIDwgMiAqIGlubmVyQW5nbGVPZmZzZXQ7XG4gICAgY29uc3QgcmFkaWFsTGVuZ3RoID0gb3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cztcbiAgICBjb25zdCBtYXhSYWRpYWxMZW5ndGggPSBNYXRoLm1heChcbiAgICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMsXG4gICAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzLFxuICAgICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXMsXG4gICAgICBlbmRJbm5lckNvcm5lclJhZGl1c1xuICAgICk7XG4gICAgY29uc3QgaW5pdGlhbFNjYWxpbmdGYWN0b3IgPSBtYXhSYWRpYWxMZW5ndGggPiAwID8gTWF0aC5taW4ocmFkaWFsTGVuZ3RoIC8gbWF4UmFkaWFsTGVuZ3RoLCAxKSA6IDE7XG4gICAgc3RhcnRPdXRlckNvcm5lclJhZGl1cyAqPSBpbml0aWFsU2NhbGluZ0ZhY3RvcjtcbiAgICBlbmRPdXRlckNvcm5lclJhZGl1cyAqPSBpbml0aWFsU2NhbGluZ0ZhY3RvcjtcbiAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzICo9IGluaXRpYWxTY2FsaW5nRmFjdG9yO1xuICAgIGVuZElubmVyQ29ybmVyUmFkaXVzICo9IGluaXRpYWxTY2FsaW5nRmFjdG9yO1xuICAgIGNvbnN0IG91dGVyU2NhbGluZ0ZhY3RvciA9IHJhZGlpU2NhbGluZ0ZhY3RvcihcbiAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgc3dlZXBBbmdsZSAtIDIgKiBvdXRlckFuZ2xlT2Zmc2V0LFxuICAgICAgLXN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMsXG4gICAgICAtZW5kT3V0ZXJDb3JuZXJSYWRpdXNcbiAgICApO1xuICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgKj0gb3V0ZXJTY2FsaW5nRmFjdG9yO1xuICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzICo9IG91dGVyU2NhbGluZ0ZhY3RvcjtcbiAgICBpZiAoIWlubmVyQW5nbGVFeGNlZWRlZCAmJiBoYXNJbm5lclN3ZWVwKSB7XG4gICAgICBjb25zdCBpbm5lclNjYWxpbmdGYWN0b3IgPSByYWRpaVNjYWxpbmdGYWN0b3IoXG4gICAgICAgIGlubmVyUmFkaXVzLFxuICAgICAgICBzd2VlcEFuZ2xlIC0gMiAqIGlubmVyQW5nbGVPZmZzZXQsXG4gICAgICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMsXG4gICAgICAgIGVuZElubmVyQ29ybmVyUmFkaXVzXG4gICAgICApO1xuICAgICAgc3RhcnRJbm5lckNvcm5lclJhZGl1cyAqPSBpbm5lclNjYWxpbmdGYWN0b3I7XG4gICAgICBlbmRJbm5lckNvcm5lclJhZGl1cyAqPSBpbm5lclNjYWxpbmdGYWN0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMgPSAwO1xuICAgICAgZW5kSW5uZXJDb3JuZXJSYWRpdXMgPSAwO1xuICAgIH1cbiAgICBjb25zdCBtYXhDb21iaW5lZFJhZGlhbExlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgc3RhcnRPdXRlckNvcm5lclJhZGl1cyArIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMsXG4gICAgICBlbmRPdXRlckNvcm5lclJhZGl1cyArIGVuZElubmVyQ29ybmVyUmFkaXVzXG4gICAgKTtcbiAgICBjb25zdCBlZGdlc1NjYWxpbmdGYWN0b3IgPSBtYXhDb21iaW5lZFJhZGlhbExlbmd0aCA+IDAgPyBNYXRoLm1pbihyYWRpYWxMZW5ndGggLyBtYXhDb21iaW5lZFJhZGlhbExlbmd0aCwgMSkgOiAxO1xuICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgKj0gZWRnZXNTY2FsaW5nRmFjdG9yO1xuICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzICo9IGVkZ2VzU2NhbGluZ0ZhY3RvcjtcbiAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzICo9IGVkZ2VzU2NhbGluZ0ZhY3RvcjtcbiAgICBlbmRJbm5lckNvcm5lclJhZGl1cyAqPSBlZGdlc1NjYWxpbmdGYWN0b3I7XG4gICAgbGV0IHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwID0gMDtcbiAgICBsZXQgZW5kT3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwID0gMDtcbiAgICBjb25zdCBzdGFydE91dGVyQ29ybmVyUmFkaXVzU3dlZXAgPSBzdGFydE91dGVyQ29ybmVyUmFkaXVzIC8gKG91dGVyUmFkaXVzIC0gc3RhcnRPdXRlckNvcm5lclJhZGl1cyk7XG4gICAgY29uc3QgZW5kT3V0ZXJDb3JuZXJSYWRpdXNTd2VlcCA9IGVuZE91dGVyQ29ybmVyUmFkaXVzIC8gKG91dGVyUmFkaXVzIC0gZW5kT3V0ZXJDb3JuZXJSYWRpdXMpO1xuICAgIGlmIChzdGFydE91dGVyQ29ybmVyUmFkaXVzU3dlZXAgPj0gMCAmJiBzdGFydE91dGVyQ29ybmVyUmFkaXVzU3dlZXAgPCAxIC0gZGVsdGEzKSB7XG4gICAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCA9IE1hdGguYXNpbihzdGFydE91dGVyQ29ybmVyUmFkaXVzU3dlZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCA9IHN3ZWVwQW5nbGUgLyAyO1xuICAgICAgY29uc3QgbWF4U3RhcnRPdXRlckNvcm5lclJhZGl1cyA9IG91dGVyUmFkaXVzIC8gKDEgLyBNYXRoLnNpbihzdGFydE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCkgKyAxKTtcbiAgICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgPSBNYXRoLm1pbihtYXhTdGFydE91dGVyQ29ybmVyUmFkaXVzLCBzdGFydE91dGVyQ29ybmVyUmFkaXVzKTtcbiAgICB9XG4gICAgaWYgKGVuZE91dGVyQ29ybmVyUmFkaXVzU3dlZXAgPj0gMCAmJiBlbmRPdXRlckNvcm5lclJhZGl1c1N3ZWVwIDwgMSAtIGRlbHRhMykge1xuICAgICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwID0gTWF0aC5hc2luKGVuZE91dGVyQ29ybmVyUmFkaXVzU3dlZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAgPSBzd2VlcEFuZ2xlIC8gMjtcbiAgICAgIGNvbnN0IG1heEVuZE91dGVyQ29ybmVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLyAoMSAvIE1hdGguc2luKGVuZE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCkgKyAxKTtcbiAgICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzID0gTWF0aC5taW4obWF4RW5kT3V0ZXJDb3JuZXJSYWRpdXMsIGVuZE91dGVyQ29ybmVyUmFkaXVzKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRJbm5lckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAgPSBNYXRoLmFzaW4oXG4gICAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzIC8gKGlubmVyUmFkaXVzICsgc3RhcnRJbm5lckNvcm5lclJhZGl1cylcbiAgICApO1xuICAgIGNvbnN0IGVuZElubmVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCA9IE1hdGguYXNpbihlbmRJbm5lckNvcm5lclJhZGl1cyAvIChpbm5lclJhZGl1cyArIGVuZElubmVyQ29ybmVyUmFkaXVzKSk7XG4gICAgY29uc3Qgb3V0ZXJBcmNSYWRpdXMgPSBjbGlwU2VjdG9yPy5vdXRlclJhZGl1cyA/PyBvdXRlclJhZGl1cztcbiAgICBjb25zdCBvdXRlckFyY1JhZGl1c09mZnNldCA9IHRoaXMuZ2V0QW5nbGVPZmZzZXQob3V0ZXJBcmNSYWRpdXMpO1xuICAgIGNvbnN0IG91dGVyQXJjID0gbmV3IEFyYyhcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgb3V0ZXJBcmNSYWRpdXMsXG4gICAgICBzdGFydEFuZ2xlICsgb3V0ZXJBcmNSYWRpdXNPZmZzZXQsXG4gICAgICBlbmRBbmdsZSAtIG91dGVyQXJjUmFkaXVzT2Zmc2V0XG4gICAgKTtcbiAgICBjb25zdCBpbm5lckFyY1JhZGl1cyA9IGNsaXBTZWN0b3I/LmlubmVyUmFkaXVzID8/IGlubmVyUmFkaXVzO1xuICAgIGNvbnN0IGlubmVyQXJjUmFkaXVzT2Zmc2V0ID0gdGhpcy5nZXRBbmdsZU9mZnNldChpbm5lckFyY1JhZGl1cyk7XG4gICAgY29uc3QgaW5uZXJBcmMgPSBoYXNJbm5lclN3ZWVwID8gbmV3IEFyYygwLCAwLCBpbm5lckFyY1JhZGl1cywgc3RhcnRBbmdsZSArIGlubmVyQXJjUmFkaXVzT2Zmc2V0LCBlbmRBbmdsZSAtIGlubmVyQXJjUmFkaXVzT2Zmc2V0KSA6IHZvaWQgMDtcbiAgICBpZiAoY2xpcFNlY3RvciAhPSBudWxsKSB7XG4gICAgICBvdXRlckFyYy5jbGlwU3RhcnQoY2xpcFNlY3Rvci5zdGFydEFuZ2xlKTtcbiAgICAgIG91dGVyQXJjLmNsaXBFbmQoY2xpcFNlY3Rvci5lbmRBbmdsZSk7XG4gICAgICBpbm5lckFyYz8uY2xpcFN0YXJ0KGNsaXBTZWN0b3Iuc3RhcnRBbmdsZSk7XG4gICAgICBpbm5lckFyYz8uY2xpcEVuZChjbGlwU2VjdG9yLmVuZEFuZ2xlKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRPdXRlckFyYyA9IHRoaXMuYXJjKFxuICAgICAgc3RhcnRPdXRlckNvcm5lclJhZGl1cyxcbiAgICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwLFxuICAgICAgc3RhcnRBbmdsZSAtIE1hdGguUEkgKiAwLjUsXG4gICAgICBzdGFydEFuZ2xlICsgc3RhcnRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAsXG4gICAgICBvdXRlckFyYyxcbiAgICAgIGlubmVyQXJjLFxuICAgICAgdHJ1ZSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICBjb25zdCBlbmRPdXRlckFyYyA9IHRoaXMuYXJjKFxuICAgICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXMsXG4gICAgICBlbmRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAsXG4gICAgICBlbmRBbmdsZSAtIGVuZE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCxcbiAgICAgIGVuZEFuZ2xlICsgTWF0aC5QSSAqIDAuNSxcbiAgICAgIG91dGVyQXJjLFxuICAgICAgaW5uZXJBcmMsXG4gICAgICBmYWxzZSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICBjb25zdCBlbmRJbm5lckFyYyA9IHRoaXMuYXJjKFxuICAgICAgZW5kSW5uZXJDb3JuZXJSYWRpdXMsXG4gICAgICBlbmRJbm5lckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAsXG4gICAgICBlbmRBbmdsZSArIE1hdGguUEkgKiAwLjUsXG4gICAgICBlbmRBbmdsZSArIE1hdGguUEkgLSBlbmRJbm5lckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAsXG4gICAgICBvdXRlckFyYyxcbiAgICAgIGlubmVyQXJjLFxuICAgICAgZmFsc2UsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBjb25zdCBzdGFydElubmVyQXJjID0gdGhpcy5hcmMoXG4gICAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzLFxuICAgICAgc3RhcnRJbm5lckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAsXG4gICAgICBzdGFydEFuZ2xlICsgTWF0aC5QSSArIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwLFxuICAgICAgc3RhcnRBbmdsZSArIE1hdGguUEkgKiAxLjUsXG4gICAgICBvdXRlckFyYyxcbiAgICAgIGlubmVyQXJjLFxuICAgICAgdHJ1ZSxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIGlmIChpbm5lckFuZ2xlRXhjZWVkZWQpIHtcbiAgICAgIGNvbnN0IHggPSBzd2VlcEFuZ2xlIDwgTWF0aC5QSSAqIDAuNSA/IHJhZGlhbEVkZ2VJbnNldCAqICgxICsgTWF0aC5jb3Moc3dlZXBBbmdsZSkpIC8gTWF0aC5zaW4oc3dlZXBBbmdsZSkgOiBOYU47XG4gICAgICBsZXQgcjtcbiAgICAgIGlmICh4ID4gMCAmJiB4IDwgb3V0ZXJSYWRpdXMpIHtcbiAgICAgICAgciA9IE1hdGgubWF4KE1hdGguaHlwb3QocmFkaWFsRWRnZUluc2V0LCB4KSwgaW5uZXJSYWRpdXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciA9IHJhZGlhbEVkZ2VJbnNldDtcbiAgICAgIH1cbiAgICAgIHIgPSBNYXRoLm1heChyLCBpbm5lclJhZGl1cyk7XG4gICAgICBjb25zdCBtaWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBzd2VlcEFuZ2xlICogMC41O1xuICAgICAgcGF0aC5tb3ZlVG8oY2VudGVyWCArIHIgKiBNYXRoLmNvcyhtaWRBbmdsZSksIGNlbnRlclkgKyByICogTWF0aC5zaW4obWlkQW5nbGUpKTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0SW5uZXJBcmM/LmlzVmFsaWQoKSA9PT0gdHJ1ZSB8fCBpbm5lckFyYz8uaXNWYWxpZCgpID09PSB0cnVlKSB7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1pZEFuZ2xlID0gc3RhcnRBbmdsZSArIHN3ZWVwQW5nbGUgLyAyO1xuICAgICAgY29uc3QgY3ggPSBpbm5lclJhZGl1cyAqIE1hdGguY29zKG1pZEFuZ2xlKTtcbiAgICAgIGNvbnN0IGN5ID0gaW5uZXJSYWRpdXMgKiBNYXRoLnNpbihtaWRBbmdsZSk7XG4gICAgICBwYXRoLm1vdmVUbyhjZW50ZXJYICsgY3gsIGNlbnRlclkgKyBjeSk7XG4gICAgfVxuICAgIGlmIChzdGFydE91dGVyQXJjPy5pc1ZhbGlkKCkgPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IHsgY3gsIGN5LCByLCBhMCwgYTEgfSA9IHN0YXJ0T3V0ZXJBcmM7XG4gICAgICBwYXRoLmFyYyhjZW50ZXJYICsgY3gsIGNlbnRlclkgKyBjeSwgciwgYTAsIGExKTtcbiAgICB9XG4gICAgaWYgKG91dGVyQXJjLmlzVmFsaWQoKSkge1xuICAgICAgY29uc3QgeyByLCBhMCwgYTEgfSA9IG91dGVyQXJjO1xuICAgICAgcGF0aC5hcmMoY2VudGVyWCwgY2VudGVyWSwgciwgYTAsIGExKTtcbiAgICB9XG4gICAgaWYgKGVuZE91dGVyQXJjPy5pc1ZhbGlkKCkgPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IHsgY3gsIGN5LCByLCBhMCwgYTEgfSA9IGVuZE91dGVyQXJjO1xuICAgICAgcGF0aC5hcmMoY2VudGVyWCArIGN4LCBjZW50ZXJZICsgY3ksIHIsIGEwLCBhMSk7XG4gICAgfVxuICAgIGlmICghaW5uZXJBbmdsZUV4Y2VlZGVkKSB7XG4gICAgICBpZiAoZW5kSW5uZXJBcmM/LmlzVmFsaWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGN4LCBjeSwgciwgYTAsIGExIH0gPSBlbmRJbm5lckFyYztcbiAgICAgICAgcGF0aC5hcmMoY2VudGVyWCArIGN4LCBjZW50ZXJZICsgY3ksIHIsIGEwLCBhMSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5uZXJBcmM/LmlzVmFsaWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCB7IHIsIGEwLCBhMSB9ID0gaW5uZXJBcmM7XG4gICAgICAgIHBhdGguYXJjKGNlbnRlclgsIGNlbnRlclksIHIsIGExLCBhMCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnRJbm5lckFyYz8uaXNWYWxpZCgpID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgY3gsIGN5LCByLCBhMCwgYTEgfSA9IHN0YXJ0SW5uZXJBcmM7XG4gICAgICAgIHBhdGguYXJjKGNlbnRlclggKyBjeCwgY2VudGVyWSArIGN5LCByLCBhMCwgYTEpO1xuICAgICAgfVxuICAgIH1cbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG4gIGlzUG9pbnRJblBhdGgoeCwgeSkge1xuICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gdGhpcy5jbGlwU2VjdG9yID8/IHRoaXM7XG4gICAgcmV0dXJuIGlzUG9pbnRJblNlY3Rvcih4IC0gdGhpcy5jZW50ZXJYLCB5IC0gdGhpcy5jZW50ZXJZLCB7XG4gICAgICBzdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUsXG4gICAgICBpbm5lclJhZGl1czogTWF0aC5taW4oaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzKSxcbiAgICAgIG91dGVyUmFkaXVzOiBNYXRoLm1heChpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMpXG4gICAgfSk7XG4gIH1cbn07XG5TZWN0b3IuY2xhc3NOYW1lID0gXCJTZWN0b3JcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImNlbnRlclhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJjZW50ZXJZXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwiaW5uZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJvdXRlclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcInN0YXJ0QW5nbGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJlbmRBbmdsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImNsaXBTZWN0b3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJjb25jZW50cmljRWRnZUluc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwicmFkaWFsRWRnZUluc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwic3RhcnRPdXRlckNvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImVuZE91dGVyQ29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwic3RhcnRJbm5lckNvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImVuZElubmVyQ29ybmVyUmFkaXVzXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvZGVmYXVsdENvbG9ycy50c1xudmFyIERFRkFVTFRfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzUwOTBkY1wiLFxuICBPUkFOR0U6IFwiI2ZmYTAzYVwiLFxuICBHUkVFTjogXCIjNDU5ZDU1XCIsXG4gIENZQU46IFwiIzM0YmZlMVwiLFxuICBZRUxMT1c6IFwiI2UxY2MwMFwiLFxuICBWSU9MRVQ6IFwiIzk2NjljYlwiLFxuICBHUkFZOiBcIiNiNWI1YjVcIixcbiAgTUFHRU5UQTogXCIjYmQ1YWE3XCIsXG4gIEJST1dOOiBcIiM4YTYyMjRcIixcbiAgUkVEOiBcIiNlZjU0NTJcIlxufTtcbnZhciBERUZBVUxUX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzJiNWM5NVwiLFxuICBPUkFOR0U6IFwiI2NjNmYxMFwiLFxuICBHUkVFTjogXCIjMWU2NTJlXCIsXG4gIENZQU46IFwiIzE4ODU5ZVwiLFxuICBZRUxMT1c6IFwiI2E2OTQwMFwiLFxuICBWSU9MRVQ6IFwiIzYwM2M4OFwiLFxuICBHUkFZOiBcIiM1NzU3NTdcIixcbiAgTUFHRU5UQTogXCIjN2QyZjZkXCIsXG4gIEJST1dOOiBcIiM0ZjM1MDhcIixcbiAgUkVEOiBcIiNhODI1MjlcIlxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL2RvbnV0U2VyaWVzUHJvcGVydGllcy50c1xudmFyIERvbnV0VGl0bGUgPSBjbGFzcyBleHRlbmRzIENhcHRpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc2hvd0luTGVnZW5kID0gZmFsc2U7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgRG9udXRUaXRsZS5wcm90b3R5cGUsIFwic2hvd0luTGVnZW5kXCIsIDIpO1xudmFyIERvbnV0SW5uZXJMYWJlbCA9IGNsYXNzIGV4dGVuZHMgTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc3BhY2luZyA9IDI7XG4gIH1cbiAgc2V0KHByb3BlcnRpZXMsIF9yZXNldCkge1xuICAgIHJldHVybiBzdXBlci5zZXQocHJvcGVydGllcyk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBEb251dElubmVyTGFiZWwucHJvdG90eXBlLCBcInRleHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBEb251dElubmVyTGFiZWwucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgMik7XG52YXIgRG9udXRJbm5lckNpcmNsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZmlsbCA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIERvbnV0SW5uZXJDaXJjbGUucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIERvbnV0SW5uZXJDaXJjbGUucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xudmFyIERvbnV0U2VyaWVzQ2FsbG91dExhYmVsID0gY2xhc3MgZXh0ZW5kcyBMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5vZmZzZXQgPSAzO1xuICAgIHRoaXMubWluQW5nbGUgPSAwO1xuICAgIHRoaXMubWluU3BhY2luZyA9IDQ7XG4gICAgdGhpcy5tYXhDb2xsaXNpb25PZmZzZXQgPSA1MDtcbiAgICB0aGlzLmF2b2lkQ29sbGlzaW9ucyA9IHRydWU7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBEb251dFNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwib2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSLnJlc3RyaWN0KHsgbWluOiAwLCBtYXg6IDM2MCB9KSlcbl0sIERvbnV0U2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJtaW5BbmdsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIERvbnV0U2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJtaW5TcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcIm1heENvbGxpc2lvbk9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBEb251dFNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwiYXZvaWRDb2xsaXNpb25zXCIsIDIpO1xudmFyIERvbnV0U2VyaWVzU2VjdG9yTGFiZWwgPSBjbGFzcyBleHRlbmRzIExhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnBvc2l0aW9uT2Zmc2V0ID0gMDtcbiAgICB0aGlzLnBvc2l0aW9uUmF0aW8gPSAwLjU7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBEb251dFNlcmllc1NlY3RvckxhYmVsLnByb3RvdHlwZSwgXCJwb3NpdGlvbk9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgRG9udXRTZXJpZXNTZWN0b3JMYWJlbC5wcm90b3R5cGUsIFwicG9zaXRpb25SYXRpb1wiLCAyKTtcbnZhciBEb251dFNlcmllc0NhbGxvdXRMaW5lID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5sZW5ndGggPSAxMDtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGluZS5wcm90b3R5cGUsIFwiY29sb3JzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGluZS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGluZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG52YXIgRG9udXRTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZpbGxzID0gT2JqZWN0LnZhbHVlcyhERUZBVUxUX0ZJTExTKTtcbiAgICB0aGlzLnN0cm9rZXMgPSBPYmplY3QudmFsdWVzKERFRkFVTFRfU1RST0tFUyk7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmxpbmVEYXNoID0gWzBdO1xuICAgIHRoaXMubGluZURhc2hPZmZzZXQgPSAwO1xuICAgIHRoaXMuY29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICB0aGlzLm91dGVyUmFkaXVzT2Zmc2V0ID0gMDtcbiAgICB0aGlzLm91dGVyUmFkaXVzUmF0aW8gPSAxO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xuICAgIHRoaXMuc2VjdG9yU3BhY2luZyA9IDA7XG4gICAgdGhpcy5oaWRlWmVyb1ZhbHVlU2VjdG9yc0luTGVnZW5kID0gZmFsc2U7XG4gICAgdGhpcy5pbm5lckxhYmVscyA9IG5ldyBQcm9wZXJ0aWVzQXJyYXkoRG9udXRJbm5lckxhYmVsKTtcbiAgICB0aGlzLnRpdGxlID0gbmV3IERvbnV0VGl0bGUoKTtcbiAgICB0aGlzLmlubmVyQ2lyY2xlID0gbmV3IERvbnV0SW5uZXJDaXJjbGUoKTtcbiAgICB0aGlzLnNoYWRvdyA9IG5ldyBEcm9wU2hhZG93KCk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWwgPSBuZXcgRG9udXRTZXJpZXNDYWxsb3V0TGFiZWwoKTtcbiAgICB0aGlzLnNlY3RvckxhYmVsID0gbmV3IERvbnV0U2VyaWVzU2VjdG9yTGFiZWwoKTtcbiAgICB0aGlzLmNhbGxvdXRMaW5lID0gbmV3IERvbnV0U2VyaWVzQ2FsbG91dExpbmUoKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xuICB9XG4gIGlzVmFsaWQoKSB7XG4gICAgY29uc3Qgc3VwZXJJc1ZhbGlkID0gc3VwZXIuaXNWYWxpZCgpO1xuICAgIGlmICh0aGlzLmlubmVyUmFkaXVzUmF0aW8gPT0gbnVsbCAmJiB0aGlzLmlubmVyUmFkaXVzT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKFxuICAgICAgICBcIkVpdGhlciBhbiBbaW5uZXJSYWRpdXNSYXRpb10gb3IgYW4gW2lubmVyUmFkaXVzT2Zmc2V0XSBtdXN0IGJlIHNldCB0byByZW5kZXIgYSBkb251dCBzZXJpZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdXBlcklzVmFsaWQ7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImFuZ2xlS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImFuZ2xlTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhbmdsZUZpbHRlcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyYWRpdXNLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicmFkaXVzTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyYWRpdXNNaW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicmFkaXVzTWF4XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMYWJlbEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjYWxsb3V0TGFiZWxOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNlY3RvckxhYmVsS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNlY3RvckxhYmVsTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsZWdlbmRJdGVtS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTElORV9EQVNIKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIml0ZW1TdHlsZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJvdXRlclJhZGl1c09mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJvdXRlclJhZGl1c1JhdGlvXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImlubmVyUmFkaXVzT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaW5uZXJSYWRpdXNSYXRpb1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNlY3RvclNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJoaWRlWmVyb1ZhbHVlU2VjdG9yc0luTGVnZW5kXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUX0FSUkFZKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpbm5lckxhYmVsc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImlubmVyQ2lyY2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaGFkb3dcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2VjdG9yTGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMaW5lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvcGllVXRpbC50c1xuZnVuY3Rpb24gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyhpbml0aWFsTG9hZCwgcm90YXRpb25EZWdyZWVzLCBzY2FsZUZuLCBvbGRTY2FsZUZuKSB7XG4gIGNvbnN0IHNjYWxlMiA9IFtzY2FsZUZuLmNvbnZlcnQoMCksIHNjYWxlRm4uY29udmVydCgxKV07XG4gIGNvbnN0IG9sZFNjYWxlID0gW29sZFNjYWxlRm4uY29udmVydCgwKSwgb2xkU2NhbGVGbi5jb252ZXJ0KDEpXTtcbiAgY29uc3Qgcm90YXRpb24gPSBNYXRoLlBJIC8gLTIgKyB0b1JhZGlhbnMocm90YXRpb25EZWdyZWVzKTtcbiAgY29uc3QgcGhhc2UgPSBpbml0aWFsTG9hZCA/IFwiaW5pdGlhbFwiIDogXCJ1cGRhdGVcIjtcbiAgY29uc3Qgc2NhbGVUb05ld1JhZGl1cyA9ICh7IHJhZGl1cyB9KSA9PiB7XG4gICAgcmV0dXJuIHsgaW5uZXJSYWRpdXM6IHNjYWxlMlswXSwgb3V0ZXJSYWRpdXM6IHNjYWxlMlswXSArIChzY2FsZTJbMV0gLSBzY2FsZTJbMF0pICogcmFkaXVzIH07XG4gIH07XG4gIGNvbnN0IHNjYWxlVG9PbGRSYWRpdXMgPSAoeyByYWRpdXMgfSkgPT4ge1xuICAgIHJldHVybiB7IGlubmVyUmFkaXVzOiBvbGRTY2FsZVswXSwgb3V0ZXJSYWRpdXM6IG9sZFNjYWxlWzBdICsgKG9sZFNjYWxlWzFdIC0gb2xkU2NhbGVbMF0pICogcmFkaXVzIH07XG4gIH07XG4gIGNvbnN0IGZyb21GbiA9IChzZWN0LCBkYXR1bSwgc3RhdHVzLCB7IHByZXZGcm9tUHJvcHMgfSkgPT4ge1xuICAgIGxldCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHNlY3Q7XG4gICAgbGV0IHsgZmlsbCwgc3Ryb2tlOiBzdHJva2UyIH0gPSBkYXR1bS5zZWN0b3JGb3JtYXQ7XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJ1bmtub3duXCIgfHwgc3RhdHVzID09PSBcImFkZGVkXCIgJiYgIXByZXZGcm9tUHJvcHMpIHtcbiAgICAgIHN0YXJ0QW5nbGUgPSByb3RhdGlvbjtcbiAgICAgIGVuZEFuZ2xlID0gcm90YXRpb247XG4gICAgICBpbm5lclJhZGl1cyA9IGRhdHVtLmlubmVyUmFkaXVzO1xuICAgICAgb3V0ZXJSYWRpdXMgPSBkYXR1bS5vdXRlclJhZGl1cztcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJhZGRlZFwiICYmIHByZXZGcm9tUHJvcHMpIHtcbiAgICAgIHN0YXJ0QW5nbGUgPSBwcmV2RnJvbVByb3BzLmVuZEFuZ2xlID8/IHJvdGF0aW9uO1xuICAgICAgZW5kQW5nbGUgPSBwcmV2RnJvbVByb3BzLmVuZEFuZ2xlID8/IHJvdGF0aW9uO1xuICAgICAgaW5uZXJSYWRpdXMgPSBwcmV2RnJvbVByb3BzLmlubmVyUmFkaXVzID8/IGRhdHVtLmlubmVyUmFkaXVzO1xuICAgICAgb3V0ZXJSYWRpdXMgPSBwcmV2RnJvbVByb3BzLm91dGVyUmFkaXVzID8/IGRhdHVtLm91dGVyUmFkaXVzO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBcImFkZGVkXCIgJiYgIWluaXRpYWxMb2FkKSB7XG4gICAgICBjb25zdCByYWRpaSA9IHNjYWxlVG9PbGRSYWRpdXMoZGF0dW0pO1xuICAgICAgaW5uZXJSYWRpdXMgPSByYWRpaS5pbm5lclJhZGl1cztcbiAgICAgIG91dGVyUmFkaXVzID0gcmFkaWkub3V0ZXJSYWRpdXM7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IFwidXBkYXRlZFwiKSB7XG4gICAgICBmaWxsID0gc2VjdC5maWxsID8/IGZpbGw7XG4gICAgICBzdHJva2UyID0gKHR5cGVvZiBzZWN0LnN0cm9rZSA9PT0gXCJzdHJpbmdcIiA/IHNlY3Quc3Ryb2tlIDogdm9pZCAwKSA/PyBzdHJva2UyO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBmaWxsLCBzdHJva2U6IHN0cm9rZTIsIHBoYXNlIH07XG4gIH07XG4gIGNvbnN0IHRvRm4gPSAoX3NlY3QsIGRhdHVtLCBzdGF0dXMsIHsgcHJldkxpdmUgfSkgPT4ge1xuICAgIGxldCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IGRhdHVtO1xuICAgIGNvbnN0IHsgc3Ryb2tlOiBzdHJva2UyLCBmaWxsIH0gPSBkYXR1bS5zZWN0b3JGb3JtYXQ7XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgJiYgcHJldkxpdmUpIHtcbiAgICAgIHN0YXJ0QW5nbGUgPSBwcmV2TGl2ZS5kYXR1bT8uZW5kQW5nbGU7XG4gICAgICBlbmRBbmdsZSA9IHByZXZMaXZlLmRhdHVtPy5lbmRBbmdsZTtcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgJiYgIXByZXZMaXZlKSB7XG4gICAgICBzdGFydEFuZ2xlID0gcm90YXRpb247XG4gICAgICBlbmRBbmdsZSA9IHJvdGF0aW9uO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIikge1xuICAgICAgY29uc3QgcmFkaWkgPSBzY2FsZVRvTmV3UmFkaXVzKGRhdHVtKTtcbiAgICAgIGlubmVyUmFkaXVzID0gcmFkaWkuaW5uZXJSYWRpdXM7XG4gICAgICBvdXRlclJhZGl1cyA9IHJhZGlpLm91dGVyUmFkaXVzO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzLCBzdHJva2U6IHN0cm9rZTIsIGZpbGwgfTtcbiAgfTtcbiAgY29uc3QgaW5uZXJDaXJjbGVGcm9tRm4gPSAobm9kZSwgXykgPT4ge1xuICAgIHJldHVybiB7IHNpemU6IG5vZGUucHJldmlvdXNEYXR1bT8ucmFkaXVzID8/IG5vZGUuc2l6ZSA/PyAwLCBwaGFzZSB9O1xuICB9O1xuICBjb25zdCBpbm5lckNpcmNsZVRvRm4gPSAoXywgZGF0dW0pID0+IHtcbiAgICByZXR1cm4geyBzaXplOiBkYXR1bS5yYWRpdXMgPz8gMCB9O1xuICB9O1xuICByZXR1cm4geyBub2RlczogeyB0b0ZuLCBmcm9tRm4gfSwgaW5uZXJDaXJjbGU6IHsgZnJvbUZuOiBpbm5lckNpcmNsZUZyb21GbiwgdG9GbjogaW5uZXJDaXJjbGVUb0ZuIH0gfTtcbn1cbmZ1bmN0aW9uIHJlc2V0UGllU2VsZWN0aW9uc0ZuKF9ub2RlLCBkYXR1bSkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0QW5nbGU6IGRhdHVtLnN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGU6IGRhdHVtLmVuZEFuZ2xlLFxuICAgIGlubmVyUmFkaXVzOiBkYXR1bS5pbm5lclJhZGl1cyxcbiAgICBvdXRlclJhZGl1czogZGF0dW0ub3V0ZXJSYWRpdXMsXG4gICAgZmlsbDogZGF0dW0uc2VjdG9yRm9ybWF0LmZpbGwsXG4gICAgc3Ryb2tlOiBkYXR1bS5zZWN0b3JGb3JtYXQuc3Ryb2tlXG4gIH07XG59XG5mdW5jdGlvbiBwaWNrQnlNYXRjaGluZ0FuZ2xlKHNlcmllcywgcG9pbnQpIHtcbiAgY29uc3QgZHkgPSBwb2ludC55IC0gc2VyaWVzLmNlbnRlclk7XG4gIGNvbnN0IGR4ID0gcG9pbnQueCAtIHNlcmllcy5jZW50ZXJYO1xuICBjb25zdCBhbmdsZTIgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gIGNvbnN0IHNlY3RvcnMgPSBzZXJpZXMuZ2V0SXRlbU5vZGVzKCk7XG4gIGZvciAoY29uc3Qgc2VjdG9yIG9mIHNlY3RvcnMpIHtcbiAgICBpZiAoc2VjdG9yLmRhdHVtLm1pc3NpbmcgPT09IHRydWUpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoaXNCZXR3ZWVuQW5nbGVzKGFuZ2xlMiwgc2VjdG9yLnN0YXJ0QW5nbGUsIHNlY3Rvci5lbmRBbmdsZSkpIHtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBsZXQgZGlzdGFuY2UyID0gMDtcbiAgICAgIGlmIChyYWRpdXMgPCBzZWN0b3IuaW5uZXJSYWRpdXMpIHtcbiAgICAgICAgZGlzdGFuY2UyID0gc2VjdG9yLmlubmVyUmFkaXVzIC0gcmFkaXVzO1xuICAgICAgfSBlbHNlIGlmIChyYWRpdXMgPiBzZWN0b3Iub3V0ZXJSYWRpdXMpIHtcbiAgICAgICAgZGlzdGFuY2UyID0gcmFkaXVzIC0gc2VjdG9yLm91dGVyUmFkaXVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0dW06IHNlY3Rvci5kYXR1bSwgZGlzdGFuY2U6IGRpc3RhbmNlMiB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvcG9sYXJaSW5kZXhNYXAudHNcbnZhciBQb2xhclpJbmRleE1hcCA9IC8qIEBfX1BVUkVfXyAqLyAoKFBvbGFyWkluZGV4TWFwMikgPT4ge1xuICBQb2xhclpJbmRleE1hcDJbUG9sYXJaSW5kZXhNYXAyW1wiQkFDS0dST1VORFwiXSA9IDBdID0gXCJCQUNLR1JPVU5EXCI7XG4gIFBvbGFyWkluZGV4TWFwMltQb2xhclpJbmRleE1hcDJbXCJGT1JFR1JPVU5EXCJdID0gMV0gPSBcIkZPUkVHUk9VTkRcIjtcbiAgUG9sYXJaSW5kZXhNYXAyW1BvbGFyWkluZGV4TWFwMltcIkhJR0hMSUdIVFwiXSA9IDJdID0gXCJISUdITElHSFRcIjtcbiAgUG9sYXJaSW5kZXhNYXAyW1BvbGFyWkluZGV4TWFwMltcIkxBQkVMXCJdID0gM10gPSBcIkxBQkVMXCI7XG4gIHJldHVybiBQb2xhclpJbmRleE1hcDI7XG59KShQb2xhclpJbmRleE1hcCB8fCB7fSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9wb2xhci9wb2xhclNlcmllcy50c1xudmFyIFBvbGFyU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBEYXRhTW9kZWxTZXJpZXMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdXNlTGFiZWxMYXllciA9IGZhbHNlLFxuICAgIHBpY2tNb2RlcyA9IFsxIC8qIE5FQVJFU1RfTk9ERSAqLywgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL10sXG4gICAgY2FuSGF2ZUF4ZXMgPSBmYWxzZSxcbiAgICBhbmltYXRpb25SZXNldEZucyxcbiAgICAuLi5vcHRzXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRzLFxuICAgICAgdXNlTGFiZWxMYXllcixcbiAgICAgIHBpY2tNb2RlcyxcbiAgICAgIGRpcmVjdGlvbktleXM6IHtcbiAgICAgICAgW1wieFwiIC8qIFggKi9dOiBbXCJhbmdsZUtleVwiXSxcbiAgICAgICAgW1wieVwiIC8qIFkgKi9dOiBbXCJyYWRpdXNLZXlcIl1cbiAgICAgIH0sXG4gICAgICBkaXJlY3Rpb25OYW1lczoge1xuICAgICAgICBbXCJ4XCIgLyogWCAqL106IFtcImFuZ2xlTmFtZVwiXSxcbiAgICAgICAgW1wieVwiIC8qIFkgKi9dOiBbXCJyYWRpdXNOYW1lXCJdXG4gICAgICB9LFxuICAgICAgY2FuSGF2ZUF4ZXNcbiAgICB9KTtcbiAgICB0aGlzLml0ZW1Hcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCgpKTtcbiAgICB0aGlzLm5vZGVEYXRhID0gW107XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMuaXRlbUdyb3VwLFxuICAgICAgKCkgPT4gdGhpcy5ub2RlRmFjdG9yeSgpLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5sYWJlbEdyb3VwLFxuICAgICAgKCkgPT4gdGhpcy5sYWJlbEZhY3RvcnkoKSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLFxuICAgICAgKCkgPT4gdGhpcy5ub2RlRmFjdG9yeSgpXG4gICAgKTtcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWwsXG4gICAgICAoKSA9PiB0aGlzLmxhYmVsRmFjdG9yeSgpXG4gICAgKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2VudGVyIG9mIHRoZSBwb2xhciBzZXJpZXMgKGZvciBleGFtcGxlLCB0aGUgY2VudGVyIG9mIGEgcGllKS5cbiAgICAgKiBJZiB0aGUgcG9sYXIgY2hhcnQgaGFzIG11bHRpcGxlIHNlcmllcywgYWxsIG9mIHRoZW0gd2lsbCBoYXZlIHRoZWlyXG4gICAgICogY2VudGVyIHNldCB0byB0aGUgc2FtZSB2YWx1ZSBhcyBhIHJlc3VsdCBvZiB0aGUgcG9sYXIgY2hhcnQgbGF5b3V0LlxuICAgICAqIFRoZSBjZW50ZXIgY29vcmRpbmF0ZXMgYXJlIG5vdCBzdXBwb3NlZCB0byBiZSBzZXQgYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgdGhpcy5jZW50ZXJYID0gMDtcbiAgICB0aGlzLmNlbnRlclkgPSAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIHJhZGl1cyB0aGUgc2VyaWVzIGNhbiB1c2UuXG4gICAgICogVGhpcyB2YWx1ZSBpcyBzZXQgYXV0b21hdGljYWxseSBhcyBhIHJlc3VsdCBvZiB0aGUgcG9sYXIgY2hhcnQgbGF5b3V0XG4gICAgICogYW5kIGlzIG5vdCBzdXBwb3NlZCB0byBiZSBzZXQgYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgdGhpcy5yYWRpdXMgPSAwO1xuICAgIHRoaXMuYW5pbWF0aW9uUmVzZXRGbnMgPSBhbmltYXRpb25SZXNldEZucztcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gbmV3IFN0YXRlTWFjaGluZShcbiAgICAgIFwiZW1wdHlcIixcbiAgICAgIHtcbiAgICAgICAgZW1wdHk6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJyZWFkeVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlRW1wdHlVcGRhdGVSZWFkeShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZHk6IHtcbiAgICAgICAgICB1cGRhdGVEYXRhOiBcIndhaXRpbmdcIixcbiAgICAgICAgICBjbGVhcjogXCJjbGVhcmluZ1wiLFxuICAgICAgICAgIGhpZ2hsaWdodDogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0KGRhdGEpLFxuICAgICAgICAgIGhpZ2hsaWdodE1hcmtlcnM6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeUhpZ2hsaWdodE1hcmtlcnMoZGF0YSksXG4gICAgICAgICAgcmVzaXplOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlSZXNpemUoZGF0YSksXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgd2FpdGluZzoge1xuICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyaW5nOiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZUNsZWFyaW5nVXBkYXRlRW1wdHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoKSA9PiB0aGlzLmNoZWNrUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKVxuICAgICk7XG4gIH1cbiAgZ2V0SXRlbU5vZGVzKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5pdGVtR3JvdXAuY2hpbGRyZW4oKV07XG4gIH1cbiAgZ2V0Tm9kZURhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZURhdGE7XG4gIH1cbiAgc2V0U2VyaWVzSW5kZXgoaW5kZXgpIHtcbiAgICBpZiAoIXN1cGVyLnNldFNlcmllc0luZGV4KGluZGV4KSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLmNvbnRlbnRHcm91cC56SW5kZXggPSBbaW5kZXgsIDEgLyogRk9SRUdST1VORCAqL107XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC56SW5kZXggPSBbaW5kZXgsIDIgLyogSElHSExJR0hUICovXTtcbiAgICB0aGlzLmxhYmVsR3JvdXAuekluZGV4ID0gW2luZGV4LCAzIC8qIExBQkVMICovXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXNldEFuaW1hdGlvbihwaGFzZSkge1xuICAgIGlmIChwaGFzZSA9PT0gXCJpbml0aWFsXCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInJlc2V0XCIpO1xuICAgIH0gZWxzZSBpZiAocGhhc2UgPT09IFwicmVhZHlcIikge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwic2tpcFwiKTtcbiAgICB9XG4gIH1cbiAgbGFiZWxGYWN0b3J5KCkge1xuICAgIGNvbnN0IHRleHQyID0gbmV3IFRleHQoKTtcbiAgICB0ZXh0Mi5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgIHJldHVybiB0ZXh0MjtcbiAgfVxuICBhZGRDaGFydEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgdGhpcy5jdHguY2hhcnRFdmVudE1hbmFnZXI/LmFkZExpc3RlbmVyKFwibGVnZW5kLWl0ZW0tY2xpY2tcIiwgKGV2ZW50KSA9PiB0aGlzLm9uTGVnZW5kSXRlbUNsaWNrKGV2ZW50KSlcbiAgICApO1xuICB9XG4gIGdldElubmVyUmFkaXVzKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbXB1dGVMYWJlbHNCQm94KF9vcHRpb25zLCBfc2VyaWVzUmVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlc2V0QWxsQW5pbWF0aW9uKCkge1xuICAgIGNvbnN0IHsgaXRlbSwgbGFiZWwgfSA9IHRoaXMuYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICByZXNldE1vdGlvbihbdGhpcy5pdGVtU2VsZWN0aW9uLCB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbl0sIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHJlc2V0TW90aW9uKFt0aGlzLmxhYmVsU2VsZWN0aW9uLCB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uXSwgbGFiZWwpO1xuICAgIH1cbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeShfZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oKTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KF9kYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbigpO1xuICB9XG4gIGFuaW1hdGVSZWFkeUhpZ2hsaWdodChfZGF0YSkge1xuICAgIGNvbnN0IHsgaXRlbSwgbGFiZWwgfSA9IHRoaXMuYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHJlc2V0TW90aW9uKFt0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbl0sIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHJlc2V0TW90aW9uKFt0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uXSwgbGFiZWwpO1xuICAgIH1cbiAgfVxuICBhbmltYXRlUmVhZHlIaWdobGlnaHRNYXJrZXJzKF9kYXRhKSB7XG4gIH1cbiAgYW5pbWF0ZVJlYWR5UmVzaXplKF9kYXRhKSB7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbigpO1xuICB9XG4gIGFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KF9kYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbigpO1xuICB9XG4gIGNvbXB1dGVGb2N1c0JvdW5kcyhvcHRzKSB7XG4gICAgY29uc3QgZGF0dW0gPSB0aGlzLmdldE5vZGVEYXRhKCk/LltvcHRzLmRhdHVtSW5kZXhdO1xuICAgIGlmIChkYXR1bSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtU2VsZWN0aW9uLnNlbGVjdCgobm9kZSkgPT4gbm9kZSBpbnN0YW5jZW9mIFBhdGggJiYgbm9kZS5kYXR1bSA9PT0gZGF0dW0pWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGdldFNlcmllc1JhbmdlKF9kaXJlY3Rpb24sIF92aXNpYmxlUmFuZ2UpIHtcbiAgICByZXR1cm4gW05hTiwgTmFOXTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL2RvbnV0U2VyaWVzLnRzXG52YXIgRG9udXRTZXJpZXNOb2RlRXZlbnQgPSBjbGFzcyBleHRlbmRzIFNlcmllc05vZGVFdmVudCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIG5hdGl2ZUV2ZW50LCBkYXR1bSwgc2VyaWVzKSB7XG4gICAgc3VwZXIodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpO1xuICAgIHRoaXMuYW5nbGVLZXkgPSBzZXJpZXMucHJvcGVydGllcy5hbmdsZUtleTtcbiAgICB0aGlzLnJhZGl1c0tleSA9IHNlcmllcy5wcm9wZXJ0aWVzLnJhZGl1c0tleTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbEtleSA9IHNlcmllcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbEtleTtcbiAgICB0aGlzLnNlY3RvckxhYmVsS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXk7XG4gIH1cbn07XG52YXIgRG9udXRTZXJpZXMgPSBjbGFzcyBleHRlbmRzIFBvbGFyU2VyaWVzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgcGlja01vZGVzOiBbMSAvKiBORUFSRVNUX05PREUgKi8sIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9dLFxuICAgICAgdXNlTGFiZWxMYXllcjogdHJ1ZSxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7IGl0ZW06IHJlc2V0UGllU2VsZWN0aW9uc0ZuLCBsYWJlbDogcmVzZXRMYWJlbEZuIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgRG9udXRTZXJpZXNQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAgPSBuZXcgVHJhbnNsYXRhYmxlR3JvdXAoe1xuICAgICAgbmFtZTogYCR7dGhpcy5pZH0tYmFja2dyb3VuZGAsXG4gICAgICB6SW5kZXg6IDAgLyogQkFDS0dST1VORCAqL1xuICAgIH0pO1xuICAgIHRoaXMubm9WaXNpYmxlRGF0YSA9IGZhbHNlO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpO1xuICAgIHRoaXMucmFkaXVzU2NhbGUgPSBuZXcgTGluZWFyU2NhbGUoKTtcbiAgICB0aGlzLnBoYW50b21Hcm91cCA9IHRoaXMuYmFja2dyb3VuZEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IFwicGhhbnRvbVwiIH0pKTtcbiAgICB0aGlzLnBoYW50b21TZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5waGFudG9tR3JvdXAsXG4gICAgICAoKSA9PiB0aGlzLm5vZGVGYWN0b3J5KCksXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxHcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IFwicGllQ2FsbG91dExhYmVsc1wiIH0pKTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb24oXG4gICAgICB0aGlzLmNhbGxvdXRMYWJlbEdyb3VwLFxuICAgICAgR3JvdXBcbiAgICApO1xuICAgIC8vIEFHLTYxOTMgSWYgdGhlIHN1bSBvZiBhbGwgZGF0dW1zIGlzIDAsIHRoZW4gd2UnbGwgZHJhdyAxIG9yIDIgcmluZ3MgdG8gcmVwcmVzZW50IHRoZSBlbXB0eSBzZXJpZXMuXG4gICAgdGhpcy56ZXJvc3VtUmluZ3NHcm91cCA9IHRoaXMuYmFja2dyb3VuZEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LXplcm9zdW1SaW5nc2AgfSkpO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZyA9IHRoaXMuemVyb3N1bVJpbmdzR3JvdXAuYXBwZW5kQ2hpbGQobmV3IE1hcmtlcih7IHNoYXBlOiBcImNpcmNsZVwiIH0pKTtcbiAgICB0aGlzLnplcm9zdW1Jbm5lclJpbmcgPSB0aGlzLnplcm9zdW1SaW5nc0dyb3VwLmFwcGVuZENoaWxkKG5ldyBNYXJrZXIoeyBzaGFwZTogXCJjaXJjbGVcIiB9KSk7XG4gICAgdGhpcy5pbm5lckxhYmVsc0dyb3VwID0gdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKHsgbmFtZTogXCJpbm5lckxhYmVsc1wiIH0pKTtcbiAgICB0aGlzLmlubmVyQ2lyY2xlR3JvdXAgPSB0aGlzLmJhY2tncm91bmRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1pbm5lckNpcmNsZWAgfSkpO1xuICAgIHRoaXMuaW5uZXJMYWJlbHNTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMuaW5uZXJMYWJlbHNHcm91cCwgVGV4dCk7XG4gICAgdGhpcy5pbm5lckNpcmNsZVNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLmlubmVyQ2lyY2xlR3JvdXAsXG4gICAgICAoKSA9PiBuZXcgTWFya2VyKHsgc2hhcGU6IFwiY2lyY2xlXCIgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vycm91bmRpbmdSYWRpdXMgPSB2b2lkIDA7XG4gICAgdGhpcy5Ob2RlRXZlbnQgPSBEb251dFNlcmllc05vZGVFdmVudDtcbiAgICB0aGlzLmFuZ2xlU2NhbGUgPSBuZXcgTGluZWFyU2NhbGUoKTtcbiAgICB0aGlzLmFuZ2xlU2NhbGUuZG9tYWluID0gWzAsIDFdO1xuICAgIHRoaXMuYW5nbGVTY2FsZS5yYW5nZSA9IFstTWF0aC5QSSwgTWF0aC5QSV0ubWFwKChhbmdsZTIpID0+IGFuZ2xlMiArIE1hdGguUEkgLyAyKTtcbiAgICB0aGlzLnBoYW50b21Hcm91cC5vcGFjaXR5ID0gMC4yO1xuICB9XG4gIGdldCBjYWxsb3V0Tm9kZURhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMucGhhbnRvbU5vZGVEYXRhID8/IHRoaXMubm9kZURhdGE7XG4gIH1cbiAgYXR0YWNoU2VyaWVzKHNlcmllc0NvbnRlbnROb2RlLCBzZXJpZXNOb2RlLCBhbm5vdGF0aW9uTm9kZSkge1xuICAgIHN1cGVyLmF0dGFjaFNlcmllcyhzZXJpZXNDb250ZW50Tm9kZSwgc2VyaWVzTm9kZSwgYW5ub3RhdGlvbk5vZGUpO1xuICAgIHNlcmllc0NvbnRlbnROb2RlPy5hcHBlbmRDaGlsZCh0aGlzLmJhY2tncm91bmRHcm91cCk7XG4gIH1cbiAgZGV0YWNoU2VyaWVzKHNlcmllc0NvbnRlbnROb2RlLCBzZXJpZXNOb2RlLCBhbm5vdGF0aW9uTm9kZSkge1xuICAgIHN1cGVyLmRldGFjaFNlcmllcyhzZXJpZXNDb250ZW50Tm9kZSwgc2VyaWVzTm9kZSwgYW5ub3RhdGlvbk5vZGUpO1xuICAgIHNlcmllc0NvbnRlbnROb2RlPy5yZW1vdmVDaGlsZCh0aGlzLmJhY2tncm91bmRHcm91cCk7XG4gIH1cbiAgc2V0U2VyaWVzSW5kZXgoaW5kZXgpIHtcbiAgICBpZiAoIXN1cGVyLnNldFNlcmllc0luZGV4KGluZGV4KSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLmJhY2tncm91bmRHcm91cC56SW5kZXggPSBbMCAvKiBCQUNLR1JPVU5EICovLCBpbmRleF07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgbm9kZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBTZWN0b3IoKTtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuYW5nbGVTY2FsZS5kb21haW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnJhZGl1c1NjYWxlLmRvbWFpbjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcbiAgICBpZiAodGhpcy5kYXRhID09IG51bGwgfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyB2aXNpYmxlLCBpZDogc2VyaWVzSWQgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBhbmdsZUtleSwgYW5nbGVGaWx0ZXJLZXksIHJhZGl1c0tleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHZhbGlkU2VjdG9yID0gKF92YWx1ZSwgX2RhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIHZpc2libGUgJiYgdGhpcy5jdHgubGVnZW5kTWFuYWdlci5nZXRJdGVtRW5hYmxlZCh7IHNlcmllc0lkLCBpdGVtSWQ6IGluZGV4IH0pO1xuICAgIH07XG4gICAgY29uc3QgYW5pbWF0aW9uRW5hYmxlZCA9ICF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IGV4dHJhS2V5UHJvcHMgPSBbXTtcbiAgICBjb25zdCBleHRyYVByb3BzID0gW107XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkpIHtcbiAgICAgIGV4dHJhS2V5UHJvcHMucHVzaChrZXlQcm9wZXJ0eShsZWdlbmRJdGVtS2V5LCBcImJhbmRcIiwgeyBpZDogYGxlZ2VuZEl0ZW1LZXlgIH0pKTtcbiAgICB9IGVsc2UgaWYgKGNhbGxvdXRMYWJlbEtleSkge1xuICAgICAgZXh0cmFLZXlQcm9wcy5wdXNoKGtleVByb3BlcnR5KGNhbGxvdXRMYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBjYWxsb3V0TGFiZWxLZXlgIH0pKTtcbiAgICB9IGVsc2UgaWYgKHNlY3RvckxhYmVsS2V5KSB7XG4gICAgICBleHRyYUtleVByb3BzLnB1c2goa2V5UHJvcGVydHkoc2VjdG9yTGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgc2VjdG9yTGFiZWxLZXlgIH0pKTtcbiAgICB9XG4gICAgY29uc3QgcmFkaXVzU2NhbGVUeXBlID0gdGhpcy5yYWRpdXNTY2FsZS50eXBlO1xuICAgIGNvbnN0IGFuZ2xlU2NhbGVUeXBlID0gdGhpcy5hbmdsZVNjYWxlLnR5cGU7XG4gICAgaWYgKHJhZGl1c0tleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKFxuICAgICAgICByYW5nZWRWYWx1ZVByb3BlcnR5KHJhZGl1c0tleSwge1xuICAgICAgICAgIGlkOiBcInJhZGl1c1ZhbHVlXCIsXG4gICAgICAgICAgbWluOiB0aGlzLnByb3BlcnRpZXMucmFkaXVzTWluID8/IDAsXG4gICAgICAgICAgbWF4OiB0aGlzLnByb3BlcnRpZXMucmFkaXVzTWF4XG4gICAgICAgIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHJhZGl1c0tleSwgcmFkaXVzU2NhbGVUeXBlLCB7IGlkOiBgcmFkaXVzUmF3YCB9KSxcbiAgICAgICAgLy8gUmF3IHZhbHVlIHBhc3MtdGhyb3VnaC5cbiAgICAgICAgbm9ybWFsaXNlUHJvcGVydHlUbyhcInJhZGl1c1ZhbHVlXCIsIFswLCAxXSwgMSwgdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c01pbiA/PyAwLCB0aGlzLnByb3BlcnRpZXMucmFkaXVzTWF4KVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNhbGxvdXRMYWJlbEtleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkoY2FsbG91dExhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYGNhbGxvdXRMYWJlbFZhbHVlYCB9KSk7XG4gICAgfVxuICAgIGlmIChzZWN0b3JMYWJlbEtleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkoc2VjdG9yTGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgc2VjdG9yTGFiZWxWYWx1ZWAgfSkpO1xuICAgIH1cbiAgICBpZiAobGVnZW5kSXRlbUtleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkobGVnZW5kSXRlbUtleSwgXCJiYW5kXCIsIHsgaWQ6IGBsZWdlbmRJdGVtVmFsdWVgIH0pKTtcbiAgICB9XG4gICAgaWYgKGFuZ2xlRmlsdGVyS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goXG4gICAgICAgIGFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoYW5nbGVGaWx0ZXJLZXksIGFuZ2xlU2NhbGVUeXBlLCB7XG4gICAgICAgICAgaWQ6IGBhbmdsZUZpbHRlclZhbHVlYCxcbiAgICAgICAgICBvbmx5UG9zaXRpdmU6IHRydWUsXG4gICAgICAgICAgdmFsaWRhdGlvbjogdmFsaWRTZWN0b3IsXG4gICAgICAgICAgaW52YWxpZFZhbHVlOiAwXG4gICAgICAgIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KGFuZ2xlRmlsdGVyS2V5LCBhbmdsZVNjYWxlVHlwZSwgeyBpZDogYGFuZ2xlRmlsdGVyUmF3YCB9KSxcbiAgICAgICAgbm9ybWFsaXNlUHJvcGVydHlUbyhcImFuZ2xlRmlsdGVyVmFsdWVcIiwgWzAsIDFdLCAwLCAwKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGFuaW1hdGlvbkVuYWJsZWQgJiYgdGhpcy5wcm9jZXNzZWREYXRhICYmIGV4dHJhS2V5UHJvcHMubGVuZ3RoID4gMCkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKGRpZmYodGhpcy5pZCwgdGhpcy5wcm9jZXNzZWREYXRhKSk7XG4gICAgfVxuICAgIGV4dHJhUHJvcHMucHVzaChhbmltYXRpb25WYWxpZGF0aW9uKCkpO1xuICAgIGF3YWl0IHRoaXMucmVxdWVzdERhdGFNb2RlbChkYXRhQ29udHJvbGxlciwgdGhpcy5kYXRhLCB7XG4gICAgICBwcm9wczogW1xuICAgICAgICAuLi5leHRyYUtleVByb3BzLFxuICAgICAgICBhY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KGFuZ2xlS2V5LCBhbmdsZVNjYWxlVHlwZSwge1xuICAgICAgICAgIGlkOiBgYW5nbGVWYWx1ZWAsXG4gICAgICAgICAgb25seVBvc2l0aXZlOiB0cnVlLFxuICAgICAgICAgIHZhbGlkYXRpb246IHZhbGlkU2VjdG9yLFxuICAgICAgICAgIGludmFsaWRWYWx1ZTogMFxuICAgICAgICB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eShhbmdsZUtleSwgYW5nbGVTY2FsZVR5cGUsIHsgaWQ6IGBhbmdsZVJhd2AgfSksXG4gICAgICAgIC8vIFJhdyB2YWx1ZSBwYXNzLXRocm91Z2guXG4gICAgICAgIG5vcm1hbGlzZVByb3BlcnR5VG8oXCJhbmdsZVZhbHVlXCIsIFswLCAxXSwgMCwgMCksXG4gICAgICAgIC4uLmV4dHJhUHJvcHNcbiAgICAgIF1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlRGVmIG9mIHRoaXMucHJvY2Vzc2VkRGF0YT8uZGVmcz8udmFsdWVzID8/IFtdKSB7XG4gICAgICBjb25zdCB7IGlkLCBtaXNzaW5nLCBwcm9wZXJ0eSB9ID0gdmFsdWVEZWY7XG4gICAgICBjb25zdCBtaXNzQ291bnQgPSBnZXRNaXNzQ291bnQodGhpcywgbWlzc2luZyk7XG4gICAgICBpZiAoaWQgIT09IFwiYW5nbGVSYXdcIiAmJiBtaXNzQ291bnQgPiAwKSB7XG4gICAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKFxuICAgICAgICAgIGBubyB2YWx1ZSB3YXMgZm91bmQgZm9yIHRoZSBrZXkgJyR7U3RyaW5nKHByb3BlcnR5KX0nIG9uICR7bWlzc0NvdW50fSBkYXRhIGVsZW1lbnQke21pc3NDb3VudCA+IDEgPyBcInNcIiA6IFwiXCJ9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIG1heWJlUmVmcmVzaE5vZGVEYXRhKCkge1xuICAgIGlmICghdGhpcy5ub2RlRGF0YVJlZnJlc2gpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBub2RlRGF0YSA9IFtdLCBwaGFudG9tTm9kZURhdGEgfSA9IHRoaXMuY3JlYXRlTm9kZURhdGEoKSA/PyB7fTtcbiAgICB0aGlzLm5vZGVEYXRhID0gbm9kZURhdGE7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGEgPSBwaGFudG9tTm9kZURhdGE7XG4gICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSBmYWxzZTtcbiAgfVxuICBnZXRQcm9jZXNzZWREYXRhVmFsdWVzKGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSkge1xuICAgIGNvbnN0IGFuZ2xlVmFsdWVzID0gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGBhbmdsZVZhbHVlYCwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgY29uc3QgYW5nbGVSYXdWYWx1ZXMgPSBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYGFuZ2xlUmF3YCwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgY29uc3QgYW5nbGVGaWx0ZXJWYWx1ZXMgPSB0aGlzLnByb3BlcnRpZXMuYW5nbGVGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBgYW5nbGVGaWx0ZXJWYWx1ZWAsIHByb2Nlc3NlZERhdGEpIDogdm9pZCAwO1xuICAgIGNvbnN0IGFuZ2xlRmlsdGVyUmF3VmFsdWVzID0gdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlRmlsdGVyS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYGFuZ2xlRmlsdGVyUmF3YCwgcHJvY2Vzc2VkRGF0YSkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmFkaXVzVmFsdWVzID0gdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c0tleSA/IGRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBgcmFkaXVzVmFsdWVgLCBwcm9jZXNzZWREYXRhKSA6IHZvaWQgMDtcbiAgICBjb25zdCByYWRpdXNSYXdWYWx1ZXMgPSB0aGlzLnByb3BlcnRpZXMucmFkaXVzS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGByYWRpdXNSYXdgLCBwcm9jZXNzZWREYXRhKSA6IHZvaWQgMDtcbiAgICBjb25zdCBjYWxsb3V0TGFiZWxWYWx1ZXMgPSB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGBjYWxsb3V0TGFiZWxWYWx1ZWAsIHByb2Nlc3NlZERhdGEpIDogdm9pZCAwO1xuICAgIGNvbnN0IHNlY3RvckxhYmVsVmFsdWVzID0gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGBzZWN0b3JMYWJlbFZhbHVlYCwgcHJvY2Vzc2VkRGF0YSkgOiB2b2lkIDA7XG4gICAgY29uc3QgbGVnZW5kSXRlbVZhbHVlcyA9IHRoaXMucHJvcGVydGllcy5sZWdlbmRJdGVtS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGBsZWdlbmRJdGVtVmFsdWVgLCBwcm9jZXNzZWREYXRhKSA6IHZvaWQgMDtcbiAgICByZXR1cm4ge1xuICAgICAgYW5nbGVWYWx1ZXMsXG4gICAgICBhbmdsZVJhd1ZhbHVlcyxcbiAgICAgIGFuZ2xlRmlsdGVyVmFsdWVzLFxuICAgICAgYW5nbGVGaWx0ZXJSYXdWYWx1ZXMsXG4gICAgICByYWRpdXNWYWx1ZXMsXG4gICAgICByYWRpdXNSYXdWYWx1ZXMsXG4gICAgICBjYWxsb3V0TGFiZWxWYWx1ZXMsXG4gICAgICBzZWN0b3JMYWJlbFZhbHVlcyxcbiAgICAgIGxlZ2VuZEl0ZW1WYWx1ZXNcbiAgICB9O1xuICB9XG4gIGNyZWF0ZU5vZGVEYXRhKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgIHByb2Nlc3NlZERhdGEsXG4gICAgICBkYXRhTW9kZWwsXG4gICAgICBhbmdsZVNjYWxlLFxuICAgICAgY3R4OiB7IGxlZ2VuZE1hbmFnZXIgfSxcbiAgICAgIHZpc2libGVcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7IHJvdGF0aW9uLCBpbm5lclJhZGl1c1JhdGlvIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcudmlzaWJsZSA9IHRydWU7XG4gICAgICB0aGlzLnplcm9zdW1Jbm5lclJpbmcudmlzaWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4geyBpdGVtSWQ6IHNlcmllc0lkLCBub2RlRGF0YTogW10sIGxhYmVsRGF0YTogW10gfTtcbiAgICB9XG4gICAgaWYgKCFkYXRhTW9kZWwgfHwgcHJvY2Vzc2VkRGF0YT8udHlwZSAhPT0gXCJ1bmdyb3VwZWRcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBhbmdsZVZhbHVlcyxcbiAgICAgIGFuZ2xlUmF3VmFsdWVzLFxuICAgICAgYW5nbGVGaWx0ZXJWYWx1ZXMsXG4gICAgICBhbmdsZUZpbHRlclJhd1ZhbHVlcyxcbiAgICAgIHJhZGl1c1ZhbHVlcyxcbiAgICAgIHJhZGl1c1Jhd1ZhbHVlcyxcbiAgICAgIGNhbGxvdXRMYWJlbFZhbHVlcyxcbiAgICAgIHNlY3RvckxhYmVsVmFsdWVzLFxuICAgICAgbGVnZW5kSXRlbVZhbHVlc1xuICAgIH0gPSB0aGlzLmdldFByb2Nlc3NlZERhdGFWYWx1ZXMoZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhKTtcbiAgICBjb25zdCB1c2VGaWx0ZXJBbmdsZXMgPSBhbmdsZUZpbHRlclJhd1ZhbHVlcz8uc29tZSgoZmlsdGVyUmF3VmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gZmlsdGVyUmF3VmFsdWUgPiBhbmdsZVJhd1ZhbHVlc1tpbmRleF07XG4gICAgfSkgPz8gZmFsc2U7XG4gICAgbGV0IGN1cnJlbnRTdGFydCA9IDA7XG4gICAgbGV0IHN1bTIgPSAwO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3QgcGhhbnRvbU5vZGVzID0gYW5nbGVGaWx0ZXJSYXdWYWx1ZXMgIT0gbnVsbCA/IFtdIDogdm9pZCAwO1xuICAgIGNvbnN0IHJhd0RhdGEgPSBwcm9jZXNzZWREYXRhLmRhdGFTb3VyY2VzLmdldCh0aGlzLmlkKSA/PyBbXTtcbiAgICBjb25zdCBpbnZhbGlkRGF0YSA9IHByb2Nlc3NlZERhdGEuaW52YWxpZERhdGE/LmdldCh0aGlzLmlkKTtcbiAgICByYXdEYXRhLmZvckVhY2goKGRhdHVtLCBkYXR1bUluZGV4KSA9PiB7XG4gICAgICBpZiAoaW52YWxpZERhdGE/LltkYXR1bUluZGV4XSA9PT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdXNlRmlsdGVyQW5nbGVzID8gYW5nbGVGaWx0ZXJWYWx1ZXNbZGF0dW1JbmRleF0gOiBhbmdsZVZhbHVlc1tkYXR1bUluZGV4XTtcbiAgICAgIGNvbnN0IGNyb3NzRmlsdGVyU2NhbGUgPSBhbmdsZUZpbHRlclJhd1ZhbHVlcyAhPSBudWxsICYmICF1c2VGaWx0ZXJBbmdsZXMgPyBNYXRoLnNxcnQoYW5nbGVGaWx0ZXJSYXdWYWx1ZXNbZGF0dW1JbmRleF0gLyBhbmdsZVJhd1ZhbHVlc1tkYXR1bUluZGV4XSkgOiAxO1xuICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IGFuZ2xlU2NhbGUuY29udmVydChjdXJyZW50U3RhcnQpICsgdG9SYWRpYW5zKHJvdGF0aW9uKTtcbiAgICAgIGN1cnJlbnRTdGFydCA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgIHN1bTIgKz0gY3VycmVudFZhbHVlO1xuICAgICAgY29uc3QgZW5kQW5nbGUgPSBhbmdsZVNjYWxlLmNvbnZlcnQoY3VycmVudFN0YXJ0KSArIHRvUmFkaWFucyhyb3RhdGlvbik7XG4gICAgICBjb25zdCBzcGFuID0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICAgIGNvbnN0IG1pZEFuZ2xlID0gc3RhcnRBbmdsZSArIHNwYW4gLyAyO1xuICAgICAgY29uc3QgYW5nbGVWYWx1ZSA9IGFuZ2xlUmF3VmFsdWVzW2RhdHVtSW5kZXhdO1xuICAgICAgY29uc3QgcmFkaXVzUmF3ID0gcmFkaXVzVmFsdWVzPy5bZGF0dW1JbmRleF0gPz8gMTtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IHJhZGl1c1JhdyAqIGNyb3NzRmlsdGVyU2NhbGU7XG4gICAgICBjb25zdCByYWRpdXNWYWx1ZSA9IHJhZGl1c1Jhd1ZhbHVlcz8uW2RhdHVtSW5kZXhdO1xuICAgICAgY29uc3QgbGVnZW5kSXRlbVZhbHVlID0gbGVnZW5kSXRlbVZhbHVlcz8uW2RhdHVtSW5kZXhdO1xuICAgICAgY29uc3Qgbm9kZUxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgbWlkQW5nbGUsXG4gICAgICAgIHNwYW4sXG4gICAgICAgIHRydWUsXG4gICAgICAgIGNhbGxvdXRMYWJlbFZhbHVlcz8uW2RhdHVtSW5kZXhdLFxuICAgICAgICBzZWN0b3JMYWJlbFZhbHVlcz8uW2RhdHVtSW5kZXhdLFxuICAgICAgICBsZWdlbmRJdGVtVmFsdWVcbiAgICAgICk7XG4gICAgICBjb25zdCBzZWN0b3JGb3JtYXQgPSB0aGlzLmdldFNlY3RvckZvcm1hdChkYXR1bSwgZGF0dW1JbmRleCwgZmFsc2UpO1xuICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgaXRlbUlkOiBkYXR1bUluZGV4LFxuICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgIGRhdHVtLFxuICAgICAgICBkYXR1bUluZGV4LFxuICAgICAgICBhbmdsZVZhbHVlLFxuICAgICAgICBtaWRBbmdsZSxcbiAgICAgICAgbWlkQ29zOiBNYXRoLmNvcyhtaWRBbmdsZSksXG4gICAgICAgIG1pZFNpbjogTWF0aC5zaW4obWlkQW5nbGUpLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZSxcbiAgICAgICAgcmFkaXVzLFxuICAgICAgICBpbm5lclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDApLCAwKSxcbiAgICAgICAgb3V0ZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydChyYWRpdXMpLCAwKSxcbiAgICAgICAgc2VjdG9yRm9ybWF0LFxuICAgICAgICByYWRpdXNWYWx1ZSxcbiAgICAgICAgbGVnZW5kSXRlbVZhbHVlLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlICYmIGxlZ2VuZE1hbmFnZXIuZ2V0SXRlbUVuYWJsZWQoeyBzZXJpZXNJZCwgaXRlbUlkOiBkYXR1bUluZGV4IH0pLFxuICAgICAgICBmb2N1c2FibGU6IHRydWUsXG4gICAgICAgIC4uLm5vZGVMYWJlbHNcbiAgICAgIH07XG4gICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgaWYgKHBoYW50b21Ob2RlcyAhPSBudWxsKSB7XG4gICAgICAgIHBoYW50b21Ob2Rlcy5wdXNoKHtcbiAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgIHJhZGl1czogMSxcbiAgICAgICAgICBpbm5lclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDApLCAwKSxcbiAgICAgICAgICBvdXRlclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDEpLCAwKSxcbiAgICAgICAgICBmb2N1c2FibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy52aXNpYmxlID0gc3VtMiA9PT0gMDtcbiAgICB0aGlzLnplcm9zdW1Jbm5lclJpbmcudmlzaWJsZSA9IHN1bTIgPT09IDAgJiYgaW5uZXJSYWRpdXNSYXRpbyAhPSBudWxsICYmIGlubmVyUmFkaXVzUmF0aW8gIT09IDEgJiYgaW5uZXJSYWRpdXNSYXRpbyA+IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1JZDogc2VyaWVzSWQsXG4gICAgICBub2RlRGF0YTogbm9kZXMsXG4gICAgICBsYWJlbERhdGE6IG5vZGVzLFxuICAgICAgcGhhbnRvbU5vZGVEYXRhOiBwaGFudG9tTm9kZXNcbiAgICB9O1xuICB9XG4gIGdldExhYmVscyhkYXR1bSwgbWlkQW5nbGUsIHNwYW4sIHNraXBEaXNhYmxlZCwgY2FsbG91dExhYmVsVmFsdWUsIHNlY3RvckxhYmVsVmFsdWUsIGxlZ2VuZEl0ZW1WYWx1ZSkge1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsLCBzZWN0b3JMYWJlbCwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNhbGxvdXRMYWJlbEtleSA9ICFza2lwRGlzYWJsZWQgfHwgY2FsbG91dExhYmVsLmVuYWJsZWQgPyB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5IDogdm9pZCAwO1xuICAgIGNvbnN0IHNlY3RvckxhYmVsS2V5ID0gIXNraXBEaXNhYmxlZCB8fCBzZWN0b3JMYWJlbC5lbmFibGVkID8gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5IDogdm9pZCAwO1xuICAgIGlmICghY2FsbG91dExhYmVsS2V5ICYmICFzZWN0b3JMYWJlbEtleSAmJiAhbGVnZW5kSXRlbUtleSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBsYWJlbEZvcm1hdHRlclBhcmFtcyA9IHtcbiAgICAgIGRhdHVtLFxuICAgICAgYW5nbGVLZXk6IHRoaXMucHJvcGVydGllcy5hbmdsZUtleSxcbiAgICAgIGFuZ2xlTmFtZTogdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlTmFtZSxcbiAgICAgIHJhZGl1c0tleTogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c0tleSxcbiAgICAgIHJhZGl1c05hbWU6IHRoaXMucHJvcGVydGllcy5yYWRpdXNOYW1lLFxuICAgICAgY2FsbG91dExhYmVsS2V5OiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5LFxuICAgICAgY2FsbG91dExhYmVsTmFtZTogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbE5hbWUsXG4gICAgICBzZWN0b3JMYWJlbEtleTogdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5LFxuICAgICAgc2VjdG9yTGFiZWxOYW1lOiB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxOYW1lLFxuICAgICAgbGVnZW5kSXRlbUtleTogdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXlcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGlmIChjYWxsb3V0TGFiZWxLZXkgJiYgc3BhbiA+PSB0b1JhZGlhbnMoY2FsbG91dExhYmVsLm1pbkFuZ2xlKSkge1xuICAgICAgcmVzdWx0LmNhbGxvdXRMYWJlbCA9IHtcbiAgICAgICAgLi4udGhpcy5nZXRUZXh0QWxpZ25tZW50KG1pZEFuZ2xlKSxcbiAgICAgICAgdGV4dDogdGhpcy5nZXRMYWJlbFRleHQoY2FsbG91dExhYmVsLCB7XG4gICAgICAgICAgLi4ubGFiZWxGb3JtYXR0ZXJQYXJhbXMsXG4gICAgICAgICAgdmFsdWU6IGNhbGxvdXRMYWJlbFZhbHVlXG4gICAgICAgIH0pLFxuICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICBjb2xsaXNpb25UZXh0QWxpZ246IHZvaWQgMCxcbiAgICAgICAgY29sbGlzaW9uT2Zmc2V0WTogMCxcbiAgICAgICAgYm94OiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChzZWN0b3JMYWJlbEtleSkge1xuICAgICAgcmVzdWx0LnNlY3RvckxhYmVsID0ge1xuICAgICAgICB0ZXh0OiB0aGlzLmdldExhYmVsVGV4dChzZWN0b3JMYWJlbCwge1xuICAgICAgICAgIC4uLmxhYmVsRm9ybWF0dGVyUGFyYW1zLFxuICAgICAgICAgIHZhbHVlOiBzZWN0b3JMYWJlbFZhbHVlXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobGVnZW5kSXRlbUtleSAhPSBudWxsICYmIGxlZ2VuZEl0ZW1WYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXN1bHQubGVnZW5kSXRlbSA9IHsga2V5OiBsZWdlbmRJdGVtS2V5LCB0ZXh0OiBsZWdlbmRJdGVtVmFsdWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXRUZXh0QWxpZ25tZW50KG1pZEFuZ2xlKSB7XG4gICAgY29uc3QgcXVhZHJhbnRUZXh0T3B0cyA9IFtcbiAgICAgIHsgdGV4dEFsaWduOiBcImNlbnRlclwiLCB0ZXh0QmFzZWxpbmU6IFwiYm90dG9tXCIgfSxcbiAgICAgIHsgdGV4dEFsaWduOiBcImxlZnRcIiwgdGV4dEJhc2VsaW5lOiBcIm1pZGRsZVwiIH0sXG4gICAgICB7IHRleHRBbGlnbjogXCJjZW50ZXJcIiwgdGV4dEJhc2VsaW5lOiBcImhhbmdpbmdcIiB9LFxuICAgICAgeyB0ZXh0QWxpZ246IFwicmlnaHRcIiwgdGV4dEJhc2VsaW5lOiBcIm1pZGRsZVwiIH1cbiAgICBdO1xuICAgIGNvbnN0IG1pZEFuZ2xlMTgwID0gbm9ybWFsaXplQW5nbGUxODAobWlkQW5nbGUpO1xuICAgIGNvbnN0IHF1YWRyYW50U3RhcnQgPSAtMC43NSAqIE1hdGguUEk7XG4gICAgY29uc3QgcXVhZHJhbnRPZmZzZXQgPSBtaWRBbmdsZTE4MCAtIHF1YWRyYW50U3RhcnQ7XG4gICAgY29uc3QgcXVhZHJhbnQgPSBNYXRoLmZsb29yKHF1YWRyYW50T2Zmc2V0IC8gKE1hdGguUEkgLyAyKSk7XG4gICAgY29uc3QgcXVhZHJhbnRJbmRleCA9IG1vZChxdWFkcmFudCwgcXVhZHJhbnRUZXh0T3B0cy5sZW5ndGgpO1xuICAgIHJldHVybiBxdWFkcmFudFRleHRPcHRzW3F1YWRyYW50SW5kZXhdO1xuICB9XG4gIGdldFNlY3RvckZvcm1hdChkYXR1bSwgZGF0dW1JbmRleCwgaGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25zdCB7IGFuZ2xlS2V5LCByYWRpdXNLZXksIGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXksIGZpbGxzLCBzdHJva2VzLCBpdGVtU3R5bGVyIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgZGVmYXVsdFN0cm9rZSA9IHN0cm9rZXNbZGF0dW1JbmRleCAlIHN0cm9rZXMubGVuZ3RoXTtcbiAgICBjb25zdCB7IGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2U6IHN0cm9rZTIsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5LCBsaW5lRGFzaCwgbGluZURhc2hPZmZzZXQsIGNvcm5lclJhZGl1cyB9ID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgIGhpZ2hsaWdodGVkICYmIHRoaXMucHJvcGVydGllcy5oaWdobGlnaHRTdHlsZS5pdGVtLFxuICAgICAge1xuICAgICAgICBmaWxsOiBmaWxscy5sZW5ndGggPiAwID8gZmlsbHNbZGF0dW1JbmRleCAlIGZpbGxzLmxlbmd0aF0gOiB2b2lkIDAsXG4gICAgICAgIHN0cm9rZTogZGVmYXVsdFN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuZ2V0U3Ryb2tlV2lkdGgodGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoKSxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5nZXRPcGFjaXR5KClcbiAgICAgIH0sXG4gICAgICB0aGlzLnByb3BlcnRpZXNcbiAgICApO1xuICAgIGxldCBmb3JtYXQ7XG4gICAgaWYgKGl0ZW1TdHlsZXIpIHtcbiAgICAgIGZvcm1hdCA9IHRoaXMuY2FjaGVkRGF0dW1DYWxsYmFjayhcbiAgICAgICAgdGhpcy5nZXREYXR1bUlkKGRhdHVtLCBkYXR1bUluZGV4KSArIChoaWdobGlnaHRlZCA/IFwiLWhpZ2hsaWdodFwiIDogXCItaGlkZVwiKSxcbiAgICAgICAgKCkgPT4gaXRlbVN0eWxlcih7XG4gICAgICAgICAgZGF0dW0sXG4gICAgICAgICAgYW5nbGVLZXksXG4gICAgICAgICAgcmFkaXVzS2V5LFxuICAgICAgICAgIGNhbGxvdXRMYWJlbEtleSxcbiAgICAgICAgICBzZWN0b3JMYWJlbEtleSxcbiAgICAgICAgICBsZWdlbmRJdGVtS2V5LFxuICAgICAgICAgIGZpbGwsXG4gICAgICAgICAgZmlsbE9wYWNpdHksXG4gICAgICAgICAgc3Ryb2tlOiBzdHJva2UyLFxuICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgbGluZURhc2gsXG4gICAgICAgICAgbGluZURhc2hPZmZzZXQsXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGhpZ2hsaWdodGVkLFxuICAgICAgICAgIHNlcmllc0lkOiB0aGlzLmlkXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZmlsbDogZm9ybWF0Py5maWxsID8/IGZpbGwsXG4gICAgICBmaWxsT3BhY2l0eTogZm9ybWF0Py5maWxsT3BhY2l0eSA/PyBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZTogZm9ybWF0Py5zdHJva2UgPz8gc3Ryb2tlMixcbiAgICAgIHN0cm9rZVdpZHRoOiBmb3JtYXQ/LnN0cm9rZVdpZHRoID8/IHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogZm9ybWF0Py5zdHJva2VPcGFjaXR5ID8/IHN0cm9rZU9wYWNpdHksXG4gICAgICBsaW5lRGFzaDogZm9ybWF0Py5saW5lRGFzaCA/PyBsaW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiBmb3JtYXQ/LmxpbmVEYXNoT2Zmc2V0ID8/IGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgY29ybmVyUmFkaXVzOiBmb3JtYXQ/LmNvcm5lclJhZGl1cyA/PyBjb3JuZXJSYWRpdXNcbiAgICB9O1xuICB9XG4gIGdldElubmVyUmFkaXVzKCkge1xuICAgIGNvbnN0IHsgcmFkaXVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgaW5uZXJSYWRpdXNSYXRpbyA9IDEsIGlubmVyUmFkaXVzT2Zmc2V0ID0gMCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gcmFkaXVzICogaW5uZXJSYWRpdXNSYXRpbyArIGlubmVyUmFkaXVzT2Zmc2V0O1xuICAgIGlmIChpbm5lclJhZGl1cyA9PT0gcmFkaXVzIHx8IGlubmVyUmFkaXVzIDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBpbm5lclJhZGl1cztcbiAgfVxuICBnZXRPdXRlclJhZGl1cygpIHtcbiAgICBjb25zdCB7IG91dGVyUmFkaXVzUmF0aW8sIG91dGVyUmFkaXVzT2Zmc2V0IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMucmFkaXVzICogb3V0ZXJSYWRpdXNSYXRpbyArIG91dGVyUmFkaXVzT2Zmc2V0LCAwKTtcbiAgfVxuICB1cGRhdGVSYWRpdXNTY2FsZShyZXNpemUpIHtcbiAgICBjb25zdCBuZXdSYW5nZSA9IFt0aGlzLmdldElubmVyUmFkaXVzKCksIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKV07XG4gICAgdGhpcy5yYWRpdXNTY2FsZS5yYW5nZSA9IG5ld1JhbmdlO1xuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IG5ld1JhbmdlO1xuICAgIH1cbiAgICBjb25zdCBzZXRSYWRpaSA9IChkKSA9PiAoe1xuICAgICAgLi4uZCxcbiAgICAgIGlubmVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoMCksIDApLFxuICAgICAgb3V0ZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydChkLnJhZGl1cyksIDApXG4gICAgfSk7XG4gICAgdGhpcy5ub2RlRGF0YSA9IHRoaXMubm9kZURhdGEubWFwKHNldFJhZGlpKTtcbiAgICB0aGlzLnBoYW50b21Ob2RlRGF0YSA9IHRoaXMucGhhbnRvbU5vZGVEYXRhPy5tYXAoc2V0UmFkaWkpO1xuICB9XG4gIGdldFRpdGxlVHJhbnNsYXRpb25ZKCkge1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoMCwgdGhpcy5yYWRpdXNTY2FsZS5yYW5nZVsxXSk7XG4gICAgaWYgKG91dGVyUmFkaXVzID09PSAwKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBjb25zdCBzcGFjaW5nID0gdGhpcy5wcm9wZXJ0aWVzLnRpdGxlPy5zcGFjaW5nID8/IDA7XG4gICAgY29uc3QgdGl0bGVPZmZzZXQgPSAyICsgc3BhY2luZztcbiAgICBjb25zdCBkeSA9IE1hdGgubWF4KDAsIC1vdXRlclJhZGl1cyk7XG4gICAgcmV0dXJuIC1vdXRlclJhZGl1cyAtIHRpdGxlT2Zmc2V0IC0gZHk7XG4gIH1cbiAgdXBkYXRlKHsgc2VyaWVzUmVjdCB9KSB7XG4gICAgY29uc3QgeyB0aXRsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzID0ge1xuICAgICAgc2VyaWVzUmVjdFdpZHRoOiBzZXJpZXNSZWN0Py53aWR0aCxcbiAgICAgIHNlcmllc1JlY3RIZWlnaHQ6IHNlcmllc1JlY3Q/LmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgcmVzaXplID0ganNvbkRpZmYodGhpcy5ub2RlRGF0YURlcGVuZGVuY2llcywgbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXMpICE9IG51bGw7XG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgdGhpcy5fbm9kZURhdGFEZXBlbmRlbmNpZXMgPSBuZXdOb2RlRGF0YURlcGVuZGVuY2llcztcbiAgICB9XG4gICAgdGhpcy5tYXliZVJlZnJlc2hOb2RlRGF0YSgpO1xuICAgIHRoaXMudXBkYXRlVGl0bGVOb2RlcygpO1xuICAgIHRoaXMudXBkYXRlUmFkaXVzU2NhbGUocmVzaXplKTtcbiAgICB0aGlzLmNvbnRlbnRHcm91cC50cmFuc2xhdGlvblggPSB0aGlzLmNlbnRlclg7XG4gICAgdGhpcy5jb250ZW50R3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xuICAgIHRoaXMuaGlnaGxpZ2h0R3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy5jZW50ZXJYO1xuICAgIHRoaXMuaGlnaGxpZ2h0R3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcbiAgICB0aGlzLmJhY2tncm91bmRHcm91cC50cmFuc2xhdGlvblkgPSB0aGlzLmNlbnRlclk7XG4gICAgaWYgKHRoaXMubGFiZWxHcm91cCkge1xuICAgICAgdGhpcy5sYWJlbEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcbiAgICAgIHRoaXMubGFiZWxHcm91cC50cmFuc2xhdGlvblkgPSB0aGlzLmNlbnRlclk7XG4gICAgfVxuICAgIGlmICh0aXRsZSkge1xuICAgICAgY29uc3QgZHkgPSB0aGlzLmdldFRpdGxlVHJhbnNsYXRpb25ZKCk7XG4gICAgICB0aXRsZS5ub2RlLnkgPSBpc0Zpbml0ZShkeSkgPyBkeSA6IDA7XG4gICAgICBjb25zdCB0aXRsZUJveCA9IHRpdGxlLm5vZGUuZ2V0QkJveCgpO1xuICAgICAgdGl0bGUubm9kZS52aXNpYmxlID0gdGl0bGUuZW5hYmxlZCAmJiBpc0Zpbml0ZShkeSkgJiYgIXRoaXMuYmJveEludGVyc2VjdHNTdXJyb3VuZGluZ1Nlcmllcyh0aXRsZUJveCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2lyY2xlIG9mIFt0aGlzLnplcm9zdW1Jbm5lclJpbmcsIHRoaXMuemVyb3N1bU91dGVyUmluZ10pIHtcbiAgICAgIGNpcmNsZS5maWxsT3BhY2l0eSA9IDA7XG4gICAgICBjaXJjbGUuc3Ryb2tlID0gdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbC5jb2xvcjtcbiAgICAgIGNpcmNsZS5zdHJva2VXaWR0aCA9IDE7XG4gICAgICBjaXJjbGUuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTm9kZU1pZFBvaW50KCk7XG4gICAgdGhpcy51cGRhdGVTZWxlY3Rpb25zKCk7XG4gICAgdGhpcy51cGRhdGVOb2RlcyhzZXJpZXNSZWN0KTtcbiAgfVxuICB1cGRhdGVUaXRsZU5vZGVzKCkge1xuICAgIGNvbnN0IHsgb2xkVGl0bGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB0aXRsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmIChvbGRUaXRsZSAhPT0gdGl0bGUpIHtcbiAgICAgIGlmIChvbGRUaXRsZSkge1xuICAgICAgICB0aGlzLmxhYmVsR3JvdXA/LnJlbW92ZUNoaWxkKG9sZFRpdGxlLm5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIHRpdGxlLm5vZGUudGV4dEJhc2VsaW5lID0gXCJib3R0b21cIjtcbiAgICAgICAgdGhpcy5sYWJlbEdyb3VwPy5hcHBlbmRDaGlsZCh0aXRsZS5ub2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2xkVGl0bGUgPSB0aXRsZTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlTm9kZU1pZFBvaW50KCkge1xuICAgIGNvbnN0IHNldE1pZFBvaW50ID0gKGQpID0+IHtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IGQuaW5uZXJSYWRpdXMgKyAoZC5vdXRlclJhZGl1cyAtIGQuaW5uZXJSYWRpdXMpIC8gMjtcbiAgICAgIGQubWlkUG9pbnQgPSB7XG4gICAgICAgIHg6IGQubWlkQ29zICogTWF0aC5tYXgoMCwgcmFkaXVzKSxcbiAgICAgICAgeTogZC5taWRTaW4gKiBNYXRoLm1heCgwLCByYWRpdXMpXG4gICAgICB9O1xuICAgIH07XG4gICAgdGhpcy5ub2RlRGF0YS5mb3JFYWNoKHNldE1pZFBvaW50KTtcbiAgICB0aGlzLnBoYW50b21Ob2RlRGF0YT8uZm9yRWFjaChzZXRNaWRQb2ludCk7XG4gIH1cbiAgdXBkYXRlU2VsZWN0aW9ucygpIHtcbiAgICB0aGlzLnVwZGF0ZUdyb3VwU2VsZWN0aW9uKCk7XG4gICAgdGhpcy51cGRhdGVJbm5lckNpcmNsZVNlbGVjdGlvbigpO1xuICB9XG4gIHVwZGF0ZUdyb3VwU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGl0ZW1TZWxlY3Rpb24sXG4gICAgICBoaWdobGlnaHRTZWxlY3Rpb24sXG4gICAgICBwaGFudG9tU2VsZWN0aW9uLFxuICAgICAgaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24sXG4gICAgICBjYWxsb3V0TGFiZWxTZWxlY3Rpb24sXG4gICAgICBsYWJlbFNlbGVjdGlvbixcbiAgICAgIGlubmVyTGFiZWxzU2VsZWN0aW9uXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgaGlnaGxpZ2h0ZWROb2RlRGF0YSA9IHRoaXMubm9kZURhdGEubWFwKChkYXR1bSkgPT4gKHtcbiAgICAgIC4uLmRhdHVtLFxuICAgICAgLy8gQWxsb3cgbXV0YWJsZSBzZWN0b3JGb3JtYXQsIHNvIGZvcm1hdHRlZCBzZWN0b3Igc3R5bGVzIGNhbiBiZSB1cGRhdGVkIGFuZCB2YXJpZWRcbiAgICAgIC8vIGJldHdlZW4gbm9ybWFsIGFuZCBoaWdobGlnaHRlZCBjYXNlcy5cbiAgICAgIHNlY3RvckZvcm1hdDogeyAuLi5kYXR1bS5zZWN0b3JGb3JtYXQgfVxuICAgIH0pKTtcbiAgICBjb25zdCB1cGRhdGUgPSAoc2VsZWN0aW9uLCBub2RlRGF0YSkgPT4ge1xuICAgICAgc2VsZWN0aW9uLnVwZGF0ZShub2RlRGF0YSwgdm9pZCAwLCAoZGF0dW0pID0+IHRoaXMuZ2V0RGF0dW1JZChkYXR1bS5kYXR1bSwgZGF0dW0uZGF0dW1JbmRleCkpO1xuICAgICAgaWYgKHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCkpIHtcbiAgICAgICAgc2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHVwZGF0ZShpdGVtU2VsZWN0aW9uLCB0aGlzLm5vZGVEYXRhKTtcbiAgICB1cGRhdGUoaGlnaGxpZ2h0U2VsZWN0aW9uLCBoaWdobGlnaHRlZE5vZGVEYXRhKTtcbiAgICB1cGRhdGUocGhhbnRvbVNlbGVjdGlvbiwgdGhpcy5waGFudG9tTm9kZURhdGEgPz8gW10pO1xuICAgIGNhbGxvdXRMYWJlbFNlbGVjdGlvbi51cGRhdGUodGhpcy5jYWxsb3V0Tm9kZURhdGEsIChncm91cCkgPT4ge1xuICAgICAgY29uc3QgbGluZSA9IG5ldyBMaW5lKCk7XG4gICAgICBsaW5lLnRhZyA9IDAgLyogQ2FsbG91dCAqLztcbiAgICAgIGxpbmUucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKGxpbmUpO1xuICAgICAgY29uc3QgdGV4dDIgPSBuZXcgVGV4dCgpO1xuICAgICAgdGV4dDIudGFnID0gMSAvKiBMYWJlbCAqLztcbiAgICAgIHRleHQyLnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgICBncm91cC5hcHBlbmRDaGlsZCh0ZXh0Mik7XG4gICAgfSk7XG4gICAgbGFiZWxTZWxlY3Rpb24udXBkYXRlKHRoaXMubm9kZURhdGEpO1xuICAgIGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLnVwZGF0ZShoaWdobGlnaHRlZE5vZGVEYXRhKTtcbiAgICBpbm5lckxhYmVsc1NlbGVjdGlvbi51cGRhdGUodGhpcy5wcm9wZXJ0aWVzLmlubmVyTGFiZWxzLCAobm9kZSkgPT4ge1xuICAgICAgbm9kZS5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUlubmVyQ2lyY2xlU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHsgaW5uZXJDaXJjbGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBsZXQgcmFkaXVzID0gMDtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHRoaXMuZ2V0SW5uZXJSYWRpdXMoKTtcbiAgICBpZiAoaW5uZXJSYWRpdXMgPiAwKSB7XG4gICAgICBjb25zdCBjaXJjbGVSYWRpdXMgPSBNYXRoLm1pbihpbm5lclJhZGl1cywgdGhpcy5nZXRPdXRlclJhZGl1cygpKTtcbiAgICAgIGNvbnN0IGFudGlBbGlhc2luZ1BhZGRpbmcgPSAxO1xuICAgICAgcmFkaXVzID0gTWF0aC5jZWlsKGNpcmNsZVJhZGl1cyAqIDIgKyBhbnRpQWxpYXNpbmdQYWRkaW5nKTtcbiAgICB9XG4gICAgY29uc3QgZGF0dW1zID0gaW5uZXJDaXJjbGUgPyBbeyByYWRpdXMgfV0gOiBbXTtcbiAgICB0aGlzLmlubmVyQ2lyY2xlU2VsZWN0aW9uLnVwZGF0ZShkYXR1bXMpO1xuICB9XG4gIHVwZGF0ZU5vZGVzKHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCBoaWdobGlnaHRlZERhdHVtID0gdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlci5nZXRBY3RpdmVIaWdobGlnaHQoKTtcbiAgICBjb25zdCB7IHZpc2libGUgfSA9IHRoaXM7XG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAudmlzaWJsZSA9IHZpc2libGU7XG4gICAgdGhpcy5jb250ZW50R3JvdXAudmlzaWJsZSA9IHZpc2libGU7XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC52aXNpYmxlID0gdmlzaWJsZSAmJiBoaWdobGlnaHRlZERhdHVtPy5zZXJpZXMgPT09IHRoaXM7XG4gICAgdGhpcy5oaWdobGlnaHRMYWJlbC52aXNpYmxlID0gdmlzaWJsZSAmJiBoaWdobGlnaHRlZERhdHVtPy5zZXJpZXMgPT09IHRoaXM7XG4gICAgdGhpcy5sYWJlbEdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIHRoaXMuY29udGVudEdyb3VwLm9wYWNpdHkgPSB0aGlzLmdldE9wYWNpdHkoKTtcbiAgICB0aGlzLmlubmVyQ2lyY2xlU2VsZWN0aW9uLmVhY2goKG5vZGUsIHsgcmFkaXVzIH0pID0+IHtcbiAgICAgIG5vZGUuc2V0UHJvcGVydGllcyh7XG4gICAgICAgIGZpbGw6IHRoaXMucHJvcGVydGllcy5pbm5lckNpcmNsZT8uZmlsbCxcbiAgICAgICAgb3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLmlubmVyQ2lyY2xlPy5maWxsT3BhY2l0eSxcbiAgICAgICAgc2l6ZTogcmFkaXVzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBhbmltYXRpb25EaXNhYmxlZCA9IHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgdXBkYXRlU2VjdG9yRm4gPSAoc2VjdG9yLCBkYXR1bSwgX2luZGV4LCBpc0RhdHVtSGlnaGxpZ2h0ZWQpID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLmRhdHVtLCBkYXR1bS5pdGVtSWQsIGlzRGF0dW1IaWdobGlnaHRlZCk7XG4gICAgICBkYXR1bS5zZWN0b3JGb3JtYXQuZmlsbCA9IGZvcm1hdC5maWxsO1xuICAgICAgZGF0dW0uc2VjdG9yRm9ybWF0LnN0cm9rZSA9IGZvcm1hdC5zdHJva2U7XG4gICAgICBpZiAoYW5pbWF0aW9uRGlzYWJsZWQpIHtcbiAgICAgICAgc2VjdG9yLnN0YXJ0QW5nbGUgPSBkYXR1bS5zdGFydEFuZ2xlO1xuICAgICAgICBzZWN0b3IuZW5kQW5nbGUgPSBkYXR1bS5lbmRBbmdsZTtcbiAgICAgICAgc2VjdG9yLmlubmVyUmFkaXVzID0gZGF0dW0uaW5uZXJSYWRpdXM7XG4gICAgICAgIHNlY3Rvci5vdXRlclJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGF0dW1IaWdobGlnaHRlZCB8fCBhbmltYXRpb25EaXNhYmxlZCkge1xuICAgICAgICBzZWN0b3IuZmlsbCA9IGZvcm1hdC5maWxsO1xuICAgICAgICBzZWN0b3Iuc3Ryb2tlID0gZm9ybWF0LnN0cm9rZTtcbiAgICAgIH1cbiAgICAgIHNlY3Rvci5zdHJva2VXaWR0aCA9IGZvcm1hdC5zdHJva2VXaWR0aDtcbiAgICAgIHNlY3Rvci5maWxsT3BhY2l0eSA9IGZvcm1hdC5maWxsT3BhY2l0eTtcbiAgICAgIHNlY3Rvci5zdHJva2VPcGFjaXR5ID0gZm9ybWF0LnN0cm9rZU9wYWNpdHk7XG4gICAgICBzZWN0b3IubGluZURhc2ggPSBmb3JtYXQubGluZURhc2g7XG4gICAgICBzZWN0b3IubGluZURhc2hPZmZzZXQgPSBmb3JtYXQubGluZURhc2hPZmZzZXQ7XG4gICAgICBzZWN0b3IuY29ybmVyUmFkaXVzID0gZm9ybWF0LmNvcm5lclJhZGl1cztcbiAgICAgIHNlY3Rvci5maWxsU2hhZG93ID0gdGhpcy5wcm9wZXJ0aWVzLnNoYWRvdztcbiAgICAgIGNvbnN0IGluc2V0ID0gTWF0aC5tYXgoXG4gICAgICAgICh0aGlzLnByb3BlcnRpZXMuc2VjdG9yU3BhY2luZyArIChmb3JtYXQuc3Ryb2tlICE9IG51bGwgPyBmb3JtYXQuc3Ryb2tlV2lkdGggOiAwKSkgLyAyLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgc2VjdG9yLmluc2V0ID0gaW5zZXQ7XG4gICAgICBzZWN0b3IubGluZUpvaW4gPSB0aGlzLnByb3BlcnRpZXMuc2VjdG9yU3BhY2luZyA+PSAwIHx8IGluc2V0ID4gMCA/IFwibWl0ZXJcIiA6IFwicm91bmRcIjtcbiAgICB9O1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSwgaW5kZXgpID0+IHVwZGF0ZVNlY3RvckZuKG5vZGUsIGRhdHVtLCBpbmRleCwgZmFsc2UpKTtcbiAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIHVwZGF0ZVNlY3RvckZuKG5vZGUsIGRhdHVtLCBpbmRleCwgdHJ1ZSk7XG4gICAgICBub2RlLnZpc2libGUgPSBkYXR1bS5pdGVtSWQgPT09IGhpZ2hsaWdodGVkRGF0dW0/Lml0ZW1JZDtcbiAgICB9KTtcbiAgICB0aGlzLnBoYW50b21TZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0sIGluZGV4KSA9PiB1cGRhdGVTZWN0b3JGbihub2RlLCBkYXR1bSwgaW5kZXgsIGZhbHNlKSk7XG4gICAgdGhpcy51cGRhdGVDYWxsb3V0TGluZU5vZGVzKCk7XG4gICAgdGhpcy51cGRhdGVDYWxsb3V0TGFiZWxOb2RlcyhzZXJpZXNSZWN0KTtcbiAgICB0aGlzLnVwZGF0ZVNlY3RvckxhYmVsTm9kZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUlubmVyTGFiZWxOb2RlcygpO1xuICAgIHRoaXMudXBkYXRlWmVyb3N1bVJpbmdzKCk7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlXCIpO1xuICB9XG4gIHVwZGF0ZUNhbGxvdXRMaW5lTm9kZXMoKSB7XG4gICAgY29uc3QgeyBjYWxsb3V0TGluZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNhbGxvdXRMZW5ndGggPSBjYWxsb3V0TGluZS5sZW5ndGg7XG4gICAgY29uc3QgY2FsbG91dFN0cm9rZVdpZHRoID0gY2FsbG91dExpbmUuc3Ryb2tlV2lkdGg7XG4gICAgY29uc3QgY2FsbG91dENvbG9ycyA9IGNhbGxvdXRMaW5lLmNvbG9ycyA/PyB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlcztcbiAgICBjb25zdCB7IG9mZnNldDogb2Zmc2V0NCB9ID0gdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbDtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbi5zZWxlY3RCeVRhZygwIC8qIENhbGxvdXQgKi8pLmZvckVhY2goKGxpbmUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBkYXR1bSA9IGxpbmUuZGF0dW07XG4gICAgICBjb25zdCB7IGNhbGxvdXRMYWJlbDogbGFiZWwsIG91dGVyUmFkaXVzIH0gPSBkYXR1bTtcbiAgICAgIGlmIChsYWJlbD8udGV4dCAmJiAhbGFiZWwuaGlkZGVuICYmIG91dGVyUmFkaXVzICE9PSAwKSB7XG4gICAgICAgIGxpbmUudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIGxpbmUuc3Ryb2tlV2lkdGggPSBjYWxsb3V0U3Ryb2tlV2lkdGg7XG4gICAgICAgIGxpbmUuc3Ryb2tlID0gY2FsbG91dENvbG9yc1tpbmRleCAlIGNhbGxvdXRDb2xvcnMubGVuZ3RoXTtcbiAgICAgICAgbGluZS5maWxsID0gdm9pZCAwO1xuICAgICAgICBjb25zdCB4MSA9IGRhdHVtLm1pZENvcyAqIG91dGVyUmFkaXVzO1xuICAgICAgICBjb25zdCB5MSA9IGRhdHVtLm1pZFNpbiAqIG91dGVyUmFkaXVzO1xuICAgICAgICBsZXQgeDIgPSBkYXR1bS5taWRDb3MgKiAob3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoKTtcbiAgICAgICAgbGV0IHkyID0gZGF0dW0ubWlkU2luICogKG91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCk7XG4gICAgICAgIGNvbnN0IGlzTW92ZWQgPSBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPz8gbGFiZWwuY29sbGlzaW9uT2Zmc2V0WSAhPT0gMDtcbiAgICAgICAgaWYgKGlzTW92ZWQgJiYgbGFiZWwuYm94ICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBib3ggPSBsYWJlbC5ib3g7XG4gICAgICAgICAgbGV0IGN4ID0geDI7XG4gICAgICAgICAgbGV0IGN5ID0geTI7XG4gICAgICAgICAgaWYgKHgyIDwgYm94LngpIHtcbiAgICAgICAgICAgIGN4ID0gYm94Lng7XG4gICAgICAgICAgfSBlbHNlIGlmICh4MiA+IGJveC54ICsgYm94LndpZHRoKSB7XG4gICAgICAgICAgICBjeCA9IGJveC54ICsgYm94LndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoeTIgPCBib3gueSkge1xuICAgICAgICAgICAgY3kgPSBib3gueTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHkyID4gYm94LnkgKyBib3guaGVpZ2h0KSB7XG4gICAgICAgICAgICBjeSA9IGJveC55ICsgYm94LmhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZHggPSBjeCAtIHgyO1xuICAgICAgICAgIGNvbnN0IGR5ID0gY3kgLSB5MjtcbiAgICAgICAgICBjb25zdCBsZW5ndGgyID0gTWF0aC5zcXJ0KE1hdGgucG93KGR4LCAyKSArIE1hdGgucG93KGR5LCAyKSk7XG4gICAgICAgICAgY29uc3QgcGFkZGVkTGVuZ3RoID0gbGVuZ3RoMiAtIG9mZnNldDQ7XG4gICAgICAgICAgaWYgKHBhZGRlZExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHgyID0geDIgKyBkeCAqIHBhZGRlZExlbmd0aCAvIGxlbmd0aDI7XG4gICAgICAgICAgICB5MiA9IHkyICsgZHkgKiBwYWRkZWRMZW5ndGggLyBsZW5ndGgyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaW5lLngxID0geDE7XG4gICAgICAgIGxpbmUueTEgPSB5MTtcbiAgICAgICAgbGluZS54MiA9IHgyO1xuICAgICAgICBsaW5lLnkyID0geTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRMYWJlbE92ZXJmbG93KHRleHQyLCBib3gsIHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCBzZXJpZXNMZWZ0ID0gLXRoaXMuY2VudGVyWDtcbiAgICBjb25zdCBzZXJpZXNSaWdodCA9IHNlcmllc0xlZnQgKyBzZXJpZXNSZWN0LndpZHRoO1xuICAgIGNvbnN0IHNlcmllc1RvcCA9IC10aGlzLmNlbnRlclk7XG4gICAgY29uc3Qgc2VyaWVzQm90dG9tID0gc2VyaWVzVG9wICsgc2VyaWVzUmVjdC5oZWlnaHQ7XG4gICAgY29uc3QgZXJyUHggPSAxO1xuICAgIGxldCB2aXNpYmxlVGV4dFBhcnQgPSAxO1xuICAgIGlmIChib3gueCArIGVyclB4IDwgc2VyaWVzTGVmdCkge1xuICAgICAgdmlzaWJsZVRleHRQYXJ0ID0gKGJveC54ICsgYm94LndpZHRoIC0gc2VyaWVzTGVmdCkgLyBib3gud2lkdGg7XG4gICAgfSBlbHNlIGlmIChib3gueCArIGJveC53aWR0aCAtIGVyclB4ID4gc2VyaWVzUmlnaHQpIHtcbiAgICAgIHZpc2libGVUZXh0UGFydCA9IChzZXJpZXNSaWdodCAtIGJveC54KSAvIGJveC53aWR0aDtcbiAgICB9XG4gICAgY29uc3QgaGFzVmVydGljYWxPdmVyZmxvdyA9IGJveC55ICsgZXJyUHggPCBzZXJpZXNUb3AgfHwgYm94LnkgKyBib3guaGVpZ2h0IC0gZXJyUHggPiBzZXJpZXNCb3R0b207XG4gICAgY29uc3QgdGV4dExlbmd0aCA9IHZpc2libGVUZXh0UGFydCA9PT0gMSA/IHRleHQyLmxlbmd0aCA6IE1hdGguZmxvb3IodGV4dDIubGVuZ3RoICogdmlzaWJsZVRleHRQYXJ0KSAtIDE7XG4gICAgY29uc3QgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdyA9IHRoaXMuYmJveEludGVyc2VjdHNTdXJyb3VuZGluZ1Nlcmllcyhib3gpO1xuICAgIHJldHVybiB7IHRleHRMZW5ndGgsIGhhc1ZlcnRpY2FsT3ZlcmZsb3csIGhhc1N1cnJvdW5kaW5nU2VyaWVzT3ZlcmZsb3cgfTtcbiAgfVxuICBiYm94SW50ZXJzZWN0c1N1cnJvdW5kaW5nU2VyaWVzKGJveCkge1xuICAgIGNvbnN0IHsgc3Vycm91bmRpbmdSYWRpdXMgfSA9IHRoaXM7XG4gICAgaWYgKHN1cnJvdW5kaW5nUmFkaXVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY29ybmVycyA9IFtcbiAgICAgIHsgeDogYm94LngsIHk6IGJveC55IH0sXG4gICAgICB7IHg6IGJveC54ICsgYm94LndpZHRoLCB5OiBib3gueSB9LFxuICAgICAgeyB4OiBib3gueCArIGJveC53aWR0aCwgeTogYm94LnkgKyBib3guaGVpZ2h0IH0sXG4gICAgICB7IHg6IGJveC54LCB5OiBib3gueSArIGJveC5oZWlnaHQgfVxuICAgIF07XG4gICAgY29uc3Qgc3VyMiA9IHN1cnJvdW5kaW5nUmFkaXVzICoqIDI7XG4gICAgcmV0dXJuIGNvcm5lcnMuc29tZSgoY29ybmVyKSA9PiBjb3JuZXIueCAqKiAyICsgY29ybmVyLnkgKiogMiA+IHN1cjIpO1xuICB9XG4gIGNvbXB1dGVDYWxsb3V0TGFiZWxDb2xsaXNpb25PZmZzZXRzKCkge1xuICAgIGNvbnN0IHsgcmFkaXVzU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWwsIGNhbGxvdXRMaW5lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBvZmZzZXQ6IG9mZnNldDQsIG1pblNwYWNpbmcgfSA9IGNhbGxvdXRMYWJlbDtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1c1NjYWxlLmNvbnZlcnQoMCk7XG4gICAgY29uc3Qgc2hvdWxkU2tpcCA9IChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICByZXR1cm4gIWxhYmVsIHx8IGRhdHVtLm91dGVyUmFkaXVzID09PSAwO1xuICAgIH07XG4gICAgY29uc3QgZnVsbERhdGEgPSB0aGlzLmNhbGxvdXROb2RlRGF0YTtcbiAgICBjb25zdCBkYXRhID0gZnVsbERhdGEuZmlsdGVyKCh0KSA9PiAhc2hvdWxkU2tpcCh0KSk7XG4gICAgZGF0YS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICBpZiAobGFiZWwgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGFiZWwuaGlkZGVuID0gZmFsc2U7XG4gICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSB2b2lkIDA7XG4gICAgICBsYWJlbC5jb2xsaXNpb25PZmZzZXRZID0gMDtcbiAgICB9KTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPD0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsZWZ0TGFiZWxzID0gZGF0YS5maWx0ZXIoKGQpID0+IGQubWlkQ29zIDwgMCkuc29ydCgoYSwgYikgPT4gYS5taWRTaW4gLSBiLm1pZFNpbik7XG4gICAgY29uc3QgcmlnaHRMYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRDb3MgPj0gMCkuc29ydCgoYSwgYikgPT4gYS5taWRTaW4gLSBiLm1pZFNpbik7XG4gICAgY29uc3QgdG9wTGFiZWxzID0gZGF0YS5maWx0ZXIoKGQpID0+IGQubWlkU2luIDwgMCAmJiBkLmNhbGxvdXRMYWJlbD8udGV4dEFsaWduID09PSBcImNlbnRlclwiKS5zb3J0KChhLCBiKSA9PiBhLm1pZENvcyAtIGIubWlkQ29zKTtcbiAgICBjb25zdCBib3R0b21MYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRTaW4gPj0gMCAmJiBkLmNhbGxvdXRMYWJlbD8udGV4dEFsaWduID09PSBcImNlbnRlclwiKS5zb3J0KChhLCBiKSA9PiBhLm1pZENvcyAtIGIubWlkQ29zKTtcbiAgICBjb25zdCBnZXRUZXh0QkJveCA9IChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICBpZiAobGFiZWwgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIEJCb3guemVyby5jbG9uZSgpO1xuICAgICAgY29uc3QgbGFiZWxSYWRpdXMgPSBkYXR1bS5vdXRlclJhZGl1cyArIGNhbGxvdXRMaW5lLmxlbmd0aCArIG9mZnNldDQ7XG4gICAgICBjb25zdCB4ID0gZGF0dW0ubWlkQ29zICogbGFiZWxSYWRpdXM7XG4gICAgICBjb25zdCB5ID0gZGF0dW0ubWlkU2luICogbGFiZWxSYWRpdXMgKyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZO1xuICAgICAgY29uc3QgdGV4dEFsaWduID0gbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID8/IGxhYmVsLnRleHRBbGlnbjtcbiAgICAgIGNvbnN0IHRleHRCYXNlbGluZSA9IGxhYmVsLnRleHRCYXNlbGluZTtcbiAgICAgIHJldHVybiBUZXh0LmNvbXB1dGVCQm94KGxhYmVsLnRleHQsIHgsIHksIHtcbiAgICAgICAgZm9udDogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbCxcbiAgICAgICAgdGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgYXZvaWROZWlnaGJvdXJZQ29sbGlzaW9uID0gKGxhYmVsLCBuZXh0LCBkaXJlY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGJveCA9IGdldFRleHRCQm94KGxhYmVsKS5ncm93KG1pblNwYWNpbmcgLyAyKTtcbiAgICAgIGNvbnN0IG90aGVyID0gZ2V0VGV4dEJCb3gobmV4dCkuZ3JvdyhtaW5TcGFjaW5nIC8gMik7XG4gICAgICBjb25zdCBjb2xsaWRlc09yQmVoaW5kID0gYm94LnggPCBvdGhlci54ICsgb3RoZXIud2lkdGggJiYgYm94LnggKyBib3gud2lkdGggPiBvdGhlci54ICYmIChkaXJlY3Rpb24gPT09IFwidG8tdG9wXCIgPyBib3gueSA8IG90aGVyLnkgKyBvdGhlci5oZWlnaHQgOiBib3gueSArIGJveC5oZWlnaHQgPiBvdGhlci55KTtcbiAgICAgIGlmIChjb2xsaWRlc09yQmVoaW5kKSB7XG4gICAgICAgIG5leHQuY2FsbG91dExhYmVsLmNvbGxpc2lvbk9mZnNldFkgPSBkaXJlY3Rpb24gPT09IFwidG8tdG9wXCIgPyBib3gueSAtIG90aGVyLnkgLSBvdGhlci5oZWlnaHQgOiBib3gueSArIGJveC5oZWlnaHQgLSBvdGhlci55O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXZvaWRZQ29sbGlzaW9ucyA9IChsYWJlbHMpID0+IHtcbiAgICAgIGNvbnN0IG1pZExhYmVsID0gbGFiZWxzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gTWF0aC5hYnMoYS5taWRTaW4pIC0gTWF0aC5hYnMoYi5taWRTaW4pKVswXTtcbiAgICAgIGNvbnN0IG1pZEluZGV4ID0gbGFiZWxzLmluZGV4T2YobWlkTGFiZWwpO1xuICAgICAgZm9yIChsZXQgaSA9IG1pZEluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgcHJldiA9IGxhYmVsc1tpICsgMV07XG4gICAgICAgIGNvbnN0IG5leHQgPSBsYWJlbHNbaV07XG4gICAgICAgIGF2b2lkTmVpZ2hib3VyWUNvbGxpc2lvbihwcmV2LCBuZXh0LCBcInRvLXRvcFwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSBtaWRJbmRleCArIDE7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJldiA9IGxhYmVsc1tpIC0gMV07XG4gICAgICAgIGNvbnN0IG5leHQgPSBsYWJlbHNbaV07XG4gICAgICAgIGF2b2lkTmVpZ2hib3VyWUNvbGxpc2lvbihwcmV2LCBuZXh0LCBcInRvLWJvdHRvbVwiKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGF2b2lkWENvbGxpc2lvbnMgPSAobGFiZWxzKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbHNDb2xsaWRlTGFiZWxzQnlZID0gZGF0YS5zb21lKChkYXR1bSkgPT4gZGF0dW0uY2FsbG91dExhYmVsLmNvbGxpc2lvbk9mZnNldFkgIT09IDApO1xuICAgICAgY29uc3QgYm94ZXMgPSBsYWJlbHMubWFwKChsYWJlbCkgPT4gZ2V0VGV4dEJCb3gobGFiZWwpKTtcbiAgICAgIGNvbnN0IHBhZGRlZEJveGVzID0gYm94ZXMubWFwKChib3gpID0+IGJveC5jbG9uZSgpLmdyb3cobWluU3BhY2luZyAvIDIpKTtcbiAgICAgIGxldCBsYWJlbHNDb2xsaWRlTGFiZWxzQnlYID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRlZEJveGVzLmxlbmd0aCAmJiAhbGFiZWxzQ29sbGlkZUxhYmVsc0J5WDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJveCA9IHBhZGRlZEJveGVzW2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBsYWJlbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBvdGhlciA9IHBhZGRlZEJveGVzW2pdO1xuICAgICAgICAgIGlmIChib3guY29sbGlkZXNCQm94KG90aGVyKSkge1xuICAgICAgICAgICAgbGFiZWxzQ29sbGlkZUxhYmVsc0J5WCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlY3RvcnMgPSBmdWxsRGF0YS5tYXAoKGRhdHVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIG91dGVyUmFkaXVzIH0gPSBkYXR1bTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9O1xuICAgICAgfSk7XG4gICAgICBjb25zdCBsYWJlbHNDb2xsaWRlU2VjdG9ycyA9IGJveGVzLnNvbWUoKGJveCkgPT4ge1xuICAgICAgICByZXR1cm4gc2VjdG9ycy5zb21lKChzZWN0b3IpID0+IGJveENvbGxpZGVzU2VjdG9yKGJveCwgc2VjdG9yKSk7XG4gICAgICB9KTtcbiAgICAgIGlmICghbGFiZWxzQ29sbGlkZUxhYmVsc0J5WCAmJiAhbGFiZWxzQ29sbGlkZUxhYmVsc0J5WSAmJiAhbGFiZWxzQ29sbGlkZVNlY3RvcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGFiZWxzLmZpbHRlcigoZCkgPT4gZC5jYWxsb3V0TGFiZWwudGV4dEFsaWduID09PSBcImNlbnRlclwiKS5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gZC5jYWxsb3V0TGFiZWw7XG4gICAgICAgIGlmIChkLm1pZENvcyA8IDApIHtcbiAgICAgICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZC5taWRDb3MgPiAwKSB7XG4gICAgICAgICAgbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBhdm9pZFlDb2xsaXNpb25zKGxlZnRMYWJlbHMpO1xuICAgIGF2b2lkWUNvbGxpc2lvbnMocmlnaHRMYWJlbHMpO1xuICAgIGF2b2lkWENvbGxpc2lvbnModG9wTGFiZWxzKTtcbiAgICBhdm9pZFhDb2xsaXNpb25zKGJvdHRvbUxhYmVscyk7XG4gIH1cbiAgdXBkYXRlQ2FsbG91dExhYmVsTm9kZXMoc2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IHsgcmFkaXVzU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWwsIGNhbGxvdXRMaW5lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2FsbG91dExlbmd0aCA9IGNhbGxvdXRMaW5lLmxlbmd0aDtcbiAgICBjb25zdCB7IG9mZnNldDogb2Zmc2V0NCwgY29sb3IgfSA9IGNhbGxvdXRMYWJlbDtcbiAgICBjb25zdCB0ZW1wVGV4dE5vZGUgPSBuZXcgVGV4dCgpO1xuICAgIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uLnNlbGVjdEJ5VGFnKDEgLyogTGFiZWwgKi8pLmZvckVhY2goKHRleHQyKSA9PiB7XG4gICAgICBjb25zdCB7IGRhdHVtIH0gPSB0ZXh0MjtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xuICAgICAgY29uc3QgcmFkaXVzID0gcmFkaXVzU2NhbGUuY29udmVydChkYXR1bS5yYWRpdXMpO1xuICAgICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heCgwLCByYWRpdXMpO1xuICAgICAgaWYgKCFsYWJlbD8udGV4dCB8fCBvdXRlclJhZGl1cyA9PT0gMCB8fCBsYWJlbC5oaWRkZW4pIHtcbiAgICAgICAgdGV4dDIudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IG91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCArIG9mZnNldDQ7XG4gICAgICBjb25zdCB4ID0gZGF0dW0ubWlkQ29zICogbGFiZWxSYWRpdXM7XG4gICAgICBjb25zdCB5ID0gZGF0dW0ubWlkU2luICogbGFiZWxSYWRpdXMgKyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZO1xuICAgICAgY29uc3QgYWxpZ24yID0ge1xuICAgICAgICB0ZXh0QWxpZ246IGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA/PyBsYWJlbC50ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogbGFiZWwudGV4dEJhc2VsaW5lXG4gICAgICB9O1xuICAgICAgdGVtcFRleHROb2RlLnRleHQgPSBsYWJlbC50ZXh0O1xuICAgICAgdGVtcFRleHROb2RlLnggPSB4O1xuICAgICAgdGVtcFRleHROb2RlLnkgPSB5O1xuICAgICAgdGVtcFRleHROb2RlLnNldEZvbnQodGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbCk7XG4gICAgICB0ZW1wVGV4dE5vZGUuc2V0QWxpZ24oYWxpZ24yKTtcbiAgICAgIGNvbnN0IGJveCA9IHRlbXBUZXh0Tm9kZS5nZXRCQm94KCk7XG4gICAgICBsZXQgZGlzcGxheVRleHQgPSBsYWJlbC50ZXh0O1xuICAgICAgbGV0IHZpc2libGUgPSB0cnVlO1xuICAgICAgaWYgKGNhbGxvdXRMYWJlbC5hdm9pZENvbGxpc2lvbnMpIHtcbiAgICAgICAgY29uc3QgeyB0ZXh0TGVuZ3RoLCBoYXNWZXJ0aWNhbE92ZXJmbG93IH0gPSB0aGlzLmdldExhYmVsT3ZlcmZsb3cobGFiZWwudGV4dCwgYm94LCBzZXJpZXNSZWN0KTtcbiAgICAgICAgZGlzcGxheVRleHQgPSBsYWJlbC50ZXh0Lmxlbmd0aCA9PT0gdGV4dExlbmd0aCA/IGxhYmVsLnRleHQgOiBgJHtsYWJlbC50ZXh0LnN1YnN0cmluZygwLCB0ZXh0TGVuZ3RoKX1cXHUyMDI2YDtcbiAgICAgICAgdmlzaWJsZSA9ICFoYXNWZXJ0aWNhbE92ZXJmbG93O1xuICAgICAgfVxuICAgICAgdGV4dDIudGV4dCA9IGRpc3BsYXlUZXh0O1xuICAgICAgdGV4dDIueCA9IHg7XG4gICAgICB0ZXh0Mi55ID0geTtcbiAgICAgIHRleHQyLnNldEZvbnQodGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbCk7XG4gICAgICB0ZXh0Mi5zZXRBbGlnbihhbGlnbjIpO1xuICAgICAgdGV4dDIuZmlsbCA9IGNvbG9yO1xuICAgICAgdGV4dDIudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfSk7XG4gIH1cbiAgY29tcHV0ZUxhYmVsc0JCb3gob3B0aW9ucywgc2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsLCBjYWxsb3V0TGluZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNhbGxvdXRMZW5ndGggPSBjYWxsb3V0TGluZS5sZW5ndGg7XG4gICAgY29uc3QgeyBvZmZzZXQ6IG9mZnNldDQsIG1heENvbGxpc2lvbk9mZnNldCwgbWluU3BhY2luZyB9ID0gY2FsbG91dExhYmVsO1xuICAgIGlmICghY2FsbG91dExhYmVsLmF2b2lkQ29sbGlzaW9ucykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMubWF5YmVSZWZyZXNoTm9kZURhdGEoKTtcbiAgICB0aGlzLnVwZGF0ZVJhZGl1c1NjYWxlKGZhbHNlKTtcbiAgICB0aGlzLmNvbXB1dGVDYWxsb3V0TGFiZWxDb2xsaXNpb25PZmZzZXRzKCk7XG4gICAgY29uc3QgdGV4dEJveGVzID0gW107XG4gICAgY29uc3QgdGV4dDIgPSBuZXcgVGV4dCgpO1xuICAgIGxldCB0aXRsZUJveDtcbiAgICBjb25zdCB7IHRpdGxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKHRpdGxlPy50ZXh0ICYmIHRpdGxlLmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IGR5ID0gdGhpcy5nZXRUaXRsZVRyYW5zbGF0aW9uWSgpO1xuICAgICAgaWYgKGlzRmluaXRlKGR5KSkge1xuICAgICAgICB0ZXh0Mi50ZXh0ID0gdGl0bGUudGV4dDtcbiAgICAgICAgdGV4dDIueCA9IDA7XG4gICAgICAgIHRleHQyLnkgPSBkeTtcbiAgICAgICAgdGV4dDIuc2V0Rm9udCh0aXRsZSk7XG4gICAgICAgIHRleHQyLnNldEFsaWduKHtcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6IFwiYm90dG9tXCIsXG4gICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aXRsZUJveCA9IHRleHQyLmdldEJCb3goKTtcbiAgICAgICAgdGV4dEJveGVzLnB1c2godGl0bGVCb3gpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNhbGxvdXROb2RlRGF0YS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICBpZiAoIWxhYmVsIHx8IGRhdHVtLm91dGVyUmFkaXVzID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxSYWRpdXMgPSBkYXR1bS5vdXRlclJhZGl1cyArIGNhbGxvdXRMZW5ndGggKyBvZmZzZXQ0O1xuICAgICAgY29uc3QgeCA9IGRhdHVtLm1pZENvcyAqIGxhYmVsUmFkaXVzO1xuICAgICAgY29uc3QgeSA9IGRhdHVtLm1pZFNpbiAqIGxhYmVsUmFkaXVzICsgbGFiZWwuY29sbGlzaW9uT2Zmc2V0WTtcbiAgICAgIHRleHQyLnRleHQgPSBsYWJlbC50ZXh0O1xuICAgICAgdGV4dDIueCA9IHg7XG4gICAgICB0ZXh0Mi55ID0geTtcbiAgICAgIHRleHQyLnNldEZvbnQodGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbCk7XG4gICAgICB0ZXh0Mi5zZXRBbGlnbih7XG4gICAgICAgIHRleHRBbGlnbjogbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID8/IGxhYmVsLnRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiBsYWJlbC50ZXh0QmFzZWxpbmVcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYm94ID0gdGV4dDIuZ2V0QkJveCgpO1xuICAgICAgbGFiZWwuYm94ID0gYm94O1xuICAgICAgaWYgKE1hdGguYWJzKGxhYmVsLmNvbGxpc2lvbk9mZnNldFkpID4gbWF4Q29sbGlzaW9uT2Zmc2V0KSB7XG4gICAgICAgIGxhYmVsLmhpZGRlbiA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aXRsZUJveCkge1xuICAgICAgICBjb25zdCBzZXJpZXNUb3AgPSAtdGhpcy5jZW50ZXJZO1xuICAgICAgICBjb25zdCB0aXRsZUNsZWFuQXJlYSA9IG5ldyBCQm94KFxuICAgICAgICAgIHRpdGxlQm94LnggLSBtaW5TcGFjaW5nLFxuICAgICAgICAgIHNlcmllc1RvcCxcbiAgICAgICAgICB0aXRsZUJveC53aWR0aCArIDIgKiBtaW5TcGFjaW5nLFxuICAgICAgICAgIHRpdGxlQm94LnkgKyB0aXRsZUJveC5oZWlnaHQgKyBtaW5TcGFjaW5nIC0gc2VyaWVzVG9wXG4gICAgICAgICk7XG4gICAgICAgIGlmIChib3guY29sbGlkZXNCQm94KHRpdGxlQ2xlYW5BcmVhKSkge1xuICAgICAgICAgIGxhYmVsLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5oaWRlV2hlbk5lY2Vzc2FyeSkge1xuICAgICAgICBjb25zdCB7IHRleHRMZW5ndGgsIGhhc1ZlcnRpY2FsT3ZlcmZsb3csIGhhc1N1cnJvdW5kaW5nU2VyaWVzT3ZlcmZsb3cgfSA9IHRoaXMuZ2V0TGFiZWxPdmVyZmxvdyhcbiAgICAgICAgICBsYWJlbC50ZXh0LFxuICAgICAgICAgIGJveCxcbiAgICAgICAgICBzZXJpZXNSZWN0XG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGlzVG9vU2hvcnQgPSBsYWJlbC50ZXh0Lmxlbmd0aCA+IDIgJiYgdGV4dExlbmd0aCA8IDI7XG4gICAgICAgIGlmIChoYXNWZXJ0aWNhbE92ZXJmbG93IHx8IGlzVG9vU2hvcnQgfHwgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdykge1xuICAgICAgICAgIGxhYmVsLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYWJlbC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIHRleHRCb3hlcy5wdXNoKGJveCk7XG4gICAgfSk7XG4gICAgaWYgKHRleHRCb3hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gQkJveC5tZXJnZSh0ZXh0Qm94ZXMpO1xuICB9XG4gIHVwZGF0ZVNlY3RvckxhYmVsTm9kZXMoKSB7XG4gICAgY29uc3QgeyByYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1c1NjYWxlLmNvbnZlcnQoMCk7XG4gICAgY29uc3QgeyBmb250U2l6ZSwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250RmFtaWx5LCBwb3NpdGlvbk9mZnNldCwgcG9zaXRpb25SYXRpbywgY29sb3IgfSA9IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbDtcbiAgICBjb25zdCB1cGRhdGVTZWN0b3JMYWJlbCA9ICh0ZXh0MiwgZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IHsgc2VjdG9yTGFiZWwsIG91dGVyUmFkaXVzIH0gPSBkYXR1bTtcbiAgICAgIGxldCBpc1RleHRWaXNpYmxlID0gZmFsc2U7XG4gICAgICBpZiAoc2VjdG9yTGFiZWwgJiYgb3V0ZXJSYWRpdXMgIT09IDApIHtcbiAgICAgICAgY29uc3QgbGFiZWxSYWRpdXMgPSBpbm5lclJhZGl1cyAqICgxIC0gcG9zaXRpb25SYXRpbykgKyBvdXRlclJhZGl1cyAqIHBvc2l0aW9uUmF0aW8gKyBwb3NpdGlvbk9mZnNldDtcbiAgICAgICAgdGV4dDIuZmlsbCA9IGNvbG9yO1xuICAgICAgICB0ZXh0Mi5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICAgIHRleHQyLmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgICB0ZXh0Mi5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICB0ZXh0Mi5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgICAgdGV4dDIudGV4dCA9IHNlY3RvckxhYmVsLnRleHQ7XG4gICAgICAgIHRleHQyLnggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgICAgdGV4dDIueSA9IGRhdHVtLm1pZFNpbiAqIGxhYmVsUmFkaXVzO1xuICAgICAgICB0ZXh0Mi50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB0ZXh0Mi50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgICBjb25zdCBiYm94ID0gdGV4dDIuZ2V0QkJveCgpO1xuICAgICAgICBjb25zdCBjb3JuZXJzID0gW1xuICAgICAgICAgIFtiYm94LngsIGJib3gueV0sXG4gICAgICAgICAgW2Jib3gueCArIGJib3gud2lkdGgsIGJib3gueV0sXG4gICAgICAgICAgW2Jib3gueCArIGJib3gud2lkdGgsIGJib3gueSArIGJib3guaGVpZ2h0XSxcbiAgICAgICAgICBbYmJveC54LCBiYm94LnkgKyBiYm94LmhlaWdodF1cbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSB9ID0gZGF0dW07XG4gICAgICAgIGNvbnN0IHNlY3RvckJvdW5kcyA9IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9O1xuICAgICAgICBpZiAoY29ybmVycy5ldmVyeSgoW3gsIHldKSA9PiBpc1BvaW50SW5TZWN0b3IoeCwgeSwgc2VjdG9yQm91bmRzKSkpIHtcbiAgICAgICAgICBpc1RleHRWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGV4dDIudmlzaWJsZSA9IGlzVGV4dFZpc2libGU7XG4gICAgfTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uLmVhY2godXBkYXRlU2VjdG9yTGFiZWwpO1xuICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24uZWFjaCh1cGRhdGVTZWN0b3JMYWJlbCk7XG4gIH1cbiAgdXBkYXRlSW5uZXJMYWJlbE5vZGVzKCkge1xuICAgIGNvbnN0IHRleHRCQm94ZXMgPSBbXTtcbiAgICBjb25zdCBtYXJnaW5zID0gW107XG4gICAgdGhpcy5pbm5lckxhYmVsc1NlbGVjdGlvbi5lYWNoKCh0ZXh0MiwgZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IHsgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgY29sb3IgfSA9IGRhdHVtO1xuICAgICAgdGV4dDIuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgdGV4dDIuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgICB0ZXh0Mi5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgdGV4dDIuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICB0ZXh0Mi50ZXh0ID0gZGF0dW0udGV4dDtcbiAgICAgIHRleHQyLnggPSAwO1xuICAgICAgdGV4dDIueSA9IDA7XG4gICAgICB0ZXh0Mi5maWxsID0gY29sb3I7XG4gICAgICB0ZXh0Mi50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgdGV4dDIudGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCI7XG4gICAgICB0ZXh0QkJveGVzLnB1c2godGV4dDIuZ2V0QkJveCgpKTtcbiAgICAgIG1hcmdpbnMucHVzaChkYXR1bS5zcGFjaW5nKTtcbiAgICB9KTtcbiAgICBjb25zdCBnZXRNYXJnaW5Ub3AgPSAoaW5kZXgpID0+IGluZGV4ID09PSAwID8gMCA6IG1hcmdpbnNbaW5kZXhdO1xuICAgIGNvbnN0IGdldE1hcmdpbkJvdHRvbSA9IChpbmRleCkgPT4gaW5kZXggPT09IG1hcmdpbnMubGVuZ3RoIC0gMSA/IDAgOiBtYXJnaW5zW2luZGV4XTtcbiAgICBjb25zdCB0b3RhbEhlaWdodCA9IHRleHRCQm94ZXMucmVkdWNlKChzdW0yLCBiYm94LCBpKSA9PiB7XG4gICAgICByZXR1cm4gc3VtMiArIGJib3guaGVpZ2h0ICsgZ2V0TWFyZ2luVG9wKGkpICsgZ2V0TWFyZ2luQm90dG9tKGkpO1xuICAgIH0sIDApO1xuICAgIGNvbnN0IHRvdGFsV2lkdGggPSBNYXRoLm1heCguLi50ZXh0QkJveGVzLm1hcCgoYmJveCkgPT4gYmJveC53aWR0aCkpO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gdGhpcy5nZXRJbm5lclJhZGl1cygpO1xuICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gTWF0aC5zcXJ0KE1hdGgucG93KHRvdGFsV2lkdGggLyAyLCAyKSArIE1hdGgucG93KHRvdGFsSGVpZ2h0IC8gMiwgMikpO1xuICAgIGNvbnN0IGxhYmVsc1Zpc2libGUgPSBsYWJlbFJhZGl1cyA8PSAoaW5uZXJSYWRpdXMgPiAwID8gaW5uZXJSYWRpdXMgOiB0aGlzLmdldE91dGVyUmFkaXVzKCkpO1xuICAgIGNvbnN0IHRleHRCb3R0b21zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIHByZXYgPSAtdG90YWxIZWlnaHQgLyAyOyBpIDwgdGV4dEJCb3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYmJveCA9IHRleHRCQm94ZXNbaV07XG4gICAgICBjb25zdCBib3R0b20gPSBiYm94LmhlaWdodCArIHByZXYgKyBnZXRNYXJnaW5Ub3AoaSk7XG4gICAgICB0ZXh0Qm90dG9tcy5wdXNoKGJvdHRvbSk7XG4gICAgICBwcmV2ID0gYm90dG9tICsgZ2V0TWFyZ2luQm90dG9tKGkpO1xuICAgIH1cbiAgICB0aGlzLmlubmVyTGFiZWxzU2VsZWN0aW9uLmVhY2goKHRleHQyLCBfZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICB0ZXh0Mi55ID0gdGV4dEJvdHRvbXNbaW5kZXhdO1xuICAgICAgdGV4dDIudmlzaWJsZSA9IGxhYmVsc1Zpc2libGU7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlWmVyb3N1bVJpbmdzKCkge1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy5zaXplID0gdGhpcy5nZXRPdXRlclJhZGl1cygpICogMjtcbiAgICB0aGlzLnplcm9zdW1Jbm5lclJpbmcuc2l6ZSA9IHRoaXMuZ2V0SW5uZXJSYWRpdXMoKSAqIDI7XG4gIH1cbiAgcGlja05vZGVDbG9zZXN0RGF0dW0ocG9pbnQpIHtcbiAgICByZXR1cm4gcGlja0J5TWF0Y2hpbmdBbmdsZSh0aGlzLCBwb2ludCk7XG4gIH1cbiAgZ2V0VG9vbHRpcENvbnRlbnQobm9kZURhdHVtKSB7XG4gICAgY29uc3QgeyBpZDogc2VyaWVzSWQsIGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSwgcHJvcGVydGllcyB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBsZWdlbmRJdGVtS2V5LFxuICAgICAgY2FsbG91dExhYmVsS2V5LFxuICAgICAgY2FsbG91dExhYmVsTmFtZSxcbiAgICAgIHNlY3RvckxhYmVsS2V5LFxuICAgICAgc2VjdG9yTGFiZWxOYW1lLFxuICAgICAgYW5nbGVLZXksXG4gICAgICBhbmdsZU5hbWUsXG4gICAgICByYWRpdXNLZXksXG4gICAgICByYWRpdXNOYW1lLFxuICAgICAgdG9vbHRpcFxuICAgIH0gPSBwcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy5wcm9wZXJ0aWVzLnRpdGxlLnRleHQ7XG4gICAgaWYgKCFkYXRhTW9kZWwgfHwgIXByb2Nlc3NlZERhdGEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBkYXR1bUluZGV4IH0gPSBub2RlRGF0dW07XG4gICAgY29uc3QgZGF0dW0gPSBwcm9jZXNzZWREYXRhLmRhdGFTb3VyY2VzLmdldCh0aGlzLmlkKT8uW2RhdHVtSW5kZXhdO1xuICAgIGNvbnN0IHsgYW5nbGVSYXdWYWx1ZXMsIGxlZ2VuZEl0ZW1WYWx1ZXMsIGNhbGxvdXRMYWJlbFZhbHVlcywgc2VjdG9yTGFiZWxWYWx1ZXMgfSA9IHRoaXMuZ2V0UHJvY2Vzc2VkRGF0YVZhbHVlcyhcbiAgICAgIGRhdGFNb2RlbCxcbiAgICAgIHByb2Nlc3NlZERhdGFcbiAgICApO1xuICAgIGNvbnN0IGFuZ2xlUmF3VmFsdWUgPSBhbmdsZVJhd1ZhbHVlc1tkYXR1bUluZGV4XTtcbiAgICBjb25zdCBsYWJlbCA9IGxlZ2VuZEl0ZW1WYWx1ZXM/LltkYXR1bUluZGV4XSA/PyAoY2FsbG91dExhYmVsS2V5ID09PSBhbmdsZUtleSA/IHZvaWQgMCA6IGNhbGxvdXRMYWJlbFZhbHVlcz8uW2RhdHVtSW5kZXhdKSA/PyAoc2VjdG9yTGFiZWxLZXkgPT09IGFuZ2xlS2V5ID8gdm9pZCAwIDogc2VjdG9yTGFiZWxWYWx1ZXM/LltkYXR1bUluZGV4XSkgPz8gYW5nbGVOYW1lO1xuICAgIHJldHVybiB0b29sdGlwLmZvcm1hdFRvb2x0aXAoXG4gICAgICB7XG4gICAgICAgIHRpdGxlLFxuICAgICAgICBzeW1ib2w6IHRoaXMubGVnZW5kSXRlbVN5bWJvbChkYXR1bUluZGV4KSxcbiAgICAgICAgZGF0YTogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgZmFsbGJhY2tMYWJlbDogYW5nbGVLZXksXG4gICAgICAgICAgICB2YWx1ZTogZm9ybWF0VmFsdWUoYW5nbGVSYXdWYWx1ZSwgMylcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHNlcmllc0lkLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgdGl0bGU6IGFuZ2xlTmFtZSxcbiAgICAgICAgbGVnZW5kSXRlbUtleSxcbiAgICAgICAgY2FsbG91dExhYmVsS2V5LFxuICAgICAgICBjYWxsb3V0TGFiZWxOYW1lLFxuICAgICAgICBzZWN0b3JMYWJlbEtleSxcbiAgICAgICAgc2VjdG9yTGFiZWxOYW1lLFxuICAgICAgICBhbmdsZUtleSxcbiAgICAgICAgYW5nbGVOYW1lLFxuICAgICAgICByYWRpdXNLZXksXG4gICAgICAgIHJhZGl1c05hbWUsXG4gICAgICAgIC4uLnRoaXMuZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLCBkYXR1bUluZGV4LCBmYWxzZSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGxlZ2VuZEl0ZW1TeW1ib2woZGF0dW1JbmRleCkge1xuICAgIGNvbnN0IGRhdHVtID0gdGhpcy5wcm9jZXNzZWREYXRhPy5kYXRhU291cmNlcy5nZXQodGhpcy5pZCk/LltkYXR1bUluZGV4XTtcbiAgICBjb25zdCBzZWN0b3JGb3JtYXQgPSB0aGlzLmdldFNlY3RvckZvcm1hdChkYXR1bSwgZGF0dW1JbmRleCwgZmFsc2UpO1xuICAgIHJldHVybiB7XG4gICAgICBtYXJrZXI6IHtcbiAgICAgICAgZmlsbDogc2VjdG9yRm9ybWF0LmZpbGwsXG4gICAgICAgIHN0cm9rZTogc2VjdG9yRm9ybWF0LnN0cm9rZSxcbiAgICAgICAgZmlsbE9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5maWxsT3BhY2l0eSxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZU9wYWNpdHksXG4gICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgIGxpbmVEYXNoOiB0aGlzLnByb3BlcnRpZXMubGluZURhc2gsXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0OiB0aGlzLnByb3BlcnRpZXMubGluZURhc2hPZmZzZXRcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHZpc2libGUsXG4gICAgICBwcm9jZXNzZWREYXRhLFxuICAgICAgZGF0YU1vZGVsLFxuICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgY3R4OiB7IGxlZ2VuZE1hbmFnZXIgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZGF0YU1vZGVsIHx8ICFwcm9jZXNzZWREYXRhIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8IGxlZ2VuZFR5cGUgIT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7IGFuZ2xlS2V5LCBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5LCBzaG93SW5MZWdlbmQgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAoIWxlZ2VuZEl0ZW1LZXkgJiYgKCFjYWxsb3V0TGFiZWxLZXkgfHwgY2FsbG91dExhYmVsS2V5ID09PSBhbmdsZUtleSkgJiYgKCFzZWN0b3JMYWJlbEtleSB8fCBzZWN0b3JMYWJlbEtleSA9PT0gYW5nbGVLZXkpKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHsgYW5nbGVSYXdWYWx1ZXMsIGNhbGxvdXRMYWJlbFZhbHVlcywgc2VjdG9yTGFiZWxWYWx1ZXMsIGxlZ2VuZEl0ZW1WYWx1ZXMgfSA9IHRoaXMuZ2V0UHJvY2Vzc2VkRGF0YVZhbHVlcyhcbiAgICAgIGRhdGFNb2RlbCxcbiAgICAgIHByb2Nlc3NlZERhdGFcbiAgICApO1xuICAgIGNvbnN0IHRpdGxlVGV4dCA9IHRoaXMucHJvcGVydGllcy50aXRsZT8uc2hvd0luTGVnZW5kICYmIHRoaXMucHJvcGVydGllcy50aXRsZS50ZXh0O1xuICAgIGNvbnN0IGxlZ2VuZERhdGEgPSBbXTtcbiAgICBjb25zdCBoaWRlWmVyb3MgPSB0aGlzLnByb3BlcnRpZXMuaGlkZVplcm9WYWx1ZVNlY3RvcnNJbkxlZ2VuZDtcbiAgICBjb25zdCByYXdEYXRhID0gcHJvY2Vzc2VkRGF0YS5kYXRhU291cmNlcy5nZXQodGhpcy5pZCk7XG4gICAgY29uc3QgaW52YWxpZERhdGEgPSBwcm9jZXNzZWREYXRhLmludmFsaWREYXRhPy5nZXQodGhpcy5pZCk7XG4gICAgZm9yIChsZXQgZGF0dW1JbmRleCA9IDA7IGRhdHVtSW5kZXggPCBwcm9jZXNzZWREYXRhLmlucHV0LmNvdW50OyBkYXR1bUluZGV4KyspIHtcbiAgICAgIGNvbnN0IGRhdHVtID0gcmF3RGF0YT8uW2RhdHVtSW5kZXhdO1xuICAgICAgY29uc3QgYW5nbGVSYXdWYWx1ZSA9IGFuZ2xlUmF3VmFsdWVzW2RhdHVtSW5kZXhdO1xuICAgICAgaWYgKGludmFsaWREYXRhPy5bZGF0dW1JbmRleF0gPT09IHRydWUgfHwgaGlkZVplcm9zICYmIGFuZ2xlUmF3VmFsdWUgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbFBhcnRzID0gW107XG4gICAgICBpZiAodGl0bGVUZXh0KSB7XG4gICAgICAgIGxhYmVsUGFydHMucHVzaCh0aXRsZVRleHQpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoXG4gICAgICAgIGRhdHVtLFxuICAgICAgICAyICogTWF0aC5QSSxcbiAgICAgICAgMiAqIE1hdGguUEksXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBjYWxsb3V0TGFiZWxWYWx1ZXM/LltkYXR1bUluZGV4XSxcbiAgICAgICAgc2VjdG9yTGFiZWxWYWx1ZXM/LltkYXR1bUluZGV4XSxcbiAgICAgICAgbGVnZW5kSXRlbVZhbHVlcz8uW2RhdHVtSW5kZXhdXG4gICAgICApO1xuICAgICAgaWYgKGxlZ2VuZEl0ZW1LZXkgJiYgbGFiZWxzLmxlZ2VuZEl0ZW0gIT09IHZvaWQgMCkge1xuICAgICAgICBsYWJlbFBhcnRzLnB1c2gobGFiZWxzLmxlZ2VuZEl0ZW0udGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKGNhbGxvdXRMYWJlbEtleSAmJiBjYWxsb3V0TGFiZWxLZXkgIT09IGFuZ2xlS2V5ICYmIGxhYmVscy5jYWxsb3V0TGFiZWw/LnRleHQgIT09IHZvaWQgMCkge1xuICAgICAgICBsYWJlbFBhcnRzLnB1c2gobGFiZWxzLmNhbGxvdXRMYWJlbD8udGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKHNlY3RvckxhYmVsS2V5ICYmIHNlY3RvckxhYmVsS2V5ICE9PSBhbmdsZUtleSAmJiBsYWJlbHMuc2VjdG9yTGFiZWw/LnRleHQgIT09IHZvaWQgMCkge1xuICAgICAgICBsYWJlbFBhcnRzLnB1c2gobGFiZWxzLnNlY3RvckxhYmVsPy50ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmIChsYWJlbFBhcnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBsZWdlbmREYXRhLnB1c2goe1xuICAgICAgICBsZWdlbmRUeXBlOiBcImNhdGVnb3J5XCIsXG4gICAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGl0ZW1JZDogZGF0dW1JbmRleCxcbiAgICAgICAgc2VyaWVzSWQsXG4gICAgICAgIGVuYWJsZWQ6IHZpc2libGUgJiYgbGVnZW5kTWFuYWdlci5nZXRJdGVtRW5hYmxlZCh7IHNlcmllc0lkLCBpdGVtSWQ6IGRhdHVtSW5kZXggfSksXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgdGV4dDogbGFiZWxQYXJ0cy5qb2luKFwiIC0gXCIpXG4gICAgICAgIH0sXG4gICAgICAgIHN5bWJvbDogdGhpcy5sZWdlbmRJdGVtU3ltYm9sKGRhdHVtSW5kZXgpLFxuICAgICAgICBsZWdlbmRJdGVtTmFtZTogbGVnZW5kSXRlbUtleSAhPSBudWxsID8gZGF0dW1bbGVnZW5kSXRlbUtleV0gOiB2b2lkIDAsXG4gICAgICAgIGhpZGVJbkxlZ2VuZDogIXNob3dJbkxlZ2VuZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmREYXRhO1xuICB9XG4gIC8vIFVzZWQgZm9yIGdyaWRcbiAgc2V0TGVnZW5kU3RhdGUoZW5hYmxlZEl0ZW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgY3R4OiB7IGxlZ2VuZE1hbmFnZXIsIHVwZGF0ZVNlcnZpY2UgfVxuICAgIH0gPSB0aGlzO1xuICAgIGVuYWJsZWRJdGVtcy5mb3JFYWNoKChlbmFibGVkLCBpdGVtSWQpID0+IGxlZ2VuZE1hbmFnZXIudG9nZ2xlSXRlbSh7IGVuYWJsZWQsIHNlcmllc0lkLCBpdGVtSWQgfSkpO1xuICAgIGxlZ2VuZE1hbmFnZXIudXBkYXRlKCk7XG4gICAgdXBkYXRlU2VydmljZS51cGRhdGUoNCAvKiBTRVJJRVNfVVBEQVRFICovKTtcbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeShfZGF0YSkge1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyhcbiAgICAgIHRydWUsXG4gICAgICB0aGlzLnByb3BlcnRpZXMucm90YXRpb24sXG4gICAgICB0aGlzLnJhZGl1c1NjYWxlLFxuICAgICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJub2Rlc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFt0aGlzLml0ZW1TZWxlY3Rpb24sIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uLCB0aGlzLnBoYW50b21TZWxlY3Rpb25dLFxuICAgICAgZm5zLm5vZGVzLFxuICAgICAgKF8sIGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0uZGF0dW0sIGRhdHVtLmRhdHVtSW5kZXgpXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgYGlubmVyQ2lyY2xlYCwgYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMuaW5uZXJDaXJjbGVTZWxlY3Rpb25dLCBmbnMuaW5uZXJDaXJjbGUpO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiY2FsbG91dFwiLCBhbmltYXRpb25NYW5hZ2VyLCB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJzZWN0b3JcIiwgYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5sYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJoaWdobGlnaHRcIiwgYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJpbm5lclwiLCBhbmltYXRpb25NYW5hZ2VyLCB0aGlzLmlubmVyTGFiZWxzU2VsZWN0aW9uKTtcbiAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoKSB7XG4gICAgY29uc3QgeyBpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb24sIHByb2Nlc3NlZERhdGEsIHJhZGl1c1NjYWxlLCBwcmV2aW91c1JhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZGF0YURpZmYgPSBwcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5kaWZmPy5bdGhpcy5pZF07XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xuICAgIGNvbnN0IHN1cHBvcnRlZERpZmYgPSAoZGF0YURpZmY/Lm1vdmVkLnNpemUgPz8gMCkgPT09IDA7XG4gICAgY29uc3QgaGFzS2V5cyA9IChwcm9jZXNzZWREYXRhPy5kZWZzLmtleXMubGVuZ3RoID8/IDApID4gMDtcbiAgICBjb25zdCBoYXNVbmlxdWVLZXlzID0gcHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uYW5pbWF0aW9uVmFsaWRhdGlvbj8udW5pcXVlS2V5cyA/PyB0cnVlO1xuICAgIGlmICghc3VwcG9ydGVkRGlmZiB8fCAhaGFzS2V5cyB8fCAhaGFzVW5pcXVlS2V5cykge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgfVxuICAgIGNvbnN0IG5vVmlzaWJsZURhdGEgPSAhdGhpcy5ub2RlRGF0YS5zb21lKChuKSA9PiBuLmVuYWJsZWQpO1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoXG4gICAgICBmYWxzZSxcbiAgICAgIHRoaXMucHJvcGVydGllcy5yb3RhdGlvbixcbiAgICAgIHJhZGl1c1NjYWxlLFxuICAgICAgcHJldmlvdXNSYWRpdXNTY2FsZVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwaGFudG9tU2VsZWN0aW9uXSxcbiAgICAgIGZucy5ub2RlcyxcbiAgICAgIChfLCBkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtLmRhdHVtLCBkYXR1bS5kYXR1bUluZGV4KSxcbiAgICAgIGRhdGFEaWZmXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgYGlubmVyQ2lyY2xlYCwgYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMuaW5uZXJDaXJjbGVTZWxlY3Rpb25dLCBmbnMuaW5uZXJDaXJjbGUpO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiY2FsbG91dFwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJzZWN0b3JcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5sYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJoaWdobGlnaHRcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbik7XG4gICAgaWYgKHRoaXMubm9WaXNpYmxlRGF0YSAhPT0gbm9WaXNpYmxlRGF0YSkge1xuICAgICAgdGhpcy5ub1Zpc2libGVEYXRhID0gbm9WaXNpYmxlRGF0YTtcbiAgICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiaW5uZXJcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5pbm5lckxhYmVsc1NlbGVjdGlvbik7XG4gICAgfVxuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XG4gIH1cbiAgYW5pbWF0ZUNsZWFyaW5nVXBkYXRlRW1wdHkoKSB7XG4gICAgY29uc3QgeyBpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb24sIHJhZGl1c1NjYWxlLCBwcmV2aW91c1JhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyhcbiAgICAgIGZhbHNlLFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzLnJvdGF0aW9uLFxuICAgICAgcmFkaXVzU2NhbGUsXG4gICAgICBwcmV2aW91c1JhZGl1c1NjYWxlXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJub2Rlc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFtpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb25dLFxuICAgICAgZm5zLm5vZGVzLFxuICAgICAgKF8sIGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0uZGF0dW0sIGRhdHVtLmRhdHVtSW5kZXgpXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgYGlubmVyQ2lyY2xlYCwgYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMuaW5uZXJDaXJjbGVTZWxlY3Rpb25dLCBmbnMuaW5uZXJDaXJjbGUpO1xuICAgIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbih0aGlzLCBcImNhbGxvdXRcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbih0aGlzLCBcInNlY3RvclwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24odGhpcywgXCJoaWdobGlnaHRcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uKHRoaXMsIFwiaW5uZXJcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5pbm5lckxhYmVsc1NlbGVjdGlvbik7XG4gICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlLnJhbmdlID0gdGhpcy5yYWRpdXNTY2FsZS5yYW5nZTtcbiAgfVxuICBnZXREYXR1bUlkKGRhdHVtLCBkYXR1bUluZGV4KSB7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKCF0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmFuaW1hdGlvblZhbGlkYXRpb24/LnVuaXF1ZUtleXMpIHtcbiAgICAgIHJldHVybiBgJHtkYXR1bUluZGV4fWA7XG4gICAgfVxuICAgIGlmIChsZWdlbmRJdGVtS2V5KSB7XG4gICAgICByZXR1cm4gY3JlYXRlRGF0dW1JZChkYXR1bVtsZWdlbmRJdGVtS2V5XSk7XG4gICAgfSBlbHNlIGlmIChjYWxsb3V0TGFiZWxLZXkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVEYXR1bUlkKGRhdHVtW2NhbGxvdXRMYWJlbEtleV0pO1xuICAgIH0gZWxzZSBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVEYXR1bUlkKGRhdHVtW3NlY3RvckxhYmVsS2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBgJHtkYXR1bUluZGV4fWA7XG4gIH1cbn07XG5Eb251dFNlcmllcy5jbGFzc05hbWUgPSBcIkRvbnV0U2VyaWVzXCI7XG5Eb251dFNlcmllcy50eXBlID0gXCJkb251dFwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvZG9udXRUaGVtZS50c1xudmFyIGRvbnV0VGhlbWUgPSB7XG4gIHNlcmllczoge1xuICAgIHRpdGxlOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgZm9udFdlaWdodDogeyAkcmVmOiBcImZvbnRXZWlnaHRcIiB9LFxuICAgICAgZm9udFNpemU6IHsgJHJlbTogWzEuMTY2NjY2NjY2NjY2NjY2NyAvKiBMQVJHRSAqL10gfSxcbiAgICAgIGZvbnRGYW1pbHk6IHsgJHJlZjogXCJmb250RmFtaWx5XCIgfSxcbiAgICAgIGNvbG9yOiB7ICRyZWY6IFwic3VidGxlVGV4dENvbG9yXCIgfSxcbiAgICAgIHNwYWNpbmc6IDVcbiAgICB9LFxuICAgIGNhbGxvdXRMYWJlbDoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGZvbnRTaXplOiB7ICRyZWY6IFwiZm9udFNpemVcIiB9LFxuICAgICAgZm9udEZhbWlseTogeyAkcmVmOiBcImZvbnRGYW1pbHlcIiB9LFxuICAgICAgZm9udFdlaWdodDogeyAkcmVmOiBcImZvbnRXZWlnaHRcIiB9LFxuICAgICAgY29sb3I6IHsgJHJlZjogXCJ0ZXh0Q29sb3JcIiB9LFxuICAgICAgb2Zmc2V0OiAzLFxuICAgICAgbWluQW5nbGU6IDFlLTNcbiAgICB9LFxuICAgIHNlY3RvckxhYmVsOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgZm9udFdlaWdodDogeyAkcmVmOiBcImZvbnRXZWlnaHRcIiB9LFxuICAgICAgZm9udFNpemU6IHsgJHJlZjogXCJmb250U2l6ZVwiIH0sXG4gICAgICBmb250RmFtaWx5OiB7ICRyZWY6IFwiZm9udEZhbWlseVwiIH0sXG4gICAgICBjb2xvcjogeyAkcmVmOiBcImJhY2tncm91bmRDb2xvclwiIH0sXG4gICAgICBwb3NpdGlvbk9mZnNldDogMCxcbiAgICAgIHBvc2l0aW9uUmF0aW86IDAuNVxuICAgIH0sXG4gICAgY2FsbG91dExpbmU6IHtcbiAgICAgIGxlbmd0aDogMTAsXG4gICAgICBzdHJva2VXaWR0aDogMlxuICAgIH0sXG4gICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgICBzdHJva2VXaWR0aDogMCxcbiAgICBsaW5lRGFzaDogWzBdLFxuICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxuICAgIHJvdGF0aW9uOiAwLFxuICAgIHNlY3RvclNwYWNpbmc6IDEsXG4gICAgc2hhZG93OiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGNvbG9yOiBERUZBVUxUX1NIQURPV19DT0xPVVIsXG4gICAgICB4T2Zmc2V0OiAzLFxuICAgICAgeU9mZnNldDogMyxcbiAgICAgIGJsdXI6IDVcbiAgICB9LFxuICAgIGlubmVyTGFiZWxzOiB7XG4gICAgICBmb250U2l6ZTogeyAkcmVmOiBcImZvbnRTaXplXCIgfSxcbiAgICAgIGZvbnRGYW1pbHk6IHsgJHJlZjogXCJmb250RmFtaWx5XCIgfSxcbiAgICAgIGZvbnRXZWlnaHQ6IHsgJHJlZjogXCJmb250V2VpZ2h0XCIgfSxcbiAgICAgIGNvbG9yOiB7ICRyZWY6IFwidGV4dENvbG9yXCIgfSxcbiAgICAgIHNwYWNpbmc6IDJcbiAgICB9XG4gIH0sXG4gIGxlZ2VuZDogeyBlbmFibGVkOiB0cnVlIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9wb2xhci9waWVUaGVtZS50c1xudmFyIHBpZVRoZW1lID0ge1xuICBzZXJpZXM6IHtcbiAgICB0aXRsZToge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGZvbnRXZWlnaHQ6IHsgJHJlZjogXCJmb250V2VpZ2h0XCIgfSxcbiAgICAgIGZvbnRTaXplOiB7ICRyZW06IFsxLjE2NjY2NjY2NjY2NjY2NjcgLyogTEFSR0UgKi9dIH0sXG4gICAgICBmb250RmFtaWx5OiB7ICRyZWY6IFwiZm9udEZhbWlseVwiIH0sXG4gICAgICBjb2xvcjogeyAkcmVmOiBcInN1YnRsZVRleHRDb2xvclwiIH0sXG4gICAgICBzcGFjaW5nOiA1XG4gICAgfSxcbiAgICBjYWxsb3V0TGFiZWw6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBmb250U2l6ZTogeyAkcmVmOiBcImZvbnRTaXplXCIgfSxcbiAgICAgIGZvbnRGYW1pbHk6IHsgJHJlZjogXCJmb250RmFtaWx5XCIgfSxcbiAgICAgIGZvbnRXZWlnaHQ6IHsgJHJlZjogXCJmb250V2VpZ2h0XCIgfSxcbiAgICAgIGNvbG9yOiB7ICRyZWY6IFwidGV4dENvbG9yXCIgfSxcbiAgICAgIG9mZnNldDogMyxcbiAgICAgIG1pbkFuZ2xlOiAxZS0zXG4gICAgfSxcbiAgICBzZWN0b3JMYWJlbDoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGZvbnRXZWlnaHQ6IHsgJHJlZjogXCJmb250V2VpZ2h0XCIgfSxcbiAgICAgIGZvbnRTaXplOiB7ICRyZWY6IFwiZm9udFNpemVcIiB9LFxuICAgICAgZm9udEZhbWlseTogeyAkcmVmOiBcImZvbnRGYW1pbHlcIiB9LFxuICAgICAgY29sb3I6IHsgJHJlZjogXCJiYWNrZ3JvdW5kQ29sb3JcIiB9LFxuICAgICAgcG9zaXRpb25PZmZzZXQ6IDAsXG4gICAgICBwb3NpdGlvblJhdGlvOiAwLjVcbiAgICB9LFxuICAgIGNhbGxvdXRMaW5lOiB7XG4gICAgICBsZW5ndGg6IDEwLFxuICAgICAgc3Ryb2tlV2lkdGg6IDJcbiAgICB9LFxuICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgIHN0cm9rZU9wYWNpdHk6IDEsXG4gICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgbGluZURhc2g6IFswXSxcbiAgICBsaW5lRGFzaE9mZnNldDogMCxcbiAgICByb3RhdGlvbjogMCxcbiAgICBzZWN0b3JTcGFjaW5nOiAxLFxuICAgIHNoYWRvdzoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBjb2xvcjogREVGQVVMVF9TSEFET1dfQ09MT1VSLFxuICAgICAgeE9mZnNldDogMyxcbiAgICAgIHlPZmZzZXQ6IDMsXG4gICAgICBibHVyOiA1XG4gICAgfVxuICB9LFxuICBsZWdlbmQ6IHsgZW5hYmxlZDogdHJ1ZSB9XG59O1xudmFyIHBpZVBhbGV0dGVGYWN0b3J5ID0gKHsgdGFrZUNvbG9ycywgY29sb3JzQ291bnQgfSkgPT4ge1xuICBjb25zdCB7IGZpbGxzLCBzdHJva2VzIH0gPSB0YWtlQ29sb3JzKGNvbG9yc0NvdW50KTtcbiAgcmV0dXJuIHsgZmlsbHMsIHN0cm9rZXMsIGNhbGxvdXRMaW5lOiB7IGNvbG9yczogc3Ryb2tlcyB9IH07XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvZG9udXRTZXJpZXNNb2R1bGUudHNcbnZhciBEb251dFNlcmllc01vZHVsZSA9IHtcbiAgdHlwZTogXCJzZXJpZXNcIixcbiAgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sXG4gIGlkZW50aWZpZXI6IFwiZG9udXRcIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IERvbnV0U2VyaWVzKGN0eCksXG4gIHRvb2x0aXBEZWZhdWx0czogeyByYW5nZTogXCJleGFjdFwiIH0sXG4gIHRoZW1lVGVtcGxhdGU6IGRvbnV0VGhlbWUsXG4gIHBhbGV0dGVGYWN0b3J5OiBwaWVQYWxldHRlRmFjdG9yeVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL3BpZVNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBQaWVUaXRsZSA9IGNsYXNzIGV4dGVuZHMgQ2FwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zaG93SW5MZWdlbmQgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBQaWVUaXRsZS5wcm90b3R5cGUsIFwic2hvd0luTGVnZW5kXCIsIDIpO1xudmFyIFBpZVNlcmllc0NhbGxvdXRMYWJlbCA9IGNsYXNzIGV4dGVuZHMgTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMub2Zmc2V0ID0gMztcbiAgICB0aGlzLm1pbkFuZ2xlID0gMDtcbiAgICB0aGlzLm1pblNwYWNpbmcgPSA0O1xuICAgIHRoaXMubWF4Q29sbGlzaW9uT2Zmc2V0ID0gNTA7XG4gICAgdGhpcy5hdm9pZENvbGxpc2lvbnMgPSB0cnVlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGllU2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJvZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIucmVzdHJpY3QoeyBtaW46IDAsIG1heDogMzYwIH0pKVxuXSwgUGllU2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJtaW5BbmdsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBpZVNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwibWluU3BhY2luZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBpZVNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwibWF4Q29sbGlzaW9uT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFBpZVNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwiYXZvaWRDb2xsaXNpb25zXCIsIDIpO1xudmFyIFBpZVNlcmllc1NlY3RvckxhYmVsID0gY2xhc3MgZXh0ZW5kcyBMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wb3NpdGlvbk9mZnNldCA9IDA7XG4gICAgdGhpcy5wb3NpdGlvblJhdGlvID0gMC41O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgUGllU2VyaWVzU2VjdG9yTGFiZWwucHJvdG90eXBlLCBcInBvc2l0aW9uT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBQaWVTZXJpZXNTZWN0b3JMYWJlbC5wcm90b3R5cGUsIFwicG9zaXRpb25SYXRpb1wiLCAyKTtcbnZhciBQaWVTZXJpZXNDYWxsb3V0TGluZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubGVuZ3RoID0gMTA7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc0NhbGxvdXRMaW5lLnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGluZS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGllU2VyaWVzQ2FsbG91dExpbmUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xudmFyIFBpZVNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIFNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZmlsbHMgPSBPYmplY3QudmFsdWVzKERFRkFVTFRfRklMTFMpO1xuICAgIHRoaXMuc3Ryb2tlcyA9IE9iamVjdC52YWx1ZXMoREVGQVVMVF9TVFJPS0VTKTtcbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuICAgIHRoaXMubGluZURhc2ggPSBbMF07XG4gICAgdGhpcy5saW5lRGFzaE9mZnNldCA9IDA7XG4gICAgdGhpcy5jb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMucm90YXRpb24gPSAwO1xuICAgIHRoaXMub3V0ZXJSYWRpdXNPZmZzZXQgPSAwO1xuICAgIHRoaXMub3V0ZXJSYWRpdXNSYXRpbyA9IDE7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG4gICAgdGhpcy5zZWN0b3JTcGFjaW5nID0gMDtcbiAgICB0aGlzLmhpZGVaZXJvVmFsdWVTZWN0b3JzSW5MZWdlbmQgPSBmYWxzZTtcbiAgICB0aGlzLnRpdGxlID0gbmV3IFBpZVRpdGxlKCk7XG4gICAgdGhpcy5zaGFkb3cgPSBuZXcgRHJvcFNoYWRvdygpO1xuICAgIHRoaXMuY2FsbG91dExhYmVsID0gbmV3IFBpZVNlcmllc0NhbGxvdXRMYWJlbCgpO1xuICAgIHRoaXMuc2VjdG9yTGFiZWwgPSBuZXcgUGllU2VyaWVzU2VjdG9yTGFiZWwoKTtcbiAgICB0aGlzLmNhbGxvdXRMaW5lID0gbmV3IFBpZVNlcmllc0NhbGxvdXRMaW5lKCk7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImFuZ2xlS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhbmdsZU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImFuZ2xlRmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyYWRpdXNLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJhZGl1c05hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJhZGl1c01pblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicmFkaXVzTWF4XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjYWxsb3V0TGFiZWxLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMYWJlbE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNlY3RvckxhYmVsS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzZWN0b3JMYWJlbE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxlZ2VuZEl0ZW1LZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTElORV9EQVNIKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpdGVtU3R5bGVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJvdXRlclJhZGl1c09mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwib3V0ZXJSYWRpdXNSYXRpb1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2VjdG9yU3BhY2luZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJoaWRlWmVyb1ZhbHVlU2VjdG9yc0luTGVnZW5kXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaGFkb3dcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjYWxsb3V0TGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzZWN0b3JMYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMaW5lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL3BpZVNlcmllcy50c1xudmFyIFBpZVNlcmllc05vZGVFdmVudCA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzTm9kZUV2ZW50IHtcbiAgY29uc3RydWN0b3IodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpIHtcbiAgICBzdXBlcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcyk7XG4gICAgdGhpcy5hbmdsZUtleSA9IHNlcmllcy5wcm9wZXJ0aWVzLmFuZ2xlS2V5O1xuICAgIHRoaXMucmFkaXVzS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMucmFkaXVzS2V5O1xuICAgIHRoaXMuY2FsbG91dExhYmVsS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5O1xuICAgIHRoaXMuc2VjdG9yTGFiZWxLZXkgPSBzZXJpZXMucHJvcGVydGllcy5zZWN0b3JMYWJlbEtleTtcbiAgfVxufTtcbnZhciBQaWVTZXJpZXMgPSBjbGFzcyBleHRlbmRzIFBvbGFyU2VyaWVzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgcGlja01vZGVzOiBbMSAvKiBORUFSRVNUX05PREUgKi8sIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9dLFxuICAgICAgdXNlTGFiZWxMYXllcjogdHJ1ZSxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7IGl0ZW06IHJlc2V0UGllU2VsZWN0aW9uc0ZuLCBsYWJlbDogcmVzZXRMYWJlbEZuIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgUGllU2VyaWVzUHJvcGVydGllcygpO1xuICAgIHRoaXMucGhhbnRvbU5vZGVEYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwID0gbmV3IFRyYW5zbGF0YWJsZUdyb3VwKHtcbiAgICAgIG5hbWU6IGAke3RoaXMuaWR9LWJhY2tncm91bmRgLFxuICAgICAgekluZGV4OiAwIC8qIEJBQ0tHUk9VTkQgKi9cbiAgICB9KTtcbiAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUgPSBuZXcgTGluZWFyU2NhbGUoKTtcbiAgICB0aGlzLnJhZGl1c1NjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XG4gICAgdGhpcy5waGFudG9tR3JvdXAgPSB0aGlzLmJhY2tncm91bmRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBcInBoYW50b21cIiB9KSk7XG4gICAgdGhpcy5waGFudG9tU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMucGhhbnRvbUdyb3VwLFxuICAgICAgKCkgPT4gdGhpcy5ub2RlRmFjdG9yeSgpLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHRoaXMuY2FsbG91dExhYmVsR3JvdXAgPSB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBcInBpZUNhbGxvdXRMYWJlbHNcIiB9KSk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uKFxuICAgICAgdGhpcy5jYWxsb3V0TGFiZWxHcm91cCxcbiAgICAgIEdyb3VwXG4gICAgKTtcbiAgICAvLyBBRy02MTkzIElmIHRoZSBzdW0gb2YgYWxsIGRhdHVtcyBpcyAwLCB0aGVuIHdlJ2xsIGRyYXcgMSBvciAyIHJpbmdzIHRvIHJlcHJlc2VudCB0aGUgZW1wdHkgc2VyaWVzLlxuICAgIHRoaXMuemVyb3N1bVJpbmdzR3JvdXAgPSB0aGlzLmJhY2tncm91bmRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS16ZXJvc3VtUmluZ3NgIH0pKTtcbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcgPSB0aGlzLnplcm9zdW1SaW5nc0dyb3VwLmFwcGVuZENoaWxkKG5ldyBNYXJrZXIoeyBzaGFwZTogXCJjaXJjbGVcIiB9KSk7XG4gICAgdGhpcy5zdXJyb3VuZGluZ1JhZGl1cyA9IHZvaWQgMDtcbiAgICB0aGlzLk5vZGVFdmVudCA9IFBpZVNlcmllc05vZGVFdmVudDtcbiAgICB0aGlzLmFuZ2xlU2NhbGUgPSBuZXcgTGluZWFyU2NhbGUoKTtcbiAgICB0aGlzLmFuZ2xlU2NhbGUuZG9tYWluID0gWzAsIDFdO1xuICAgIHRoaXMuYW5nbGVTY2FsZS5yYW5nZSA9IFstTWF0aC5QSSwgTWF0aC5QSV0ubWFwKChhbmdsZTIpID0+IGFuZ2xlMiArIE1hdGguUEkgLyAyKTtcbiAgICB0aGlzLnBoYW50b21Hcm91cC5vcGFjaXR5ID0gMC4yO1xuICB9XG4gIGdldCBjYWxsb3V0Tm9kZURhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMucGhhbnRvbU5vZGVEYXRhID8/IHRoaXMubm9kZURhdGE7XG4gIH1cbiAgYXR0YWNoU2VyaWVzKHNlcmllc0NvbnRlbnROb2RlLCBzZXJpZXNOb2RlLCBhbm5vdGF0aW9uTm9kZSkge1xuICAgIHN1cGVyLmF0dGFjaFNlcmllcyhzZXJpZXNDb250ZW50Tm9kZSwgc2VyaWVzTm9kZSwgYW5ub3RhdGlvbk5vZGUpO1xuICAgIHNlcmllc0NvbnRlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMuYmFja2dyb3VuZEdyb3VwKTtcbiAgfVxuICBkZXRhY2hTZXJpZXMoc2VyaWVzQ29udGVudE5vZGUsIHNlcmllc05vZGUsIGFubm90YXRpb25Ob2RlKSB7XG4gICAgc3VwZXIuZGV0YWNoU2VyaWVzKHNlcmllc0NvbnRlbnROb2RlLCBzZXJpZXNOb2RlLCBhbm5vdGF0aW9uTm9kZSk7XG4gICAgc2VyaWVzQ29udGVudE5vZGU/LnJlbW92ZUNoaWxkKHRoaXMuYmFja2dyb3VuZEdyb3VwKTtcbiAgfVxuICBzZXRTZXJpZXNJbmRleChpbmRleCkge1xuICAgIGlmICghc3VwZXIuc2V0U2VyaWVzSW5kZXgoaW5kZXgpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwLnpJbmRleCA9IFswIC8qIEJBQ0tHUk9VTkQgKi8sIGluZGV4XTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBub2RlRmFjdG9yeSgpIHtcbiAgICBjb25zdCBzZWN0b3IgPSBuZXcgU2VjdG9yKCk7XG4gICAgc2VjdG9yLm1pdGVyTGltaXQgPSAxZTk7XG4gICAgcmV0dXJuIHNlY3RvcjtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuYW5nbGVTY2FsZS5kb21haW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnJhZGl1c1NjYWxlLmRvbWFpbjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcbiAgICBpZiAodGhpcy5kYXRhID09IG51bGwgfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdmlzaWJsZSxcbiAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgIGN0eDogeyBsZWdlbmRNYW5hZ2VyIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7IGFuZ2xlS2V5LCBhbmdsZUZpbHRlcktleSwgcmFkaXVzS2V5LCBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgdmFsaWRTZWN0b3IgPSAoX3ZhbHVlLCBfZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gdmlzaWJsZSAmJiBsZWdlbmRNYW5hZ2VyLmdldEl0ZW1FbmFibGVkKHsgc2VyaWVzSWQsIGl0ZW1JZDogaW5kZXggfSk7XG4gICAgfTtcbiAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgZXh0cmFLZXlQcm9wcyA9IFtdO1xuICAgIGNvbnN0IGV4dHJhUHJvcHMgPSBbXTtcbiAgICBpZiAobGVnZW5kSXRlbUtleSkge1xuICAgICAgZXh0cmFLZXlQcm9wcy5wdXNoKGtleVByb3BlcnR5KGxlZ2VuZEl0ZW1LZXksIFwiYmFuZFwiLCB7IGlkOiBgbGVnZW5kSXRlbUtleWAgfSkpO1xuICAgIH0gZWxzZSBpZiAoY2FsbG91dExhYmVsS2V5KSB7XG4gICAgICBleHRyYUtleVByb3BzLnB1c2goa2V5UHJvcGVydHkoY2FsbG91dExhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYGNhbGxvdXRMYWJlbEtleWAgfSkpO1xuICAgIH0gZWxzZSBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcbiAgICAgIGV4dHJhS2V5UHJvcHMucHVzaChrZXlQcm9wZXJ0eShzZWN0b3JMYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBzZWN0b3JMYWJlbEtleWAgfSkpO1xuICAgIH1cbiAgICBjb25zdCByYWRpdXNTY2FsZVR5cGUgPSB0aGlzLnJhZGl1c1NjYWxlLnR5cGU7XG4gICAgY29uc3QgYW5nbGVTY2FsZVR5cGUgPSB0aGlzLmFuZ2xlU2NhbGUudHlwZTtcbiAgICBpZiAocmFkaXVzS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goXG4gICAgICAgIHJhbmdlZFZhbHVlUHJvcGVydHkocmFkaXVzS2V5LCB7XG4gICAgICAgICAgaWQ6IFwicmFkaXVzVmFsdWVcIixcbiAgICAgICAgICBtaW46IHRoaXMucHJvcGVydGllcy5yYWRpdXNNaW4gPz8gMCxcbiAgICAgICAgICBtYXg6IHRoaXMucHJvcGVydGllcy5yYWRpdXNNYXhcbiAgICAgICAgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkocmFkaXVzS2V5LCByYWRpdXNTY2FsZVR5cGUsIHsgaWQ6IGByYWRpdXNSYXdgIH0pLFxuICAgICAgICAvLyBSYXcgdmFsdWUgcGFzcy10aHJvdWdoLlxuICAgICAgICBub3JtYWxpc2VQcm9wZXJ0eVRvKFwicmFkaXVzVmFsdWVcIiwgWzAsIDFdLCAxLCB0aGlzLnByb3BlcnRpZXMucmFkaXVzTWluID8/IDAsIHRoaXMucHJvcGVydGllcy5yYWRpdXNNYXgpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoY2FsbG91dExhYmVsS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2godmFsdWVQcm9wZXJ0eShjYWxsb3V0TGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgY2FsbG91dExhYmVsVmFsdWVgIH0pKTtcbiAgICB9XG4gICAgaWYgKHNlY3RvckxhYmVsS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2godmFsdWVQcm9wZXJ0eShzZWN0b3JMYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBzZWN0b3JMYWJlbFZhbHVlYCB9KSk7XG4gICAgfVxuICAgIGlmIChsZWdlbmRJdGVtS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2godmFsdWVQcm9wZXJ0eShsZWdlbmRJdGVtS2V5LCBcImJhbmRcIiwgeyBpZDogYGxlZ2VuZEl0ZW1WYWx1ZWAgfSkpO1xuICAgIH1cbiAgICBpZiAoYW5nbGVGaWx0ZXJLZXkpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChcbiAgICAgICAgYWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShhbmdsZUZpbHRlcktleSwgYW5nbGVTY2FsZVR5cGUsIHtcbiAgICAgICAgICBpZDogYGFuZ2xlRmlsdGVyVmFsdWVgLFxuICAgICAgICAgIG9ubHlQb3NpdGl2ZTogdHJ1ZSxcbiAgICAgICAgICB2YWxpZGF0aW9uOiB2YWxpZFNlY3RvcixcbiAgICAgICAgICBpbnZhbGlkVmFsdWU6IDBcbiAgICAgICAgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkoYW5nbGVGaWx0ZXJLZXksIGFuZ2xlU2NhbGVUeXBlLCB7IGlkOiBgYW5nbGVGaWx0ZXJSYXdgIH0pLFxuICAgICAgICBub3JtYWxpc2VQcm9wZXJ0eVRvKFwiYW5nbGVGaWx0ZXJWYWx1ZVwiLCBbMCwgMV0sIDAsIDApXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCAmJiB0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmFuaW1hdGlvblZhbGlkYXRpb24/LnVuaXF1ZUtleXMgJiYgZXh0cmFLZXlQcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goZGlmZih0aGlzLmlkLCB0aGlzLnByb2Nlc3NlZERhdGEpKTtcbiAgICB9XG4gICAgZXh0cmFQcm9wcy5wdXNoKGFuaW1hdGlvblZhbGlkYXRpb24oKSk7XG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCB0aGlzLmRhdGEsIHtcbiAgICAgIHByb3BzOiBbXG4gICAgICAgIC4uLmV4dHJhS2V5UHJvcHMsXG4gICAgICAgIGFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoYW5nbGVLZXksIGFuZ2xlU2NhbGVUeXBlLCB7XG4gICAgICAgICAgaWQ6IGBhbmdsZVZhbHVlYCxcbiAgICAgICAgICBvbmx5UG9zaXRpdmU6IHRydWUsXG4gICAgICAgICAgdmFsaWRhdGlvbjogdmFsaWRTZWN0b3IsXG4gICAgICAgICAgaW52YWxpZFZhbHVlOiAwXG4gICAgICAgIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KGFuZ2xlS2V5LCBhbmdsZVNjYWxlVHlwZSwgeyBpZDogYGFuZ2xlUmF3YCB9KSxcbiAgICAgICAgLy8gUmF3IHZhbHVlIHBhc3MtdGhyb3VnaC5cbiAgICAgICAgbm9ybWFsaXNlUHJvcGVydHlUbyhcImFuZ2xlVmFsdWVcIiwgWzAsIDFdLCAwLCAwKSxcbiAgICAgICAgLi4uZXh0cmFQcm9wc1xuICAgICAgXVxuICAgIH0pO1xuICAgIGZvciAoY29uc3QgdmFsdWVEZWYgb2YgdGhpcy5wcm9jZXNzZWREYXRhPy5kZWZzPy52YWx1ZXMgPz8gW10pIHtcbiAgICAgIGNvbnN0IHsgaWQsIG1pc3NpbmcsIHByb3BlcnR5IH0gPSB2YWx1ZURlZjtcbiAgICAgIGNvbnN0IG1pc3NDb3VudCA9IGdldE1pc3NDb3VudCh0aGlzLCBtaXNzaW5nKTtcbiAgICAgIGlmIChpZCAhPT0gXCJhbmdsZVJhd1wiICYmIG1pc3NDb3VudCA+IDApIHtcbiAgICAgICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoXG4gICAgICAgICAgYG5vIHZhbHVlIHdhcyBmb3VuZCBmb3IgdGhlIGtleSAnJHtTdHJpbmcocHJvcGVydHkpfScgb24gJHttaXNzQ291bnR9IGRhdGEgZWxlbWVudCR7bWlzc0NvdW50ID4gMSA/IFwic1wiIDogXCJcIn1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gIH1cbiAgbWF5YmVSZWZyZXNoTm9kZURhdGEoKSB7XG4gICAgaWYgKCF0aGlzLm5vZGVEYXRhUmVmcmVzaClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IG5vZGVEYXRhID0gW10sIHBoYW50b21Ob2RlRGF0YSB9ID0gdGhpcy5jcmVhdGVOb2RlRGF0YSgpID8/IHt9O1xuICAgIHRoaXMubm9kZURhdGEgPSBub2RlRGF0YTtcbiAgICB0aGlzLnBoYW50b21Ob2RlRGF0YSA9IHBoYW50b21Ob2RlRGF0YTtcbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IGZhbHNlO1xuICB9XG4gIGdldFByb2Nlc3NlZERhdGFWYWx1ZXMoZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhKSB7XG4gICAgY29uc3QgYW5nbGVWYWx1ZXMgPSBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYGFuZ2xlVmFsdWVgLCBwcm9jZXNzZWREYXRhKTtcbiAgICBjb25zdCBhbmdsZVJhd1ZhbHVlcyA9IGRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBgYW5nbGVSYXdgLCBwcm9jZXNzZWREYXRhKTtcbiAgICBjb25zdCBhbmdsZUZpbHRlclZhbHVlcyA9IHRoaXMucHJvcGVydGllcy5hbmdsZUZpbHRlcktleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGBhbmdsZUZpbHRlclZhbHVlYCwgcHJvY2Vzc2VkRGF0YSkgOiB2b2lkIDA7XG4gICAgY29uc3QgYW5nbGVGaWx0ZXJSYXdWYWx1ZXMgPSB0aGlzLnByb3BlcnRpZXMuYW5nbGVGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlQ29sdW1uQnlJZCh0aGlzLCBgYW5nbGVGaWx0ZXJSYXdgLCBwcm9jZXNzZWREYXRhKSA6IHZvaWQgMDtcbiAgICBjb25zdCByYWRpdXNWYWx1ZXMgPSB0aGlzLnByb3BlcnRpZXMucmFkaXVzS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVDb2x1bW5CeUlkKHRoaXMsIGByYWRpdXNWYWx1ZWAsIHByb2Nlc3NlZERhdGEpIDogdm9pZCAwO1xuICAgIGNvbnN0IHJhZGl1c1Jhd1ZhbHVlcyA9IHRoaXMucHJvcGVydGllcy5yYWRpdXNLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYHJhZGl1c1Jhd2AsIHByb2Nlc3NlZERhdGEpIDogdm9pZCAwO1xuICAgIGNvbnN0IGNhbGxvdXRMYWJlbFZhbHVlcyA9IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYGNhbGxvdXRMYWJlbFZhbHVlYCwgcHJvY2Vzc2VkRGF0YSkgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2VjdG9yTGFiZWxWYWx1ZXMgPSB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYHNlY3RvckxhYmVsVmFsdWVgLCBwcm9jZXNzZWREYXRhKSA6IHZvaWQgMDtcbiAgICBjb25zdCBsZWdlbmRJdGVtVmFsdWVzID0gdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXkgPyBkYXRhTW9kZWwucmVzb2x2ZUNvbHVtbkJ5SWQodGhpcywgYGxlZ2VuZEl0ZW1WYWx1ZWAsIHByb2Nlc3NlZERhdGEpIDogdm9pZCAwO1xuICAgIHJldHVybiB7XG4gICAgICBhbmdsZVZhbHVlcyxcbiAgICAgIGFuZ2xlUmF3VmFsdWVzLFxuICAgICAgYW5nbGVGaWx0ZXJWYWx1ZXMsXG4gICAgICBhbmdsZUZpbHRlclJhd1ZhbHVlcyxcbiAgICAgIHJhZGl1c1ZhbHVlcyxcbiAgICAgIHJhZGl1c1Jhd1ZhbHVlcyxcbiAgICAgIGNhbGxvdXRMYWJlbFZhbHVlcyxcbiAgICAgIHNlY3RvckxhYmVsVmFsdWVzLFxuICAgICAgbGVnZW5kSXRlbVZhbHVlc1xuICAgIH07XG4gIH1cbiAgY3JlYXRlTm9kZURhdGEoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQ6IHNlcmllc0lkLFxuICAgICAgcHJvY2Vzc2VkRGF0YSxcbiAgICAgIGRhdGFNb2RlbCxcbiAgICAgIGFuZ2xlU2NhbGUsXG4gICAgICBjdHg6IHsgbGVnZW5kTWFuYWdlciB9LFxuICAgICAgdmlzaWJsZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcm90YXRpb24gfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAoIWRhdGFNb2RlbCB8fCBwcm9jZXNzZWREYXRhPy50eXBlICE9PSBcInVuZ3JvdXBlZFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGFuZ2xlVmFsdWVzLFxuICAgICAgYW5nbGVSYXdWYWx1ZXMsXG4gICAgICBhbmdsZUZpbHRlclZhbHVlcyxcbiAgICAgIGFuZ2xlRmlsdGVyUmF3VmFsdWVzLFxuICAgICAgcmFkaXVzVmFsdWVzLFxuICAgICAgcmFkaXVzUmF3VmFsdWVzLFxuICAgICAgY2FsbG91dExhYmVsVmFsdWVzLFxuICAgICAgc2VjdG9yTGFiZWxWYWx1ZXMsXG4gICAgICBsZWdlbmRJdGVtVmFsdWVzXG4gICAgfSA9IHRoaXMuZ2V0UHJvY2Vzc2VkRGF0YVZhbHVlcyhkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEpO1xuICAgIGNvbnN0IHVzZUZpbHRlckFuZ2xlcyA9IGFuZ2xlRmlsdGVyUmF3VmFsdWVzPy5zb21lKChmaWx0ZXJSYXdWYWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiBmaWx0ZXJSYXdWYWx1ZSA+IGFuZ2xlUmF3VmFsdWVzW2luZGV4XTtcbiAgICB9KSA/PyBmYWxzZTtcbiAgICBsZXQgY3VycmVudFN0YXJ0ID0gMDtcbiAgICBsZXQgc3VtMiA9IDA7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBjb25zdCBwaGFudG9tTm9kZXMgPSBhbmdsZUZpbHRlclJhd1ZhbHVlcyAhPSBudWxsID8gW10gOiB2b2lkIDA7XG4gICAgY29uc3QgcmF3RGF0YSA9IHByb2Nlc3NlZERhdGEuZGF0YVNvdXJjZXMuZ2V0KHRoaXMuaWQpID8/IFtdO1xuICAgIGNvbnN0IGludmFsaWREYXRhID0gcHJvY2Vzc2VkRGF0YS5pbnZhbGlkRGF0YT8uZ2V0KHRoaXMuaWQpO1xuICAgIHJhd0RhdGEuZm9yRWFjaCgoZGF0dW0sIGRhdHVtSW5kZXgpID0+IHtcbiAgICAgIGlmIChpbnZhbGlkRGF0YT8uW2RhdHVtSW5kZXhdID09PSB0cnVlKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB1c2VGaWx0ZXJBbmdsZXMgPyBhbmdsZUZpbHRlclZhbHVlc1tkYXR1bUluZGV4XSA6IGFuZ2xlVmFsdWVzW2RhdHVtSW5kZXhdO1xuICAgICAgY29uc3QgY3Jvc3NGaWx0ZXJTY2FsZSA9IGFuZ2xlRmlsdGVyUmF3VmFsdWVzICE9IG51bGwgJiYgIXVzZUZpbHRlckFuZ2xlcyA/IE1hdGguc3FydChhbmdsZUZpbHRlclJhd1ZhbHVlc1tkYXR1bUluZGV4XSAvIGFuZ2xlUmF3VmFsdWVzW2RhdHVtSW5kZXhdKSA6IDE7XG4gICAgICBjb25zdCBzdGFydEFuZ2xlID0gYW5nbGVTY2FsZS5jb252ZXJ0KGN1cnJlbnRTdGFydCkgKyB0b1JhZGlhbnMocm90YXRpb24pO1xuICAgICAgY3VycmVudFN0YXJ0ID0gY3VycmVudFZhbHVlO1xuICAgICAgc3VtMiArPSBjdXJyZW50VmFsdWU7XG4gICAgICBjb25zdCBlbmRBbmdsZSA9IGFuZ2xlU2NhbGUuY29udmVydChjdXJyZW50U3RhcnQpICsgdG9SYWRpYW5zKHJvdGF0aW9uKTtcbiAgICAgIGNvbnN0IHNwYW4gPSBNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICAgICAgY29uc3QgbWlkQW5nbGUgPSBzdGFydEFuZ2xlICsgc3BhbiAvIDI7XG4gICAgICBjb25zdCBhbmdsZVZhbHVlID0gYW5nbGVSYXdWYWx1ZXNbZGF0dW1JbmRleF07XG4gICAgICBjb25zdCByYWRpdXNSYXcgPSByYWRpdXNWYWx1ZXM/LltkYXR1bUluZGV4XSA/PyAxO1xuICAgICAgY29uc3QgcmFkaXVzID0gcmFkaXVzUmF3ICogY3Jvc3NGaWx0ZXJTY2FsZTtcbiAgICAgIGNvbnN0IHJhZGl1c1ZhbHVlID0gcmFkaXVzUmF3VmFsdWVzPy5bZGF0dW1JbmRleF07XG4gICAgICBjb25zdCBsZWdlbmRJdGVtVmFsdWUgPSBsZWdlbmRJdGVtVmFsdWVzPy5bZGF0dW1JbmRleF07XG4gICAgICBjb25zdCBub2RlTGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoXG4gICAgICAgIGRhdHVtLFxuICAgICAgICBtaWRBbmdsZSxcbiAgICAgICAgc3BhbixcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgY2FsbG91dExhYmVsVmFsdWVzPy5bZGF0dW1JbmRleF0sXG4gICAgICAgIHNlY3RvckxhYmVsVmFsdWVzPy5bZGF0dW1JbmRleF0sXG4gICAgICAgIGxlZ2VuZEl0ZW1WYWx1ZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHNlY3RvckZvcm1hdCA9IHRoaXMuZ2V0U2VjdG9yRm9ybWF0KGRhdHVtLCBkYXR1bUluZGV4LCBmYWxzZSk7XG4gICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICBpdGVtSWQ6IGRhdHVtSW5kZXgsXG4gICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGRhdHVtSW5kZXgsXG4gICAgICAgIGFuZ2xlVmFsdWUsXG4gICAgICAgIG1pZEFuZ2xlLFxuICAgICAgICBtaWRDb3M6IE1hdGguY29zKG1pZEFuZ2xlKSxcbiAgICAgICAgbWlkU2luOiBNYXRoLnNpbihtaWRBbmdsZSksXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICByYWRpdXMsXG4gICAgICAgIGlubmVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoMCksIDApLFxuICAgICAgICBvdXRlclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KHJhZGl1cyksIDApLFxuICAgICAgICBzZWN0b3JGb3JtYXQsXG4gICAgICAgIHJhZGl1c1ZhbHVlLFxuICAgICAgICBsZWdlbmRJdGVtVmFsdWUsXG4gICAgICAgIGVuYWJsZWQ6IHZpc2libGUgJiYgbGVnZW5kTWFuYWdlci5nZXRJdGVtRW5hYmxlZCh7IHNlcmllc0lkLCBpdGVtSWQ6IGRhdHVtSW5kZXggfSksXG4gICAgICAgIC4uLm5vZGVMYWJlbHNcbiAgICAgIH07XG4gICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgaWYgKHBoYW50b21Ob2RlcyAhPSBudWxsKSB7XG4gICAgICAgIHBoYW50b21Ob2Rlcy5wdXNoKHtcbiAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgIHJhZGl1czogMSxcbiAgICAgICAgICBpbm5lclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDApLCAwKSxcbiAgICAgICAgICBvdXRlclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDEpLCAwKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcudmlzaWJsZSA9IHN1bTIgPT09IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1JZDogc2VyaWVzSWQsXG4gICAgICBub2RlRGF0YTogbm9kZXMsXG4gICAgICBsYWJlbERhdGE6IG5vZGVzLFxuICAgICAgcGhhbnRvbU5vZGVEYXRhOiBwaGFudG9tTm9kZXNcbiAgICB9O1xuICB9XG4gIGdldExhYmVscyhkYXR1bSwgbWlkQW5nbGUsIHNwYW4sIHNraXBEaXNhYmxlZCwgY2FsbG91dExhYmVsVmFsdWUsIHNlY3RvckxhYmVsVmFsdWUsIGxlZ2VuZEl0ZW1WYWx1ZSkge1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsLCBzZWN0b3JMYWJlbCwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNhbGxvdXRMYWJlbEtleSA9ICFza2lwRGlzYWJsZWQgfHwgY2FsbG91dExhYmVsLmVuYWJsZWQgPyB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5IDogdm9pZCAwO1xuICAgIGNvbnN0IHNlY3RvckxhYmVsS2V5ID0gIXNraXBEaXNhYmxlZCB8fCBzZWN0b3JMYWJlbC5lbmFibGVkID8gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5IDogdm9pZCAwO1xuICAgIGlmICghY2FsbG91dExhYmVsS2V5ICYmICFzZWN0b3JMYWJlbEtleSAmJiAhbGVnZW5kSXRlbUtleSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBsYWJlbEZvcm1hdHRlclBhcmFtcyA9IHtcbiAgICAgIGRhdHVtLFxuICAgICAgYW5nbGVLZXk6IHRoaXMucHJvcGVydGllcy5hbmdsZUtleSxcbiAgICAgIGFuZ2xlTmFtZTogdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlTmFtZSxcbiAgICAgIHJhZGl1c0tleTogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c0tleSxcbiAgICAgIHJhZGl1c05hbWU6IHRoaXMucHJvcGVydGllcy5yYWRpdXNOYW1lLFxuICAgICAgY2FsbG91dExhYmVsS2V5OiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5LFxuICAgICAgY2FsbG91dExhYmVsTmFtZTogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbE5hbWUsXG4gICAgICBzZWN0b3JMYWJlbEtleTogdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5LFxuICAgICAgc2VjdG9yTGFiZWxOYW1lOiB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxOYW1lLFxuICAgICAgbGVnZW5kSXRlbUtleTogdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXlcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGlmIChjYWxsb3V0TGFiZWxLZXkgJiYgc3BhbiA+PSB0b1JhZGlhbnMoY2FsbG91dExhYmVsLm1pbkFuZ2xlKSkge1xuICAgICAgcmVzdWx0LmNhbGxvdXRMYWJlbCA9IHtcbiAgICAgICAgLi4udGhpcy5nZXRUZXh0QWxpZ25tZW50KG1pZEFuZ2xlKSxcbiAgICAgICAgdGV4dDogdGhpcy5nZXRMYWJlbFRleHQoY2FsbG91dExhYmVsLCB7XG4gICAgICAgICAgLi4ubGFiZWxGb3JtYXR0ZXJQYXJhbXMsXG4gICAgICAgICAgdmFsdWU6IGNhbGxvdXRMYWJlbFZhbHVlXG4gICAgICAgIH0pLFxuICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICBjb2xsaXNpb25UZXh0QWxpZ246IHZvaWQgMCxcbiAgICAgICAgY29sbGlzaW9uT2Zmc2V0WTogMCxcbiAgICAgICAgYm94OiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChzZWN0b3JMYWJlbEtleSkge1xuICAgICAgcmVzdWx0LnNlY3RvckxhYmVsID0ge1xuICAgICAgICB0ZXh0OiB0aGlzLmdldExhYmVsVGV4dChzZWN0b3JMYWJlbCwge1xuICAgICAgICAgIC4uLmxhYmVsRm9ybWF0dGVyUGFyYW1zLFxuICAgICAgICAgIHZhbHVlOiBzZWN0b3JMYWJlbFZhbHVlXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobGVnZW5kSXRlbUtleSAhPSBudWxsICYmIGxlZ2VuZEl0ZW1WYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXN1bHQubGVnZW5kSXRlbSA9IHsga2V5OiBsZWdlbmRJdGVtS2V5LCB0ZXh0OiBsZWdlbmRJdGVtVmFsdWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXRUZXh0QWxpZ25tZW50KG1pZEFuZ2xlKSB7XG4gICAgY29uc3QgcXVhZHJhbnRUZXh0T3B0cyA9IFtcbiAgICAgIHsgdGV4dEFsaWduOiBcImNlbnRlclwiLCB0ZXh0QmFzZWxpbmU6IFwiYm90dG9tXCIgfSxcbiAgICAgIHsgdGV4dEFsaWduOiBcImxlZnRcIiwgdGV4dEJhc2VsaW5lOiBcIm1pZGRsZVwiIH0sXG4gICAgICB7IHRleHRBbGlnbjogXCJjZW50ZXJcIiwgdGV4dEJhc2VsaW5lOiBcImhhbmdpbmdcIiB9LFxuICAgICAgeyB0ZXh0QWxpZ246IFwicmlnaHRcIiwgdGV4dEJhc2VsaW5lOiBcIm1pZGRsZVwiIH1cbiAgICBdO1xuICAgIGNvbnN0IG1pZEFuZ2xlMTgwID0gbm9ybWFsaXplQW5nbGUxODAobWlkQW5nbGUpO1xuICAgIGNvbnN0IHF1YWRyYW50U3RhcnQgPSAtMC43NSAqIE1hdGguUEk7XG4gICAgY29uc3QgcXVhZHJhbnRPZmZzZXQgPSBtaWRBbmdsZTE4MCAtIHF1YWRyYW50U3RhcnQ7XG4gICAgY29uc3QgcXVhZHJhbnQgPSBNYXRoLmZsb29yKHF1YWRyYW50T2Zmc2V0IC8gKE1hdGguUEkgLyAyKSk7XG4gICAgY29uc3QgcXVhZHJhbnRJbmRleCA9IG1vZChxdWFkcmFudCwgcXVhZHJhbnRUZXh0T3B0cy5sZW5ndGgpO1xuICAgIHJldHVybiBxdWFkcmFudFRleHRPcHRzW3F1YWRyYW50SW5kZXhdO1xuICB9XG4gIGdldFNlY3RvckZvcm1hdChkYXR1bSwgZGF0dW1JbmRleCwgaGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25zdCB7IGFuZ2xlS2V5LCByYWRpdXNLZXksIGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXksIGZpbGxzLCBzdHJva2VzLCBpdGVtU3R5bGVyIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgZGVmYXVsdFN0cm9rZSA9IHN0cm9rZXNbZGF0dW1JbmRleCAlIHN0cm9rZXMubGVuZ3RoXTtcbiAgICBjb25zdCB7IGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2U6IHN0cm9rZTIsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5LCBsaW5lRGFzaCwgbGluZURhc2hPZmZzZXQsIGNvcm5lclJhZGl1cyB9ID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgIGhpZ2hsaWdodGVkICYmIHRoaXMucHJvcGVydGllcy5oaWdobGlnaHRTdHlsZS5pdGVtLFxuICAgICAge1xuICAgICAgICBmaWxsOiBmaWxscy5sZW5ndGggPiAwID8gZmlsbHNbZGF0dW1JbmRleCAlIGZpbGxzLmxlbmd0aF0gOiB2b2lkIDAsXG4gICAgICAgIHN0cm9rZTogZGVmYXVsdFN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuZ2V0U3Ryb2tlV2lkdGgodGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoKSxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5nZXRPcGFjaXR5KClcbiAgICAgIH0sXG4gICAgICB0aGlzLnByb3BlcnRpZXNcbiAgICApO1xuICAgIGxldCBmb3JtYXQ7XG4gICAgaWYgKGl0ZW1TdHlsZXIpIHtcbiAgICAgIGZvcm1hdCA9IHRoaXMuY2FjaGVkRGF0dW1DYWxsYmFjayhcbiAgICAgICAgdGhpcy5nZXREYXR1bUlkKGRhdHVtLCBkYXR1bUluZGV4KSArIChoaWdobGlnaHRlZCA/IFwiLWhpZ2hsaWdodFwiIDogXCItaGlkZVwiKSxcbiAgICAgICAgKCkgPT4gaXRlbVN0eWxlcih7XG4gICAgICAgICAgZGF0dW0sXG4gICAgICAgICAgYW5nbGVLZXksXG4gICAgICAgICAgcmFkaXVzS2V5LFxuICAgICAgICAgIGNhbGxvdXRMYWJlbEtleSxcbiAgICAgICAgICBzZWN0b3JMYWJlbEtleSxcbiAgICAgICAgICBsZWdlbmRJdGVtS2V5LFxuICAgICAgICAgIGZpbGwsXG4gICAgICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICBzdHJva2U6IHN0cm9rZTIsXG4gICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgZmlsbE9wYWNpdHksXG4gICAgICAgICAgbGluZURhc2gsXG4gICAgICAgICAgbGluZURhc2hPZmZzZXQsXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGhpZ2hsaWdodGVkLFxuICAgICAgICAgIHNlcmllc0lkOiB0aGlzLmlkXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZmlsbDogZm9ybWF0Py5maWxsID8/IGZpbGwsXG4gICAgICBmaWxsT3BhY2l0eTogZm9ybWF0Py5maWxsT3BhY2l0eSA/PyBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZTogZm9ybWF0Py5zdHJva2UgPz8gc3Ryb2tlMixcbiAgICAgIHN0cm9rZVdpZHRoOiBmb3JtYXQ/LnN0cm9rZVdpZHRoID8/IHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogZm9ybWF0Py5zdHJva2VPcGFjaXR5ID8/IHN0cm9rZU9wYWNpdHksXG4gICAgICBsaW5lRGFzaDogZm9ybWF0Py5saW5lRGFzaCA/PyBsaW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiBmb3JtYXQ/LmxpbmVEYXNoT2Zmc2V0ID8/IGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgY29ybmVyUmFkaXVzOiBmb3JtYXQ/LmNvcm5lclJhZGl1cyA/PyBjb3JuZXJSYWRpdXNcbiAgICB9O1xuICB9XG4gIGdldE91dGVyUmFkaXVzKCkge1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnJhZGl1cyAqIHRoaXMucHJvcGVydGllcy5vdXRlclJhZGl1c1JhdGlvICsgdGhpcy5wcm9wZXJ0aWVzLm91dGVyUmFkaXVzT2Zmc2V0LCAwKTtcbiAgfVxuICB1cGRhdGVSYWRpdXNTY2FsZShyZXNpemUpIHtcbiAgICBjb25zdCBuZXdSYW5nZSA9IFswLCB0aGlzLmdldE91dGVyUmFkaXVzKCldO1xuICAgIHRoaXMucmFkaXVzU2NhbGUucmFuZ2UgPSBuZXdSYW5nZTtcbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSBuZXdSYW5nZTtcbiAgICB9XG4gICAgY29uc3Qgc2V0UmFkaWkgPSAoZCkgPT4gKHtcbiAgICAgIC4uLmQsXG4gICAgICBpbm5lclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDApLCAwKSxcbiAgICAgIG91dGVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoZC5yYWRpdXMpLCAwKVxuICAgIH0pO1xuICAgIHRoaXMubm9kZURhdGEgPSB0aGlzLm5vZGVEYXRhLm1hcChzZXRSYWRpaSk7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGEgPSB0aGlzLnBoYW50b21Ob2RlRGF0YT8ubWFwKHNldFJhZGlpKTtcbiAgfVxuICBnZXRUaXRsZVRyYW5zbGF0aW9uWSgpIHtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KDAsIHRoaXMucmFkaXVzU2NhbGUucmFuZ2VbMV0pO1xuICAgIGlmIChvdXRlclJhZGl1cyA9PT0gMCkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3Qgc3BhY2luZyA9IHRoaXMucHJvcGVydGllcy50aXRsZT8uc3BhY2luZyA/PyAwO1xuICAgIGNvbnN0IHRpdGxlT2Zmc2V0ID0gMiArIHNwYWNpbmc7XG4gICAgY29uc3QgZHkgPSBNYXRoLm1heCgwLCAtb3V0ZXJSYWRpdXMpO1xuICAgIHJldHVybiAtb3V0ZXJSYWRpdXMgLSB0aXRsZU9mZnNldCAtIGR5O1xuICB9XG4gIHVwZGF0ZSh7IHNlcmllc1JlY3QgfSkge1xuICAgIGNvbnN0IHsgdGl0bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBuZXdOb2RlRGF0YURlcGVuZGVuY2llcyA9IHtcbiAgICAgIHNlcmllc1JlY3RXaWR0aDogc2VyaWVzUmVjdD8ud2lkdGgsXG4gICAgICBzZXJpZXNSZWN0SGVpZ2h0OiBzZXJpZXNSZWN0Py5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHJlc2l6ZSA9IGpzb25EaWZmKHRoaXMubm9kZURhdGFEZXBlbmRlbmNpZXMsIG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzKSAhPSBudWxsO1xuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHRoaXMuX25vZGVEYXRhRGVwZW5kZW5jaWVzID0gbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXM7XG4gICAgfVxuICAgIHRoaXMubWF5YmVSZWZyZXNoTm9kZURhdGEoKTtcbiAgICB0aGlzLnVwZGF0ZVRpdGxlTm9kZXMoKTtcbiAgICB0aGlzLnVwZGF0ZVJhZGl1c1NjYWxlKHJlc2l6ZSk7XG4gICAgdGhpcy5jb250ZW50R3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy5jZW50ZXJYO1xuICAgIHRoaXMuY29udGVudEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcbiAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICB0aGlzLmJhY2tncm91bmRHcm91cC50cmFuc2xhdGlvblggPSB0aGlzLmNlbnRlclg7XG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xuICAgIGlmICh0aGlzLmxhYmVsR3JvdXApIHtcbiAgICAgIHRoaXMubGFiZWxHcm91cC50cmFuc2xhdGlvblggPSB0aGlzLmNlbnRlclg7XG4gICAgICB0aGlzLmxhYmVsR3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xuICAgIH1cbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGNvbnN0IGR5ID0gdGhpcy5nZXRUaXRsZVRyYW5zbGF0aW9uWSgpO1xuICAgICAgdGl0bGUubm9kZS55ID0gaXNGaW5pdGUoZHkpID8gZHkgOiAwO1xuICAgICAgY29uc3QgdGl0bGVCb3ggPSB0aXRsZS5ub2RlLmdldEJCb3goKTtcbiAgICAgIHRpdGxlLm5vZGUudmlzaWJsZSA9IHRpdGxlLmVuYWJsZWQgJiYgaXNGaW5pdGUoZHkpICYmICF0aGlzLmJib3hJbnRlcnNlY3RzU3Vycm91bmRpbmdTZXJpZXModGl0bGVCb3gpO1xuICAgIH1cbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcuZmlsbE9wYWNpdHkgPSAwO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy5zdHJva2UgPSB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsLmNvbG9yO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy5zdHJva2VXaWR0aCA9IDE7XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nLnN0cm9rZU9wYWNpdHkgPSAxO1xuICAgIHRoaXMudXBkYXRlTm9kZU1pZFBvaW50KCk7XG4gICAgdGhpcy51cGRhdGVTZWxlY3Rpb25zKCk7XG4gICAgdGhpcy51cGRhdGVOb2RlcyhzZXJpZXNSZWN0KTtcbiAgfVxuICB1cGRhdGVUaXRsZU5vZGVzKCkge1xuICAgIGNvbnN0IHsgb2xkVGl0bGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB0aXRsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmIChvbGRUaXRsZSAhPT0gdGl0bGUpIHtcbiAgICAgIGlmIChvbGRUaXRsZSkge1xuICAgICAgICB0aGlzLmxhYmVsR3JvdXA/LnJlbW92ZUNoaWxkKG9sZFRpdGxlLm5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIHRpdGxlLm5vZGUudGV4dEJhc2VsaW5lID0gXCJib3R0b21cIjtcbiAgICAgICAgdGhpcy5sYWJlbEdyb3VwPy5hcHBlbmRDaGlsZCh0aXRsZS5ub2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2xkVGl0bGUgPSB0aXRsZTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlTm9kZU1pZFBvaW50KCkge1xuICAgIGNvbnN0IHNldE1pZFBvaW50ID0gKGQpID0+IHtcbiAgICAgIGNvbnN0IHJhZGl1cyA9IGQuaW5uZXJSYWRpdXMgKyAoZC5vdXRlclJhZGl1cyAtIGQuaW5uZXJSYWRpdXMpIC8gMjtcbiAgICAgIGQubWlkUG9pbnQgPSB7XG4gICAgICAgIHg6IGQubWlkQ29zICogTWF0aC5tYXgoMCwgcmFkaXVzKSxcbiAgICAgICAgeTogZC5taWRTaW4gKiBNYXRoLm1heCgwLCByYWRpdXMpXG4gICAgICB9O1xuICAgIH07XG4gICAgdGhpcy5ub2RlRGF0YS5mb3JFYWNoKHNldE1pZFBvaW50KTtcbiAgICB0aGlzLnBoYW50b21Ob2RlRGF0YT8uZm9yRWFjaChzZXRNaWRQb2ludCk7XG4gIH1cbiAgdXBkYXRlU2VsZWN0aW9ucygpIHtcbiAgICBjb25zdCB7XG4gICAgICBpdGVtU2VsZWN0aW9uLFxuICAgICAgaGlnaGxpZ2h0U2VsZWN0aW9uLFxuICAgICAgcGhhbnRvbVNlbGVjdGlvbixcbiAgICAgIGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLFxuICAgICAgY2FsbG91dExhYmVsU2VsZWN0aW9uLFxuICAgICAgbGFiZWxTZWxlY3Rpb25cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBoaWdobGlnaHRlZE5vZGVEYXRhID0gdGhpcy5ub2RlRGF0YS5tYXAoKGRhdHVtKSA9PiAoe1xuICAgICAgLi4uZGF0dW0sXG4gICAgICAvLyBBbGxvdyBtdXRhYmxlIHNlY3RvckZvcm1hdCwgc28gZm9ybWF0dGVkIHNlY3RvciBzdHlsZXMgY2FuIGJlIHVwZGF0ZWQgYW5kIHZhcmllZFxuICAgICAgLy8gYmV0d2VlbiBub3JtYWwgYW5kIGhpZ2hsaWdodGVkIGNhc2VzLlxuICAgICAgc2VjdG9yRm9ybWF0OiB7IC4uLmRhdHVtLnNlY3RvckZvcm1hdCB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHVwZGF0ZSA9IChzZWxlY3Rpb24sIG5vZGVEYXRhKSA9PiB7XG4gICAgICBzZWxlY3Rpb24udXBkYXRlKG5vZGVEYXRhLCB2b2lkIDAsIChkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtLmRhdHVtLCBkYXR1bS5kYXR1bUluZGV4KSk7XG4gICAgICBpZiAodGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKSkge1xuICAgICAgICBzZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdXBkYXRlKGl0ZW1TZWxlY3Rpb24sIHRoaXMubm9kZURhdGEpO1xuICAgIHVwZGF0ZShoaWdobGlnaHRTZWxlY3Rpb24sIGhpZ2hsaWdodGVkTm9kZURhdGEpO1xuICAgIHVwZGF0ZShwaGFudG9tU2VsZWN0aW9uLCB0aGlzLnBoYW50b21Ob2RlRGF0YSA/PyBbXSk7XG4gICAgY2FsbG91dExhYmVsU2VsZWN0aW9uLnVwZGF0ZSh0aGlzLmNhbGxvdXROb2RlRGF0YSwgKGdyb3VwKSA9PiB7XG4gICAgICBjb25zdCBsaW5lID0gbmV3IExpbmUoKTtcbiAgICAgIGxpbmUudGFnID0gMCAvKiBDYWxsb3V0ICovO1xuICAgICAgbGluZS5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQobGluZSk7XG4gICAgICBjb25zdCB0ZXh0MiA9IG5ldyBUZXh0KCk7XG4gICAgICB0ZXh0Mi50YWcgPSAxIC8qIExhYmVsICovO1xuICAgICAgdGV4dDIucG9pbnRlckV2ZW50cyA9IDEgLyogTm9uZSAqLztcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKHRleHQyKTtcbiAgICB9KTtcbiAgICBsYWJlbFNlbGVjdGlvbi51cGRhdGUodGhpcy5ub2RlRGF0YSk7XG4gICAgaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24udXBkYXRlKGhpZ2hsaWdodGVkTm9kZURhdGEpO1xuICB9XG4gIHVwZGF0ZU5vZGVzKHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCBoaWdobGlnaHRlZERhdHVtID0gdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlci5nZXRBY3RpdmVIaWdobGlnaHQoKTtcbiAgICBjb25zdCB7IHZpc2libGUgfSA9IHRoaXM7XG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAudmlzaWJsZSA9IHZpc2libGU7XG4gICAgdGhpcy5jb250ZW50R3JvdXAudmlzaWJsZSA9IHZpc2libGU7XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC52aXNpYmxlID0gdmlzaWJsZSAmJiBoaWdobGlnaHRlZERhdHVtPy5zZXJpZXMgPT09IHRoaXM7XG4gICAgdGhpcy5oaWdobGlnaHRMYWJlbC52aXNpYmxlID0gdmlzaWJsZSAmJiBoaWdobGlnaHRlZERhdHVtPy5zZXJpZXMgPT09IHRoaXM7XG4gICAgaWYgKHRoaXMubGFiZWxHcm91cCkge1xuICAgICAgdGhpcy5sYWJlbEdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIH1cbiAgICB0aGlzLmNvbnRlbnRHcm91cC5vcGFjaXR5ID0gdGhpcy5nZXRPcGFjaXR5KCk7XG4gICAgY29uc3QgYW5pbWF0aW9uRGlzYWJsZWQgPSB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IHVwZGF0ZVNlY3RvckZuID0gKHNlY3RvciwgZGF0dW0sIF9pbmRleCwgaXNEYXR1bUhpZ2hsaWdodGVkKSA9PiB7XG4gICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmdldFNlY3RvckZvcm1hdChkYXR1bS5kYXR1bSwgZGF0dW0uaXRlbUlkLCBpc0RhdHVtSGlnaGxpZ2h0ZWQpO1xuICAgICAgZGF0dW0uc2VjdG9yRm9ybWF0LmZpbGwgPSBmb3JtYXQuZmlsbDtcbiAgICAgIGRhdHVtLnNlY3RvckZvcm1hdC5zdHJva2UgPSBmb3JtYXQuc3Ryb2tlO1xuICAgICAgaWYgKGFuaW1hdGlvbkRpc2FibGVkKSB7XG4gICAgICAgIHNlY3Rvci5zdGFydEFuZ2xlID0gZGF0dW0uc3RhcnRBbmdsZTtcbiAgICAgICAgc2VjdG9yLmVuZEFuZ2xlID0gZGF0dW0uZW5kQW5nbGU7XG4gICAgICAgIHNlY3Rvci5pbm5lclJhZGl1cyA9IGRhdHVtLmlubmVyUmFkaXVzO1xuICAgICAgICBzZWN0b3Iub3V0ZXJSYWRpdXMgPSBkYXR1bS5vdXRlclJhZGl1cztcbiAgICAgIH1cbiAgICAgIGlmIChpc0RhdHVtSGlnaGxpZ2h0ZWQgfHwgYW5pbWF0aW9uRGlzYWJsZWQpIHtcbiAgICAgICAgc2VjdG9yLmZpbGwgPSBmb3JtYXQuZmlsbDtcbiAgICAgICAgc2VjdG9yLnN0cm9rZSA9IGZvcm1hdC5zdHJva2U7XG4gICAgICB9XG4gICAgICBzZWN0b3Iuc3Ryb2tlV2lkdGggPSBmb3JtYXQuc3Ryb2tlV2lkdGg7XG4gICAgICBzZWN0b3IuZmlsbE9wYWNpdHkgPSBmb3JtYXQuZmlsbE9wYWNpdHk7XG4gICAgICBzZWN0b3Iuc3Ryb2tlT3BhY2l0eSA9IGZvcm1hdC5zdHJva2VPcGFjaXR5O1xuICAgICAgc2VjdG9yLmxpbmVEYXNoID0gZm9ybWF0LmxpbmVEYXNoO1xuICAgICAgc2VjdG9yLmxpbmVEYXNoT2Zmc2V0ID0gZm9ybWF0LmxpbmVEYXNoT2Zmc2V0O1xuICAgICAgc2VjdG9yLmNvcm5lclJhZGl1cyA9IGZvcm1hdC5jb3JuZXJSYWRpdXM7XG4gICAgICBzZWN0b3IuZmlsbFNoYWRvdyA9IHRoaXMucHJvcGVydGllcy5zaGFkb3c7XG4gICAgICBjb25zdCBpbnNldCA9IE1hdGgubWF4KFxuICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLnNlY3RvclNwYWNpbmcgKyAoZm9ybWF0LnN0cm9rZSAhPSBudWxsID8gZm9ybWF0LnN0cm9rZVdpZHRoIDogMCkpIC8gMixcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIHNlY3Rvci5pbnNldCA9IGluc2V0O1xuICAgICAgc2VjdG9yLmxpbmVKb2luID0gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvclNwYWNpbmcgPj0gMCB8fCBpbnNldCA+IDAgPyBcIm1pdGVyXCIgOiBcInJvdW5kXCI7XG4gICAgfTtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0sIGluZGV4KSA9PiB1cGRhdGVTZWN0b3JGbihub2RlLCBkYXR1bSwgaW5kZXgsIGZhbHNlKSk7XG4gICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICB1cGRhdGVTZWN0b3JGbihub2RlLCBkYXR1bSwgaW5kZXgsIHRydWUpO1xuICAgICAgbm9kZS52aXNpYmxlID0gZGF0dW0uaXRlbUlkID09PSBoaWdobGlnaHRlZERhdHVtPy5pdGVtSWQ7XG4gICAgfSk7XG4gICAgdGhpcy5waGFudG9tU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtLCBpbmRleCkgPT4gdXBkYXRlU2VjdG9yRm4obm9kZSwgZGF0dW0sIGluZGV4LCBmYWxzZSkpO1xuICAgIHRoaXMudXBkYXRlQ2FsbG91dExpbmVOb2RlcygpO1xuICAgIHRoaXMudXBkYXRlQ2FsbG91dExhYmVsTm9kZXMoc2VyaWVzUmVjdCk7XG4gICAgdGhpcy51cGRhdGVTZWN0b3JMYWJlbE5vZGVzKCk7XG4gICAgdGhpcy51cGRhdGVaZXJvc3VtUmluZ3MoKTtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVcIik7XG4gIH1cbiAgdXBkYXRlQ2FsbG91dExpbmVOb2RlcygpIHtcbiAgICBjb25zdCB7IGNhbGxvdXRMaW5lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2FsbG91dExlbmd0aCA9IGNhbGxvdXRMaW5lLmxlbmd0aDtcbiAgICBjb25zdCBjYWxsb3V0U3Ryb2tlV2lkdGggPSBjYWxsb3V0TGluZS5zdHJva2VXaWR0aDtcbiAgICBjb25zdCBjYWxsb3V0Q29sb3JzID0gY2FsbG91dExpbmUuY29sb3JzID8/IHRoaXMucHJvcGVydGllcy5zdHJva2VzO1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXQ0IH0gPSB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsO1xuICAgIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uLnNlbGVjdEJ5VGFnKDAgLyogQ2FsbG91dCAqLykuZm9yRWFjaCgobGluZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGRhdHVtID0gbGluZS5kYXR1bTtcbiAgICAgIGNvbnN0IHsgY2FsbG91dExhYmVsOiBsYWJlbCwgb3V0ZXJSYWRpdXMgfSA9IGRhdHVtO1xuICAgICAgaWYgKGxhYmVsPy50ZXh0ICYmICFsYWJlbC5oaWRkZW4gJiYgb3V0ZXJSYWRpdXMgIT09IDApIHtcbiAgICAgICAgbGluZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgbGluZS5zdHJva2VXaWR0aCA9IGNhbGxvdXRTdHJva2VXaWR0aDtcbiAgICAgICAgbGluZS5zdHJva2UgPSBjYWxsb3V0Q29sb3JzW2luZGV4ICUgY2FsbG91dENvbG9ycy5sZW5ndGhdO1xuICAgICAgICBsaW5lLmZpbGwgPSB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHgxID0gZGF0dW0ubWlkQ29zICogb3V0ZXJSYWRpdXM7XG4gICAgICAgIGNvbnN0IHkxID0gZGF0dW0ubWlkU2luICogb3V0ZXJSYWRpdXM7XG4gICAgICAgIGxldCB4MiA9IGRhdHVtLm1pZENvcyAqIChvdXRlclJhZGl1cyArIGNhbGxvdXRMZW5ndGgpO1xuICAgICAgICBsZXQgeTIgPSBkYXR1bS5taWRTaW4gKiAob3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoKTtcbiAgICAgICAgY29uc3QgaXNNb3ZlZCA9IGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA/PyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZICE9PSAwO1xuICAgICAgICBpZiAoaXNNb3ZlZCAmJiBsYWJlbC5ib3ggIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGJveCA9IGxhYmVsLmJveDtcbiAgICAgICAgICBsZXQgY3ggPSB4MjtcbiAgICAgICAgICBsZXQgY3kgPSB5MjtcbiAgICAgICAgICBpZiAoeDIgPCBib3gueCkge1xuICAgICAgICAgICAgY3ggPSBib3gueDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHgyID4gYm94LnggKyBib3gud2lkdGgpIHtcbiAgICAgICAgICAgIGN4ID0gYm94LnggKyBib3gud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh5MiA8IGJveC55KSB7XG4gICAgICAgICAgICBjeSA9IGJveC55O1xuICAgICAgICAgIH0gZWxzZSBpZiAoeTIgPiBib3gueSArIGJveC5oZWlnaHQpIHtcbiAgICAgICAgICAgIGN5ID0gYm94LnkgKyBib3guaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkeCA9IGN4IC0geDI7XG4gICAgICAgICAgY29uc3QgZHkgPSBjeSAtIHkyO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aDIgPSBNYXRoLnNxcnQoTWF0aC5wb3coZHgsIDIpICsgTWF0aC5wb3coZHksIDIpKTtcbiAgICAgICAgICBjb25zdCBwYWRkZWRMZW5ndGggPSBsZW5ndGgyIC0gb2Zmc2V0NDtcbiAgICAgICAgICBpZiAocGFkZGVkTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgeDIgPSB4MiArIGR4ICogcGFkZGVkTGVuZ3RoIC8gbGVuZ3RoMjtcbiAgICAgICAgICAgIHkyID0geTIgKyBkeSAqIHBhZGRlZExlbmd0aCAvIGxlbmd0aDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpbmUueDEgPSB4MTtcbiAgICAgICAgbGluZS55MSA9IHkxO1xuICAgICAgICBsaW5lLngyID0geDI7XG4gICAgICAgIGxpbmUueTIgPSB5MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldExhYmVsT3ZlcmZsb3codGV4dDIsIGJveCwgc2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IHNlcmllc0xlZnQgPSAtdGhpcy5jZW50ZXJYO1xuICAgIGNvbnN0IHNlcmllc1JpZ2h0ID0gc2VyaWVzTGVmdCArIHNlcmllc1JlY3Qud2lkdGg7XG4gICAgY29uc3Qgc2VyaWVzVG9wID0gLXRoaXMuY2VudGVyWTtcbiAgICBjb25zdCBzZXJpZXNCb3R0b20gPSBzZXJpZXNUb3AgKyBzZXJpZXNSZWN0LmhlaWdodDtcbiAgICBjb25zdCBlcnJQeCA9IDE7XG4gICAgbGV0IHZpc2libGVUZXh0UGFydCA9IDE7XG4gICAgaWYgKGJveC54ICsgZXJyUHggPCBzZXJpZXNMZWZ0KSB7XG4gICAgICB2aXNpYmxlVGV4dFBhcnQgPSAoYm94LnggKyBib3gud2lkdGggLSBzZXJpZXNMZWZ0KSAvIGJveC53aWR0aDtcbiAgICB9IGVsc2UgaWYgKGJveC54ICsgYm94LndpZHRoIC0gZXJyUHggPiBzZXJpZXNSaWdodCkge1xuICAgICAgdmlzaWJsZVRleHRQYXJ0ID0gKHNlcmllc1JpZ2h0IC0gYm94LngpIC8gYm94LndpZHRoO1xuICAgIH1cbiAgICBjb25zdCBoYXNWZXJ0aWNhbE92ZXJmbG93ID0gYm94LnkgKyBlcnJQeCA8IHNlcmllc1RvcCB8fCBib3gueSArIGJveC5oZWlnaHQgLSBlcnJQeCA+IHNlcmllc0JvdHRvbTtcbiAgICBjb25zdCB0ZXh0TGVuZ3RoID0gdmlzaWJsZVRleHRQYXJ0ID09PSAxID8gdGV4dDIubGVuZ3RoIDogTWF0aC5mbG9vcih0ZXh0Mi5sZW5ndGggKiB2aXNpYmxlVGV4dFBhcnQpIC0gMTtcbiAgICBjb25zdCBoYXNTdXJyb3VuZGluZ1Nlcmllc092ZXJmbG93ID0gdGhpcy5iYm94SW50ZXJzZWN0c1N1cnJvdW5kaW5nU2VyaWVzKGJveCk7XG4gICAgcmV0dXJuIHsgdGV4dExlbmd0aCwgaGFzVmVydGljYWxPdmVyZmxvdywgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdyB9O1xuICB9XG4gIGJib3hJbnRlcnNlY3RzU3Vycm91bmRpbmdTZXJpZXMoYm94KSB7XG4gICAgY29uc3QgeyBzdXJyb3VuZGluZ1JhZGl1cyB9ID0gdGhpcztcbiAgICBpZiAoc3Vycm91bmRpbmdSYWRpdXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb3JuZXJzID0gW1xuICAgICAgeyB4OiBib3gueCwgeTogYm94LnkgfSxcbiAgICAgIHsgeDogYm94LnggKyBib3gud2lkdGgsIHk6IGJveC55IH0sXG4gICAgICB7IHg6IGJveC54ICsgYm94LndpZHRoLCB5OiBib3gueSArIGJveC5oZWlnaHQgfSxcbiAgICAgIHsgeDogYm94LngsIHk6IGJveC55ICsgYm94LmhlaWdodCB9XG4gICAgXTtcbiAgICBjb25zdCBzdXIyID0gc3Vycm91bmRpbmdSYWRpdXMgKiogMjtcbiAgICByZXR1cm4gY29ybmVycy5zb21lKChjb3JuZXIpID0+IGNvcm5lci54ICoqIDIgKyBjb3JuZXIueSAqKiAyID4gc3VyMik7XG4gIH1cbiAgY29tcHV0ZUNhbGxvdXRMYWJlbENvbGxpc2lvbk9mZnNldHMoKSB7XG4gICAgY29uc3QgeyByYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgY2FsbG91dExpbmUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IG9mZnNldDogb2Zmc2V0NCwgbWluU3BhY2luZyB9ID0gY2FsbG91dExhYmVsO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gcmFkaXVzU2NhbGUuY29udmVydCgwKTtcbiAgICBjb25zdCBzaG91bGRTa2lwID0gKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIHJldHVybiAhbGFiZWwgfHwgZGF0dW0ub3V0ZXJSYWRpdXMgPT09IDA7XG4gICAgfTtcbiAgICBjb25zdCBmdWxsRGF0YSA9IHRoaXMuY2FsbG91dE5vZGVEYXRhO1xuICAgIGNvbnN0IGRhdGEgPSBmdWxsRGF0YS5maWx0ZXIoKHQpID0+ICFzaG91bGRTa2lwKHQpKTtcbiAgICBkYXRhLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIGlmIChsYWJlbCA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICBsYWJlbC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9IHZvaWQgMDtcbiAgICAgIGxhYmVsLmNvbGxpc2lvbk9mZnNldFkgPSAwO1xuICAgIH0pO1xuICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxlZnRMYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRDb3MgPCAwKS5zb3J0KChhLCBiKSA9PiBhLm1pZFNpbiAtIGIubWlkU2luKTtcbiAgICBjb25zdCByaWdodExhYmVscyA9IGRhdGEuZmlsdGVyKChkKSA9PiBkLm1pZENvcyA+PSAwKS5zb3J0KChhLCBiKSA9PiBhLm1pZFNpbiAtIGIubWlkU2luKTtcbiAgICBjb25zdCB0b3BMYWJlbHMgPSBkYXRhLmZpbHRlcigoZCkgPT4gZC5taWRTaW4gPCAwICYmIGQuY2FsbG91dExhYmVsPy50ZXh0QWxpZ24gPT09IFwiY2VudGVyXCIpLnNvcnQoKGEsIGIpID0+IGEubWlkQ29zIC0gYi5taWRDb3MpO1xuICAgIGNvbnN0IGJvdHRvbUxhYmVscyA9IGRhdGEuZmlsdGVyKChkKSA9PiBkLm1pZFNpbiA+PSAwICYmIGQuY2FsbG91dExhYmVsPy50ZXh0QWxpZ24gPT09IFwiY2VudGVyXCIpLnNvcnQoKGEsIGIpID0+IGEubWlkQ29zIC0gYi5taWRDb3MpO1xuICAgIGNvbnN0IGdldFRleHRCQm94ID0gKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIGlmIChsYWJlbCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gQkJveC56ZXJvLmNsb25lKCk7XG4gICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzICsgY2FsbG91dExpbmUubGVuZ3RoICsgb2Zmc2V0NDtcbiAgICAgIGNvbnN0IHggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgIGNvbnN0IHkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cyArIGxhYmVsLmNvbGxpc2lvbk9mZnNldFk7XG4gICAgICBjb25zdCB0ZXh0QWxpZ24gPSBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPz8gbGFiZWwudGV4dEFsaWduO1xuICAgICAgY29uc3QgdGV4dEJhc2VsaW5lID0gbGFiZWwudGV4dEJhc2VsaW5lO1xuICAgICAgcmV0dXJuIFRleHQuY29tcHV0ZUJCb3gobGFiZWwudGV4dCwgeCwgeSwge1xuICAgICAgICBmb250OiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsLFxuICAgICAgICB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBhdm9pZE5laWdoYm91cllDb2xsaXNpb24gPSAobGFiZWwsIG5leHQsIGRpcmVjdGlvbikgPT4ge1xuICAgICAgY29uc3QgYm94ID0gZ2V0VGV4dEJCb3gobGFiZWwpLmdyb3cobWluU3BhY2luZyAvIDIpO1xuICAgICAgY29uc3Qgb3RoZXIgPSBnZXRUZXh0QkJveChuZXh0KS5ncm93KG1pblNwYWNpbmcgLyAyKTtcbiAgICAgIGNvbnN0IGNvbGxpZGVzT3JCZWhpbmQgPSBib3gueCA8IG90aGVyLnggKyBvdGhlci53aWR0aCAmJiBib3gueCArIGJveC53aWR0aCA+IG90aGVyLnggJiYgKGRpcmVjdGlvbiA9PT0gXCJ0by10b3BcIiA/IGJveC55IDwgb3RoZXIueSArIG90aGVyLmhlaWdodCA6IGJveC55ICsgYm94LmhlaWdodCA+IG90aGVyLnkpO1xuICAgICAgaWYgKGNvbGxpZGVzT3JCZWhpbmQpIHtcbiAgICAgICAgbmV4dC5jYWxsb3V0TGFiZWwuY29sbGlzaW9uT2Zmc2V0WSA9IGRpcmVjdGlvbiA9PT0gXCJ0by10b3BcIiA/IGJveC55IC0gb3RoZXIueSAtIG90aGVyLmhlaWdodCA6IGJveC55ICsgYm94LmhlaWdodCAtIG90aGVyLnk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhdm9pZFlDb2xsaXNpb25zID0gKGxhYmVscykgPT4ge1xuICAgICAgY29uc3QgbWlkTGFiZWwgPSBsYWJlbHMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBNYXRoLmFicyhhLm1pZFNpbikgLSBNYXRoLmFicyhiLm1pZFNpbikpWzBdO1xuICAgICAgY29uc3QgbWlkSW5kZXggPSBsYWJlbHMuaW5kZXhPZihtaWRMYWJlbCk7XG4gICAgICBmb3IgKGxldCBpID0gbWlkSW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBwcmV2ID0gbGFiZWxzW2kgKyAxXTtcbiAgICAgICAgY29uc3QgbmV4dCA9IGxhYmVsc1tpXTtcbiAgICAgICAgYXZvaWROZWlnaGJvdXJZQ29sbGlzaW9uKHByZXYsIG5leHQsIFwidG8tdG9wXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IG1pZEluZGV4ICsgMTsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2ID0gbGFiZWxzW2kgLSAxXTtcbiAgICAgICAgY29uc3QgbmV4dCA9IGxhYmVsc1tpXTtcbiAgICAgICAgYXZvaWROZWlnaGJvdXJZQ29sbGlzaW9uKHByZXYsIG5leHQsIFwidG8tYm90dG9tXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYXZvaWRYQ29sbGlzaW9ucyA9IChsYWJlbHMpID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsc0NvbGxpZGVMYWJlbHNCeVkgPSBkYXRhLnNvbWUoKGRhdHVtKSA9PiBkYXR1bS5jYWxsb3V0TGFiZWwuY29sbGlzaW9uT2Zmc2V0WSAhPT0gMCk7XG4gICAgICBjb25zdCBib3hlcyA9IGxhYmVscy5tYXAoKGxhYmVsKSA9PiBnZXRUZXh0QkJveChsYWJlbCkpO1xuICAgICAgY29uc3QgcGFkZGVkQm94ZXMgPSBib3hlcy5tYXAoKGJveCkgPT4gYm94LmNsb25lKCkuZ3JvdyhtaW5TcGFjaW5nIC8gMikpO1xuICAgICAgbGV0IGxhYmVsc0NvbGxpZGVMYWJlbHNCeVggPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGVkQm94ZXMubGVuZ3RoICYmICFsYWJlbHNDb2xsaWRlTGFiZWxzQnlYOyBpKyspIHtcbiAgICAgICAgY29uc3QgYm94ID0gcGFkZGVkQm94ZXNbaV07XG4gICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGxhYmVscy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IG90aGVyID0gcGFkZGVkQm94ZXNbal07XG4gICAgICAgICAgaWYgKGJveC5jb2xsaWRlc0JCb3gob3RoZXIpKSB7XG4gICAgICAgICAgICBsYWJlbHNDb2xsaWRlTGFiZWxzQnlYID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc2VjdG9ycyA9IGZ1bGxEYXRhLm1hcCgoZGF0dW0pID0+IHtcbiAgICAgICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgb3V0ZXJSYWRpdXMgfSA9IGRhdHVtO1xuICAgICAgICByZXR1cm4geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGxhYmVsc0NvbGxpZGVTZWN0b3JzID0gYm94ZXMuc29tZSgoYm94KSA9PiB7XG4gICAgICAgIHJldHVybiBzZWN0b3JzLnNvbWUoKHNlY3RvcikgPT4gYm94Q29sbGlkZXNTZWN0b3IoYm94LCBzZWN0b3IpKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFsYWJlbHNDb2xsaWRlTGFiZWxzQnlYICYmICFsYWJlbHNDb2xsaWRlTGFiZWxzQnlZICYmICFsYWJlbHNDb2xsaWRlU2VjdG9ycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsYWJlbHMuZmlsdGVyKChkKSA9PiBkLmNhbGxvdXRMYWJlbC50ZXh0QWxpZ24gPT09IFwiY2VudGVyXCIpLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBkLmNhbGxvdXRMYWJlbDtcbiAgICAgICAgaWYgKGQubWlkQ29zIDwgMCkge1xuICAgICAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9IFwicmlnaHRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChkLm1pZENvcyA+IDApIHtcbiAgICAgICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGF2b2lkWUNvbGxpc2lvbnMobGVmdExhYmVscyk7XG4gICAgYXZvaWRZQ29sbGlzaW9ucyhyaWdodExhYmVscyk7XG4gICAgYXZvaWRYQ29sbGlzaW9ucyh0b3BMYWJlbHMpO1xuICAgIGF2b2lkWENvbGxpc2lvbnMoYm90dG9tTGFiZWxzKTtcbiAgfVxuICB1cGRhdGVDYWxsb3V0TGFiZWxOb2RlcyhzZXJpZXNSZWN0KSB7XG4gICAgY29uc3QgeyByYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbCwgY2FsbG91dExpbmUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBjYWxsb3V0TGVuZ3RoID0gY2FsbG91dExpbmUubGVuZ3RoO1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXQ0LCBjb2xvciB9ID0gY2FsbG91dExhYmVsO1xuICAgIGNvbnN0IHRlbXBUZXh0Tm9kZSA9IG5ldyBUZXh0KCk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24uc2VsZWN0QnlUYWcoMSAvKiBMYWJlbCAqLykuZm9yRWFjaCgodGV4dDIpID0+IHtcbiAgICAgIGNvbnN0IHsgZGF0dW0gfSA9IHRleHQyO1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICBjb25zdCByYWRpdXMgPSByYWRpdXNTY2FsZS5jb252ZXJ0KGRhdHVtLnJhZGl1cyk7XG4gICAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KDAsIHJhZGl1cyk7XG4gICAgICBpZiAoIWxhYmVsPy50ZXh0IHx8IG91dGVyUmFkaXVzID09PSAwIHx8IGxhYmVsLmhpZGRlbikge1xuICAgICAgICB0ZXh0Mi52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gb3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoICsgb2Zmc2V0NDtcbiAgICAgIGNvbnN0IHggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgIGNvbnN0IHkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cyArIGxhYmVsLmNvbGxpc2lvbk9mZnNldFk7XG4gICAgICBjb25zdCBhbGlnbjIgPSB7XG4gICAgICAgIHRleHRBbGlnbjogbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID8/IGxhYmVsLnRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiBsYWJlbC50ZXh0QmFzZWxpbmVcbiAgICAgIH07XG4gICAgICB0ZW1wVGV4dE5vZGUudGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgICB0ZW1wVGV4dE5vZGUueCA9IHg7XG4gICAgICB0ZW1wVGV4dE5vZGUueSA9IHk7XG4gICAgICB0ZW1wVGV4dE5vZGUuc2V0Rm9udCh0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsKTtcbiAgICAgIHRlbXBUZXh0Tm9kZS5zZXRBbGlnbihhbGlnbjIpO1xuICAgICAgY29uc3QgYm94ID0gdGVtcFRleHROb2RlLmdldEJCb3goKTtcbiAgICAgIGxldCBkaXNwbGF5VGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgICBsZXQgdmlzaWJsZSA9IHRydWU7XG4gICAgICBpZiAoY2FsbG91dExhYmVsLmF2b2lkQ29sbGlzaW9ucykge1xuICAgICAgICBjb25zdCB7IHRleHRMZW5ndGgsIGhhc1ZlcnRpY2FsT3ZlcmZsb3cgfSA9IHRoaXMuZ2V0TGFiZWxPdmVyZmxvdyhsYWJlbC50ZXh0LCBib3gsIHNlcmllc1JlY3QpO1xuICAgICAgICBkaXNwbGF5VGV4dCA9IGxhYmVsLnRleHQubGVuZ3RoID09PSB0ZXh0TGVuZ3RoID8gbGFiZWwudGV4dCA6IGAke2xhYmVsLnRleHQuc3Vic3RyaW5nKDAsIHRleHRMZW5ndGgpfVxcdTIwMjZgO1xuICAgICAgICB2aXNpYmxlID0gIWhhc1ZlcnRpY2FsT3ZlcmZsb3c7XG4gICAgICB9XG4gICAgICB0ZXh0Mi50ZXh0ID0gZGlzcGxheVRleHQ7XG4gICAgICB0ZXh0Mi54ID0geDtcbiAgICAgIHRleHQyLnkgPSB5O1xuICAgICAgdGV4dDIuc2V0Rm9udCh0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsKTtcbiAgICAgIHRleHQyLnNldEFsaWduKGFsaWduMik7XG4gICAgICB0ZXh0Mi5maWxsID0gY29sb3I7XG4gICAgICB0ZXh0Mi52aXNpYmxlID0gdmlzaWJsZTtcbiAgICB9KTtcbiAgfVxuICBjb21wdXRlTGFiZWxzQkJveChvcHRpb25zLCBzZXJpZXNSZWN0KSB7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWwsIGNhbGxvdXRMaW5lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2FsbG91dExlbmd0aCA9IGNhbGxvdXRMaW5lLmxlbmd0aDtcbiAgICBjb25zdCB7IG9mZnNldDogb2Zmc2V0NCwgbWF4Q29sbGlzaW9uT2Zmc2V0LCBtaW5TcGFjaW5nIH0gPSBjYWxsb3V0TGFiZWw7XG4gICAgaWYgKCFjYWxsb3V0TGFiZWwuYXZvaWRDb2xsaXNpb25zKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5tYXliZVJlZnJlc2hOb2RlRGF0YSgpO1xuICAgIHRoaXMudXBkYXRlUmFkaXVzU2NhbGUoZmFsc2UpO1xuICAgIHRoaXMuY29tcHV0ZUNhbGxvdXRMYWJlbENvbGxpc2lvbk9mZnNldHMoKTtcbiAgICBjb25zdCB0ZXh0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCB0ZXh0MiA9IG5ldyBUZXh0KCk7XG4gICAgbGV0IHRpdGxlQm94O1xuICAgIGNvbnN0IHsgdGl0bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAodGl0bGU/LnRleHQgJiYgdGl0bGUuZW5hYmxlZCkge1xuICAgICAgY29uc3QgZHkgPSB0aGlzLmdldFRpdGxlVHJhbnNsYXRpb25ZKCk7XG4gICAgICBpZiAoaXNGaW5pdGUoZHkpKSB7XG4gICAgICAgIHRleHQyLnRleHQgPSB0aXRsZS50ZXh0O1xuICAgICAgICB0ZXh0Mi54ID0gMDtcbiAgICAgICAgdGV4dDIueSA9IGR5O1xuICAgICAgICB0ZXh0Mi5zZXRGb250KHRpdGxlKTtcbiAgICAgICAgdGV4dDIuc2V0QWxpZ24oe1xuICAgICAgICAgIHRleHRCYXNlbGluZTogXCJib3R0b21cIixcbiAgICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRpdGxlQm94ID0gdGV4dDIuZ2V0QkJveCgpO1xuICAgICAgICB0ZXh0Qm94ZXMucHVzaCh0aXRsZUJveCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2FsbG91dE5vZGVEYXRhLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIGlmICghbGFiZWwgfHwgZGF0dW0ub3V0ZXJSYWRpdXMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCArIG9mZnNldDQ7XG4gICAgICBjb25zdCB4ID0gZGF0dW0ubWlkQ29zICogbGFiZWxSYWRpdXM7XG4gICAgICBjb25zdCB5ID0gZGF0dW0ubWlkU2luICogbGFiZWxSYWRpdXMgKyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZO1xuICAgICAgdGV4dDIudGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgICB0ZXh0Mi54ID0geDtcbiAgICAgIHRleHQyLnkgPSB5O1xuICAgICAgdGV4dDIuc2V0Rm9udCh0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsKTtcbiAgICAgIHRleHQyLnNldEFsaWduKHtcbiAgICAgICAgdGV4dEFsaWduOiBsYWJlbC5jb2xsaXNpb25UZXh0QWxpZ24gPz8gbGFiZWwudGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6IGxhYmVsLnRleHRCYXNlbGluZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBib3ggPSB0ZXh0Mi5nZXRCQm94KCk7XG4gICAgICBsYWJlbC5ib3ggPSBib3g7XG4gICAgICBpZiAoTWF0aC5hYnMobGFiZWwuY29sbGlzaW9uT2Zmc2V0WSkgPiBtYXhDb2xsaXNpb25PZmZzZXQpIHtcbiAgICAgICAgbGFiZWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRpdGxlQm94KSB7XG4gICAgICAgIGNvbnN0IHNlcmllc1RvcCA9IC10aGlzLmNlbnRlclk7XG4gICAgICAgIGNvbnN0IHRpdGxlQ2xlYW5BcmVhID0gbmV3IEJCb3goXG4gICAgICAgICAgdGl0bGVCb3gueCAtIG1pblNwYWNpbmcsXG4gICAgICAgICAgc2VyaWVzVG9wLFxuICAgICAgICAgIHRpdGxlQm94LndpZHRoICsgMiAqIG1pblNwYWNpbmcsXG4gICAgICAgICAgdGl0bGVCb3gueSArIHRpdGxlQm94LmhlaWdodCArIG1pblNwYWNpbmcgLSBzZXJpZXNUb3BcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGJveC5jb2xsaWRlc0JCb3godGl0bGVDbGVhbkFyZWEpKSB7XG4gICAgICAgICAgbGFiZWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmhpZGVXaGVuTmVjZXNzYXJ5KSB7XG4gICAgICAgIGNvbnN0IHsgdGV4dExlbmd0aCwgaGFzVmVydGljYWxPdmVyZmxvdywgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdyB9ID0gdGhpcy5nZXRMYWJlbE92ZXJmbG93KFxuICAgICAgICAgIGxhYmVsLnRleHQsXG4gICAgICAgICAgYm94LFxuICAgICAgICAgIHNlcmllc1JlY3RcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaXNUb29TaG9ydCA9IGxhYmVsLnRleHQubGVuZ3RoID4gMiAmJiB0ZXh0TGVuZ3RoIDwgMjtcbiAgICAgICAgaWYgKGhhc1ZlcnRpY2FsT3ZlcmZsb3cgfHwgaXNUb29TaG9ydCB8fCBoYXNTdXJyb3VuZGluZ1Nlcmllc092ZXJmbG93KSB7XG4gICAgICAgICAgbGFiZWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhYmVsLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgdGV4dEJveGVzLnB1c2goYm94KTtcbiAgICB9KTtcbiAgICBpZiAodGV4dEJveGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBCQm94Lm1lcmdlKHRleHRCb3hlcyk7XG4gIH1cbiAgdXBkYXRlU2VjdG9yTGFiZWxOb2RlcygpIHtcbiAgICBjb25zdCB7IHJhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gcmFkaXVzU2NhbGUuY29udmVydCgwKTtcbiAgICBjb25zdCB7IGZvbnRTaXplLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRGYW1pbHksIHBvc2l0aW9uT2Zmc2V0LCBwb3NpdGlvblJhdGlvLCBjb2xvciB9ID0gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsO1xuICAgIGNvbnN0IGlzRG9udXQgPSBpbm5lclJhZGl1cyA+IDA7XG4gICAgY29uc3Qgc2luZ2xlVmlzaWJsZVNlY3RvciA9IHRoaXMuY3R4LmxlZ2VuZE1hbmFnZXIuZ2V0RGF0YSh0aGlzLmlkKT8uZmlsdGVyKChkKSA9PiBkLmVuYWJsZWQpLmxlbmd0aCA9PT0gMTtcbiAgICBjb25zdCB1cGRhdGVTZWN0b3JMYWJlbCA9ICh0ZXh0MiwgZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IHsgc2VjdG9yTGFiZWwsIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSB9ID0gZGF0dW07XG4gICAgICBsZXQgaXNUZXh0VmlzaWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKHNlY3RvckxhYmVsICYmIG91dGVyUmFkaXVzICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gaW5uZXJSYWRpdXMgKiAoMSAtIHBvc2l0aW9uUmF0aW8pICsgb3V0ZXJSYWRpdXMgKiBwb3NpdGlvblJhdGlvICsgcG9zaXRpb25PZmZzZXQ7XG4gICAgICAgIHRleHQyLmZpbGwgPSBjb2xvcjtcbiAgICAgICAgdGV4dDIuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgICB0ZXh0Mi5mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcbiAgICAgICAgdGV4dDIuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgdGV4dDIuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICAgIHRleHQyLnRleHQgPSBzZWN0b3JMYWJlbC50ZXh0O1xuICAgICAgICBjb25zdCBzaG91bGRQdXRUZXh0SW5DZW50ZXIgPSAhaXNEb251dCAmJiBzaW5nbGVWaXNpYmxlU2VjdG9yO1xuICAgICAgICBpZiAoc2hvdWxkUHV0VGV4dEluQ2VudGVyKSB7XG4gICAgICAgICAgdGV4dDIueCA9IDA7XG4gICAgICAgICAgdGV4dDIueSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dDIueCA9IGRhdHVtLm1pZENvcyAqIGxhYmVsUmFkaXVzO1xuICAgICAgICAgIHRleHQyLnkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cztcbiAgICAgICAgfVxuICAgICAgICB0ZXh0Mi50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB0ZXh0Mi50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgICBjb25zdCBiYm94ID0gdGV4dDIuZ2V0QkJveCgpO1xuICAgICAgICBjb25zdCBjb3JuZXJzID0gW1xuICAgICAgICAgIFtiYm94LngsIGJib3gueV0sXG4gICAgICAgICAgW2Jib3gueCArIGJib3gud2lkdGgsIGJib3gueV0sXG4gICAgICAgICAgW2Jib3gueCArIGJib3gud2lkdGgsIGJib3gueSArIGJib3guaGVpZ2h0XSxcbiAgICAgICAgICBbYmJveC54LCBiYm94LnkgKyBiYm94LmhlaWdodF1cbiAgICAgICAgXTtcbiAgICAgICAgY29uc3Qgc2VjdG9yQm91bmRzID0geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH07XG4gICAgICAgIGlmIChjb3JuZXJzLmV2ZXJ5KChbeCwgeV0pID0+IGlzUG9pbnRJblNlY3Rvcih4LCB5LCBzZWN0b3JCb3VuZHMpKSkge1xuICAgICAgICAgIGlzVGV4dFZpc2libGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZXh0Mi52aXNpYmxlID0gaXNUZXh0VmlzaWJsZTtcbiAgICB9O1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24uZWFjaCh1cGRhdGVTZWN0b3JMYWJlbCk7XG4gICAgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbi5lYWNoKHVwZGF0ZVNlY3RvckxhYmVsKTtcbiAgfVxuICB1cGRhdGVaZXJvc3VtUmluZ3MoKSB7XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nLnNpemUgPSB0aGlzLmdldE91dGVyUmFkaXVzKCkgKiAyO1xuICB9XG4gIHBpY2tOb2RlQ2xvc2VzdERhdHVtKHBvaW50KSB7XG4gICAgcmV0dXJuIHBpY2tCeU1hdGNoaW5nQW5nbGUodGhpcywgcG9pbnQpO1xuICB9XG4gIGdldFRvb2x0aXBDb250ZW50KG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHsgaWQ6IHNlcmllc0lkLCBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEsIHByb3BlcnRpZXMgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgbGVnZW5kSXRlbUtleSxcbiAgICAgIGNhbGxvdXRMYWJlbEtleSxcbiAgICAgIGNhbGxvdXRMYWJlbE5hbWUsXG4gICAgICBzZWN0b3JMYWJlbEtleSxcbiAgICAgIHNlY3RvckxhYmVsTmFtZSxcbiAgICAgIGFuZ2xlS2V5LFxuICAgICAgYW5nbGVOYW1lLFxuICAgICAgcmFkaXVzS2V5LFxuICAgICAgcmFkaXVzTmFtZSxcbiAgICAgIHRvb2x0aXBcbiAgICB9ID0gcHJvcGVydGllcztcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMucHJvcGVydGllcy50aXRsZS50ZXh0O1xuICAgIGlmICghZGF0YU1vZGVsIHx8ICFwcm9jZXNzZWREYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgZGF0dW1JbmRleCB9ID0gbm9kZURhdHVtO1xuICAgIGNvbnN0IGRhdHVtID0gcHJvY2Vzc2VkRGF0YS5kYXRhU291cmNlcy5nZXQodGhpcy5pZCk/LltkYXR1bUluZGV4XTtcbiAgICBjb25zdCB7IGFuZ2xlUmF3VmFsdWVzLCBsZWdlbmRJdGVtVmFsdWVzLCBjYWxsb3V0TGFiZWxWYWx1ZXMsIHNlY3RvckxhYmVsVmFsdWVzIH0gPSB0aGlzLmdldFByb2Nlc3NlZERhdGFWYWx1ZXMoXG4gICAgICBkYXRhTW9kZWwsXG4gICAgICBwcm9jZXNzZWREYXRhXG4gICAgKTtcbiAgICBjb25zdCBhbmdsZVJhd1ZhbHVlID0gYW5nbGVSYXdWYWx1ZXNbZGF0dW1JbmRleF07XG4gICAgY29uc3QgbGFiZWwgPSBsZWdlbmRJdGVtVmFsdWVzPy5bZGF0dW1JbmRleF0gPz8gKGNhbGxvdXRMYWJlbEtleSA9PT0gYW5nbGVLZXkgPyB2b2lkIDAgOiBjYWxsb3V0TGFiZWxWYWx1ZXM/LltkYXR1bUluZGV4XSkgPz8gKHNlY3RvckxhYmVsS2V5ID09PSBhbmdsZUtleSA/IHZvaWQgMCA6IHNlY3RvckxhYmVsVmFsdWVzPy5bZGF0dW1JbmRleF0pID8/IGFuZ2xlTmFtZTtcbiAgICByZXR1cm4gdG9vbHRpcC5mb3JtYXRUb29sdGlwKFxuICAgICAge1xuICAgICAgICB0aXRsZSxcbiAgICAgICAgc3ltYm9sOiB0aGlzLmxlZ2VuZEl0ZW1TeW1ib2woZGF0dW1JbmRleCksXG4gICAgICAgIGRhdGE6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgIGZhbGxiYWNrTGFiZWw6IGFuZ2xlS2V5LFxuICAgICAgICAgICAgdmFsdWU6IGZvcm1hdFZhbHVlKGFuZ2xlUmF3VmFsdWUsIDMpXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHRpdGxlOiBhbmdsZU5hbWUsXG4gICAgICAgIGxlZ2VuZEl0ZW1LZXksXG4gICAgICAgIGNhbGxvdXRMYWJlbEtleSxcbiAgICAgICAgY2FsbG91dExhYmVsTmFtZSxcbiAgICAgICAgc2VjdG9yTGFiZWxLZXksXG4gICAgICAgIHNlY3RvckxhYmVsTmFtZSxcbiAgICAgICAgYW5nbGVLZXksXG4gICAgICAgIGFuZ2xlTmFtZSxcbiAgICAgICAgcmFkaXVzS2V5LFxuICAgICAgICByYWRpdXNOYW1lLFxuICAgICAgICAuLi50aGlzLmdldFNlY3RvckZvcm1hdChkYXR1bSwgZGF0dW1JbmRleCwgZmFsc2UpXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBsZWdlbmRJdGVtU3ltYm9sKGRhdHVtSW5kZXgpIHtcbiAgICBjb25zdCBkYXR1bSA9IHRoaXMucHJvY2Vzc2VkRGF0YT8uZGF0YVNvdXJjZXMuZ2V0KHRoaXMuaWQpPy5bZGF0dW1JbmRleF07XG4gICAgY29uc3Qgc2VjdG9yRm9ybWF0ID0gdGhpcy5nZXRTZWN0b3JGb3JtYXQoZGF0dW0sIGRhdHVtSW5kZXgsIGZhbHNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWFya2VyOiB7XG4gICAgICAgIGZpbGw6IHNlY3RvckZvcm1hdC5maWxsLFxuICAgICAgICBzdHJva2U6IHNlY3RvckZvcm1hdC5zdHJva2UsXG4gICAgICAgIGZpbGxPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuZmlsbE9wYWNpdHksXG4gICAgICAgIHN0cm9rZU9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5zdHJva2VPcGFjaXR5LFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoLFxuICAgICAgICBsaW5lRGFzaDogdGhpcy5wcm9wZXJ0aWVzLmxpbmVEYXNoLFxuICAgICAgICBsaW5lRGFzaE9mZnNldDogdGhpcy5wcm9wZXJ0aWVzLmxpbmVEYXNoT2Zmc2V0XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZDogc2VyaWVzSWQsXG4gICAgICB2aXNpYmxlLFxuICAgICAgcHJvY2Vzc2VkRGF0YSxcbiAgICAgIGRhdGFNb2RlbCxcbiAgICAgIGN0eDogeyBsZWdlbmRNYW5hZ2VyIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWRhdGFNb2RlbCB8fCAhcHJvY2Vzc2VkRGF0YSB8fCBsZWdlbmRUeXBlICE9PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgeyBhbmdsZUtleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSwgc2hvd0luTGVnZW5kIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKCFsZWdlbmRJdGVtS2V5ICYmICghY2FsbG91dExhYmVsS2V5IHx8IGNhbGxvdXRMYWJlbEtleSA9PT0gYW5nbGVLZXkpICYmICghc2VjdG9yTGFiZWxLZXkgfHwgc2VjdG9yTGFiZWxLZXkgPT09IGFuZ2xlS2V5KSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbFZhbHVlcywgc2VjdG9yTGFiZWxWYWx1ZXMsIGxlZ2VuZEl0ZW1WYWx1ZXMsIGFuZ2xlUmF3VmFsdWVzIH0gPSB0aGlzLmdldFByb2Nlc3NlZERhdGFWYWx1ZXMoXG4gICAgICBkYXRhTW9kZWwsXG4gICAgICBwcm9jZXNzZWREYXRhXG4gICAgKTtcbiAgICBjb25zdCB0aXRsZVRleHQgPSB0aGlzLnByb3BlcnRpZXMudGl0bGU/LnNob3dJbkxlZ2VuZCAmJiB0aGlzLnByb3BlcnRpZXMudGl0bGUudGV4dDtcbiAgICBjb25zdCBsZWdlbmREYXRhID0gW107XG4gICAgY29uc3QgaGlkZVplcm9zID0gdGhpcy5wcm9wZXJ0aWVzLmhpZGVaZXJvVmFsdWVTZWN0b3JzSW5MZWdlbmQ7XG4gICAgY29uc3QgcmF3RGF0YSA9IHByb2Nlc3NlZERhdGEuZGF0YVNvdXJjZXMuZ2V0KHRoaXMuaWQpO1xuICAgIGNvbnN0IGludmFsaWREYXRhID0gcHJvY2Vzc2VkRGF0YS5pbnZhbGlkRGF0YT8uZ2V0KHRoaXMuaWQpO1xuICAgIGZvciAobGV0IGRhdHVtSW5kZXggPSAwOyBkYXR1bUluZGV4IDwgcHJvY2Vzc2VkRGF0YS5pbnB1dC5jb3VudDsgZGF0dW1JbmRleCsrKSB7XG4gICAgICBjb25zdCBkYXR1bSA9IHJhd0RhdGE/LltkYXR1bUluZGV4XTtcbiAgICAgIGNvbnN0IGFuZ2xlUmF3VmFsdWUgPSBhbmdsZVJhd1ZhbHVlc1tkYXR1bUluZGV4XTtcbiAgICAgIGlmIChpbnZhbGlkRGF0YT8uW2RhdHVtSW5kZXhdID09PSB0cnVlIHx8IGhpZGVaZXJvcyAmJiBhbmdsZVJhd1ZhbHVlID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxQYXJ0cyA9IFtdO1xuICAgICAgaWYgKHRpdGxlVGV4dCkge1xuICAgICAgICBsYWJlbFBhcnRzLnB1c2godGl0bGVUZXh0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgMiAqIE1hdGguUEksXG4gICAgICAgIDIgKiBNYXRoLlBJLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgY2FsbG91dExhYmVsVmFsdWVzPy5bZGF0dW1JbmRleF0sXG4gICAgICAgIHNlY3RvckxhYmVsVmFsdWVzPy5bZGF0dW1JbmRleF0sXG4gICAgICAgIGxlZ2VuZEl0ZW1WYWx1ZXM/LltkYXR1bUluZGV4XVxuICAgICAgKTtcbiAgICAgIGlmIChsZWdlbmRJdGVtS2V5ICYmIGxhYmVscy5sZWdlbmRJdGVtICE9PSB2b2lkIDApIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKGxhYmVscy5sZWdlbmRJdGVtLnRleHQpO1xuICAgICAgfSBlbHNlIGlmIChjYWxsb3V0TGFiZWxLZXkgJiYgY2FsbG91dExhYmVsS2V5ICE9PSBhbmdsZUtleSAmJiBsYWJlbHMuY2FsbG91dExhYmVsPy50ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKGxhYmVscy5jYWxsb3V0TGFiZWw/LnRleHQpO1xuICAgICAgfSBlbHNlIGlmIChzZWN0b3JMYWJlbEtleSAmJiBzZWN0b3JMYWJlbEtleSAhPT0gYW5nbGVLZXkgJiYgbGFiZWxzLnNlY3RvckxhYmVsPy50ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgbGFiZWxQYXJ0cy5wdXNoKGxhYmVscy5zZWN0b3JMYWJlbD8udGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAobGFiZWxQYXJ0cy5sZW5ndGggPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgbGVnZW5kRGF0YS5wdXNoKHtcbiAgICAgICAgbGVnZW5kVHlwZTogXCJjYXRlZ29yeVwiLFxuICAgICAgICBpZDogc2VyaWVzSWQsXG4gICAgICAgIGRhdHVtLFxuICAgICAgICBpdGVtSWQ6IGRhdHVtSW5kZXgsXG4gICAgICAgIHNlcmllc0lkLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlICYmIGxlZ2VuZE1hbmFnZXIuZ2V0SXRlbUVuYWJsZWQoeyBzZXJpZXNJZCwgaXRlbUlkOiBkYXR1bUluZGV4IH0pLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IGxhYmVsUGFydHMuam9pbihcIiAtIFwiKVxuICAgICAgICB9LFxuICAgICAgICBzeW1ib2w6IHRoaXMubGVnZW5kSXRlbVN5bWJvbChkYXR1bUluZGV4KSxcbiAgICAgICAgbGVnZW5kSXRlbU5hbWU6IGxlZ2VuZEl0ZW1LZXkgIT0gbnVsbCA/IGRhdHVtW2xlZ2VuZEl0ZW1LZXldIDogdm9pZCAwLFxuICAgICAgICBoaWRlSW5MZWdlbmQ6ICFzaG93SW5MZWdlbmRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kRGF0YTtcbiAgfVxuICAvLyBVc2VkIGZvciBncmlkXG4gIHNldExlZ2VuZFN0YXRlKGVuYWJsZWRJdGVtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgIGN0eDogeyBsZWdlbmRNYW5hZ2VyLCB1cGRhdGVTZXJ2aWNlIH1cbiAgICB9ID0gdGhpcztcbiAgICBlbmFibGVkSXRlbXMuZm9yRWFjaCgoZW5hYmxlZCwgaXRlbUlkKSA9PiBsZWdlbmRNYW5hZ2VyLnRvZ2dsZUl0ZW0oeyBlbmFibGVkLCBzZXJpZXNJZCwgaXRlbUlkIH0pKTtcbiAgICBsZWdlbmRNYW5hZ2VyLnVwZGF0ZSgpO1xuICAgIHVwZGF0ZVNlcnZpY2UudXBkYXRlKDQgLyogU0VSSUVTX1VQREFURSAqLyk7XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoX2RhdGEpIHtcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoXG4gICAgICB0cnVlLFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzLnJvdGF0aW9uLFxuICAgICAgdGhpcy5yYWRpdXNTY2FsZSxcbiAgICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbdGhpcy5pdGVtU2VsZWN0aW9uLCB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbiwgdGhpcy5waGFudG9tU2VsZWN0aW9uXSxcbiAgICAgIGZucy5ub2RlcyxcbiAgICAgIChfLCBkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtLmRhdHVtLCBkYXR1bS5kYXR1bUluZGV4KVxuICAgICk7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJjYWxsb3V0XCIsIGFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcInNlY3RvclwiLCBhbmltYXRpb25NYW5hZ2VyLCB0aGlzLmxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImhpZ2hsaWdodFwiLCBhbmltYXRpb25NYW5hZ2VyLCB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uKTtcbiAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoKSB7XG4gICAgY29uc3QgeyBpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb24sIHByb2Nlc3NlZERhdGEsIHJhZGl1c1NjYWxlLCBwcmV2aW91c1JhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZGF0YURpZmYgPSBwcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5kaWZmPy5bdGhpcy5pZF07XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xuICAgIGNvbnN0IHN1cHBvcnRlZERpZmYgPSAoZGF0YURpZmY/Lm1vdmVkLnNpemUgPz8gMCkgPT09IDA7XG4gICAgY29uc3QgaGFzS2V5cyA9IChwcm9jZXNzZWREYXRhPy5kZWZzLmtleXMubGVuZ3RoID8/IDApID4gMDtcbiAgICBjb25zdCBoYXNVbmlxdWVLZXlzID0gcHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uYW5pbWF0aW9uVmFsaWRhdGlvbj8udW5pcXVlS2V5cyA/PyB0cnVlO1xuICAgIGlmICghc3VwcG9ydGVkRGlmZiB8fCAhaGFzS2V5cyB8fCAhaGFzVW5pcXVlS2V5cykge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgfVxuICAgIGNvbnN0IGZucyA9IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoXG4gICAgICBmYWxzZSxcbiAgICAgIHRoaXMucHJvcGVydGllcy5yb3RhdGlvbixcbiAgICAgIHJhZGl1c1NjYWxlLFxuICAgICAgcHJldmlvdXNSYWRpdXNTY2FsZVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwaGFudG9tU2VsZWN0aW9uXSxcbiAgICAgIGZucy5ub2RlcyxcbiAgICAgIChfLCBkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtLmRhdHVtLCBkYXR1bS5kYXR1bUluZGV4KSxcbiAgICAgIGRhdGFEaWZmXG4gICAgKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImNhbGxvdXRcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwic2VjdG9yXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMubGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiaGlnaGxpZ2h0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XG4gIH1cbiAgYW5pbWF0ZUNsZWFyaW5nVXBkYXRlRW1wdHkoKSB7XG4gICAgY29uc3QgeyBpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb24sIHJhZGl1c1NjYWxlLCBwcmV2aW91c1JhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyhcbiAgICAgIGZhbHNlLFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzLnJvdGF0aW9uLFxuICAgICAgcmFkaXVzU2NhbGUsXG4gICAgICBwcmV2aW91c1JhZGl1c1NjYWxlXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJub2Rlc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFtpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb25dLFxuICAgICAgZm5zLm5vZGVzLFxuICAgICAgKF8sIGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0uZGF0dW0sIGRhdHVtLmRhdHVtSW5kZXgpXG4gICAgKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24odGhpcywgXCJjYWxsb3V0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24odGhpcywgXCJzZWN0b3JcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5sYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uKHRoaXMsIFwiaGlnaGxpZ2h0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XG4gIH1cbiAgZ2V0RGF0dW1JZChkYXR1bSwgZGF0dW1JbmRleCkge1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmICghdGhpcy5wcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5hbmltYXRpb25WYWxpZGF0aW9uPy51bmlxdWVLZXlzKSB7XG4gICAgICByZXR1cm4gYCR7ZGF0dW1JbmRleH1gO1xuICAgIH1cbiAgICBpZiAobGVnZW5kSXRlbUtleSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZURhdHVtSWQoZGF0dW1bbGVnZW5kSXRlbUtleV0pO1xuICAgIH0gZWxzZSBpZiAoY2FsbG91dExhYmVsS2V5KSB7XG4gICAgICByZXR1cm4gY3JlYXRlRGF0dW1JZChkYXR1bVtjYWxsb3V0TGFiZWxLZXldKTtcbiAgICB9IGVsc2UgaWYgKHNlY3RvckxhYmVsS2V5KSB7XG4gICAgICByZXR1cm4gY3JlYXRlRGF0dW1JZChkYXR1bVtzZWN0b3JMYWJlbEtleV0pO1xuICAgIH1cbiAgICByZXR1cm4gYCR7ZGF0dW1JbmRleH1gO1xuICB9XG59O1xuUGllU2VyaWVzLmNsYXNzTmFtZSA9IFwiUGllU2VyaWVzXCI7XG5QaWVTZXJpZXMudHlwZSA9IFwicGllXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9wb2xhci9waWVTZXJpZXNNb2R1bGUudHNcbnZhciBQaWVTZXJpZXNNb2R1bGUgPSB7XG4gIHR5cGU6IFwic2VyaWVzXCIsXG4gIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLFxuICBpZGVudGlmaWVyOiBcInBpZVwiLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgUGllU2VyaWVzKGN0eCksXG4gIHRvb2x0aXBEZWZhdWx0czogeyByYW5nZTogXCJleGFjdFwiIH0sXG4gIHRoZW1lVGVtcGxhdGU6IHBpZVRoZW1lLFxuICBwYWxldHRlRmFjdG9yeTogcGllUGFsZXR0ZUZhY3Rvcnlcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ZhY3RvcnkvcmVnaXN0ZXJJbmJ1aWx0TW9kdWxlcy50c1xuZnVuY3Rpb24gcmVnaXN0ZXJJbmJ1aWx0TW9kdWxlcygpIHtcbiAgbW9kdWxlUmVnaXN0cnkucmVnaXN0ZXIoXG4gICAgQmFja2dyb3VuZE1vZHVsZSxcbiAgICBDb21tdW5pdHlMZWdlbmRNb2R1bGUsXG4gICAgTG9jYWxlTW9kdWxlLFxuICAgIEFyZWFTZXJpZXNNb2R1bGUsXG4gICAgQmFyU2VyaWVzTW9kdWxlLFxuICAgIEJ1YmJsZVNlcmllc01vZHVsZSxcbiAgICBMaW5lU2VyaWVzTW9kdWxlLFxuICAgIFNjYXR0ZXJTZXJpZXNNb2R1bGUsXG4gICAgRG9udXRTZXJpZXNNb2R1bGUsXG4gICAgUGllU2VyaWVzTW9kdWxlLFxuICAgIEhpc3RvZ3JhbVNlcmllc01vZHVsZVxuICApO1xuICBmb3IgKGNvbnN0IEF4aXNDb25zdHJ1Y3RvciBvZiBbTnVtYmVyQXhpcywgQ2F0ZWdvcnlBeGlzLCBUaW1lQXhpcywgR3JvdXBlZENhdGVnb3J5QXhpcywgTG9nQXhpc10pIHtcbiAgICBheGlzUmVnaXN0cnkucmVnaXN0ZXIoQXhpc0NvbnN0cnVjdG9yLnR5cGUsIHtcbiAgICAgIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBBeGlzQ29uc3RydWN0b3IoY3R4KVxuICAgIH0pO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ZhY3Rvcnkvc2V0dXBNb2R1bGVzLnRzXG5mdW5jdGlvbiBzZXR1cE1vZHVsZXMoKSB7XG4gIGZvciAoY29uc3QgbSBvZiBtb2R1bGVSZWdpc3RyeS5tb2R1bGVzKSB7XG4gICAgaWYgKG0ucGFja2FnZVR5cGUgPT09IFwiZW50ZXJwcmlzZVwiICYmICF2ZXJpZnlJZk1vZHVsZUV4cGVjdGVkKG0pKSB7XG4gICAgICBsb2dnZXJfZXhwb3J0cy5lcnJvck9uY2UoXCJVbmV4cGVjdGVkIGVudGVycHJpc2UgbW9kdWxlIHJlZ2lzdGVyZWQ6IFwiICsgbS5pZGVudGlmaWVyKTtcbiAgICB9XG4gICAgaWYgKG0udHlwZSA9PT0gXCJyb290XCIgJiYgbS50aGVtZVRlbXBsYXRlKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoYXJ0VHlwZSBvZiBtLmNoYXJ0VHlwZXMpIHtcbiAgICAgICAgY2hhcnREZWZhdWx0cy5zZXQoY2hhcnRUeXBlLCBtLnRoZW1lVGVtcGxhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobS50eXBlID09PSBcInNlcmllc1wiKSB7XG4gICAgICBpZiAobS5jaGFydFR5cGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBNb2R1bGUgZGVmaW5pdGlvbiBlcnJvcjogJHttLmlkZW50aWZpZXJ9YCk7XG4gICAgICB9XG4gICAgICBzZXJpZXNSZWdpc3RyeS5yZWdpc3RlcihtLmlkZW50aWZpZXIsIG0pO1xuICAgIH1cbiAgICBpZiAobS50eXBlID09PSBcInNlcmllcy1vcHRpb25cIiAmJiBtLnRoZW1lVGVtcGxhdGUpIHtcbiAgICAgIGZvciAoY29uc3Qgc2VyaWVzVHlwZSBvZiBtLnNlcmllc1R5cGVzKSB7XG4gICAgICAgIHNlcmllc1JlZ2lzdHJ5LnNldFRoZW1lVGVtcGxhdGUoc2VyaWVzVHlwZSwgbS50aGVtZVRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG0udHlwZSA9PT0gXCJheGlzLW9wdGlvblwiICYmIG0udGhlbWVUZW1wbGF0ZSkge1xuICAgICAgZm9yIChjb25zdCBheGlzVHlwZSBvZiBtLmF4aXNUeXBlcykge1xuICAgICAgICBjb25zdCBheGlzVHlwZVRoZW1lID0gYXhpc1JlZ2lzdHJ5LmdldFRoZW1lVGVtcGxhdGUoYXhpc1R5cGUpO1xuICAgICAgICBjb25zdCB0aGVtZSA9IG1lcmdlRGVmYXVsdHMobS50aGVtZVRlbXBsYXRlLCBheGlzVHlwZVRoZW1lKTtcbiAgICAgICAgYXhpc1JlZ2lzdHJ5LnNldFRoZW1lVGVtcGxhdGUoYXhpc1R5cGUsIHRoZW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG0udHlwZSA9PT0gXCJheGlzXCIpIHtcbiAgICAgIGF4aXNSZWdpc3RyeS5yZWdpc3RlcihtLmlkZW50aWZpZXIsIG0pO1xuICAgIH1cbiAgICBpZiAobS50eXBlID09PSBcImxlZ2VuZFwiKSB7XG4gICAgICBsZWdlbmRSZWdpc3RyeS5yZWdpc3RlcihtLmlkZW50aWZpZXIsIG0pO1xuICAgIH1cbiAgfVxuICBpZiAobW9kdWxlUmVnaXN0cnkuaGFzRW50ZXJwcmlzZU1vZHVsZXMoKSkge1xuICAgIGNvbnN0IGV4cGVjdGVkQnV0VW51c2VkID0gZ2V0VW51c2VkRXhwZWN0ZWRNb2R1bGVzKCk7XG4gICAgaWYgKGV4cGVjdGVkQnV0VW51c2VkLmxlbmd0aCA+IDApIHtcbiAgICAgIGxvZ2dlcl9leHBvcnRzLmVycm9yT25jZShcIkVudGVycHJpc2UgbW9kdWxlcyBleHBlY3RlZCBidXQgbm90IHJlZ2lzdGVyZWQ6IFwiLCBleHBlY3RlZEJ1dFVudXNlZCk7XG4gICAgfVxuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvcG9sYXJBeGlzLnRzXG52YXIgUG9sYXJBeGlzID0gY2xhc3MgZXh0ZW5kcyBBeGlzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnNoYXBlID0gXCJwb2x5Z29uXCI7XG4gICAgdGhpcy5pbm5lclJhZGl1c1JhdGlvID0gMDtcbiAgICB0aGlzLmRlZmF1bHRUaWNrTWluU3BhY2luZyA9IDIwO1xuICB9XG4gIHVwZGF0ZVBvc2l0aW9uKCkge1xuICAgIHN1cGVyLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uQ3R4ID0gcHJlcGFyZUF4aXNBbmltYXRpb25Db250ZXh0KHRoaXMpO1xuICAgIGNvbnN0IHJlc2V0QXhpc0ZuID0gcmVzZXRBeGlzU2VsZWN0aW9uRm4oc2VsZWN0aW9uQ3R4KTtcbiAgICB0aGlzLmF4aXNHcm91cC5zZXRQcm9wZXJ0aWVzKHRoaXMuZ2V0QXhpc1RyYW5zZm9ybSgpKTtcbiAgICB0aGlzLmdyaWRMaW5lR3JvdXBTZWxlY3Rpb24uZWFjaChyZXNldEF4aXNGbik7XG4gICAgdGhpcy50aWNrTGluZUdyb3VwU2VsZWN0aW9uLmVhY2gocmVzZXRBeGlzRm4pO1xuICAgIHRoaXMudGlja0xhYmVsR3JvdXBTZWxlY3Rpb24uZWFjaChyZXNldEF4aXNMYWJlbFNlbGVjdGlvbkZuKCkpO1xuICB9XG4gIGNvbXB1dGVMYWJlbHNCQm94KF9vcHRpb25zLCBfc2VyaWVzUmVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbXB1dGVSYW5nZSgpIHtcbiAgfVxuICBnZXRBeGlzTGluZVBvaW50cygpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVU5JT04oW1wicG9seWdvblwiLCBcImNpcmNsZVwiXSwgXCJhIHBvbGFyIGF4aXMgc2hhcGVcIikpXG5dLCBQb2xhckF4aXMucHJvdG90eXBlLCBcInNoYXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBQb2xhckF4aXMucHJvdG90eXBlLCBcImlubmVyUmFkaXVzUmF0aW9cIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3BvbGFyQ2hhcnQudHNcbnZhciBQb2xhckNoYXJ0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHJlc291cmNlcykge1xuICAgIHN1cGVyKG9wdGlvbnMsIHJlc291cmNlcyk7XG4gICAgdGhpcy5wYWRkaW5nID0gbmV3IFBhZGRpbmcoNDApO1xuICAgIHRoaXMuY3R4LmF4aXNNYW5hZ2VyLmF4aXNHcm91cC56SW5kZXggPSA2IC8qIEFYSVNfRk9SRUdST1VORCAqLztcbiAgfVxuICBnZXRDaGFydFR5cGUoKSB7XG4gICAgcmV0dXJuIFwicG9sYXJcIjtcbiAgfVxuICBhc3luYyBwZXJmb3JtTGF5b3V0KGN0eCkge1xuICAgIGNvbnN0IHsgbGF5b3V0Qm94IH0gPSBjdHg7XG4gICAgbGF5b3V0Qm94LnNocmluayh0aGlzLnNlcmllc0FyZWEucGFkZGluZy50b0pzb24oKSk7XG4gICAgY29uc3Qgc2VyaWVzUmVjdCA9IGxheW91dEJveC5jbG9uZSgpO1xuICAgIHRoaXMuc2VyaWVzUmVjdCA9IHNlcmllc1JlY3Q7XG4gICAgdGhpcy5hbmltYXRpb25SZWN0ID0gc2VyaWVzUmVjdDtcbiAgICB0aGlzLnNlcmllc1Jvb3QudHJhbnNsYXRpb25YID0gc2VyaWVzUmVjdC54O1xuICAgIHRoaXMuc2VyaWVzUm9vdC50cmFuc2xhdGlvblkgPSBzZXJpZXNSZWN0Lnk7XG4gICAgYXdhaXQgdGhpcy5jb21wdXRlQ2lyY2xlKHNlcmllc1JlY3QpO1xuICAgIHRoaXMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiBheGlzLnVwZGF0ZSgpKTtcbiAgICB0aGlzLmN0eC5sYXlvdXRNYW5hZ2VyLmVtaXRMYXlvdXRDb21wbGV0ZShjdHgsIHtcbiAgICAgIHNlcmllczogeyB2aXNpYmxlOiB0cnVlLCByZWN0OiBzZXJpZXNSZWN0LCBwYWRkZWRSZWN0OiBzZXJpZXNSZWN0IH1cbiAgICB9KTtcbiAgfVxuICB1cGRhdGVBeGVzKHNlcmllc0JveCwgY3gsIGN5LCByYWRpdXMpIHtcbiAgICBjb25zdCBhbmdsZUF4aXMgPSB0aGlzLmF4ZXMuZmluZCgoYXhpcykgPT4gYXhpcy5kaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8pO1xuICAgIGNvbnN0IHJhZGl1c0F4aXMgPSB0aGlzLmF4ZXMuZmluZCgoYXhpcykgPT4gYXhpcy5kaXJlY3Rpb24gPT09IFwieVwiIC8qIFkgKi8pO1xuICAgIGlmICghKGFuZ2xlQXhpcyBpbnN0YW5jZW9mIFBvbGFyQXhpcykgfHwgIShyYWRpdXNBeGlzIGluc3RhbmNlb2YgUG9sYXJBeGlzKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhbmdsZVNjYWxlID0gYW5nbGVBeGlzLnNjYWxlO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzUmF0aW8gPSByYWRpdXNBeGlzLmlubmVyUmFkaXVzUmF0aW87XG4gICAgYW5nbGVBeGlzLmlubmVyUmFkaXVzUmF0aW8gPSBpbm5lclJhZGl1c1JhdGlvO1xuICAgIGFuZ2xlQXhpcy5jb21wdXRlUmFuZ2UoKTtcbiAgICBhbmdsZUF4aXMuZ3JpZExlbmd0aCA9IHJhZGl1cztcbiAgICByYWRpdXNBeGlzLmdyaWRBbmdsZXMgPSBhbmdsZVNjYWxlLnRpY2tzKHtcbiAgICAgIG5pY2U6IGFuZ2xlQXhpcy5uaWNlLFxuICAgICAgaW50ZXJ2YWw6IHZvaWQgMCxcbiAgICAgIHRpY2tDb3VudDogdm9pZCAwLFxuICAgICAgbWluVGlja0NvdW50OiAwLFxuICAgICAgbWF4VGlja0NvdW50OiBJbmZpbml0eVxuICAgIH0pPy5tYXAoKHZhbHVlKSA9PiBhbmdsZVNjYWxlLmNvbnZlcnQodmFsdWUpKTtcbiAgICByYWRpdXNBeGlzLmdyaWRSYW5nZSA9IGFuZ2xlQXhpcy5yYW5nZTtcbiAgICByYWRpdXNBeGlzLnJhbmdlID0gW3JhZGl1cywgcmFkaXVzICogaW5uZXJSYWRpdXNSYXRpb107XG4gICAgW2FuZ2xlQXhpcywgcmFkaXVzQXhpc10uZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgICAgYXhpcy50cmFuc2xhdGlvbi54ID0gc2VyaWVzQm94LnggKyBjeDtcbiAgICAgIGF4aXMudHJhbnNsYXRpb24ueSA9IHNlcmllc0JveC55ICsgY3k7XG4gICAgICBheGlzLmNhbGN1bGF0ZUxheW91dCgpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNvbXB1dGVDaXJjbGUoc2VyaWVzQm94KSB7XG4gICAgY29uc3QgcG9sYXJTZXJpZXMgPSB0aGlzLnNlcmllcy5maWx0ZXIoaXNQb2xhclNlcmllcyk7XG4gICAgY29uc3QgcG9sYXJBeGVzID0gdGhpcy5heGVzLmZpbHRlcihpc1BvbGFyQXhpcyk7XG4gICAgY29uc3Qgc2V0U2VyaWVzQ2lyY2xlID0gKGN4LCBjeSwgcikgPT4ge1xuICAgICAgdGhpcy51cGRhdGVBeGVzKHNlcmllc0JveCwgY3gsIGN5LCByKTtcbiAgICAgIHBvbGFyU2VyaWVzLmZvckVhY2goKHNlcmllcykgPT4ge1xuICAgICAgICBzZXJpZXMuY2VudGVyWCA9IGN4O1xuICAgICAgICBzZXJpZXMuY2VudGVyWSA9IGN5O1xuICAgICAgICBzZXJpZXMucmFkaXVzID0gcjtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGllU2VyaWVzID0gcG9sYXJTZXJpZXMuZmlsdGVyKChzKSA9PiBzLnR5cGUgPT09IFwiZG9udXRcIiB8fCBzLnR5cGUgPT09IFwicGllXCIpO1xuICAgICAgaWYgKHBpZVNlcmllcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IGlubmVyUmFkaWkgPSBwaWVTZXJpZXMubWFwKChzZXJpZXMpID0+IHtcbiAgICAgICAgICBjb25zdCBpbm5lclJhZGl1cyA9IHNlcmllcy5nZXRJbm5lclJhZGl1cygpO1xuICAgICAgICAgIHJldHVybiB7IHNlcmllcywgaW5uZXJSYWRpdXMgfTtcbiAgICAgICAgfSkuc29ydCgoYSwgYikgPT4gYS5pbm5lclJhZGl1cyAtIGIuaW5uZXJSYWRpdXMpO1xuICAgICAgICBpbm5lclJhZGlpLmF0KC0xKS5zZXJpZXMuc3Vycm91bmRpbmdSYWRpdXMgPSB2b2lkIDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5uZXJSYWRpaS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICBpbm5lclJhZGlpW2ldLnNlcmllcy5zdXJyb3VuZGluZ1JhZGl1cyA9IGlubmVyUmFkaWlbaSArIDFdLmlubmVyUmFkaXVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjZW50ZXJYID0gc2VyaWVzQm94LndpZHRoIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gc2VyaWVzQm94LmhlaWdodCAvIDI7XG4gICAgY29uc3QgaW5pdGlhbFJhZGl1cyA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNlcmllc0JveC53aWR0aCwgc2VyaWVzQm94LmhlaWdodCkgLyAyKTtcbiAgICBsZXQgcmFkaXVzID0gaW5pdGlhbFJhZGl1cztcbiAgICBzZXRTZXJpZXNDaXJjbGUoY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzKTtcbiAgICBjb25zdCBzaGFrZSA9IGFzeW5jICh7IGhpZGVXaGVuTmVjZXNzYXJ5ID0gZmFsc2UgfSA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBsYWJlbEJveGVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IHNlcmllcyBvZiBpdGVyYXRlKHBvbGFyQXhlcywgcG9sYXJTZXJpZXMpKSB7XG4gICAgICAgIGNvbnN0IGJveCA9IGF3YWl0IHNlcmllcy5jb21wdXRlTGFiZWxzQkJveCh7IGhpZGVXaGVuTmVjZXNzYXJ5IH0sIHNlcmllc0JveCk7XG4gICAgICAgIGlmIChib3gpIHtcbiAgICAgICAgICBsYWJlbEJveGVzLnB1c2goYm94KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhYmVsQm94ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNldFNlcmllc0NpcmNsZShjZW50ZXJYLCBjZW50ZXJZLCBpbml0aWFsUmFkaXVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxCb3ggPSBCQm94Lm1lcmdlKGxhYmVsQm94ZXMpO1xuICAgICAgY29uc3QgcmVmaW5lZCA9IHRoaXMucmVmaW5lQ2lyY2xlKGxhYmVsQm94LCByYWRpdXMsIHNlcmllc0JveCk7XG4gICAgICBzZXRTZXJpZXNDaXJjbGUocmVmaW5lZC5jZW50ZXJYLCByZWZpbmVkLmNlbnRlclksIHJlZmluZWQucmFkaXVzKTtcbiAgICAgIHJhZGl1cyA9IHJlZmluZWQucmFkaXVzO1xuICAgIH07XG4gICAgYXdhaXQgc2hha2UoKTtcbiAgICBhd2FpdCBzaGFrZSgpO1xuICAgIGF3YWl0IHNoYWtlKCk7XG4gICAgYXdhaXQgc2hha2UoeyBoaWRlV2hlbk5lY2Vzc2FyeTogdHJ1ZSB9KTtcbiAgICBhd2FpdCBzaGFrZSh7IGhpZGVXaGVuTmVjZXNzYXJ5OiB0cnVlIH0pO1xuICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIGl0ZXJhdGUocG9sYXJBeGVzLCBwb2xhclNlcmllcykpIHtcbiAgICAgIGF3YWl0IHNlcmllcy5jb21wdXRlTGFiZWxzQkJveCh7IGhpZGVXaGVuTmVjZXNzYXJ5OiB0cnVlIH0sIHNlcmllc0JveCk7XG4gICAgfVxuICAgIHJldHVybiB7IHJhZGl1cywgY2VudGVyWCwgY2VudGVyWSB9O1xuICB9XG4gIHJlZmluZUNpcmNsZShsYWJlbHNCb3gsIHJhZGl1cywgc2VyaWVzQm94KSB7XG4gICAgY29uc3QgbWluQ2lyY2xlUmF0aW8gPSAwLjU7XG4gICAgY29uc3QgY2lyY2xlTGVmdCA9IC1yYWRpdXM7XG4gICAgY29uc3QgY2lyY2xlVG9wID0gLXJhZGl1cztcbiAgICBjb25zdCBjaXJjbGVSaWdodCA9IHJhZGl1cztcbiAgICBjb25zdCBjaXJjbGVCb3R0b20gPSByYWRpdXM7XG4gICAgbGV0IHBhZExlZnQgPSBNYXRoLm1heCgwLCBjaXJjbGVMZWZ0IC0gbGFiZWxzQm94LngpO1xuICAgIGxldCBwYWRUb3AgPSBNYXRoLm1heCgwLCBjaXJjbGVUb3AgLSBsYWJlbHNCb3gueSk7XG4gICAgbGV0IHBhZFJpZ2h0ID0gTWF0aC5tYXgoMCwgbGFiZWxzQm94LnggKyBsYWJlbHNCb3gud2lkdGggLSBjaXJjbGVSaWdodCk7XG4gICAgbGV0IHBhZEJvdHRvbSA9IE1hdGgubWF4KDAsIGxhYmVsc0JveC55ICsgbGFiZWxzQm94LmhlaWdodCAtIGNpcmNsZUJvdHRvbSk7XG4gICAgcGFkTGVmdCA9IHBhZFJpZ2h0ID0gTWF0aC5tYXgocGFkTGVmdCwgcGFkUmlnaHQpO1xuICAgIHBhZFRvcCA9IHBhZEJvdHRvbSA9IE1hdGgubWF4KHBhZFRvcCwgcGFkQm90dG9tKTtcbiAgICBjb25zdCBhdmFpbENpcmNsZVdpZHRoID0gc2VyaWVzQm94LndpZHRoIC0gcGFkTGVmdCAtIHBhZFJpZ2h0O1xuICAgIGNvbnN0IGF2YWlsQ2lyY2xlSGVpZ2h0ID0gc2VyaWVzQm94LmhlaWdodCAtIHBhZFRvcCAtIHBhZEJvdHRvbTtcbiAgICBsZXQgbmV3UmFkaXVzID0gTWF0aC5taW4oYXZhaWxDaXJjbGVXaWR0aCwgYXZhaWxDaXJjbGVIZWlnaHQpIC8gMjtcbiAgICBjb25zdCBtaW5Ib3Jpem9udGFsUmFkaXVzID0gbWluQ2lyY2xlUmF0aW8gKiBzZXJpZXNCb3gud2lkdGggLyAyO1xuICAgIGNvbnN0IG1pblZlcnRpY2FsUmFkaXVzID0gbWluQ2lyY2xlUmF0aW8gKiBzZXJpZXNCb3guaGVpZ2h0IC8gMjtcbiAgICBjb25zdCBtaW5SYWRpdXMgPSBNYXRoLm1pbihtaW5Ib3Jpem9udGFsUmFkaXVzLCBtaW5WZXJ0aWNhbFJhZGl1cyk7XG4gICAgaWYgKG5ld1JhZGl1cyA8IG1pblJhZGl1cykge1xuICAgICAgbmV3UmFkaXVzID0gbWluUmFkaXVzO1xuICAgICAgY29uc3QgaG9yaXpvbnRhbFBhZGRpbmcgPSBwYWRMZWZ0ICsgcGFkUmlnaHQ7XG4gICAgICBjb25zdCB2ZXJ0aWNhbFBhZGRpbmcgPSBwYWRUb3AgKyBwYWRCb3R0b207XG4gICAgICBpZiAoMiAqIG5ld1JhZGl1cyArIHZlcnRpY2FsUGFkZGluZyA+IHNlcmllc0JveC5oZWlnaHQpIHtcbiAgICAgICAgY29uc3QgcGFkSGVpZ2h0ID0gc2VyaWVzQm94LmhlaWdodCAtIDIgKiBuZXdSYWRpdXM7XG4gICAgICAgIGlmIChNYXRoLm1pbihwYWRUb3AsIHBhZEJvdHRvbSkgKiAyID4gcGFkSGVpZ2h0KSB7XG4gICAgICAgICAgcGFkVG9wID0gcGFkSGVpZ2h0IC8gMjtcbiAgICAgICAgICBwYWRCb3R0b20gPSBwYWRIZWlnaHQgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKHBhZFRvcCA+IHBhZEJvdHRvbSkge1xuICAgICAgICAgIHBhZFRvcCA9IHBhZEhlaWdodCAtIHBhZEJvdHRvbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWRCb3R0b20gPSBwYWRIZWlnaHQgLSBwYWRUb3A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgyICogbmV3UmFkaXVzICsgaG9yaXpvbnRhbFBhZGRpbmcgPiBzZXJpZXNCb3gud2lkdGgpIHtcbiAgICAgICAgY29uc3QgcGFkV2lkdGggPSBzZXJpZXNCb3gud2lkdGggLSAyICogbmV3UmFkaXVzO1xuICAgICAgICBpZiAoTWF0aC5taW4ocGFkTGVmdCwgcGFkUmlnaHQpICogMiA+IHBhZFdpZHRoKSB7XG4gICAgICAgICAgcGFkTGVmdCA9IHBhZFdpZHRoIC8gMjtcbiAgICAgICAgICBwYWRSaWdodCA9IHBhZFdpZHRoIC8gMjtcbiAgICAgICAgfSBlbHNlIGlmIChwYWRMZWZ0ID4gcGFkUmlnaHQpIHtcbiAgICAgICAgICBwYWRMZWZ0ID0gcGFkV2lkdGggLSBwYWRSaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWRSaWdodCA9IHBhZFdpZHRoIC0gcGFkTGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXdXaWR0aCA9IHBhZExlZnQgKyAyICogbmV3UmFkaXVzICsgcGFkUmlnaHQ7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gcGFkVG9wICsgMiAqIG5ld1JhZGl1cyArIHBhZEJvdHRvbTtcbiAgICByZXR1cm4ge1xuICAgICAgY2VudGVyWDogKHNlcmllc0JveC53aWR0aCAtIG5ld1dpZHRoKSAvIDIgKyBwYWRMZWZ0ICsgbmV3UmFkaXVzLFxuICAgICAgY2VudGVyWTogKHNlcmllc0JveC5oZWlnaHQgLSBuZXdIZWlnaHQpIC8gMiArIHBhZFRvcCArIG5ld1JhZGl1cyxcbiAgICAgIHJhZGl1czogbmV3UmFkaXVzXG4gICAgfTtcbiAgfVxufTtcblBvbGFyQ2hhcnQuY2xhc3NOYW1lID0gXCJQb2xhckNoYXJ0XCI7XG5Qb2xhckNoYXJ0LnR5cGUgPSBcInBvbGFyXCI7XG5mdW5jdGlvbiBpc1BvbGFyU2VyaWVzKHNlcmllcykge1xuICByZXR1cm4gc2VyaWVzIGluc3RhbmNlb2YgUG9sYXJTZXJpZXM7XG59XG5mdW5jdGlvbiBpc1BvbGFyQXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzIGluc3RhbmNlb2YgUG9sYXJBeGlzO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9wb2xhckNoYXJ0TW9kdWxlLnRzXG52YXIgUG9sYXJDaGFydE1vZHVsZSA9IHtcbiAgdHlwZTogXCJjaGFydFwiLFxuICBuYW1lOiBcInBvbGFyXCIsXG4gIGRldGVjdDogaXNBZ1BvbGFyQ2hhcnRPcHRpb25zLFxuICBjcmVhdGUob3B0aW9ucywgcmVzb3VyY2VzKSB7XG4gICAgcmV0dXJuIG5ldyBQb2xhckNoYXJ0KG9wdGlvbnMsIHJlc291cmNlcyk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vZHVsZS9lbnRlcnByaXNlTW9kdWxlLnRzXG52YXIgZW50ZXJwcmlzZU1vZHVsZSA9IHtcbiAgaXNFbnRlcnByaXNlOiBmYWxzZVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLXR5cGVzL3NyYy9jaGFydC9lcnJvckJhck9wdGlvbnMudHNcbnZhciBBZ0Vycm9yQmFyU3VwcG9ydGVkU2VyaWVzVHlwZXMgPSBbXCJiYXJcIiwgXCJsaW5lXCIsIFwic2NhdHRlclwiXTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLXR5cGVzL3NyYy9jaGFydC9uYXZpZ2F0b3JPcHRpb25zLnRzXG52YXIgX19NSU5JX0NIQVJUX1NFUklFU19PUFRJT05TID0gdm9pZCAwO1xudmFyIF9fVkVSSUZZX01JTklfQ0hBUlRfU0VSSUVTX09QVElPTlMgPSB2b2lkIDA7XG5fX1ZFUklGWV9NSU5JX0NIQVJUX1NFUklFU19PUFRJT05TID0gX19NSU5JX0NIQVJUX1NFUklFU19PUFRJT05TO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtdHlwZXMvc3JjL2NoYXJ0L3RoZW1lT3B0aW9ucy50c1xudmFyIF9fVEhFTUVfT1ZFUlJJREVTID0gdm9pZCAwO1xudmFyIF9fVkVSSUZZX1RIRU1FX09WRVJSSURFUyA9IHZvaWQgMDtcbl9fVkVSSUZZX1RIRU1FX09WRVJSSURFUyA9IF9fVEhFTUVfT1ZFUlJJREVTO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtdHlwZXMvc3JjL2NoYXJ0L3Rvb2x0aXBPcHRpb25zLnRzXG52YXIgQWdUb29sdGlwUG9zaXRpb25UeXBlID0gLyogQF9fUFVSRV9fICovICgoQWdUb29sdGlwUG9zaXRpb25UeXBlMikgPT4ge1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiUE9JTlRFUlwiXSA9IFwicG9pbnRlclwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiTk9ERVwiXSA9IFwibm9kZVwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiVE9QXCJdID0gXCJ0b3BcIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIlJJR0hUXCJdID0gXCJyaWdodFwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiQk9UVE9NXCJdID0gXCJib3R0b21cIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIkxFRlRcIl0gPSBcImxlZnRcIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIlRPUF9MRUZUXCJdID0gXCJ0b3AtbGVmdFwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiVE9QX1JJR0hUXCJdID0gXCJ0b3AtcmlnaHRcIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIkJPVFRPTV9SSUdIVFwiXSA9IFwiYm90dG9tLXJpZ2h0XCI7XG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTJbXCJCT1RUT01fTEVGVFwiXSA9IFwiYm90dG9tLWxlZnRcIjtcbiAgcmV0dXJuIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTI7XG59KShBZ1Rvb2x0aXBQb3NpdGlvblR5cGUgfHwge30pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtdHlwZXMvc3JjL3ByZXNldHMvZ2F1Z2UvY29tbW9uT3B0aW9ucy50c1xudmFyIF9fVEhFTUVBQkxFX09QVElPTlMgPSB2b2lkIDA7XG52YXIgX19WRVJJRllfVEhFTUVBQkxFX09QVElPTlMgPSB2b2lkIDA7XG5fX1ZFUklGWV9USEVNRUFCTEVfT1BUSU9OUyA9IF9fVEhFTUVBQkxFX09QVElPTlM7XG52YXIgX19BWElTX0xBQkVMX09QVElPTlMgPSB2b2lkIDA7XG52YXIgX19WRVJJRllfQVhJU19MQUJFTF9PUFRJT05TID0gdm9pZCAwO1xuX19WRVJJRllfQVhJU19MQUJFTF9PUFRJT05TID0gX19BWElTX0xBQkVMX09QVElPTlM7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2FwaS9wcmVzZXQvcHJlc2V0VXRpbHMudHNcbnZhciBJR05PUkVEX1BST1AgPSBTeW1ib2woXCJJR05PUkVEX1BST1BcIik7XG5mdW5jdGlvbiBwaWNrUHJvcHMob3B0cywgdmFsdWVzKSB7XG4gIGNvbnN0IG91dCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZXMpKSB7XG4gICAgaWYgKHZhbHVlICE9PSBJR05PUkVEX1BST1AgJiYgT2JqZWN0Lmhhc093bihvcHRzLCBrZXkpKSB7XG4gICAgICBvdXRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvcHJlc2V0L2dhdWdlLnRzXG5mdW5jdGlvbiBwaWNrVG9vbHRpcFByb3BzKHRvb2x0aXApIHtcbiAgaWYgKHRvb2x0aXAgPT09IHZvaWQgMClcbiAgICByZXR1cm4gdm9pZCAwO1xuICBjb25zdCB7IGVuYWJsZWQsIHNob3dBcnJvdywgcmFuZ2U6IHJhbmdlMywgcG9zaXRpb24sIGRlbGF5LCB3cmFwcGluZyB9ID0gdG9vbHRpcDtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGVuYWJsZWQsXG4gICAgc2hvd0Fycm93LFxuICAgIHJhbmdlOiByYW5nZTMsXG4gICAgcG9zaXRpb24sXG4gICAgZGVsYXksXG4gICAgd3JhcHBpbmdcbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhyZXN1bHQpLmZpbHRlcigoW18sIHZhbHVlXSkgPT4gdmFsdWUgIT09IHZvaWQgMCkpO1xufVxuZnVuY3Rpb24gaXNSYWRpYWxHYXVnZShvcHRzKSB7XG4gIHJldHVybiBvcHRzLnR5cGUgPT09IFwicmFkaWFsLWdhdWdlXCI7XG59XG5mdW5jdGlvbiBpc0xpbmVhckdhdWdlKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMudHlwZSA9PT0gXCJsaW5lYXItZ2F1Z2VcIjtcbn1cbmZ1bmN0aW9uIHJhZGlhbEdhdWdlT3B0aW9ucyhvcHRzKSB7XG4gIGNvbnN0IHtcbiAgICBhbmltYXRpb24sXG4gICAgYmFja2dyb3VuZCxcbiAgICBjb250YWluZXIsXG4gICAgY29udGV4dE1lbnUsXG4gICAgZm9vdG5vdGUsXG4gICAgaGVpZ2h0OiBoZWlnaHQyLFxuICAgIGxpc3RlbmVycyxcbiAgICBsb2NhbGUsXG4gICAgbWluSGVpZ2h0LFxuICAgIG1pbldpZHRoLFxuICAgIG92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpbyxcbiAgICBwYWRkaW5nLFxuICAgIHN1YnRpdGxlLFxuICAgIHRoZW1lLFxuICAgIHRpdGxlLFxuICAgIHdpZHRoOiB3aWR0aDIsXG4gICAgdHlwZSxcbiAgICBjdXJzb3IsXG4gICAgbm9kZUNsaWNrUmFuZ2UsXG4gICAgdG9vbHRpcCxcbiAgICB2YWx1ZSxcbiAgICBzY2FsZTogc2NhbGUyID0ge30sXG4gICAgc3RhcnRBbmdsZSxcbiAgICBlbmRBbmdsZSxcbiAgICBoaWdobGlnaHRTdHlsZSxcbiAgICBzZWdtZW50YXRpb24sXG4gICAgYmFyLFxuICAgIG5lZWRsZSxcbiAgICB0YXJnZXRzLFxuICAgIG91dGVyUmFkaXVzLFxuICAgIGlubmVyUmFkaXVzLFxuICAgIG91dGVyUmFkaXVzUmF0aW8sXG4gICAgaW5uZXJSYWRpdXNSYXRpbyxcbiAgICBjb3JuZXJSYWRpdXMsXG4gICAgY29ybmVyTW9kZSxcbiAgICBsYWJlbCxcbiAgICBzZWNvbmRhcnlMYWJlbCxcbiAgICBzcGFjaW5nLFxuICAgIC4uLnJlc3RcbiAgfSA9IG9wdHM7XG4gIGNvbnN0IHtcbiAgICBmaWxsczogc2NhbGVGaWxscyxcbiAgICBmaWxsTW9kZTogc2NhbGVGaWxsTW9kZSxcbiAgICBmaWxsOiBzY2FsZUZpbGwsXG4gICAgZmlsbE9wYWNpdHk6IHNjYWxlRmlsbE9wYWNpdHksXG4gICAgc3Ryb2tlOiBzY2FsZVN0cm9rZSxcbiAgICBzdHJva2VXaWR0aDogc2NhbGVTdHJva2VXaWR0aCxcbiAgICBzdHJva2VPcGFjaXR5OiBzY2FsZVN0cm9rZU9wYWNpdHksXG4gICAgbGluZURhc2g6IHNjYWxlTGluZURhc2gsXG4gICAgbGluZURhc2hPZmZzZXQ6IHNjYWxlTGluZURhc2hPZmZzZXQsXG4gICAgbWluOiBzY2FsZU1pbiA9IDAsXG4gICAgbWF4OiBzY2FsZU1heCA9IDEsXG4gICAgaW50ZXJ2YWw6IHNjYWxlSW50ZXJ2YWwgPSB7fSxcbiAgICBsYWJlbDogc2NhbGVMYWJlbCA9IHt9XG4gIH0gPSBzY2FsZTI7XG4gIGNvbnN0IGNoYXJ0T3B0cyA9IHBpY2tQcm9wcyhvcHRzLCB7XG4gICAgYW5pbWF0aW9uLFxuICAgIGJhY2tncm91bmQsXG4gICAgY29udGFpbmVyLFxuICAgIGNvbnRleHRNZW51LFxuICAgIGZvb3Rub3RlLFxuICAgIGhlaWdodDogaGVpZ2h0MixcbiAgICBsaXN0ZW5lcnMsXG4gICAgbG9jYWxlLFxuICAgIG1pbkhlaWdodCxcbiAgICBtaW5XaWR0aCxcbiAgICBvdmVycmlkZURldmljZVBpeGVsUmF0aW8sXG4gICAgcGFkZGluZyxcbiAgICBzdWJ0aXRsZSxcbiAgICB0aGVtZSxcbiAgICB0aXRsZSxcbiAgICB0b29sdGlwOiBwaWNrVG9vbHRpcFByb3BzKHRvb2x0aXApLFxuICAgIHdpZHRoOiB3aWR0aDJcbiAgfSk7XG4gIGNvbnN0IHNjYWxlT3B0cyA9IHBpY2tQcm9wcyhzY2FsZTIsIHtcbiAgICBmaWxsczogc2NhbGVGaWxscyxcbiAgICBmaWxsTW9kZTogc2NhbGVGaWxsTW9kZSxcbiAgICBmaWxsOiBzY2FsZUZpbGwsXG4gICAgZmlsbE9wYWNpdHk6IHNjYWxlRmlsbE9wYWNpdHksXG4gICAgc3Ryb2tlOiBzY2FsZVN0cm9rZSxcbiAgICBzdHJva2VXaWR0aDogc2NhbGVTdHJva2VXaWR0aCxcbiAgICBzdHJva2VPcGFjaXR5OiBzY2FsZVN0cm9rZU9wYWNpdHksXG4gICAgbGluZURhc2g6IHNjYWxlTGluZURhc2gsXG4gICAgbGluZURhc2hPZmZzZXQ6IHNjYWxlTGluZURhc2hPZmZzZXRcbiAgfSk7XG4gIGNvbnN0IHNlcmllc09wdHMgPSBwaWNrUHJvcHMob3B0cywge1xuICAgIHN0YXJ0QW5nbGU6IElHTk9SRURfUFJPUCxcbiAgICBlbmRBbmdsZTogSUdOT1JFRF9QUk9QLFxuICAgIG5lZWRsZTogbmVlZGxlICE9IG51bGwgPyB7IGVuYWJsZWQ6IHRydWUsIC4uLm5lZWRsZSB9IDogSUdOT1JFRF9QUk9QLFxuICAgIHNjYWxlOiBzY2FsZU9wdHMsXG4gICAgdHlwZSxcbiAgICBjdXJzb3IsXG4gICAgbm9kZUNsaWNrUmFuZ2UsXG4gICAgbGlzdGVuZXJzLFxuICAgIHRvb2x0aXAsXG4gICAgdmFsdWUsXG4gICAgaGlnaGxpZ2h0U3R5bGUsXG4gICAgc2VnbWVudGF0aW9uLFxuICAgIGJhcixcbiAgICB0YXJnZXRzLFxuICAgIG91dGVyUmFkaXVzLFxuICAgIGlubmVyUmFkaXVzLFxuICAgIG91dGVyUmFkaXVzUmF0aW8sXG4gICAgaW5uZXJSYWRpdXNSYXRpbyxcbiAgICBjb3JuZXJSYWRpdXMsXG4gICAgY29ybmVyTW9kZSxcbiAgICBsYWJlbCxcbiAgICBzZWNvbmRhcnlMYWJlbCxcbiAgICBzcGFjaW5nLFxuICAgIC4uLnJlc3RcbiAgfSk7XG4gIGNvbnN0IGF4ZXNPcHRzID0gW1xuICAgIHtcbiAgICAgIHR5cGU6IFwiYW5nbGUtbnVtYmVyXCIsXG4gICAgICBtaW46IHNjYWxlTWluLFxuICAgICAgbWF4OiBzY2FsZU1heCxcbiAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSxcbiAgICAgIGludGVydmFsOiBzY2FsZUludGVydmFsID8/IHt9LFxuICAgICAgbGFiZWw6IHNjYWxlTGFiZWwgPz8ge31cbiAgICB9LFxuICAgIHsgdHlwZTogXCJyYWRpdXMtbnVtYmVyXCIgfVxuICBdO1xuICByZXR1cm4ge1xuICAgIC4uLmNoYXJ0T3B0cyxcbiAgICBzZXJpZXM6IFtzZXJpZXNPcHRzXSxcbiAgICBheGVzOiBheGVzT3B0c1xuICB9O1xufVxuZnVuY3Rpb24gbGluZWFyR2F1Z2VPcHRpb25zKG9wdHMpIHtcbiAgY29uc3Qge1xuICAgIGFuaW1hdGlvbixcbiAgICBiYWNrZ3JvdW5kLFxuICAgIGNvbnRhaW5lcixcbiAgICBjb250ZXh0TWVudSxcbiAgICBmb290bm90ZSxcbiAgICBoZWlnaHQ6IGhlaWdodDIsXG4gICAgbGlzdGVuZXJzLFxuICAgIGxvY2FsZSxcbiAgICBtaW5IZWlnaHQsXG4gICAgbWluV2lkdGgsXG4gICAgb3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvLFxuICAgIHBhZGRpbmcsXG4gICAgc3VidGl0bGUsXG4gICAgdGhlbWUsXG4gICAgdGl0bGUsXG4gICAgd2lkdGg6IHdpZHRoMixcbiAgICB0eXBlLFxuICAgIGN1cnNvcixcbiAgICBub2RlQ2xpY2tSYW5nZSxcbiAgICB0b29sdGlwLFxuICAgIHZhbHVlLFxuICAgIHNjYWxlOiBzY2FsZTIgPSB7fSxcbiAgICBkaXJlY3Rpb24gPSBcInZlcnRpY2FsXCIsXG4gICAgdGhpY2tuZXNzLFxuICAgIGhpZ2hsaWdodFN0eWxlLFxuICAgIHNlZ21lbnRhdGlvbixcbiAgICBiYXIsXG4gICAgdGFyZ2V0cyxcbiAgICBjb3JuZXJSYWRpdXMsXG4gICAgY29ybmVyTW9kZSxcbiAgICBsYWJlbCxcbiAgICAuLi5yZXN0XG4gIH0gPSBvcHRzO1xuICBjb25zdCB7XG4gICAgZmlsbHM6IHNjYWxlRmlsbHMsXG4gICAgZmlsbE1vZGU6IHNjYWxlRmlsbE1vZGUsXG4gICAgZmlsbDogc2NhbGVGaWxsLFxuICAgIGZpbGxPcGFjaXR5OiBzY2FsZUZpbGxPcGFjaXR5LFxuICAgIHN0cm9rZTogc2NhbGVTdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IHNjYWxlU3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlT3BhY2l0eTogc2NhbGVTdHJva2VPcGFjaXR5LFxuICAgIGxpbmVEYXNoOiBzY2FsZUxpbmVEYXNoLFxuICAgIGxpbmVEYXNoT2Zmc2V0OiBzY2FsZUxpbmVEYXNoT2Zmc2V0LFxuICAgIG1pbjogc2NhbGVNaW4gPSAwLFxuICAgIG1heDogc2NhbGVNYXggPSAxLFxuICAgIGludGVydmFsOiBzY2FsZUludGVydmFsID0ge30sXG4gICAgbGFiZWw6IHNjYWxlTGFiZWwgPSB7fVxuICB9ID0gc2NhbGUyO1xuICBjb25zdCBjaGFydE9wdHMgPSBwaWNrUHJvcHMob3B0cywge1xuICAgIGFuaW1hdGlvbixcbiAgICBiYWNrZ3JvdW5kLFxuICAgIGNvbnRhaW5lcixcbiAgICBjb250ZXh0TWVudSxcbiAgICBmb290bm90ZSxcbiAgICBoZWlnaHQ6IGhlaWdodDIsXG4gICAgbGlzdGVuZXJzLFxuICAgIGxvY2FsZSxcbiAgICBtaW5IZWlnaHQsXG4gICAgbWluV2lkdGgsXG4gICAgb3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvLFxuICAgIHBhZGRpbmcsXG4gICAgc3VidGl0bGUsXG4gICAgdGhlbWUsXG4gICAgdGl0bGUsXG4gICAgdG9vbHRpcDogcGlja1Rvb2x0aXBQcm9wcyh0b29sdGlwKSxcbiAgICB3aWR0aDogd2lkdGgyXG4gIH0pO1xuICBjb25zdCBzY2FsZU9wdHMgPSBwaWNrUHJvcHMoc2NhbGUyLCB7XG4gICAgZmlsbHM6IHNjYWxlRmlsbHMsXG4gICAgZmlsbE1vZGU6IHNjYWxlRmlsbE1vZGUsXG4gICAgZmlsbDogc2NhbGVGaWxsLFxuICAgIGZpbGxPcGFjaXR5OiBzY2FsZUZpbGxPcGFjaXR5LFxuICAgIHN0cm9rZTogc2NhbGVTdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IHNjYWxlU3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlT3BhY2l0eTogc2NhbGVTdHJva2VPcGFjaXR5LFxuICAgIGxpbmVEYXNoOiBzY2FsZUxpbmVEYXNoLFxuICAgIGxpbmVEYXNoT2Zmc2V0OiBzY2FsZUxpbmVEYXNoT2Zmc2V0XG4gIH0pO1xuICBjb25zdCBzZXJpZXNPcHRzID0gcGlja1Byb3BzKG9wdHMsIHtcbiAgICBzY2FsZTogc2NhbGVPcHRzLFxuICAgIHR5cGUsXG4gICAgY3Vyc29yLFxuICAgIG5vZGVDbGlja1JhbmdlLFxuICAgIGxpc3RlbmVycyxcbiAgICB0b29sdGlwLFxuICAgIHZhbHVlLFxuICAgIGRpcmVjdGlvbixcbiAgICB0aGlja25lc3MsXG4gICAgaGlnaGxpZ2h0U3R5bGUsXG4gICAgc2VnbWVudGF0aW9uLFxuICAgIGJhcixcbiAgICB0YXJnZXRzLFxuICAgIGNvcm5lclJhZGl1cyxcbiAgICBjb3JuZXJNb2RlLFxuICAgIGxhYmVsLFxuICAgIC4uLnJlc3RcbiAgfSk7XG4gIGNvbnN0IHsgcGxhY2VtZW50OiBsYWJlbFBsYWNlbWVudCwgLi4uYXhpc0xhYmVsMiB9ID0gc2NhbGVMYWJlbDtcbiAgbGV0IG1haW5BeGlzUG9zaXRpb247XG4gIGxldCBjcm9zc0F4aXNQb3NpdGlvbjtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gIGlmIChob3Jpem9udGFsKSB7XG4gICAgbWFpbkF4aXNQb3NpdGlvbiA9IGxhYmVsUGxhY2VtZW50ID09PSBcImJlZm9yZVwiID8gXCJ0b3BcIiA6IFwiYm90dG9tXCI7XG4gICAgY3Jvc3NBeGlzUG9zaXRpb24gPSBcImxlZnRcIjtcbiAgfSBlbHNlIHtcbiAgICBtYWluQXhpc1Bvc2l0aW9uID0gbGFiZWxQbGFjZW1lbnQgPT09IFwiYWZ0ZXJcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xuICAgIGNyb3NzQXhpc1Bvc2l0aW9uID0gXCJib3R0b21cIjtcbiAgfVxuICBjb25zdCBtYWluQXhpcyA9IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHBvc2l0aW9uOiBtYWluQXhpc1Bvc2l0aW9uLFxuICAgIG1pbjogc2NhbGVNaW4sXG4gICAgbWF4OiBzY2FsZU1heCxcbiAgICByZXZlcnNlOiAhaG9yaXpvbnRhbCxcbiAgICBpbnRlcnZhbDogc2NhbGVJbnRlcnZhbCxcbiAgICBsYWJlbDogYXhpc0xhYmVsMixcbiAgICBuaWNlOiBmYWxzZVxuICB9O1xuICBjb25zdCBjcm9zc0F4aXMgPSB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBwb3NpdGlvbjogY3Jvc3NBeGlzUG9zaXRpb24sXG4gICAgbWluOiAwLFxuICAgIG1heDogMSxcbiAgICBsYWJlbDoge1xuICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICB9XG4gIH07XG4gIGNvbnN0IGF4ZXNPcHRzID0gaG9yaXpvbnRhbCA/IFttYWluQXhpcywgY3Jvc3NBeGlzXSA6IFtjcm9zc0F4aXMsIG1haW5BeGlzXTtcbiAgcmV0dXJuIHtcbiAgICAuLi5jaGFydE9wdHMsXG4gICAgc2VyaWVzOiBbc2VyaWVzT3B0c10sXG4gICAgYXhlczogYXhlc09wdHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGFwcGx5VGhlbWVEZWZhdWx0cyhvcHRzLCBwcmVzZXRUaGVtZSkge1xuICBpZiAocHJlc2V0VGhlbWUgPT0gbnVsbClcbiAgICByZXR1cm4gb3B0cztcbiAgY29uc3QgeyB0YXJnZXRzOiB0YXJnZXRzVGhlbWUsIC4uLmdhdWdlVGhlbWUgfSA9IHByZXNldFRoZW1lO1xuICBvcHRzID0gbWVyZ2VEZWZhdWx0cyhvcHRzLCBnYXVnZVRoZW1lKTtcbiAgaWYgKG9wdHMudGFyZ2V0cyAhPSBudWxsICYmIHRhcmdldHNUaGVtZSAhPSBudWxsKSB7XG4gICAgb3B0cy50YXJnZXRzID0gbWVyZ2VBcnJheURlZmF1bHRzKG9wdHMudGFyZ2V0cywgdGFyZ2V0c1RoZW1lKTtcbiAgfVxuICByZXR1cm4gb3B0cztcbn1cbmZ1bmN0aW9uIGdhdWdlKG9wdHMsIHByZXNldFRoZW1lKSB7XG4gIGlmIChpc1JhZGlhbEdhdWdlKG9wdHMpKSB7XG4gICAgY29uc3QgcmFkaWFsR2F1Z2VPcHRzID0gYXBwbHlUaGVtZURlZmF1bHRzKG9wdHMsIHByZXNldFRoZW1lKTtcbiAgICByZXR1cm4gcmFkaWFsR2F1Z2VPcHRpb25zKHJhZGlhbEdhdWdlT3B0cyk7XG4gIH0gZWxzZSBpZiAoaXNMaW5lYXJHYXVnZShvcHRzKSkge1xuICAgIGNvbnN0IGxpbmVhckdhdWdlT3B0cyA9IGFwcGx5VGhlbWVEZWZhdWx0cyhvcHRzLCBwcmVzZXRUaGVtZSk7XG4gICAgcmV0dXJuIGxpbmVhckdhdWdlT3B0aW9ucyhsaW5lYXJHYXVnZU9wdHMpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBhbmltYXRpb24sXG4gICAgYmFja2dyb3VuZCxcbiAgICBjb250YWluZXIsXG4gICAgY29udGV4dE1lbnUsXG4gICAgZm9vdG5vdGUsXG4gICAgaGVpZ2h0OiBoZWlnaHQyLFxuICAgIGxpc3RlbmVycyxcbiAgICBsb2NhbGUsXG4gICAgbWluSGVpZ2h0LFxuICAgIG1pbldpZHRoLFxuICAgIHBhZGRpbmcsXG4gICAgc3VidGl0bGUsXG4gICAgdGhlbWUsXG4gICAgdGl0bGUsXG4gICAgdG9vbHRpcCxcbiAgICB3aWR0aDogd2lkdGgyXG4gIH0gPSBvcHRzO1xuICByZXR1cm4gcGlja1Byb3BzKG9wdHMsIHtcbiAgICBhbmltYXRpb24sXG4gICAgYmFja2dyb3VuZCxcbiAgICBjb250YWluZXIsXG4gICAgY29udGV4dE1lbnUsXG4gICAgZm9vdG5vdGUsXG4gICAgaGVpZ2h0OiBoZWlnaHQyLFxuICAgIGxpc3RlbmVycyxcbiAgICBsb2NhbGUsXG4gICAgbWluSGVpZ2h0LFxuICAgIG1pbldpZHRoLFxuICAgIHBhZGRpbmcsXG4gICAgc3VidGl0bGUsXG4gICAgdGhlbWUsXG4gICAgdGl0bGUsXG4gICAgdG9vbHRpcCxcbiAgICB3aWR0aDogd2lkdGgyXG4gIH0pO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvcHJlc2V0L3ByaWNlVm9sdW1lUHJlc2V0VGhlbWUudHNcbnZhciBzdHJva2UgPSB7XG4gIHN0cm9rZTogREVGQVVMVF9GSU5BTkNJQUxfQ0hBUlRTX0FOTk9UQVRJT05fQ09MT1Jcbn07XG52YXIgaGFuZGxlID0ge1xuICBmaWxsOiBERUZBVUxUX0FOTk9UQVRJT05fSEFORExFX0ZJTExcbn07XG52YXIgYXhpc0xhYmVsID0ge1xuICBjb2xvcjogXCJ3aGl0ZVwiLFxuICBmaWxsOiBERUZBVUxUX0ZJTkFOQ0lBTF9DSEFSVFNfQU5OT1RBVElPTl9DT0xPUlxufTtcbnZhciBsaW5lVGV4dCA9IHtcbiAgY29sb3I6IERFRkFVTFRfRklOQU5DSUFMX0NIQVJUU19BTk5PVEFUSU9OX0NPTE9SXG59O1xudmFyIGZvbnQgPSB7XG4gIGNvbG9yOiBERUZBVUxUX1RFWFRfQU5OT1RBVElPTl9DT0xPUixcbiAgZm9udFNpemU6IHsgJHJlbTogWzEuMTY2NjY2NjY2NjY2NjY2NyAvKiBMQVJHRSAqL10gfSxcbiAgZm9udEZhbWlseTogeyAkcmVmOiBcImZvbnRGYW1pbHlcIiB9XG59O1xudmFyIHRleHQgPSB7XG4gIC4uLmZvbnQsXG4gIHRleHRBbGlnbjogXCJsZWZ0XCJcbn07XG52YXIgbWVhc3VyZXJTdGF0aXN0aWNzID0ge1xuICAuLi5mb250LFxuICBmb250U2l6ZTogeyAkcmVmOiBcImZvbnRTaXplXCIgfSxcbiAgY29sb3I6IERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0NPTE9SLFxuICBmaWxsOiBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19GSUxMLFxuICBzdHJva2U6IERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX1NUUk9LRSxcbiAgc3Ryb2tlV2lkdGg6IDEsXG4gIGRpdmlkZXI6IHtcbiAgICBzdHJva2U6IERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0RJVklERVJfU1RST0tFLFxuICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgIHN0cm9rZU9wYWNpdHk6IDAuNVxuICB9XG59O1xudmFyIG1lYXN1cmVyID0ge1xuICAuLi5zdHJva2UsXG4gIGJhY2tncm91bmQ6IHtcbiAgICBmaWxsOiBERUZBVUxUX0ZJTkFOQ0lBTF9DSEFSVFNfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsXG4gICAgZmlsbE9wYWNpdHk6IDAuMlxuICB9LFxuICBoYW5kbGU6IHsgLi4uaGFuZGxlIH0sXG4gIHRleHQ6IHsgLi4ubGluZVRleHQgfSxcbiAgc3RhdGlzdGljczogeyAuLi5tZWFzdXJlclN0YXRpc3RpY3MgfVxufTtcbnZhciBhbm5vdGF0aW9uc1RoZW1lID0ge1xuICAvLyBMaW5lc1xuICBsaW5lOiB7XG4gICAgLi4uc3Ryb2tlLFxuICAgIGhhbmRsZTogeyAuLi5oYW5kbGUgfSxcbiAgICB0ZXh0OiB7IC4uLmxpbmVUZXh0IH1cbiAgfSxcbiAgXCJob3Jpem9udGFsLWxpbmVcIjoge1xuICAgIC4uLnN0cm9rZSxcbiAgICBoYW5kbGU6IHsgLi4uaGFuZGxlIH0sXG4gICAgYXhpc0xhYmVsOiB7IC4uLmF4aXNMYWJlbCB9LFxuICAgIHRleHQ6IHsgLi4ubGluZVRleHQgfVxuICB9LFxuICBcInZlcnRpY2FsLWxpbmVcIjoge1xuICAgIC4uLnN0cm9rZSxcbiAgICBoYW5kbGU6IHsgLi4uaGFuZGxlIH0sXG4gICAgYXhpc0xhYmVsOiB7IC4uLmF4aXNMYWJlbCB9LFxuICAgIHRleHQ6IHsgLi4ubGluZVRleHQgfVxuICB9LFxuICAvLyBDaGFubmVsc1xuICBcImRpc2pvaW50LWNoYW5uZWxcIjoge1xuICAgIC4uLnN0cm9rZSxcbiAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICBmaWxsOiBERUZBVUxUX0ZJTkFOQ0lBTF9DSEFSVFNfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsXG4gICAgICBmaWxsT3BhY2l0eTogMC4yXG4gICAgfSxcbiAgICBoYW5kbGU6IHsgLi4uaGFuZGxlIH0sXG4gICAgdGV4dDogeyAuLi5saW5lVGV4dCB9XG4gIH0sXG4gIFwicGFyYWxsZWwtY2hhbm5lbFwiOiB7XG4gICAgLi4uc3Ryb2tlLFxuICAgIGJhY2tncm91bmQ6IHtcbiAgICAgIGZpbGw6IERFRkFVTFRfRklOQU5DSUFMX0NIQVJUU19BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCxcbiAgICAgIGZpbGxPcGFjaXR5OiAwLjJcbiAgICB9LFxuICAgIGhhbmRsZTogeyAuLi5oYW5kbGUgfSxcbiAgICB0ZXh0OiB7IC4uLmxpbmVUZXh0IH1cbiAgfSxcbiAgLy8gRmlib25uYWNjaXNcbiAgXCJmaWJvbmFjY2ktcmV0cmFjZW1lbnRcIjoge1xuICAgIC4uLnN0cm9rZSxcbiAgICBzdHJva2VzOiBERUZBVUxUX0ZJQk9OQUNDSV9TVFJPS0VTLFxuICAgIHJhbmdlU3Ryb2tlOiBERUZBVUxUX0ZJTkFOQ0lBTF9DSEFSVFNfQU5OT1RBVElPTl9DT0xPUixcbiAgICBoYW5kbGU6IHsgLi4uaGFuZGxlIH0sXG4gICAgdGV4dDogeyAuLi5saW5lVGV4dCwgcG9zaXRpb246IFwiY2VudGVyXCIgfSxcbiAgICBsYWJlbDoge1xuICAgICAgLi4uZm9udCxcbiAgICAgIGNvbG9yOiB2b2lkIDAsXG4gICAgICBmb250U2l6ZToge1xuICAgICAgICAkcm91bmQ6IFt7ICRtdWw6IFt7ICRyZWY6IFwiZm9udFNpemVcIiB9LCAxMCAvIDEyXSB9XVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJmaWJvbmFjY2ktcmV0cmFjZW1lbnQtdHJlbmQtYmFzZWRcIjoge1xuICAgIC4uLnN0cm9rZSxcbiAgICBzdHJva2VzOiBERUZBVUxUX0ZJQk9OQUNDSV9TVFJPS0VTLFxuICAgIHJhbmdlU3Ryb2tlOiBERUZBVUxUX0ZJTkFOQ0lBTF9DSEFSVFNfQU5OT1RBVElPTl9DT0xPUixcbiAgICBoYW5kbGU6IHsgLi4uaGFuZGxlIH0sXG4gICAgdGV4dDogeyAuLi5saW5lVGV4dCwgcG9zaXRpb246IFwiY2VudGVyXCIgfSxcbiAgICBsYWJlbDoge1xuICAgICAgLi4uZm9udCxcbiAgICAgIGNvbG9yOiB2b2lkIDAsXG4gICAgICBmb250U2l6ZToge1xuICAgICAgICAkcm91bmQ6IFt7ICRtdWw6IFt7ICRyZWY6IFwiZm9udFNpemVcIiB9LCAxMCAvIDEyXSB9XVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gVGV4dHNcbiAgY2FsbG91dDoge1xuICAgIC4uLnN0cm9rZSxcbiAgICAuLi50ZXh0LFxuICAgIGNvbG9yOiB7ICRyZWY6IFwidGV4dENvbG9yXCIgfSxcbiAgICBoYW5kbGU6IHsgLi4uaGFuZGxlIH0sXG4gICAgZmlsbDogREVGQVVMVF9GSU5BTkNJQUxfQ0hBUlRTX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLFxuICAgIGZpbGxPcGFjaXR5OiAwLjJcbiAgfSxcbiAgY29tbWVudDoge1xuICAgIC4uLnRleHQsXG4gICAgY29sb3I6IFwid2hpdGVcIixcbiAgICBmb250V2VpZ2h0OiA3MDAsXG4gICAgaGFuZGxlOiB7IC4uLmhhbmRsZSB9LFxuICAgIGZpbGw6IERFRkFVTFRfRklOQU5DSUFMX0NIQVJUU19BTk5PVEFUSU9OX0NPTE9SXG4gIH0sXG4gIG5vdGU6IHtcbiAgICAuLi50ZXh0LFxuICAgIGNvbG9yOiBERUZBVUxUX1RFWFRCT1hfQ09MT1IsXG4gICAgZmlsbDogREVGQVVMVF9GSU5BTkNJQUxfQ0hBUlRTX0FOTk9UQVRJT05fQ09MT1IsXG4gICAgc3Ryb2tlOiB7ICRyZWY6IFwiYmFja2dyb3VuZENvbG9yXCIgfSxcbiAgICBzdHJva2VXaWR0aDogMSxcbiAgICBzdHJva2VPcGFjaXR5OiAxLFxuICAgIGhhbmRsZTogeyAuLi5oYW5kbGUgfSxcbiAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICBmaWxsOiBERUZBVUxUX1RFWFRCT1hfRklMTCxcbiAgICAgIHN0cm9rZTogREVGQVVMVF9URVhUQk9YX1NUUk9LRSxcbiAgICAgIHN0cm9rZVdpZHRoOiAxXG4gICAgfVxuICB9LFxuICB0ZXh0OiB7XG4gICAgLi4udGV4dCxcbiAgICBoYW5kbGU6IHsgLi4uaGFuZGxlIH1cbiAgfSxcbiAgLy8gU2hhcGVzXG4gIGFycm93OiB7XG4gICAgLi4uc3Ryb2tlLFxuICAgIGhhbmRsZTogeyAuLi5oYW5kbGUgfSxcbiAgICB0ZXh0OiB7IC4uLmxpbmVUZXh0IH1cbiAgfSxcbiAgXCJhcnJvdy11cFwiOiB7XG4gICAgZmlsbDogUEFMRVRURV9VUF9GSUxMLFxuICAgIGhhbmRsZTogeyAuLi5oYW5kbGUsIHN0cm9rZTogREVGQVVMVF9GSU5BTkNJQUxfQ0hBUlRTX0FOTk9UQVRJT05fQ09MT1IgfVxuICB9LFxuICBcImFycm93LWRvd25cIjoge1xuICAgIGZpbGw6IFBBTEVUVEVfRE9XTl9GSUxMLFxuICAgIGhhbmRsZTogeyAuLi5oYW5kbGUsIHN0cm9rZTogREVGQVVMVF9GSU5BTkNJQUxfQ0hBUlRTX0FOTk9UQVRJT05fQ09MT1IgfVxuICB9LFxuICAvLyBNZWFzdXJlcnNcbiAgXCJkYXRlLXJhbmdlXCI6IHtcbiAgICAuLi5tZWFzdXJlclxuICB9LFxuICBcInByaWNlLXJhbmdlXCI6IHtcbiAgICAuLi5tZWFzdXJlclxuICB9LFxuICBcImRhdGUtcHJpY2UtcmFuZ2VcIjoge1xuICAgIC4uLm1lYXN1cmVyXG4gIH0sXG4gIFwicXVpY2stZGF0ZS1wcmljZS1yYW5nZVwiOiB7XG4gICAgdXA6IHtcbiAgICAgIC4uLnN0cm9rZSxcbiAgICAgIGZpbGw6IERFRkFVTFRfRklOQU5DSUFMX0NIQVJUU19BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCxcbiAgICAgIGZpbGxPcGFjaXR5OiAwLjIsXG4gICAgICBoYW5kbGU6IHsgLi4uaGFuZGxlIH0sXG4gICAgICBzdGF0aXN0aWNzOiB7XG4gICAgICAgIC4uLm1lYXN1cmVyU3RhdGlzdGljcyxcbiAgICAgICAgY29sb3I6IFwiI2ZmZlwiLFxuICAgICAgICBmaWxsOiBERUZBVUxUX0ZJTkFOQ0lBTF9DSEFSVFNfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgICBkaXZpZGVyOiB7XG4gICAgICAgICAgc3Ryb2tlOiBcIiNmZmZcIixcbiAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgICBzdHJva2VPcGFjaXR5OiAwLjVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZG93bjoge1xuICAgICAgLi4uc3Ryb2tlLFxuICAgICAgc3Ryb2tlOiBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19ET1dOX1NUUk9LRSxcbiAgICAgIGZpbGw6IERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0RPV05fRklMTCxcbiAgICAgIGZpbGxPcGFjaXR5OiAwLjIsXG4gICAgICBoYW5kbGU6IHtcbiAgICAgICAgLi4uaGFuZGxlLFxuICAgICAgICBzdHJva2U6IERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0RPV05fU1RST0tFXG4gICAgICB9LFxuICAgICAgc3RhdGlzdGljczoge1xuICAgICAgICAuLi5tZWFzdXJlclN0YXRpc3RpY3MsXG4gICAgICAgIGNvbG9yOiBcIiNmZmZcIixcbiAgICAgICAgZmlsbDogREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRE9XTl9GSUxMLFxuICAgICAgICBzdHJva2VXaWR0aDogMCxcbiAgICAgICAgZGl2aWRlcjoge1xuICAgICAgICAgIHN0cm9rZTogXCIjZmZmXCIsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMC41XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2FwaS9wcmVzZXQvcHJpY2VWb2x1bWVQcmVzZXQudHNcbmZ1bmN0aW9uIGZyb21UaGVtZSh0aGVtZSwgY2IpIHtcbiAgaWYgKGlzT2JqZWN0KHRoZW1lKSkge1xuICAgIHJldHVybiBjYih0aGVtZSk7XG4gIH1cbn1cbnZhciBjaGFydFR5cGVzMyA9IFtcIm9obGNcIiwgXCJsaW5lXCIsIFwic3RlcC1saW5lXCIsIFwiaGxjXCIsIFwiaGlnaC1sb3dcIiwgXCJjYW5kbGVzdGlja1wiLCBcImhvbGxvdy1jYW5kbGVzdGlja1wiXTtcbnZhciB0b29sYmFyQnV0dG9ucyA9IFtcbiAge1xuICAgIGljb246IFwidHJlbmQtbGluZS1kcmF3aW5nXCIsXG4gICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNMaW5lQW5ub3RhdGlvbnNcIixcbiAgICB2YWx1ZTogXCJsaW5lLW1lbnVcIlxuICB9LFxuICB7XG4gICAgaWNvbjogXCJmaWJvbmFjY2ktcmV0cmFjZW1lbnQtZHJhd2luZ1wiLFxuICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zRmlib25hY2NpQW5ub3RhdGlvbnNcIixcbiAgICB2YWx1ZTogXCJmaWJvbmFjY2ktbWVudVwiXG4gIH0sXG4gIHtcbiAgICBpY29uOiBcInRleHQtYW5ub3RhdGlvblwiLFxuICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zVGV4dEFubm90YXRpb25zXCIsXG4gICAgdmFsdWU6IFwidGV4dC1tZW51XCJcbiAgfSxcbiAge1xuICAgIGljb246IFwiYXJyb3ctZHJhd2luZ1wiLFxuICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zU2hhcGVBbm5vdGF0aW9uc1wiLFxuICAgIHZhbHVlOiBcInNoYXBlLW1lbnVcIlxuICB9LFxuICB7XG4gICAgaWNvbjogXCJtZWFzdXJlci1kcmF3aW5nXCIsXG4gICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNNZWFzdXJlckFubm90YXRpb25zXCIsXG4gICAgdmFsdWU6IFwibWVhc3VyZXItbWVudVwiXG4gIH0sXG4gIHtcbiAgICBpY29uOiBcImRlbGV0ZVwiLFxuICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zQ2xlYXJBbGxcIixcbiAgICB2YWx1ZTogXCJjbGVhclwiXG4gIH1cbl07XG5mdW5jdGlvbiBwcmljZVZvbHVtZShvcHRzLCBfcHJlc2V0VGhlbWUsIGdldFRoZW1lKSB7XG4gIGNvbnN0IHtcbiAgICBkYXRlS2V5ID0gXCJkYXRlXCIsXG4gICAgaGlnaEtleSA9IFwiaGlnaFwiLFxuICAgIG9wZW5LZXkgPSBcIm9wZW5cIixcbiAgICBsb3dLZXkgPSBcImxvd1wiLFxuICAgIGNsb3NlS2V5ID0gXCJjbG9zZVwiLFxuICAgIHZvbHVtZUtleSA9IFwidm9sdW1lXCIsXG4gICAgY2hhcnRUeXBlID0gXCJjYW5kbGVzdGlja1wiLFxuICAgIG5hdmlnYXRvciA9IGZhbHNlLFxuICAgIHZvbHVtZSA9IHRydWUsXG4gICAgcmFuZ2VCdXR0b25zID0gdHJ1ZSxcbiAgICBzdGF0dXNCYXIgPSB0cnVlLFxuICAgIHRvb2xiYXIgPSB0cnVlLFxuICAgIHpvb20gPSB0cnVlLFxuICAgIHRoZW1lLFxuICAgIGRhdGEsXG4gICAgLi4udW51c2VkT3B0c1xuICB9ID0gb3B0cztcbiAgY29uc3QgcHJpY2VTZXJpZXMgPSBjcmVhdGVQcmljZVNlcmllcyh0aGVtZSwgY2hhcnRUeXBlLCBkYXRlS2V5LCBoaWdoS2V5LCBsb3dLZXksIG9wZW5LZXksIGNsb3NlS2V5KTtcbiAgY29uc3Qgdm9sdW1lU2VyaWVzID0gY3JlYXRlVm9sdW1lU2VyaWVzKHRoZW1lLCBnZXRUaGVtZSwgb3BlbktleSwgY2xvc2VLZXksIHZvbHVtZSwgdm9sdW1lS2V5KTtcbiAgY29uc3QgbWluaUNoYXJ0ID0gdm9sdW1lID8ge1xuICAgIG1pbmlDaGFydDoge1xuICAgICAgZW5hYmxlZDogbmF2aWdhdG9yLFxuICAgICAgc2VyaWVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImxpbmVcIixcbiAgICAgICAgICB4S2V5OiBkYXRlS2V5LFxuICAgICAgICAgIHlLZXk6IHZvbHVtZUtleSxcbiAgICAgICAgICBtYXJrZXI6IHsgZW5hYmxlZDogZmFsc2UgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBoZWlnaHQ6IDQwLFxuICAgIG1pbkhhbmRsZToge1xuICAgICAgaGVpZ2h0OiA0NlxuICAgIH0sXG4gICAgbWF4SGFuZGxlOiB7XG4gICAgICBoZWlnaHQ6IDQ2XG4gICAgfVxuICB9IDogbnVsbDtcbiAgY29uc3QgbmF2aWdhdG9yT3B0cyA9IHtcbiAgICBuYXZpZ2F0b3I6IHtcbiAgICAgIGVuYWJsZWQ6IG5hdmlnYXRvcixcbiAgICAgIC4uLm1pbmlDaGFydFxuICAgIH1cbiAgfTtcbiAgY29uc3QgYXhlc0J1dHRvbnNFbmFibGVkID0gdHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiID8gdHJ1ZSA6IHRoZW1lPy5vdmVycmlkZXM/LmNvbW1vbj8uYW5ub3RhdGlvbnM/LmF4ZXNCdXR0b25zPy5lbmFibGVkID8/IHRydWU7XG4gIGNvbnN0IGFubm90YXRpb25PcHRzID0ge1xuICAgIGFubm90YXRpb25zOiB7XG4gICAgICBlbmFibGVkOiB0b29sYmFyLFxuICAgICAgb3B0aW9uc1Rvb2xiYXI6IHtcbiAgICAgICAgZW5hYmxlZDogdG9vbGJhclxuICAgICAgfSxcbiAgICAgIHNuYXA6IHRydWUsXG4gICAgICBheGVzQnV0dG9uczoge1xuICAgICAgICBlbmFibGVkOiBheGVzQnV0dG9uc0VuYWJsZWRcbiAgICAgIH0sXG4gICAgICB0b29sYmFyOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRvb2xiYXIsXG4gICAgICAgIGJ1dHRvbnM6IHRvb2xiYXJCdXR0b25zLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHVuZG9jdW1lbnRlZCBvcHRpb25cbiAgICAgICAgcGFkZGluZzogMFxuICAgICAgfSxcbiAgICAgIGRhdGEsXG4gICAgICB4S2V5OiBkYXRlS2V5LFxuICAgICAgdm9sdW1lS2V5OiB2b2x1bWUgPyB2b2x1bWVLZXkgOiB2b2lkIDBcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN0YXR1c0Jhck9wdHMgPSBzdGF0dXNCYXIgPyB7XG4gICAgc3RhdHVzQmFyOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgZGF0YSxcbiAgICAgIGhpZ2hLZXksXG4gICAgICBvcGVuS2V5LFxuICAgICAgbG93S2V5LFxuICAgICAgY2xvc2VLZXksXG4gICAgICB2b2x1bWVLZXk6IHZvbHVtZSA/IHZvbHVtZUtleSA6IHZvaWQgMFxuICAgIH1cbiAgfSA6IG51bGw7XG4gIGNvbnN0IHpvb21PcHRzID0ge1xuICAgIHpvb206IHtcbiAgICAgIGVuYWJsZWQ6IHpvb20sXG4gICAgICBhdXRvU2NhbGluZzoge1xuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICB9LFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB1bmRvY3VtZW50ZWQgb3B0aW9uXG4gICAgICBlbmFibGVJbmRlcGVuZGVudEF4ZXM6IHRydWVcbiAgICB9XG4gIH07XG4gIGNvbnN0IHRvb2xiYXJPcHRzID0ge1xuICAgIHJhbmdlczoge1xuICAgICAgZW5hYmxlZDogcmFuZ2VCdXR0b25zXG4gICAgfVxuICB9O1xuICBjb25zdCB2b2x1bWVBeGlzID0gdm9sdW1lID8gW1xuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCIsXG4gICAgICBrZXlzOiBbdm9sdW1lS2V5XSxcbiAgICAgIGxhYmVsOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICBjcm9zc2hhaXI6IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgIGdyaWRMaW5lOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICBuaWNlOiBmYWxzZSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdW5kb2N1bWVudGVkIG9wdGlvblxuICAgICAgbGF5b3V0Q29uc3RyYWludHM6IHtcbiAgICAgICAgc3RhY2tlZDogZmFsc2UsXG4gICAgICAgIHdpZHRoOiAyMCxcbiAgICAgICAgdW5pdDogXCJwZXJjZW50YWdlXCIsXG4gICAgICAgIGFsaWduOiBcImVuZFwiXG4gICAgICB9XG4gICAgfVxuICBdIDogW107XG4gIHJldHVybiB7XG4gICAgdGhlbWU6IHtcbiAgICAgIGJhc2VUaGVtZTogdHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiID8gdGhlbWUgOiBcImFnLWZpbmFuY2lhbFwiLFxuICAgICAgLi4ubWVyZ2VEZWZhdWx0cyh0eXBlb2YgdGhlbWUgPT09IFwib2JqZWN0XCIgPyB0aGVtZSA6IG51bGwsIHtcbiAgICAgICAgb3ZlcnJpZGVzOiB7XG4gICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICB0aXRsZTogeyBwYWRkaW5nOiA0IH0sXG4gICAgICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgICAgIHRvcDogNixcbiAgICAgICAgICAgICAgcmlnaHQ6IDgsXG4gICAgICAgICAgICAgIGJvdHRvbTogNVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoYXJ0VG9vbGJhcjoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0b29sYmFyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYW5ub3RhdGlvbnM6IHsgLi4uYW5ub3RhdGlvbnNUaGVtZSB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgbGVnZW5kOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgc2VyaWVzOiBbLi4udm9sdW1lU2VyaWVzLCAuLi5wcmljZVNlcmllc10sXG4gICAgYXhlczogW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBwb3NpdGlvbjogXCJyaWdodFwiLFxuICAgICAgICBrZXlzOiBbb3BlbktleSwgY2xvc2VLZXksIGhpZ2hLZXksIGxvd0tleV0sXG4gICAgICAgIGludGVydmFsOiB7XG4gICAgICAgICAgbWF4U3BhY2luZzogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmNvbW1vbj8uYXhlcz8ubnVtYmVyPy5pbnRlcnZhbD8ubWF4U3BhY2luZykgPz8gNDVcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBmb3JtYXQ6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5jb21tb24/LmF4ZXM/Lm51bWJlcj8ubGFiZWw/LmZvcm1hdCkgPz8gXCIuMmZcIlxuICAgICAgICB9LFxuICAgICAgICBjcm9zc2hhaXI6IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIHNuYXA6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdW5kb2N1bWVudGVkIG9wdGlvblxuICAgICAgICBsYXlvdXRDb25zdHJhaW50czoge1xuICAgICAgICAgIHN0YWNrZWQ6IGZhbHNlLFxuICAgICAgICAgIHdpZHRoOiAxMDAsXG4gICAgICAgICAgdW5pdDogXCJwZXJjZW50YWdlXCIsXG4gICAgICAgICAgYWxpZ246IFwic3RhcnRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLi4udm9sdW1lQXhpcyxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJvcmRpbmFsLXRpbWVcIixcbiAgICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIsXG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgY3Jvc3NoYWlyOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXSxcbiAgICB0b29sdGlwOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgZGF0YSxcbiAgICAuLi5hbm5vdGF0aW9uT3B0cyxcbiAgICAuLi5uYXZpZ2F0b3JPcHRzLFxuICAgIC4uLnN0YXR1c0Jhck9wdHMsXG4gICAgLi4uem9vbU9wdHMsXG4gICAgLi4udG9vbGJhck9wdHMsXG4gICAgLi4udW51c2VkT3B0c1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVm9sdW1lU2VyaWVzKHRoZW1lLCBnZXRUaGVtZSwgb3BlbktleSwgY2xvc2VLZXksIHZvbHVtZSwgdm9sdW1lS2V5KSB7XG4gIGlmICghdm9sdW1lKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgYmFyU2VyaWVzRmlsbCA9IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5iYXI/LnNlcmllcz8uZmlsbCk7XG4gIGNvbnN0IGl0ZW1TdHlsZXIgPSBiYXJTZXJpZXNGaWxsID8geyBmaWxsOiBiYXJTZXJpZXNGaWxsIH0gOiB7XG4gICAgaXRlbVN0eWxlcih7IGRhdHVtIH0pIHtcbiAgICAgIGNvbnN0IHsgdXAsIGRvd24gfSA9IGdldFRoZW1lKCkucGFsZXR0ZTtcbiAgICAgIHJldHVybiB7IGZpbGw6IGRhdHVtW29wZW5LZXldIDwgZGF0dW1bY2xvc2VLZXldID8gdXA/LmZpbGwgOiBkb3duPy5maWxsIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHR5cGU6IFwiYmFyXCIsXG4gICAgICB4S2V5OiBcImRhdGVcIixcbiAgICAgIHlLZXk6IHZvbHVtZUtleSxcbiAgICAgIHRvb2x0aXA6IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgIGhpZ2hsaWdodDogeyBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgZmlsbE9wYWNpdHk6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5iYXI/LnNlcmllcz8uZmlsbE9wYWNpdHkpID8/IDAuNSxcbiAgICAgIC4uLml0ZW1TdHlsZXIsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHVuZG9jdW1lbnRlZCBvcHRpb25cbiAgICAgIGZvY3VzUHJpb3JpdHk6IDEsXG4gICAgICBmYXN0RGF0YVByb2Nlc3Npbmc6IHRydWVcbiAgICB9XG4gIF07XG59XG52YXIgUkFOR0VfQVJFQV9UWVBFID0gXCJyYW5nZS1hcmVhXCI7XG5mdW5jdGlvbiBjcmVhdGVQcmljZVNlcmllcyh0aGVtZSwgY2hhcnRUeXBlLCB4S2V5LCBoaWdoS2V5LCBsb3dLZXksIG9wZW5LZXksIGNsb3NlS2V5KSB7XG4gIGNvbnN0IGtleXMgPSB7XG4gICAgeEtleSxcbiAgICBvcGVuS2V5LFxuICAgIGNsb3NlS2V5LFxuICAgIGhpZ2hLZXksXG4gICAgbG93S2V5XG4gIH07XG4gIGNvbnN0IHNpbmdsZUtleXMgPSB7XG4gICAgeEtleSxcbiAgICB5S2V5OiBjbG9zZUtleVxuICB9O1xuICBjb25zdCBjb21tb24gPSB7XG4gICAgcGlja091dHNpZGVWaXNpYmxlTWlub3JBeGlzOiB0cnVlXG4gIH07XG4gIHN3aXRjaCAoY2hhcnRUeXBlID8/IFwiY2FuZGxlc3RpY2tcIikge1xuICAgIGNhc2UgXCJvaGxjXCI6XG4gICAgICByZXR1cm4gY3JlYXRlUHJpY2VTZXJpZXNPSExDKGNvbW1vbiwga2V5cyk7XG4gICAgY2FzZSBcImxpbmVcIjpcbiAgICAgIHJldHVybiBjcmVhdGVQcmljZVNlcmllc0xpbmUoY29tbW9uLCB0aGVtZSwgc2luZ2xlS2V5cyk7XG4gICAgY2FzZSBcInN0ZXAtbGluZVwiOlxuICAgICAgcmV0dXJuIGNyZWF0ZVByaWNlU2VyaWVzU3RlcExpbmUoY29tbW9uLCB0aGVtZSwgc2luZ2xlS2V5cyk7XG4gICAgY2FzZSBcImhsY1wiOlxuICAgICAgcmV0dXJuIGNyZWF0ZVByaWNlU2VyaWVzSExDKGNvbW1vbiwgdGhlbWUsIHNpbmdsZUtleXMsIGtleXMpO1xuICAgIGNhc2UgXCJoaWdoLWxvd1wiOlxuICAgICAgcmV0dXJuIGNyZWF0ZVByaWNlU2VyaWVzSGlnaExvdyhjb21tb24sIHRoZW1lLCBrZXlzKTtcbiAgICBjYXNlIFwiY2FuZGxlc3RpY2tcIjpcbiAgICAgIHJldHVybiBjcmVhdGVQcmljZVNlcmllc0NhbmRsZXN0aWNrKGNvbW1vbiwga2V5cyk7XG4gICAgY2FzZSBcImhvbGxvdy1jYW5kbGVzdGlja1wiOlxuICAgICAgcmV0dXJuIGNyZWF0ZVByaWNlU2VyaWVzSG9sbG93Q2FuZGxlc3RpY2soY29tbW9uLCB0aGVtZSwga2V5cyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKGB1bmtub3duIGNoYXJ0IHR5cGU6ICR7Y2hhcnRUeXBlfTsgZXhwZWN0ZWQgb25lIG9mOiAke2NoYXJ0VHlwZXMzLmpvaW4oXCIsIFwiKX1gKTtcbiAgICAgIHJldHVybiBjcmVhdGVQcmljZVNlcmllc0NhbmRsZXN0aWNrKGNvbW1vbiwga2V5cyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVByaWNlU2VyaWVzT0hMQyhjb21tb24sIGtleXMpIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICB0eXBlOiBcIm9obGNcIixcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdW5kb2N1bWVudGVkIG9wdGlvblxuICAgICAgZm9jdXNQcmlvcml0eTogMCxcbiAgICAgIC4uLmNvbW1vbixcbiAgICAgIC4uLmtleXNcbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBjcmVhdGVQcmljZVNlcmllc0xpbmUoY29tbW9uLCB0aGVtZSwgc2luZ2xlS2V5cykge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHR5cGU6IFwibGluZVwiLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB1bmRvY3VtZW50ZWQgb3B0aW9uXG4gICAgICBmb2N1c1ByaW9yaXR5OiAwLFxuICAgICAgLi4uY29tbW9uLFxuICAgICAgLi4uc2luZ2xlS2V5cyxcbiAgICAgIHN0cm9rZTogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmxpbmU/LnNlcmllcz8uc3Ryb2tlKSA/PyBQQUxFVFRFX05FVVRSQUxfU1RST0tFLFxuICAgICAgbWFya2VyOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8ubGluZT8uc2VyaWVzPy5tYXJrZXIpID8/IHsgZW5hYmxlZDogZmFsc2UgfVxuICAgIH1cbiAgXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByaWNlU2VyaWVzU3RlcExpbmUoY29tbW9uLCB0aGVtZSwgc2luZ2xlS2V5cykge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHR5cGU6IFwibGluZVwiLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB1bmRvY3VtZW50ZWQgb3B0aW9uXG4gICAgICBmb2N1c1ByaW9yaXR5OiAwLFxuICAgICAgLi4uY29tbW9uLFxuICAgICAgLi4uc2luZ2xlS2V5cyxcbiAgICAgIHN0cm9rZTogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmxpbmU/LnNlcmllcz8uc3Ryb2tlKSA/PyBQQUxFVFRFX05FVVRSQUxfU1RST0tFLFxuICAgICAgaW50ZXJwb2xhdGlvbjogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmxpbmU/LnNlcmllcz8uaW50ZXJwb2xhdGlvbikgPz8ge1xuICAgICAgICB0eXBlOiBcInN0ZXBcIlxuICAgICAgfSxcbiAgICAgIG1hcmtlcjogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmxpbmU/LnNlcmllcz8ubWFya2VyKSA/PyB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBjcmVhdGVQcmljZVNlcmllc0hMQyhjb21tb24sIHRoZW1lLCBzaW5nbGVLZXlzLCB7IHhLZXksIGhpZ2hLZXksIGNsb3NlS2V5LCBsb3dLZXkgfSkge1xuICBjb25zdCByYW5nZUFyZWFDb2xvcnMgPSBnZXRUaGVtZUNvbG9ycyhSQU5HRV9BUkVBX1RZUEUsIHRoZW1lKTtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICB0eXBlOiBSQU5HRV9BUkVBX1RZUEUsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHVuZG9jdW1lbnRlZCBvcHRpb25cbiAgICAgIGZvY3VzUHJpb3JpdHk6IDAsXG4gICAgICAuLi5jb21tb24sXG4gICAgICB4S2V5LFxuICAgICAgeUhpZ2hLZXk6IGhpZ2hLZXksXG4gICAgICB5TG93S2V5OiBjbG9zZUtleSxcbiAgICAgIGZpbGw6IHJhbmdlQXJlYUNvbG9ycy5maWxsID8/IFBBTEVUVEVfVVBfRklMTCxcbiAgICAgIHN0cm9rZTogcmFuZ2VBcmVhQ29sb3JzLnN0cm9rZSA/PyBQQUxFVFRFX1VQX1NUUk9LRSxcbiAgICAgIGZpbGxPcGFjaXR5OiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uW1wicmFuZ2UtYXJlYVwiXT8uc2VyaWVzPy5maWxsT3BhY2l0eSkgPz8gMC4zLFxuICAgICAgc3Ryb2tlV2lkdGg6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5bXCJyYW5nZS1hcmVhXCJdPy5zZXJpZXM/LnN0cm9rZVdpZHRoKSA/PyAyXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBSQU5HRV9BUkVBX1RZUEUsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHVuZG9jdW1lbnRlZCBvcHRpb25cbiAgICAgIGZvY3VzUHJpb3JpdHk6IDAsXG4gICAgICAuLi5jb21tb24sXG4gICAgICB4S2V5LFxuICAgICAgeUhpZ2hLZXk6IGNsb3NlS2V5LFxuICAgICAgeUxvd0tleTogbG93S2V5LFxuICAgICAgZmlsbDogcmFuZ2VBcmVhQ29sb3JzLmZpbGwgPz8gUEFMRVRURV9ET1dOX0ZJTEwsXG4gICAgICBzdHJva2U6IHJhbmdlQXJlYUNvbG9ycy5zdHJva2UgPz8gUEFMRVRURV9ET1dOX1NUUk9LRSxcbiAgICAgIGZpbGxPcGFjaXR5OiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uW1wicmFuZ2UtYXJlYVwiXT8uc2VyaWVzPy5maWxsT3BhY2l0eSkgPz8gMC4zLFxuICAgICAgc3Ryb2tlV2lkdGg6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5bXCJyYW5nZS1hcmVhXCJdPy5zZXJpZXM/LnN0cm9rZVdpZHRoKSA/PyAyXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImxpbmVcIixcbiAgICAgIC4uLmNvbW1vbixcbiAgICAgIC4uLnNpbmdsZUtleXMsXG4gICAgICBzdHJva2U6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5saW5lPy5zZXJpZXM/LnN0cm9rZSkgPz8gUEFMRVRURV9BTFRfTkVVVFJBTF9TVFJPS0UsXG4gICAgICBzdHJva2VXaWR0aDogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmxpbmU/LnNlcmllcz8uc3Ryb2tlV2lkdGgpID8/IDIsXG4gICAgICBtYXJrZXI6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5saW5lPy5zZXJpZXM/Lm1hcmtlcikgPz8geyBlbmFibGVkOiBmYWxzZSB9XG4gICAgfVxuICBdO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJpY2VTZXJpZXNIaWdoTG93KGNvbW1vbiwgdGhlbWUsIHsgeEtleSwgaGlnaEtleSwgbG93S2V5IH0pIHtcbiAgY29uc3QgcmFuZ2VCYXJDb2xvcnMgPSBnZXRUaGVtZUNvbG9ycyhcInJhbmdlLWJhclwiLCB0aGVtZSk7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgdHlwZTogXCJyYW5nZS1iYXJcIixcbiAgICAgIC4uLmNvbW1vbixcbiAgICAgIHhLZXksXG4gICAgICB5SGlnaEtleTogaGlnaEtleSxcbiAgICAgIHlMb3dLZXk6IGxvd0tleSxcbiAgICAgIGZpbGw6IHJhbmdlQmFyQ29sb3JzLmZpbGwgPz8gUEFMRVRURV9ORVVUUkFMX0ZJTEwsXG4gICAgICBzdHJva2U6IHJhbmdlQmFyQ29sb3JzLnN0cm9rZSA/PyBQQUxFVFRFX05FVVRSQUxfU1RST0tFLFxuICAgICAgdG9vbHRpcDoge1xuICAgICAgICByYW5nZTogXCJuZWFyZXN0XCJcbiAgICAgIH0sXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHVuZG9jdW1lbnRlZCBvcHRpb25cbiAgICAgIGZvY3VzUHJpb3JpdHk6IDAsXG4gICAgICBmYXN0RGF0YVByb2Nlc3Npbmc6IHRydWVcbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBjcmVhdGVQcmljZVNlcmllc0NhbmRsZXN0aWNrKGNvbW1vbiwga2V5cykge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHR5cGU6IFwiY2FuZGxlc3RpY2tcIixcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdW5kb2N1bWVudGVkIG9wdGlvblxuICAgICAgZm9jdXNQcmlvcml0eTogMCxcbiAgICAgIC4uLmNvbW1vbixcbiAgICAgIC4uLmtleXNcbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBjcmVhdGVQcmljZVNlcmllc0hvbGxvd0NhbmRsZXN0aWNrKGNvbW1vbiwgdGhlbWUsIGtleXMpIHtcbiAgY29uc3QgaXRlbSA9IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5jYW5kbGVzdGljaz8uc2VyaWVzPy5pdGVtKTtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICB0eXBlOiBcImNhbmRsZXN0aWNrXCIsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHVuZG9jdW1lbnRlZCBvcHRpb25cbiAgICAgIGZvY3VzUHJpb3JpdHk6IDAsXG4gICAgICAuLi5jb21tb24sXG4gICAgICAuLi5rZXlzLFxuICAgICAgaXRlbToge1xuICAgICAgICB1cDoge1xuICAgICAgICAgIGZpbGw6IGl0ZW0/LnVwPy5maWxsID8/IFwidHJhbnNwYXJlbnRcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBdO1xufVxuZnVuY3Rpb24gZ2V0VGhlbWVDb2xvcnMoc2VyaWVzVHlwZSwgdGhlbWUpIHtcbiAgY29uc3QgZmlsbCA9IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5bc2VyaWVzVHlwZV0/LnNlcmllcz8uZmlsbCk7XG4gIGNvbnN0IHN0cm9rZTIgPSBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uW3Nlcmllc1R5cGVdPy5zZXJpZXM/LnN0cm9rZSk7XG4gIHJldHVybiB7IGZpbGwsIHN0cm9rZTogc3Ryb2tlMiB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvcHJlc2V0L3NwYXJrbGluZS50c1xudmFyIGNvbW1vbkF4aXNQcm9wZXJ0aWVzID0ge1xuICB0aXRsZToge1xuICAgIGVuYWJsZWQ6IGZhbHNlXG4gIH0sXG4gIGxhYmVsOiB7XG4gICAgZW5hYmxlZDogZmFsc2VcbiAgfSxcbiAgbGluZToge1xuICAgIGVuYWJsZWQ6IGZhbHNlXG4gIH0sXG4gIGdyaWRMaW5lOiB7XG4gICAgZW5hYmxlZDogZmFsc2VcbiAgfSxcbiAgY3Jvc3NoYWlyOiB7XG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgc3Ryb2tlOiBERUZBVUxUX1NQQVJLTElORV9DUk9TU0hBSVJfU1RST0tFLFxuICAgIGxpbmVEYXNoOiBbMF0sXG4gICAgbGFiZWw6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgfVxuICB9XG59O1xudmFyIG51bWVyaWNBeGlzUHJvcGVydGllcyA9IHtcbiAgLi4uY29tbW9uQXhpc1Byb3BlcnRpZXMsXG4gIG5pY2U6IGZhbHNlXG59O1xudmFyIHRvb2x0aXBEZWZhdWx0cyA9IHtcbiAgcG9zaXRpb246IHtcbiAgICB0eXBlOiBcInNwYXJrbGluZVwiXG4gIH1cbn07XG52YXIgYmFyR3JpZExpbmVEZWZhdWx0cyA9IHtcbiAgc3R5bGU6IFt7IHN0cm9rZTogeyAkcmVmOiBcImdyaWRMaW5lQ29sb3JcIiB9IH1dLFxuICB3aWR0aDogMlxufTtcbnZhciBiYXJBeGlzRGVmYXVsdHMgPSB7XG4gIG51bWJlcjoge1xuICAgIGdyaWRMaW5lOiBiYXJHcmlkTGluZURlZmF1bHRzXG4gIH0sXG4gIHRpbWU6IHtcbiAgICBncmlkTGluZTogYmFyR3JpZExpbmVEZWZhdWx0c1xuICB9LFxuICBjYXRlZ29yeToge1xuICAgIGdyaWRMaW5lOiBiYXJHcmlkTGluZURlZmF1bHRzXG4gIH1cbn07XG52YXIgU1BBUktMSU5FX1RIRU1FID0ge1xuICBvdmVycmlkZXM6IHtcbiAgICBjb21tb246IHtcbiAgICAgIGFuaW1hdGlvbjogeyBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgY29udGV4dE1lbnU6IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgIGtleWJvYXJkOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICBiYWNrZ3JvdW5kOiB7IHZpc2libGU6IGZhbHNlIH0sXG4gICAgICBwYWRkaW5nOiB7XG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgbGVmdDogMFxuICAgICAgfSxcbiAgICAgIGF4ZXM6IHtcbiAgICAgICAgbnVtYmVyOiB7XG4gICAgICAgICAgLi4ubnVtZXJpY0F4aXNQcm9wZXJ0aWVzLFxuICAgICAgICAgIGludGVydmFsOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IFswXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbG9nOiB7XG4gICAgICAgICAgLi4ubnVtZXJpY0F4aXNQcm9wZXJ0aWVzXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWU6IHtcbiAgICAgICAgICAuLi5udW1lcmljQXhpc1Byb3BlcnRpZXNcbiAgICAgICAgfSxcbiAgICAgICAgY2F0ZWdvcnk6IHtcbiAgICAgICAgICAuLi5jb21tb25BeGlzUHJvcGVydGllc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBiYXI6IHtcbiAgICAgIHNlcmllczoge1xuICAgICAgICBjcmlzcDogZmFsc2UsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgcGxhY2VtZW50OiBcImluc2lkZS1lbmRcIixcbiAgICAgICAgICBwYWRkaW5nOiA0XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdW5kb2N1bWVudGVkIG9wdGlvblxuICAgICAgICBzcGFya2xpbmVNb2RlOiB0cnVlXG4gICAgICB9LFxuICAgICAgdG9vbHRpcDoge1xuICAgICAgICAuLi50b29sdGlwRGVmYXVsdHMsXG4gICAgICAgIHJhbmdlOiBcIm5lYXJlc3RcIlxuICAgICAgfSxcbiAgICAgIGF4ZXM6IGJhckF4aXNEZWZhdWx0c1xuICAgIH0sXG4gICAgbGluZToge1xuICAgICAgc2VyaWVzQXJlYToge1xuICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgdG9wOiAyLFxuICAgICAgICAgIHJpZ2h0OiAyLFxuICAgICAgICAgIGJvdHRvbTogMixcbiAgICAgICAgICBsZWZ0OiAyXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXJpZXM6IHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB1bmRvY3VtZW50ZWQgb3B0aW9uXG4gICAgICAgIHNwYXJrbGluZU1vZGU6IHRydWUsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBzaXplOiAzXG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHRvb2x0aXBEZWZhdWx0c1xuICAgICAgfVxuICAgIH0sXG4gICAgYXJlYToge1xuICAgICAgc2VyaWVzQXJlYToge1xuICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgdG9wOiAxLFxuICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgIGJvdHRvbTogMSxcbiAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXJpZXM6IHtcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIGZpbGxPcGFjaXR5OiAwLjQsXG4gICAgICAgIHRvb2x0aXA6IHRvb2x0aXBEZWZhdWx0c1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBzZXRJbml0aWFsQmFzZVRoZW1lID0gc2ltcGxlTWVtb3JpemUoY3JlYXRlSW5pdGlhbEJhc2VUaGVtZSk7XG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsQmFzZVRoZW1lKGJhc2VUaGVtZSwgaW5pdGlhbEJhc2VUaGVtZSkge1xuICBpZiAodHlwZW9mIGJhc2VUaGVtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5pbml0aWFsQmFzZVRoZW1lLFxuICAgICAgYmFzZVRoZW1lXG4gICAgfTtcbiAgfVxuICBpZiAoYmFzZVRoZW1lICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uYmFzZVRoZW1lLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvblxuICAgICAgYmFzZVRoZW1lOiBzZXRJbml0aWFsQmFzZVRoZW1lKGJhc2VUaGVtZS5iYXNlVGhlbWUsIGluaXRpYWxCYXNlVGhlbWUpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gaW5pdGlhbEJhc2VUaGVtZTtcbn1cbmZ1bmN0aW9uIHNwYXJrbGluZURhdGFQcmVzZXQoZGF0YSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSAmJiBkYXRhLmxlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IGZpcnN0SXRlbSA9IGRhdGFbMF07XG4gICAgaWYgKHR5cGVvZiBmaXJzdEl0ZW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IG1hcHBlZERhdGEgPSBkYXRhLm1hcCgoeSwgeCkgPT4gKHsgeCwgeSB9KSk7XG4gICAgICByZXR1cm4geyBkYXRhOiBtYXBwZWREYXRhLCBzZXJpZXM6IFt7IHhLZXk6IFwieFwiLCB5S2V5OiBcInlcIiB9XSwgZGF0dW1LZXk6IFwieVwiIH07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpcnN0SXRlbSkpIHtcbiAgICAgIGNvbnN0IG1hcHBlZERhdGEgPSBkYXRhLm1hcCgoZGF0dW0pID0+ICh7IHg6IGRhdHVtWzBdLCB5OiBkYXR1bVsxXSwgZGF0dW0gfSkpO1xuICAgICAgcmV0dXJuIHsgZGF0YTogbWFwcGVkRGF0YSwgc2VyaWVzOiBbeyB4S2V5OiBcInhcIiwgeUtleTogXCJ5XCIgfV0sIGRhdHVtS2V5OiBcImRhdHVtXCIgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgZGF0YSB9O1xufVxuZnVuY3Rpb24gYXhpc1ByZXNldChvcHRzLCBkZWZhdWx0VHlwZSkge1xuICBzd2l0Y2ggKG9wdHM/LnR5cGUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6IHtcbiAgICAgIGNvbnN0IHsgdHlwZSwgbWluLCBtYXgsIHJldmVyc2UgfSA9IG9wdHM7XG4gICAgICByZXR1cm4gcGlja1Byb3BzKG9wdHMsIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmV2ZXJzZSxcbiAgICAgICAgbWluLFxuICAgICAgICBtYXhcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjYXNlIFwidGltZVwiOiB7XG4gICAgICBjb25zdCB7IHR5cGUsIG1pbiwgbWF4LCByZXZlcnNlIH0gPSBvcHRzO1xuICAgICAgcmV0dXJuIHBpY2tQcm9wcyhvcHRzLCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHJldmVyc2UsXG4gICAgICAgIG1pbixcbiAgICAgICAgbWF4XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2FzZSBcImNhdGVnb3J5XCI6IHtcbiAgICAgIGNvbnN0IHsgdHlwZSwgcGFkZGluZ0lubmVyLCBwYWRkaW5nT3V0ZXIsIHJldmVyc2UgfSA9IG9wdHM7XG4gICAgICByZXR1cm4gcGlja1Byb3BzKG9wdHMsIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmV2ZXJzZSxcbiAgICAgICAgcGFkZGluZ0lubmVyLFxuICAgICAgICBwYWRkaW5nT3V0ZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB0eXBlOiBkZWZhdWx0VHlwZSB9O1xufVxuZnVuY3Rpb24gZ3JpZExpbmVQcmVzZXQob3B0cywgZGVmYXVsdEVuYWJsZWQsIHNwYXJrT3B0cykge1xuICBjb25zdCBncmlkTGluZU9wdHMgPSB7fTtcbiAgaWYgKG9wdHM/LnN0cm9rZSAhPSBudWxsKSB7XG4gICAgZ3JpZExpbmVPcHRzLnN0eWxlID0gW3sgc3Ryb2tlOiBvcHRzPy5zdHJva2UgfV07XG4gICAgZ3JpZExpbmVPcHRzLmVuYWJsZWQgPz8gKGdyaWRMaW5lT3B0cy5lbmFibGVkID0gdHJ1ZSk7XG4gIH1cbiAgaWYgKG9wdHM/LnN0cm9rZVdpZHRoICE9IG51bGwpIHtcbiAgICBncmlkTGluZU9wdHMud2lkdGggPSBvcHRzPy5zdHJva2VXaWR0aDtcbiAgICBncmlkTGluZU9wdHMuZW5hYmxlZCA/PyAoZ3JpZExpbmVPcHRzLmVuYWJsZWQgPSB0cnVlKTtcbiAgfVxuICBpZiAoc3BhcmtPcHRzLnR5cGUgPT09IFwiYmFyXCIgJiYgc3BhcmtPcHRzLmRpcmVjdGlvbiAhPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICBncmlkTGluZU9wdHMuZW5hYmxlZCA/PyAoZ3JpZExpbmVPcHRzLmVuYWJsZWQgPSB0cnVlKTtcbiAgfVxuICBpZiAob3B0cz8udmlzaWJsZSAhPSBudWxsKSB7XG4gICAgZ3JpZExpbmVPcHRzLmVuYWJsZWQgPSBvcHRzLnZpc2libGU7XG4gIH1cbiAgZ3JpZExpbmVPcHRzLmVuYWJsZWQgPz8gKGdyaWRMaW5lT3B0cy5lbmFibGVkID0gZGVmYXVsdEVuYWJsZWQpO1xuICByZXR1cm4gZ3JpZExpbmVPcHRzO1xufVxudmFyIHRvb2x0aXBSZW5kZXJlckZuID0gc2ltcGxlTWVtb3JpemUoKGNvbnRleHQsIHRvb2x0aXAsIGRhdHVtS2V5KSA9PiB7XG4gIHJldHVybiAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeFZhbHVlID0gcGFyYW1zLmRhdHVtW3BhcmFtcy54S2V5XTtcbiAgICBjb25zdCB5VmFsdWUgPSBwYXJhbXMuZGF0dW1bcGFyYW1zLnlLZXldO1xuICAgIGNvbnN0IGRhdHVtID0gZGF0dW1LZXkgIT0gbnVsbCA/IHBhcmFtcy5kYXR1bVtkYXR1bUtleV0gOiBwYXJhbXMuZGF0dW07XG4gICAgY29uc3QgdXNlckNvbnRlbnQgPSB0b29sdGlwPy5yZW5kZXJlcj8uKHsgY29udGV4dCwgZGF0dW0sIHhWYWx1ZSwgeVZhbHVlIH0pO1xuICAgIGlmICh0eXBlb2YgdXNlckNvbnRlbnQgPT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gdXNlckNvbnRlbnQ7XG4gICAgY29uc3QgdGl0bGUgPSB1c2VyQ29udGVudD8udGl0bGU7XG4gICAgY29uc3QgY29udGVudCA9IHVzZXJDb250ZW50Py5jb250ZW50O1xuICAgIHJldHVybiB0aXRsZSAhPSBudWxsICYmIGNvbnRlbnQgIT0gbnVsbCA/IHtcbiAgICAgIGhlYWRpbmc6IHRpdGxlLFxuICAgICAgdGl0bGU6IHZvaWQgMCxcbiAgICAgIC8vIFVuZG9jdW1lbnRlZCAnY29tcGFjdCcgdG9vbHRpcCBtb2RlXG4gICAgICBkYXRhOiBbeyBsYWJlbDogdm9pZCAwLCB2YWx1ZTogY29udGVudCB9XVxuICAgIH0gOiB7XG4gICAgICBoZWFkaW5nOiB0aXRsZSA/PyBjb250ZW50ID8/IHlWYWx1ZS50b0ZpeGVkKDIpLFxuICAgICAgdGl0bGU6IHZvaWQgMCxcbiAgICAgIGRhdGE6IFtdXG4gICAgfTtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gc3BhcmtsaW5lKG9wdHMpIHtcbiAgY29uc3Qge1xuICAgIGJhY2tncm91bmQsXG4gICAgY29udGFpbmVyLFxuICAgIGhlaWdodDogaGVpZ2h0MixcbiAgICBsaXN0ZW5lcnMsXG4gICAgbG9jYWxlLFxuICAgIG1pbkhlaWdodCxcbiAgICBtaW5XaWR0aCxcbiAgICBvdmVycmlkZURldmljZVBpeGVsUmF0aW8sXG4gICAgcGFkZGluZyxcbiAgICB3aWR0aDogd2lkdGgyLFxuICAgIHRoZW1lOiBiYXNlVGhlbWUsXG4gICAgZGF0YTogYmFzZURhdGEsXG4gICAgY3Jvc3NoYWlyLFxuICAgIGF4aXMsXG4gICAgbWluLFxuICAgIG1heCxcbiAgICB0b29sdGlwLFxuICAgIGNvbnRleHQsXG4gICAgLi4ub3B0c1Jlc3RcbiAgfSA9IG9wdHM7XG4gIGNvbnN0IGNoYXJ0T3B0cyA9IHBpY2tQcm9wcyhvcHRzLCB7XG4gICAgYmFja2dyb3VuZCxcbiAgICBjb250YWluZXIsXG4gICAgaGVpZ2h0OiBoZWlnaHQyLFxuICAgIGxpc3RlbmVycyxcbiAgICBsb2NhbGUsXG4gICAgbWluSGVpZ2h0LFxuICAgIG1pbldpZHRoLFxuICAgIG92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpbyxcbiAgICBwYWRkaW5nLFxuICAgIHdpZHRoOiB3aWR0aDIsXG4gICAgdG9vbHRpcDogSUdOT1JFRF9QUk9QLFxuICAgIGNvbnRleHQ6IElHTk9SRURfUFJPUCxcbiAgICBkYXRhOiBJR05PUkVEX1BST1AsXG4gICAgY3Jvc3NoYWlyOiBJR05PUkVEX1BST1AsXG4gICAgYXhpczogSUdOT1JFRF9QUk9QLFxuICAgIG1pbjogSUdOT1JFRF9QUk9QLFxuICAgIG1heDogSUdOT1JFRF9QUk9QLFxuICAgIHRoZW1lOiBJR05PUkVEX1BST1BcbiAgfSk7XG4gIGNvbnN0IHsgZGF0YSwgc2VyaWVzOiBbc2VyaWVzT3ZlcnJpZGVzXSA9IFtdLCBkYXR1bUtleSB9ID0gc3BhcmtsaW5lRGF0YVByZXNldChiYXNlRGF0YSk7XG4gIGNvbnN0IHNlcmllc09wdGlvbnMgPSBvcHRzUmVzdDtcbiAgaWYgKHNlcmllc092ZXJyaWRlcyAhPSBudWxsKVxuICAgIE9iamVjdC5hc3NpZ24oc2VyaWVzT3B0aW9ucywgc2VyaWVzT3ZlcnJpZGVzKTtcbiAgc2VyaWVzT3B0aW9ucy50b29sdGlwID0ge1xuICAgIC4uLnRvb2x0aXAsXG4gICAgcmVuZGVyZXI6IHRvb2x0aXBSZW5kZXJlckZuKGNvbnRleHQsIHRvb2x0aXAsIGRhdHVtS2V5KVxuICB9O1xuICBjaGFydE9wdHMudGhlbWUgPSBzZXRJbml0aWFsQmFzZVRoZW1lKGJhc2VUaGVtZSwgU1BBUktMSU5FX1RIRU1FKTtcbiAgY2hhcnRPcHRzLmRhdGEgPSBkYXRhO1xuICBjaGFydE9wdHMuc2VyaWVzID0gW3Nlcmllc09wdGlvbnNdO1xuICBjb25zdCBzd2FwQXhlcyA9IHNlcmllc09wdGlvbnMudHlwZSAhPT0gXCJiYXJcIiB8fCBzZXJpZXNPcHRpb25zLmRpcmVjdGlvbiAhPT0gXCJob3Jpem9udGFsXCI7XG4gIGNvbnN0IFt4QXhpc1Bvc2l0aW9uLCB5QXhpc1Bvc2l0aW9uXSA9IHN3YXBBeGVzID8gW1wiYm90dG9tXCIsIFwibGVmdFwiXSA6IFtcImxlZnRcIiwgXCJib3R0b21cIl07XG4gIGNvbnN0IHhBeGlzID0ge1xuICAgIC4uLmF4aXNQcmVzZXQoYXhpcywgXCJjYXRlZ29yeVwiKSxcbiAgICBwb3NpdGlvbjogeEF4aXNQb3NpdGlvbixcbiAgICAuLi5waWNrUHJvcHMob3B0cywgeyBjcm9zc2hhaXIgfSlcbiAgfTtcbiAgY29uc3QgeUF4aXMgPSB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBncmlkTGluZTogZ3JpZExpbmVQcmVzZXQoYXhpcywgZmFsc2UsIG9wdHMpLFxuICAgIHBvc2l0aW9uOiB5QXhpc1Bvc2l0aW9uLFxuICAgIC4uLnBpY2tQcm9wcyhvcHRzLCB7IG1pbiwgbWF4IH0pXG4gIH07XG4gIGNoYXJ0T3B0cy5heGVzID0gc3dhcEF4ZXMgPyBbeUF4aXMsIHhBeGlzXSA6IFt4QXhpcywgeUF4aXNdO1xuICByZXR1cm4gY2hhcnRPcHRzO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvcHJlc2V0L3ByZXNldHMudHNcbnZhciBQUkVTRVRTID0ge1xuICBcInByaWNlLXZvbHVtZVwiOiBwcmljZVZvbHVtZSxcbiAgZ2F1Z2UsXG4gIHNwYXJrbGluZVxufTtcbnZhciBQUkVTRVRfREFUQV9QUk9DRVNTT1JTID0ge1xuICBzcGFya2xpbmU6IHNwYXJrbGluZURhdGFQcmVzZXRcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ZhY3RvcnkvcHJvY2Vzc0VudGVycHJpc2VPcHRpb25zLnRzXG5mdW5jdGlvbiByZW1vdmVVc2VkRW50ZXJwcmlzZU9wdGlvbnMob3B0aW9ucywgc2lsZW50KSB7XG4gIGxldCB1c2VkT3B0aW9ucyA9IFtdO1xuICBjb25zdCBpc0dhdWdlQ2hhcnQgPSBpc0FnR2F1Z2VDaGFydE9wdGlvbnMob3B0aW9ucyk7XG4gIGNvbnN0IG9wdHNUeXBlID0gb3B0aW9uc1R5cGUob3B0aW9ucyk7XG4gIGNvbnN0IG9wdGlvbnNDaGFydFR5cGUgPSBvcHRzVHlwZSA/IGNoYXJ0VHlwZXMyLmdldChvcHRzVHlwZSkgOiBcInVua25vd25cIjtcbiAgZm9yIChjb25zdCBtb2R1bGUgb2YgRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTKSB7XG4gICAgaWYgKG9wdGlvbnNDaGFydFR5cGUgIT09IFwidW5rbm93blwiICYmICFtb2R1bGUuY2hhcnRUeXBlcy5pbmNsdWRlcyhvcHRpb25zQ2hhcnRUeXBlKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gXCJyb290XCIgfHwgbW9kdWxlLnR5cGUgPT09IFwibGVnZW5kXCIpIHtcbiAgICAgIGNvbnN0IG9wdGlvblZhbHVlID0gb3B0aW9uc1ttb2R1bGUub3B0aW9uc0tleV07XG4gICAgICBpZiAob3B0aW9uVmFsdWUgPT0gbnVsbClcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoIW1vZHVsZS5vcHRpb25zSW5uZXJLZXkpIHtcbiAgICAgICAgdXNlZE9wdGlvbnMucHVzaChtb2R1bGUub3B0aW9uc0tleSk7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zW21vZHVsZS5vcHRpb25zS2V5XTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9uVmFsdWVbbW9kdWxlLm9wdGlvbnNJbm5lcktleV0pIHtcbiAgICAgICAgdXNlZE9wdGlvbnMucHVzaChgJHttb2R1bGUub3B0aW9uc0tleX0uJHttb2R1bGUub3B0aW9uc0lubmVyS2V5fWApO1xuICAgICAgICBkZWxldGUgb3B0aW9uVmFsdWVbbW9kdWxlLm9wdGlvbnNJbm5lcktleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtb2R1bGUudHlwZSA9PT0gXCJheGlzXCIpIHtcbiAgICAgIGlmICghKFwiYXhlc1wiIGluIG9wdGlvbnMpIHx8ICFvcHRpb25zLmF4ZXM/LnNvbWUoKGF4aXMpID0+IGF4aXMudHlwZSA9PT0gbW9kdWxlLmlkZW50aWZpZXIpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHVzZWRPcHRpb25zLnB1c2goYGF4aXNbdHlwZT0ke21vZHVsZS5pZGVudGlmaWVyfV1gKTtcbiAgICAgIG9wdGlvbnMuYXhlcyA9IG9wdGlvbnMuYXhlcy5maWx0ZXIoKGF4aXMpID0+IGF4aXMudHlwZSAhPT0gbW9kdWxlLmlkZW50aWZpZXIpO1xuICAgIH0gZWxzZSBpZiAobW9kdWxlLnR5cGUgPT09IFwiYXhpcy1vcHRpb25cIikge1xuICAgICAgaWYgKCEoXCJheGVzXCIgaW4gb3B0aW9ucykgfHwgIW9wdGlvbnMuYXhlcz8uc29tZSgoYXhpcykgPT4gYXhpc1ttb2R1bGUub3B0aW9uc0tleV0pKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHVzZWRPcHRpb25zLnB1c2goYGF4aXMuJHttb2R1bGUub3B0aW9uc0tleX1gKTtcbiAgICAgIG9wdGlvbnMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiB7XG4gICAgICAgIGlmIChheGlzW21vZHVsZS5vcHRpb25zS2V5XSkge1xuICAgICAgICAgIGRlbGV0ZSBheGlzW21vZHVsZS5vcHRpb25zS2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChtb2R1bGUudHlwZSA9PT0gXCJzZXJpZXNcIikge1xuICAgICAgaWYgKG1vZHVsZS5jb21tdW5pdHkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKCFvcHRpb25zLnNlcmllcz8uc29tZSgoc2VyaWVzKSA9PiBzZXJpZXMudHlwZSA9PT0gbW9kdWxlLmlkZW50aWZpZXIpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHVzZWRPcHRpb25zLnB1c2goYHNlcmllc1t0eXBlPSR7bW9kdWxlLmlkZW50aWZpZXJ9XWApO1xuICAgICAgb3B0aW9ucy5zZXJpZXMgPSBvcHRpb25zLnNlcmllcy5maWx0ZXIoKHNlcmllcykgPT4gc2VyaWVzLnR5cGUgIT09IG1vZHVsZS5pZGVudGlmaWVyKTtcbiAgICB9IGVsc2UgaWYgKG1vZHVsZS50eXBlID09PSBcInNlcmllcy1vcHRpb25cIikge1xuICAgICAgaWYgKCFvcHRpb25zLnNlcmllcz8uc29tZSgoc2VyaWVzKSA9PiBzZXJpZXNbbW9kdWxlLm9wdGlvbnNLZXldKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB1c2VkT3B0aW9ucy5wdXNoKGBzZXJpZXMuJHttb2R1bGUub3B0aW9uc0tleX1gKTtcbiAgICAgIG9wdGlvbnMuc2VyaWVzLmZvckVhY2goKHNlcmllcykgPT4ge1xuICAgICAgICBpZiAoc2VyaWVzW21vZHVsZS5vcHRpb25zS2V5XSkge1xuICAgICAgICAgIGRlbGV0ZSBzZXJpZXNbbW9kdWxlLm9wdGlvbnNLZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHVzZWRPcHRpb25zLmxlbmd0aCAmJiAhc2lsZW50KSB7XG4gICAgaWYgKGlzR2F1Z2VDaGFydCkge1xuICAgICAgdXNlZE9wdGlvbnMgPSBbXCJBZ0NoYXJ0cy5jcmVhdGVHYXVnZVwiXTtcbiAgICB9XG4gICAgbGV0IGVudGVycHJpc2VQYWNrYWdlTmFtZSA9IFwiYWctY2hhcnRzLWVudGVycHJpc2VcIjtcbiAgICBsZXQgZW50ZXJwcmlzZVJlZmVyZW5jZVVybCA9IFwiaHR0cHM6Ly93d3cuYWctZ3JpZC5jb20vY2hhcnRzL2phdmFzY3JpcHQvaW5zdGFsbGF0aW9uL1wiO1xuICAgIGlmIChvcHRpb25zLm1vZGUgPT09IFwiaW50ZWdyYXRlZFwiKSB7XG4gICAgICBlbnRlcnByaXNlUGFja2FnZU5hbWUgPSBcImFnLWdyaWQtY2hhcnRzLWVudGVycHJpc2UnIG9yICdhZy1ncmlkLWVudGVycHJpc2UvY2hhcnRzLWVudGVycHJpc2VcIjtcbiAgICAgIGVudGVycHJpc2VSZWZlcmVuY2VVcmwgPSBcImh0dHBzOi8vd3d3LmFnLWdyaWQuY29tL2phdmFzY3JpcHQtZGF0YS1ncmlkL2ludGVncmF0ZWQtY2hhcnRzLWluc3RhbGxhdGlvbi9cIjtcbiAgICB9XG4gICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UoXG4gICAgICBbXG4gICAgICAgIGB1bmFibGUgdG8gdXNlIHRoZXNlIGVudGVycHJpc2UgZmVhdHVyZXMgYXMgJyR7ZW50ZXJwcmlzZVBhY2thZ2VOYW1lfScgaGFzIG5vdCBiZWVuIGxvYWRlZDpgLFxuICAgICAgICBcIlwiLFxuICAgICAgICAuLi51c2VkT3B0aW9ucyxcbiAgICAgICAgXCJcIixcbiAgICAgICAgYFNlZTogJHtlbnRlcnByaXNlUmVmZXJlbmNlVXJsfWBcbiAgICAgIF0uam9pbihcIlxcblwiKVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZVVudXNlZEVudGVycHJpc2VPcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3QgaW50ZWdyYXRlZE1vZGUgPSBcIm1vZGVcIiBpbiBvcHRpb25zICYmIG9wdGlvbnMubW9kZSA9PT0gXCJpbnRlZ3JhdGVkXCI7XG4gIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZVJlZ2lzdHJ5LmJ5VHlwZShcInJvb3RcIiwgXCJsZWdlbmRcIikpIHtcbiAgICBjb25zdCBtb2R1bGVPcHRpb25zID0gb3B0aW9uc1ttb2R1bGUub3B0aW9uc0tleV07XG4gICAgY29uc3QgaXNQcmVzZW50QW5kRGlzYWJsZWQgPSBtb2R1bGVPcHRpb25zICE9IG51bGwgJiYgbW9kdWxlT3B0aW9ucy5lbmFibGVkID09PSBmYWxzZTtcbiAgICBjb25zdCByZW1vdmFibGUgPSAhKFwicmVtb3ZhYmxlXCIgaW4gbW9kdWxlKSB8fCBtb2R1bGUucmVtb3ZhYmxlID09PSB0cnVlIHx8IG1vZHVsZS5yZW1vdmFibGUgPT09IFwic3RhbmRhbG9uZS1vbmx5XCIgJiYgIWludGVncmF0ZWRNb2RlO1xuICAgIGlmIChpc1ByZXNlbnRBbmREaXNhYmxlZCAmJiByZW1vdmFibGUpIHtcbiAgICAgIGRlbGV0ZSBvcHRpb25zW21vZHVsZS5vcHRpb25zS2V5XTtcbiAgICB9XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW9kdWxlL2NvcmVNb2R1bGVzVHlwZXMudHNcbmZ1bmN0aW9uIHBhbGV0dGVUeXBlKHBhcnRpYWwpIHtcbiAgaWYgKHBhcnRpYWw/LnVwIHx8IHBhcnRpYWw/LmRvd24gfHwgcGFydGlhbD8ubmV1dHJhbCkge1xuICAgIHJldHVybiBcInVzZXItZnVsbFwiO1xuICB9IGVsc2UgaWYgKHBhcnRpYWw/LmZpbGxzIHx8IHBhcnRpYWw/LnN0cm9rZXMpIHtcbiAgICByZXR1cm4gXCJ1c2VyLWluZGV4ZWRcIjtcbiAgfVxuICByZXR1cm4gXCJpbmJ1aWx0XCI7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9jaGFydFRoZW1lLnRzXG52YXIgREVGQVVMVF9CQUNLR1JPVU5EX0ZJTEwgPSBcIndoaXRlXCI7XG52YXIgQ0hBUlRfVFlQRV9DT05GSUcgPSB7XG4gIGdldCBjYXJ0ZXNpYW4oKSB7XG4gICAgcmV0dXJuIHsgc2VyaWVzVHlwZXM6IGNoYXJ0VHlwZXMyLmNhcnRlc2lhblR5cGVzLCBjb21tb25PcHRpb25zOiBbXCJ6b29tXCIsIFwibmF2aWdhdG9yXCJdIH07XG4gIH0sXG4gIGdldCBwb2xhcigpIHtcbiAgICByZXR1cm4geyBzZXJpZXNUeXBlczogY2hhcnRUeXBlczIucG9sYXJUeXBlcywgY29tbW9uT3B0aW9uczogW10gfTtcbiAgfSxcbiAgZ2V0IGhpZXJhcmNoeSgpIHtcbiAgICByZXR1cm4geyBzZXJpZXNUeXBlczogY2hhcnRUeXBlczIuaGllcmFyY2h5VHlwZXMsIGNvbW1vbk9wdGlvbnM6IFtdIH07XG4gIH0sXG4gIGdldCB0b3BvbG9neSgpIHtcbiAgICByZXR1cm4geyBzZXJpZXNUeXBlczogY2hhcnRUeXBlczIudG9wb2xvZ3lUeXBlcywgY29tbW9uT3B0aW9uczogW10gfTtcbiAgfSxcbiAgZ2V0IFwiZmxvdy1wcm9wb3J0aW9uXCIoKSB7XG4gICAgcmV0dXJuIHsgc2VyaWVzVHlwZXM6IGNoYXJ0VHlwZXMyLmZsb3dQcm9wb3J0aW9uVHlwZXMsIGNvbW1vbk9wdGlvbnM6IFtdIH07XG4gIH0sXG4gIGdldCBzdGFuZGFsb25lKCkge1xuICAgIHJldHVybiB7IHNlcmllc1R5cGVzOiBjaGFydFR5cGVzMi5zdGFuZGFsb25lVHlwZXMsIGNvbW1vbk9wdGlvbnM6IFtdIH07XG4gIH0sXG4gIGdldCBnYXVnZSgpIHtcbiAgICByZXR1cm4geyBzZXJpZXNUeXBlczogY2hhcnRUeXBlczIuZ2F1Z2VUeXBlcywgY29tbW9uT3B0aW9uczogW10gfTtcbiAgfVxufTtcbnZhciBQUkVTRVRfT1ZFUlJJREVTX1RZUEVTID0ge1xuICBcInJhZGlhbC1nYXVnZVwiOiB0cnVlLFxuICBcImxpbmVhci1nYXVnZVwiOiB0cnVlXG59O1xuZnVuY3Rpb24gaXNQcmVzZXRPdmVycmlkZXNUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIFBSRVNFVF9PVkVSUklERVNfVFlQRVNbdHlwZV0gPT09IHRydWU7XG59XG52YXIgQ0hBUlRfVFlQRV9TUEVDSUZJQ19DT01NT05fT1BUSU9OUyA9IE9iamVjdC52YWx1ZXMoQ0hBUlRfVFlQRV9DT05GSUcpLnJlZHVjZSgociwgeyBjb21tb25PcHRpb25zIH0pID0+IHIuY29uY2F0KGNvbW1vbk9wdGlvbnMpLCBbXSk7XG52YXIgX0NoYXJ0VGhlbWUgPSBjbGFzcyBfQ2hhcnRUaGVtZSB7XG4gIHN0YXRpYyBnZXRBeGlzRGVmYXVsdHMob3ZlcnJpZGVEZWZhdWx0cykge1xuICAgIHJldHVybiBtZXJnZURlZmF1bHRzKG92ZXJyaWRlRGVmYXVsdHMsIHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB0ZXh0OiBcIkF4aXMgVGl0bGVcIixcbiAgICAgICAgc3BhY2luZzogMjUsXG4gICAgICAgIGZvbnRXZWlnaHQ6IHsgJHJlZjogXCJmb250V2VpZ2h0XCIgfSxcbiAgICAgICAgZm9udFNpemU6IHsgJHJlbTogWzEuMDgzMzMzMzMzMzMzMzMzMyAvKiBNRURJVU0gKi9dIH0sXG4gICAgICAgIGZvbnRGYW1pbHk6IHsgJHJlZjogXCJmb250RmFtaWx5XCIgfSxcbiAgICAgICAgY29sb3I6IHsgJHJlZjogXCJ0ZXh0Q29sb3JcIiB9XG4gICAgICB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZm9udFNpemU6IHsgJHJlZjogXCJmb250U2l6ZVwiIH0sXG4gICAgICAgIGZvbnRGYW1pbHk6IHsgJHJlZjogXCJmb250RmFtaWx5XCIgfSxcbiAgICAgICAgZm9udFdlaWdodDogeyAkcmVmOiBcImZvbnRXZWlnaHRcIiB9LFxuICAgICAgICBzcGFjaW5nOiAxMSxcbiAgICAgICAgY29sb3I6IHsgJHJlZjogXCJ0ZXh0Q29sb3JcIiB9LFxuICAgICAgICBhdm9pZENvbGxpc2lvbnM6IHRydWVcbiAgICAgIH0sXG4gICAgICBsaW5lOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICBzdHJva2U6IHsgJHJlZjogXCJheGlzQ29sb3JcIiB9XG4gICAgICB9LFxuICAgICAgdGljazoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZTogeyAkcmVmOiBcImF4aXNDb2xvclwiIH1cbiAgICAgIH0sXG4gICAgICBncmlkTGluZToge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBzdHlsZTogW3sgc3Ryb2tlOiB7ICRyZWY6IFwiZ3JpZExpbmVDb2xvclwiIH0sIGxpbmVEYXNoOiBbXSB9XVxuICAgICAgfSxcbiAgICAgIGNyb3NzTGluZXM6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGZpbGw6IHsgJHJlZjogXCJmb3JlZ3JvdW5kQ29sb3JcIiB9LFxuICAgICAgICBzdHJva2U6IHsgJHJlZjogXCJmb3JlZ3JvdW5kQ29sb3JcIiB9LFxuICAgICAgICBmaWxsT3BhY2l0eTogMC4xLFxuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBmb250U2l6ZTogeyAkcmVmOiBcImZvbnRTaXplXCIgfSxcbiAgICAgICAgICBmb250RmFtaWx5OiB7ICRyZWY6IFwiZm9udEZhbWlseVwiIH0sXG4gICAgICAgICAgZm9udFdlaWdodDogeyAkcmVmOiBcImZvbnRXZWlnaHRcIiB9LFxuICAgICAgICAgIHBhZGRpbmc6IDUsXG4gICAgICAgICAgY29sb3I6IHsgJHJlZjogXCJ0ZXh0Q29sb3JcIiB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcm9zc2hhaXI6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldENoYXJ0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbkhlaWdodDogMzAwLFxuICAgICAgbWluV2lkdGg6IDMwMCxcbiAgICAgIGJhY2tncm91bmQ6IHsgdmlzaWJsZTogdHJ1ZSwgZmlsbDogeyAkcmVmOiBcImJhY2tncm91bmRDb2xvclwiIH0gfSxcbiAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgdG9wOiB7ICRyZWY6IFwicGFkZGluZ1wiIH0sXG4gICAgICAgIHJpZ2h0OiB7ICRyZWY6IFwicGFkZGluZ1wiIH0sXG4gICAgICAgIGJvdHRvbTogeyAkcmVmOiBcInBhZGRpbmdcIiB9LFxuICAgICAgICBsZWZ0OiB7ICRyZWY6IFwicGFkZGluZ1wiIH1cbiAgICAgIH0sXG4gICAgICBzZXJpZXNBcmVhOiB7XG4gICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGtleWJvYXJkOiB7IGVuYWJsZWQ6IHRydWUgfSxcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB0ZXh0OiBcIlRpdGxlXCIsXG4gICAgICAgIGZvbnRXZWlnaHQ6IHsgJHJlZjogXCJmb250V2VpZ2h0XCIgfSxcbiAgICAgICAgZm9udFNpemU6IHsgJHJlbTogWzEuNDE2NjY2NjY2NjY2NjY2NyAvKiBMQVJHRVNUICovXSB9LFxuICAgICAgICBmb250RmFtaWx5OiB7ICRyZWY6IFwiZm9udEZhbWlseVwiIH0sXG4gICAgICAgIGNvbG9yOiB7ICRyZWY6IFwidGV4dENvbG9yXCIgfSxcbiAgICAgICAgd3JhcHBpbmc6IFwiaHlwaGVuYXRlXCIsXG4gICAgICAgIGxheW91dFN0eWxlOiBERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFLFxuICAgICAgICB0ZXh0QWxpZ246IERFRkFVTFRfQ0FQVElPTl9BTElHTk1FTlRcbiAgICAgIH0sXG4gICAgICBzdWJ0aXRsZToge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgdGV4dDogXCJTdWJ0aXRsZVwiLFxuICAgICAgICBzcGFjaW5nOiAyMCxcbiAgICAgICAgZm9udFdlaWdodDogeyAkcmVmOiBcImZvbnRXZWlnaHRcIiB9LFxuICAgICAgICBmb250U2l6ZTogeyAkcmVtOiBbMS4wODMzMzMzMzMzMzMzMzMzIC8qIE1FRElVTSAqL10gfSxcbiAgICAgICAgZm9udEZhbWlseTogeyAkcmVmOiBcImZvbnRGYW1pbHlcIiB9LFxuICAgICAgICBjb2xvcjogeyAkcmVmOiBcInN1YnRsZVRleHRDb2xvclwiIH0sXG4gICAgICAgIHdyYXBwaW5nOiBcImh5cGhlbmF0ZVwiLFxuICAgICAgICBsYXlvdXRTdHlsZTogREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRSxcbiAgICAgICAgdGV4dEFsaWduOiBERUZBVUxUX0NBUFRJT05fQUxJR05NRU5UXG4gICAgICB9LFxuICAgICAgZm9vdG5vdGU6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHRleHQ6IFwiRm9vdG5vdGVcIixcbiAgICAgICAgc3BhY2luZzogMjAsXG4gICAgICAgIGZvbnRTaXplOiB7ICRyZW06IFsxLjA4MzMzMzMzMzMzMzMzMzMgLyogTUVESVVNICovXSB9LFxuICAgICAgICBmb250RmFtaWx5OiB7ICRyZWY6IFwiZm9udEZhbWlseVwiIH0sXG4gICAgICAgIGZvbnRXZWlnaHQ6IHsgJHJlZjogXCJmb250V2VpZ2h0XCIgfSxcbiAgICAgICAgY29sb3I6IHsgJHJlZjogXCJzdWJ0bGVUZXh0Q29sb3JcIiB9LFxuICAgICAgICB3cmFwcGluZzogXCJoeXBoZW5hdGVcIixcbiAgICAgICAgbGF5b3V0U3R5bGU6IERFRkFVTFRfQ0FQVElPTl9MQVlPVVRfU1RZTEUsXG4gICAgICAgIHRleHRBbGlnbjogREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVFxuICAgICAgfSxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBwb3NpdGlvbjogXCJib3R0b21cIiAvKiBCT1RUT00gKi8sXG4gICAgICAgIHNwYWNpbmc6IDMwLFxuICAgICAgICBsaXN0ZW5lcnM6IHt9LFxuICAgICAgICB0b2dnbGVTZXJpZXM6IHRydWUsXG4gICAgICAgIGl0ZW06IHtcbiAgICAgICAgICBwYWRkaW5nWDogMTYsXG4gICAgICAgICAgcGFkZGluZ1k6IDgsXG4gICAgICAgICAgbWFya2VyOiB7IHNpemU6IDE1LCBwYWRkaW5nOiA4IH0sXG4gICAgICAgICAgc2hvd1Nlcmllc1N0cm9rZTogdHJ1ZSxcbiAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgY29sb3I6IHsgJHJlZjogXCJ0ZXh0Q29sb3JcIiB9LFxuICAgICAgICAgICAgZm9udFNpemU6IHsgJHJlZjogXCJmb250U2l6ZVwiIH0sXG4gICAgICAgICAgICBmb250RmFtaWx5OiB7ICRyZWY6IFwiZm9udEZhbWlseVwiIH0sXG4gICAgICAgICAgICBmb250V2VpZ2h0OiB7ICRyZWY6IFwiZm9udFdlaWdodFwiIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJldmVyc2VPcmRlcjogZmFsc2UsXG4gICAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgICBtYXJrZXI6IHsgc2l6ZTogMTIgfSxcbiAgICAgICAgICBhY3RpdmVTdHlsZTogeyBmaWxsOiB7ICRyZWY6IFwiZm9yZWdyb3VuZENvbG9yXCIgfSB9LFxuICAgICAgICAgIGluYWN0aXZlU3R5bGU6IHsgZmlsbDogeyAkcmVmOiBcInN1YnRsZVRleHRDb2xvclwiIH0gfSxcbiAgICAgICAgICBoaWdobGlnaHRTdHlsZTogeyBmaWxsOiB7ICRyZWY6IFwiZm9yZWdyb3VuZENvbG9yXCIgfSB9LFxuICAgICAgICAgIGxhYmVsOiB7IGNvbG9yOiB7ICRyZWY6IFwidGV4dENvbG9yXCIgfSB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b29sdGlwOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGRhcmtUaGVtZTogSVNfREFSS19USEVNRSxcbiAgICAgICAgZGVsYXk6IDBcbiAgICAgIH0sXG4gICAgICBvdmVybGF5czogeyBkYXJrVGhlbWU6IElTX0RBUktfVEhFTUUgfSxcbiAgICAgIGxpc3RlbmVyczoge31cbiAgICB9O1xuICB9XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgb3ZlcnJpZGVzLCBwYWxldHRlIH0gPSBkZWVwQ2xvbmUob3B0aW9ucyk7XG4gICAgY29uc3QgZGVmYXVsdHMgPSB0aGlzLmNyZWF0ZUNoYXJ0Q29uZmlnUGVyQ2hhcnRUeXBlKHRoaXMuZ2V0RGVmYXVsdHMoKSk7XG4gICAgY29uc3QgcHJlc2V0cyA9IHt9O1xuICAgIGlmIChvdmVycmlkZXMpIHtcbiAgICAgIHRoaXMubWVyZ2VPdmVycmlkZXMoZGVmYXVsdHMsIHByZXNldHMsIG92ZXJyaWRlcyk7XG4gICAgfVxuICAgIGNvbnN0IHsgZmlsbHMsIHN0cm9rZXMsIC4uLm90aGVyQ29sb3JzIH0gPSB0aGlzLmdldERlZmF1bHRDb2xvcnMoKTtcbiAgICB0aGlzLnBhbGV0dGUgPSBkZWVwRnJlZXplKFxuICAgICAgbWVyZ2VEZWZhdWx0cyhwYWxldHRlLCB7XG4gICAgICAgIGZpbGxzOiBPYmplY3QudmFsdWVzKGZpbGxzKSxcbiAgICAgICAgc3Ryb2tlczogT2JqZWN0LnZhbHVlcyhzdHJva2VzKSxcbiAgICAgICAgLi4ub3RoZXJDb2xvcnNcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnBhbGV0dGVUeXBlID0gcGFsZXR0ZVR5cGUocGFsZXR0ZSk7XG4gICAgdGhpcy5jb25maWcgPSBkZWVwRnJlZXplKHRoaXMudGVtcGxhdGVUaGVtZShkZWZhdWx0cykpO1xuICAgIHRoaXMucHJlc2V0cyA9IGRlZXBGcmVlemUocHJlc2V0cyk7XG4gIH1cbiAgbWVyZ2VPdmVycmlkZXMoZGVmYXVsdHMsIHByZXNldHMsIG92ZXJyaWRlcykge1xuICAgIGZvciAoY29uc3QgeyBzZXJpZXNUeXBlcywgY29tbW9uT3B0aW9ucyB9IG9mIE9iamVjdC52YWx1ZXMoQ0hBUlRfVFlQRV9DT05GSUcpKSB7XG4gICAgICBjb25zdCBjbGVhbmVkQ29tbW9uID0geyAuLi5vdmVycmlkZXMuY29tbW9uIH07XG4gICAgICBmb3IgKGNvbnN0IGNvbW1vbktleSBvZiBDSEFSVF9UWVBFX1NQRUNJRklDX0NPTU1PTl9PUFRJT05TKSB7XG4gICAgICAgIGlmICghY29tbW9uT3B0aW9ucy5pbmNsdWRlcyhjb21tb25LZXkpKSB7XG4gICAgICAgICAgZGVsZXRlIGNsZWFuZWRDb21tb25bY29tbW9uS2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjbGVhbmVkQ29tbW9uKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGZvciAoY29uc3QgcyBvZiBzZXJpZXNUeXBlcykge1xuICAgICAgICBjb25zdCBzZXJpZXNUeXBlID0gcztcbiAgICAgICAgaWYgKCFpc1ByZXNldE92ZXJyaWRlc1R5cGUoc2VyaWVzVHlwZSkpIHtcbiAgICAgICAgICBkZWZhdWx0c1tzZXJpZXNUeXBlXSA9IG1lcmdlRGVmYXVsdHMoY2xlYW5lZENvbW1vbiwgZGVmYXVsdHNbc2VyaWVzVHlwZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNoYXJ0VHlwZXMyLnNlcmllc1R5cGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgIGNvbnN0IHNlcmllc1R5cGUgPSBzO1xuICAgICAgY29uc3Qgc2VyaWVzT3ZlcnJpZGVzID0gb3ZlcnJpZGVzW3Nlcmllc1R5cGVdO1xuICAgICAgaWYgKGlzUHJlc2V0T3ZlcnJpZGVzVHlwZShzZXJpZXNUeXBlKSkge1xuICAgICAgICBwcmVzZXRzW3Nlcmllc1R5cGVdID0gc2VyaWVzT3ZlcnJpZGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmYXVsdHNbc2VyaWVzVHlwZV0gPSBtZXJnZURlZmF1bHRzKHNlcmllc092ZXJyaWRlcywgZGVmYXVsdHNbc2VyaWVzVHlwZV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUNoYXJ0Q29uZmlnUGVyQ2hhcnRUeXBlKGNvbmZpZykge1xuICAgIGZvciAoY29uc3QgW25leHRUeXBlLCB7IHNlcmllc1R5cGVzIH1dIG9mIE9iamVjdC5lbnRyaWVzKENIQVJUX1RZUEVfQ09ORklHKSkge1xuICAgICAgY29uc3QgdHlwZURlZmF1bHRzID0gY2hhcnREZWZhdWx0cy5nZXQobmV4dFR5cGUpO1xuICAgICAgZm9yIChjb25zdCBzZXJpZXNUeXBlIG9mIHNlcmllc1R5cGVzKSB7XG4gICAgICAgIGNvbmZpZ1tzZXJpZXNUeXBlXSA/PyAoY29uZmlnW3Nlcmllc1R5cGVdID0gZGVlcENsb25lKHR5cGVEZWZhdWx0cykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIGdldERlZmF1bHRzKCkge1xuICAgIGNvbnN0IGdldE92ZXJyaWRlc0J5VHlwZSA9IChjaGFydFR5cGUsIHNlcmllc1R5cGVzKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGNvbnN0IGNoYXJ0VHlwZURlZmF1bHRzID0ge1xuICAgICAgICBheGVzOiB7fSxcbiAgICAgICAgLi4ubGVnZW5kUmVnaXN0cnkuZ2V0VGhlbWVUZW1wbGF0ZXMoKSxcbiAgICAgICAgLi4udGhpcy5nZXRDaGFydERlZmF1bHRzKCksXG4gICAgICAgIC4uLmNoYXJ0RGVmYXVsdHMuZ2V0KGNoYXJ0VHlwZSlcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IHNlcmllc1R5cGUgb2Ygc2VyaWVzVHlwZXMpIHtcbiAgICAgICAgcmVzdWx0W3Nlcmllc1R5cGVdID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgICAgICBzZXJpZXNSZWdpc3RyeS5nZXRUaGVtZVRlbXBsYXRlKHNlcmllc1R5cGUpLFxuICAgICAgICAgIHJlc3VsdFtzZXJpZXNUeXBlXSA/PyBkZWVwQ2xvbmUoY2hhcnRUeXBlRGVmYXVsdHMpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHsgYXhlcyB9ID0gcmVzdWx0W3Nlcmllc1R5cGVdO1xuICAgICAgICBmb3IgKGNvbnN0IGF4aXNUeXBlIG9mIGF4aXNSZWdpc3RyeS5rZXlzKCkpIHtcbiAgICAgICAgICBheGVzW2F4aXNUeXBlXSA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICAgICAgICBheGVzW2F4aXNUeXBlXSxcbiAgICAgICAgICAgIGF4aXNSZWdpc3RyeS5nZXRUaGVtZVRlbXBsYXRlKGF4aXNUeXBlKSxcbiAgICAgICAgICAgIF9DaGFydFRoZW1lLmNhcnRlc2lhbkF4aXNEZWZhdWx0W2F4aXNUeXBlXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gbWVyZ2VEZWZhdWx0cyhcbiAgICAgIGdldE92ZXJyaWRlc0J5VHlwZShcImNhcnRlc2lhblwiLCBjaGFydFR5cGVzMi5jYXJ0ZXNpYW5UeXBlcyksXG4gICAgICBnZXRPdmVycmlkZXNCeVR5cGUoXCJwb2xhclwiLCBjaGFydFR5cGVzMi5wb2xhclR5cGVzKSxcbiAgICAgIGdldE92ZXJyaWRlc0J5VHlwZShcImhpZXJhcmNoeVwiLCBjaGFydFR5cGVzMi5oaWVyYXJjaHlUeXBlcyksXG4gICAgICBnZXRPdmVycmlkZXNCeVR5cGUoXCJ0b3BvbG9neVwiLCBjaGFydFR5cGVzMi50b3BvbG9neVR5cGVzKSxcbiAgICAgIGdldE92ZXJyaWRlc0J5VHlwZShcImZsb3ctcHJvcG9ydGlvblwiLCBjaGFydFR5cGVzMi5mbG93UHJvcG9ydGlvblR5cGVzKSxcbiAgICAgIGdldE92ZXJyaWRlc0J5VHlwZShcInN0YW5kYWxvbmVcIiwgY2hhcnRUeXBlczIuc3RhbmRhbG9uZVR5cGVzKSxcbiAgICAgIGdldE92ZXJyaWRlc0J5VHlwZShcImdhdWdlXCIsIGNoYXJ0VHlwZXMyLmdhdWdlVHlwZXMpXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgYXBwbHlUZW1wbGF0ZVRoZW1lKG5vZGUsIF9vdGhlciwgcGFyYW1zKSB7XG4gICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzeW1ib2wgPSBub2RlW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHN5bWJvbCA9PT0gXCJzeW1ib2xcIiAmJiBwYXJhbXM/LmhhcyhzeW1ib2wpKSB7XG4gICAgICAgICAgbm9kZVtpXSA9IHBhcmFtcy5nZXQoc3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobm9kZSkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzeW1ib2xcIiAmJiBwYXJhbXM/Lmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICBub2RlW25hbWVdID0gcGFyYW1zLmdldCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGVtcGxhdGVUaGVtZSh0aGVtZVRlbXBsYXRlLCBjbG9uZTIgPSB0cnVlKSB7XG4gICAgY29uc3QgdGhlbWVJbnN0YW5jZSA9IGNsb25lMiA/IGRlZXBDbG9uZSh0aGVtZVRlbXBsYXRlKSA6IHRoZW1lVGVtcGxhdGU7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBqc29uV2Fsayh0aGVtZUluc3RhbmNlLCBfQ2hhcnRUaGVtZS5hcHBseVRlbXBsYXRlVGhlbWUsIHZvaWQgMCwgdm9pZCAwLCBwYXJhbXMpO1xuICAgIHJldHVybiB0aGVtZUluc3RhbmNlO1xuICB9XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiBERUZBVUxUX0ZJTExTLFxuICAgICAgc3Ryb2tlczogREVGQVVMVF9TVFJPS0VTLFxuICAgICAgdXA6IHsgZmlsbDogREVGQVVMVF9GSUxMUy5HUkVFTiwgc3Ryb2tlOiBERUZBVUxUX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogREVGQVVMVF9GSUxMUy5SRUQsIHN0cm9rZTogREVGQVVMVF9TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBERUZBVUxUX0ZJTExTLkdSQVksIHN0cm9rZTogREVGQVVMVF9TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IERFRkFVTFRfRklMTFMuQkxVRSwgc3Ryb2tlOiBERUZBVUxUX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBERUZBVUxUX0ZJTExTLk9SQU5HRSwgc3Ryb2tlOiBERUZBVUxUX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IERFRkFVTFRfRklMTFMuR1JBWSwgc3Ryb2tlOiBERUZBVUxUX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRQdWJsaWNQYXJhbWV0ZXJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhY2NlbnRDb2xvcjogXCIjMjE5NmYzXCIsXG4gICAgICBheGlzQ29sb3I6IHsgJGZvcmVncm91bmRCYWNrZ3JvdW5kTWl4OiBbMC42NzVdIH0sXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IERFRkFVTFRfQkFDS0dST1VORF9GSUxMLFxuICAgICAgYm9yZGVyQ29sb3I6IHsgJGZvcmVncm91bmRCYWNrZ3JvdW5kTWl4OiBbMC44MThdIH0sXG4gICAgICBmb3JlZ3JvdW5kQ29sb3I6IFwiIzQ2NDY0NlwiLFxuICAgICAgZm9udEZhbWlseTogXCJWZXJkYW5hLCBzYW5zLXNlcmlmXCIsXG4gICAgICBmb250U2l6ZTogMTIgLyogU01BTEwgKi8sXG4gICAgICBmb250V2VpZ2h0OiA0MDAsXG4gICAgICBncmlkTGluZUNvbG9yOiB7ICRmb3JlZ3JvdW5kQmFja2dyb3VuZEFjY2VudE1peDogWzAuOTMsIDAuMDg1XSB9LFxuICAgICAgcGFkZGluZzogMjAsXG4gICAgICBzdWJ0bGVUZXh0Q29sb3I6IHsgJG1peDogW3sgJHJlZjogXCJ0ZXh0Q29sb3JcIiB9LCB7ICRyZWY6IFwiYmFja2dyb3VuZENvbG9yXCIgfSwgMC4zOF0gfSxcbiAgICAgIHRleHRDb2xvcjogeyAkcmVmOiBcImZvcmVncm91bmRDb2xvclwiIH0sXG4gICAgICBjaHJvbWVCYWNrZ3JvdW5kQ29sb3I6IHsgJGZvcmVncm91bmRCYWNrZ3JvdW5kTWl4OiBbMC45NzVdIH0sXG4gICAgICBjaHJvbWVGb250RmFtaWx5OiB7ICRyZWY6IFwiZm9udEZhbWlseVwiIH0sXG4gICAgICBjaHJvbWVGb250U2l6ZTogeyAkcmVmOiBcImZvbnRTaXplXCIgfSxcbiAgICAgIGNocm9tZUZvbnRXZWlnaHQ6IHsgJHJlZjogXCJmb250V2VpZ2h0XCIgfSxcbiAgICAgIGNocm9tZVRleHRDb2xvcjogXCIjMTgxZDFmXCIsXG4gICAgICBjaHJvbWVTdWJ0bGVUZXh0Q29sb3I6IHsgJG1peDogW3sgJHJlZjogXCJjaHJvbWVUZXh0Q29sb3JcIiB9LCB7ICRyZWY6IFwiYmFja2dyb3VuZENvbG9yXCIgfSwgMC4zOF0gfSxcbiAgICAgIGlucHV0QmFja2dyb3VuZENvbG9yOiB7ICRyZWY6IFwiYmFja2dyb3VuZENvbG9yXCIgfSxcbiAgICAgIGlucHV0VGV4dENvbG9yOiB7ICRyZWY6IFwidGV4dENvbG9yXCIgfSxcbiAgICAgIGNyb3NzaGFpckxhYmVsQmFja2dyb3VuZENvbG9yOiB7ICRyZWY6IFwiZm9yZWdyb3VuZENvbG9yXCIgfSxcbiAgICAgIGNyb3NzaGFpckxhYmVsVGV4dENvbG9yOiB7ICRyZWY6IFwiYmFja2dyb3VuZENvbG9yXCIgfVxuICAgIH07XG4gIH1cbiAgLy8gUHJpdmF0ZSBwYXJhbWV0ZXJzIHRoYXQgYXJlIG5vdCBleHBvc2VkIGluIHRoZSB0aGVtZXMgQVBJLlxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgeyBpc0VudGVycHJpc2UgfSA9IGVudGVycHJpc2VNb2R1bGU7XG4gICAgY29uc3QgcGFyYW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBwYXJhbXMuc2V0KElTX0RBUktfVEhFTUUsIGZhbHNlKTtcbiAgICBwYXJhbXMuc2V0KElTX0VOVEVSUFJJU0UsIGlzRW50ZXJwcmlzZSk7XG4gICAgcGFyYW1zLnNldChJU19DT01NVU5JVFksICFpc0VudGVycHJpc2UpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9TRVBBUkFUSU9OX0xJTkVTX0NPTE9VUiwgXCIjZDlkOWQ5XCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9VUiwgREVGQVVMVF9CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9TSEFET1dfQ09MT1VSLCBcIiMwMDAwMDA4MFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgREVGQVVMVF9GSUxMUy5PUkFOR0UsXG4gICAgICBERUZBVUxUX0ZJTExTLllFTExPVyxcbiAgICAgIERFRkFVTFRfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQ09MT1JfUkFOR0UsIFtERUZBVUxUX0ZJTExTLkJMVUUsIERFRkFVTFRfRklMTFMuUkVEXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1NQQVJLTElORV9DUk9TU0hBSVJfU1RST0tFLCBcIiNhYWFcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0dBVUdFX1NFUklFU19DT0xPUl9SQU5HRSwgW0RFRkFVTFRfRklMTFMuR1JFRU4sIERFRkFVTFRfRklMTFMuWUVMTE9XLCBERUZBVUxUX0ZJTExTLlJFRF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GVU5ORUxfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBcIiM1MDkwZGNcIixcbiAgICAgIFwiIzYyOWJlMFwiLFxuICAgICAgXCIjNzNhNmUzXCIsXG4gICAgICBcIiM4NWIxZTdcIixcbiAgICAgIFwiIzk2YmNlYVwiLFxuICAgICAgXCIjYThjOGVlXCIsXG4gICAgICBcIiNiOWQzZjFcIixcbiAgICAgIFwiI2NiZGVmNVwiXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFLCBcImJsb2NrXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVCwgXCJjZW50ZXJcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0hJRVJBUkNIWV9GSUxMUywgW1wiI2ZmZlwiLCBcIiNlMGU1ZWFcIiwgXCIjYzFjY2Q1XCIsIFwiI2EzYjRjMVwiLCBcIiM4NTljYWRcIl0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ISUVSQVJDSFlfU1RST0tFUywgW1wiI2ZmZlwiLCBcIiNjNWNiZDFcIiwgXCIjYTRiMWJkXCIsIFwiIzg0OThhOVwiLCBcIiM2NDgwOTZcIl0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GSUJPTkFDQ0lfU1RST0tFUywgW1xuICAgICAgXCIjNzk3Yjg2XCIsXG4gICAgICBcIiNlMjRjNGFcIixcbiAgICAgIFwiI2Y0OWQyZFwiLFxuICAgICAgXCIjNjVhYjU4XCIsXG4gICAgICBcIiM0MDk2ODJcIixcbiAgICAgIFwiIzRkYjlkMlwiLFxuICAgICAgXCIjNTA5MGRjXCIsXG4gICAgICBcIiMzMDY4ZjlcIixcbiAgICAgIFwiI2UyNGM0YVwiLFxuICAgICAgXCIjOTEzYWFjXCIsXG4gICAgICBcIiNkOTNlNjRcIlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9QT0xBUl9TRVJJRVNfU1RST0tFLCBERUZBVUxUX0JBQ0tHUk9VTkRfRklMTCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZJTkFOQ0lBTF9DSEFSVFNfQU5OT1RBVElPTl9DT0xPUiwgREVGQVVMVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRklOQU5DSUFMX0NIQVJUU19BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgREVGQVVMVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVF9BTk5PVEFUSU9OX0NPTE9SLCBERUZBVUxUX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0hBTkRMRV9GSUxMLCBERUZBVUxUX0JBQ0tHUk9VTkRfRklMTCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19GSUxMLCBcIiNmYWZhZmFcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19TVFJPS0UsIFwiI2RkZFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0NPTE9SLCBcIiMwMDBcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19ESVZJREVSX1NUUk9LRSwgXCIjMTgxZDFmXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRE9XTl9GSUxMLCBcIiNlMzVjNWNcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19ET1dOX1NUUk9LRSwgXCIjZTM1YzVjXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9URVhUQk9YX0ZJTEwsIFwiI2ZhZmFmYVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVEJPWF9TVFJPS0UsIFwiI2RkZFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVEJPWF9DT0xPUiwgXCIjMDAwXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9UT09MQkFSX1BPU0lUSU9OLCBcInRvcFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCwgZmFsc2UpO1xuICAgIGNvbnN0IGRlZmF1bHRDb2xvcnMgPSB0aGlzLmdldERlZmF1bHRDb2xvcnMoKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfVVBfU1RST0tFLCB0aGlzLnBhbGV0dGUudXA/LnN0cm9rZSA/PyBkZWZhdWx0Q29sb3JzLnVwLnN0cm9rZSk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX1VQX0ZJTEwsIHRoaXMucGFsZXR0ZS51cD8uZmlsbCA/PyBkZWZhdWx0Q29sb3JzLnVwLmZpbGwpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9ET1dOX1NUUk9LRSwgdGhpcy5wYWxldHRlLmRvd24/LnN0cm9rZSA/PyBkZWZhdWx0Q29sb3JzLmRvd24uc3Ryb2tlKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfRE9XTl9GSUxMLCB0aGlzLnBhbGV0dGUuZG93bj8uZmlsbCA/PyBkZWZhdWx0Q29sb3JzLmRvd24uZmlsbCk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX05FVVRSQUxfU1RST0tFLCB0aGlzLnBhbGV0dGUubmV1dHJhbD8uc3Ryb2tlID8/IGRlZmF1bHRDb2xvcnMubmV1dHJhbC5zdHJva2UpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9ORVVUUkFMX0ZJTEwsIHRoaXMucGFsZXR0ZS5uZXV0cmFsPy5maWxsID8/IGRlZmF1bHRDb2xvcnMubmV1dHJhbC5maWxsKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfQUxUX1VQX1NUUk9LRSwgdGhpcy5wYWxldHRlLmFsdFVwPy5zdHJva2UgPz8gZGVmYXVsdENvbG9ycy51cC5zdHJva2UpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9BTFRfVVBfRklMTCwgdGhpcy5wYWxldHRlLmFsdFVwPy5maWxsID8/IGRlZmF1bHRDb2xvcnMudXAuZmlsbCk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX0FMVF9ET1dOX1NUUk9LRSwgdGhpcy5wYWxldHRlLmFsdERvd24/LnN0cm9rZSA/PyBkZWZhdWx0Q29sb3JzLmRvd24uc3Ryb2tlKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfQUxUX0RPV05fRklMTCwgdGhpcy5wYWxldHRlLmFsdERvd24/LmZpbGwgPz8gZGVmYXVsdENvbG9ycy5kb3duLmZpbGwpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9BTFRfTkVVVFJBTF9GSUxMLCB0aGlzLnBhbGV0dGUuYWx0TmV1dHJhbD8uZmlsbCA/PyBkZWZhdWx0Q29sb3JzLmFsdE5ldXRyYWwuZmlsbCk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX0FMVF9ORVVUUkFMX1NUUk9LRSwgdGhpcy5wYWxldHRlLmFsdE5ldXRyYWw/LnN0cm9rZSA/PyBkZWZhdWx0Q29sb3JzLmFsdE5ldXRyYWwuc3Ryb2tlKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuX0NoYXJ0VGhlbWUuY2FydGVzaWFuQXhpc0RlZmF1bHQgPSB7XG4gIFtcIm51bWJlclwiIC8qIE5VTUJFUiAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7XG4gICAgbGluZTogeyBlbmFibGVkOiBmYWxzZSB9XG4gIH0pLFxuICBbXCJsb2dcIiAvKiBMT0cgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIGJhc2U6IDEwLFxuICAgIGxpbmU6IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICBpbnRlcnZhbDogeyBtaW5TcGFjaW5nOiBOYU4gfVxuICB9KSxcbiAgW1wiY2F0ZWdvcnlcIiAvKiBDQVRFR09SWSAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7XG4gICAgZ3JvdXBQYWRkaW5nSW5uZXI6IDAuMSxcbiAgICBsYWJlbDogeyBhdXRvUm90YXRlOiB0cnVlIH0sXG4gICAgZ3JpZExpbmU6IHsgZW5hYmxlZDogREVGQVVMVF9HUklETElORV9FTkFCTEVEIH0sXG4gICAgY3Jvc3NoYWlyOiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAgfSksXG4gIFtcImdyb3VwZWQtY2F0ZWdvcnlcIiAvKiBHUk9VUEVEX0NBVEVHT1JZICovXTogX0NoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKHtcbiAgICB0aWNrOiB7IGVuYWJsZWQ6IHRydWUsIHN0cm9rZTogREVGQVVMVF9TRVBBUkFUSU9OX0xJTkVTX0NPTE9VUiB9LFxuICAgIGxhYmVsOiB7IHNwYWNpbmc6IDEwLCByb3RhdGlvbjogMjcwIH0sXG4gICAgcGFkZGluZ0lubmVyOiAwLjQsXG4gICAgZ3JvdXBQYWRkaW5nSW5uZXI6IDAuMixcbiAgICBjcm9zc2hhaXI6IHsgZW5hYmxlZDogZmFsc2UgfVxuICB9KSxcbiAgW1widGltZVwiIC8qIFRJTUUgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoeyBncmlkTGluZTogeyBlbmFibGVkOiBERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQgfSB9KSxcbiAgW1wib3JkaW5hbC10aW1lXCIgLyogT1JESU5BTF9USU1FICovXTogX0NoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKHtcbiAgICBncm91cFBhZGRpbmdJbm5lcjogMCxcbiAgICBsYWJlbDogeyBhdXRvUm90YXRlOiBmYWxzZSB9LFxuICAgIGdyaWRMaW5lOiB7IGVuYWJsZWQ6IERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCB9XG4gIH0pLFxuICBbXCJhbmdsZS1jYXRlZ29yeVwiIC8qIEFOR0xFX0NBVEVHT1JZICovXTogX0NoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKHtcbiAgICBsYWJlbDogeyBzcGFjaW5nOiA1IH0sXG4gICAgZ3JpZExpbmU6IHsgZW5hYmxlZDogREVGQVVMVF9HUklETElORV9FTkFCTEVEIH1cbiAgfSksXG4gIFtcImFuZ2xlLW51bWJlclwiIC8qIEFOR0xFX05VTUJFUiAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7XG4gICAgbGFiZWw6IHsgc3BhY2luZzogNSB9LFxuICAgIGdyaWRMaW5lOiB7IGVuYWJsZWQ6IERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCB9XG4gIH0pLFxuICBbXCJyYWRpdXMtY2F0ZWdvcnlcIiAvKiBSQURJVVNfQ0FURUdPUlkgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIGxpbmU6IHsgZW5hYmxlZDogZmFsc2UgfVxuICB9KSxcbiAgW1wicmFkaXVzLW51bWJlclwiIC8qIFJBRElVU19OVU1CRVIgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIGxpbmU6IHsgZW5hYmxlZDogZmFsc2UgfVxuICB9KVxufTtcbnZhciBDaGFydFRoZW1lID0gX0NoYXJ0VGhlbWU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9kYXJrVGhlbWUudHNcbnZhciBERUZBVUxUX0RBUktfQkFDS0dST1VORF9GSUxMID0gXCIjMTkyMjMyXCI7XG52YXIgREVGQVVMVF9EQVJLX0ZJTExTID0ge1xuICBCTFVFOiBcIiM1MDkwZGNcIixcbiAgT1JBTkdFOiBcIiNmZmEwM2FcIixcbiAgR1JFRU46IFwiIzQ1OWQ1NVwiLFxuICBDWUFOOiBcIiMzNGJmZTFcIixcbiAgWUVMTE9XOiBcIiNlMWNjMDBcIixcbiAgVklPTEVUOiBcIiM5NjY5Y2JcIixcbiAgR1JBWTogXCIjYjViNWI1XCIsXG4gIE1BR0VOVEE6IFwiI2JkNWFhN1wiLFxuICBCUk9XTjogXCIjOGE2MjI0XCIsXG4gIFJFRDogXCIjZWY1NDUyXCJcbn07XG52YXIgREVGQVVMVF9EQVJLX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzc0YThlNlwiLFxuICBPUkFOR0U6IFwiI2ZmYmU3MFwiLFxuICBHUkVFTjogXCIjNmNiMTc2XCIsXG4gIENZQU46IFwiIzc1ZDRlZlwiLFxuICBZRUxMT1c6IFwiI2Y2ZTU1OVwiLFxuICBWSU9MRVQ6IFwiI2FhODZkOFwiLFxuICBHUkFZOiBcIiNhMWExYTFcIixcbiAgTUFHRU5UQTogXCIjY2U3YWI5XCIsXG4gIEJST1dOOiBcIiM5OTdiNTJcIixcbiAgUkVEOiBcIiNmZjc4NzJcIlxufTtcbnZhciBEYXJrVGhlbWUgPSBjbGFzcyBleHRlbmRzIENoYXJ0VGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogREVGQVVMVF9EQVJLX0ZJTExTLFxuICAgICAgc3Ryb2tlczogREVGQVVMVF9EQVJLX1NUUk9LRVMsXG4gICAgICB1cDogeyBmaWxsOiBERUZBVUxUX0RBUktfRklMTFMuR1JFRU4sIHN0cm9rZTogREVGQVVMVF9EQVJLX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogREVGQVVMVF9EQVJLX0ZJTExTLlJFRCwgc3Ryb2tlOiBERUZBVUxUX0RBUktfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogREVGQVVMVF9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogREVGQVVMVF9EQVJLX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogREVGQVVMVF9EQVJLX0ZJTExTLkJMVUUsIHN0cm9rZTogREVGQVVMVF9EQVJLX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBERUZBVUxUX0RBUktfRklMTFMuT1JBTkdFLCBzdHJva2U6IERFRkFVTFRfREFSS19TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBERUZBVUxUX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBERUZBVUxUX0RBUktfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFB1YmxpY1BhcmFtZXRlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmdldFB1YmxpY1BhcmFtZXRlcnMoKSxcbiAgICAgIGF4aXNDb2xvcjogeyAkZm9yZWdyb3VuZEJhY2tncm91bmRNaXg6IFswLjI2M10gfSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogREVGQVVMVF9EQVJLX0JBQ0tHUk9VTkRfRklMTCxcbiAgICAgIGJvcmRlckNvbG9yOiB7ICRmb3JlZ3JvdW5kQmFja2dyb3VuZE1peDogWzAuNzg0XSB9LFxuICAgICAgY2hyb21lQmFja2dyb3VuZENvbG9yOiB7ICRmb3JlZ3JvdW5kQmFja2dyb3VuZE1peDogWzAuOTNdIH0sXG4gICAgICBmb3JlZ3JvdW5kQ29sb3I6IFwiI2ZmZlwiLFxuICAgICAgZ3JpZExpbmVDb2xvcjogeyAkZm9yZWdyb3VuZEJhY2tncm91bmRBY2NlbnRNaXg6IFswLjc0MywgMC4wMV0gfSxcbiAgICAgIHN1YnRsZVRleHRDb2xvcjogeyAkbWl4OiBbeyAkcmVmOiBcInRleHRDb2xvclwiIH0sIHsgJHJlZjogXCJiYWNrZ3JvdW5kQ29sb3JcIiB9LCAwLjU3XSB9LFxuICAgICAgY2hyb21lVGV4dENvbG9yOiB7ICRyZWY6IFwidGV4dENvbG9yXCIgfSxcbiAgICAgIGNyb3NzaGFpckxhYmVsQmFja2dyb3VuZENvbG9yOiB7ICRmb3JlZ3JvdW5kQmFja2dyb3VuZEFjY2VudE1peDogWzAuMzUsIDAuMV0gfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoSVNfREFSS19USEVNRSwgdHJ1ZSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1BPTEFSX1NFUklFU19TVFJPS0UsIERFRkFVTFRfREFSS19CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9TRVBBUkFUSU9OX0xJTkVTX0NPTE9VUiwgXCIjN2Y4Mzg5XCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBERUZBVUxUX0RBUktfRklMTFMuT1JBTkdFLFxuICAgICAgREVGQVVMVF9EQVJLX0ZJTExTLllFTExPVyxcbiAgICAgIERFRkFVTFRfREFSS19GSUxMUy5HUkVFTlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9HQVVHRV9TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIERFRkFVTFRfREFSS19GSUxMUy5HUkVFTixcbiAgICAgIERFRkFVTFRfREFSS19GSUxMUy5ZRUxMT1csXG4gICAgICBERUZBVUxUX0RBUktfRklMTFMuUkVEXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZVTk5FTF9TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIFwiIzUwOTBkY1wiLFxuICAgICAgXCIjNDg4MmM2XCIsXG4gICAgICBcIiM0MDczYjBcIixcbiAgICAgIFwiIzM4NjU5YVwiLFxuICAgICAgXCIjMzA1Njg0XCIsXG4gICAgICBcIiMyODQ4NmVcIixcbiAgICAgIFwiIzIwM2E1OFwiLFxuICAgICAgXCIjMTgyYjQyXCJcbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfSElFUkFSQ0hZX0ZJTExTLCBbXCIjMTkyODM0XCIsIFwiIzI1Mzc0NlwiLCBcIiMzMjQ4NTlcIiwgXCIjM2Y1OTZjXCIsIFwiIzRkNmE4MFwiXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0hJRVJBUkNIWV9TVFJPS0VTLCBbXCIjMTkyODM0XCIsIFwiIzNiNTE2NFwiLCBcIiM0OTYyNzVcIiwgXCIjNTc3Mjg3XCIsIFwiIzY2ODM5OVwiXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1VSLCBERUZBVUxUX0RBUktfQkFDS0dST1VORF9GSUxMKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRklOQU5DSUFMX0NIQVJUU19BTk5PVEFUSU9OX0NPTE9SLCBERUZBVUxUX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RFWFRfQU5OT1RBVElPTl9DT0xPUiwgXCIjZmZmXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GSU5BTkNJQUxfQ0hBUlRTX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBERUZBVUxUX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fSEFORExFX0ZJTEwsIERFRkFVTFRfREFSS19CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRklMTCwgXCIjMjgzMTNlXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfU1RST0tFLCBcIiM0YjUyNWRcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19DT0xPUiwgXCIjZmZmXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRElWSURFUl9TVFJPS0UsIFwiI2ZmZlwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVEJPWF9GSUxMLCBcIiMyODMxM2VcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RFWFRCT1hfU1RST0tFLCBcIiM0YjUyNWRcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RFWFRCT1hfQ09MT1IsIFwiI2ZmZlwiKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL2ZpbmFuY2lhbERhcmsudHNcbnZhciBGSU5BTkNJQUxfREFSS19GSUxMUyA9IHtcbiAgR1JFRU46IFwiIzA4OTk4MVwiLFxuICBSRUQ6IFwiI0YyMzY0NVwiLFxuICBCTFVFOiBcIiM1MDkwZGNcIixcbiAgR1JBWTogXCIjQTlBOUE5XCJcbn07XG52YXIgRklOQU5DSUFMX0RBUktfU1RST0tFUyA9IHtcbiAgR1JFRU46IFwiIzA4OTk4MVwiLFxuICBSRUQ6IFwiI0YyMzY0NVwiLFxuICBCTFVFOiBcIiM1MDkwZGNcIixcbiAgR1JBWTogXCIjOTA5MDkwXCJcbn07XG52YXIgRmluYW5jaWFsRGFyayA9IGNsYXNzIGV4dGVuZHMgRGFya1RoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IHsgLi4uRklOQU5DSUFMX0RBUktfRklMTFMgfSxcbiAgICAgIHN0cm9rZXM6IHsgLi4uRklOQU5DSUFMX0RBUktfU1RST0tFUyB9LFxuICAgICAgdXA6IHsgZmlsbDogRklOQU5DSUFMX0RBUktfRklMTFMuR1JFRU4sIHN0cm9rZTogRklOQU5DSUFMX0RBUktfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBGSU5BTkNJQUxfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogRklOQU5DSUFMX0RBUktfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogRklOQU5DSUFMX0RBUktfRklMTFMuQkxVRSwgc3Ryb2tlOiBGSU5BTkNJQUxfREFSS19TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IEZJTkFOQ0lBTF9EQVJLX0ZJTExTLkdSRUVOLCBzdHJva2U6IEZJTkFOQ0lBTF9EQVJLX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogRklOQU5DSUFMX0RBUktfRklMTFMuUkVELCBzdHJva2U6IEZJTkFOQ0lBTF9EQVJLX1NUUk9LRVMuUkVEIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IEZJTkFOQ0lBTF9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogRklOQU5DSUFMX0RBUktfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFB1YmxpY1BhcmFtZXRlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmdldFB1YmxpY1BhcmFtZXRlcnMoKSxcbiAgICAgIGdyaWRMaW5lQ29sb3I6IHsgJGZvcmVncm91bmRCYWNrZ3JvdW5kQWNjZW50TWl4OiBbMC44OCwgMC4wMV0gfSxcbiAgICAgIHBhZGRpbmc6IDBcbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgRklOQU5DSUFMX0RBUktfRklMTFMuR1JFRU4sXG4gICAgICBGSU5BTkNJQUxfREFSS19GSUxMUy5CTFVFLFxuICAgICAgRklOQU5DSUFMX0RBUktfRklMTFMuUkVEXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZJTkFOQ0lBTF9DSEFSVFNfQU5OT1RBVElPTl9DT0xPUiwgRklOQU5DSUFMX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZJTkFOQ0lBTF9DSEFSVFNfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIEZJTkFOQ0lBTF9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRSwgXCJvdmVybGF5XCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVCwgXCJsZWZ0XCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9UT09MQkFSX1BPU0lUSU9OLCBcImJvdHRvbVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL2ZpbmFuY2lhbExpZ2h0LnRzXG52YXIgRklOQU5DSUFMX0xJR0hUX0ZJTExTID0ge1xuICBHUkVFTjogXCIjMDg5OTgxXCIsXG4gIFJFRDogXCIjRjIzNjQ1XCIsXG4gIEJMVUU6IFwiIzUwOTBkY1wiLFxuICBHUkFZOiBcIiNBOUE5QTlcIlxufTtcbnZhciBGSU5BTkNJQUxfTElHSFRfU1RST0tFUyA9IHtcbiAgR1JFRU46IFwiIzA4OTk4MVwiLFxuICBSRUQ6IFwiI0YyMzY0NVwiLFxuICBCTFVFOiBcIiM1MDkwZGNcIixcbiAgR1JBWTogXCIjOTA5MDkwXCJcbn07XG52YXIgRmluYW5jaWFsTGlnaHQgPSBjbGFzcyBleHRlbmRzIENoYXJ0VGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogeyAuLi5GSU5BTkNJQUxfTElHSFRfRklMTFMgfSxcbiAgICAgIHN0cm9rZXM6IHsgLi4uRklOQU5DSUFMX0xJR0hUX1NUUk9LRVMgfSxcbiAgICAgIHVwOiB7IGZpbGw6IEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5HUkVFTiwgc3Ryb2tlOiBGSU5BTkNJQUxfTElHSFRfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBGSU5BTkNJQUxfTElHSFRfRklMTFMuUkVELCBzdHJva2U6IEZJTkFOQ0lBTF9MSUdIVF9TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBGSU5BTkNJQUxfTElHSFRfRklMTFMuQkxVRSwgc3Ryb2tlOiBGSU5BTkNJQUxfTElHSFRfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBGSU5BTkNJQUxfTElHSFRfRklMTFMuR1JFRU4sIHN0cm9rZTogRklOQU5DSUFMX0xJR0hUX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogRklOQU5DSUFMX0xJR0hUX0ZJTExTLlJFRCwgc3Ryb2tlOiBGSU5BTkNJQUxfTElHSFRfU1RST0tFUy5SRUQgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogRklOQU5DSUFMX0xJR0hUX0ZJTExTLkdSQVksIHN0cm9rZTogRklOQU5DSUFMX0xJR0hUX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRQdWJsaWNQYXJhbWV0ZXJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5nZXRQdWJsaWNQYXJhbWV0ZXJzKCksXG4gICAgICBncmlkTGluZUNvbG9yOiB7ICRmb3JlZ3JvdW5kQmFja2dyb3VuZEFjY2VudE1peDogWzAuOTQsIDAuMDFdIH0sXG4gICAgICBwYWRkaW5nOiAwXG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5HUkVFTixcbiAgICAgIEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5CTFVFLFxuICAgICAgRklOQU5DSUFMX0xJR0hUX0ZJTExTLlJFRFxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GSU5BTkNJQUxfQ0hBUlRTX0FOTk9UQVRJT05fQ09MT1IsIEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRklOQU5DSUFMX0NIQVJUU19BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgRklOQU5DSUFMX0xJR0hUX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRSwgXCJvdmVybGF5XCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVCwgXCJsZWZ0XCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9UT09MQkFSX1BPU0lUSU9OLCBcImJvdHRvbVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL21hdGVyaWFsRGFyay50c1xudmFyIE1BVEVSSUFMX0RBUktfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzIxOTZGM1wiLFxuICBPUkFOR0U6IFwiI0ZGOTgwMFwiLFxuICBHUkVFTjogXCIjNENBRjUwXCIsXG4gIENZQU46IFwiIzAwQkNENFwiLFxuICBZRUxMT1c6IFwiI0ZGRUIzQlwiLFxuICBWSU9MRVQ6IFwiIzdFNTdDMlwiLFxuICBHUkFZOiBcIiM5RTlFOUVcIixcbiAgTUFHRU5UQTogXCIjRjA2MjkyXCIsXG4gIEJST1dOOiBcIiM3OTU1NDhcIixcbiAgUkVEOiBcIiNGNDQzMzZcIlxufTtcbnZhciBNQVRFUklBTF9EQVJLX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzkwQ0FGOVwiLFxuICBPUkFOR0U6IFwiI0ZGQ0M4MFwiLFxuICBHUkVFTjogXCIjQTVENkE3XCIsXG4gIENZQU46IFwiIzgwREVFQVwiLFxuICBZRUxMT1c6IFwiI0ZGRjlDNFwiLFxuICBWSU9MRVQ6IFwiI0IzOUREQlwiLFxuICBHUkFZOiBcIiNFMEUwRTBcIixcbiAgTUFHRU5UQTogXCIjRjQ4RkIxXCIsXG4gIEJST1dOOiBcIiNBMTg4N0ZcIixcbiAgUkVEOiBcIiNFRjlBOUFcIlxufTtcbnZhciBNYXRlcmlhbERhcmsgPSBjbGFzcyBleHRlbmRzIERhcmtUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiBNQVRFUklBTF9EQVJLX0ZJTExTLFxuICAgICAgc3Ryb2tlczogTUFURVJJQUxfREFSS19TVFJPS0VTLFxuICAgICAgdXA6IHsgZmlsbDogTUFURVJJQUxfREFSS19GSUxMUy5HUkVFTiwgc3Ryb2tlOiBNQVRFUklBTF9EQVJLX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogTUFURVJJQUxfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogTUFURVJJQUxfREFSS19TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBNQVRFUklBTF9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogTUFURVJJQUxfREFSS19TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IE1BVEVSSUFMX0RBUktfRklMTFMuQkxVRSwgc3Ryb2tlOiBNQVRFUklBTF9EQVJLX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBNQVRFUklBTF9EQVJLX0ZJTExTLlJFRCwgc3Ryb2tlOiBNQVRFUklBTF9EQVJLX1NUUk9LRVMuUkVEIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IE1BVEVSSUFMX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBNQVRFUklBTF9EQVJLX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIE1BVEVSSUFMX0RBUktfRklMTFMuT1JBTkdFLFxuICAgICAgTUFURVJJQUxfREFSS19GSUxMUy5ZRUxMT1csXG4gICAgICBNQVRFUklBTF9EQVJLX0ZJTExTLkdSRUVOXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZVTk5FTF9TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIFwiIzIxOTZmM1wiLFxuICAgICAgLy8gNTAwXG4gICAgICBcIiMyMDhGRUNcIixcbiAgICAgIC8vIChpbnRlcnBvbGF0ZWQpXG4gICAgICBcIiMxRTg4RTVcIixcbiAgICAgIC8vIDYwMFxuICAgICAgXCIjMUM3RkRDXCIsXG4gICAgICAvLyAoaW50ZXJwb2xhdGVkKVxuICAgICAgXCIjMTk3NmQyXCIsXG4gICAgICAvLyA3MDBcbiAgICAgIFwiIzE3NkVDOVwiLFxuICAgICAgLy8gKGludGVycG9sYXRlZClcbiAgICAgIFwiIzE1NjVjMFwiXG4gICAgICAvLyA4MDBcbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR0FVR0VfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBNQVRFUklBTF9EQVJLX0ZJTExTLkdSRUVOLFxuICAgICAgTUFURVJJQUxfREFSS19GSUxMUy5ZRUxMT1csXG4gICAgICBNQVRFUklBTF9EQVJLX0ZJTExTLlJFRFxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GSU5BTkNJQUxfQ0hBUlRTX0FOTk9UQVRJT05fQ09MT1IsIE1BVEVSSUFMX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZJTkFOQ0lBTF9DSEFSVFNfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIE1BVEVSSUFMX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL21hdGVyaWFsTGlnaHQudHNcbnZhciBNQVRFUklBTF9MSUdIVF9GSUxMUyA9IHtcbiAgQkxVRTogXCIjMjE5NkYzXCIsXG4gIE9SQU5HRTogXCIjRkY5ODAwXCIsXG4gIEdSRUVOOiBcIiM0Q0FGNTBcIixcbiAgQ1lBTjogXCIjMDBCQ0Q0XCIsXG4gIFlFTExPVzogXCIjRkZFQjNCXCIsXG4gIFZJT0xFVDogXCIjN0U1N0MyXCIsXG4gIEdSQVk6IFwiIzlFOUU5RVwiLFxuICBNQUdFTlRBOiBcIiNGMDYyOTJcIixcbiAgQlJPV046IFwiIzc5NTU0OFwiLFxuICBSRUQ6IFwiI0Y0NDMzNlwiXG59O1xudmFyIE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzE1NjVDMFwiLFxuICBPUkFOR0U6IFwiI0U2NTEwMFwiLFxuICBHUkVFTjogXCIjMkU3RDMyXCIsXG4gIENZQU46IFwiIzAwODM4RlwiLFxuICBZRUxMT1c6IFwiI0Y5QTgyNVwiLFxuICBWSU9MRVQ6IFwiIzQ1MjdBMFwiLFxuICBHUkFZOiBcIiM2MTYxNjFcIixcbiAgTUFHRU5UQTogXCIjQzIxODVCXCIsXG4gIEJST1dOOiBcIiM0RTM0MkVcIixcbiAgUkVEOiBcIiNCNzFDMUNcIlxufTtcbnZhciBNYXRlcmlhbExpZ2h0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydFRoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IE1BVEVSSUFMX0xJR0hUX0ZJTExTLFxuICAgICAgc3Ryb2tlczogTUFURVJJQUxfTElHSFRfU1RST0tFUyxcbiAgICAgIHVwOiB7IGZpbGw6IE1BVEVSSUFMX0xJR0hUX0ZJTExTLkdSRUVOLCBzdHJva2U6IE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMuR1JFRU4gfSxcbiAgICAgIGRvd246IHsgZmlsbDogTUFURVJJQUxfTElHSFRfRklMTFMuUkVELCBzdHJva2U6IE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IE1BVEVSSUFMX0xJR0hUX0ZJTExTLkdSQVksIHN0cm9rZTogTUFURVJJQUxfTElHSFRfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBNQVRFUklBTF9MSUdIVF9GSUxMUy5CTFVFLCBzdHJva2U6IE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBNQVRFUklBTF9MSUdIVF9GSUxMUy5SRUQsIHN0cm9rZTogTUFURVJJQUxfTElHSFRfU1RST0tFUy5SRUQgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogTUFURVJJQUxfTElHSFRfRklMTFMuR1JBWSwgc3Ryb2tlOiBNQVRFUklBTF9MSUdIVF9TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBNQVRFUklBTF9MSUdIVF9GSUxMUy5PUkFOR0UsXG4gICAgICBNQVRFUklBTF9MSUdIVF9GSUxMUy5ZRUxMT1csXG4gICAgICBNQVRFUklBTF9MSUdIVF9GSUxMUy5HUkVFTlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GVU5ORUxfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBcIiMyMTk2ZjNcIixcbiAgICAgIC8vIDUwMFxuICAgICAgXCIjMzI5RUY0XCIsXG4gICAgICAvLyAoaW50ZXJwb2xhdGVkKVxuICAgICAgXCIjNDJhNWY1XCIsXG4gICAgICAvLyA0MDBcbiAgICAgIFwiIzUzQURGNlwiLFxuICAgICAgLy8gKGludGVycG9sYXRlZClcbiAgICAgIFwiIzY0YjVmNlwiLFxuICAgICAgLy8gMzAwXG4gICAgICBcIiM3QUMwRjhcIixcbiAgICAgIC8vIChpbnRlcnBvbGF0ZWQpXG4gICAgICBcIiM5MGNhZjlcIlxuICAgICAgLy8gMjAwXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0dBVUdFX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgTUFURVJJQUxfTElHSFRfRklMTFMuR1JFRU4sXG4gICAgICBNQVRFUklBTF9MSUdIVF9GSUxMUy5ZRUxMT1csXG4gICAgICBNQVRFUklBTF9MSUdIVF9GSUxMUy5SRURcbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRklOQU5DSUFMX0NIQVJUU19BTk5PVEFUSU9OX0NPTE9SLCBNQVRFUklBTF9MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRklOQU5DSUFMX0NIQVJUU19BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgTUFURVJJQUxfTElHSFRfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL3BvbHljaHJvbWFEYXJrLnRzXG52YXIgUE9MWUNIUk9NQV9EQVJLX0ZJTExTID0ge1xuICBCTFVFOiBcIiM0MzZmZjRcIixcbiAgUFVSUExFOiBcIiM5YTdiZmZcIixcbiAgTUFHRU5UQTogXCIjZDE2NWQyXCIsXG4gIFBJTks6IFwiI2YwNTk4YlwiLFxuICBSRUQ6IFwiI2Y0NzM0OFwiLFxuICBPUkFOR0U6IFwiI2YyYTYwMlwiLFxuICBZRUxMT1c6IFwiI2U5ZTIwMVwiLFxuICBHUkVFTjogXCIjMjFiNDQ4XCIsXG4gIENZQU46IFwiIzAwYjlhMlwiLFxuICBNT0RFUkFURV9CTFVFOiBcIiMwMGFlZTRcIixcbiAgR1JBWTogXCIjYmJiYmJiXCJcbn07XG52YXIgUE9MWUNIUk9NQV9EQVJLX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzY2OThmZlwiLFxuICBQVVJQTEU6IFwiI2MwYTNmZlwiLFxuICBNQUdFTlRBOiBcIiNmYzhkZmNcIixcbiAgUElOSzogXCIjZmY4MmIxXCIsXG4gIFJFRDogXCIjZmY5YjcwXCIsXG4gIE9SQU5HRTogXCIjZmZjZjRlXCIsXG4gIFlFTExPVzogXCIjZmZmZjU4XCIsXG4gIEdSRUVOOiBcIiM1OGRkNzBcIixcbiAgQ1lBTjogXCIjNTFlMmM5XCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzRmZDdmZlwiLFxuICBHUkFZOiBcIiNlZWVlZWVcIlxufTtcbnZhciBQb2x5Y2hyb21hRGFyayA9IGNsYXNzIGV4dGVuZHMgRGFya1RoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IFBPTFlDSFJPTUFfREFSS19GSUxMUyxcbiAgICAgIHN0cm9rZXM6IFBPTFlDSFJPTUFfREFSS19TVFJPS0VTLFxuICAgICAgdXA6IHsgZmlsbDogUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkdSRUVOLCBzdHJva2U6IFBPTFlDSFJPTUFfREFSS19TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IFBPTFlDSFJPTUFfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogUE9MWUNIUk9NQV9EQVJLX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IFBPTFlDSFJPTUFfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IFBPTFlDSFJPTUFfREFSS19TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IFBPTFlDSFJPTUFfREFSS19GSUxMUy5CTFVFLCBzdHJva2U6IFBPTFlDSFJPTUFfREFSS19TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogUE9MWUNIUk9NQV9EQVJLX0ZJTExTLlJFRCwgc3Ryb2tlOiBQT0xZQ0hST01BX0RBUktfU1RST0tFUy5SRUQgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogUE9MWUNIUk9NQV9EQVJLX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1JfUkFOR0UsIFtQT0xZQ0hST01BX0RBUktfRklMTFMuQkxVRSwgUE9MWUNIUk9NQV9EQVJLX0ZJTExTLlJFRF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GVU5ORUxfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBQT0xZQ0hST01BX0RBUktfRklMTFMuQkxVRSxcbiAgICAgIFBPTFlDSFJPTUFfREFSS19GSUxMUy5QVVJQTEUsXG4gICAgICBQT0xZQ0hST01BX0RBUktfRklMTFMuTUFHRU5UQSxcbiAgICAgIFBPTFlDSFJPTUFfREFSS19GSUxMUy5QSU5LLFxuICAgICAgUE9MWUNIUk9NQV9EQVJLX0ZJTExTLlJFRCxcbiAgICAgIFBPTFlDSFJPTUFfREFSS19GSUxMUy5PUkFOR0UsXG4gICAgICBQT0xZQ0hST01BX0RBUktfRklMTFMuWUVMTE9XLFxuICAgICAgUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkdSRUVOXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0dBVUdFX1NFUklFU19DT0xPUl9SQU5HRSwgW1BPTFlDSFJPTUFfREFSS19GSUxMUy5CTFVFLCBQT0xZQ0hST01BX0RBUktfRklMTFMuUkVEXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZJTkFOQ0lBTF9DSEFSVFNfQU5OT1RBVElPTl9DT0xPUiwgUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GSU5BTkNJQUxfQ0hBUlRTX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBQT0xZQ0hST01BX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL3BvbHljaHJvbWFMaWdodC50c1xudmFyIFBPTFlDSFJPTUFfTElHSFRfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzQzNmZmNFwiLFxuICBQVVJQTEU6IFwiIzlhN2JmZlwiLFxuICBNQUdFTlRBOiBcIiNkMTY1ZDJcIixcbiAgUElOSzogXCIjZjA1OThiXCIsXG4gIFJFRDogXCIjZjQ3MzQ4XCIsXG4gIE9SQU5HRTogXCIjZjJhNjAyXCIsXG4gIFlFTExPVzogXCIjZTllMjAxXCIsXG4gIEdSRUVOOiBcIiMyMWI0NDhcIixcbiAgQ1lBTjogXCIjMDBiOWEyXCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzAwYWVlNFwiLFxuICBHUkFZOiBcIiNiYmJiYmJcIlxufTtcbnZhciBQT0xZQ0hST01BX0xJR0hUX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzIzNDZjOVwiLFxuICBQVVJQTEU6IFwiIzc2NTNkNFwiLFxuICBNQUdFTlRBOiBcIiNhNzNkYTlcIixcbiAgUElOSzogXCIjYzMyZDY2XCIsXG4gIFJFRDogXCIjYzg0YjFjXCIsXG4gIE9SQU5HRTogXCIjYzg3ZjAwXCIsXG4gIFlFTExPVzogXCIjYzFiOTAwXCIsXG4gIEdSRUVOOiBcIiMwMDhjMWNcIixcbiAgQ1lBTjogXCIjMDA5MjdjXCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzAwODdiYlwiLFxuICBHUkFZOiBcIiM4ODg4ODhcIlxufTtcbnZhciBQb2x5Y2hyb21hTGlnaHQgPSBjbGFzcyBleHRlbmRzIENoYXJ0VGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogUE9MWUNIUk9NQV9MSUdIVF9GSUxMUyxcbiAgICAgIHN0cm9rZXM6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUyxcbiAgICAgIHVwOiB7IGZpbGw6IFBPTFlDSFJPTUFfTElHSFRfRklMTFMuR1JFRU4sIHN0cm9rZTogUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IFBPTFlDSFJPTUFfTElHSFRfRklMTFMuUkVELCBzdHJva2U6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5HUkFZLCBzdHJva2U6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLkJMVUUsIHN0cm9rZTogUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5SRUQsIHN0cm9rZTogUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VTLlJFRCB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLkdSQVksIHN0cm9rZTogUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9SX1JBTkdFLCBbUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5CTFVFLCBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLlJFRF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GVU5ORUxfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLkJMVUUsXG4gICAgICBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLlBVUlBMRSxcbiAgICAgIFBPTFlDSFJPTUFfTElHSFRfRklMTFMuTUFHRU5UQSxcbiAgICAgIFBPTFlDSFJPTUFfTElHSFRfRklMTFMuUElOSyxcbiAgICAgIFBPTFlDSFJPTUFfTElHSFRfRklMTFMuUkVELFxuICAgICAgUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5PUkFOR0UsXG4gICAgICBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLllFTExPVyxcbiAgICAgIFBPTFlDSFJPTUFfTElHSFRfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR0FVR0VfU0VSSUVTX0NPTE9SX1JBTkdFLCBbUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5CTFVFLCBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLlJFRF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GSU5BTkNJQUxfQ0hBUlRTX0FOTk9UQVRJT05fQ09MT1IsIFBPTFlDSFJPTUFfTElHSFRfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZJTkFOQ0lBTF9DSEFSVFNfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIFBPTFlDSFJPTUFfTElHSFRfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL3NoZWV0c0RhcmsudHNcbnZhciBTSEVFVFNfREFSS19GSUxMUyA9IHtcbiAgQkxVRTogXCIjNDQ3MkM0XCIsXG4gIE9SQU5HRTogXCIjRUQ3RDMxXCIsXG4gIEdSQVk6IFwiI0E1QTVBNVwiLFxuICBZRUxMT1c6IFwiI0ZGQzAwMFwiLFxuICBNT0RFUkFURV9CTFVFOiBcIiM1QjlCRDVcIixcbiAgR1JFRU46IFwiIzcwQUQ0N1wiLFxuICBEQVJLX0dSQVk6IFwiIzdCN0I3QlwiLFxuICBEQVJLX0JMVUU6IFwiIzI2NDQ3OFwiLFxuICBWRVJZX0RBUktfR1JBWTogXCIjNjM2MzYzXCIsXG4gIERBUktfWUVMTE9XOiBcIiM5OTczMDBcIlxufTtcbnZhciBTSEVFVFNfREFSS19TVFJPS0VTID0ge1xuICBCTFVFOiBcIiM2ODk5ZWVcIixcbiAgT1JBTkdFOiBcIiNmZmE1NWRcIixcbiAgR1JBWTogXCIjY2RjZGNkXCIsXG4gIFlFTExPVzogXCIjZmZlYTUzXCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzgyYzNmZlwiLFxuICBHUkVFTjogXCIjOTZkNTZmXCIsXG4gIERBUktfR1JBWTogXCIjYTFhMWExXCIsXG4gIERBUktfQkxVRTogXCIjNDc2ODlmXCIsXG4gIFZFUllfREFSS19HUkFZOiBcIiM4Nzg3ODdcIixcbiAgREFSS19ZRUxMT1c6IFwiI2MwOTkzZFwiXG59O1xudmFyIFNoZWV0c0RhcmsgPSBjbGFzcyBleHRlbmRzIERhcmtUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiB7IC4uLlNIRUVUU19EQVJLX0ZJTExTLCBSRUQ6IFNIRUVUU19EQVJLX0ZJTExTLk9SQU5HRSB9LFxuICAgICAgc3Ryb2tlczogeyAuLi5TSEVFVFNfREFSS19TVFJPS0VTLCBSRUQ6IFNIRUVUU19EQVJLX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICB1cDogeyBmaWxsOiBTSEVFVFNfREFSS19GSUxMUy5HUkVFTiwgc3Ryb2tlOiBTSEVFVFNfREFSS19TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IFNIRUVUU19EQVJLX0ZJTExTLk9SQU5HRSwgc3Ryb2tlOiBTSEVFVFNfREFSS19TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBTSEVFVFNfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IFNIRUVUU19EQVJLX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogU0hFRVRTX0RBUktfRklMTFMuQkxVRSwgc3Ryb2tlOiBTSEVFVFNfREFSS19TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogU0hFRVRTX0RBUktfRklMTFMuT1JBTkdFLCBzdHJva2U6IFNIRUVUU19EQVJLX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IFNIRUVUU19EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogU0hFRVRTX0RBUktfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgU0hFRVRTX0RBUktfRklMTFMuT1JBTkdFLFxuICAgICAgU0hFRVRTX0RBUktfRklMTFMuWUVMTE9XLFxuICAgICAgU0hFRVRTX0RBUktfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfR0FVR0VfU0VSSUVTX0NPTE9SX1JBTkdFLCBbXG4gICAgICBTSEVFVFNfREFSS19GSUxMUy5HUkVFTixcbiAgICAgIFNIRUVUU19EQVJLX0ZJTExTLllFTExPVyxcbiAgICAgIFNIRUVUU19EQVJLX0ZJTExTLk9SQU5HRVxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GSU5BTkNJQUxfQ0hBUlRTX0FOTk9UQVRJT05fQ09MT1IsIFNIRUVUU19EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9GSU5BTkNJQUxfQ0hBUlRTX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBTSEVFVFNfREFSS19GSUxMUy5CTFVFKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvc2hlZXRzTGlnaHQudHNcbnZhciBTSEVFVFNfTElHSFRfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzUyODFkNVwiLFxuICBPUkFOR0U6IFwiI2ZmOGQ0NFwiLFxuICBHUkFZOiBcIiNiNWI1YjVcIixcbiAgWUVMTE9XOiBcIiNmZmQwMmZcIixcbiAgTU9ERVJBVEVfQkxVRTogXCIjNmFhYmU2XCIsXG4gIEdSRUVOOiBcIiM3ZmJkNTdcIixcbiAgREFSS19HUkFZOiBcIiM4YThhOGFcIixcbiAgREFSS19CTFVFOiBcIiMzMzUyODdcIixcbiAgVkVSWV9EQVJLX0dSQVk6IFwiIzcxNzE3MVwiLFxuICBEQVJLX1lFTExPVzogXCIjYTk4MjIwXCJcbn07XG52YXIgU0hFRVRTX0xJR0hUX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzIxNGQ5YlwiLFxuICBPUkFOR0U6IFwiI2MyNTYwMFwiLFxuICBHUkFZOiBcIiM3ZjdmN2ZcIixcbiAgWUVMTE9XOiBcIiNkNTk4MDBcIixcbiAgTU9ERVJBVEVfQkxVRTogXCIjMzU3NWFjXCIsXG4gIEdSRUVOOiBcIiM0Yjg2MWFcIixcbiAgREFSS19HUkFZOiBcIiM1NzU3NTdcIixcbiAgREFSS19CTFVFOiBcIiMwNjIyNTNcIixcbiAgVkVSWV9EQVJLX0dSQVk6IFwiIzQxNDE0MVwiLFxuICBEQVJLX1lFTExPVzogXCIjNzM0ZjAwXCJcbn07XG52YXIgU2hlZXRzTGlnaHQgPSBjbGFzcyBleHRlbmRzIENoYXJ0VGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogeyAuLi5TSEVFVFNfTElHSFRfRklMTFMsIFJFRDogU0hFRVRTX0xJR0hUX0ZJTExTLk9SQU5HRSB9LFxuICAgICAgc3Ryb2tlczogeyAuLi5TSEVFVFNfTElHSFRfU1RST0tFUywgUkVEOiBTSEVFVFNfTElHSFRfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIHVwOiB7IGZpbGw6IFNIRUVUU19MSUdIVF9GSUxMUy5HUkVFTiwgc3Ryb2tlOiBTSEVFVFNfTElHSFRfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBTSEVFVFNfTElHSFRfRklMTFMuT1JBTkdFLCBzdHJva2U6IFNIRUVUU19MSUdIVF9TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBTSEVFVFNfTElHSFRfU1RST0tFUy5HUkFZLCBzdHJva2U6IFNIRUVUU19MSUdIVF9TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IFNIRUVUU19MSUdIVF9GSUxMUy5CTFVFLCBzdHJva2U6IFNIRUVUU19MSUdIVF9TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogU0hFRVRTX0xJR0hUX0ZJTExTLk9SQU5HRSwgc3Ryb2tlOiBTSEVFVFNfTElHSFRfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogU0hFRVRTX0xJR0hUX0ZJTExTLkdSQVksIHN0cm9rZTogU0hFRVRTX0xJR0hUX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIFNIRUVUU19MSUdIVF9GSUxMUy5PUkFOR0UsXG4gICAgICBTSEVFVFNfTElHSFRfRklMTFMuWUVMTE9XLFxuICAgICAgU0hFRVRTX0xJR0hUX0ZJTExTLkdSRUVOXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0dBVUdFX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgU0hFRVRTX0xJR0hUX0ZJTExTLkdSRUVOLFxuICAgICAgU0hFRVRTX0xJR0hUX0ZJTExTLllFTExPVyxcbiAgICAgIFNIRUVUU19MSUdIVF9GSUxMUy5PUkFOR0VcbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRklOQU5DSUFMX0NIQVJUU19BTk5PVEFUSU9OX0NPTE9SLCBTSEVFVFNfTElHSFRfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZJTkFOQ0lBTF9DSEFSVFNfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIFNIRUVUU19MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvdml2aWREYXJrLnRzXG52YXIgVklWSURfREFSS19GSUxMUyA9IHtcbiAgQkxVRTogXCIjMDA4M2ZmXCIsXG4gIE9SQU5HRTogXCIjZmY2NjAwXCIsXG4gIEdSRUVOOiBcIiMwMGFmMDBcIixcbiAgQ1lBTjogXCIjMDBjY2ZmXCIsXG4gIFlFTExPVzogXCIjZjdjNzAwXCIsXG4gIFZJT0xFVDogXCIjYWMyNmZmXCIsXG4gIEdSQVk6IFwiI2E3YTdiN1wiLFxuICBNQUdFTlRBOiBcIiNlODAwYzVcIixcbiAgQlJPV046IFwiI2I1NDMwMFwiLFxuICBSRUQ6IFwiI2ZmMDAwMFwiXG59O1xudmFyIFZJVklEX0RBUktfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjNjdiN2ZmXCIsXG4gIE9SQU5HRTogXCIjZmZjMjRkXCIsXG4gIEdSRUVOOiBcIiM1Y2M4NmZcIixcbiAgQ1lBTjogXCIjNTRlYmZmXCIsXG4gIFZJT0xFVDogXCIjZmZmNjUzXCIsXG4gIFlFTExPVzogXCIjYzE4YWZmXCIsXG4gIEdSQVk6IFwiI2FlYWVhZVwiLFxuICBNQUdFTlRBOiBcIiNmMDc4ZDRcIixcbiAgQlJPV046IFwiI2JhODQzOFwiLFxuICBSRUQ6IFwiI2ZmNzI2ZVwiXG59O1xudmFyIFZpdmlkRGFyayA9IGNsYXNzIGV4dGVuZHMgRGFya1RoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IFZJVklEX0RBUktfRklMTFMsXG4gICAgICBzdHJva2VzOiBWSVZJRF9EQVJLX1NUUk9LRVMsXG4gICAgICB1cDogeyBmaWxsOiBWSVZJRF9EQVJLX0ZJTExTLkdSRUVOLCBzdHJva2U6IFZJVklEX0RBUktfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBWSVZJRF9EQVJLX0ZJTExTLlJFRCwgc3Ryb2tlOiBWSVZJRF9EQVJLX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IFZJVklEX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBWSVZJRF9EQVJLX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogVklWSURfREFSS19GSUxMUy5CTFVFLCBzdHJva2U6IFZJVklEX0RBUktfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IFZJVklEX0RBUktfRklMTFMuT1JBTkdFLCBzdHJva2U6IFZJVklEX0RBUktfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogVklWSURfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IFZJVklEX0RBUktfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgVklWSURfREFSS19GSUxMUy5PUkFOR0UsXG4gICAgICBWSVZJRF9EQVJLX0ZJTExTLllFTExPVyxcbiAgICAgIFZJVklEX0RBUktfRklMTFMuR1JFRU5cbiAgICBdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRlVOTkVMX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgXCIjMDA4M2ZmXCIsXG4gICAgICBcIiMwMDc2ZTZcIixcbiAgICAgIFwiIzAwNjljY1wiLFxuICAgICAgXCIjMDA1Y2IzXCIsXG4gICAgICBcIiMwMDRmOTlcIixcbiAgICAgIFwiIzAwNDI4MFwiLFxuICAgICAgXCIjMDAzNDY2XCIsXG4gICAgICBcIiMwMDI3NGNcIlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9HQVVHRV9TRVJJRVNfQ09MT1JfUkFOR0UsIFtcbiAgICAgIFZJVklEX0RBUktfRklMTFMuR1JFRU4sXG4gICAgICBWSVZJRF9EQVJLX0ZJTExTLllFTExPVyxcbiAgICAgIFZJVklEX0RBUktfRklMTFMuUkVEXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZJTkFOQ0lBTF9DSEFSVFNfQU5OT1RBVElPTl9DT0xPUiwgVklWSURfREFSS19GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRklOQU5DSUFMX0NIQVJUU19BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgVklWSURfREFSS19GSUxMUy5CTFVFKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvdml2aWRMaWdodC50c1xudmFyIFZJVklEX0ZJTExTID0ge1xuICBCTFVFOiBcIiMwMDgzZmZcIixcbiAgT1JBTkdFOiBcIiNmZjY2MDBcIixcbiAgR1JFRU46IFwiIzAwYWYwMFwiLFxuICBDWUFOOiBcIiMwMGNjZmZcIixcbiAgWUVMTE9XOiBcIiNmN2M3MDBcIixcbiAgVklPTEVUOiBcIiNhYzI2ZmZcIixcbiAgR1JBWTogXCIjYTdhN2I3XCIsXG4gIE1BR0VOVEE6IFwiI2U4MDBjNVwiLFxuICBCUk9XTjogXCIjYjU0MzAwXCIsXG4gIFJFRDogXCIjZmYwMDAwXCJcbn07XG52YXIgVklWSURfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjMGY2OGMwXCIsXG4gIE9SQU5HRTogXCIjZDQ3MTAwXCIsXG4gIEdSRUVOOiBcIiMwMDc5MjJcIixcbiAgQ1lBTjogXCIjMDA5YWMyXCIsXG4gIFZJT0xFVDogXCIjYmNhNDAwXCIsXG4gIFlFTExPVzogXCIjNzUzY2FjXCIsXG4gIEdSQVk6IFwiIzY0NjQ2NFwiLFxuICBNQUdFTlRBOiBcIiM5YjI2ODVcIixcbiAgQlJPV046IFwiIzZjM2IwMFwiLFxuICBSRUQ6IFwiI2NiMDAyMVwiXG59O1xudmFyIFZpdmlkTGlnaHQgPSBjbGFzcyBleHRlbmRzIENoYXJ0VGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogVklWSURfRklMTFMsXG4gICAgICBzdHJva2VzOiBWSVZJRF9TVFJPS0VTLFxuICAgICAgdXA6IHsgZmlsbDogVklWSURfRklMTFMuR1JFRU4sIHN0cm9rZTogVklWSURfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBWSVZJRF9GSUxMUy5SRUQsIHN0cm9rZTogVklWSURfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogVklWSURfRklMTFMuR1JBWSwgc3Ryb2tlOiBWSVZJRF9TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IFZJVklEX0ZJTExTLkJMVUUsIHN0cm9rZTogVklWSURfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IFZJVklEX0ZJTExTLk9SQU5HRSwgc3Ryb2tlOiBWSVZJRF9TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBWSVZJRF9GSUxMUy5HUkFZLCBzdHJva2U6IFZJVklEX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1JfUkFOR0UsIFtWSVZJRF9GSUxMUy5PUkFOR0UsIFZJVklEX0ZJTExTLllFTExPVywgVklWSURfRklMTFMuR1JFRU5dKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRlVOTkVMX1NFUklFU19DT0xPUl9SQU5HRSwgW1xuICAgICAgXCIjMDA4M2ZmXCIsXG4gICAgICBcIiMxYThmZmZcIixcbiAgICAgIFwiIzMzOWNmZlwiLFxuICAgICAgXCIjNGRhOGZmXCIsXG4gICAgICBcIiM2NmI1ZmZcIixcbiAgICAgIFwiIzgwYzFmZlwiLFxuICAgICAgXCIjOTljZGZmXCIsXG4gICAgICBcIiNiM2RhZmZcIlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9HQVVHRV9TRVJJRVNfQ09MT1JfUkFOR0UsIFtWSVZJRF9GSUxMUy5HUkVFTiwgVklWSURfRklMTFMuWUVMTE9XLCBWSVZJRF9GSUxMUy5SRURdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRklOQU5DSUFMX0NIQVJUU19BTk5PVEFUSU9OX0NPTE9SLCBWSVZJRF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRklOQU5DSUFMX0NIQVJUU19BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgVklWSURfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFwcGluZy90aGVtZXMudHNcbnZhciBsaWdodFRoZW1lID0gc2ltcGxlTWVtb3JpemUoKCkgPT4gbmV3IENoYXJ0VGhlbWUoKSk7XG52YXIgZGFya1RoZW1lID0gc2ltcGxlTWVtb3JpemUoKCkgPT4gbmV3IERhcmtUaGVtZSgpKTtcbnZhciB0aGVtZXMgPSB7XG4gIC8vIGRhcmtUaGVtZXMsXG4gIFwiYWctZGVmYXVsdC1kYXJrXCI6IGRhcmtUaGVtZSxcbiAgXCJhZy1zaGVldHMtZGFya1wiOiBzaW1wbGVNZW1vcml6ZSgoKSA9PiBuZXcgU2hlZXRzRGFyaygpKSxcbiAgXCJhZy1wb2x5Y2hyb21hLWRhcmtcIjogc2ltcGxlTWVtb3JpemUoKCkgPT4gbmV3IFBvbHljaHJvbWFEYXJrKCkpLFxuICBcImFnLXZpdmlkLWRhcmtcIjogc2ltcGxlTWVtb3JpemUoKCkgPT4gbmV3IFZpdmlkRGFyaygpKSxcbiAgXCJhZy1tYXRlcmlhbC1kYXJrXCI6IHNpbXBsZU1lbW9yaXplKCgpID0+IG5ldyBNYXRlcmlhbERhcmsoKSksXG4gIFwiYWctZmluYW5jaWFsLWRhcmtcIjogc2ltcGxlTWVtb3JpemUoKCkgPT4gbmV3IEZpbmFuY2lhbERhcmsoKSksXG4gIC8vIGxpZ2h0VGhlbWVzLFxuICBudWxsOiBsaWdodFRoZW1lLFxuICB1bmRlZmluZWQ6IGxpZ2h0VGhlbWUsXG4gIFwiYWctZGVmYXVsdFwiOiBsaWdodFRoZW1lLFxuICBcImFnLXNoZWV0c1wiOiBzaW1wbGVNZW1vcml6ZSgoKSA9PiBuZXcgU2hlZXRzTGlnaHQoKSksXG4gIFwiYWctcG9seWNocm9tYVwiOiBzaW1wbGVNZW1vcml6ZSgoKSA9PiBuZXcgUG9seWNocm9tYUxpZ2h0KCkpLFxuICBcImFnLXZpdmlkXCI6IHNpbXBsZU1lbW9yaXplKCgpID0+IG5ldyBWaXZpZExpZ2h0KCkpLFxuICBcImFnLW1hdGVyaWFsXCI6IHNpbXBsZU1lbW9yaXplKCgpID0+IG5ldyBNYXRlcmlhbExpZ2h0KCkpLFxuICBcImFnLWZpbmFuY2lhbFwiOiBzaW1wbGVNZW1vcml6ZSgoKSA9PiBuZXcgRmluYW5jaWFsTGlnaHQoKSlcbn07XG52YXIgZ2V0Q2hhcnRUaGVtZSA9IHNpbXBsZU1lbW9yaXplKGNyZWF0ZUNoYXJ0VGhlbWUpO1xuZnVuY3Rpb24gY3JlYXRlQ2hhcnRUaGVtZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBDaGFydFRoZW1lKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHN0b2NrVGhlbWUgPSB0aGVtZXNbdmFsdWVdO1xuICAgIGlmIChzdG9ja1RoZW1lKSB7XG4gICAgICByZXR1cm4gc3RvY2tUaGVtZSgpO1xuICAgIH1cbiAgICBsb2dnZXJfZXhwb3J0cy53YXJuT25jZShgdGhlIHRoZW1lIFske3ZhbHVlfV0gaXMgaW52YWxpZCwgdXNpbmcgW2FnLWRlZmF1bHRdIGluc3RlYWQuYCk7XG4gICAgcmV0dXJuIGxpZ2h0VGhlbWUoKTtcbiAgfVxuICBjb25zdCB7IGVycm9ycyB9ID0gdmFsaWRhdGUodmFsdWUsIHRoZW1lT3B0aW9uc0RlZiwgXCJ0aGVtZVwiKTtcbiAgaWYgKCFlcnJvcnMubGVuZ3RoKSB7XG4gICAgY29uc3QgZmxhdHRlbmVkVGhlbWUgPSByZWR1Y2VUaGVtZU9wdGlvbnModmFsdWUpO1xuICAgIGNvbnN0IGJhc2VUaGVtZSA9IGZsYXR0ZW5lZFRoZW1lLmJhc2VUaGVtZSA/IGdldENoYXJ0VGhlbWUoZmxhdHRlbmVkVGhlbWUuYmFzZVRoZW1lKSA6IGxpZ2h0VGhlbWUoKTtcbiAgICByZXR1cm4gbmV3IGJhc2VUaGVtZS5jb25zdHJ1Y3RvcihmbGF0dGVuZWRUaGVtZSk7XG4gIH1cbiAgZm9yIChjb25zdCB7IG1lc3NhZ2UgfSBvZiBlcnJvcnMpIHtcbiAgICBsb2dnZXJfZXhwb3J0cy53YXJuT25jZShtZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gbGlnaHRUaGVtZSgpO1xufVxuZnVuY3Rpb24gcmVkdWNlVGhlbWVPcHRpb25zKG9wdGlvbnMpIHtcbiAgbGV0IG1heWJlTmVzdGVkID0gb3B0aW9ucztcbiAgbGV0IHBhbGV0dGU7XG4gIGxldCBwYXJhbXM7XG4gIGNvbnN0IG92ZXJyaWRlcyA9IFtdO1xuICB3aGlsZSAodHlwZW9mIG1heWJlTmVzdGVkID09PSBcIm9iamVjdFwiKSB7XG4gICAgcGFsZXR0ZSA/PyAocGFsZXR0ZSA9IG1heWJlTmVzdGVkLnBhbGV0dGUpO1xuICAgIHBhcmFtcyA/PyAocGFyYW1zID0gbWF5YmVOZXN0ZWQucGFyYW1zKTtcbiAgICBpZiAobWF5YmVOZXN0ZWQub3ZlcnJpZGVzKSB7XG4gICAgICBvdmVycmlkZXMucHVzaChtYXliZU5lc3RlZC5vdmVycmlkZXMpO1xuICAgIH1cbiAgICBtYXliZU5lc3RlZCA9IG1heWJlTmVzdGVkLmJhc2VUaGVtZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJhc2VUaGVtZTogbWF5YmVOZXN0ZWQsXG4gICAgb3ZlcnJpZGVzOiBtZXJnZURlZmF1bHRzKC4uLm92ZXJyaWRlcyksXG4gICAgcGFyYW1zLFxuICAgIHBhbGV0dGVcbiAgfTtcbn1cbnZhciB0aGVtZU9wdGlvbnNEZWYgPSB7XG4gIGJhc2VUaGVtZTogb3Ioc3RyaW5nLCBvYmplY3QpLFxuICBvdmVycmlkZXM6IG9iamVjdCxcbiAgcGFyYW1zOiBvYmplY3QsXG4gIHBhbGV0dGU6IHtcbiAgICBmaWxsczogYXJyYXlPZihzdHJpbmcpLFxuICAgIHN0cm9rZXM6IGFycmF5T2Yoc3RyaW5nKSxcbiAgICB1cDogeyBmaWxsOiBzdHJpbmcsIHN0cm9rZTogc3RyaW5nIH0sXG4gICAgZG93bjogeyBmaWxsOiBzdHJpbmcsIHN0cm9rZTogc3RyaW5nIH0sXG4gICAgbmV1dHJhbDogeyBmaWxsOiBzdHJpbmcsIHN0cm9rZTogc3RyaW5nIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW9kdWxlL29wdGlvbnNNb2R1bGUudHNcbnZhciB1bnRoZW1lZFNlcmllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcIm1hcC1zaGFwZS1iYWNrZ3JvdW5kXCIsIFwibWFwLWxpbmUtYmFja2dyb3VuZFwiXSk7XG52YXIgX0NoYXJ0T3B0aW9ucyA9IGNsYXNzIF9DaGFydE9wdGlvbnMge1xuICBjb25zdHJ1Y3Rvcih1c2VyT3B0aW9ucywgcHJvY2Vzc2VkT3ZlcnJpZGVzLCBzcGVjaWFsT3ZlcnJpZGVzLCBtZXRhZGF0YSwgZGVsdGFPcHRpb25zLCBzdHJpcFN5bWJvbHMgPSBmYWxzZSkge1xuICAgIHRoaXMudGhlbWVQYXJhbWV0ZXJzID0ge307XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcIm9wdHNcIik7XG4gICAgdGhpcy5vcHRpb25NZXRhZGF0YSA9IG1ldGFkYXRhID8/IHt9O1xuICAgIHRoaXMucHJvY2Vzc2VkT3ZlcnJpZGVzID0gcHJvY2Vzc2VkT3ZlcnJpZGVzID8/IHt9O1xuICAgIGxldCBiYXNlQ2hhcnRPcHRpb25zID0gbnVsbDtcbiAgICBpZiAodXNlck9wdGlvbnMgaW5zdGFuY2VvZiBfQ2hhcnRPcHRpb25zKSB7XG4gICAgICBiYXNlQ2hhcnRPcHRpb25zID0gdXNlck9wdGlvbnM7XG4gICAgICB0aGlzLnNwZWNpYWxPdmVycmlkZXMgPSBiYXNlQ2hhcnRPcHRpb25zLnNwZWNpYWxPdmVycmlkZXM7XG4gICAgICBpZiAoIWRlbHRhT3B0aW9ucylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gaW50ZXJuYWwgZXJyb3I6IGRlbHRhT3B0aW9ucyBtdXN0IGJlIHN1cHBsaWVkLlwiKTtcbiAgICAgIHRoaXMudXNlck9wdGlvbnMgPSBtZXJnZURlZmF1bHRzKFxuICAgICAgICBkZWx0YU9wdGlvbnMsXG4gICAgICAgIGRlZXBDbG9uZShiYXNlQ2hhcnRPcHRpb25zLnVzZXJPcHRpb25zLCBfQ2hhcnRPcHRpb25zLk9QVElPTlNfQ0xPTkVfT1BUUylcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXNlck9wdGlvbnMgPSB1c2VyT3B0aW9ucztcbiAgICAgIHRoaXMuc3BlY2lhbE92ZXJyaWRlcyA9IHRoaXMuc3BlY2lhbE92ZXJyaWRlc0RlZmF1bHRzKHsgLi4uc3BlY2lhbE92ZXJyaWRlcyB9KTtcbiAgICB9XG4gICAgaWYgKHN0cmlwU3ltYm9scykge1xuICAgICAgdGhpcy5yZW1vdmVMZWZ0b3ZlclN5bWJvbHModGhpcy51c2VyT3B0aW9ucyk7XG4gICAgfVxuICAgIGxldCBhY3RpdmVUaGVtZSwgcHJvY2Vzc2VkT3B0aW9ucywgZGVmYXVsdEF4ZXMsIGZhc3REZWx0YSwgdGhlbWVQYXJhbWV0ZXJzO1xuICAgIGlmICghc3RyaXBTeW1ib2xzICYmIGRlbHRhT3B0aW9ucyAhPSBudWxsICYmIF9DaGFydE9wdGlvbnMuaXNGYXN0UGF0aERlbHRhKGRlbHRhT3B0aW9ucykgJiYgYmFzZUNoYXJ0T3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAoeyBhY3RpdmVUaGVtZSwgcHJvY2Vzc2VkT3B0aW9ucywgZGVmYXVsdEF4ZXMsIGZhc3REZWx0YSB9ID0gdGhpcy5mYXN0U2V0dXAoXG4gICAgICAgIGRlbHRhT3B0aW9ucyxcbiAgICAgICAgYmFzZUNoYXJ0T3B0aW9uc1xuICAgICAgKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICh7IGFjdGl2ZVRoZW1lLCBwcm9jZXNzZWRPcHRpb25zLCBkZWZhdWx0QXhlcywgdGhlbWVQYXJhbWV0ZXJzIH0gPSB0aGlzLnNsb3dTZXR1cChcbiAgICAgICAgcHJvY2Vzc2VkT3ZlcnJpZGVzLFxuICAgICAgICBkZWx0YU9wdGlvbnMsXG4gICAgICAgIHN0cmlwU3ltYm9sc1xuICAgICAgKSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlVGhlbWUgPSBhY3RpdmVUaGVtZTtcbiAgICB0aGlzLnByb2Nlc3NlZE9wdGlvbnMgPSBwcm9jZXNzZWRPcHRpb25zO1xuICAgIHRoaXMuZGVmYXVsdEF4ZXMgPSBkZWZhdWx0QXhlcztcbiAgICB0aGlzLmZhc3REZWx0YSA9IGZhc3REZWx0YTtcbiAgICB0aGlzLnRoZW1lUGFyYW1ldGVycyA9IHRoZW1lUGFyYW1ldGVycyA/PyB7fTtcbiAgfVxuICBzdGF0aWMgaXNGYXN0UGF0aERlbHRhKGRlbHRhT3B0aW9ucykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGRlbHRhT3B0aW9ucykpIHtcbiAgICAgIGlmICghdGhpcy5GQVNUX1BBVEhfT1BUSU9OUy5oYXMoa2V5KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmYXN0U2V0dXAoZGVsdGFPcHRpb25zLCBiYXNlQ2hhcnRPcHRpb25zKSB7XG4gICAgY29uc3QgeyBhY3RpdmVUaGVtZSwgZGVmYXVsdEF4ZXMsIHByb2Nlc3NlZE9wdGlvbnM6IGJhc2VPcHRpb25zIH0gPSBiYXNlQ2hhcnRPcHRpb25zO1xuICAgIGNvbnN0IHsgcHJlc2V0VHlwZSB9ID0gdGhpcy5vcHRpb25NZXRhZGF0YTtcbiAgICBjb25zdCBwcm9jZXNzb3IgPSBwcmVzZXRUeXBlID8gUFJFU0VUX0RBVEFfUFJPQ0VTU09SU1twcmVzZXRUeXBlXSA6IHZvaWQgMDtcbiAgICBpZiAocHJlc2V0VHlwZSAhPSBudWxsICYmIGRlbHRhT3B0aW9ucy5kYXRhICE9IG51bGwgJiYgcHJvY2Vzc29yICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgc2VyaWVzLCBkYXRhIH0gPSBwcm9jZXNzb3IoZGVsdGFPcHRpb25zLmRhdGEpO1xuICAgICAgZGVsdGFPcHRpb25zID0gbWVyZ2VEZWZhdWx0cyh7IHNlcmllcywgZGF0YSB9LCBkZWx0YU9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLmZhc3RTZXJpZXNTZXR1cChkZWx0YU9wdGlvbnMsIGJhc2VPcHRpb25zKTtcbiAgICBjb25zdCBwcm9jZXNzZWRPcHRpb25zID0gbWVyZ2VEZWZhdWx0cyhkZWx0YU9wdGlvbnMsIGJhc2VPcHRpb25zKTtcbiAgICByZXR1cm4geyBhY3RpdmVUaGVtZSwgZGVmYXVsdEF4ZXMsIHByb2Nlc3NlZE9wdGlvbnMsIGZhc3REZWx0YTogZGVsdGFPcHRpb25zIH07XG4gIH1cbiAgZmFzdFNlcmllc1NldHVwKGRlbHRhT3B0aW9ucywgYmFzZU9wdGlvbnMpIHtcbiAgICBpZiAoIWRlbHRhT3B0aW9ucy5zZXJpZXMpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGRlbHRhT3B0aW9ucy5zZXJpZXM/LmV2ZXJ5KChzLCBpKSA9PiBqc29uUHJvcGVydHlDb21wYXJlKHMsIGJhc2VPcHRpb25zLnNlcmllcz8uW2ldID8/IHt9KSkpIHtcbiAgICAgIGRlbGV0ZSBkZWx0YU9wdGlvbnNbXCJzZXJpZXNcIl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbHRhT3B0aW9ucy5zZXJpZXMgPSBkZWx0YU9wdGlvbnMuc2VyaWVzLm1hcCgocywgaSkgPT4ge1xuICAgICAgICByZXR1cm4gbWVyZ2VEZWZhdWx0cyhzLCBiYXNlT3B0aW9ucy5zZXJpZXM/LltpXSA/PyB7fSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgc2xvd1NldHVwKHByb2Nlc3NlZE92ZXJyaWRlcywgZGVsdGFPcHRpb25zLCBzdHJpcFN5bWJvbHMgPSBmYWxzZSkge1xuICAgIGxldCBvcHRpb25zID0gZGVlcENsb25lKHRoaXMudXNlck9wdGlvbnMsIF9DaGFydE9wdGlvbnMuT1BUSU9OU19DTE9ORV9PUFRTKTtcbiAgICBpZiAoZGVsdGFPcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0cyhkZWx0YU9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgaWYgKHN0cmlwU3ltYm9scykge1xuICAgICAgICB0aGlzLnJlbW92ZUxlZnRvdmVyU3ltYm9scyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBwcmVzZXRUeXBlIH0gPSB0aGlzLm9wdGlvbk1ldGFkYXRhO1xuICAgIGlmIChwcmVzZXRUeXBlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHByZXNldENvbnN0cnVjdG9yID0gUFJFU0VUU1twcmVzZXRUeXBlXTtcbiAgICAgIGNvbnN0IHByZXNldFBhcmFtcyA9IHRoaXMudXNlck9wdGlvbnM7XG4gICAgICBjb25zdCBwcmVzZXRTdWJUeXBlID0gdGhpcy51c2VyT3B0aW9ucy50eXBlO1xuICAgICAgY29uc3QgcHJlc2V0VGhlbWUgPSBwcmVzZXRTdWJUeXBlICE9IG51bGwgPyBnZXRDaGFydFRoZW1lKHRoaXMudXNlck9wdGlvbnMudGhlbWUpLnByZXNldHNbcHJlc2V0U3ViVHlwZV0gOiB2b2lkIDA7XG4gICAgICB0aGlzLmRlYnVnKFwiPj4+IEFnQ2hhcnRzLmNyZWF0ZU9yVXBkYXRlKCkgLSBhcHBseWluZyBwcmVzZXRcIiwgcHJlc2V0UGFyYW1zKTtcbiAgICAgIG9wdGlvbnMgPSBwcmVzZXRDb25zdHJ1Y3Rvcj8uKHByZXNldFBhcmFtcywgcHJlc2V0VGhlbWUsICgpID0+IHRoaXMuYWN0aXZlVGhlbWUpID8/IG9wdGlvbnM7XG4gICAgfVxuICAgIGlmICghZW50ZXJwcmlzZU1vZHVsZS5pc0VudGVycHJpc2UpIHtcbiAgICAgIHJlbW92ZVVzZWRFbnRlcnByaXNlT3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgYWN0aXZlVGhlbWUgPSBnZXRDaGFydFRoZW1lKG9wdGlvbnMudGhlbWUpO1xuICAgIHRoaXMuc2FuaXR5Q2hlY2sob3B0aW9ucyk7XG4gICAgdGhpcy5yZW1vdmVEaXNhYmxlZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3Qgc2VyaWVzVHlwZSA9IHRoaXMub3B0aW9uc1R5cGUob3B0aW9ucyk7XG4gICAgY29uc3Qge1xuICAgICAgYXhlczogYXhlc1RoZW1lcyA9IHt9LFxuICAgICAgYW5ub3RhdGlvbnMgPSB7fSxcbiAgICAgIHNlcmllczogc2VyaWVzVGhlbWUsXG4gICAgICAuLi50aGVtZURlZmF1bHRzXG4gICAgfSA9IHRoaXMuZ2V0U2VyaWVzVGhlbWVDb25maWcoc2VyaWVzVHlwZSwgYWN0aXZlVGhlbWUpO1xuICAgIGNvbnN0IFthbm5vdGF0aW9uc09wdGlvbnMsIGFubm90YXRpb25zVGhlbWVzXSA9IHRoaXMuc3BsaXRBbm5vdGF0aW9uc09wdGlvbnMoYW5ub3RhdGlvbnMpO1xuICAgIHRoaXMuYW5ub3RhdGlvblRoZW1lcyA9IGRlZXBDbG9uZShhbm5vdGF0aW9uc1RoZW1lcyk7XG4gICAgY29uc3QgZGVmYXVsdEF4ZXMgPSB0aGlzLmdldERlZmF1bHRBeGVzKG9wdGlvbnMsIHNlcmllc1RoZW1lKTtcbiAgICBsZXQgcHJvY2Vzc2VkT3B0aW9ucyA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICBwcm9jZXNzZWRPdmVycmlkZXMsXG4gICAgICBvcHRpb25zLFxuICAgICAgYW5ub3RhdGlvbnNPcHRpb25zLFxuICAgICAgdGhlbWVEZWZhdWx0cyxcbiAgICAgIGRlZmF1bHRBeGVzXG4gICAgKTtcbiAgICB0aGlzLnByb2Nlc3NBeGVzT3B0aW9ucyhwcm9jZXNzZWRPcHRpb25zLCBheGVzVGhlbWVzKTtcbiAgICB0aGlzLnByb2Nlc3NTZXJpZXNPcHRpb25zKHByb2Nlc3NlZE9wdGlvbnMsIGFjdGl2ZVRoZW1lKTtcbiAgICB0aGlzLnByb2Nlc3NNaW5pQ2hhcnRTZXJpZXNPcHRpb25zKHByb2Nlc3NlZE9wdGlvbnMsIGFjdGl2ZVRoZW1lKTtcbiAgICBwcm9jZXNzZWRPcHRpb25zID0gZGVlcENsb25lKHByb2Nlc3NlZE9wdGlvbnMsIF9DaGFydE9wdGlvbnMuT1BUSU9OU19DTE9ORV9PUFRTKTtcbiAgICBjb25zdCB0aGVtZVBhcmFtZXRlcnMgPSB0aGlzLmdldFRoZW1lUGFyYW1ldGVycyhhY3RpdmVUaGVtZSwgcHJvY2Vzc2VkT3B0aW9ucyk7XG4gICAgdGhpcy5yZXNvbHZlVGhlbWVPcGVyYXRpb25zKHRoZW1lUGFyYW1ldGVycywgdGhlbWVQYXJhbWV0ZXJzKTtcbiAgICB0aGlzLnJlc29sdmVUaGVtZU9wZXJhdGlvbnModGhlbWVQYXJhbWV0ZXJzLCBwcm9jZXNzZWRPcHRpb25zKTtcbiAgICB0aGlzLnJlc29sdmVUaGVtZU9wZXJhdGlvbnModGhlbWVQYXJhbWV0ZXJzLCB0aGlzLmFubm90YXRpb25UaGVtZXMpO1xuICAgIGlmICgoaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyhwcm9jZXNzZWRPcHRpb25zKSB8fCBpc0FnU3RhbmRhbG9uZUNoYXJ0T3B0aW9ucyhwcm9jZXNzZWRPcHRpb25zKSB8fCBpc0FnUG9sYXJDaGFydE9wdGlvbnNXaXRoU2VyaWVzQmFzZWRMZWdlbmQocHJvY2Vzc2VkT3B0aW9ucykpICYmIHByb2Nlc3NlZE9wdGlvbnMubGVnZW5kPy5lbmFibGVkID09IG51bGwpIHtcbiAgICAgIHByb2Nlc3NlZE9wdGlvbnMubGVnZW5kID8/IChwcm9jZXNzZWRPcHRpb25zLmxlZ2VuZCA9IHt9KTtcbiAgICAgIHByb2Nlc3NlZE9wdGlvbnMubGVnZW5kLmVuYWJsZWQgPSBwcm9jZXNzZWRPcHRpb25zLnNlcmllcy5sZW5ndGggPiAxO1xuICAgIH1cbiAgICB0aGlzLmVuYWJsZUNvbmZpZ3VyZWRPcHRpb25zKHByb2Nlc3NlZE9wdGlvbnMsIHRoaXMudXNlck9wdGlvbnMpO1xuICAgIGFjdGl2ZVRoZW1lLnRlbXBsYXRlVGhlbWUocHJvY2Vzc2VkT3B0aW9ucywgZmFsc2UpO1xuICAgIHRoaXMucmVtb3ZlRGlzYWJsZWRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJlbW92ZVVudXNlZEVudGVycHJpc2VPcHRpb25zKHByb2Nlc3NlZE9wdGlvbnMpO1xuICAgIGlmICghZW50ZXJwcmlzZU1vZHVsZS5pc0VudGVycHJpc2UpIHtcbiAgICAgIHJlbW92ZVVzZWRFbnRlcnByaXNlT3B0aW9ucyhwcm9jZXNzZWRPcHRpb25zLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyhcIkFnQ2hhcnRzLmNyZWF0ZU9yVXBkYXRlKCkgLSBwcm9jZXNzZWQgb3B0aW9uc1wiLCBwcm9jZXNzZWRPcHRpb25zKTtcbiAgICByZXR1cm4geyBhY3RpdmVUaGVtZSwgcHJvY2Vzc2VkT3B0aW9ucywgZGVmYXVsdEF4ZXMsIHRoZW1lUGFyYW1ldGVycyB9O1xuICB9XG4gIGRpZmZPcHRpb25zKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKVxuICAgICAgcmV0dXJuIHt9O1xuICAgIGlmIChvdGhlciA9PSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc2VkT3B0aW9ucztcbiAgICByZXR1cm4gdGhpcy5mYXN0RGVsdGEgPz8ganNvbkRpZmYob3RoZXIucHJvY2Vzc2VkT3B0aW9ucywgdGhpcy5wcm9jZXNzZWRPcHRpb25zKTtcbiAgfVxuICBnZXRTZXJpZXNUaGVtZUNvbmZpZyhzZXJpZXNUeXBlLCBhY3RpdmVUaGVtZSkge1xuICAgIHJldHVybiBhY3RpdmVUaGVtZT8uY29uZmlnW3Nlcmllc1R5cGVdID8/IHt9O1xuICB9XG4gIGdldERlZmF1bHRBeGVzKG9wdGlvbnMsIHNlcmllc1RoZW1lKSB7XG4gICAgY29uc3Qgb3B0aW9uc1R5cGUyID0gdGhpcy5vcHRpb25zVHlwZShvcHRpb25zKTtcbiAgICBsZXQgZmlyc3RTZXJpZXNPcHRpb25zID0gb3B0aW9ucy5zZXJpZXM/LmZpbmQoKHNlcmllcykgPT4gKHNlcmllcy50eXBlID8/IFwibGluZVwiKSA9PT0gb3B0aW9uc1R5cGUyKSA/PyB7fTtcbiAgICBpZiAoc2VyaWVzUmVnaXN0cnkuaXNEZXJpdmVkRGVmYXVsdEF4ZXMob3B0aW9uc1R5cGUyKSkge1xuICAgICAgZmlyc3RTZXJpZXNPcHRpb25zID0gbWVyZ2VEZWZhdWx0cyhmaXJzdFNlcmllc09wdGlvbnMsIHNlcmllc1RoZW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmllc1JlZ2lzdHJ5LmNsb25lRGVmYXVsdEF4ZXMob3B0aW9uc1R5cGUyLCBmaXJzdFNlcmllc09wdGlvbnMpO1xuICB9XG4gIG9wdGlvbnNUeXBlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5zZXJpZXM/LlswXT8udHlwZSA/PyBcImxpbmVcIjtcbiAgfVxuICBzYW5pdHlDaGVjayhvcHRpb25zKSB7XG4gICAgdGhpcy5heGVzVHlwZUludGVncml0eShvcHRpb25zKTtcbiAgICB0aGlzLnNlcmllc1R5cGVJbnRlZ3JpdHkob3B0aW9ucyk7XG4gICAgdGhpcy5zb2xvU2VyaWVzSW50ZWdyaXR5KG9wdGlvbnMpO1xuICB9XG4gIHNwbGl0QW5ub3RhdGlvbnNPcHRpb25zKGFubm90YXRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXhlc0J1dHRvbnMgPSBudWxsLFxuICAgICAgZW5hYmxlZCA9IG51bGwsXG4gICAgICBvcHRpb25zVG9vbGJhciA9IG51bGwsXG4gICAgICB0b29sYmFyID0gbnVsbCxcbiAgICAgIC4uLmFubm90YXRpb25zVGhlbWVzXG4gICAgfSA9IGFubm90YXRpb25zO1xuICAgIGlmIChheGVzQnV0dG9ucyA9PSBudWxsICYmIGVuYWJsZWQgPT0gbnVsbCAmJiBvcHRpb25zVG9vbGJhciA9PSBudWxsICYmIHRvb2xiYXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFt7fSwgYW5ub3RhdGlvbnNUaGVtZXNdO1xuICAgIH1cbiAgICByZXR1cm4gW3sgYW5ub3RhdGlvbnM6IHsgYXhlc0J1dHRvbnMsIGVuYWJsZWQsIG9wdGlvbnNUb29sYmFyLCB0b29sYmFyIH0gfSwgYW5ub3RhdGlvbnNUaGVtZXNdO1xuICB9XG4gIHByb2Nlc3NBeGVzT3B0aW9ucyhvcHRpb25zLCBheGVzVGhlbWVzKSB7XG4gICAgaWYgKCEoXCJheGVzXCIgaW4gb3B0aW9ucykpXG4gICAgICByZXR1cm47XG4gICAgb3B0aW9ucy5heGVzID0gb3B0aW9ucy5heGVzPy5tYXAoKGF4aXMpID0+IHtcbiAgICAgIGNvbnN0IHsgY3Jvc3NMaW5lczogY3Jvc3NMaW5lc1RoZW1lLCAuLi5heGlzVGhlbWUgfSA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICAgIGF4ZXNUaGVtZXNbYXhpcy50eXBlXT8uW2F4aXMucG9zaXRpb25dLFxuICAgICAgICBheGVzVGhlbWVzW2F4aXMudHlwZV1cbiAgICAgICk7XG4gICAgICBpZiAoYXhpcy5jcm9zc0xpbmVzKSB7XG4gICAgICAgIGF4aXMuY3Jvc3NMaW5lcyA9IG1lcmdlQXJyYXlEZWZhdWx0cyhheGlzLmNyb3NzTGluZXMsIGNyb3NzTGluZXNUaGVtZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBncmlkTGluZVN0eWxlID0gYXhpc1RoZW1lLmdyaWRMaW5lPy5zdHlsZTtcbiAgICAgIGlmIChheGlzLmdyaWRMaW5lPy5zdHlsZSAmJiBncmlkTGluZVN0eWxlPy5sZW5ndGgpIHtcbiAgICAgICAgYXhpcy5ncmlkTGluZS5zdHlsZSA9IGF4aXMuZ3JpZExpbmUuc3R5bGUubWFwKFxuICAgICAgICAgIChzdHlsZSwgaW5kZXgpID0+IHN0eWxlLnN0cm9rZSAhPSBudWxsIHx8IHN0eWxlLmxpbmVEYXNoICE9IG51bGwgPyBtZXJnZURlZmF1bHRzKHN0eWxlLCBncmlkTGluZVN0eWxlLmF0KGluZGV4ICUgZ3JpZExpbmVTdHlsZS5sZW5ndGgpKSA6IHN0eWxlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcDogXzEsIHJpZ2h0OiBfMiwgYm90dG9tOiBfMywgbGVmdDogXzQsIC4uLmF4aXNPcHRpb25zIH0gPSBtZXJnZURlZmF1bHRzKGF4aXMsIGF4aXNUaGVtZSk7XG4gICAgICByZXR1cm4gYXhpc09wdGlvbnM7XG4gICAgfSk7XG4gIH1cbiAgcHJvY2Vzc1Nlcmllc09wdGlvbnMob3B0aW9ucywgYWN0aXZlVGhlbWUpIHtcbiAgICBjb25zdCBkZWZhdWx0VG9vbHRpcFBvc2l0aW9uID0gdGhpcy5nZXRUb29sdGlwUG9zaXRpb25EZWZhdWx0cyhvcHRpb25zKTtcbiAgICBjb25zdCB1c2VyUGFsZXR0ZSA9IGlzT2JqZWN0KG9wdGlvbnMudGhlbWUpID8gcGFsZXR0ZVR5cGUob3B0aW9ucy50aGVtZT8ucGFsZXR0ZSkgOiBcImluYnVpbHRcIjtcbiAgICBjb25zdCBwYWxldHRlT3B0aW9ucyA9IHtcbiAgICAgIGNvbG91ckluZGV4OiAwLFxuICAgICAgdXNlclBhbGV0dGVcbiAgICB9O1xuICAgIGNvbnN0IHByb2Nlc3NlZFNlcmllcyA9IG9wdGlvbnMuc2VyaWVzPy5tYXAoKHNlcmllcykgPT4ge1xuICAgICAgc2VyaWVzLnR5cGUgPz8gKHNlcmllcy50eXBlID0gdGhpcy5nZXREZWZhdWx0U2VyaWVzVHlwZShvcHRpb25zKSk7XG4gICAgICBjb25zdCB7IGlubmVyTGFiZWxzOiBpbm5lckxhYmVsc1RoZW1lLCAuLi5zZXJpZXNUaGVtZSB9ID0gdGhpcy5nZXRTZXJpZXNUaGVtZUNvbmZpZyhzZXJpZXMudHlwZSwgYWN0aXZlVGhlbWUpLnNlcmllcyA/PyB7fTtcbiAgICAgIGNvbnN0IHNlcmllc1BhbGV0dGVPcHRpb25zID0gdW50aGVtZWRTZXJpZXMuaGFzKHNlcmllcy50eXBlKSA/IHsgY29sb3VySW5kZXg6IDAsIHVzZXJQYWxldHRlIH0gOiBwYWxldHRlT3B0aW9ucztcbiAgICAgIGNvbnN0IHBhbGV0dGUgPSB0aGlzLmdldFNlcmllc1BhbGV0dGUoc2VyaWVzLnR5cGUsIHNlcmllc1BhbGV0dGVPcHRpb25zLCBhY3RpdmVUaGVtZSk7XG4gICAgICBjb25zdCBkZWZhdWx0VG9vbHRpcFJhbmdlID0gdGhpcy5nZXRUb29sdGlwUmFuZ2VEZWZhdWx0cyhvcHRpb25zLCBzZXJpZXMudHlwZSk7XG4gICAgICBjb25zdCBzZXJpZXNPcHRpb25zID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgICAgdGhpcy5nZXRTZXJpZXNHcm91cGluZ09wdGlvbnMoc2VyaWVzKSxcbiAgICAgICAgc2VyaWVzLFxuICAgICAgICBkZWZhdWx0VG9vbHRpcFBvc2l0aW9uLFxuICAgICAgICBkZWZhdWx0VG9vbHRpcFJhbmdlLFxuICAgICAgICBzZXJpZXNUaGVtZSxcbiAgICAgICAgcGFsZXR0ZSxcbiAgICAgICAgeyB2aXNpYmxlOiB0cnVlIH1cbiAgICAgICk7XG4gICAgICBpZiAoc2VyaWVzT3B0aW9ucy5pbm5lckxhYmVscykge1xuICAgICAgICBzZXJpZXNPcHRpb25zLmlubmVyTGFiZWxzID0gbWVyZ2VBcnJheURlZmF1bHRzKHNlcmllc09wdGlvbnMuaW5uZXJMYWJlbHMsIGlubmVyTGFiZWxzVGhlbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlcmllc09wdGlvbnM7XG4gICAgfSk7XG4gICAgb3B0aW9ucy5zZXJpZXMgPSB0aGlzLnNldFNlcmllc0dyb3VwaW5nT3B0aW9ucyhwcm9jZXNzZWRTZXJpZXMgPz8gW10pO1xuICB9XG4gIHByb2Nlc3NNaW5pQ2hhcnRTZXJpZXNPcHRpb25zKG9wdGlvbnMsIGFjdGl2ZVRoZW1lKSB7XG4gICAgbGV0IG1pbmlDaGFydFNlcmllcyA9IG9wdGlvbnMubmF2aWdhdG9yPy5taW5pQ2hhcnQ/LnNlcmllcztcbiAgICBpZiAobWluaUNoYXJ0U2VyaWVzID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcGFsZXR0ZU9wdGlvbnMgPSB7XG4gICAgICBjb2xvdXJJbmRleDogMCxcbiAgICAgIHVzZXJQYWxldHRlOiBpc09iamVjdChvcHRpb25zLnRoZW1lKSA/IHBhbGV0dGVUeXBlKG9wdGlvbnMudGhlbWUucGFsZXR0ZSkgOiBcImluYnVpbHRcIlxuICAgIH07XG4gICAgbWluaUNoYXJ0U2VyaWVzID0gbWluaUNoYXJ0U2VyaWVzLm1hcCgoc2VyaWVzKSA9PiB7XG4gICAgICBzZXJpZXMudHlwZSA/PyAoc2VyaWVzLnR5cGUgPSBcImxpbmVcIik7XG4gICAgICBjb25zdCB7IGlubmVyTGFiZWxzOiBfLCAuLi5zZXJpZXNUaGVtZSB9ID0gdGhpcy5nZXRTZXJpZXNUaGVtZUNvbmZpZyhzZXJpZXMudHlwZSwgYWN0aXZlVGhlbWUpLnNlcmllcyA/PyB7fTtcbiAgICAgIHJldHVybiBtZXJnZURlZmF1bHRzKFxuICAgICAgICB0aGlzLmdldFNlcmllc0dyb3VwaW5nT3B0aW9ucyhzZXJpZXMpLFxuICAgICAgICBzZXJpZXMsXG4gICAgICAgIHNlcmllc1RoZW1lLFxuICAgICAgICB0aGlzLmdldFNlcmllc1BhbGV0dGUoc2VyaWVzLnR5cGUsIHBhbGV0dGVPcHRpb25zLCBhY3RpdmVUaGVtZSlcbiAgICAgICk7XG4gICAgfSk7XG4gICAgb3B0aW9ucy5uYXZpZ2F0b3IubWluaUNoYXJ0LnNlcmllcyA9IHRoaXMuc2V0U2VyaWVzR3JvdXBpbmdPcHRpb25zKG1pbmlDaGFydFNlcmllcyk7XG4gIH1cbiAgZ2V0VGhlbWVQYXJhbWV0ZXJzKHRoZW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmYXVsdFBhcmFtZXRlcnMgPSB0aGVtZS5nZXRQdWJsaWNQYXJhbWV0ZXJzKCk7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KG9wdGlvbnMudGhlbWUpIHx8ICFvcHRpb25zLnRoZW1lLnBhcmFtcykge1xuICAgICAgcmV0dXJuIGRlZmF1bHRQYXJhbWV0ZXJzO1xuICAgIH1cbiAgICBjb25zdCBjb2xvciA9IGF0dGFjaERlc2NyaXB0aW9uKFxuICAgICAgKHZhbHVlKSA9PiBpc1N0cmluZyh2YWx1ZSkgJiYgQ29sb3IudmFsaWRDb2xvclN0cmluZyh2YWx1ZSksXG4gICAgICBgYSBjb2xvcmBcbiAgICApO1xuICAgIGNvbnN0IHRoZW1lUGFyYW1zT3B0aW9uc0RlZiA9IHtcbiAgICAgIGFjY2VudENvbG9yOiBjb2xvcixcbiAgICAgIGF4aXNDb2xvcjogY29sb3IsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yLFxuICAgICAgYm9yZGVyQ29sb3I6IGNvbG9yLFxuICAgICAgZm9yZWdyb3VuZENvbG9yOiBjb2xvcixcbiAgICAgIGZvbnRGYW1pbHk6IHN0cmluZyxcbiAgICAgIGZvbnRTaXplOiBudW1iZXIsXG4gICAgICBmb250V2VpZ2h0OiBvcihzdHJpbmcsIG51bWJlciksXG4gICAgICBncmlkTGluZUNvbG9yOiBjb2xvcixcbiAgICAgIHBhZGRpbmc6IG51bWJlcixcbiAgICAgIHN1YnRsZVRleHRDb2xvcjogY29sb3IsXG4gICAgICB0ZXh0Q29sb3I6IGNvbG9yLFxuICAgICAgY2hyb21lQmFja2dyb3VuZENvbG9yOiBjb2xvcixcbiAgICAgIGNocm9tZUZvbnRGYW1pbHk6IHN0cmluZyxcbiAgICAgIGNocm9tZUZvbnRTaXplOiBudW1iZXIsXG4gICAgICBjaHJvbWVGb250V2VpZ2h0OiBvcihzdHJpbmcsIG51bWJlciksXG4gICAgICBjaHJvbWVTdWJ0bGVUZXh0Q29sb3I6IGNvbG9yLFxuICAgICAgY2hyb21lVGV4dENvbG9yOiBjb2xvcixcbiAgICAgIGlucHV0QmFja2dyb3VuZENvbG9yOiBjb2xvcixcbiAgICAgIGlucHV0VGV4dENvbG9yOiBjb2xvcixcbiAgICAgIGNyb3NzaGFpckxhYmVsQmFja2dyb3VuZENvbG9yOiBjb2xvcixcbiAgICAgIGNyb3NzaGFpckxhYmVsVGV4dENvbG9yOiBjb2xvclxuICAgIH07XG4gICAgY29uc3QgeyB2YWxpZCwgZXJyb3JzIH0gPSB2YWxpZGF0ZShvcHRpb25zLnRoZW1lLnBhcmFtcywgdGhlbWVQYXJhbXNPcHRpb25zRGVmKTtcbiAgICBmb3IgKGNvbnN0IHsgbWVzc2FnZSB9IG9mIGVycm9ycykge1xuICAgICAgbG9nZ2VyX2V4cG9ydHMud2Fybk9uY2UobWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZURlZmF1bHRzKHZhbGlkLCBkZWZhdWx0UGFyYW1ldGVycyk7XG4gIH1cbiAgcmVzb2x2ZVRoZW1lT3BlcmF0aW9ucyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtb2RpZmllZFBhdGhzID0ganNvblJlc29sdmVPcGVyYXRpb25zKG9wdGlvbnMsIHBhcmFtcywgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wicGFsZXR0ZVwiLCBcImRhdGFcIl0pKTtcbiAgICB0aGlzLmRlYnVnKFwicmVzb2x2ZVRoZW1lKClcIiwgbW9kaWZpZWRQYXRocyk7XG4gIH1cbiAgZ2V0U2VyaWVzUGFsZXR0ZShzZXJpZXNUeXBlLCBvcHRpb25zLCBhY3RpdmVUaGVtZSkge1xuICAgIGNvbnN0IHBhbGV0dGVGYWN0b3J5ID0gc2VyaWVzUmVnaXN0cnkuZ2V0UGFsZXR0ZUZhY3Rvcnkoc2VyaWVzVHlwZSk7XG4gICAgY29uc3QgeyBjb2xvdXJJbmRleDogY29sb3VyT2Zmc2V0LCB1c2VyUGFsZXR0ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IGZpbGxzID0gW10sIHN0cm9rZXMgPSBbXSB9ID0gYWN0aXZlVGhlbWUucGFsZXR0ZTtcbiAgICByZXR1cm4gcGFsZXR0ZUZhY3Rvcnk/Lih7XG4gICAgICB1c2VyUGFsZXR0ZSxcbiAgICAgIGNvbG9yc0NvdW50OiBNYXRoLm1heChmaWxscy5sZW5ndGgsIHN0cm9rZXMubGVuZ3RoKSxcbiAgICAgIHRoZW1lVGVtcGxhdGVQYXJhbWV0ZXJzOiBhY3RpdmVUaGVtZS5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSxcbiAgICAgIHBhbGV0dGU6IGFjdGl2ZVRoZW1lLnBhbGV0dGUsXG4gICAgICB0YWtlQ29sb3JzKGNvdW50KSB7XG4gICAgICAgIG9wdGlvbnMuY29sb3VySW5kZXggKz0gY291bnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZmlsbHM6IGNpcmN1bGFyU2xpY2VBcnJheShmaWxscywgY291bnQsIGNvbG91ck9mZnNldCksXG4gICAgICAgICAgc3Ryb2tlczogY2lyY3VsYXJTbGljZUFycmF5KHN0cm9rZXMsIGNvdW50LCBjb2xvdXJPZmZzZXQpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0U2VyaWVzR3JvdXBpbmdPcHRpb25zKHNlcmllcykge1xuICAgIGNvbnN0IGdyb3VwYWJsZSA9IHNlcmllc1JlZ2lzdHJ5LmlzR3JvdXBhYmxlKHNlcmllcy50eXBlKTtcbiAgICBjb25zdCBzdGFja2FibGUgPSBzZXJpZXNSZWdpc3RyeS5pc1N0YWNrYWJsZShzZXJpZXMudHlwZSk7XG4gICAgY29uc3Qgc3RhY2tlZEJ5RGVmYXVsdCA9IHNlcmllc1JlZ2lzdHJ5LmlzU3RhY2tlZEJ5RGVmYXVsdChzZXJpZXMudHlwZSk7XG4gICAgaWYgKHNlcmllcy5ncm91cGVkICYmICFncm91cGFibGUpIHtcbiAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKGB1bnN1cHBvcnRlZCBncm91cGluZyBvZiBzZXJpZXMgdHlwZSBcIiR7c2VyaWVzLnR5cGV9XCIuYCk7XG4gICAgfVxuICAgIGlmICgoc2VyaWVzLnN0YWNrZWQgfHwgc2VyaWVzLnN0YWNrR3JvdXApICYmICFzdGFja2FibGUpIHtcbiAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKGB1bnN1cHBvcnRlZCBzdGFja2luZyBvZiBzZXJpZXMgdHlwZSBcIiR7c2VyaWVzLnR5cGV9XCIuYCk7XG4gICAgfVxuICAgIGxldCB7IGdyb3VwZWQsIHN0YWNrZWQgfSA9IHNlcmllcztcbiAgICBzdGFja2VkID8/IChzdGFja2VkID0gKHN0YWNrZWRCeURlZmF1bHQgfHwgc2VyaWVzLnN0YWNrR3JvdXAgIT0gbnVsbCkgJiYgIShncm91cGFibGUgJiYgZ3JvdXBlZCkpO1xuICAgIGdyb3VwZWQgPz8gKGdyb3VwZWQgPSB0cnVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhY2tlZDogc3RhY2thYmxlICYmIHN0YWNrZWQsXG4gICAgICBncm91cGVkOiBncm91cGFibGUgJiYgZ3JvdXBlZCAmJiAhKHN0YWNrYWJsZSAmJiBzdGFja2VkKVxuICAgIH07XG4gIH1cbiAgc2V0U2VyaWVzR3JvdXBpbmdPcHRpb25zKGFsbFNlcmllcykge1xuICAgIGNvbnN0IHNlcmllc0dyb3VwcyA9IHRoaXMuZ2V0U2VyaWVzR3JvdXBpbmcoYWxsU2VyaWVzKTtcbiAgICB0aGlzLmRlYnVnKFwic2V0U2VyaWVzR3JvdXBpbmdPcHRpb25zKCkgLSBzZXJpZXMgZ3JvdXBpbmc6IFwiLCBzZXJpZXNHcm91cHMpO1xuICAgIGNvbnN0IGdyb3VwSWR4ID0ge307XG4gICAgY29uc3QgZ3JvdXBDb3VudDIgPSBzZXJpZXNHcm91cHMucmVkdWNlKChjb3VudE1hcCwgc2VyaWVzR3JvdXApID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChzZXJpZXNHcm91cC5ncm91cFR5cGUgPT09IFwiZGVmYXVsdFwiIC8qIERFRkFVTFQgKi8pIHtcbiAgICAgICAgcmV0dXJuIGNvdW50TWFwO1xuICAgICAgfVxuICAgICAgY291bnRNYXBbX2EgPSBzZXJpZXNHcm91cC5zZXJpZXNUeXBlXSA/PyAoY291bnRNYXBbX2FdID0gMCk7XG4gICAgICBjb3VudE1hcFtzZXJpZXNHcm91cC5zZXJpZXNUeXBlXSArPSBzZXJpZXNHcm91cC5ncm91cFR5cGUgPT09IFwic3RhY2tcIiAvKiBTVEFDSyAqLyA/IDEgOiBzZXJpZXNHcm91cC5zZXJpZXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGNvdW50TWFwO1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gc2VyaWVzR3JvdXBzLmZsYXRNYXAoKHNlcmllc0dyb3VwKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBncm91cElkeFtfYSA9IHNlcmllc0dyb3VwLnNlcmllc1R5cGVdID8/IChncm91cElkeFtfYV0gPSAwKTtcbiAgICAgIHN3aXRjaCAoc2VyaWVzR3JvdXAuZ3JvdXBUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdGFja1wiIC8qIFNUQUNLICovOiB7XG4gICAgICAgICAgY29uc3QgZ3JvdXBJbmRleCA9IGdyb3VwSWR4W3Nlcmllc0dyb3VwLnNlcmllc1R5cGVdKys7XG4gICAgICAgICAgcmV0dXJuIHNlcmllc0dyb3VwLnNlcmllcy5tYXAoXG4gICAgICAgICAgICAoc2VyaWVzLCBzdGFja0luZGV4KSA9PiBPYmplY3QuYXNzaWduKHNlcmllcywge1xuICAgICAgICAgICAgICBzZXJpZXNHcm91cGluZzoge1xuICAgICAgICAgICAgICAgIGdyb3VwSWQ6IHNlcmllc0dyb3VwLmdyb3VwSWQsXG4gICAgICAgICAgICAgICAgZ3JvdXBJbmRleCxcbiAgICAgICAgICAgICAgICBncm91cENvdW50OiBncm91cENvdW50MltzZXJpZXNHcm91cC5zZXJpZXNUeXBlXSxcbiAgICAgICAgICAgICAgICBzdGFja0luZGV4LFxuICAgICAgICAgICAgICAgIHN0YWNrQ291bnQ6IHNlcmllc0dyb3VwLnNlcmllcy5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJncm91cFwiIC8qIEdST1VQICovOlxuICAgICAgICAgIHJldHVybiBzZXJpZXNHcm91cC5zZXJpZXMubWFwKFxuICAgICAgICAgICAgKHNlcmllcykgPT4gT2JqZWN0LmFzc2lnbihzZXJpZXMsIHtcbiAgICAgICAgICAgICAgc2VyaWVzR3JvdXBpbmc6IHtcbiAgICAgICAgICAgICAgICBncm91cElkOiBzZXJpZXNHcm91cC5ncm91cElkLFxuICAgICAgICAgICAgICAgIGdyb3VwSW5kZXg6IGdyb3VwSWR4W3Nlcmllc0dyb3VwLnNlcmllc1R5cGVdKyssXG4gICAgICAgICAgICAgICAgZ3JvdXBDb3VudDogZ3JvdXBDb3VudDJbc2VyaWVzR3JvdXAuc2VyaWVzVHlwZV0sXG4gICAgICAgICAgICAgICAgc3RhY2tJbmRleDogMCxcbiAgICAgICAgICAgICAgICBzdGFja0NvdW50OiAwXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJpZXNHcm91cC5zZXJpZXM7XG4gICAgfSkubWFwKCh7IHN0YWNrZWQ6IF8sIGdyb3VwZWQ6IF9fLCAuLi5zZXJpZXNPcHRpb25zIH0pID0+IHNlcmllc09wdGlvbnMpO1xuICB9XG4gIGdldFNlcmllc0dyb3VwSWQoc2VyaWVzKSB7XG4gICAgcmV0dXJuIFtzZXJpZXMudHlwZSwgc2VyaWVzLnhLZXksIHNlcmllcy5zdGFja2VkID8gc2VyaWVzLnN0YWNrR3JvdXAgPz8gXCJzdGFja2VkXCIgOiBcImdyb3VwZWRcIl0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCItXCIpO1xuICB9XG4gIGdldFNlcmllc0dyb3VwaW5nKGFsbFNlcmllcykge1xuICAgIGNvbnN0IGdyb3VwTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICByZXR1cm4gYWxsU2VyaWVzLnJlZHVjZSgocmVzdWx0LCBzZXJpZXMpID0+IHtcbiAgICAgIGNvbnN0IHNlcmllc1R5cGUgPSBzZXJpZXMudHlwZTtcbiAgICAgIGlmICghc2VyaWVzLnN0YWNrZWQgJiYgIXNlcmllcy5ncm91cGVkKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHsgZ3JvdXBUeXBlOiBcImRlZmF1bHRcIiAvKiBERUZBVUxUICovLCBzZXJpZXNUeXBlLCBzZXJpZXM6IFtzZXJpZXNdLCBncm91cElkOiBcIl9fZGVmYXVsdF9fXCIgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBncm91cElkID0gdGhpcy5nZXRTZXJpZXNHcm91cElkKHNlcmllcyk7XG4gICAgICAgIGlmICghZ3JvdXBNYXAuaGFzKGdyb3VwSWQpKSB7XG4gICAgICAgICAgY29uc3QgZ3JvdXBUeXBlID0gc2VyaWVzLnN0YWNrZWQgPyBcInN0YWNrXCIgLyogU1RBQ0sgKi8gOiBcImdyb3VwXCIgLyogR1JPVVAgKi87XG4gICAgICAgICAgY29uc3QgcmVjb3JkID0geyBncm91cFR5cGUsIHNlcmllc1R5cGUsIHNlcmllczogW10sIGdyb3VwSWQgfTtcbiAgICAgICAgICBncm91cE1hcC5zZXQoZ3JvdXBJZCwgcmVjb3JkKTtcbiAgICAgICAgICByZXN1bHQucHVzaChyZWNvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGdyb3VwTWFwLmdldChncm91cElkKS5zZXJpZXMucHVzaChzZXJpZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG4gIH1cbiAgZ2V0RGVmYXVsdFNlcmllc1R5cGUob3B0aW9ucykge1xuICAgIGNvbnN0IGNoYXJ0RGVmID0gTW9kdWxlUmVnaXN0cnkuZGV0ZWN0Q2hhcnREZWZpbml0aW9uKG9wdGlvbnMpO1xuICAgIHN3aXRjaCAoY2hhcnREZWYubmFtZSkge1xuICAgICAgY2FzZSBcImNhcnRlc2lhblwiOlxuICAgICAgICByZXR1cm4gXCJsaW5lXCI7XG4gICAgICBjYXNlIFwicG9sYXJcIjpcbiAgICAgICAgcmV0dXJuIFwicGllXCI7XG4gICAgICBjYXNlIFwiaGllcmFyY2h5XCI6XG4gICAgICAgIHJldHVybiBcInRyZWVtYXBcIjtcbiAgICAgIGNhc2UgXCJ0b3BvbG9neVwiOlxuICAgICAgICByZXR1cm4gXCJtYXAtc2hhcGVcIjtcbiAgICAgIGNhc2UgXCJmbG93LXByb3BvcnRpb25cIjpcbiAgICAgICAgcmV0dXJuIFwic2Fua2V5XCI7XG4gICAgICBjYXNlIFwic3RhbmRhbG9uZVwiOlxuICAgICAgICByZXR1cm4gXCJweXJhbWlkXCI7XG4gICAgICBjYXNlIFwiZ2F1Z2VcIjpcbiAgICAgICAgcmV0dXJuIFwicmFkaWFsLWdhdWdlXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNoYXJ0IG9wdGlvbnMgdHlwZSBkZXRlY3RlZC5cIik7XG4gICAgfVxuICB9XG4gIGdldFRvb2x0aXBQb3NpdGlvbkRlZmF1bHRzKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG9wdGlvbnMudG9vbHRpcD8ucG9zaXRpb247XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHR5cGUsIHhPZmZzZXQsIHlPZmZzZXQgfSA9IHBvc2l0aW9uO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGlmIChpc1N0cmluZyh0eXBlKSAmJiBpc0VudW1WYWx1ZShBZ1Rvb2x0aXBQb3NpdGlvblR5cGUsIHR5cGUpKSB7XG4gICAgICByZXN1bHQudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIGlmIChpc0Zpbml0ZU51bWJlcih4T2Zmc2V0KSkge1xuICAgICAgcmVzdWx0LnhPZmZzZXQgPSB4T2Zmc2V0O1xuICAgIH1cbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoeU9mZnNldCkpIHtcbiAgICAgIHJlc3VsdC55T2Zmc2V0ID0geU9mZnNldDtcbiAgICB9XG4gICAgcmV0dXJuIHsgdG9vbHRpcDogeyBwb3NpdGlvbjogcmVzdWx0IH0gfTtcbiAgfVxuICAvLyBBRy0xMTU5MSBTdXBwb3J0IGZvciBuZXcgc2VyaWVzLXNwZWNpZmljICYgbGVnYWN5IGNoYXJ0LWdsb2JhbCAndG9vbHRpcC5yYW5nZScgb3B0aW9uc1xuICAvL1xuICAvLyBUaGUgYGNoYXJ0LnNlcmllc1tdLnRvb2x0aXAucmFuZ2VgIG9wdGlvbiBpcyBhIGJpdCBkaWZmZXJlbnQgZm9yIGxlZ2FjeSByZWFzb24uIFRoaXMgdXNlIHRvIGJlXG4gIC8vIGdsb2JhbCBvcHRpb24gKGBjaGFydC50b29sdGlwLnJhbmdlYCkgdGhhdCBjb3VsZCBvdmVycmlkZSB0aGUgdGhlbWUuIEJ1dCBub3csIHRoZSB0b29sdGlwIHJhbmdlXG4gIC8vIG9wdGlvbiBpcyBzZXJpZXMtc3BlY2lmaWMuXG4gIC8vXG4gIC8vIFRvIHByZXNlcnZlIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSBgY2hhcnQudG9vbHRpcC5yYW5nZWAgdGhlbWUgZGVmYXVsdCBoYXMgYmVlbiBjaGFuZ2VkIGZyb21cbiAgLy8gJ25lYXJlc3QnIHRvIHVuZGVmaW5lZC5cbiAgZ2V0VG9vbHRpcFJhbmdlRGVmYXVsdHMob3B0aW9ucywgc2VyaWVzVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICB0b29sdGlwOiB7XG4gICAgICAgIHJhbmdlOiBvcHRpb25zLnRvb2x0aXA/LnJhbmdlID8/IHNlcmllc1JlZ2lzdHJ5LmdldFRvb2x0aXBEZWZhdWxzKHNlcmllc1R5cGUpPy5yYW5nZVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYXhlc1R5cGVJbnRlZ3JpdHkob3B0aW9ucykge1xuICAgIGlmIChcImF4ZXNcIiBpbiBvcHRpb25zICYmIG9wdGlvbnMuYXhlcykge1xuICAgICAgY29uc3QgYXhlcyA9IG9wdGlvbnMuYXhlcztcbiAgICAgIGZvciAoY29uc3QgeyB0eXBlIH0gb2YgYXhlcykge1xuICAgICAgICBpZiAoIWlzQXhpc09wdGlvblR5cGUodHlwZSkpIHtcbiAgICAgICAgICBkZWxldGUgb3B0aW9ucy5heGVzO1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbLi4uYXhpc1JlZ2lzdHJ5LmtleXMoKV0uam9pbihcIiwgXCIpO1xuICAgICAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKGB1bmtub3duIGF4aXMgdHlwZTogJHt0eXBlfTsgZXhwZWN0ZWQgb25lIG9mOiAke2V4cGVjdGVkVHlwZXN9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2VyaWVzVHlwZUludGVncml0eShvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5zZXJpZXMgPSBvcHRpb25zLnNlcmllcz8uZmlsdGVyKCh7IHR5cGUgfSkgPT4ge1xuICAgICAgaWYgKHR5cGUgPT0gbnVsbCB8fCBpc1Nlcmllc09wdGlvblR5cGUodHlwZSkgfHwgaXNFbnRlcnByaXNlU2VyaWVzVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm5PbmNlKFxuICAgICAgICBgdW5rbm93biBzZXJpZXMgdHlwZTogJHtKU09OLnN0cmluZ2lmeSh0eXBlKX07IGV4cGVjdGVkIG9uZSBvZjogJHtwdWJsaWNDaGFydFR5cGVzLnNlcmllc1R5cGVzLmpvaW4oXCIsIFwiKX1gXG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIHNvbG9TZXJpZXNJbnRlZ3JpdHkob3B0aW9ucykge1xuICAgIGNvbnN0IGFsbFNlcmllcyA9IG9wdGlvbnMuc2VyaWVzO1xuICAgIGlmIChhbGxTZXJpZXMgJiYgYWxsU2VyaWVzLmxlbmd0aCA+IDEgJiYgYWxsU2VyaWVzLnNvbWUoKHNlcmllcykgPT4gc2VyaWVzUmVnaXN0cnkuaXNTb2xvKHNlcmllcy50eXBlKSkpIHtcbiAgICAgIGNvbnN0IG1haW5TZXJpZXNUeXBlID0gdGhpcy5vcHRpb25zVHlwZShvcHRpb25zKTtcbiAgICAgIGlmIChzZXJpZXNSZWdpc3RyeS5pc1NvbG8obWFpblNlcmllc1R5cGUpKSB7XG4gICAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm4oXG4gICAgICAgICAgYHNlcmllc1swXSBvZiB0eXBlICcke21haW5TZXJpZXNUeXBlfScgaXMgaW5jb21wYXRpYmxlIHdpdGggb3RoZXIgc2VyaWVzIHR5cGVzLiBPbmx5IHByb2Nlc3Npbmcgc2VyaWVzWzBdYFxuICAgICAgICApO1xuICAgICAgICBvcHRpb25zLnNlcmllcyA9IGFsbFNlcmllcy5zbGljZSgwLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgc29sbywgbm9uU29sbyB9ID0gZ3JvdXBCeShcbiAgICAgICAgICBhbGxTZXJpZXMsXG4gICAgICAgICAgKHMpID0+IHNlcmllc1JlZ2lzdHJ5LmlzU29sbyhzLnR5cGUpID8gXCJzb2xvXCIgOiBcIm5vblNvbG9cIlxuICAgICAgICApO1xuICAgICAgICBjb25zdCByZWplY3RzID0gdW5pcXVlKHNvbG8ubWFwKChzKSA9PiBzLnR5cGUpKS5qb2luKFwiLCBcIik7XG4gICAgICAgIGxvZ2dlcl9leHBvcnRzLndhcm4oYFVuYWJsZSB0byBtaXggdGhlc2Ugc2VyaWVzIHR5cGVzIHdpdGggdGhlIGxlYWQgc2VyaWVzIHR5cGU6ICR7cmVqZWN0c31gKTtcbiAgICAgICAgb3B0aW9ucy5zZXJpZXMgPSBub25Tb2xvO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgZW5hYmxlQ29uZmlndXJlZEpzb25PcHRpb25zKHZpc2l0aW5nVXNlck9wdHMsIHZpc2l0aW5nTWVyZ2VkT3B0cykge1xuICAgIGlmICh0eXBlb2YgdmlzaXRpbmdNZXJnZWRPcHRzID09PSBcIm9iamVjdFwiICYmIFwiZW5hYmxlZFwiIGluIHZpc2l0aW5nTWVyZ2VkT3B0cyAmJiAhdmlzaXRpbmdNZXJnZWRPcHRzLl9lbmFibGVkRnJvbVRoZW1lICYmIHZpc2l0aW5nVXNlck9wdHMuZW5hYmxlZCA9PSBudWxsKSB7XG4gICAgICB2aXNpdGluZ01lcmdlZE9wdHMuZW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjbGVhbnVwRW5hYmxlZEZyb21UaGVtZUpzb25PcHRpb25zKHZpc2l0aW5nTWVyZ2VkT3B0cykge1xuICAgIGlmICh2aXNpdGluZ01lcmdlZE9wdHMuX2VuYWJsZWRGcm9tVGhlbWUgIT0gbnVsbCkge1xuICAgICAgZGVsZXRlIHZpc2l0aW5nTWVyZ2VkT3B0cy5fZW5hYmxlZEZyb21UaGVtZTtcbiAgICB9XG4gIH1cbiAgZW5hYmxlQ29uZmlndXJlZE9wdGlvbnMob3B0aW9ucywgdXNlck9wdGlvbnMpIHtcbiAgICBqc29uV2Fsayh1c2VyT3B0aW9ucywgX0NoYXJ0T3B0aW9ucy5lbmFibGVDb25maWd1cmVkSnNvbk9wdGlvbnMsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImRhdGFcIiwgXCJ0aGVtZVwiXSksIG9wdGlvbnMpO1xuICAgIGpzb25XYWxrKG9wdGlvbnMsIF9DaGFydE9wdGlvbnMuY2xlYW51cEVuYWJsZWRGcm9tVGhlbWVKc29uT3B0aW9ucywgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZGF0YVwiLCBcInRoZW1lXCJdKSk7XG4gIH1cbiAgc3RhdGljIHJlbW92ZURpc2FibGVkT3B0aW9uSnNvbihvcHRpb25zTm9kZSkge1xuICAgIGlmIChcImVuYWJsZWRcIiBpbiBvcHRpb25zTm9kZSAmJiBvcHRpb25zTm9kZS5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgT2JqZWN0LmtleXMob3B0aW9uc05vZGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAoa2V5ID09PSBcImVuYWJsZWRcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zTm9kZVtrZXldO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlbW92ZURpc2FibGVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAganNvbldhbGsob3B0aW9ucywgX0NoYXJ0T3B0aW9ucy5yZW1vdmVEaXNhYmxlZE9wdGlvbkpzb24sIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImRhdGFcIiwgXCJ0aGVtZVwiXSkpO1xuICB9XG4gIHN0YXRpYyByZW1vdmVMZWZ0b3ZlclN5bWJvbHNKc29uKG9wdGlvbnNOb2RlKSB7XG4gICAgaWYgKCFvcHRpb25zTm9kZSB8fCAhaXNPYmplY3Qob3B0aW9uc05vZGUpKVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnNOb2RlKSkge1xuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICBkZWxldGUgb3B0aW9uc05vZGVba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVtb3ZlTGVmdG92ZXJTeW1ib2xzKG9wdGlvbnMpIHtcbiAgICBqc29uV2FsayhvcHRpb25zLCBfQ2hhcnRPcHRpb25zLnJlbW92ZUxlZnRvdmVyU3ltYm9sc0pzb24sIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImRhdGFcIl0pKTtcbiAgfVxuICBzcGVjaWFsT3ZlcnJpZGVzRGVmYXVsdHMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLndpbmRvdyAhPSBudWxsKSB7XG4gICAgICBzZXRXaW5kb3cob3B0aW9ucy53aW5kb3cpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgb3B0aW9ucy53aW5kb3cgPSB3aW5kb3c7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBvcHRpb25zLndpbmRvdyA9IGdsb2JhbC53aW5kb3c7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRvY3VtZW50ICE9IG51bGwpIHtcbiAgICAgIHNldERvY3VtZW50KG9wdGlvbnMuZG9jdW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBvcHRpb25zLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBvcHRpb25zLmRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy53aW5kb3cgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gdW5hYmxlIHRvIHJlc29sdmUgZ2xvYmFsIHdpbmRvd1wiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZG9jdW1lbnQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gdW5hYmxlIHRvIHJlc29sdmUgZ2xvYmFsIGRvY3VtZW50XCIpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxufTtcbl9DaGFydE9wdGlvbnMuT1BUSU9OU19DTE9ORV9PUFRTID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZGF0YVwiLCBcImNvbnRhaW5lclwiXSk7XG5fQ2hhcnRPcHRpb25zLkZBU1RfUEFUSF9PUFRJT05TID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZGF0YVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCJdKTtcbnZhciBDaGFydE9wdGlvbnMgPSBfQ2hhcnRPcHRpb25zO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3Bvb2wudHNcbnZhciBDTEVBTlVQX1RJTUVPVVRfTVMgPSAxMDA7XG52YXIgX1Bvb2wgPSBjbGFzcyBfUG9vbCB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGJ1aWxkSXRlbSwgcmVsZWFzZUl0ZW0sIGRlc3Ryb3lJdGVtLCBtYXhQb29sU2l6ZSwgY2xlYW51cFRpbWVNcyA9IENMRUFOVVBfVElNRU9VVF9NUykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5idWlsZEl0ZW0gPSBidWlsZEl0ZW07XG4gICAgdGhpcy5yZWxlYXNlSXRlbSA9IHJlbGVhc2VJdGVtO1xuICAgIHRoaXMuZGVzdHJveUl0ZW0gPSBkZXN0cm95SXRlbTtcbiAgICB0aGlzLm1heFBvb2xTaXplID0gbWF4UG9vbFNpemU7XG4gICAgdGhpcy5jbGVhbnVwVGltZU1zID0gY2xlYW51cFRpbWVNcztcbiAgICB0aGlzLmZyZWVQb29sID0gW107XG4gICAgdGhpcy5idXN5UG9vbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIH1cbiAgc3RhdGljIGdldFBvb2wobmFtZSwgYnVpbGRJdGVtLCByZWxlYXNlSXRlbSwgZGVzdHJveUl0ZW0sIG1heFBvb2xTaXplKSB7XG4gICAgaWYgKCF0aGlzLnBvb2xzLmhhcyhuYW1lKSkge1xuICAgICAgdGhpcy5wb29scy5zZXQobmFtZSwgbmV3IF9Qb29sKG5hbWUsIGJ1aWxkSXRlbSwgcmVsZWFzZUl0ZW0sIGRlc3Ryb3lJdGVtLCBtYXhQb29sU2l6ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wb29scy5nZXQobmFtZSk7XG4gIH1cbiAgaXNGdWxsKCkge1xuICAgIHJldHVybiB0aGlzLmZyZWVQb29sLmxlbmd0aCArIHRoaXMuYnVzeVBvb2wuc2l6ZSA+PSB0aGlzLm1heFBvb2xTaXplO1xuICB9XG4gIG9idGFpbihwYXJhbXMpIHtcbiAgICBpZiAodGhpcy5mcmVlUG9vbC5sZW5ndGggPT09IDAgJiYgdGhpcy5pc0Z1bGwoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gcG9vbCBleGhhdXN0ZWRcIik7XG4gICAgfVxuICAgIGxldCBuZXh0RnJlZSA9IHRoaXMuZnJlZVBvb2wucG9wKCk7XG4gICAgaWYgKG5leHRGcmVlID09IG51bGwpIHtcbiAgICAgIG5leHRGcmVlID0gdGhpcy5idWlsZEl0ZW0ocGFyYW1zKTtcbiAgICAgIF9Qb29sLmRlYnVnKFxuICAgICAgICBgUG9vbFtuYW1lPSR7dGhpcy5uYW1lfV06IENyZWF0ZWQgaW5zdGFuY2UgKCR7dGhpcy5mcmVlUG9vbC5sZW5ndGh9IC8gJHt0aGlzLmJ1c3lQb29sLnNpemUgKyAxfSAvICR7dGhpcy5tYXhQb29sU2l6ZX0pYCxcbiAgICAgICAgbmV4dEZyZWVcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9Qb29sLmRlYnVnKFxuICAgICAgICBgUG9vbFtuYW1lPSR7dGhpcy5uYW1lfV06IFJlLXVzZWQgaW5zdGFuY2UgKCR7dGhpcy5mcmVlUG9vbC5sZW5ndGh9IC8gJHt0aGlzLmJ1c3lQb29sLnNpemUgKyAxfSAvICR7dGhpcy5tYXhQb29sU2l6ZX0pYCxcbiAgICAgICAgbmV4dEZyZWVcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuYnVzeVBvb2wuYWRkKG5leHRGcmVlKTtcbiAgICByZXR1cm4geyBpdGVtOiBuZXh0RnJlZSwgcmVsZWFzZTogKCkgPT4gdGhpcy5yZWxlYXNlKG5leHRGcmVlKSB9O1xuICB9XG4gIHJlbGVhc2UoaXRlbSkge1xuICAgIGlmICghdGhpcy5idXN5UG9vbC5oYXMoaXRlbSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIGNhbm5vdCBmcmVlIGl0ZW0gZnJvbSBwb29sIHdoaWNoIGlzIG5vdCB0cmFja2VkIGFzIGJ1c3kuXCIpO1xuICAgIH1cbiAgICBfUG9vbC5kZWJ1ZyhcbiAgICAgIGBQb29sW25hbWU9JHt0aGlzLm5hbWV9XTogUmVsZWFzaW5nIGluc3RhbmNlICgke3RoaXMuZnJlZVBvb2wubGVuZ3RofSAvICR7dGhpcy5idXN5UG9vbC5zaXplfSAvICR7dGhpcy5tYXhQb29sU2l6ZX0pYCxcbiAgICAgIGl0ZW1cbiAgICApO1xuICAgIHRoaXMucmVsZWFzZUl0ZW0oaXRlbSk7XG4gICAgdGhpcy5idXN5UG9vbC5kZWxldGUoaXRlbSk7XG4gICAgdGhpcy5mcmVlUG9vbC5wdXNoKGl0ZW0pO1xuICAgIF9Qb29sLmRlYnVnKFxuICAgICAgYFBvb2xbbmFtZT0ke3RoaXMubmFtZX1dOiBSZXR1cm5lZCBpbnN0YW5jZSB0byBmcmVlIHBvb2wgKCR7dGhpcy5mcmVlUG9vbC5sZW5ndGh9IC8gJHt0aGlzLmJ1c3lQb29sLnNpemV9IC8gJHt0aGlzLm1heFBvb2xTaXplfSlgLFxuICAgICAgaXRlbVxuICAgICk7XG4gICAgaWYgKHRoaXMuY2xlYW5Qb29sVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNsZWFuUG9vbFRpbWVyKTtcbiAgICB9XG4gICAgdGhpcy5jbGVhblBvb2xUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5jbGVhblBvb2woKTtcbiAgICB9LCB0aGlzLmNsZWFudXBUaW1lTXMpO1xuICB9XG4gIGNsZWFuUG9vbCgpIHtcbiAgICBjb25zdCBpdGVtc1RvRnJlZSA9IHRoaXMuZnJlZVBvb2wuc3BsaWNlKDApO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtc1RvRnJlZSkge1xuICAgICAgdGhpcy5kZXN0cm95SXRlbShpdGVtKTtcbiAgICB9XG4gICAgX1Bvb2wuZGVidWcoXG4gICAgICBgUG9vbFtuYW1lPSR7dGhpcy5uYW1lfV06IENsZWFuZWQgcG9vbCBvZiAke2l0ZW1zVG9GcmVlLmxlbmd0aH0gaXRlbXMgKCR7dGhpcy5mcmVlUG9vbC5sZW5ndGh9IC8gJHt0aGlzLmJ1c3lQb29sLnNpemV9IC8gJHt0aGlzLm1heFBvb2xTaXplfSlgXG4gICAgKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2xlYW5Qb29sKCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuYnVzeVBvb2wudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuZGVzdHJveUl0ZW0oaXRlbSk7XG4gICAgfVxuICAgIHRoaXMuYnVzeVBvb2wuY2xlYXIoKTtcbiAgfVxufTtcbl9Qb29sLnBvb2xzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbl9Qb29sLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwicG9vbFwiKTtcbnZhciBQb29sID0gX1Bvb2w7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2FwaS9hZ0NoYXJ0cy50c1xuTW9kdWxlUmVnaXN0cnkucmVnaXN0ZXJNYW55KFtDYXJ0ZXNpYW5DaGFydE1vZHVsZSwgUG9sYXJDaGFydE1vZHVsZV0pO1xudmFyIGRlYnVnMyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcIm9wdHNcIik7XG52YXIgQWdDaGFydHMgPSBjbGFzcyB7XG4gIHN0YXRpYyBsaWNlbnNlQ2hlY2sob3B0aW9ucykge1xuICAgIGlmICh0aGlzLmxpY2Vuc2VDaGVja2VkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMubGljZW5zZU1hbmFnZXIgPSBlbnRlcnByaXNlTW9kdWxlLmxpY2Vuc2VNYW5hZ2VyPy4ob3B0aW9ucyk7XG4gICAgdGhpcy5saWNlbnNlTWFuYWdlcj8udmFsaWRhdGVMaWNlbnNlKCk7XG4gICAgdGhpcy5saWNlbnNlQ2hlY2tlZCA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGdldExpY2Vuc2VEZXRhaWxzKGxpY2Vuc2VLZXkpIHtcbiAgICByZXR1cm4gZW50ZXJwcmlzZU1vZHVsZS5saWNlbnNlTWFuYWdlcj8uKHt9KS5nZXRMaWNlbnNlRGV0YWlscyhsaWNlbnNlS2V5KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYEFnQ2hhcnRJbnN0YW5jZWAgZm9yIGEgRE9NIG5vZGUsIGlmIHRoZXJlIGlzIG9uZS5cbiAgICovXG4gIHN0YXRpYyBnZXRJbnN0YW5jZShlbGVtZW50Mikge1xuICAgIHJldHVybiBBZ0NoYXJ0c0ludGVybmFsLmdldEluc3RhbmNlKGVsZW1lbnQyKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBBZ0NoYXJ0SW5zdGFuY2VgIGJhc2VkIHVwb24gdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGUodXNlck9wdGlvbnMsIG9wdGlvbnNNZXRhZGF0YSkge1xuICAgIHJldHVybiBkZWJ1ZzMuZ3JvdXAoXCJBZ0NoYXJ0cy5jcmVhdGUoKVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmxpY2Vuc2VDaGVjayh1c2VyT3B0aW9ucyk7XG4gICAgICBjb25zdCBjaGFydCA9IEFnQ2hhcnRzSW50ZXJuYWwuY3JlYXRlT3JVcGRhdGUoe1xuICAgICAgICB1c2VyT3B0aW9ucyxcbiAgICAgICAgbGljZW5zZU1hbmFnZXI6IHRoaXMubGljZW5zZU1hbmFnZXIsXG4gICAgICAgIG9wdGlvbnNNZXRhZGF0YVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5saWNlbnNlTWFuYWdlcj8uaXNEaXNwbGF5V2F0ZXJtYXJrKCkgJiYgdGhpcy5saWNlbnNlTWFuYWdlcikge1xuICAgICAgICBlbnRlcnByaXNlTW9kdWxlLmluamVjdFdhdGVybWFyaz8uKFxuICAgICAgICAgIGNoYXJ0LmNoYXJ0LmN0eC5kb21NYW5hZ2VyLFxuICAgICAgICAgIHRoaXMubGljZW5zZU1hbmFnZXIuZ2V0V2F0ZXJtYXJrTWVzc2FnZSgpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUZpbmFuY2lhbENoYXJ0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZGVidWczLmdyb3VwKFwiQWdDaGFydHMuY3JlYXRlRmluYW5jaWFsQ2hhcnQoKVwiLCAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGUob3B0aW9ucywgeyBwcmVzZXRUeXBlOiBcInByaWNlLXZvbHVtZVwiIH0pO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVHYXVnZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRlYnVnMy5ncm91cChcIkFnQ2hhcnRzLmNyZWF0ZUdhdWdlKClcIiwgKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKG9wdGlvbnMsIHsgcHJlc2V0VHlwZTogXCJnYXVnZVwiIH0pO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBfX2NyZWF0ZVNwYXJrbGluZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRlYnVnMy5ncm91cChcIkFnQ2hhcnRzLl9fY3JlYXRlU3BhcmtsaW5lKClcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgeyBwb29sLCAuLi5ub3JtYWxPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKG5vcm1hbE9wdGlvbnMsIHsgcHJlc2V0VHlwZTogXCJzcGFya2xpbmVcIiwgcG9vbDogcG9vbCA/PyB0cnVlIH0pO1xuICAgIH0pO1xuICB9XG59O1xuQWdDaGFydHMubGljZW5zZUNoZWNrZWQgPSBmYWxzZTtcbnZhciBfQWdDaGFydHNJbnRlcm5hbCA9IGNsYXNzIF9BZ0NoYXJ0c0ludGVybmFsIHtcbiAgc3RhdGljIGdldEluc3RhbmNlKGVsZW1lbnQyKSB7XG4gICAgY29uc3QgY2hhcnQgPSBDaGFydC5nZXRJbnN0YW5jZShlbGVtZW50Mik7XG4gICAgcmV0dXJuIGNoYXJ0ID8gQWdDaGFydEluc3RhbmNlUHJveHkuY2hhcnRJbnN0YW5jZXMuZ2V0KGNoYXJ0KSA6IHZvaWQgMDtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGlzZU1vZHVsZXMoKSB7XG4gICAgaWYgKF9BZ0NoYXJ0c0ludGVybmFsLmluaXRpYWxpc2VkKVxuICAgICAgcmV0dXJuO1xuICAgIHJlZ2lzdGVySW5idWlsdE1vZHVsZXMoKTtcbiAgICBzZXR1cE1vZHVsZXMoKTtcbiAgICBfQWdDaGFydHNJbnRlcm5hbC5pbml0aWFsaXNlZCA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZU9yVXBkYXRlKG9wdHMpIHtcbiAgICBsZXQgeyBwcm94eSB9ID0gb3B0cztcbiAgICBjb25zdCB7XG4gICAgICB1c2VyT3B0aW9ucyxcbiAgICAgIGxpY2Vuc2VNYW5hZ2VyLFxuICAgICAgcHJvY2Vzc2VkT3ZlcnJpZGVzID0gcHJveHk/LmNoYXJ0LmNoYXJ0T3B0aW9ucy5wcm9jZXNzZWRPdmVycmlkZXMgPz8ge30sXG4gICAgICBzcGVjaWFsT3ZlcnJpZGVzID0gcHJveHk/LmNoYXJ0LmNoYXJ0T3B0aW9ucy5zcGVjaWFsT3ZlcnJpZGVzID8/IHt9LFxuICAgICAgb3B0aW9uc01ldGFkYXRhID0gcHJveHk/LmNoYXJ0LmNoYXJ0T3B0aW9ucy5vcHRpb25NZXRhZGF0YSA/PyB7fSxcbiAgICAgIGRlbHRhT3B0aW9ucyxcbiAgICAgIHN0cmlwU3ltYm9scyA9IGZhbHNlXG4gICAgfSA9IG9wdHM7XG4gICAgY29uc3Qgc3R5bGVzID0gZW50ZXJwcmlzZU1vZHVsZS5zdHlsZXMgIT0gbnVsbCA/IFtbXCJhZy1jaGFydHMtZW50ZXJwcmlzZVwiLCBlbnRlcnByaXNlTW9kdWxlLnN0eWxlc11dIDogW107XG4gICAgY29uc3QgeyBwcmVzZXRUeXBlIH0gPSBvcHRpb25zTWV0YWRhdGE7XG4gICAgX0FnQ2hhcnRzSW50ZXJuYWwuaW5pdGlhbGlzZU1vZHVsZXMoKTtcbiAgICBkZWJ1ZzMoKCkgPT4gW1wiPj4+IEFnQ2hhcnRzLmNyZWF0ZU9yVXBkYXRlKCkgdXNlciBvcHRpb25zXCIsIGRlZXBDbG9uZSh1c2VyT3B0aW9ucyldKTtcbiAgICBsZXQgbXV0YWJsZU9wdGlvbnMgPSB1c2VyT3B0aW9ucztcbiAgICBpZiAoQWdDaGFydHMub3B0aW9uc011dGF0aW9uRm4gJiYgbXV0YWJsZU9wdGlvbnMpIHtcbiAgICAgIG11dGFibGVPcHRpb25zID0gQWdDaGFydHMub3B0aW9uc011dGF0aW9uRm4oZGVlcENsb25lKG11dGFibGVPcHRpb25zKSwgcHJlc2V0VHlwZSk7XG4gICAgICBkZWJ1ZzMoKCkgPT4gW1wiPj4+IEFnQ2hhcnRzLmNyZWF0ZU9yVXBkYXRlKCkgTVVUQVRFRCB1c2VyIG9wdGlvbnNcIiwgZGVlcENsb25lKG11dGFibGVPcHRpb25zKV0pO1xuICAgIH1cbiAgICBjb25zdCB7IGRvY3VtZW50OiBkb2N1bWVudDIsIHdpbmRvdzogdXNlcldpbmRvdywgc3R5bGVDb250YWluZXIsIC4uLm9wdGlvbnMgfSA9IG11dGFibGVPcHRpb25zID8/IHt9O1xuICAgIGNvbnN0IGJhc2VPcHRpb25zID0gKGRlbHRhT3B0aW9ucyA/IHByb3h5Py5jaGFydC5nZXRDaGFydE9wdGlvbnMoKSA6IG9wdGlvbnMpID8/IG9wdGlvbnM7XG4gICAgY29uc3QgY2hhcnRPcHRpb25zID0gbmV3IENoYXJ0T3B0aW9ucyhcbiAgICAgIGJhc2VPcHRpb25zLFxuICAgICAgcHJvY2Vzc2VkT3ZlcnJpZGVzLFxuICAgICAge1xuICAgICAgICAuLi5zcGVjaWFsT3ZlcnJpZGVzLFxuICAgICAgICBkb2N1bWVudDogZG9jdW1lbnQyLFxuICAgICAgICB3aW5kb3c6IHVzZXJXaW5kb3csXG4gICAgICAgIHN0eWxlQ29udGFpbmVyXG4gICAgICB9LFxuICAgICAgb3B0aW9uc01ldGFkYXRhLFxuICAgICAgZGVsdGFPcHRpb25zLFxuICAgICAgc3RyaXBTeW1ib2xzXG4gICAgKTtcbiAgICBsZXQgY3JlYXRlID0gZmFsc2U7XG4gICAgbGV0IGNoYXJ0ID0gcHJveHk/LmNoYXJ0O1xuICAgIGxldCBwb29sUmVzdWx0O1xuICAgIGlmIChjaGFydCA9PSBudWxsIHx8IE1vZHVsZVJlZ2lzdHJ5LmRldGVjdENoYXJ0RGVmaW5pdGlvbihjaGFydE9wdGlvbnMucHJvY2Vzc2VkT3B0aW9ucykgIT09IE1vZHVsZVJlZ2lzdHJ5LmRldGVjdENoYXJ0RGVmaW5pdGlvbihjaGFydC5jaGFydE9wdGlvbnMucHJvY2Vzc2VkT3B0aW9ucykpIHtcbiAgICAgIHBvb2xSZXN1bHQgPSB0aGlzLmdldFBvb2woY2hhcnRPcHRpb25zKT8ub2J0YWluKGNoYXJ0T3B0aW9ucyk7XG4gICAgICBpZiAocG9vbFJlc3VsdCkge1xuICAgICAgICBjaGFydCA9IHBvb2xSZXN1bHQuaXRlbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZSA9IHRydWU7XG4gICAgICAgIGNoYXJ0ID0gX0FnQ2hhcnRzSW50ZXJuYWwuY3JlYXRlQ2hhcnRJbnN0YW5jZShjaGFydE9wdGlvbnMsIGNoYXJ0KTtcbiAgICAgIH1cbiAgICAgIHN0eWxlcy5mb3JFYWNoKChbaWQsIGNzc10pID0+IHtcbiAgICAgICAgY2hhcnQ/LmN0eC5kb21NYW5hZ2VyLmFkZFN0eWxlcyhpZCwgY3NzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocHJveHkgPT0gbnVsbCkge1xuICAgICAgcHJveHkgPSBuZXcgQWdDaGFydEluc3RhbmNlUHJveHkoY2hhcnQsIF9BZ0NoYXJ0c0ludGVybmFsLmNhbGxiYWNrQXBpLCBsaWNlbnNlTWFuYWdlcik7XG4gICAgICBwcm94eS5yZWxlYXNlQ2hhcnQgPSBwb29sUmVzdWx0Py5yZWxlYXNlO1xuICAgIH0gZWxzZSBpZiAocG9vbFJlc3VsdCB8fCBjcmVhdGUpIHtcbiAgICAgIHByb3h5LnJlbGVhc2VDaGFydD8uKCk7XG4gICAgICBwcm94eS5jaGFydCA9IGNoYXJ0O1xuICAgICAgcHJveHkucmVsZWFzZUNoYXJ0ID0gcG9vbFJlc3VsdD8ucmVsZWFzZTtcbiAgICB9XG4gICAgaWYgKGRlYnVnMy5jaGVjaygpICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5hZ0NoYXJ0SW5zdGFuY2VzID8/ICh3aW5kb3cuYWdDaGFydEluc3RhbmNlcyA9IHt9KTtcbiAgICAgIHdpbmRvdy5hZ0NoYXJ0SW5zdGFuY2VzW2NoYXJ0LmlkXSA9IGNoYXJ0O1xuICAgIH1cbiAgICBjaGFydC5xdWV1ZWRVc2VyT3B0aW9ucy5wdXNoKGNoYXJ0T3B0aW9ucy51c2VyT3B0aW9ucyk7XG4gICAgY2hhcnQucXVldWVkQ2hhcnRPcHRpb25zLnB1c2goY2hhcnRPcHRpb25zKTtcbiAgICBjaGFydC5yZXF1ZXN0RmFjdG9yeVVwZGF0ZSgoY2hhcnRSZWYpID0+IHtcbiAgICAgIGRlYnVnMy5ncm91cChcIj4+Pj4gQ2hhcnQuYXBwbHlPcHRpb25zKClcIiwgKCkgPT4ge1xuICAgICAgICBjaGFydFJlZi5hcHBseU9wdGlvbnMoY2hhcnRPcHRpb25zKTtcbiAgICAgICAgY29uc3QgcXVldWVJZHggPSBjaGFydFJlZi5xdWV1ZWRVc2VyT3B0aW9ucy5pbmRleE9mKGNoYXJ0T3B0aW9ucy51c2VyT3B0aW9ucykgKyAxO1xuICAgICAgICBjaGFydFJlZi5xdWV1ZWRVc2VyT3B0aW9ucy5zcGxpY2UoMCwgcXVldWVJZHgpO1xuICAgICAgICBjaGFydFJlZi5xdWV1ZWRDaGFydE9wdGlvbnMuc3BsaWNlKDAsIHF1ZXVlSWR4KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm94eTtcbiAgfVxuICBzdGF0aWMgbWFya1JlbW92ZWRQcm9wZXJ0aWVzKG5vZGUsIF8sIG1vZGlmaWVkID0gZmFsc2UpIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gbW9kaWZpZWQ7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobm9kZSkpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihub2RlLCB7IFtrZXldOiBTeW1ib2woXCJVTlNFVFwiKSB9KTtcbiAgICAgICAgbW9kaWZpZWQgfHwgKG1vZGlmaWVkID0gdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb2RpZmllZDtcbiAgfVxuICBzdGF0aWMgdXBkYXRlVXNlckRlbHRhKHByb3h5LCBkZWx0YU9wdGlvbnMpIHtcbiAgICBkZWx0YU9wdGlvbnMgPSBkZWVwQ2xvbmUoZGVsdGFPcHRpb25zLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJkYXRhXCJdKSk7XG4gICAgY29uc3Qgc3RyaXBTeW1ib2xzID0ganNvbldhbGsoXG4gICAgICBkZWx0YU9wdGlvbnMsXG4gICAgICBfQWdDaGFydHNJbnRlcm5hbC5tYXJrUmVtb3ZlZFByb3BlcnRpZXMsXG4gICAgICAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJkYXRhXCJdKSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHZvaWQgMCxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICBkZWJ1ZzMoKCkgPT4gW1wiPj4+IEFnQ2hhcnRzLnVwZGF0ZVVzZXJEZWx0YSgpIHVzZXIgZGVsdGFcIiwgZGVlcENsb25lKGRlbHRhT3B0aW9ucyldKTtcbiAgICBfQWdDaGFydHNJbnRlcm5hbC5jcmVhdGVPclVwZGF0ZSh7XG4gICAgICBwcm94eSxcbiAgICAgIGRlbHRhT3B0aW9ucyxcbiAgICAgIHN0cmlwU3ltYm9sc1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVDaGFydEluc3RhbmNlKG9wdGlvbnMsIG9sZENoYXJ0KSB7XG4gICAgY29uc3QgdHJhbnNmZXJhYmxlUmVzb3VyY2UgPSBvbGRDaGFydD8uZGVzdHJveSh7IGtlZXBUcmFuc2ZlcmFibGVSZXNvdXJjZXM6IHRydWUgfSk7XG4gICAgY29uc3QgY2hhcnREZWYgPSBNb2R1bGVSZWdpc3RyeS5kZXRlY3RDaGFydERlZmluaXRpb24ob3B0aW9ucy5wcm9jZXNzZWRPcHRpb25zKTtcbiAgICByZXR1cm4gY2hhcnREZWYuY3JlYXRlKG9wdGlvbnMsIHRyYW5zZmVyYWJsZVJlc291cmNlKTtcbiAgfVxuICBzdGF0aWMgZ2V0UG9vbChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMub3B0aW9uTWV0YWRhdGEucG9vbCAhPT0gdHJ1ZSlcbiAgICAgIHJldHVybjtcbiAgICByZXR1cm4gUG9vbC5nZXRQb29sKFxuICAgICAgb3B0aW9ucy5vcHRpb25NZXRhZGF0YS5wcmVzZXRUeXBlID8/IFwiZGVmYXVsdFwiLFxuICAgICAgdGhpcy5jcmVhdGVDaGFydEluc3RhbmNlLFxuICAgICAgdGhpcy5kZXRhY2hBbmRDbGVhcixcbiAgICAgIHRoaXMuZGVzdHJveSxcbiAgICAgIEluZmluaXR5XG4gICAgICAvLyBBRy0xMzQ4MCAtIFByZXZlbnQgR3JpZCBleGhhdXN0aW5nIHBvb2wgZHVyaW5nIHNvcnRpbmcuXG4gICAgKTtcbiAgfVxufTtcbl9BZ0NoYXJ0c0ludGVybmFsLmNhcmV0YWtlciA9IG5ldyBNZW1lbnRvQ2FyZXRha2VyKFZFUlNJT04pO1xuX0FnQ2hhcnRzSW50ZXJuYWwuaW5pdGlhbGlzZWQgPSBmYWxzZTtcbl9BZ0NoYXJ0c0ludGVybmFsLmNhbGxiYWNrQXBpID0ge1xuICBjYXJldGFrZXI6IF9BZ0NoYXJ0c0ludGVybmFsLmNhcmV0YWtlcixcbiAgY3JlYXRlKHVzZXJPcHRpb25zLCBwcm9jZXNzZWRPdmVycmlkZXMsIHNwZWNpYWxPdmVycmlkZXMsIG9wdGlvbnNNZXRhZGF0YSkge1xuICAgIHJldHVybiBfQWdDaGFydHNJbnRlcm5hbC5jcmVhdGVPclVwZGF0ZSh7XG4gICAgICB1c2VyT3B0aW9ucyxcbiAgICAgIHByb2Nlc3NlZE92ZXJyaWRlcyxcbiAgICAgIHNwZWNpYWxPdmVycmlkZXMsXG4gICAgICBvcHRpb25zTWV0YWRhdGFcbiAgICB9KTtcbiAgfSxcbiAgdXBkYXRlKG9wdHMsIGNoYXJ0KSB7XG4gICAgcmV0dXJuIF9BZ0NoYXJ0c0ludGVybmFsLmNyZWF0ZU9yVXBkYXRlKHsgdXNlck9wdGlvbnM6IG9wdHMsIHByb3h5OiBjaGFydCB9KTtcbiAgfSxcbiAgdXBkYXRlVXNlckRlbHRhKGNoYXJ0LCBkZWx0YU9wdGlvbnMpIHtcbiAgICByZXR1cm4gX0FnQ2hhcnRzSW50ZXJuYWwudXBkYXRlVXNlckRlbHRhKGNoYXJ0LCBkZWx0YU9wdGlvbnMpO1xuICB9XG59O1xuX0FnQ2hhcnRzSW50ZXJuYWwuZGV0YWNoQW5kQ2xlYXIgPSAoY2hhcnQpID0+IGNoYXJ0LmRldGFjaEFuZENsZWFyKCk7XG5fQWdDaGFydHNJbnRlcm5hbC5kZXN0cm95ID0gKGNoYXJ0KSA9PiBjaGFydC5kZXN0cm95KCk7XG52YXIgQWdDaGFydHNJbnRlcm5hbCA9IF9BZ0NoYXJ0c0ludGVybmFsO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9pbnRlZ3JhdGVkLWNoYXJ0cy1zY2VuZS50c1xudmFyIGludGVncmF0ZWRfY2hhcnRzX3NjZW5lX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGludGVncmF0ZWRfY2hhcnRzX3NjZW5lX2V4cG9ydHMsIHtcbiAgQXJjOiAoKSA9PiBBcmMyLFxuICBCQm94OiAoKSA9PiBCQm94LFxuICBDYXB0aW9uOiAoKSA9PiBDYXB0aW9uLFxuICBDYXRlZ29yeVNjYWxlOiAoKSA9PiBDYXRlZ29yeVNjYWxlLFxuICBHcm91cDogKCkgPT4gR3JvdXAsXG4gIExpbmU6ICgpID0+IExpbmUsXG4gIExpbmVhclNjYWxlOiAoKSA9PiBMaW5lYXJTY2FsZSxcbiAgTWFya2VyOiAoKSA9PiBNYXJrZXIsXG4gIFBhdGg6ICgpID0+IFBhdGgsXG4gIFJhZGlhbENvbHVtblNoYXBlOiAoKSA9PiBSYWRpYWxDb2x1bW5TaGFwZSxcbiAgUmVjdDogKCkgPT4gUmVjdCxcbiAgU2NlbmU6ICgpID0+IFNjZW5lLFxuICBTZWN0b3I6ICgpID0+IFNlY3RvcixcbiAgU2hhcGU6ICgpID0+IFNoYXBlLFxuICBUcmFuc2xhdGFibGVHcm91cDogKCkgPT4gVHJhbnNsYXRhYmxlR3JvdXAsXG4gIGdldFJhZGlhbENvbHVtbldpZHRoOiAoKSA9PiBnZXRSYWRpYWxDb2x1bW5XaWR0aCxcbiAgdG9SYWRpYW5zOiAoKSA9PiB0b1JhZGlhbnNcbn0pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9hcmMudHNcbnZhciBBcmMyID0gY2xhc3MgZXh0ZW5kcyBQYXRoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNlbnRlclggPSAwO1xuICAgIHRoaXMuY2VudGVyWSA9IDA7XG4gICAgdGhpcy5yYWRpdXMgPSAxMDtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSAwO1xuICAgIHRoaXMuZW5kQW5nbGUgPSBNYXRoLlBJICogMjtcbiAgICB0aGlzLmNvdW50ZXJDbG9ja3dpc2UgPSBmYWxzZTtcbiAgICB0aGlzLnR5cGUgPSAwIC8qIE9wZW4gKi87XG4gICAgdGhpcy5yZXN0b3JlT3duU3R5bGVzKCk7XG4gIH1cbiAgZ2V0IGZ1bGxQaWUoKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyRXF1YWwobm9ybWFsaXplQW5nbGUzNjAodGhpcy5zdGFydEFuZ2xlKSwgbm9ybWFsaXplQW5nbGUzNjAodGhpcy5lbmRBbmdsZSkpO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMucGF0aDtcbiAgICBwYXRoLmNsZWFyKCk7XG4gICAgcGF0aC5hcmModGhpcy5jZW50ZXJYLCB0aGlzLmNlbnRlclksIHRoaXMucmFkaXVzLCB0aGlzLnN0YXJ0QW5nbGUsIHRoaXMuZW5kQW5nbGUsIHRoaXMuY291bnRlckNsb2Nrd2lzZSk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gMSAvKiBDaG9yZCAqLykge1xuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gMiAvKiBSb3VuZCAqLyAmJiAhdGhpcy5mdWxsUGllKSB7XG4gICAgICBwYXRoLmxpbmVUbyh0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSk7XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICByZXR1cm4gbmV3IEJCb3godGhpcy5jZW50ZXJYIC0gdGhpcy5yYWRpdXMsIHRoaXMuY2VudGVyWSAtIHRoaXMucmFkaXVzLCB0aGlzLnJhZGl1cyAqIDIsIHRoaXMucmFkaXVzICogMik7XG4gIH1cbiAgaXNQb2ludEluUGF0aCh4LCB5KSB7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgIHJldHVybiB0aGlzLnR5cGUgIT09IDAgLyogT3BlbiAqLyAmJiBiYm94LmNvbnRhaW5zUG9pbnQoeCwgeSkgJiYgdGhpcy5wYXRoLmlzUG9pbnRJblBhdGgoeCwgeSk7XG4gIH1cbn07XG5BcmMyLmNsYXNzTmFtZSA9IFwiQXJjXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgQXJjMi5wcm90b3R5cGUsIFwiY2VudGVyWFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBBcmMyLnByb3RvdHlwZSwgXCJjZW50ZXJZXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEFyYzIucHJvdG90eXBlLCBcInJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBBcmMyLnByb3RvdHlwZSwgXCJzdGFydEFuZ2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEFyYzIucHJvdG90eXBlLCBcImVuZEFuZ2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEFyYzIucHJvdG90eXBlLCBcImNvdW50ZXJDbG9ja3dpc2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgQXJjMi5wcm90b3R5cGUsIFwidHlwZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvcmFkaWFsQ29sdW1uU2hhcGUudHNcbmZ1bmN0aW9uIHJvdGF0ZVBvaW50KHgsIHksIHJvdGF0aW9uKSB7XG4gIGNvbnN0IHJhZGl1cyA9IE1hdGguc3FydCh4ICoqIDIgKyB5ICoqIDIpO1xuICBjb25zdCBhbmdsZTIgPSBNYXRoLmF0YW4yKHksIHgpO1xuICBjb25zdCByb3RhdGVkID0gYW5nbGUyICsgcm90YXRpb247XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5jb3Mocm90YXRlZCkgKiByYWRpdXMsXG4gICAgeTogTWF0aC5zaW4ocm90YXRlZCkgKiByYWRpdXNcbiAgfTtcbn1cbnZhciBSYWRpYWxDb2x1bW5TaGFwZSA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5pc0JldmVsZWQgPSB0cnVlO1xuICAgIHRoaXMuY29sdW1uV2lkdGggPSAwO1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IDA7XG4gICAgdGhpcy5lbmRBbmdsZSA9IDA7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IDA7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5heGlzSW5uZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuYXhpc091dGVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmlzUmFkaXVzQXhpc1JldmVyc2VkID0gZmFsc2U7XG4gIH1cbiAgc2V0IGNvcm5lclJhZGl1cyhfdmFsdWUpIHtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBjb25zdCB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgY29sdW1uV2lkdGggfSA9IHRoaXM7XG4gICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLmdldFJvdGF0aW9uKCk7XG4gICAgY29uc3QgbGVmdCA9IC1jb2x1bW5XaWR0aCAvIDI7XG4gICAgY29uc3QgcmlnaHQgPSBjb2x1bW5XaWR0aCAvIDI7XG4gICAgY29uc3QgdG9wID0gLW91dGVyUmFkaXVzO1xuICAgIGNvbnN0IGJvdHRvbSA9IC1pbm5lclJhZGl1cztcbiAgICBsZXQgeDAgPSBJbmZpbml0eTtcbiAgICBsZXQgeTAgPSBJbmZpbml0eTtcbiAgICBsZXQgeDEgPSAtSW5maW5pdHk7XG4gICAgbGV0IHkxID0gLUluZmluaXR5O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IHJvdGF0ZVBvaW50KGkgJSAyID09PSAwID8gbGVmdCA6IHJpZ2h0LCBpIDwgMiA/IHRvcCA6IGJvdHRvbSwgcm90YXRpb24pO1xuICAgICAgeDAgPSBNYXRoLm1pbih4LCB4MCk7XG4gICAgICB5MCA9IE1hdGgubWluKHksIHkwKTtcbiAgICAgIHgxID0gTWF0aC5tYXgoeCwgeDEpO1xuICAgICAgeTEgPSBNYXRoLm1heCh5LCB5MSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQkJveCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xuICB9XG4gIGdldFJvdGF0aW9uKCkge1xuICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgbWlkQW5nbGUgPSBhbmdsZUJldHdlZW4oc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xuICAgIHJldHVybiBub3JtYWxpemVBbmdsZTM2MChzdGFydEFuZ2xlICsgbWlkQW5nbGUgLyAyICsgTWF0aC5QSSAvIDIpO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyBpc0JldmVsZWQgfSA9IHRoaXM7XG4gICAgaWYgKGlzQmV2ZWxlZCkge1xuICAgICAgdGhpcy51cGRhdGVCZXZlbGVkUGF0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZVJlY3Rhbmd1bGFyUGF0aCgpO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrUGF0aERpcnR5KCk7XG4gIH1cbiAgdXBkYXRlUmVjdGFuZ3VsYXJQYXRoKCkge1xuICAgIGNvbnN0IHsgY29sdW1uV2lkdGgsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgcGF0aCB9ID0gdGhpcztcbiAgICBjb25zdCBsZWZ0ID0gLWNvbHVtbldpZHRoIC8gMjtcbiAgICBjb25zdCByaWdodCA9IGNvbHVtbldpZHRoIC8gMjtcbiAgICBjb25zdCB0b3AgPSAtb3V0ZXJSYWRpdXM7XG4gICAgY29uc3QgYm90dG9tID0gLWlubmVyUmFkaXVzO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuICAgIGNvbnN0IHBvaW50cyA9IFtcbiAgICAgIFtsZWZ0LCBib3R0b21dLFxuICAgICAgW2xlZnQsIHRvcF0sXG4gICAgICBbcmlnaHQsIHRvcF0sXG4gICAgICBbcmlnaHQsIGJvdHRvbV1cbiAgICBdLm1hcCgoW3gsIHldKSA9PiByb3RhdGVQb2ludCh4LCB5LCByb3RhdGlvbikpO1xuICAgIHBhdGguY2xlYXIodHJ1ZSk7XG4gICAgcGF0aC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcbiAgICBwYXRoLmxpbmVUbyhwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnkpO1xuICAgIHBhdGgubGluZVRvKHBvaW50c1syXS54LCBwb2ludHNbMl0ueSk7XG4gICAgcGF0aC5saW5lVG8ocG9pbnRzWzNdLngsIHBvaW50c1szXS55KTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG4gIHVwZGF0ZUJldmVsZWRQYXRoKCkge1xuICAgIGNvbnN0IHsgY29sdW1uV2lkdGgsIHBhdGgsIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1cywgYXhpc0lubmVyUmFkaXVzLCBheGlzT3V0ZXJSYWRpdXMsIGlzUmFkaXVzQXhpc1JldmVyc2VkIH0gPSB0aGlzO1xuICAgIGNvbnN0IGlzU3RhY2tCb3R0b20gPSBpc051bWJlckVxdWFsKGlubmVyUmFkaXVzLCBheGlzSW5uZXJSYWRpdXMpO1xuICAgIGNvbnN0IHNpZGVSb3RhdGlvbiA9IE1hdGguYXNpbihjb2x1bW5XaWR0aCAvIDIgLyBpbm5lclJhZGl1cyk7XG4gICAgY29uc3QgcG9pbnRSb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcbiAgICBjb25zdCByb3RhdGUyID0gKHgsIHkpID0+IHJvdGF0ZVBvaW50KHgsIHksIHBvaW50Um90YXRpb24pO1xuICAgIGNvbnN0IGdldFRyaWFuZ2xlSHlwb3RlbnVzZSA9IChsZWcsIG90aGVyTGVnKSA9PiBNYXRoLnNxcnQobGVnICoqIDIgKyBvdGhlckxlZyAqKiAyKTtcbiAgICBjb25zdCBnZXRUcmlhbmdsZUxlZyA9IChoeXBvdGVudXNlLCBvdGhlckxlZykgPT4ge1xuICAgICAgaWYgKG90aGVyTGVnID4gaHlwb3RlbnVzZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnNxcnQoaHlwb3RlbnVzZSAqKiAyIC0gb3RoZXJMZWcgKiogMik7XG4gICAgfTtcbiAgICBjb25zdCBjb21wYXJlID0gKHZhbHVlLCBvdGhlclZhbHVlLCBsZXNzVGhhbjIpID0+IGxlc3NUaGFuMiA/IHZhbHVlIDwgb3RoZXJWYWx1ZSA6IHZhbHVlID4gb3RoZXJWYWx1ZTtcbiAgICBjb25zdCBzaG91bGRDb25uZWN0Qm90dG9tQ2lyY2xlID0gaXNTdGFja0JvdHRvbSAmJiAhaXNOYU4oc2lkZVJvdGF0aW9uKSAmJiBzaWRlUm90YXRpb24gPCBNYXRoLlBJIC8gNjtcbiAgICBsZXQgbGVmdCA9IC1jb2x1bW5XaWR0aCAvIDI7XG4gICAgbGV0IHJpZ2h0ID0gY29sdW1uV2lkdGggLyAyO1xuICAgIGNvbnN0IHRvcCA9IC1vdXRlclJhZGl1cztcbiAgICBjb25zdCBib3R0b20gPSAtaW5uZXJSYWRpdXMgKiAoc2hvdWxkQ29ubmVjdEJvdHRvbUNpcmNsZSA/IE1hdGguY29zKHNpZGVSb3RhdGlvbikgOiAxKTtcbiAgICBjb25zdCBoYXNCb3R0b21JbnRlcnNlY3Rpb24gPSBjb21wYXJlKFxuICAgICAgYXhpc091dGVyUmFkaXVzLFxuICAgICAgZ2V0VHJpYW5nbGVIeXBvdGVudXNlKGlubmVyUmFkaXVzLCBjb2x1bW5XaWR0aCAvIDIpLFxuICAgICAgIWlzUmFkaXVzQXhpc1JldmVyc2VkXG4gICAgKTtcbiAgICBpZiAoaGFzQm90dG9tSW50ZXJzZWN0aW9uKSB7XG4gICAgICBjb25zdCBib3R0b21JbnRlcnNlY3Rpb25YID0gZ2V0VHJpYW5nbGVMZWcoYXhpc091dGVyUmFkaXVzLCBpbm5lclJhZGl1cyk7XG4gICAgICBsZWZ0ID0gLWJvdHRvbUludGVyc2VjdGlvblg7XG4gICAgICByaWdodCA9IGJvdHRvbUludGVyc2VjdGlvblg7XG4gICAgfVxuICAgIHBhdGguY2xlYXIodHJ1ZSk7XG4gICAgY29uc3QgYm90dG9tTGVmdFB0ID0gcm90YXRlMihsZWZ0LCBib3R0b20pO1xuICAgIHBhdGgubW92ZVRvKGJvdHRvbUxlZnRQdC54LCBib3R0b21MZWZ0UHQueSk7XG4gICAgY29uc3QgaXNFbXB0eTIgPSBpc051bWJlckVxdWFsKGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyk7XG4gICAgY29uc3QgaGFzU2lkZUludGVyc2VjdGlvbiA9IGNvbXBhcmUoXG4gICAgICBheGlzT3V0ZXJSYWRpdXMsXG4gICAgICBnZXRUcmlhbmdsZUh5cG90ZW51c2Uob3V0ZXJSYWRpdXMsIGNvbHVtbldpZHRoIC8gMiksXG4gICAgICAhaXNSYWRpdXNBeGlzUmV2ZXJzZWRcbiAgICApO1xuICAgIGlmIChpc0VtcHR5MiAmJiBzaG91bGRDb25uZWN0Qm90dG9tQ2lyY2xlKSB7XG4gICAgICBwYXRoLmFyYyhcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgaW5uZXJSYWRpdXMsXG4gICAgICAgIG5vcm1hbGl6ZUFuZ2xlMzYwKC1zaWRlUm90YXRpb24gLSBNYXRoLlBJIC8gMikgKyBwb2ludFJvdGF0aW9uLFxuICAgICAgICBub3JtYWxpemVBbmdsZTM2MChzaWRlUm90YXRpb24gLSBNYXRoLlBJIC8gMikgKyBwb2ludFJvdGF0aW9uLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGhhc1NpZGVJbnRlcnNlY3Rpb24pIHtcbiAgICAgIGNvbnN0IHNpZGVJbnRlcnNlY3Rpb25ZID0gLWdldFRyaWFuZ2xlTGVnKGF4aXNPdXRlclJhZGl1cywgY29sdW1uV2lkdGggLyAyKTtcbiAgICAgIGNvbnN0IHRvcEludGVyc2VjdGlvblggPSBnZXRUcmlhbmdsZUxlZyhheGlzT3V0ZXJSYWRpdXMsIG91dGVyUmFkaXVzKTtcbiAgICAgIGlmICghaGFzQm90dG9tSW50ZXJzZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHRvcExlZnRQdCA9IHJvdGF0ZTIobGVmdCwgc2lkZUludGVyc2VjdGlvblkpO1xuICAgICAgICBwYXRoLmxpbmVUbyh0b3BMZWZ0UHQueCwgdG9wTGVmdFB0LnkpO1xuICAgICAgfVxuICAgICAgcGF0aC5hcmMoXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGF4aXNPdXRlclJhZGl1cyxcbiAgICAgICAgTWF0aC5hdGFuMihzaWRlSW50ZXJzZWN0aW9uWSwgbGVmdCkgKyBwb2ludFJvdGF0aW9uLFxuICAgICAgICBNYXRoLmF0YW4yKHRvcCwgLXRvcEludGVyc2VjdGlvblgpICsgcG9pbnRSb3RhdGlvbixcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgICBpZiAoIWlzTnVtYmVyRXF1YWwodG9wSW50ZXJzZWN0aW9uWCwgMCkpIHtcbiAgICAgICAgY29uc3QgdG9wUmlnaHRCZXZlbFB0ID0gcm90YXRlMih0b3BJbnRlcnNlY3Rpb25YLCB0b3ApO1xuICAgICAgICBwYXRoLmxpbmVUbyh0b3BSaWdodEJldmVsUHQueCwgdG9wUmlnaHRCZXZlbFB0LnkpO1xuICAgICAgfVxuICAgICAgcGF0aC5hcmMoXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGF4aXNPdXRlclJhZGl1cyxcbiAgICAgICAgTWF0aC5hdGFuMih0b3AsIHRvcEludGVyc2VjdGlvblgpICsgcG9pbnRSb3RhdGlvbixcbiAgICAgICAgTWF0aC5hdGFuMihzaWRlSW50ZXJzZWN0aW9uWSwgcmlnaHQpICsgcG9pbnRSb3RhdGlvbixcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRvcExlZnRQdCA9IHJvdGF0ZTIobGVmdCwgdG9wKTtcbiAgICAgIGNvbnN0IHRvcFJpZ2h0UHQgPSByb3RhdGUyKHJpZ2h0LCB0b3ApO1xuICAgICAgcGF0aC5saW5lVG8odG9wTGVmdFB0LngsIHRvcExlZnRQdC55KTtcbiAgICAgIHBhdGgubGluZVRvKHRvcFJpZ2h0UHQueCwgdG9wUmlnaHRQdC55KTtcbiAgICB9XG4gICAgY29uc3QgYm90dG9tUmlnaHRQdCA9IHJvdGF0ZTIocmlnaHQsIGJvdHRvbSk7XG4gICAgcGF0aC5saW5lVG8oYm90dG9tUmlnaHRQdC54LCBib3R0b21SaWdodFB0LnkpO1xuICAgIGlmIChzaG91bGRDb25uZWN0Qm90dG9tQ2lyY2xlKSB7XG4gICAgICBwYXRoLmFyYyhcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgaW5uZXJSYWRpdXMsXG4gICAgICAgIG5vcm1hbGl6ZUFuZ2xlMzYwKHNpZGVSb3RhdGlvbiAtIE1hdGguUEkgLyAyKSArIHBvaW50Um90YXRpb24sXG4gICAgICAgIG5vcm1hbGl6ZUFuZ2xlMzYwKC1zaWRlUm90YXRpb24gLSBNYXRoLlBJIC8gMikgKyBwb2ludFJvdGF0aW9uLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByb3RhdGVkQm90dG9tTGVmdFB0ID0gcm90YXRlMihsZWZ0LCBib3R0b20pO1xuICAgICAgcGF0aC5saW5lVG8ocm90YXRlZEJvdHRvbUxlZnRQdC54LCByb3RhdGVkQm90dG9tTGVmdFB0LnkpO1xuICAgIH1cbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59O1xuUmFkaWFsQ29sdW1uU2hhcGUuY2xhc3NOYW1lID0gXCJSYWRpYWxDb2x1bW5TaGFwZVwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJpc0JldmVsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcImNvbHVtbldpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJzdGFydEFuZ2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJlbmRBbmdsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwib3V0ZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcImlubmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJheGlzSW5uZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcImF4aXNPdXRlclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwiaXNSYWRpdXNBeGlzUmV2ZXJzZWRcIiwgMik7XG5mdW5jdGlvbiBnZXRSYWRpYWxDb2x1bW5XaWR0aChzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYXhpc091dGVyUmFkaXVzLCBjb2x1bW5XaWR0aFJhdGlvLCBtYXhDb2x1bW5XaWR0aFJhdGlvKSB7XG4gIGNvbnN0IHJvdGF0aW9uID0gYW5nbGVCZXR3ZWVuKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgY29uc3QgcGFkMiA9IHJvdGF0aW9uICogKDEgLSBjb2x1bW5XaWR0aFJhdGlvKSAvIDI7XG4gIHN0YXJ0QW5nbGUgKz0gcGFkMjtcbiAgZW5kQW5nbGUgLT0gcGFkMjtcbiAgaWYgKHJvdGF0aW9uIDwgMWUtMykge1xuICAgIHJldHVybiAyICogYXhpc091dGVyUmFkaXVzICogbWF4Q29sdW1uV2lkdGhSYXRpbztcbiAgfVxuICBpZiAocm90YXRpb24gPj0gMiAqIE1hdGguUEkpIHtcbiAgICBjb25zdCBtaWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyByb3RhdGlvbiAvIDI7XG4gICAgc3RhcnRBbmdsZSA9IG1pZEFuZ2xlIC0gTWF0aC5QSTtcbiAgICBlbmRBbmdsZSA9IG1pZEFuZ2xlICsgTWF0aC5QSTtcbiAgfVxuICBjb25zdCBzdGFydFggPSBheGlzT3V0ZXJSYWRpdXMgKiBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgY29uc3Qgc3RhcnRZID0gYXhpc091dGVyUmFkaXVzICogTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gIGNvbnN0IGVuZFggPSBheGlzT3V0ZXJSYWRpdXMgKiBNYXRoLmNvcyhlbmRBbmdsZSk7XG4gIGNvbnN0IGVuZFkgPSBheGlzT3V0ZXJSYWRpdXMgKiBNYXRoLnNpbihlbmRBbmdsZSk7XG4gIGNvbnN0IGNvbFdpZHRoID0gTWF0aC5mbG9vcihNYXRoLnNxcnQoKHN0YXJ0WCAtIGVuZFgpICoqIDIgKyAoc3RhcnRZIC0gZW5kWSkgKiogMikpO1xuICBjb25zdCBtYXhXaWR0aCA9IDIgKiBheGlzT3V0ZXJSYWRpdXMgKiBtYXhDb2x1bW5XaWR0aFJhdGlvO1xuICByZXR1cm4gTWF0aC5tYXgoMSwgTWF0aC5taW4obWF4V2lkdGgsIGNvbFdpZHRoKSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2ludGVncmF0ZWQtY2hhcnRzLXRoZW1lLnRzXG52YXIgaW50ZWdyYXRlZF9jaGFydHNfdGhlbWVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW50ZWdyYXRlZF9jaGFydHNfdGhlbWVfZXhwb3J0cywge1xuICBDaGFydFRoZW1lOiAoKSA9PiBDaGFydFRoZW1lLFxuICBERUZBVUxUX0FOTk9UQVRJT05fSEFORExFX0ZJTEw6ICgpID0+IERFRkFVTFRfQU5OT1RBVElPTl9IQU5ETEVfRklMTCxcbiAgREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfQ09MT1I6ICgpID0+IERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0NPTE9SLFxuICBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19ESVZJREVSX1NUUk9LRTogKCkgPT4gREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRElWSURFUl9TVFJPS0UsXG4gIERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0RPV05fRklMTDogKCkgPT4gREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRE9XTl9GSUxMLFxuICBERUZBVUxUX0FOTk9UQVRJT05fU1RBVElTVElDU19ET1dOX1NUUk9LRTogKCkgPT4gREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfRE9XTl9TVFJPS0UsXG4gIERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0ZJTEw6ICgpID0+IERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX0ZJTEwsXG4gIERFRkFVTFRfQU5OT1RBVElPTl9TVEFUSVNUSUNTX1NUUk9LRTogKCkgPT4gREVGQVVMVF9BTk5PVEFUSU9OX1NUQVRJU1RJQ1NfU1RST0tFLFxuICBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1VSOiAoKSA9PiBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1VSLFxuICBERUZBVUxUX0NBUFRJT05fQUxJR05NRU5UOiAoKSA9PiBERUZBVUxUX0NBUFRJT05fQUxJR05NRU5ULFxuICBERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFOiAoKSA9PiBERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFLFxuICBERUZBVUxUX0NPTE9SX1JBTkdFOiAoKSA9PiBERUZBVUxUX0NPTE9SX1JBTkdFLFxuICBERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1JfUkFOR0U6ICgpID0+IERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPUl9SQU5HRSxcbiAgREVGQVVMVF9GSUJPTkFDQ0lfU1RST0tFUzogKCkgPT4gREVGQVVMVF9GSUJPTkFDQ0lfU1RST0tFUyxcbiAgREVGQVVMVF9GSU5BTkNJQUxfQ0hBUlRTX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMOiAoKSA9PiBERUZBVUxUX0ZJTkFOQ0lBTF9DSEFSVFNfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsXG4gIERFRkFVTFRfRklOQU5DSUFMX0NIQVJUU19BTk5PVEFUSU9OX0NPTE9SOiAoKSA9PiBERUZBVUxUX0ZJTkFOQ0lBTF9DSEFSVFNfQU5OT1RBVElPTl9DT0xPUixcbiAgREVGQVVMVF9GVU5ORUxfU0VSSUVTX0NPTE9SX1JBTkdFOiAoKSA9PiBERUZBVUxUX0ZVTk5FTF9TRVJJRVNfQ09MT1JfUkFOR0UsXG4gIERFRkFVTFRfR0FVR0VfU0VSSUVTX0NPTE9SX1JBTkdFOiAoKSA9PiBERUZBVUxUX0dBVUdFX1NFUklFU19DT0xPUl9SQU5HRSxcbiAgREVGQVVMVF9HUklETElORV9FTkFCTEVEOiAoKSA9PiBERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQsXG4gIERFRkFVTFRfSElFUkFSQ0hZX0ZJTExTOiAoKSA9PiBERUZBVUxUX0hJRVJBUkNIWV9GSUxMUyxcbiAgREVGQVVMVF9ISUVSQVJDSFlfU1RST0tFUzogKCkgPT4gREVGQVVMVF9ISUVSQVJDSFlfU1RST0tFUyxcbiAgREVGQVVMVF9QT0xBUl9TRVJJRVNfU1RST0tFOiAoKSA9PiBERUZBVUxUX1BPTEFSX1NFUklFU19TVFJPS0UsXG4gIERFRkFVTFRfU0VQQVJBVElPTl9MSU5FU19DT0xPVVI6ICgpID0+IERFRkFVTFRfU0VQQVJBVElPTl9MSU5FU19DT0xPVVIsXG4gIERFRkFVTFRfU0hBRE9XX0NPTE9VUjogKCkgPT4gREVGQVVMVF9TSEFET1dfQ09MT1VSLFxuICBERUZBVUxUX1NQQVJLTElORV9DUk9TU0hBSVJfU1RST0tFOiAoKSA9PiBERUZBVUxUX1NQQVJLTElORV9DUk9TU0hBSVJfU1RST0tFLFxuICBERUZBVUxUX1RFWFRCT1hfQ09MT1I6ICgpID0+IERFRkFVTFRfVEVYVEJPWF9DT0xPUixcbiAgREVGQVVMVF9URVhUQk9YX0ZJTEw6ICgpID0+IERFRkFVTFRfVEVYVEJPWF9GSUxMLFxuICBERUZBVUxUX1RFWFRCT1hfU1RST0tFOiAoKSA9PiBERUZBVUxUX1RFWFRCT1hfU1RST0tFLFxuICBERUZBVUxUX1RFWFRfQU5OT1RBVElPTl9DT0xPUjogKCkgPT4gREVGQVVMVF9URVhUX0FOTk9UQVRJT05fQ09MT1IsXG4gIERFRkFVTFRfVE9PTEJBUl9QT1NJVElPTjogKCkgPT4gREVGQVVMVF9UT09MQkFSX1BPU0lUSU9OLFxuICBJU19DT01NVU5JVFk6ICgpID0+IElTX0NPTU1VTklUWSxcbiAgSVNfREFSS19USEVNRTogKCkgPT4gSVNfREFSS19USEVNRSxcbiAgSVNfRU5URVJQUklTRTogKCkgPT4gSVNfRU5URVJQUklTRSxcbiAgUEFMRVRURV9BTFRfRE9XTl9GSUxMOiAoKSA9PiBQQUxFVFRFX0FMVF9ET1dOX0ZJTEwsXG4gIFBBTEVUVEVfQUxUX0RPV05fU1RST0tFOiAoKSA9PiBQQUxFVFRFX0FMVF9ET1dOX1NUUk9LRSxcbiAgUEFMRVRURV9BTFRfTkVVVFJBTF9GSUxMOiAoKSA9PiBQQUxFVFRFX0FMVF9ORVVUUkFMX0ZJTEwsXG4gIFBBTEVUVEVfQUxUX05FVVRSQUxfU1RST0tFOiAoKSA9PiBQQUxFVFRFX0FMVF9ORVVUUkFMX1NUUk9LRSxcbiAgUEFMRVRURV9BTFRfVVBfRklMTDogKCkgPT4gUEFMRVRURV9BTFRfVVBfRklMTCxcbiAgUEFMRVRURV9BTFRfVVBfU1RST0tFOiAoKSA9PiBQQUxFVFRFX0FMVF9VUF9TVFJPS0UsXG4gIFBBTEVUVEVfRE9XTl9GSUxMOiAoKSA9PiBQQUxFVFRFX0RPV05fRklMTCxcbiAgUEFMRVRURV9ET1dOX1NUUk9LRTogKCkgPT4gUEFMRVRURV9ET1dOX1NUUk9LRSxcbiAgUEFMRVRURV9ORVVUUkFMX0ZJTEw6ICgpID0+IFBBTEVUVEVfTkVVVFJBTF9GSUxMLFxuICBQQUxFVFRFX05FVVRSQUxfU1RST0tFOiAoKSA9PiBQQUxFVFRFX05FVVRSQUxfU1RST0tFLFxuICBQQUxFVFRFX1VQX0ZJTEw6ICgpID0+IFBBTEVUVEVfVVBfRklMTCxcbiAgUEFMRVRURV9VUF9TVFJPS0U6ICgpID0+IFBBTEVUVEVfVVBfU1RST0tFLFxuICBnZXRDaGFydFRoZW1lOiAoKSA9PiBnZXRDaGFydFRoZW1lLFxuICB0aGVtZU5hbWVzOiAoKSA9PiB0aGVtZU5hbWVzLFxuICB0aGVtZVN5bWJvbHM6ICgpID0+IHN5bWJvbHNfZXhwb3J0cyxcbiAgdGhlbWVzOiAoKSA9PiB0aGVtZXNcbn0pO1xudmFyIHRoZW1lTmFtZXMgPSBPYmplY3Qua2V5cyh0aGVtZXMpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9pbnRlZ3JhdGVkLWNoYXJ0cy11dGlsLnRzXG52YXIgaW50ZWdyYXRlZF9jaGFydHNfdXRpbF9leHBvcnRzID0ge307XG5fX2V4cG9ydChpbnRlZ3JhdGVkX2NoYXJ0c191dGlsX2V4cG9ydHMsIHtcbiAgQ29sb3I6ICgpID0+IENvbG9yLFxuICBpbnRlcnBvbGF0ZUNvbG9yOiAoKSA9PiBpbnRlcnBvbGF0ZUNvbG9yXG59KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW9kdWxlLXN1cHBvcnQudHNcbnZhciBtb2R1bGVfc3VwcG9ydF9leHBvcnRzID0ge307XG5fX2V4cG9ydChtb2R1bGVfc3VwcG9ydF9leHBvcnRzLCB7XG4gIEFORDogKCkgPT4gQU5ELFxuICBBUlJBWTogKCkgPT4gQVJSQVksXG4gIEFSUkFZX09GOiAoKSA9PiBBUlJBWV9PRixcbiAgQWJzdHJhY3RCYXJTZXJpZXM6ICgpID0+IEFic3RyYWN0QmFyU2VyaWVzLFxuICBBYnN0cmFjdEJhclNlcmllc1Byb3BlcnRpZXM6ICgpID0+IEFic3RyYWN0QmFyU2VyaWVzUHJvcGVydGllcyxcbiAgQWN0aW9uT25TZXQ6ICgpID0+IEFjdGlvbk9uU2V0LFxuICBBbmNob3JlZFBvcG92ZXI6ICgpID0+IEFuY2hvcmVkUG9wb3ZlcixcbiAgQW5pbWF0aW9uOiAoKSA9PiBBbmltYXRpb24sXG4gIEFuaW1hdGlvbk1hbmFnZXI6ICgpID0+IEFuaW1hdGlvbk1hbmFnZXIsXG4gIEFyYzogKCkgPT4gQXJjMixcbiAgQXhpczogKCkgPT4gQXhpcyxcbiAgQXhpc0dyb3VwWkluZGV4TWFwOiAoKSA9PiBBeGlzR3JvdXBaSW5kZXhNYXAsXG4gIEF4aXNJbnRlcnZhbDogKCkgPT4gQXhpc0ludGVydmFsLFxuICBBeGlzTGFiZWw6ICgpID0+IEF4aXNMYWJlbCxcbiAgQXhpc1RpY2s6ICgpID0+IEF4aXNUaWNrLFxuICBBeGlzVGlja0dlbmVyYXRvcjogKCkgPT4gQXhpc1RpY2tHZW5lcmF0b3IsXG4gIEF4aXNUaWNrczogKCkgPT4gQXhpc1RpY2tzLFxuICBCQm94OiAoKSA9PiBCQm94LFxuICBCQm94VmFsdWVzOiAoKSA9PiBCQm94VmFsdWVzLFxuICBCT09MRUFOOiAoKSA9PiBCT09MRUFOLFxuICBCT09MRUFOX0FSUkFZOiAoKSA9PiBCT09MRUFOX0FSUkFZLFxuICBCYWNrZ3JvdW5kOiAoKSA9PiBCYWNrZ3JvdW5kLFxuICBCYWNrZ3JvdW5kTW9kdWxlOiAoKSA9PiBCYWNrZ3JvdW5kTW9kdWxlLFxuICBCYW5kU2NhbGU6ICgpID0+IEJhbmRTY2FsZSxcbiAgQmFyU2VyaWVzOiAoKSA9PiBCYXJTZXJpZXMsXG4gIEJhclNlcmllc01vZHVsZTogKCkgPT4gQmFyU2VyaWVzTW9kdWxlLFxuICBCYXNlTW9kdWxlSW5zdGFuY2U6ICgpID0+IEJhc2VNb2R1bGVJbnN0YW5jZSxcbiAgQmFzZVByb3BlcnRpZXM6ICgpID0+IEJhc2VQcm9wZXJ0aWVzLFxuICBCYXNlVG9vbGJhcjogKCkgPT4gQmFzZVRvb2xiYXIsXG4gIEJ1dHRvbldpZGdldDogKCkgPT4gQnV0dG9uV2lkZ2V0LFxuICBDT0xPUl9HUkFESUVOVDogKCkgPT4gQ09MT1JfR1JBRElFTlQsXG4gIENPTE9SX1NUUklORzogKCkgPT4gQ09MT1JfU1RSSU5HLFxuICBDT0xPUl9TVFJJTkdfQVJSQVk6ICgpID0+IENPTE9SX1NUUklOR19BUlJBWSxcbiAgQ2FjaGVkVGV4dE1lYXN1cmVyOiAoKSA9PiBDYWNoZWRUZXh0TWVhc3VyZXIsXG4gIENhY2hlZFRleHRNZWFzdXJlclBvb2w6ICgpID0+IENhY2hlZFRleHRNZWFzdXJlclBvb2wsXG4gIENhcHRpb246ICgpID0+IENhcHRpb24sXG4gIENhcnRlc2lhbkF4aXM6ICgpID0+IENhcnRlc2lhbkF4aXMsXG4gIENhcnRlc2lhblNlcmllczogKCkgPT4gQ2FydGVzaWFuU2VyaWVzLFxuICBDYXJ0ZXNpYW5TZXJpZXNOb2RlRXZlbnQ6ICgpID0+IENhcnRlc2lhblNlcmllc05vZGVFdmVudCxcbiAgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllczogKCkgPT4gQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcyxcbiAgQ2F0ZWdvcnlBeGlzOiAoKSA9PiBDYXRlZ29yeUF4aXMsXG4gIENhdGVnb3J5U2NhbGU6ICgpID0+IENhdGVnb3J5U2NhbGUsXG4gIENoYW5nZURldGVjdGFibGVQcm9wZXJ0aWVzOiAoKSA9PiBDaGFuZ2VEZXRlY3RhYmxlUHJvcGVydGllcyxcbiAgQ2hhcnQ6ICgpID0+IENoYXJ0LFxuICBDaGFydEF4aXNEaXJlY3Rpb246ICgpID0+IENoYXJ0QXhpc0RpcmVjdGlvbixcbiAgQ2hhcnRFdmVudE1hbmFnZXI6ICgpID0+IENoYXJ0RXZlbnRNYW5hZ2VyLFxuICBDaGFydE9wdGlvbnM6ICgpID0+IENoYXJ0T3B0aW9ucyxcbiAgQ2hhcnRVcGRhdGVUeXBlOiAoKSA9PiBDaGFydFVwZGF0ZVR5cGUsXG4gIENvbGxhcHNlTW9kZTogKCkgPT4gQ29sbGFwc2VNb2RlLFxuICBDb2xvcjogKCkgPT4gQ29sb3IsXG4gIENvbG9yU2NhbGU6ICgpID0+IENvbG9yU2NhbGUsXG4gIENvbmljR3JhZGllbnQ6ICgpID0+IENvbmljR3JhZGllbnQsXG4gIENvbnRleHRNZW51UmVnaXN0cnk6ICgpID0+IENvbnRleHRNZW51UmVnaXN0cnksXG4gIENvbnRpbnVvdXNTY2FsZTogKCkgPT4gQ29udGludW91c1NjYWxlLFxuICBEQVRFOiAoKSA9PiBEQVRFLFxuICBEQVRFX0FSUkFZOiAoKSA9PiBEQVRFX0FSUkFZLFxuICBEQVRFX09SX0RBVEVUSU1FX01TOiAoKSA9PiBEQVRFX09SX0RBVEVUSU1FX01TLFxuICBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUzogKCkgPT4gREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX0tFWVMsXG4gIERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUzogKCkgPT4gREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX05BTUVTLFxuICBERUZBVUxUX1RPT0xUSVBfQ0xBU1M6ICgpID0+IERFRkFVTFRfVE9PTFRJUF9DTEFTUyxcbiAgREVGQVVMVF9UT09MVElQX0RBUktfQ0xBU1M6ICgpID0+IERFRkFVTFRfVE9PTFRJUF9EQVJLX0NMQVNTLFxuICBESVJFQ1RJT046ICgpID0+IERJUkVDVElPTixcbiAgRE9NTWFuYWdlcjogKCkgPT4gRE9NTWFuYWdlcixcbiAgRGF0YUNvbnRyb2xsZXI6ICgpID0+IERhdGFDb250cm9sbGVyLFxuICBEYXRhTW9kZWw6ICgpID0+IERhdGFNb2RlbCxcbiAgRGF0YU1vZGVsU2VyaWVzOiAoKSA9PiBEYXRhTW9kZWxTZXJpZXMsXG4gIERhdGFTZXJ2aWNlOiAoKSA9PiBEYXRhU2VydmljZSxcbiAgRGVidWc6ICgpID0+IERlYnVnLFxuICBEZWZhdWx0OiAoKSA9PiBEZWZhdWx0LFxuICBEZXByZWNhdGVkOiAoKSA9PiBEZXByZWNhdGVkLFxuICBEZXByZWNhdGVkQW5kUmVuYW1lZFRvOiAoKSA9PiBEZXByZWNhdGVkQW5kUmVuYW1lZFRvLFxuICBEcmFnSW50ZXJwcmV0ZXI6ICgpID0+IERyYWdJbnRlcnByZXRlcixcbiAgRHJhZ2dhYmxlUG9wb3ZlcjogKCkgPT4gRHJhZ2dhYmxlUG9wb3ZlcixcbiAgRHJvcFNoYWRvdzogKCkgPT4gRHJvcFNoYWRvdyxcbiAgRXh0ZW5kZWRQYXRoMkQ6ICgpID0+IEV4dGVuZGVkUGF0aDJELFxuICBGT05UX1NJWkVfUkFUSU86ICgpID0+IEZPTlRfU0laRV9SQVRJTyxcbiAgRk9OVF9TVFlMRTogKCkgPT4gRk9OVF9TVFlMRSxcbiAgRk9OVF9XRUlHSFQ6ICgpID0+IEZPTlRfV0VJR0hULFxuICBGVU5DVElPTjogKCkgPT4gRlVOQ1RJT04sXG4gIEZsb2F0aW5nVG9vbGJhcjogKCkgPT4gRmxvYXRpbmdUb29sYmFyLFxuICBHUkVBVEVSX1RIQU46ICgpID0+IEdSRUFURVJfVEhBTixcbiAgR3JhZGllbnQ6ICgpID0+IEdyYWRpZW50LFxuICBHcm91cDogKCkgPT4gR3JvdXAsXG4gIEdyb3VwZWRDYXRlZ29yeUF4aXM6ICgpID0+IEdyb3VwZWRDYXRlZ29yeUF4aXMsXG4gIEhkcGlDYW52YXM6ICgpID0+IEhkcGlDYW52YXMsXG4gIEhpZXJhcmNoeU5vZGU6ICgpID0+IEhpZXJhcmNoeU5vZGUsXG4gIEhpZXJhcmNoeVNlcmllczogKCkgPT4gSGllcmFyY2h5U2VyaWVzLFxuICBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzOiAoKSA9PiBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLFxuICBIaWdobGlnaHRNYW5hZ2VyOiAoKSA9PiBIaWdobGlnaHRNYW5hZ2VyLFxuICBIaWdobGlnaHRQcm9wZXJ0aWVzOiAoKSA9PiBIaWdobGlnaHRQcm9wZXJ0aWVzLFxuICBIaWdobGlnaHRTdHlsZTogKCkgPT4gSGlnaGxpZ2h0U3R5bGUsXG4gIElOVEVSQUNUSU9OX1JBTkdFOiAoKSA9PiBJTlRFUkFDVElPTl9SQU5HRSxcbiAgSU5URVJQT0xBVElPTl9TVEVQX1BPU0lUSU9OOiAoKSA9PiBJTlRFUlBPTEFUSU9OX1NURVBfUE9TSVRJT04sXG4gIElOVEVSUE9MQVRJT05fVFlQRTogKCkgPT4gSU5URVJQT0xBVElPTl9UWVBFLFxuICBJbWFnZTogKCkgPT4gSW1hZ2UsXG4gIEludGVyYWN0aW9uTWFuYWdlcjogKCkgPT4gSW50ZXJhY3Rpb25NYW5hZ2VyLFxuICBJbnRlcmFjdGlvblN0YXRlOiAoKSA9PiBJbnRlcmFjdGlvblN0YXRlLFxuICBJbnRlcnBvbGF0aW9uUHJvcGVydGllczogKCkgPT4gSW50ZXJwb2xhdGlvblByb3BlcnRpZXMsXG4gIEludmFsaWRhdGluZzogKCkgPT4gSW52YWxpZGF0aW5nLFxuICBMQUJFTF9QTEFDRU1FTlQ6ICgpID0+IExBQkVMX1BMQUNFTUVOVCxcbiAgTEFSR0VTVF9LRVlfSU5URVJWQUw6ICgpID0+IExBUkdFU1RfS0VZX0lOVEVSVkFMLFxuICBMRVNTX1RIQU46ICgpID0+IExFU1NfVEhBTixcbiAgTElORV9DQVA6ICgpID0+IExJTkVfQ0FQLFxuICBMSU5FX0RBU0g6ICgpID0+IExJTkVfREFTSCxcbiAgTElORV9KT0lOOiAoKSA9PiBMSU5FX0pPSU4sXG4gIExJTkVfU1RZTEU6ICgpID0+IExJTkVfU1RZTEUsXG4gIExhYmVsOiAoKSA9PiBMYWJlbCxcbiAgTGF5b3V0RWxlbWVudDogKCkgPT4gTGF5b3V0RWxlbWVudCxcbiAgTGF5b3V0TWFuYWdlcjogKCkgPT4gTGF5b3V0TWFuYWdlcixcbiAgTGVnZW5kTWFya2VyTGFiZWw6ICgpID0+IExlZ2VuZE1hcmtlckxhYmVsLFxuICBMaW5lOiAoKSA9PiBMaW5lLFxuICBMaW5lU2VyaWVzOiAoKSA9PiBMaW5lU2VyaWVzLFxuICBMaW5lU2VyaWVzTW9kdWxlOiAoKSA9PiBMaW5lU2VyaWVzTW9kdWxlLFxuICBMaW5lYXJHcmFkaWVudDogKCkgPT4gTGluZWFyR3JhZGllbnQsXG4gIExpbmVhclNjYWxlOiAoKSA9PiBMaW5lYXJTY2FsZSxcbiAgTGlzdGVuZXJzOiAoKSA9PiBMaXN0ZW5lcnMsXG4gIExvZ1NjYWxlOiAoKSA9PiBMb2dTY2FsZSxcbiAgTG9uTGF0QkJveDogKCkgPT4gTG9uTGF0QkJveCxcbiAgTUFSS0VSX1NIQVBFOiAoKSA9PiBNQVJLRVJfU0hBUEUsXG4gIE1BVENISU5HX0NST1NTTElORV9UWVBFOiAoKSA9PiBNQVRDSElOR19DUk9TU0xJTkVfVFlQRSxcbiAgTUFYX1NQQUNJTkc6ICgpID0+IE1BWF9TUEFDSU5HLFxuICBNSU5fU1BBQ0lORzogKCkgPT4gTUlOX1NQQUNJTkcsXG4gIE1hcmtlcjogKCkgPT4gTWFya2VyLFxuICBNZW51OiAoKSA9PiBNZW51LFxuICBNZXJjYXRvclNjYWxlOiAoKSA9PiBNZXJjYXRvclNjYWxlLFxuICBNb2R1bGVSZWdpc3RyeTogKCkgPT4gTW9kdWxlUmVnaXN0cnksXG4gIE1vdGlvbjogKCkgPT4gZWFzaW5nX2V4cG9ydHMsXG4gIE5BTjogKCkgPT4gTkFOLFxuICBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HOiAoKSA9PiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HLFxuICBOVU1CRVI6ICgpID0+IE5VTUJFUixcbiAgTlVNQkVSX0FSUkFZOiAoKSA9PiBOVU1CRVJfQVJSQVksXG4gIE5VTUJFUl9PUl9OQU46ICgpID0+IE5VTUJFUl9PUl9OQU4sXG4gIE5hdGl2ZVdpZGdldDogKCkgPT4gTmF0aXZlV2lkZ2V0LFxuICBOaWNlTW9kZTogKCkgPT4gTmljZU1vZGUsXG4gIE5vZGU6ICgpID0+IE5vZGUsXG4gIE51bWJlckF4aXM6ICgpID0+IE51bWJlckF4aXMsXG4gIE9CSkVDVDogKCkgPT4gT0JKRUNULFxuICBPQkpFQ1RfQVJSQVk6ICgpID0+IE9CSkVDVF9BUlJBWSxcbiAgT1I6ICgpID0+IE9SLFxuICBPVkVSRkxPV19TVFJBVEVHWTogKCkgPT4gT1ZFUkZMT1dfU1RSQVRFR1ksXG4gIE9ic2VydmVDaGFuZ2VzOiAoKSA9PiBPYnNlcnZlQ2hhbmdlcyxcbiAgT3JkaW5hbFRpbWVTY2FsZTogKCkgPT4gT3JkaW5hbFRpbWVTY2FsZSxcbiAgUEhBU0VfTUVUQURBVEE6ICgpID0+IFBIQVNFX01FVEFEQVRBLFxuICBQSEFTRV9PUkRFUjogKCkgPT4gUEhBU0VfT1JERVIsXG4gIFBMQUNFTUVOVDogKCkgPT4gUExBQ0VNRU5ULFxuICBQTEFJTl9PQkpFQ1Q6ICgpID0+IFBMQUlOX09CSkVDVCxcbiAgUE9TSVRJT046ICgpID0+IFBPU0lUSU9OLFxuICBQT1NJVElPTl9UT1BfQ09PUkRJTkFURVM6ICgpID0+IFBPU0lUSU9OX1RPUF9DT09SRElOQVRFUyxcbiAgUE9TSVRJVkVfTlVNQkVSOiAoKSA9PiBQT1NJVElWRV9OVU1CRVIsXG4gIFBSRVZfTkVYVF9LRVlTOiAoKSA9PiBQUkVWX05FWFRfS0VZUyxcbiAgUGFkZGluZzogKCkgPT4gUGFkZGluZyxcbiAgUGFyYWxsZWxTdGF0ZU1hY2hpbmU6ICgpID0+IFBhcmFsbGVsU3RhdGVNYWNoaW5lLFxuICBQYXRoOiAoKSA9PiBQYXRoLFxuICBQb2ludGVyRXZlbnRzOiAoKSA9PiBQb2ludGVyRXZlbnRzLFxuICBQb2xhckF4aXM6ICgpID0+IFBvbGFyQXhpcyxcbiAgUG9sYXJTZXJpZXM6ICgpID0+IFBvbGFyU2VyaWVzLFxuICBQb2xhclpJbmRleE1hcDogKCkgPT4gUG9sYXJaSW5kZXhNYXAsXG4gIFBvcG92ZXI6ICgpID0+IFBvcG92ZXIsXG4gIFByb3BlcnRpZXNBcnJheTogKCkgPT4gUHJvcGVydGllc0FycmF5LFxuICBQcm94eUludGVyYWN0aW9uU2VydmljZTogKCkgPT4gUHJveHlJbnRlcmFjdGlvblNlcnZpY2UsXG4gIFByb3h5T25Xcml0ZTogKCkgPT4gUHJveHlPbldyaXRlLFxuICBQcm94eVByb3BlcnR5OiAoKSA9PiBQcm94eVByb3BlcnR5LFxuICBQcm94eVByb3BlcnR5T25Xcml0ZTogKCkgPT4gUHJveHlQcm9wZXJ0eU9uV3JpdGUsXG4gIFFVSUNLX1RSQU5TSVRJT046ICgpID0+IFFVSUNLX1RSQU5TSVRJT04sXG4gIFJBVElPOiAoKSA9PiBSQVRJTyxcbiAgUkVBTF9OVU1CRVI6ICgpID0+IFJFQUxfTlVNQkVSLFxuICBSRU5ERVJfVE9fT0ZGU0NSRUVOX0NBTlZBU19USFJFU0hPTEQ6ICgpID0+IFJFTkRFUl9UT19PRkZTQ1JFRU5fQ0FOVkFTX1RIUkVTSE9MRCxcbiAgUmFkaWFsQ29sdW1uU2hhcGU6ICgpID0+IFJhZGlhbENvbHVtblNoYXBlLFxuICBSYW5nZTogKCkgPT4gUmFuZ2UsXG4gIFJlY3Q6ICgpID0+IFJlY3QsXG4gIFJlcGVhdFR5cGU6ICgpID0+IFJlcGVhdFR5cGUsXG4gIFJvdGF0YWJsZTogKCkgPT4gUm90YXRhYmxlLFxuICBSb3RhdGFibGVHcm91cDogKCkgPT4gUm90YXRhYmxlR3JvdXAsXG4gIFJvdGF0YWJsZVRleHQ6ICgpID0+IFJvdGF0YWJsZVRleHQsXG4gIFNLSVBfSlNfQlVJTFRJTlM6ICgpID0+IFNLSVBfSlNfQlVJTFRJTlMsXG4gIFNNQUxMRVNUX0tFWV9JTlRFUlZBTDogKCkgPT4gU01BTExFU1RfS0VZX0lOVEVSVkFMLFxuICBTT1JUX0RPTUFJTl9HUk9VUFM6ICgpID0+IFNPUlRfRE9NQUlOX0dST1VQUyxcbiAgU1RSSU5HOiAoKSA9PiBTVFJJTkcsXG4gIFNUUklOR19BUlJBWTogKCkgPT4gU1RSSU5HX0FSUkFZLFxuICBTY2FsYWJsZTogKCkgPT4gU2NhbGFibGUsXG4gIFNjYWxhYmxlR3JvdXA6ICgpID0+IFNjYWxhYmxlR3JvdXAsXG4gIFNjZW5lOiAoKSA9PiBTY2VuZSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb246ICgpID0+IFNjZW5lQ2hhbmdlRGV0ZWN0aW9uLFxuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb246ICgpID0+IFNjZW5lUGF0aENoYW5nZURldGVjdGlvbixcbiAgU2VjdG9yOiAoKSA9PiBTZWN0b3IsXG4gIFNlY3RvckJveDogKCkgPT4gU2VjdG9yQm94LFxuICBTZWxlY3Rpb246ICgpID0+IFNlbGVjdGlvbixcbiAgU2VyaWVzOiAoKSA9PiBTZXJpZXMsXG4gIFNlcmllc0NvbnRlbnRaSW5kZXhNYXA6ICgpID0+IFNlcmllc0NvbnRlbnRaSW5kZXhNYXAsXG4gIFNlcmllc0dyb3VwaW5nQ2hhbmdlZEV2ZW50OiAoKSA9PiBTZXJpZXNHcm91cGluZ0NoYW5nZWRFdmVudCxcbiAgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlOiAoKSA9PiBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUsXG4gIFNlcmllc01hcmtlcjogKCkgPT4gU2VyaWVzTWFya2VyLFxuICBTZXJpZXNOb2RlRXZlbnQ6ICgpID0+IFNlcmllc05vZGVFdmVudCxcbiAgU2VyaWVzTm9kZVBpY2tNb2RlOiAoKSA9PiBTZXJpZXNOb2RlUGlja01vZGUsXG4gIFNlcmllc1Byb3BlcnRpZXM6ICgpID0+IFNlcmllc1Byb3BlcnRpZXMsXG4gIFNlcmllc1Rvb2x0aXA6ICgpID0+IFNlcmllc1Rvb2x0aXAsXG4gIFNlcmllc1pJbmRleE1hcDogKCkgPT4gU2VyaWVzWkluZGV4TWFwLFxuICBTaGFwZTogKCkgPT4gU2hhcGUsXG4gIFNpbXBsZVRleHRNZWFzdXJlcjogKCkgPT4gU2ltcGxlVGV4dE1lYXN1cmVyLFxuICBTbGlkZXJXaWRnZXQ6ICgpID0+IFNsaWRlcldpZGdldCxcbiAgU3RhdGVNYWNoaW5lOiAoKSA9PiBTdGF0ZU1hY2hpbmUsXG4gIFN0YXRlTWFjaGluZVByb3BlcnR5OiAoKSA9PiBTdGF0ZU1hY2hpbmVQcm9wZXJ0eSxcbiAgU3RvcFByb3BlcnRpZXM6ICgpID0+IFN0b3BQcm9wZXJ0aWVzLFxuICBTdmdQYXRoOiAoKSA9PiBTdmdQYXRoLFxuICBURVhUX0FMSUdOOiAoKSA9PiBURVhUX0FMSUdOLFxuICBURVhUX1dSQVA6ICgpID0+IFRFWFRfV1JBUCxcbiAgVElDS19JTlRFUlZBTDogKCkgPT4gVElDS19JTlRFUlZBTCxcbiAgVGV4dDogKCkgPT4gVGV4dCxcbiAgVGV4dFV0aWxzOiAoKSA9PiBUZXh0VXRpbHMsXG4gIFRleHRXcmFwcGVyOiAoKSA9PiBUZXh0V3JhcHBlcixcbiAgVGhlbWVDb25zdGFudHM6ICgpID0+IGNvbnN0YW50c19leHBvcnRzLFxuICBUaGVtZVN5bWJvbHM6ICgpID0+IHN5bWJvbHNfZXhwb3J0cyxcbiAgVGltZVNjYWxlOiAoKSA9PiBUaW1lU2NhbGUsXG4gIFRvb2xiYXI6ICgpID0+IFRvb2xiYXIsXG4gIFRvb2xiYXJCdXR0b25Qcm9wZXJ0aWVzOiAoKSA9PiBUb29sYmFyQnV0dG9uUHJvcGVydGllcyxcbiAgVG9vbGJhckJ1dHRvbldpZGdldDogKCkgPT4gVG9vbGJhckJ1dHRvbldpZGdldCxcbiAgVG9vbGJhcldpZGdldDogKCkgPT4gVG9vbGJhcldpZGdldCxcbiAgVG9vbHRpcDogKCkgPT4gVG9vbHRpcCxcbiAgVG9vbHRpcE1hbmFnZXI6ICgpID0+IFRvb2x0aXBNYW5hZ2VyLFxuICBUb29sdGlwUG9zaXRpb246ICgpID0+IFRvb2x0aXBQb3NpdGlvbixcbiAgVHJhbnNmb3JtYWJsZTogKCkgPT4gVHJhbnNmb3JtYWJsZSxcbiAgVHJhbnNmb3JtYWJsZVRleHQ6ICgpID0+IFRyYW5zZm9ybWFibGVUZXh0LFxuICBUcmFuc2xhdGFibGU6ICgpID0+IFRyYW5zbGF0YWJsZSxcbiAgVHJhbnNsYXRhYmxlR3JvdXA6ICgpID0+IFRyYW5zbGF0YWJsZUdyb3VwLFxuICBUcmFuc2xhdGFibGVMaW5lOiAoKSA9PiBUcmFuc2xhdGFibGVMaW5lLFxuICBVTklPTjogKCkgPT4gVU5JT04sXG4gIFVwZGF0ZVNlcnZpY2U6ICgpID0+IFVwZGF0ZVNlcnZpY2UsXG4gIFZFUlRJQ0FMX0FMSUdOOiAoKSA9PiBWRVJUSUNBTF9BTElHTixcbiAgVmFsaWRhdGU6ICgpID0+IFZhbGlkYXRlLFxuICBWZWMyOiAoKSA9PiBWZWMyLFxuICBWZWM0OiAoKSA9PiBWZWM0LFxuICBXSURHRVRfSFRNTF9FVkVOVFM6ICgpID0+IFdJREdFVF9IVE1MX0VWRU5UUyxcbiAgV2lkZ2V0OiAoKSA9PiBXaWRnZXQsXG4gIFdpZGdldEV2ZW50VXRpbDogKCkgPT4gV2lkZ2V0RXZlbnRVdGlsLFxuICBaSW5kZXhNYXA6ICgpID0+IFpJbmRleE1hcCxcbiAgWm9vbU1hbmFnZXI6ICgpID0+IFpvb21NYW5hZ2VyLFxuICBhY2N1bXVsYXRlR3JvdXA6ICgpID0+IGFjY3VtdWxhdGVHcm91cCxcbiAgYWNjdW11bGF0ZVN0YWNrOiAoKSA9PiBhY2N1bXVsYXRlU3RhY2ssXG4gIGFjY3VtdWxhdGVkVmFsdWU6ICgpID0+IGFjY3VtdWxhdGVkVmFsdWUsXG4gIGFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHk6ICgpID0+IGFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHksXG4gIGFkZEhpdFRlc3RlcnNUb1F1YWR0cmVlOiAoKSA9PiBhZGRIaXRUZXN0ZXJzVG9RdWFkdHJlZSxcbiAgYWRqdXN0TGFiZWxQbGFjZW1lbnQ6ICgpID0+IGFkanVzdExhYmVsUGxhY2VtZW50LFxuICBhbmdsZUJldHdlZW46ICgpID0+IGFuZ2xlQmV0d2VlbixcbiAgYW5pbWF0aW9uVmFsaWRhdGlvbjogKCkgPT4gYW5pbWF0aW9uVmFsaWRhdGlvbixcbiAgYXBwbHlTaGFwZVN0eWxlOiAoKSA9PiBhcHBseVNoYXBlU3R5bGUsXG4gIGFyZVNjYWxpbmdFcXVhbDogKCkgPT4gYXJlU2NhbGluZ0VxdWFsLFxuICBhcmVhOiAoKSA9PiBhcmVhLFxuICBidWlsZEZvcm1hdHRlcjogKCkgPT4gYnVpbGRGb3JtYXR0ZXIsXG4gIGJ1aWxkUmVzZXRQYXRoRm46ICgpID0+IGJ1aWxkUmVzZXRQYXRoRm4sXG4gIGNhbGN1bGF0ZURlZmF1bHRUaW1lVGlja0Zvcm1hdDogKCkgPT4gY2FsY3VsYXRlRGVmYXVsdFRpbWVUaWNrRm9ybWF0LFxuICBjYWxjdWxhdGVEZXJpdmF0aXZlRXh0cmVtYTogKCkgPT4gY2FsY3VsYXRlRGVyaXZhdGl2ZUV4dHJlbWEsXG4gIGNhbGN1bGF0ZURlcml2YXRpdmVFeHRyZW1hWFk6ICgpID0+IGNhbGN1bGF0ZURlcml2YXRpdmVFeHRyZW1hWFksXG4gIGNhbGN1bGF0ZUxhYmVsQ2hhcnRQYWRkaW5nOiAoKSA9PiBjYWxjdWxhdGVMYWJlbENoYXJ0UGFkZGluZyxcbiAgY2FsY3VsYXRlTGFiZWxUcmFuc2xhdGlvbjogKCkgPT4gY2FsY3VsYXRlTGFiZWxUcmFuc2xhdGlvbixcbiAgY2FsY3VsYXRlUGxhY2VtZW50OiAoKSA9PiBjYWxjdWxhdGVQbGFjZW1lbnQsXG4gIGNoZWNrQ3Jpc3A6ICgpID0+IGNoZWNrQ3Jpc3AsXG4gIGNsYW1wOiAoKSA9PiBjbGFtcCxcbiAgY2xhbXBBcnJheTogKCkgPT4gY2xhbXBBcnJheSxcbiAgY2xpcHBlZFJvdW5kUmVjdDogKCkgPT4gY2xpcHBlZFJvdW5kUmVjdCxcbiAgY29sbGFwc2VkU3RhcnRpbmdCYXJQb3NpdGlvbjogKCkgPT4gY29sbGFwc2VkU3RhcnRpbmdCYXJQb3NpdGlvbixcbiAgY29tcGFyZURhdGVzOiAoKSA9PiBjb21wYXJlRGF0ZXMsXG4gIGNvbXB1dGVCYXJGb2N1c0JvdW5kczogKCkgPT4gY29tcHV0ZUJhckZvY3VzQm91bmRzLFxuICBjb21wdXRlTWFya2VyRm9jdXNCb3VuZHM6ICgpID0+IGNvbXB1dGVNYXJrZXJGb2N1c0JvdW5kcyxcbiAgY291bnRFeHBhbmRpbmdTZWFyY2g6ICgpID0+IGNvdW50RXhwYW5kaW5nU2VhcmNoLFxuICBjb3VudEZyYWN0aW9uRGlnaXRzOiAoKSA9PiBjb3VudEZyYWN0aW9uRGlnaXRzLFxuICBjcmVhdGVCdXR0b246ICgpID0+IGNyZWF0ZUJ1dHRvbixcbiAgY3JlYXRlQ2hlY2tib3g6ICgpID0+IGNyZWF0ZUNoZWNrYm94LFxuICBjcmVhdGVEYXR1bUlkOiAoKSA9PiBjcmVhdGVEYXR1bUlkLFxuICBjcmVhdGVEZXByZWNhdGlvbldhcm5pbmc6ICgpID0+IGNyZWF0ZURlcHJlY2F0aW9uV2FybmluZyxcbiAgY3JlYXRlRWxlbWVudDogKCkgPT4gY3JlYXRlRWxlbWVudCxcbiAgY3JlYXRlRWxlbWVudElkOiAoKSA9PiBjcmVhdGVFbGVtZW50SWQsXG4gIGNyZWF0ZUljb246ICgpID0+IGNyZWF0ZUljb24sXG4gIGNyZWF0ZUlkOiAoKSA9PiBjcmVhdGVJZCxcbiAgY3JlYXRlU2VsZWN0OiAoKSA9PiBjcmVhdGVTZWxlY3QsXG4gIGNyZWF0ZVN2Z0VsZW1lbnQ6ICgpID0+IGNyZWF0ZVN2Z0VsZW1lbnQsXG4gIGNyZWF0ZVRleHRBcmVhOiAoKSA9PiBjcmVhdGVUZXh0QXJlYSxcbiAgZGF0ZVRvTnVtYmVyOiAoKSA9PiBkYXRlVG9OdW1iZXIsXG4gIGRhdGVzU29ydE9yZGVyOiAoKSA9PiBkYXRlc1NvcnRPcmRlcixcbiAgZGF0dW1LZXlzOiAoKSA9PiBkYXR1bUtleXMsXG4gIGRhdHVtU3R5bGVyUHJvcGVydGllczogKCkgPT4gZGF0dW1TdHlsZXJQcm9wZXJ0aWVzLFxuICBkZWNvbnN0cnVjdFNlbGVjdGlvbnNPck5vZGVzOiAoKSA9PiBkZWNvbnN0cnVjdFNlbGVjdGlvbnNPck5vZGVzLFxuICBkZWVwQ2xvbmU6ICgpID0+IGRlZXBDbG9uZSxcbiAgZGVlcEZyZWV6ZTogKCkgPT4gZGVlcEZyZWV6ZSxcbiAgZGVmYXVsdFRpbWVUaWNrRm9ybWF0OiAoKSA9PiBkZWZhdWx0VGltZVRpY2tGb3JtYXQsXG4gIGRpZmY6ICgpID0+IGRpZmYsXG4gIGRvd25sb2FkVXJsOiAoKSA9PiBkb3dubG9hZFVybCxcbiAgZHJhd0Nvcm5lcjogKCkgPT4gZHJhd0Nvcm5lcixcbiAgZHJhd01hcmtlclVuaXRQb2x5Z29uOiAoKSA9PiBkcmF3TWFya2VyVW5pdFBvbHlnb24sXG4gIGVhc2luZzogKCkgPT4gZWFzaW5nX2V4cG9ydHMsXG4gIGVudGVycHJpc2VNb2R1bGU6ICgpID0+IGVudGVycHJpc2VNb2R1bGUsXG4gIGV2YWx1YXRlQmV6aWVyOiAoKSA9PiBldmFsdWF0ZUJlemllcixcbiAgZXh0ZW50OiAoKSA9PiBleHRlbnQsXG4gIGV4dHJhY3REZWNvcmF0ZWRQcm9wZXJ0aWVzOiAoKSA9PiBleHRyYWN0RGVjb3JhdGVkUHJvcGVydGllcyxcbiAgZmluZE1pbk1heDogKCkgPT4gZmluZE1pbk1heCxcbiAgZmluZFF1YWR0cmVlTWF0Y2g6ICgpID0+IGZpbmRRdWFkdHJlZU1hdGNoLFxuICBmaW5kUmFuZ2VFeHRlbnQ6ICgpID0+IGZpbmRSYW5nZUV4dGVudCxcbiAgZml4TnVtZXJpY0V4dGVudDogKCkgPT4gZml4TnVtZXJpY0V4dGVudCxcbiAgZm9jdXNDdXJzb3JBdEVuZDogKCkgPT4gZm9jdXNDdXJzb3JBdEVuZCxcbiAgZm9ybWF0TnVtYmVyOiAoKSA9PiBmb3JtYXROdW1iZXIsXG4gIGZvcm1hdFBlcmNlbnQ6ICgpID0+IGZvcm1hdFBlcmNlbnQsXG4gIGZvcm1hdFZhbHVlOiAoKSA9PiBmb3JtYXRWYWx1ZSxcbiAgZnJvbVRvTW90aW9uOiAoKSA9PiBmcm9tVG9Nb3Rpb24sXG4gIGdlbmVyYXRlVVVJRDogKCkgPT4gZ2VuZXJhdGVVVUlELFxuICBnZXRBbmdsZVJhdGlvUmFkaWFuczogKCkgPT4gZ2V0QW5nbGVSYXRpb1JhZGlhbnMsXG4gIGdldENvbG9yU3RvcHM6ICgpID0+IGdldENvbG9yU3RvcHMsXG4gIGdldERhdGVUaWNrc0ZvckludGVydmFsOiAoKSA9PiBnZXREYXRlVGlja3NGb3JJbnRlcnZhbCxcbiAgZ2V0RGF0dW1SZWZQb2ludDogKCkgPT4gZ2V0RGF0dW1SZWZQb2ludCxcbiAgZ2V0RG9jdW1lbnQ6ICgpID0+IGdldERvY3VtZW50LFxuICBnZXRFbGVtZW50QkJveDogKCkgPT4gZ2V0RWxlbWVudEJCb3gsXG4gIGdldEljb25DbGFzc05hbWVzOiAoKSA9PiBnZXRJY29uQ2xhc3NOYW1lcyxcbiAgZ2V0TGFzdEZvY3VzOiAoKSA9PiBnZXRMYXN0Rm9jdXMsXG4gIGdldE1pc3NDb3VudDogKCkgPT4gZ2V0TWlzc0NvdW50LFxuICBnZXRQYXRoOiAoKSA9PiBnZXRQYXRoLFxuICBnZXRQYXRoQ29tcG9uZW50czogKCkgPT4gZ2V0UGF0aENvbXBvbmVudHMsXG4gIGdldFJhZGlhbENvbHVtbldpZHRoOiAoKSA9PiBnZXRSYWRpYWxDb2x1bW5XaWR0aCxcbiAgZ2V0V2luZG93OiAoKSA9PiBnZXRXaW5kb3csXG4gIGdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eTogKCkgPT4gZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5LFxuICBncm91cEF2ZXJhZ2U6ICgpID0+IGdyb3VwQXZlcmFnZSxcbiAgZ3JvdXBDb3VudDogKCkgPT4gZ3JvdXBDb3VudCxcbiAgZ3JvdXBTdGFja1ZhbHVlUHJvcGVydHk6ICgpID0+IGdyb3VwU3RhY2tWYWx1ZVByb3BlcnR5LFxuICBncm91cFN1bTogKCkgPT4gZ3JvdXBTdW0sXG4gIGhhc05vTW9kaWZpZXJzOiAoKSA9PiBoYXNOb01vZGlmaWVycyxcbiAgaW5SYW5nZTogKCkgPT4gaW5SYW5nZSxcbiAgaW5pdE1lbnVLZXlOYXY6ICgpID0+IGluaXRNZW51S2V5TmF2LFxuICBpbml0Um92aW5nVGFiSW5kZXg6ICgpID0+IGluaXRSb3ZpbmdUYWJJbmRleCxcbiAgaW50ZXJwb2xhdGVQb2ludHM6ICgpID0+IGludGVycG9sYXRlUG9pbnRzLFxuICBpc0FnRmxvd1Byb3BvcnRpb25DaGFydE9wdGlvbnM6ICgpID0+IGlzQWdGbG93UHJvcG9ydGlvbkNoYXJ0T3B0aW9ucyxcbiAgaXNBZ0dhdWdlQ2hhcnRPcHRpb25zOiAoKSA9PiBpc0FnR2F1Z2VDaGFydE9wdGlvbnMsXG4gIGlzQWdIaWVyYXJjaHlDaGFydE9wdGlvbnM6ICgpID0+IGlzQWdIaWVyYXJjaHlDaGFydE9wdGlvbnMsXG4gIGlzQWdTdGFuZGFsb25lQ2hhcnRPcHRpb25zOiAoKSA9PiBpc0FnU3RhbmRhbG9uZUNoYXJ0T3B0aW9ucyxcbiAgaXNBZ1RvcG9sb2d5Q2hhcnRPcHRpb25zOiAoKSA9PiBpc0FnVG9wb2xvZ3lDaGFydE9wdGlvbnMsXG4gIGlzQmV0d2VlbkFuZ2xlczogKCkgPT4gaXNCZXR3ZWVuQW5nbGVzLFxuICBpc0J1dHRvbkNsaWNrRXZlbnQ6ICgpID0+IGlzQnV0dG9uQ2xpY2tFdmVudCxcbiAgaXNDb250aW51b3VzOiAoKSA9PiBpc0NvbnRpbnVvdXMsXG4gIGlzRGVjb3JhdGVkT2JqZWN0OiAoKSA9PiBpc0RlY29yYXRlZE9iamVjdCxcbiAgaXNEZW5zZUludGVydmFsOiAoKSA9PiBpc0RlbnNlSW50ZXJ2YWwsXG4gIGlzSW5wdXRQZW5kaW5nOiAoKSA9PiBpc0lucHV0UGVuZGluZyxcbiAgaXNJbnRlZ2VyOiAoKSA9PiBpc0ludGVnZXIsXG4gIGlzTmVnYXRpdmU6ICgpID0+IGlzTmVnYXRpdmUsXG4gIGlzTnVtYmVyRXF1YWw6ICgpID0+IGlzTnVtYmVyRXF1YWwsXG4gIGlzUHJvcGVydGllczogKCkgPT4gaXNQcm9wZXJ0aWVzLFxuICBpc1NjYWxlVmFsaWQ6ICgpID0+IGlzU2NhbGVWYWxpZCxcbiAganNvbkFwcGx5OiAoKSA9PiBqc29uQXBwbHksXG4gIGpzb25EaWZmOiAoKSA9PiBqc29uRGlmZixcbiAganNvblByb3BlcnR5Q29tcGFyZTogKCkgPT4ganNvblByb3BlcnR5Q29tcGFyZSxcbiAganNvblJlc29sdmVPcGVyYXRpb25zOiAoKSA9PiBqc29uUmVzb2x2ZU9wZXJhdGlvbnMsXG4gIGpzb25XYWxrOiAoKSA9PiBqc29uV2FsayxcbiAga2V5UHJvcGVydHk6ICgpID0+IGtleVByb3BlcnR5LFxuICBsYWJlbERpcmVjdGlvbkhhbmRsaW5nOiAoKSA9PiBsYWJlbERpcmVjdGlvbkhhbmRsaW5nLFxuICBsZWdlbmRTeW1ib2xTdmc6ICgpID0+IGxlZ2VuZFN5bWJvbFN2ZyxcbiAgbGluZURpc3RhbmNlU3F1YXJlZDogKCkgPT4gbGluZURpc3RhbmNlU3F1YXJlZCxcbiAgbGlzdERlY29yYXRlZFByb3BlcnRpZXM6ICgpID0+IGxpc3REZWNvcmF0ZWRQcm9wZXJ0aWVzLFxuICBtYWtlQWNjZXNzaWJsZUNsaWNrTGlzdGVuZXI6ICgpID0+IG1ha2VBY2Nlc3NpYmxlQ2xpY2tMaXN0ZW5lcixcbiAgbWFwVmFsdWVzOiAoKSA9PiBtYXBWYWx1ZXMsXG4gIG1hcmtlckZhZGVJbkFuaW1hdGlvbjogKCkgPT4gbWFya2VyRmFkZUluQW5pbWF0aW9uLFxuICBtYXJrZXJQYWxldHRlRmFjdG9yeTogKCkgPT4gbWFya2VyUGFsZXR0ZUZhY3RvcnksXG4gIG1hcmtlclNjYWxlSW5BbmltYXRpb246ICgpID0+IG1hcmtlclNjYWxlSW5BbmltYXRpb24sXG4gIG1hcmtlclN3aXBlU2NhbGVJbkFuaW1hdGlvbjogKCkgPT4gbWFya2VyU3dpcGVTY2FsZUluQW5pbWF0aW9uLFxuICBtZXJnZUFycmF5RGVmYXVsdHM6ICgpID0+IG1lcmdlQXJyYXlEZWZhdWx0cyxcbiAgbWVyZ2VEZWZhdWx0czogKCkgPT4gbWVyZ2VEZWZhdWx0cyxcbiAgbWlkcG9pbnRTdGFydGluZ0JhclBvc2l0aW9uOiAoKSA9PiBtaWRwb2ludFN0YXJ0aW5nQmFyUG9zaXRpb24sXG4gIG1vZDogKCkgPT4gbW9kLFxuICBtb2R1bGVSZWdpc3RyeTogKCkgPT4gbW9kdWxlUmVnaXN0cnksXG4gIG1vdGlvbjogKCkgPT4gbW90aW9uLFxuICBuZWFyZXN0U3F1YXJlZDogKCkgPT4gbmVhcmVzdFNxdWFyZWQsXG4gIG5lYXJlc3RTcXVhcmVkSW5Db250YWluZXI6ICgpID0+IG5lYXJlc3RTcXVhcmVkSW5Db250YWluZXIsXG4gIG5vcm1hbGlzZUdyb3VwVG86ICgpID0+IG5vcm1hbGlzZUdyb3VwVG8sXG4gIG5vcm1hbGlzZVByb3BlcnR5VG86ICgpID0+IG5vcm1hbGlzZVByb3BlcnR5VG8sXG4gIG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGE6ICgpID0+IG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGEsXG4gIG5vcm1hbGl6ZUFuZ2xlMTgwOiAoKSA9PiBub3JtYWxpemVBbmdsZTE4MCxcbiAgbm9ybWFsaXplQW5nbGUzNjA6ICgpID0+IG5vcm1hbGl6ZUFuZ2xlMzYwLFxuICBub3JtYWxpemVBbmdsZTM2MEluY2x1c2l2ZTogKCkgPT4gbm9ybWFsaXplQW5nbGUzNjBJbmNsdXNpdmUsXG4gIG9iamVjdHNFcXVhbDogKCkgPT4gb2JqZWN0c0VxdWFsLFxuICBvYmplY3RzRXF1YWxXaXRoOiAoKSA9PiBvYmplY3RzRXF1YWxXaXRoLFxuICBwYWlyVXBTcGFuczogKCkgPT4gcGFpclVwU3BhbnMsXG4gIHBhcnRpYWxBc3NpZ246ICgpID0+IHBhcnRpYWxBc3NpZ24sXG4gIHBhdGhGYWRlSW5BbmltYXRpb246ICgpID0+IHBhdGhGYWRlSW5BbmltYXRpb24sXG4gIHBhdGhNb3Rpb246ICgpID0+IHBhdGhNb3Rpb24sXG4gIHBhdGhTd2lwZUluQW5pbWF0aW9uOiAoKSA9PiBwYXRoU3dpcGVJbkFuaW1hdGlvbixcbiAgcGlja0J5TWF0Y2hpbmdBbmdsZTogKCkgPT4gcGlja0J5TWF0Y2hpbmdBbmdsZSxcbiAgcGxvdEFyZWFQYXRoRmlsbDogKCkgPT4gcGxvdEFyZWFQYXRoRmlsbCxcbiAgcGxvdEludGVycG9sYXRlZEFyZWFTZXJpZXNGaWxsU3BhbnM6ICgpID0+IHBsb3RJbnRlcnBvbGF0ZWRBcmVhU2VyaWVzRmlsbFNwYW5zLFxuICBwbG90SW50ZXJwb2xhdGVkTGluZVBhdGhTdHJva2U6ICgpID0+IHBsb3RJbnRlcnBvbGF0ZWRMaW5lUGF0aFN0cm9rZSxcbiAgcGxvdExpbmVQYXRoU3Ryb2tlOiAoKSA9PiBwbG90TGluZVBhdGhTdHJva2UsXG4gIHByZWRpY2F0ZVdpdGhNZXNzYWdlOiAoKSA9PiBwcmVkaWNhdGVXaXRoTWVzc2FnZSxcbiAgcHJlcGFyZUFyZWFGaWxsQW5pbWF0aW9uRm5zOiAoKSA9PiBwcmVwYXJlQXJlYUZpbGxBbmltYXRpb25GbnMsXG4gIHByZXBhcmVBcmVhUGF0aEFuaW1hdGlvbjogKCkgPT4gcHJlcGFyZUFyZWFQYXRoQW5pbWF0aW9uLFxuICBwcmVwYXJlQXhpc0FuaW1hdGlvbkNvbnRleHQ6ICgpID0+IHByZXBhcmVBeGlzQW5pbWF0aW9uQ29udGV4dCxcbiAgcHJlcGFyZUF4aXNBbmltYXRpb25GdW5jdGlvbnM6ICgpID0+IHByZXBhcmVBeGlzQW5pbWF0aW9uRnVuY3Rpb25zLFxuICBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zOiAoKSA9PiBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zLFxuICBwcmVwYXJlTGluZVBhdGhBbmltYXRpb246ICgpID0+IHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbixcbiAgcHJlcGFyZUxpbmVQYXRoUHJvcGVydHlBbmltYXRpb246ICgpID0+IHByZXBhcmVMaW5lUGF0aFByb3BlcnR5QW5pbWF0aW9uLFxuICBwcmVwYXJlTGluZVBhdGhTdHJva2VBbmltYXRpb25GbnM6ICgpID0+IHByZXBhcmVMaW5lUGF0aFN0cm9rZUFuaW1hdGlvbkZucyxcbiAgcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9uczogKCkgPT4gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyxcbiAgcmFuZ2U6ICgpID0+IHJhbmdlLFxuICByYW5nZWRWYWx1ZVByb3BlcnR5OiAoKSA9PiByYW5nZWRWYWx1ZVByb3BlcnR5LFxuICByZXNldEF4aXNHcm91cEZuOiAoKSA9PiByZXNldEF4aXNHcm91cEZuLFxuICByZXNldEF4aXNMYWJlbFNlbGVjdGlvbkZuOiAoKSA9PiByZXNldEF4aXNMYWJlbFNlbGVjdGlvbkZuLFxuICByZXNldEF4aXNMaW5lU2VsZWN0aW9uRm46ICgpID0+IHJlc2V0QXhpc0xpbmVTZWxlY3Rpb25GbixcbiAgcmVzZXRBeGlzU2VsZWN0aW9uRm46ICgpID0+IHJlc2V0QXhpc1NlbGVjdGlvbkZuLFxuICByZXNldEJhclNlbGVjdGlvbnNGbjogKCkgPT4gcmVzZXRCYXJTZWxlY3Rpb25zRm4sXG4gIHJlc2V0SWRzOiAoKSA9PiByZXNldElkcyxcbiAgcmVzZXRMYWJlbEZuOiAoKSA9PiByZXNldExhYmVsRm4sXG4gIHJlc2V0TWFya2VyRm46ICgpID0+IHJlc2V0TWFya2VyRm4sXG4gIHJlc2V0TWFya2VyUG9zaXRpb25GbjogKCkgPT4gcmVzZXRNYXJrZXJQb3NpdGlvbkZuLFxuICByZXNldE1vdGlvbjogKCkgPT4gcmVzZXRNb3Rpb24sXG4gIHJlc2V0UGllU2VsZWN0aW9uc0ZuOiAoKSA9PiByZXNldFBpZVNlbGVjdGlvbnNGbixcbiAgcm91bmQ6ICgpID0+IHJvdW5kLFxuICByb3dDb3VudFByb3BlcnR5OiAoKSA9PiByb3dDb3VudFByb3BlcnR5LFxuICBzYW5pdGl6ZUh0bWw6ICgpID0+IHNhbml0aXplSHRtbCxcbiAgc2NhbGU6ICgpID0+IHNjYWxlLFxuICBzZWN0b3JCb3g6ICgpID0+IHNlY3RvckJveCxcbiAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb246ICgpID0+IHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uLFxuICBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb246ICgpID0+IHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbixcbiAgc2V0QXR0cmlidXRlOiAoKSA9PiBzZXRBdHRyaWJ1dGUsXG4gIHNldEF0dHJpYnV0ZXM6ICgpID0+IHNldEF0dHJpYnV0ZXMsXG4gIHNldERvY3VtZW50OiAoKSA9PiBzZXREb2N1bWVudCxcbiAgc2V0RWxlbWVudEJCb3g6ICgpID0+IHNldEVsZW1lbnRCQm94LFxuICBzZXRFbGVtZW50U3R5bGU6ICgpID0+IHNldEVsZW1lbnRTdHlsZSxcbiAgc2V0UGF0aDogKCkgPT4gc2V0UGF0aCxcbiAgc2V0V2luZG93OiAoKSA9PiBzZXRXaW5kb3csXG4gIHNoYWxsb3dDbG9uZTogKCkgPT4gc2hhbGxvd0Nsb25lLFxuICBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeTogKCkgPT4gc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3RvcnksXG4gIHNvbHZlQmV6aWVyOiAoKSA9PiBzb2x2ZUJlemllcixcbiAgc29ydEFuZFVuaXF1ZURhdGVzOiAoKSA9PiBzb3J0QW5kVW5pcXVlRGF0ZXMsXG4gIHNwbGl0QmV6aWVyOiAoKSA9PiBzcGxpdEJlemllcixcbiAgc3RhdGljRnJvbVRvTW90aW9uOiAoKSA9PiBzdGF0aWNGcm9tVG9Nb3Rpb24sXG4gIHN0b3BQYWdlU2Nyb2xsaW5nOiAoKSA9PiBzdG9wUGFnZVNjcm9sbGluZyxcbiAgc3VtOiAoKSA9PiBzdW0sXG4gIHN1bVZhbHVlczogKCkgPT4gc3VtVmFsdWVzLFxuICBzd2FwQXhpc0NvbmRpdGlvbjogKCkgPT4gc3dhcEF4aXNDb25kaXRpb24sXG4gIHRvRGVncmVlczogKCkgPT4gdG9EZWdyZWVzLFxuICB0b1JhZGlhbnM6ICgpID0+IHRvUmFkaWFucyxcbiAgdG9vbHRpcENvbnRlbnRBcmlhTGFiZWw6ICgpID0+IHRvb2x0aXBDb250ZW50QXJpYUxhYmVsLFxuICB0cmFpbGluZ0FjY3VtdWxhdGVkVmFsdWU6ICgpID0+IHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZSxcbiAgdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlUHJvcGVydHk6ICgpID0+IHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZVByb3BlcnR5LFxuICB1cGRhdGVDbGlwUGF0aDogKCkgPT4gdXBkYXRlQ2xpcFBhdGgsXG4gIHVwZGF0ZUxhYmVsTm9kZTogKCkgPT4gdXBkYXRlTGFiZWxOb2RlLFxuICB2YWxpZGF0ZUNyb3NzTGluZVZhbHVlczogKCkgPT4gdmFsaWRhdGVDcm9zc0xpbmVWYWx1ZXMsXG4gIHZhbHVlUHJvcGVydHk6ICgpID0+IHZhbHVlUHJvcGVydHksXG4gIHZpc2libGVSYW5nZUluZGljZXM6ICgpID0+IHZpc2libGVSYW5nZUluZGljZXMsXG4gIHdpdGhvdXQ6ICgpID0+IHdpdGhvdXRcbn0pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2RlcHJlY2F0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gIHJldHVybiAoa2V5LCBtZXNzYWdlKSA9PiB7XG4gICAgY29uc3QgbXNnID0gW2BQcm9wZXJ0eSBbJHtrZXl9XSBpcyBkZXByZWNhdGVkLmAsIG1lc3NhZ2VdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgICBsb2dnZXJfZXhwb3J0cy53YXJuT25jZShtc2cpO1xuICB9O1xufVxuZnVuY3Rpb24gRGVwcmVjYXRlZChtZXNzYWdlLCBvcHRzKSB7XG4gIGNvbnN0IHdhcm5EZXByZWNhdGVkID0gY3JlYXRlRGVwcmVjYXRpb25XYXJuaW5nKCk7XG4gIGNvbnN0IGRlZiA9IG9wdHM/LmRlZmF1bHQ7XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoKF8sIGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgIT09IGRlZikge1xuICAgICAgd2FybkRlcHJlY2F0ZWQoa2V5LnRvU3RyaW5nKCksIG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pO1xufVxuZnVuY3Rpb24gRGVwcmVjYXRlZEFuZFJlbmFtZWRUbyhuZXdQcm9wTmFtZSwgbWFwVmFsdWUpIHtcbiAgY29uc3Qgd2FybkRlcHJlY2F0ZWQgPSBjcmVhdGVEZXByZWNhdGlvbldhcm5pbmcoKTtcbiAgcmV0dXJuIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eShcbiAgICAodGFyZ2V0LCBrZXksIHZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHRhcmdldFtuZXdQcm9wTmFtZV0pIHtcbiAgICAgICAgd2FybkRlcHJlY2F0ZWQoa2V5LnRvU3RyaW5nKCksIGBVc2UgWyR7bmV3UHJvcE5hbWV9XSBpbnN0ZWFkLmApO1xuICAgICAgICBzZXRQYXRoKHRhcmdldCwgbmV3UHJvcE5hbWUsIG1hcFZhbHVlID8gbWFwVmFsdWUodmFsdWUpIDogdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJSRUFLX1RSQU5TRk9STV9DSEFJTjtcbiAgICB9LFxuICAgICh0YXJnZXQsIGtleSkgPT4ge1xuICAgICAgd2FybkRlcHJlY2F0ZWQoa2V5LnRvU3RyaW5nKCksIGBVc2UgWyR7bmV3UHJvcE5hbWV9XSBpbnN0ZWFkLmApO1xuICAgICAgcmV0dXJuIGdldFBhdGgodGFyZ2V0LCBuZXdQcm9wTmFtZSk7XG4gICAgfVxuICApO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3ZlY3Rvci50c1xudmFyIFZlYzIgPSB7XG4gIGFkZCxcbiAgYW5nbGUsXG4gIGFwcGx5LFxuICBlcXVhbCxcbiAgZGlzdGFuY2UsXG4gIGRpc3RhbmNlU3F1YXJlZCxcbiAgZnJvbTogZnJvbTIsXG4gIGdyYWRpZW50LFxuICBpbnRlcmNlcHQsXG4gIGludGVyc2VjdEF0WCxcbiAgaW50ZXJzZWN0QXRZLFxuICBsZW5ndGgsXG4gIGxlbmd0aFNxdWFyZWQsXG4gIG11bHRpcGx5LFxuICBub3JtYWxpemVkLFxuICBvcmlnaW46IG9yaWdpbjIsXG4gIHJlcXVpcmVkLFxuICByb3RhdGUsXG4gIHJvdW5kOiByb3VuZDQsXG4gIHN1YlxufTtcbmZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gIGlmICh0eXBlb2YgYiA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB7IHg6IGEueCArIGIsIHk6IGEueSArIGIgfTtcbiAgfVxuICByZXR1cm4geyB4OiBhLnggKyBiLngsIHk6IGEueSArIGIueSB9O1xufVxuZnVuY3Rpb24gc3ViKGEsIGIpIHtcbiAgaWYgKHR5cGVvZiBiID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHsgeDogYS54IC0gYiwgeTogYS55IC0gYiB9O1xuICB9XG4gIHJldHVybiB7IHg6IGEueCAtIGIueCwgeTogYS55IC0gYi55IH07XG59XG5mdW5jdGlvbiBtdWx0aXBseShhLCBiKSB7XG4gIGlmICh0eXBlb2YgYiA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB7IHg6IGEueCAqIGIsIHk6IGEueSAqIGIgfTtcbiAgfVxuICByZXR1cm4geyB4OiBhLnggKiBiLngsIHk6IGEueSAqIGIueSB9O1xufVxuZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgcmV0dXJuIE1hdGguc3FydChhLnggKiBhLnggKyBhLnkgKiBhLnkpO1xufVxuZnVuY3Rpb24gbGVuZ3RoU3F1YXJlZChhKSB7XG4gIHJldHVybiBhLnggKiBhLnggKyBhLnkgKiBhLnk7XG59XG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIGNvbnN0IGQgPSBzdWIoYSwgYik7XG4gIHJldHVybiBNYXRoLnNxcnQoZC54ICogZC54ICsgZC55ICogZC55KTtcbn1cbmZ1bmN0aW9uIGRpc3RhbmNlU3F1YXJlZChhLCBiKSB7XG4gIGNvbnN0IGQgPSBzdWIoYSwgYik7XG4gIHJldHVybiBkLnggKiBkLnggKyBkLnkgKiBkLnk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVkKGEpIHtcbiAgY29uc3QgbCA9IGxlbmd0aChhKTtcbiAgcmV0dXJuIHsgeDogYS54IC8gbCwgeTogYS55IC8gbCB9O1xufVxuZnVuY3Rpb24gYW5nbGUoYSwgYiA9IG9yaWdpbjIoKSkge1xuICByZXR1cm4gTWF0aC5hdGFuMihhLnksIGEueCkgLSBNYXRoLmF0YW4yKGIueSwgYi54KTtcbn1cbmZ1bmN0aW9uIHJvdGF0ZShhLCB0aGV0YSwgYiA9IG9yaWdpbjIoKSkge1xuICBjb25zdCBsID0gbGVuZ3RoKGEpO1xuICByZXR1cm4geyB4OiBiLnggKyBsICogTWF0aC5jb3ModGhldGEpLCB5OiBiLnkgKyBsICogTWF0aC5zaW4odGhldGEpIH07XG59XG5mdW5jdGlvbiBncmFkaWVudChhLCBiLCByZWZsZWN0aW9uKSB7XG4gIGNvbnN0IGR4ID0gYi54IC0gYS54O1xuICBjb25zdCBkeSA9IHJlZmxlY3Rpb24gPT0gbnVsbCA/IGIueSAtIGEueSA6IHJlZmxlY3Rpb24gLSBiLnkgLSAocmVmbGVjdGlvbiAtIGEueSk7XG4gIHJldHVybiBkeSAvIGR4O1xufVxuZnVuY3Rpb24gaW50ZXJjZXB0KGEsIGdyYWRpZW50MiwgcmVmbGVjdGlvbikge1xuICBjb25zdCB5ID0gcmVmbGVjdGlvbiA9PSBudWxsID8gYS55IDogcmVmbGVjdGlvbiAtIGEueTtcbiAgcmV0dXJuIHkgLSBncmFkaWVudDIgKiBhLng7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RBdFkoZ3JhZGllbnQyLCBjb2VmZmljaWVudCwgeSA9IDAsIHJlZmxlY3Rpb24pIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBncmFkaWVudDIgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiAoeSAtIGNvZWZmaWNpZW50KSAvIGdyYWRpZW50MixcbiAgICB5OiByZWZsZWN0aW9uID09IG51bGwgPyB5IDogcmVmbGVjdGlvbiAtIHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdEF0WChncmFkaWVudDIsIGNvZWZmaWNpZW50LCB4ID0gMCwgcmVmbGVjdGlvbikge1xuICBjb25zdCB5ID0gZ3JhZGllbnQyID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogZ3JhZGllbnQyICogeCArIGNvZWZmaWNpZW50O1xuICByZXR1cm4geyB4LCB5OiByZWZsZWN0aW9uID09IG51bGwgPyB5IDogcmVmbGVjdGlvbiAtIHkgfTtcbn1cbmZ1bmN0aW9uIHJvdW5kNChhKSB7XG4gIHJldHVybiB7IHg6IE1hdGgucm91bmQoYS54KSwgeTogTWF0aC5yb3VuZChhLnkpIH07XG59XG5mdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueTtcbn1cbmZ1bmN0aW9uIGZyb20yKGEsIGIpIHtcbiAgaWYgKHR5cGVvZiBhID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHsgeDogYSwgeTogYiB9O1xuICB9XG4gIGlmIChcImN1cnJlbnRYXCIgaW4gYSkge1xuICAgIHJldHVybiB7IHg6IGEuY3VycmVudFgsIHk6IGEuY3VycmVudFkgfTtcbiAgfVxuICBpZiAoXCJvZmZzZXRXaWR0aFwiIGluIGEpIHtcbiAgICByZXR1cm4geyB4OiBhLm9mZnNldFdpZHRoLCB5OiBhLm9mZnNldEhlaWdodCB9O1xuICB9XG4gIGlmIChcIndpZHRoXCIgaW4gYSkge1xuICAgIHJldHVybiBbXG4gICAgICB7IHg6IGEueCwgeTogYS55IH0sXG4gICAgICB7IHg6IGEueCArIGEud2lkdGgsIHk6IGEueSArIGEuaGVpZ2h0IH1cbiAgICBdO1xuICB9XG4gIGlmIChcIngxXCIgaW4gYSkge1xuICAgIHJldHVybiBbXG4gICAgICB7IHg6IGEueDEsIHk6IGEueTEgfSxcbiAgICAgIHsgeDogYS54MiwgeTogYS55MiB9XG4gICAgXTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlcyBjYW4gbm90IGJlIGNvbnZlcnRlZCBpbnRvIGEgdmVjdG9yOiBbJHtKU09OLnN0cmluZ2lmeShhKX1dIFske2J9XWApO1xufVxuZnVuY3Rpb24gYXBwbHkoYSwgYikge1xuICBhLnggPSBiLng7XG4gIGEueSA9IGIueTtcbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiByZXF1aXJlZChhKSB7XG4gIHJldHVybiB7IHg6IGE/LnggPz8gMCwgeTogYT8ueSA/PyAwIH07XG59XG5mdW5jdGlvbiBvcmlnaW4yKCkge1xuICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9oaWVyYXJjaHkvaGllcmFyY2h5U2VyaWVzLnRzXG52YXIgX0hpZXJhcmNoeU5vZGUgPSBjbGFzcyBfSGllcmFyY2h5Tm9kZSB7XG4gIGNvbnN0cnVjdG9yKHNlcmllcywgZGF0dW1JbmRleCwgZGF0dW0sIHNpemVWYWx1ZSwgY29sb3JWYWx1ZSwgc3VtU2l6ZSwgZGVwdGgsIHBhcmVudCwgY2hpbGRyZW4pIHtcbiAgICB0aGlzLnNlcmllcyA9IHNlcmllcztcbiAgICB0aGlzLmRhdHVtSW5kZXggPSBkYXR1bUluZGV4O1xuICAgIHRoaXMuZGF0dW0gPSBkYXR1bTtcbiAgICB0aGlzLnNpemVWYWx1ZSA9IHNpemVWYWx1ZTtcbiAgICB0aGlzLmNvbG9yVmFsdWUgPSBjb2xvclZhbHVlO1xuICAgIHRoaXMuc3VtU2l6ZSA9IHN1bVNpemU7XG4gICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLm1pZFBvaW50ID0geyB4OiAwLCB5OiAwIH07XG4gIH1cbiAgZ2V0IGhhc0NoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDA7XG4gIH1cbiAgd2FsayhjYWxsYmFjazIsIG9yZGVyID0gX0hpZXJhcmNoeU5vZGUuV2Fsay5QcmVPcmRlcikge1xuICAgIGlmIChvcmRlciA9PT0gX0hpZXJhcmNoeU5vZGUuV2Fsay5QcmVPcmRlcikge1xuICAgICAgY2FsbGJhY2syKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBjaGlsZC53YWxrKGNhbGxiYWNrMiwgb3JkZXIpO1xuICAgIH0pO1xuICAgIGlmIChvcmRlciA9PT0gX0hpZXJhcmNoeU5vZGUuV2Fsay5Qb3N0T3JkZXIpIHtcbiAgICAgIGNhbGxiYWNrMih0aGlzKTtcbiAgICB9XG4gIH1cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHlpZWxkIHRoaXM7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICB5aWVsZCogY2hpbGQ7XG4gICAgfVxuICB9XG59O1xuX0hpZXJhcmNoeU5vZGUuV2FsayA9IHtcbiAgUHJlT3JkZXI6IDAsXG4gIFBvc3RPcmRlcjogMVxufTtcbnZhciBIaWVyYXJjaHlOb2RlID0gX0hpZXJhcmNoeU5vZGU7XG52YXIgSGllcmFyY2h5U2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBwaWNrTW9kZXM6IFsxIC8qIE5FQVJFU1RfTk9ERSAqLywgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL11cbiAgICB9KTtcbiAgICB0aGlzLmNvbG9yRG9tYWluID0gWzAsIDBdO1xuICAgIHRoaXMubWF4RGVwdGggPSAwO1xuICAgIHRoaXMuY29sb3JTY2FsZSA9IG5ldyBDb2xvclNjYWxlKCk7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IG5ldyBTdGF0ZU1hY2hpbmUoXG4gICAgICBcImVtcHR5XCIsXG4gICAgICB7XG4gICAgICAgIGVtcHR5OiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwicmVhZHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH0sXG4gICAgICAgIHJlYWR5OiB7XG4gICAgICAgICAgdXBkYXRlRGF0YTogXCJ3YWl0aW5nXCIsXG4gICAgICAgICAgY2xlYXI6IFwiY2xlYXJpbmdcIixcbiAgICAgICAgICBoaWdobGlnaHQ6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeUhpZ2hsaWdodChkYXRhKSxcbiAgICAgICAgICByZXNpemU6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeVJlc2l6ZShkYXRhKSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIlxuICAgICAgICB9LFxuICAgICAgICB3YWl0aW5nOiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwicmVhZHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJpbmc6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJlbXB0eVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICgpID0+IHRoaXMuY2hlY2tQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpXG4gICAgKTtcbiAgfVxuICByZXNldEFuaW1hdGlvbihwaGFzZSkge1xuICAgIGlmIChwaGFzZSA9PT0gXCJpbml0aWFsXCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInJlc2V0XCIpO1xuICAgIH0gZWxzZSBpZiAocGhhc2UgPT09IFwicmVhZHlcIikge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwic2tpcFwiKTtcbiAgICB9XG4gIH1cbiAgcHJvY2Vzc0RhdGEoKSB7XG4gICAgY29uc3QgeyBOb2RlQ2xhc3MgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBjaGlsZHJlbktleSwgc2l6ZUtleSwgY29sb3JLZXksIGNvbG9yUmFuZ2UgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBsZXQgbWF4RGVwdGggPSAwO1xuICAgIGxldCBtaW5Db2xvciA9IEluZmluaXR5O1xuICAgIGxldCBtYXhDb2xvciA9IC1JbmZpbml0eTtcbiAgICBjb25zdCBjcmVhdGVOb2RlID0gKGRhdHVtLCBpbmRleFBhdGgsIHBhcmVudCkgPT4ge1xuICAgICAgY29uc3QgZGVwdGggPSBwYXJlbnQuZGVwdGggIT0gbnVsbCA/IHBhcmVudC5kZXB0aCArIDEgOiAwO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjaGlsZHJlbktleSAhPSBudWxsID8gZGF0dW1bY2hpbGRyZW5LZXldIDogdm9pZCAwO1xuICAgICAgY29uc3QgaXNMZWFmID0gY2hpbGRyZW4gPT0gbnVsbCB8fCBjaGlsZHJlbi5sZW5ndGggPT09IDA7XG4gICAgICBsZXQgc2l6ZVZhbHVlID0gc2l6ZUtleSAhPSBudWxsID8gZGF0dW1bc2l6ZUtleV0gOiB2b2lkIDA7XG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHNpemVWYWx1ZSkpIHtcbiAgICAgICAgc2l6ZVZhbHVlID0gTWF0aC5tYXgoc2l6ZVZhbHVlLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemVWYWx1ZSA9IGlzTGVhZiA/IDEgOiAwO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3VtU2l6ZSA9IHNpemVWYWx1ZTtcbiAgICAgIG1heERlcHRoID0gTWF0aC5tYXgobWF4RGVwdGgsIGRlcHRoKTtcbiAgICAgIGNvbnN0IGNvbG9yVmFsdWUgPSBjb2xvcktleSAhPSBudWxsID8gZGF0dW1bY29sb3JLZXldIDogdm9pZCAwO1xuICAgICAgaWYgKHR5cGVvZiBjb2xvclZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG1pbkNvbG9yID0gTWF0aC5taW4obWluQ29sb3IsIGNvbG9yVmFsdWUpO1xuICAgICAgICBtYXhDb2xvciA9IE1hdGgubWF4KG1heENvbG9yLCBjb2xvclZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcHBlbmRDaGlsZHJlbihcbiAgICAgICAgbmV3IE5vZGVDbGFzcyh0aGlzLCBpbmRleFBhdGgsIGRhdHVtLCBzaXplVmFsdWUsIGNvbG9yVmFsdWUsIHN1bVNpemUsIGRlcHRoLCBwYXJlbnQsIFtdKSxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgICk7XG4gICAgfTtcbiAgICBjb25zdCBhcHBlbmRDaGlsZHJlbiA9IChub2RlLCBkYXRhKSA9PiB7XG4gICAgICBjb25zdCB7IGRhdHVtSW5kZXggfSA9IG5vZGU7XG4gICAgICBkYXRhPy5mb3JFYWNoKChkYXR1bSwgY2hpbGRJbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNyZWF0ZU5vZGUoZGF0dW0sIGRhdHVtSW5kZXguY29uY2F0KGNoaWxkSW5kZXgpLCBub2RlKTtcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgbm9kZS5zdW1TaXplICs9IGNoaWxkLnN1bVNpemU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgY29uc3Qgcm9vdE5vZGUgPSBhcHBlbmRDaGlsZHJlbihcbiAgICAgIG5ldyBOb2RlQ2xhc3ModGhpcywgW10sIHZvaWQgMCwgMCwgdm9pZCAwLCAwLCB2b2lkIDAsIHZvaWQgMCwgW10pLFxuICAgICAgdGhpcy5kYXRhXG4gICAgKTtcbiAgICBjb25zdCBjb2xvckRvbWFpbiA9IFttaW5Db2xvciwgbWF4Q29sb3JdO1xuICAgIHRoaXMuY29sb3JTY2FsZS5kb21haW4gPSBtaW5Db2xvciA8IG1heENvbG9yID8gW21pbkNvbG9yLCBtYXhDb2xvcl0gOiBbMCwgMV07XG4gICAgdGhpcy5jb2xvclNjYWxlLnJhbmdlID0gY29sb3JSYW5nZSA/PyBbXCJibGFja1wiXTtcbiAgICB0aGlzLmNvbG9yU2NhbGUudXBkYXRlKCk7XG4gICAgdGhpcy5yb290Tm9kZSA9IHJvb3ROb2RlO1xuICAgIHRoaXMubWF4RGVwdGggPSBtYXhEZXB0aDtcbiAgICB0aGlzLmNvbG9yRG9tYWluID0gY29sb3JEb21haW47XG4gIH1cbiAgdXBkYXRlKHsgc2VyaWVzUmVjdCB9KSB7XG4gICAgdGhpcy51cGRhdGVTZWxlY3Rpb25zKCk7XG4gICAgdGhpcy51cGRhdGVOb2RlcygpO1xuICAgIGNvbnN0IGFuaW1hdGlvbkRhdGEgPSB0aGlzLmdldEFuaW1hdGlvbkRhdGEoKTtcbiAgICBjb25zdCByZXNpemUgPSB0aGlzLmNoZWNrUmVzaXplKHNlcmllc1JlY3QpO1xuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInJlc2l6ZVwiLCBhbmltYXRpb25EYXRhKTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlXCIsIGFuaW1hdGlvbkRhdGEpO1xuICB9XG4gIHJlc2V0QWxsQW5pbWF0aW9uKF9kYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XG4gIH1cbiAgYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0KF9kYXRhKSB7XG4gIH1cbiAgYW5pbWF0ZVJlYWR5UmVzaXplKGRhdGEpIHtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KGRhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGdldEFuaW1hdGlvbkRhdGEoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGlzUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2hlY2tQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpKSB7XG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB9XG4gIH1cbiAgZ2V0U2VyaWVzRG9tYWluKCkge1xuICAgIHJldHVybiBbTmFOLCBOYU5dO1xuICB9XG4gIGdldFNlcmllc1JhbmdlKF9kaXJlY3Rpb24sIF92aXNpYmxlUmFuZ2UpIHtcbiAgICByZXR1cm4gW05hTiwgTmFOXTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBjb25zdCB7IGNvbG9yS2V5LCBjb2xvck5hbWUsIGNvbG9yUmFuZ2UgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7XG4gICAgICBpZDogc2VyaWVzSWQsXG4gICAgICBjdHg6IHsgbGVnZW5kTWFuYWdlciB9LFxuICAgICAgdmlzaWJsZVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBsZWdlbmRUeXBlID09PSBcImdyYWRpZW50XCIgJiYgY29sb3JLZXkgIT0gbnVsbCAmJiBjb2xvclJhbmdlICE9IG51bGwgPyBbXG4gICAgICB7XG4gICAgICAgIGxlZ2VuZFR5cGU6IFwiZ3JhZGllbnRcIixcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSAmJiBsZWdlbmRNYW5hZ2VyLmdldEl0ZW1FbmFibGVkKHsgc2VyaWVzSWQgfSksXG4gICAgICAgIHNlcmllc0lkLFxuICAgICAgICBjb2xvck5hbWUsXG4gICAgICAgIGNvbG9yUmFuZ2UsXG4gICAgICAgIGNvbG9yRG9tYWluOiB0aGlzLmNvbG9yRG9tYWluXG4gICAgICB9XG4gICAgXSA6IFtdO1xuICB9XG4gIGdldERhdHVtSWRGcm9tRGF0YShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuZGF0dW1JbmRleC5qb2luKFwiOlwiKTtcbiAgfVxuICBnZXREYXR1bUlkKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREYXR1bUlkRnJvbURhdGEobm9kZSk7XG4gIH1cbiAgcmVtb3ZlTWVJbmRleFBhdGhGb3JJbmRleChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmRhdHVtU2VsZWN0aW9uLmF0KGluZGV4ICsgMSk/LmRhdHVtLmRhdHVtSW5kZXggPz8gW107XG4gIH1cbiAgcmVtb3ZlTWVJbmRleEZvckluZGV4UGF0aChpbmRleFBhdGgpIHtcbiAgICBmb3IgKGNvbnN0IHsgaW5kZXgsIGRhdHVtIH0gb2YgdGhpcy5kYXR1bVNlbGVjdGlvbikge1xuICAgICAgaWYgKGFycmF5c0VxdWFsKGRhdHVtLmRhdHVtSW5kZXgsIGluZGV4UGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4IC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcGlja0ZvY3VzKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMucm9vdE5vZGU/LmNoaWxkcmVuLmxlbmd0aClcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgaW5kZXggPSBjbGFtcCgwLCBvcHRzLmRhdHVtSW5kZXggLSBvcHRzLmRhdHVtSW5kZXhEZWx0YSwgdGhpcy5kYXR1bVNlbGVjdGlvbi5sZW5ndGggLSAxKTtcbiAgICBjb25zdCB7IGRhdHVtSW5kZXhEZWx0YTogY2hpbGREZWx0YSwgb3RoZXJJbmRleERlbHRhOiBkZXB0aERlbHRhIH0gPSBvcHRzO1xuICAgIGxldCBwYXRoID0gdGhpcy5yZW1vdmVNZUluZGV4UGF0aEZvckluZGV4KGluZGV4KTtcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHBhdGgucmVkdWNlKChuLCBjaGlsZEluZGV4KSA9PiBuLmNoaWxkcmVuW2NoaWxkSW5kZXhdLCB0aGlzLnJvb3ROb2RlKTtcbiAgICBpZiAoZGVwdGhEZWx0YSA+IDAgJiYgY3VycmVudE5vZGUuaGFzQ2hpbGRyZW4pIHtcbiAgICAgIHBhdGggPSBbLi4ucGF0aCwgMF07XG4gICAgfSBlbHNlIGlmIChkZXB0aERlbHRhIDwgMCAmJiBwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICB9IGVsc2UgaWYgKGRlcHRoRGVsdGEgPT09IDAgJiYgY2hpbGREZWx0YSAhPT0gMCkge1xuICAgICAgY29uc3QgbWF4SW5kZXggPSBjdXJyZW50Tm9kZS5wYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgIHBhdGggPSBwYXRoLnNsaWNlKCk7XG4gICAgICBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPSBjbGFtcCgwLCBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gKyBjaGlsZERlbHRhLCBtYXhJbmRleCk7XG4gICAgfVxuICAgIGNvbnN0IG5leHROb2RlID0gcGF0aC5yZWR1Y2UoKG4sIGNoaWxkSW5kZXgpID0+IG4uY2hpbGRyZW5bY2hpbGRJbmRleF0sIHRoaXMucm9vdE5vZGUpO1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuY29tcHV0ZUZvY3VzQm91bmRzKHRoaXMuZGF0dW1TZWxlY3Rpb24uYXQoaW5kZXggKyAxKSk7XG4gICAgaWYgKGJvdW5kcyA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIHJldHVybiB7XG4gICAgICBkYXR1bTogbmV4dE5vZGUsXG4gICAgICBkYXR1bUluZGV4OiB0aGlzLnJlbW92ZU1lSW5kZXhGb3JJbmRleFBhdGgocGF0aCksXG4gICAgICBvdGhlckluZGV4OiBuZXh0Tm9kZS5kZXB0aCxcbiAgICAgIGJvdW5kcyxcbiAgICAgIGNsaXBGb2N1c0JveDogdHJ1ZVxuICAgIH07XG4gIH1cbiAgZ2V0RGF0dW1BcmlhVGV4dChkYXR1bSwgZGVzY3JpcHRpb24pIHtcbiAgICBpZiAoIShkYXR1bSBpbnN0YW5jZW9mIHRoaXMuTm9kZUNsYXNzKSkge1xuICAgICAgbG9nZ2VyX2V4cG9ydHMuZXJyb3IoYGRhdHVtIGlzIG5vdCBIaWVyYXJjaHlOb2RlOiAke0pTT04uc3RyaW5naWZ5KGRhdHVtKX1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3R4LmxvY2FsZU1hbmFnZXIudChcImFyaWFBbm5vdW5jZUhpZXJhcmNoeURhdHVtXCIsIHtcbiAgICAgIGxldmVsOiAoZGF0dW0uZGVwdGggPz8gLTEpICsgMSxcbiAgICAgIGNvdW50OiBkYXR1bS5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICBkZXNjcmlwdGlvblxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvaGllcmFyY2h5L2hpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNoaWxkcmVuS2V5ID0gXCJjaGlsZHJlblwiO1xuICAgIHRoaXMuZmlsbHMgPSBPYmplY3QudmFsdWVzKERFRkFVTFRfRklMTFMpO1xuICAgIHRoaXMuc3Ryb2tlcyA9IE9iamVjdC52YWx1ZXMoREVGQVVMVF9TVFJPS0VTKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNoaWxkcmVuS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaXplS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGllcmFyY2h5U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKVxuXSwgSGllcmFyY2h5U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbHNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvclJhbmdlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvdG9wb2xvZ3kvbG9uTGF0QmJveC50c1xudmFyIExvbkxhdEJCb3ggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGxvbjAsIGxhdDAsIGxvbjEsIGxhdDEpIHtcbiAgICB0aGlzLmxvbjAgPSBsb24wO1xuICAgIHRoaXMubGF0MCA9IGxhdDA7XG4gICAgdGhpcy5sb24xID0gbG9uMTtcbiAgICB0aGlzLmxhdDEgPSBsYXQxO1xuICB9XG4gIG1lcmdlKG90aGVyKSB7XG4gICAgdGhpcy5sb24wID0gTWF0aC5taW4odGhpcy5sb24wLCBvdGhlci5sb24wKTtcbiAgICB0aGlzLmxhdDAgPSBNYXRoLm1pbih0aGlzLmxhdDAsIG90aGVyLmxhdDApO1xuICAgIHRoaXMubG9uMSA9IE1hdGgubWF4KHRoaXMubG9uMSwgb3RoZXIubG9uMSk7XG4gICAgdGhpcy5sYXQxID0gTWF0aC5tYXgodGhpcy5sYXQxLCBvdGhlci5sYXQxKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3RvcG9sb2d5L21lcmNhdG9yU2NhbGUudHNcbnZhciByYWRzSW5EZWcgPSBNYXRoLlBJIC8gMTgwO1xudmFyIGxvblggPSAobG9uKSA9PiBsb24gKiByYWRzSW5EZWc7XG52YXIgbGF0WSA9IChsYXQpID0+IC1NYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJICogMC4yNSArIGxhdCAqIHJhZHNJbkRlZyAqIDAuNSkpO1xudmFyIHhMb24gPSAoeCkgPT4geCAvIHJhZHNJbkRlZztcbnZhciB5TGF0ID0gKHkpID0+IChNYXRoLmF0YW4oTWF0aC5leHAoLXkpKSAtIE1hdGguUEkgKiAwLjI1KSAvIChyYWRzSW5EZWcgKiAwLjUpO1xudmFyIE1lcmNhdG9yU2NhbGUgPSBjbGFzcyBfTWVyY2F0b3JTY2FsZSBleHRlbmRzIEFic3RyYWN0U2NhbGUge1xuICBjb25zdHJ1Y3Rvcihkb21haW4sIHJhbmdlMykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kb21haW4gPSBkb21haW47XG4gICAgdGhpcy5yYW5nZSA9IHJhbmdlMztcbiAgICB0aGlzLnR5cGUgPSBcIm1lcmNhdG9yXCI7XG4gICAgdGhpcy5ib3VuZHMgPSBfTWVyY2F0b3JTY2FsZS5ib3VuZHMoZG9tYWluKTtcbiAgfVxuICBzdGF0aWMgYm91bmRzKGRvbWFpbikge1xuICAgIGNvbnN0IFtbbG9uMCwgbGF0MF0sIFtsb24xLCBsYXQxXV0gPSBkb21haW47XG4gICAgY29uc3QgeDAgPSBsb25YKGxvbjApO1xuICAgIGNvbnN0IHkwID0gbGF0WShsYXQwKTtcbiAgICBjb25zdCB4MSA9IGxvblgobG9uMSk7XG4gICAgY29uc3QgeTEgPSBsYXRZKGxhdDEpO1xuICAgIHJldHVybiBuZXcgQkJveChNYXRoLm1pbih4MCwgeDEpLCBNYXRoLm1pbih5MCwgeTEpLCBNYXRoLmFicyh4MSAtIHgwKSwgTWF0aC5hYnMoeTEgLSB5MCkpO1xuICB9XG4gIHN0YXRpYyBmaXhlZFNjYWxlKCkge1xuICAgIHJldHVybiBuZXcgX01lcmNhdG9yU2NhbGUoXG4gICAgICBbXG4gICAgICAgIFt4TG9uKDApLCB5TGF0KDApXSxcbiAgICAgICAgW3hMb24oMSksIHlMYXQoMSldXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFsxLCAxXVxuICAgICAgXVxuICAgICk7XG4gIH1cbiAgdG9Eb21haW4oKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG5vcm1hbGl6ZURvbWFpbnMoLi4uZG9tYWlucykge1xuICAgIGxldCB4MCA9IC1JbmZpbml0eTtcbiAgICBsZXQgeDEgPSBJbmZpbml0eTtcbiAgICBsZXQgeTAgPSAtSW5maW5pdHk7XG4gICAgbGV0IHkxID0gSW5maW5pdHk7XG4gICAgZm9yIChjb25zdCBkb21haW4gb2YgZG9tYWlucykge1xuICAgICAgZm9yIChjb25zdCBbeCwgeV0gb2YgZG9tYWluKSB7XG4gICAgICAgIHgwID0gTWF0aC5taW4oeCwgeDApO1xuICAgICAgICB4MSA9IE1hdGgubWF4KHgsIHgxKTtcbiAgICAgICAgeTAgPSBNYXRoLm1pbih5LCB5MCk7XG4gICAgICAgIHkxID0gTWF0aC5tYXgoeSwgeTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZG9tYWluOiBbXG4gICAgICAgIFt4MCwgeTBdLFxuICAgICAgICBbeDEsIHkxXVxuICAgICAgXSxcbiAgICAgIGFuaW1hdGFibGU6IHRydWVcbiAgICB9O1xuICB9XG4gIGNvbnZlcnQoW2xvbiwgbGF0XSkge1xuICAgIGNvbnN0IFtbeDAsIHkwXSwgW3gxLCB5MV1dID0gdGhpcy5yYW5nZTtcbiAgICBjb25zdCB4U2NhbGUgPSAoeDEgLSB4MCkgLyB0aGlzLmJvdW5kcy53aWR0aDtcbiAgICBjb25zdCB5U2NhbGUgPSAoeTEgLSB5MCkgLyB0aGlzLmJvdW5kcy5oZWlnaHQ7XG4gICAgcmV0dXJuIFsobG9uWChsb24pIC0gdGhpcy5ib3VuZHMueCkgKiB4U2NhbGUgKyB4MCwgKGxhdFkobGF0KSAtIHRoaXMuYm91bmRzLnkpICogeVNjYWxlICsgeTBdO1xuICB9XG4gIGludmVydChbeCwgeV0pIHtcbiAgICBjb25zdCBbW3gwLCB5MF0sIFt4MSwgeTFdXSA9IHRoaXMucmFuZ2U7XG4gICAgY29uc3QgeFNjYWxlID0gKHgxIC0geDApIC8gdGhpcy5ib3VuZHMud2lkdGg7XG4gICAgY29uc3QgeVNjYWxlID0gKHkxIC0geTApIC8gdGhpcy5ib3VuZHMuaGVpZ2h0O1xuICAgIHJldHVybiBbeExvbigoeCAtIHgwKSAvIHhTY2FsZSArIHRoaXMuYm91bmRzLngpLCB5TGF0KCh5IC0geTApIC8geVNjYWxlICsgdGhpcy5ib3VuZHMueSldO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNUaWNrcy50c1xudmFyIF9BeGlzVGlja3MgPSBjbGFzcyBfQXhpc1RpY2tzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMuYXhpc0dyb3VwID0gbmV3IFRyYW5zbGF0YWJsZUdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tQXhpc1RpY2tzYCwgekluZGV4OiAyIC8qIEFYSVMgKi8gfSk7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGhpcy5heGlzR3JvdXAsIFRleHQpO1xuICAgIHRoaXMuaW50ZXJ2YWwgPSBuZXcgQXhpc0ludGVydmFsKCk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBBeGlzTGFiZWwoKTtcbiAgICB0aGlzLnNjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IFwiYm90dG9tXCI7XG4gICAgdGhpcy50cmFuc2xhdGlvblggPSAwO1xuICAgIHRoaXMudHJhbnNsYXRpb25ZID0gMDtcbiAgICB0aGlzLnBhZGRpbmcgPSAwO1xuICB9XG4gIGF0dGFjaEF4aXMoYXhpc05vZGUpIHtcbiAgICBheGlzTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmF4aXNHcm91cCk7XG4gIH1cbiAgY2FsY3VsYXRlTGF5b3V0KCkge1xuICAgIGNvbnN0IGJveGVzID0gW107XG4gICAgY29uc3QgdGlja0RhdGEgPSB0aGlzLmdlbmVyYXRlVGlja3MoKTtcbiAgICBjb25zdCB7IHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0gPSB0aGlzO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24udXBkYXRlKFxuICAgICAgdGlja0RhdGEudGlja3MubWFwKChkKSA9PiB0aGlzLmNyZWF0ZUxhYmVsRGF0dW0oZCkpLFxuICAgICAgdm9pZCAwLFxuICAgICAgKGRhdHVtKSA9PiBkYXR1bS50aWNrSWRcbiAgICApO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0pID0+IHtcbiAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhkYXR1bSk7XG4gICAgICBpZiAoZGF0dW0udmlzaWJsZSkge1xuICAgICAgICBib3hlcy5wdXNoKG5vZGUuZ2V0QkJveCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmF4aXNHcm91cC5zZXRQcm9wZXJ0aWVzKHsgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSk7XG4gICAgcmV0dXJuIEJCb3gubWVyZ2UoYm94ZXMpO1xuICB9XG4gIGdldExhYmVsUGFyYW1zKGRhdHVtKSB7XG4gICAgY29uc3QgeyBwYWRkaW5nIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdHJhbnNsYXRlIH0gPSBkYXR1bTtcbiAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcbiAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB0cmFuc2xhdGUsXG4gICAgICAgICAgeTogcGFkZGluZyxcbiAgICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiBcInRvcFwiXG4gICAgICAgIH07XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogcGFkZGluZyxcbiAgICAgICAgICB5OiB0cmFuc2xhdGUsXG4gICAgICAgICAgdGV4dEFsaWduOiBcInN0YXJ0XCIsXG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiBcIm1pZGRsZVwiXG4gICAgICAgIH07XG4gICAgfVxuICB9XG4gIGluUmFuZ2UoeCwgdG9sZXJhbmNlID0gMWUtMykge1xuICAgIGNvbnN0IFttaW4sIG1heF0gPSBmaW5kTWluTWF4KHRoaXMuc2NhbGUucmFuZ2UpO1xuICAgIHJldHVybiB4ID49IG1pbiAtIHRvbGVyYW5jZSAmJiB4IDw9IG1heCArIHRvbGVyYW5jZTtcbiAgfVxuICBjcmVhdGVMYWJlbERhdHVtKGRhdHVtKSB7XG4gICAgY29uc3QgeyB4LCB5LCB0ZXh0QmFzZWxpbmUsIHRleHRBbGlnbiB9ID0gdGhpcy5nZXRMYWJlbFBhcmFtcyhkYXR1bSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZpc2libGU6IEJvb2xlYW4oZGF0dW0udGlja0xhYmVsKSxcbiAgICAgIHRpY2tJZDogZGF0dW0udGlja0lkLFxuICAgICAgZmlsbDogdGhpcy5sYWJlbC5jb2xvcixcbiAgICAgIGZvbnRGYW1pbHk6IHRoaXMubGFiZWwuZm9udEZhbWlseSxcbiAgICAgIGZvbnRTaXplOiB0aGlzLmxhYmVsLmZvbnRTaXplLFxuICAgICAgZm9udFN0eWxlOiB0aGlzLmxhYmVsLmZvbnRTdHlsZSxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoaXMubGFiZWwuZm9udFdlaWdodCxcbiAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgcm90YXRpb25DZW50ZXJYOiAwLFxuICAgICAgdGV4dDogZGF0dW0udGlja0xhYmVsLFxuICAgICAgdGV4dEFsaWduLFxuICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG4gIGdlbmVyYXRlVGlja3MoKSB7XG4gICAgY29uc3QgeyBtaW5TcGFjaW5nLCBtYXhTcGFjaW5nIH0gPSB0aGlzLmludGVydmFsO1xuICAgIGNvbnN0IHsgbWF4VGlja0NvdW50LCBtaW5UaWNrQ291bnQsIHRpY2tDb3VudCB9ID0gZXN0aW1hdGVUaWNrQ291bnQoXG4gICAgICBmaW5kUmFuZ2VFeHRlbnQodGhpcy5zY2FsZS5yYW5nZSksXG4gICAgICAxLFxuICAgICAgbWluU3BhY2luZyxcbiAgICAgIG1heFNwYWNpbmcsXG4gICAgICBfQXhpc1RpY2tzLkRlZmF1bHRUaWNrQ291bnQsXG4gICAgICBfQXhpc1RpY2tzLkRlZmF1bHRNaW5TcGFjaW5nXG4gICAgKTtcbiAgICBjb25zdCB0aWNrRGF0YSA9IHRoaXMuZ2V0VGlja3NEYXRhKHtcbiAgICAgIG5pY2U6IHRydWUsXG4gICAgICBpbnRlcnZhbDogdGhpcy5pbnRlcnZhbC5zdGVwLFxuICAgICAgdGlja0NvdW50LFxuICAgICAgbWluVGlja0NvdW50LFxuICAgICAgbWF4VGlja0NvdW50XG4gICAgfSk7XG4gICAgaWYgKHRoaXMucG9zaXRpb24gPT09IFwiYm90dG9tXCIgfHwgdGhpcy5wb3NpdGlvbiA9PT0gXCJ0b3BcIikge1xuICAgICAgY29uc3QgbWVhc3VyZXIyID0gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5nZXRNZWFzdXJlcih7IGZvbnQ6IHRoaXMubGFiZWwgfSk7XG4gICAgICBjb25zdCB7IGRvbWFpbiB9ID0gdGhpcy5zY2FsZTtcbiAgICAgIGNvbnN0IHJldmVyc2VkID0gZG9tYWluWzBdID4gZG9tYWluWzFdO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gcmV2ZXJzZWQgPyAtMSA6IDE7XG4gICAgICBsZXQgbGFzdFRpY2tQb3NpdGlvbiA9IC1JbmZpbml0eSAqIGRpcmVjdGlvbjtcbiAgICAgIHRpY2tEYXRhLnRpY2tzID0gdGlja0RhdGEudGlja3MuZmlsdGVyKChkYXRhKSA9PiB7XG4gICAgICAgIGlmIChNYXRoLnNpZ24oZGF0YS50cmFuc2xhdGUgLSBsYXN0VGlja1Bvc2l0aW9uKSAhPT0gZGlyZWN0aW9uKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGFzdFRpY2tQb3NpdGlvbiA9IGRhdGEudHJhbnNsYXRlICsgbWVhc3VyZXIyLnRleHRXaWR0aChkYXRhLnRpY2tMYWJlbCwgdHJ1ZSkgKiBkaXJlY3Rpb247XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrRGF0YTtcbiAgfVxuICBnZXRUaWNrc0RhdGEodGlja1BhcmFtcykge1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgY29uc3QgbmljZURvbWFpbiA9IHRpY2tQYXJhbXMubmljZSA/IHRoaXMuc2NhbGUubmljZURvbWFpbih0aWNrUGFyYW1zKSA6IHRoaXMuc2NhbGUuZG9tYWluO1xuICAgIGNvbnN0IHJhd1RpY2tzID0gdGhpcy5zY2FsZS50aWNrcyh0aWNrUGFyYW1zLCBuaWNlRG9tYWluKTtcbiAgICBjb25zdCBmcmFjdGlvbkRpZ2l0cyA9IHJhd1RpY2tzLnJlZHVjZSgobWF4LCB0aWNrKSA9PiBNYXRoLm1heChtYXgsIGNvdW50RnJhY3Rpb25EaWdpdHModGljaykpLCAwKTtcbiAgICBjb25zdCBpZEdlbmVyYXRvciA9IGNyZWF0ZUlkc0dlbmVyYXRvcigpO1xuICAgIGNvbnN0IGxhYmVsRm9ybWF0dGVyID0gdGhpcy5sYWJlbC5mb3JtYXQgPyB0aGlzLnNjYWxlLnRpY2tGb3JtYXR0ZXIoe1xuICAgICAgZG9tYWluOiBuaWNlRG9tYWluLFxuICAgICAgdGlja3M6IHJhd1RpY2tzLFxuICAgICAgZnJhY3Rpb25EaWdpdHMsXG4gICAgICBzcGVjaWZpZXI6IHRoaXMubGFiZWwuZm9ybWF0XG4gICAgfSkgOiAoeCkgPT4gZm9ybWF0VmFsdWUoeCwgZnJhY3Rpb25EaWdpdHMpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByYXdUaWNrcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHRpY2sgPSByYXdUaWNrc1tpbmRleF07XG4gICAgICBjb25zdCB0cmFuc2xhdGUgPSB0aGlzLnNjYWxlLmNvbnZlcnQodGljayk7XG4gICAgICBpZiAoIXRoaXMuaW5SYW5nZSh0cmFuc2xhdGUpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHRpY2tMYWJlbCA9IHRoaXMubGFiZWwuZm9ybWF0dGVyPy4oeyB2YWx1ZTogdGljaywgaW5kZXgsIGZyYWN0aW9uRGlnaXRzIH0pID8/IGxhYmVsRm9ybWF0dGVyKHRpY2spO1xuICAgICAgY29uc3QgdGlja0lkID0gaWRHZW5lcmF0b3IodGlja0xhYmVsKTtcbiAgICAgIHRpY2tzLnB1c2goeyB0aWNrLCB0aWNrSWQsIHRpY2tMYWJlbCwgdHJhbnNsYXRlIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyByYXdUaWNrcywgZnJhY3Rpb25EaWdpdHMsIHRpY2tzIH07XG4gIH1cbn07XG5fQXhpc1RpY2tzLkRlZmF1bHRUaWNrQ291bnQgPSA1O1xuX0F4aXNUaWNrcy5EZWZhdWx0TWluU3BhY2luZyA9IDEwO1xudmFyIEF4aXNUaWNrcyA9IF9BeGlzVGlja3M7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2RvbS9lbGVtZW50cy50c1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uKG9wdGlvbnMsIGF0dHJzKSB7XG4gIGNvbnN0IGJ1dHRvbiA9IGNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgZ2V0Q2xhc3NOYW1lKFwiYWctY2hhcnRzLWlucHV0IGFnLWNoYXJ0cy1idXR0b25cIiwgYXR0cnMpKTtcbiAgaWYgKG9wdGlvbnMubGFiZWwgIT09IHZvaWQgMCkge1xuICAgIGJ1dHRvbi5hcHBlbmQob3B0aW9ucy5sYWJlbCk7XG4gIH0gZWxzZSB7XG4gICAgYnV0dG9uLmFwcGVuZChjcmVhdGVJY29uKG9wdGlvbnMuaWNvbikpO1xuICAgIGJ1dHRvbi5hcmlhTGFiZWwgPSBvcHRpb25zLmFsdFRleHQ7XG4gIH1cbiAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBvcHRpb25zLm9uUHJlc3MpO1xuICBzZXRBdHRyaWJ1dGVzKGJ1dHRvbiwgYXR0cnMpO1xuICByZXR1cm4gYnV0dG9uO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2hlY2tib3gob3B0aW9ucywgYXR0cnMpIHtcbiAgY29uc3QgY2hlY2tib3ggPSBjcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgZ2V0Q2xhc3NOYW1lKFwiYWctY2hhcnRzLWlucHV0IGFnLWNoYXJ0cy1jaGVja2JveFwiLCBhdHRycykpO1xuICBjaGVja2JveC50eXBlID0gXCJjaGVja2JveFwiO1xuICBjaGVja2JveC5jaGVja2VkID0gb3B0aW9ucy5jaGVja2VkO1xuICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChldmVudCkgPT4gb3B0aW9ucy5vbkNoYW5nZShjaGVja2JveC5jaGVja2VkLCBldmVudCkpO1xuICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoaXNCdXR0b25DbGlja0V2ZW50KGV2ZW50KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNoZWNrYm94LmNsaWNrKCk7XG4gICAgfVxuICB9KTtcbiAgc2V0QXR0cmlidXRlcyhjaGVja2JveCwgYXR0cnMpO1xuICByZXR1cm4gY2hlY2tib3g7XG59XG5mdW5jdGlvbiBjcmVhdGVTZWxlY3Qob3B0aW9ucywgYXR0cnMpIHtcbiAgY29uc3Qgc2VsZWN0ID0gY3JlYXRlRWxlbWVudChcInNlbGVjdFwiLCBnZXRDbGFzc05hbWUoXCJhZy1jaGFydHMtaW5wdXQgYWctY2hhcnRzLXNlbGVjdFwiLCBhdHRycykpO1xuICBzZWxlY3QuYXBwZW5kKFxuICAgIC4uLm9wdGlvbnMub3B0aW9ucy5tYXAoKG9wdGlvbikgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9uRWwgPSBjcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgb3B0aW9uRWwudmFsdWUgPSBvcHRpb24udmFsdWU7XG4gICAgICBvcHRpb25FbC50ZXh0Q29udGVudCA9IG9wdGlvbi5sYWJlbDtcbiAgICAgIHJldHVybiBvcHRpb25FbDtcbiAgICB9KVxuICApO1xuICBzZXRBdHRyaWJ1dGUoc2VsZWN0LCBcImRhdGEtcHJldmVudGRlZmF1bHRcIiwgZmFsc2UpO1xuICBzZWxlY3QudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICBzZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZXZlbnQpID0+IG9wdGlvbnMub25DaGFuZ2Uoc2VsZWN0LnZhbHVlLCBldmVudCkpO1xuICBzZXRBdHRyaWJ1dGVzKHNlbGVjdCwgYXR0cnMpO1xuICByZXR1cm4gc2VsZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dEFyZWEob3B0aW9ucywgYXR0cnMpIHtcbiAgY29uc3QgdGV4dEFyZWEgPSBjcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIiwgZ2V0Q2xhc3NOYW1lKFwiYWctY2hhcnRzLWlucHV0IGFnLWNoYXJ0cy10ZXh0YXJlYVwiLCBhdHRycykpO1xuICB0ZXh0QXJlYS52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gIHRleHRBcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoZXZlbnQpID0+IG9wdGlvbnMub25DaGFuZ2UodGV4dEFyZWEudmFsdWUsIGV2ZW50KSk7XG4gIHNldEF0dHJpYnV0ZXModGV4dEFyZWEsIGF0dHJzKTtcbiAgc2V0QXR0cmlidXRlKHRleHRBcmVhLCBcImRhdGEtcHJldmVudGRlZmF1bHRcIiwgZmFsc2UpO1xuICByZXR1cm4gdGV4dEFyZWE7XG59XG5mdW5jdGlvbiBjcmVhdGVJY29uKGljb24pIHtcbiAgY29uc3QgZWwgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBgYWctY2hhcnRzLWljb24gYWctY2hhcnRzLWljb24tJHtpY29ufWApO1xuICBzZXRBdHRyaWJ1dGUoZWwsIFwiYXJpYS1oaWRkZW5cIiwgdHJ1ZSk7XG4gIHJldHVybiBlbDtcbn1cbmZ1bmN0aW9uIGdldENsYXNzTmFtZShiYXNlQ2xhc3MsIGF0dHJzKSB7XG4gIGlmIChhdHRycyA9PSBudWxsKVxuICAgIHJldHVybiBiYXNlQ2xhc3M7XG4gIHJldHVybiBgJHtiYXNlQ2xhc3N9ICR7YXR0cnMuY2xhc3N9YDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvZ3JhZGllbnQvY29uaWNHcmFkaWVudC50c1xudmFyIENvbmljR3JhZGllbnQgPSBjbGFzcyBleHRlbmRzIEdyYWRpZW50IHtcbiAgY29uc3RydWN0b3IoY29sb3JTcGFjZSwgc3RvcHMsIGFuZ2xlMiA9IDAsIGJib3gpIHtcbiAgICBzdXBlcihjb2xvclNwYWNlLCBzdG9wcywgYmJveCk7XG4gICAgdGhpcy5hbmdsZSA9IGFuZ2xlMjtcbiAgfVxuICBjcmVhdGVDYW52YXNHcmFkaWVudChjdHgsIGJib3gpIHtcbiAgICBjb25zdCBhbmdsZU9mZnNldCA9IDkwO1xuICAgIGNvbnN0IHsgYW5nbGU6IGFuZ2xlMiB9ID0gdGhpcztcbiAgICBjb25zdCByYWRpYW5zID0gbm9ybWFsaXplQW5nbGUzNjAodG9SYWRpYW5zKGFuZ2xlMiArIGFuZ2xlT2Zmc2V0KSk7XG4gICAgY29uc3QgY3ggPSBiYm94LnggKyBiYm94LndpZHRoICogMC41O1xuICAgIGNvbnN0IGN5ID0gYmJveC55ICsgYmJveC5oZWlnaHQgKiAwLjU7XG4gICAgcmV0dXJuIGN0eC5jcmVhdGVDb25pY0dyYWRpZW50KHJhZGlhbnMsIGN4LCBjeSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL3N2Z1BhdGgudHNcbnZhciBTdmdQYXRoID0gY2xhc3MgZXh0ZW5kcyBQYXRoIHtcbiAgY29uc3RydWN0b3IoZCA9IFwiXCIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLmNvbW1hbmRzID0gW107XG4gICAgdGhpcy5fZCA9IFwiXCI7XG4gICAgdGhpcy5kID0gZDtcbiAgfVxuICBnZXQgZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZDtcbiAgfVxuICBzZXQgZChkKSB7XG4gICAgaWYgKGQgPT09IHRoaXMuX2QpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fZCA9IGQ7XG4gICAgdGhpcy5jb21tYW5kcy5sZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgW18sIGNvbW1hbmQsIHBhcmFtc1N0cmluZ10gb2YgZC5tYXRjaEFsbCgvKFtBLVpdKShbMC05LiBdKikvZykpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHBhcmFtc1N0cmluZy5zcGxpdCgvXFxzKy9nKS5tYXAoTnVtYmVyKTtcbiAgICAgIHRoaXMuY29tbWFuZHMucHVzaChbY29tbWFuZCwgcGFyYW1zXSk7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tQYXRoRGlydHkoKTtcbiAgfVxuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHsgcGF0aCwgeCwgeSB9ID0gdGhpcztcbiAgICBwYXRoLmNsZWFyKCk7XG4gICAgbGV0IGxhc3RYID0geDtcbiAgICBsZXQgbGFzdFkgPSB5O1xuICAgIGZvciAoY29uc3QgW2NvbW1hbmQsIHBhcmFtc10gb2YgdGhpcy5jb21tYW5kcykge1xuICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgcGF0aC5tb3ZlVG8oeCArIHBhcmFtc1swXSwgeSArIHBhcmFtc1sxXSk7XG4gICAgICAgICAgbGFzdFggPSB4ICsgcGFyYW1zWzBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ1wiOlxuICAgICAgICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgICAgICAgeCArIHBhcmFtc1swXSxcbiAgICAgICAgICAgIHkgKyBwYXJhbXNbMV0sXG4gICAgICAgICAgICB4ICsgcGFyYW1zWzJdLFxuICAgICAgICAgICAgeSArIHBhcmFtc1szXSxcbiAgICAgICAgICAgIHggKyBwYXJhbXNbNF0sXG4gICAgICAgICAgICB5ICsgcGFyYW1zWzVdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsYXN0WCA9IHggKyBwYXJhbXNbNF07XG4gICAgICAgICAgbGFzdFkgPSB5ICsgcGFyYW1zWzVdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgIHBhdGgubGluZVRvKHggKyBwYXJhbXNbMF0sIGxhc3RZKTtcbiAgICAgICAgICBsYXN0WCA9IHkgKyBwYXJhbXNbMF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgcGF0aC5saW5lVG8oeCArIHBhcmFtc1swXSwgeSArIHBhcmFtc1sxXSk7XG4gICAgICAgICAgbGFzdFggPSB4ICsgcGFyYW1zWzBdO1xuICAgICAgICAgIGxhc3RZID0geSArIHBhcmFtc1sxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlZcIjpcbiAgICAgICAgICBwYXRoLmxpbmVUbyhsYXN0WCwgeSArIHBhcmFtc1swXSk7XG4gICAgICAgICAgbGFzdFkgPSB5ICsgcGFyYW1zWzBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgdHJhbnNsYXRlIGNvbW1hbmQgJyR7Y29tbWFuZH0nIHdpdGggJyR7cGFyYW1zLmpvaW4oXCIgXCIpfSdgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTdmdQYXRoLnByb3RvdHlwZSwgXCJ4XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFN2Z1BhdGgucHJvdG90eXBlLCBcInlcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2ltYWdlLnRzXG52YXIgSW1hZ2UgPSBjbGFzcyBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2VJbWFnZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zb3VyY2VJbWFnZSA9IHNvdXJjZUltYWdlO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHJlbmRlckN0eDtcbiAgICBjb25zdCBpbWFnZSA9IHRoaXMuc291cmNlSW1hZ2U7XG4gICAgaWYgKGltYWdlKSB7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLm9wYWNpdHk7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCB0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEltYWdlLnByb3RvdHlwZSwgXCJ4XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgSW1hZ2UucHJvdG90eXBlLCBcInlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBJbWFnZS5wcm90b3R5cGUsIFwid2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbigpXG5dLCBJbWFnZS5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgSW1hZ2UucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3dpZGdldC9leHBvcnRzLnRzXG52YXIgZXhwb3J0c19leHBvcnRzID0ge307XG5fX2V4cG9ydChleHBvcnRzX2V4cG9ydHMsIHtcbiAgQnV0dG9uV2lkZ2V0OiAoKSA9PiBCdXR0b25XaWRnZXQsXG4gIE5hdGl2ZVdpZGdldDogKCkgPT4gTmF0aXZlV2lkZ2V0LFxuICBTbGlkZXJXaWRnZXQ6ICgpID0+IFNsaWRlcldpZGdldCxcbiAgVG9vbGJhcldpZGdldDogKCkgPT4gVG9vbGJhcldpZGdldCxcbiAgV0lER0VUX0hUTUxfRVZFTlRTOiAoKSA9PiBXSURHRVRfSFRNTF9FVkVOVFMsXG4gIFdpZGdldDogKCkgPT4gV2lkZ2V0LFxuICBXaWRnZXRFdmVudFV0aWw6ICgpID0+IFdpZGdldEV2ZW50VXRpbFxufSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NvbXBvbmVudHMvcG9wb3Zlci9wb3BvdmVyLnRzXG52YXIgY2FudmFzT3ZlcmxheSA9IFwiY2FudmFzLW92ZXJsYXlcIjtcbnZhciBQb3BvdmVyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTW9kdWxlSW5zdGFuY2Uge1xuICBjb25zdHJ1Y3RvcihjdHgsIGlkLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmhpZGVGbnMgPSBbXTtcbiAgICB0aGlzLm1vZHVsZUlkID0gYHBvcG92ZXItJHtpZH1gO1xuICAgIGlmIChvcHRpb25zPy5kZXRhY2hlZCkge1xuICAgICAgdGhpcy5lbGVtZW50ID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbGVtZW50ID0gY3R4LmRvbU1hbmFnZXIuYWRkQ2hpbGQoY2FudmFzT3ZlcmxheSwgdGhpcy5tb2R1bGVJZCk7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKCgpID0+IGN0eC5kb21NYW5hZ2VyLnJlbW92ZUNoaWxkKGNhbnZhc092ZXJsYXksIHRoaXMubW9kdWxlSWQpKTtcbiAgfVxuICBhdHRhY2hUbyhwb3BvdmVyKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIHBvcG92ZXIuZWxlbWVudC5hcHBlbmQodGhpcy5lbGVtZW50KTtcbiAgfVxuICBoaWRlKG9wdHMpIHtcbiAgICBjb25zdCB7IGxhc3RGb2N1cyA9IHRoaXMubGFzdEZvY3VzIH0gPSBvcHRzID8/IHt9O1xuICAgIGlmICh0aGlzLmVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaGlkZUZucy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gICAgbGFzdEZvY3VzPy5mb2N1cygpO1xuICAgIHRoaXMubGFzdEZvY3VzID0gdm9pZCAwO1xuICB9XG4gIHJlbW92ZUNoaWxkcmVuKCkge1xuICAgIHRoaXMuZWxlbWVudC5yZXBsYWNlQ2hpbGRyZW4oKTtcbiAgfVxuICBzaG93V2l0aENoaWxkcmVuKGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBzaG93IHBvcG92ZXIgdGhhdCBoYXMgbm90IGJlZW4gYXR0YWNoZWQgdG8gYSBwYXJlbnQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBwb3BvdmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImFnLWNoYXJ0cy1wb3BvdmVyXCIpO1xuICAgIGlmIChvcHRpb25zLmFyaWFMYWJlbCAhPSBudWxsKSB7XG4gICAgICBwb3BvdmVyLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgb3B0aW9ucy5hcmlhTGFiZWwpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jbGFzcyAhPSBudWxsKSB7XG4gICAgICBwb3BvdmVyLmNsYXNzTGlzdC5hZGQob3B0aW9ucy5jbGFzcyk7XG4gICAgfVxuICAgIHBvcG92ZXIucmVwbGFjZUNoaWxkcmVuKC4uLmNoaWxkcmVuKTtcbiAgICB0aGlzLmVsZW1lbnQucmVwbGFjZUNoaWxkcmVuKHBvcG92ZXIpO1xuICAgIHRoaXMuaGlkZUZucy5wdXNoKCgpID0+IHRoaXMucmVtb3ZlQ2hpbGRyZW4oKSk7XG4gICAgaWYgKG9wdGlvbnMub25IaWRlKSB7XG4gICAgICB0aGlzLmhpZGVGbnMucHVzaChvcHRpb25zLm9uSGlkZSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmluaXRpYWxGb2N1cyAmJiBvcHRpb25zLnNvdXJjZUV2ZW50KSB7XG4gICAgICBjb25zdCBsYXN0Rm9jdXMgPSBnZXRMYXN0Rm9jdXMob3B0aW9ucy5zb3VyY2VFdmVudCk7XG4gICAgICBpZiAobGFzdEZvY3VzICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5sYXN0Rm9jdXMgPSBsYXN0Rm9jdXM7XG4gICAgICAgIHRoaXMuaW5pdGlhbEZvY3VzID0gb3B0aW9ucy5pbml0aWFsRm9jdXM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwb3BvdmVyO1xuICB9XG4gIGdldFBvcG92ZXJFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gIH1cbiAgdXBkYXRlUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICBjb25zdCBwb3BvdmVyID0gdGhpcy5nZXRQb3BvdmVyRWxlbWVudCgpO1xuICAgIGlmICghcG9wb3ZlcilcbiAgICAgIHJldHVybjtcbiAgICBwb3BvdmVyLnN0eWxlLnNldFByb3BlcnR5KFwicmlnaHRcIiwgXCJ1bnNldFwiKTtcbiAgICBwb3BvdmVyLnN0eWxlLnNldFByb3BlcnR5KFwiYm90dG9tXCIsIFwidW5zZXRcIik7XG4gICAgaWYgKHBvc2l0aW9uLnggIT0gbnVsbClcbiAgICAgIHBvcG92ZXIuc3R5bGUuc2V0UHJvcGVydHkoXCJsZWZ0XCIsIGAke01hdGguZmxvb3IocG9zaXRpb24ueCl9cHhgKTtcbiAgICBpZiAocG9zaXRpb24ueSAhPSBudWxsKVxuICAgICAgcG9wb3Zlci5zdHlsZS5zZXRQcm9wZXJ0eShcInRvcFwiLCBgJHtNYXRoLmZsb29yKHBvc2l0aW9uLnkpfXB4YCk7XG4gICAgdGhpcy5pbml0aWFsRm9jdXM/LmZvY3VzKCk7XG4gICAgdGhpcy5pbml0aWFsRm9jdXMgPSB2b2lkIDA7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NvbXBvbmVudHMvcG9wb3Zlci9hbmNob3JlZFBvcG92ZXIudHNcbnZhciBBbmNob3JlZFBvcG92ZXIgPSBjbGFzcyBleHRlbmRzIFBvcG92ZXIge1xuICBzZXRBbmNob3IoYW5jaG9yLCBmYWxsYmFja0FuY2hvcikge1xuICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIHRoaXMuZmFsbGJhY2tBbmNob3IgPSBmYWxsYmFja0FuY2hvcjtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKGFuY2hvcik7XG4gICAgdGhpcy5yZXBvc2l0aW9uV2l0aGluQm91bmRzKCk7XG4gIH1cbiAgc2hvd1dpdGhDaGlsZHJlbihjaGlsZHJlbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGFuY2hvciA9IG9wdGlvbnMuYW5jaG9yID8/IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZhbGxiYWNrQW5jaG9yID0gb3B0aW9ucy5mYWxsYmFja0FuY2hvciA/PyB0aGlzLmZhbGxiYWNrQW5jaG9yO1xuICAgIGNvbnN0IHBvcG92ZXIgPSBzdXBlci5zaG93V2l0aENoaWxkcmVuKGNoaWxkcmVuLCBvcHRpb25zKTtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICB0aGlzLnNldEFuY2hvcihhbmNob3IsIGZhbGxiYWNrQW5jaG9yKTtcbiAgICB9XG4gICAgZ2V0V2luZG93KCkucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMucmVwb3NpdGlvbldpdGhpbkJvdW5kcygpO1xuICAgIH0pO1xuICAgIHJldHVybiBwb3BvdmVyO1xuICB9XG4gIHJlcG9zaXRpb25XaXRoaW5Cb3VuZHMoKSB7XG4gICAgY29uc3QgeyBhbmNob3IsIGN0eCwgZmFsbGJhY2tBbmNob3IgfSA9IHRoaXM7XG4gICAgY29uc3QgcG9wb3ZlciA9IHRoaXMuZ2V0UG9wb3ZlckVsZW1lbnQoKTtcbiAgICBpZiAoIWFuY2hvciB8fCAhcG9wb3ZlcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBjYW52YXNSZWN0ID0gY3R4LmRvbU1hbmFnZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgeyBvZmZzZXRXaWR0aDogd2lkdGgyLCBvZmZzZXRIZWlnaHQ6IGhlaWdodDIgfSA9IHBvcG92ZXI7XG4gICAgbGV0IHggPSBjbGFtcCgwLCBhbmNob3IueCwgY2FudmFzUmVjdC53aWR0aCAtIHdpZHRoMik7XG4gICAgbGV0IHkgPSBjbGFtcCgwLCBhbmNob3IueSwgY2FudmFzUmVjdC5oZWlnaHQgLSBoZWlnaHQyKTtcbiAgICBpZiAoeCAhPT0gYW5jaG9yLnggJiYgZmFsbGJhY2tBbmNob3I/LnggIT0gbnVsbCkge1xuICAgICAgeCA9IGNsYW1wKDAsIGZhbGxiYWNrQW5jaG9yLnggLSB3aWR0aDIsIGNhbnZhc1JlY3Qud2lkdGggLSB3aWR0aDIpO1xuICAgIH1cbiAgICBpZiAoeSAhPT0gYW5jaG9yLnkgJiYgZmFsbGJhY2tBbmNob3I/LnkgIT0gbnVsbCkge1xuICAgICAgeSA9IGNsYW1wKDAsIGZhbGxiYWNrQW5jaG9yLnkgLSBoZWlnaHQyLCBjYW52YXNSZWN0LmhlaWdodCAtIGhlaWdodDIpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKHsgeCwgeSB9KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY29tcG9uZW50cy9tZW51L21lbnUudHNcbnZhciBNZW51ID0gY2xhc3MgZXh0ZW5kcyBBbmNob3JlZFBvcG92ZXIge1xuICBzaG93KG9wdGlvbnMpIHtcbiAgICBjb25zdCByb3dzID0gb3B0aW9ucy5pdGVtcy5tYXAoKGl0ZW0pID0+IHRoaXMuY3JlYXRlUm93KG9wdGlvbnMsIGl0ZW0pKTtcbiAgICBjb25zdCBwb3BvdmVyID0gdGhpcy5zaG93V2l0aENoaWxkcmVuKHJvd3MsIG9wdGlvbnMpO1xuICAgIHBvcG92ZXIuY2xhc3NMaXN0LmFkZChcImFnLWNoYXJ0cy1tZW51XCIpO1xuICAgIHBvcG92ZXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm1lbnVcIik7XG4gICAgdGhpcy5tZW51Q2xvc2VyID0gaW5pdE1lbnVLZXlOYXYoe1xuICAgICAgb3JpZW50YXRpb246IFwidmVydGljYWxcIixcbiAgICAgIG1lbnU6IHBvcG92ZXIsXG4gICAgICBidXR0b25zOiByb3dzLFxuICAgICAgc291cmNlRXZlbnQ6IG9wdGlvbnMuc291cmNlRXZlbnQsXG4gICAgICBjbG9zZUNhbGxiYWNrOiAoKSA9PiB0aGlzLmhpZGUoKVxuICAgIH0pO1xuICAgIHRoaXMuaGlkZUZucy5wdXNoKCgpID0+IHtcbiAgICAgIHRoaXMubWVudUNsb3Nlcj8uZmluaXNoQ2xvc2luZygpO1xuICAgICAgdGhpcy5tZW51Q2xvc2VyID0gdm9pZCAwO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVJvdyhvcHRpb25zLCBpdGVtKSB7XG4gICAgY29uc3QgeyBtZW51SXRlbVJvbGUgPSBcIm1lbnVpdGVtXCIgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYWN0aXZlID0gaXRlbS52YWx1ZSA9PT0gb3B0aW9ucy52YWx1ZTtcbiAgICBjb25zdCByb3cgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiYWctY2hhcnRzLW1lbnVfX3Jvd1wiKTtcbiAgICByb3cuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBtZW51SXRlbVJvbGUpO1xuICAgIGlmIChtZW51SXRlbVJvbGUgPT09IFwibWVudWl0ZW1yYWRpb1wiKSB7XG4gICAgICByb3cuc2V0QXR0cmlidXRlKFwiYXJpYS1jaGVja2VkXCIsIChvcHRpb25zLnZhbHVlID09PSBpdGVtLnZhbHVlKS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpdGVtLnZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByb3cuZGF0YXNldC5wb3BvdmVySWQgPSBpdGVtLnZhbHVlO1xuICAgIH1cbiAgICByb3cuY2xhc3NMaXN0LnRvZ2dsZShgYWctY2hhcnRzLW1lbnVfX3Jvdy0tYWN0aXZlYCwgYWN0aXZlKTtcbiAgICBpZiAoaXRlbS5pY29uICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGljb24gPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBgYWctY2hhcnRzLW1lbnVfX2ljb24gJHtnZXRJY29uQ2xhc3NOYW1lcyhpdGVtLmljb24pfWApO1xuICAgICAgcm93LmFwcGVuZENoaWxkKGljb24pO1xuICAgIH1cbiAgICBjb25zdCBzdHJva2VXaWR0aFZpc2libGUgPSBpdGVtLnN0cm9rZVdpZHRoICE9IG51bGw7XG4gICAgaWYgKHN0cm9rZVdpZHRoVmlzaWJsZSkge1xuICAgICAgcm93LmNsYXNzTGlzdC50b2dnbGUoYGFnLWNoYXJ0cy1tZW51X19yb3ctLXN0cm9rZS13aWR0aC12aXNpYmxlYCwgc3Ryb2tlV2lkdGhWaXNpYmxlKTtcbiAgICAgIHJvdy5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tc3Ryb2tlV2lkdGhcIiwgc3Ryb2tlV2lkdGhWaXNpYmxlID8gYCR7aXRlbS5zdHJva2VXaWR0aH1weGAgOiBudWxsKTtcbiAgICB9XG4gICAgaWYgKGl0ZW0ubGFiZWwgIT0gbnVsbCkge1xuICAgICAgY29uc3QgbGFiZWwgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImFnLWNoYXJ0cy1tZW51X19sYWJlbFwiKTtcbiAgICAgIGxhYmVsLnRleHRDb250ZW50ID0gdGhpcy5jdHgubG9jYWxlTWFuYWdlci50KGl0ZW0ubGFiZWwpO1xuICAgICAgcm93LmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICB9XG4gICAgaWYgKFwiYWx0VGV4dFwiIGluIGl0ZW0pIHtcbiAgICAgIHJvdy5hcmlhTGFiZWwgPSB0aGlzLmN0eC5sb2NhbGVNYW5hZ2VyLnQoaXRlbS5hbHRUZXh0KTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ID0gKCkgPT4ge1xuICAgICAgb3B0aW9ucy5vblByZXNzPy4oaXRlbSk7XG4gICAgfTtcbiAgICBjb25zdCBvbmNsaWNrID0gKGUpID0+IHtcbiAgICAgIGlmIChpc0J1dHRvbkNsaWNrRXZlbnQoZSkpIHtcbiAgICAgICAgc2VsZWN0KCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbmNsaWNrKTtcbiAgICByb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uY2xpY2spO1xuICAgIHJvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsICgpID0+IHtcbiAgICAgIHJvdy5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvdztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY29tcG9uZW50cy9wb3BvdmVyL2RyYWdnYWJsZVBvcG92ZXIudHNcbnZhciBEcmFnZ2FibGVQb3BvdmVyID0gY2xhc3MgZXh0ZW5kcyBQb3BvdmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmRyYWdnZWQgPSBmYWxzZTtcbiAgfVxuICBzZXREcmFnSGFuZGxlKGRyYWdIYW5kbGUpIHtcbiAgICBkcmFnSGFuZGxlLmFkZExpc3RlbmVyKFwiZHJhZy1zdGFydFwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGRyYWdIYW5kbGUuYWRkQ2xhc3ModGhpcy5kcmFnSGFuZGxlRHJhZ2dpbmdDbGFzcyk7XG4gICAgICB0aGlzLm9uRHJhZ1N0YXJ0KGV2ZW50KTtcbiAgICB9KTtcbiAgICBkcmFnSGFuZGxlLmFkZExpc3RlbmVyKFwiZHJhZy1tb3ZlXCIsIHRoaXMub25EcmFnTW92ZS5iaW5kKHRoaXMpKTtcbiAgICBkcmFnSGFuZGxlLmFkZExpc3RlbmVyKFwiZHJhZy1lbmRcIiwgKCkgPT4ge1xuICAgICAgZHJhZ0hhbmRsZS5yZW1vdmVDbGFzcyh0aGlzLmRyYWdIYW5kbGVEcmFnZ2luZ0NsYXNzKTtcbiAgICAgIHRoaXMub25EcmFnRW5kLmJpbmQodGhpcyk7XG4gICAgfSk7XG4gIH1cbiAgb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICBjb25zdCBwb3BvdmVyID0gdGhpcy5nZXRQb3BvdmVyRWxlbWVudCgpO1xuICAgIGlmICghcG9wb3ZlcilcbiAgICAgIHJldHVybjtcbiAgICBldmVudC5zb3VyY2VFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuZHJhZ2dlZCA9IHRydWU7XG4gICAgdGhpcy5kcmFnU3RhcnRTdGF0ZSA9IHtcbiAgICAgIGNsaWVudDogVmVjMi5mcm9tKGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpLFxuICAgICAgcG9zaXRpb246IFZlYzIuZnJvbShcbiAgICAgICAgTnVtYmVyKHBvcG92ZXIuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcImxlZnRcIikucmVwbGFjZShcInB4XCIsIFwiXCIpKSxcbiAgICAgICAgTnVtYmVyKHBvcG92ZXIuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcInRvcFwiKS5yZXBsYWNlKFwicHhcIiwgXCJcIikpXG4gICAgICApXG4gICAgfTtcbiAgfVxuICBvbkRyYWdNb3ZlKGV2ZW50KSB7XG4gICAgY29uc3QgeyBkcmFnU3RhcnRTdGF0ZSB9ID0gdGhpcztcbiAgICBjb25zdCBwb3BvdmVyID0gdGhpcy5nZXRQb3BvdmVyRWxlbWVudCgpO1xuICAgIGlmICghZHJhZ1N0YXJ0U3RhdGUgfHwgIXBvcG92ZXIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgb2Zmc2V0NCA9IFZlYzIuc3ViKFZlYzIuZnJvbShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSwgZHJhZ1N0YXJ0U3RhdGUuY2xpZW50KTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IFZlYzIuYWRkKGRyYWdTdGFydFN0YXRlLnBvc2l0aW9uLCBvZmZzZXQ0KTtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLmN0eC5kb21NYW5hZ2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHBhcnRpYWxQb3NpdGlvbiA9IHt9O1xuICAgIGlmIChwb3NpdGlvbi54ID49IGJvdW5kcy54ICYmIHBvc2l0aW9uLnggKyBwb3BvdmVyLm9mZnNldFdpZHRoIDw9IGJvdW5kcy53aWR0aCkge1xuICAgICAgcGFydGlhbFBvc2l0aW9uLnggPSBwb3NpdGlvbi54O1xuICAgIH1cbiAgICBpZiAocG9zaXRpb24ueSA+PSBib3VuZHMueSAmJiBwb3NpdGlvbi55ICsgcG9wb3Zlci5vZmZzZXRIZWlnaHQgPD0gYm91bmRzLmhlaWdodCkge1xuICAgICAgcGFydGlhbFBvc2l0aW9uLnkgPSBwb3NpdGlvbi55O1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKHBhcnRpYWxQb3NpdGlvbik7XG4gIH1cbiAgb25EcmFnRW5kKCkge1xuICAgIHRoaXMuZHJhZ1N0YXJ0U3RhdGUgPSB2b2lkIDA7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NvbXBvbmVudHMvdG9vbGJhci90b29sYmFyQnV0dG9uUHJvcGVydGllcy50c1xudmFyIFRvb2xiYXJCdXR0b25Qcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUb29sYmFyQnV0dG9uUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaWNvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVG9vbGJhckJ1dHRvblByb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUb29sYmFyQnV0dG9uUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYXJpYUxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUb29sYmFyQnV0dG9uUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY29tcG9uZW50cy90b29sYmFyL3Rvb2xiYXJCdXR0b25XaWRnZXQudHNcbnZhciBUb29sYmFyQnV0dG9uV2lkZ2V0ID0gY2xhc3MgZXh0ZW5kcyBCdXR0b25XaWRnZXQge1xuICBjb25zdHJ1Y3Rvcihsb2NhbGVNYW5hZ2VyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmxvY2FsZU1hbmFnZXIgPSBsb2NhbGVNYW5hZ2VyO1xuICB9XG4gIHVwZGF0ZShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBsb2NhbGVNYW5hZ2VyIH0gPSB0aGlzO1xuICAgIGlmIChvcHRpb25zLnRvb2x0aXApIHtcbiAgICAgIHRoaXMuZWxlbS50aXRsZSA9IGxvY2FsZU1hbmFnZXIudChvcHRpb25zLnRvb2x0aXApO1xuICAgIH1cbiAgICBsZXQgaW5uZXJIVE1MID0gXCJcIjtcbiAgICBpZiAob3B0aW9ucy5pY29uICE9IG51bGwpIHtcbiAgICAgIGlubmVySFRNTCA9IGA8c3BhbiBjbGFzcz1cIiR7Z2V0SWNvbkNsYXNzTmFtZXMob3B0aW9ucy5pY29uKX0gYWctY2hhcnRzLXRvb2xiYXJfX2ljb25cIj48L3NwYW4+YDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGFiZWwgIT0gbnVsbCkge1xuICAgICAgY29uc3QgbGFiZWwgPSBsb2NhbGVNYW5hZ2VyLnQob3B0aW9ucy5sYWJlbCk7XG4gICAgICBpbm5lckhUTUwgPSBgJHtpbm5lckhUTUx9PHNwYW4gY2xhc3M9XCJhZy1jaGFydHMtdG9vbGJhcl9fbGFiZWxcIj4ke2xhYmVsfTwvc3Bhbj5gO1xuICAgIH1cbiAgICB0aGlzLmVsZW0uaW5uZXJIVE1MID0gaW5uZXJIVE1MO1xuICB9XG4gIHNldENoZWNrZWQoY2hlY2tlZCkge1xuICAgIHNldEF0dHJpYnV0ZSh0aGlzLmVsZW0sIFwiYXJpYS1jaGVja2VkXCIsIGNoZWNrZWQpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jb21wb25lbnRzL3Rvb2xiYXIvdG9vbGJhci50c1xudmFyIEJVVFRPTl9BQ1RJVkVfQ0xBU1MgPSBcImFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWFjdGl2ZVwiO1xudmFyIEJhc2VUb29sYmFyID0gY2xhc3MgZXh0ZW5kcyBUb29sYmFyV2lkZ2V0IHtcbiAgY29uc3RydWN0b3IobG9jYWxlTWFuYWdlciwgb3JpZW50YXRpb24gPSBcImhvcml6b250YWxcIikge1xuICAgIHN1cGVyKG9yaWVudGF0aW9uKTtcbiAgICB0aGlzLmxvY2FsZU1hbmFnZXIgPSBsb2NhbGVNYW5hZ2VyO1xuICAgIHRoaXMuaG9yaXpvbnRhbFNwYWNpbmcgPSAxMDtcbiAgICB0aGlzLnZlcnRpY2FsU3BhY2luZyA9IDEwO1xuICAgIHRoaXMuZXZlbnRzID0gbmV3IExpc3RlbmVycygpO1xuICAgIHRoaXMuaGFzUHJlZml4ID0gZmFsc2U7XG4gICAgdGhpcy5idXR0b25XaWRnZXRzID0gW107XG4gICAgdGhpcy5hZGRDbGFzcyhcImFnLWNoYXJ0cy10b29sYmFyXCIpO1xuICAgIHRoaXMudG9nZ2xlQ2xhc3MoXCJhZy1jaGFydHMtdG9vbGJhci0taG9yaXpvbnRhbFwiLCBvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpO1xuICAgIHRoaXMudG9nZ2xlQ2xhc3MoXCJhZy1jaGFydHMtdG9vbGJhci0tdmVydGljYWxcIiwgb3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIik7XG4gIH1cbiAgYWRkVG9vbGJhckxpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLmV2ZW50cy5hZGRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIpO1xuICB9XG4gIGNsZWFyQnV0dG9ucygpIHtcbiAgICBmb3IgKGNvbnN0IGJ1dHRvbiBvZiB0aGlzLmJ1dHRvbldpZGdldHMpIHtcbiAgICAgIGJ1dHRvbi5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuYnV0dG9uV2lkZ2V0cy5zcGxpY2UoMCk7XG4gIH1cbiAgdXBkYXRlQnV0dG9ucyhidXR0b25zKSB7XG4gICAgY29uc3QgeyBidXR0b25XaWRnZXRzIH0gPSB0aGlzO1xuICAgIGZvciAoY29uc3QgW2luZGV4LCBidXR0b25dIG9mIGJ1dHRvbnMuZW50cmllcygpKSB7XG4gICAgICBjb25zdCBidXR0b25XaWRnZXQgPSB0aGlzLmJ1dHRvbldpZGdldHMuYXQoaW5kZXgpID8/IHRoaXMuY3JlYXRlQnV0dG9uKGluZGV4LCBidXR0b24pO1xuICAgICAgYnV0dG9uV2lkZ2V0LnVwZGF0ZShidXR0b24pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpbmRleCA9IGJ1dHRvbnMubGVuZ3RoOyBpbmRleCA8IGJ1dHRvbldpZGdldHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBidXR0b24gPSB0aGlzLmJ1dHRvbldpZGdldHMuYXQoaW5kZXgpO1xuICAgICAgYnV0dG9uPy5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuYnV0dG9uV2lkZ2V0cy5zcGxpY2UoYnV0dG9ucy5sZW5ndGgpO1xuICAgIHRoaXMucmVmcmVzaEJ1dHRvbkNsYXNzZXMoKTtcbiAgfVxuICB1cGRhdGVCdXR0b25CeUluZGV4KGluZGV4LCBidXR0b24pIHtcbiAgICB0aGlzLmJ1dHRvbldpZGdldHMuYXQoaW5kZXgpPy51cGRhdGUoYnV0dG9uKTtcbiAgfVxuICBjbGVhckFjdGl2ZUJ1dHRvbigpIHtcbiAgICBmb3IgKGNvbnN0IGJ1dHRvbiBvZiB0aGlzLmJ1dHRvbldpZGdldHMpIHtcbiAgICAgIGJ1dHRvbi50b2dnbGVDbGFzcyhCVVRUT05fQUNUSVZFX0NMQVNTLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHRvZ2dsZUFjdGl2ZUJ1dHRvbkJ5SW5kZXgoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgW2J1dHRvbkluZGV4LCBidXR0b25dIG9mIHRoaXMuYnV0dG9uV2lkZ2V0cy5lbnRyaWVzKCkpIHtcbiAgICAgIGJ1dHRvbi50b2dnbGVDbGFzcyhCVVRUT05fQUNUSVZFX0NMQVNTLCBpbmRleCAhPSBudWxsICYmIGluZGV4ID09PSBidXR0b25JbmRleCk7XG4gICAgfVxuICB9XG4gIHRvZ2dsZUJ1dHRvbkVuYWJsZWRCeUluZGV4KGluZGV4LCBlbmFibGVkKSB7XG4gICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmJ1dHRvbldpZGdldHMuYXQoaW5kZXgpPy5zZXRFbmFibGVkKGVuYWJsZWQpO1xuICB9XG4gIHRvZ2dsZVN3aXRjaENoZWNrZWRCeUluZGV4KGluZGV4LCBjaGVja2VkKSB7XG4gICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmJ1dHRvbldpZGdldHMuYXQoaW5kZXgpPy5zZXRDaGVja2VkKGNoZWNrZWQpO1xuICB9XG4gIGdldEJ1dHRvbkJvdW5kcygpIHtcbiAgICByZXR1cm4gdGhpcy5idXR0b25XaWRnZXRzLm1hcCgoYnV0dG9uV2lkZ2V0KSA9PiB0aGlzLmdldEJ1dHRvbldpZGdldEJvdW5kcyhidXR0b25XaWRnZXQpKTtcbiAgfVxuICBzZXRCdXR0b25IaWRkZW5CeUluZGV4KGluZGV4LCBoaWRkZW4pIHtcbiAgICB0aGlzLmJ1dHRvbldpZGdldHMuYXQoaW5kZXgpPy5zZXRIaWRkZW4oaGlkZGVuKTtcbiAgfVxuICBnZXRCdXR0b25XaWRnZXRCb3VuZHMoYnV0dG9uV2lkZ2V0KSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICBjb25zdCBib3VuZHMgPSBidXR0b25XaWRnZXQuZ2V0Qm91bmRzKCk7XG4gICAgcmV0dXJuIG5ldyBCQm94KGJvdW5kcy54ICsgcGFyZW50LngsIGJvdW5kcy55ICsgcGFyZW50LnksIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XG4gIH1cbiAgcmVmcmVzaEJ1dHRvbkNsYXNzZXMoKSB7XG4gICAgY29uc3QgeyBidXR0b25XaWRnZXRzLCBoYXNQcmVmaXggfSA9IHRoaXM7XG4gICAgbGV0IGZpcnN0MjtcbiAgICBsZXQgbGFzdDtcbiAgICBsZXQgc2VjdGlvbjtcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgYnV0dG9uV2lkZ2V0XSBvZiBidXR0b25XaWRnZXRzLmVudHJpZXMoKSkge1xuICAgICAgZmlyc3QyID0gIWhhc1ByZWZpeCAmJiBpbmRleCA9PT0gMCB8fCBzZWN0aW9uICE9IGJ1dHRvbldpZGdldC5zZWN0aW9uO1xuICAgICAgbGFzdCA9IGluZGV4ID09PSBidXR0b25XaWRnZXRzLmxlbmd0aCAtIDEgfHwgYnV0dG9uV2lkZ2V0LnNlY3Rpb24gIT0gYnV0dG9uV2lkZ2V0cy5hdChpbmRleCArIDEpPy5zZWN0aW9uO1xuICAgICAgYnV0dG9uV2lkZ2V0LnRvZ2dsZUNsYXNzKFwiYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tZmlyc3RcIiwgZmlyc3QyKTtcbiAgICAgIGJ1dHRvbldpZGdldC50b2dnbGVDbGFzcyhcImFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWxhc3RcIiwgbGFzdCk7XG4gICAgICBidXR0b25XaWRnZXQudG9nZ2xlQ2xhc3MoXCJhZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1nYXBcIiwgaW5kZXggPiAwICYmIGZpcnN0Mik7XG4gICAgICBzZWN0aW9uID0gYnV0dG9uV2lkZ2V0LnNlY3Rpb247XG4gICAgfVxuICB9XG4gIGNyZWF0ZUJ1dHRvbihpbmRleCwgYnV0dG9uKSB7XG4gICAgY29uc3QgYnV0dG9uV2lkZ2V0ID0gdGhpcy5jcmVhdGVCdXR0b25XaWRnZXQoKTtcbiAgICBidXR0b25XaWRnZXQuYWRkQ2xhc3MoXCJhZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uXCIpO1xuICAgIGJ1dHRvbldpZGdldC5hZGRMaXN0ZW5lcihcImNsaWNrXCIsIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgYnV0dG9uT3B0aW9ucyA9IHsgaW5kZXgsIC4uLmJ1dHRvbiBpbnN0YW5jZW9mIEJhc2VQcm9wZXJ0aWVzID8gYnV0dG9uLnRvSnNvbigpIDogYnV0dG9uIH07XG4gICAgICBjb25zdCBidXR0b25Cb3VuZHMgPSB0aGlzLmdldEJ1dHRvbldpZGdldEJvdW5kcyhidXR0b25XaWRnZXQpO1xuICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2goXCJidXR0b24tcHJlc3NlZFwiLCB7IGV2ZW50LCBidXR0b246IGJ1dHRvbk9wdGlvbnMsIGJ1dHRvbkJvdW5kcyB9KTtcbiAgICB9KTtcbiAgICBidXR0b25XaWRnZXQuYWRkTGlzdGVuZXIoXCJmb2N1c1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChcImJ1dHRvbi1mb2N1c2VkXCIsIHsgYnV0dG9uOiB7IGluZGV4IH0gfSk7XG4gICAgfSk7XG4gICAgaWYgKGJ1dHRvbi5zZWN0aW9uKSB7XG4gICAgICBidXR0b25XaWRnZXQuc2VjdGlvbiA9IGJ1dHRvbi5zZWN0aW9uO1xuICAgIH1cbiAgICB0aGlzLmJ1dHRvbldpZGdldHMucHVzaChidXR0b25XaWRnZXQpO1xuICAgIHRoaXMuYWRkQ2hpbGQoYnV0dG9uV2lkZ2V0KTtcbiAgICByZXR1cm4gYnV0dG9uV2lkZ2V0O1xuICB9XG59O1xudmFyIFRvb2xiYXIgPSBjbGFzcyBleHRlbmRzIEJhc2VUb29sYmFyIHtcbiAgY3JlYXRlQnV0dG9uV2lkZ2V0KCkge1xuICAgIHJldHVybiBuZXcgVG9vbGJhckJ1dHRvbldpZGdldCh0aGlzLmxvY2FsZU1hbmFnZXIpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jb21wb25lbnRzL3Rvb2xiYXIvZmxvYXRpbmdUb29sYmFyLnRzXG52YXIgRmxvYXRpbmdUb29sYmFyUG9wb3ZlciA9IGNsYXNzIGV4dGVuZHMgRHJhZ2dhYmxlUG9wb3ZlciB7XG4gIGNvbnN0cnVjdG9yKGN0eCwgaWQsIG9uUG9wb3Zlck1vdmVkKSB7XG4gICAgc3VwZXIoY3R4LCBpZCk7XG4gICAgdGhpcy5vblBvcG92ZXJNb3ZlZCA9IG9uUG9wb3Zlck1vdmVkO1xuICAgIHRoaXMuZHJhZ0hhbmRsZURyYWdnaW5nQ2xhc3MgPSBcImFnLWNoYXJ0cy1mbG9hdGluZy10b29sYmFyX19kcmFnLWhhbmRsZS0tZHJhZ2dpbmdcIjtcbiAgfVxuICBzaG93KGNoaWxkcmVuLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnNob3dXaXRoQ2hpbGRyZW4oY2hpbGRyZW4sIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBjbGFzczogXCJhZy1jaGFydHMtZmxvYXRpbmctdG9vbGJhclwiXG4gICAgfSk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICB0aGlzLmRyYWdnZWQgPSBmYWxzZTtcbiAgICBzdXBlci5oaWRlKCk7XG4gIH1cbiAgZ2V0Qm91bmRzKCkge1xuICAgIGNvbnN0IGVsZW1lbnQyID0gdGhpcy5nZXRQb3BvdmVyRWxlbWVudCgpO1xuICAgIHJldHVybiBuZXcgQkJveChcbiAgICAgIGVsZW1lbnQyPy5vZmZzZXRMZWZ0ID8/IDAsXG4gICAgICBlbGVtZW50Mj8ub2Zmc2V0VG9wID8/IDAsXG4gICAgICBlbGVtZW50Mj8ub2Zmc2V0V2lkdGggPz8gMCxcbiAgICAgIGVsZW1lbnQyPy5vZmZzZXRIZWlnaHQgPz8gMFxuICAgICk7XG4gIH1cbiAgaGFzQmVlbkRyYWdnZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dlZDtcbiAgfVxuICBzZXRBbmNob3IoYW5jaG9yLCBob3Jpem9udGFsU3BhY2luZywgdmVydGljYWxTcGFjaW5nKSB7XG4gICAgY29uc3QgZWxlbWVudDIgPSB0aGlzLmdldFBvcG92ZXJFbGVtZW50KCk7XG4gICAgaWYgKCFlbGVtZW50MilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGFuY2hvci5wb3NpdGlvbiA/PyBcImFib3ZlXCI7XG4gICAgY29uc3QgeyBvZmZzZXRXaWR0aDogd2lkdGgyLCBvZmZzZXRIZWlnaHQ6IGhlaWdodDIgfSA9IGVsZW1lbnQyO1xuICAgIGxldCB0b3AgPSBhbmNob3IueSAtIGhlaWdodDIgLSB2ZXJ0aWNhbFNwYWNpbmc7XG4gICAgbGV0IGxlZnQgPSBhbmNob3IueCAtIHdpZHRoMiAvIDI7XG4gICAgaWYgKHBvc2l0aW9uID09PSBcImJlbG93XCIpIHtcbiAgICAgIHRvcCA9IGFuY2hvci55ICsgdmVydGljYWxTcGFjaW5nO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwicmlnaHRcIikge1xuICAgICAgdG9wID0gYW5jaG9yLnkgLSBoZWlnaHQyIC8gMjtcbiAgICAgIGxlZnQgPSBhbmNob3IueCArIGhvcml6b250YWxTcGFjaW5nO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwiYWJvdmUtbGVmdFwiKSB7XG4gICAgICBsZWZ0ID0gYW5jaG9yLng7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlUG9zaXRpb24oeyB4OiBsZWZ0LCB5OiB0b3AgfSk7XG4gIH1cbiAgaWdub3JlUG9pbnRlckV2ZW50cygpIHtcbiAgICBjb25zdCBlbGVtZW50MiA9IHRoaXMuZ2V0UG9wb3ZlckVsZW1lbnQoKTtcbiAgICBpZiAoZWxlbWVudDIpXG4gICAgICBlbGVtZW50Mi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gIH1cbiAgY2FwdHVyZVBvaW50ZXJFdmVudHMoKSB7XG4gICAgY29uc3QgZWxlbWVudDIgPSB0aGlzLmdldFBvcG92ZXJFbGVtZW50KCk7XG4gICAgaWYgKGVsZW1lbnQyKVxuICAgICAgZWxlbWVudDIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwidW5zZXRcIjtcbiAgfVxuICB1cGRhdGVQb3NpdGlvbihwb3NpdGlvbikge1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG4gICAgY29uc3QgY2FudmFzUmVjdCA9IHRoaXMuY3R4LmRvbU1hbmFnZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcG9zaXRpb24ueCA9IE1hdGguZmxvb3IoY2xhbXAoMCwgcG9zaXRpb24ueCwgY2FudmFzUmVjdC53aWR0aCAtIGJvdW5kcy53aWR0aCkpO1xuICAgIHBvc2l0aW9uLnkgPSBNYXRoLmZsb29yKGNsYW1wKDAsIHBvc2l0aW9uLnksIGNhbnZhc1JlY3QuaGVpZ2h0IC0gYm91bmRzLmhlaWdodCkpO1xuICAgIHN1cGVyLnVwZGF0ZVBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB0aGlzLm9uUG9wb3Zlck1vdmVkKCk7XG4gIH1cbn07XG52YXIgRmxvYXRpbmdUb29sYmFyID0gY2xhc3MgZXh0ZW5kcyBCYXNlVG9vbGJhciB7XG4gIGNvbnN0cnVjdG9yKGN0eCwgaWQpIHtcbiAgICBzdXBlcihjdHgubG9jYWxlTWFuYWdlcik7XG4gICAgdGhpcy5oYXNQcmVmaXggPSB0cnVlO1xuICAgIHRoaXMucG9wb3ZlciA9IG5ldyBGbG9hdGluZ1Rvb2xiYXJQb3BvdmVyKGN0eCwgaWQsIHRoaXMub25Qb3BvdmVyTW92ZWQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5kcmFnSGFuZGxlID0gbmV3IERyYWdIYW5kbGVXaWRnZXQoY3R4LmxvY2FsZU1hbmFnZXIudChcInRvb2xiYXJBbm5vdGF0aW9uc0RyYWdIYW5kbGVcIikpO1xuICAgIHRoaXMucG9wb3Zlci5zZXREcmFnSGFuZGxlKHRoaXMuZHJhZ0hhbmRsZSk7XG4gIH1cbiAgc2hvdyhvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnBvcG92ZXIuc2hvdyhbdGhpcy5kcmFnSGFuZGxlLmdldEVsZW1lbnQoKSwgdGhpcy5nZXRFbGVtZW50KCldLCBvcHRpb25zKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIHRoaXMucG9wb3Zlci5oaWRlKCk7XG4gIH1cbiAgc2V0QW5jaG9yKGFuY2hvcikge1xuICAgIHRoaXMucG9wb3Zlci5zZXRBbmNob3IoYW5jaG9yLCB0aGlzLmhvcml6b250YWxTcGFjaW5nLCB0aGlzLnZlcnRpY2FsU3BhY2luZyk7XG4gIH1cbiAgaGFzQmVlbkRyYWdnZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9wb3Zlci5oYXNCZWVuRHJhZ2dlZCgpO1xuICB9XG4gIGlnbm9yZVBvaW50ZXJFdmVudHMoKSB7XG4gICAgdGhpcy5wb3BvdmVyLmlnbm9yZVBvaW50ZXJFdmVudHMoKTtcbiAgfVxuICBjYXB0dXJlUG9pbnRlckV2ZW50cygpIHtcbiAgICB0aGlzLnBvcG92ZXIuY2FwdHVyZVBvaW50ZXJFdmVudHMoKTtcbiAgfVxuICBvblBvcG92ZXJNb3ZlZCgpIHtcbiAgICBjb25zdCBwb3BvdmVyQm91bmRzID0gdGhpcy5wb3BvdmVyLmdldEJvdW5kcygpO1xuICAgIGlmICh0aGlzLnBvcG92ZXJCb3VuZHM/LmVxdWFscyhwb3BvdmVyQm91bmRzKSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnBvcG92ZXJCb3VuZHMgPSBwb3BvdmVyQm91bmRzLmNsb25lKCk7XG4gICAgY29uc3QgYnV0dG9uQm91bmRzID0gdGhpcy5nZXRCdXR0b25Cb3VuZHMoKTtcbiAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChcInRvb2xiYXItbW92ZWRcIiwgeyBwb3BvdmVyQm91bmRzLCBidXR0b25Cb3VuZHMgfSk7XG4gIH1cbiAgZ2V0QnV0dG9uV2lkZ2V0Qm91bmRzKGJ1dHRvbldpZGdldCkge1xuICAgIGNvbnN0IHBvcG92ZXJCb3VuZHMgPSB0aGlzLnBvcG92ZXIuZ2V0Qm91bmRzKCk7XG4gICAgY29uc3QgYm91bmRzID0gc3VwZXIuZ2V0QnV0dG9uV2lkZ2V0Qm91bmRzKGJ1dHRvbldpZGdldCk7XG4gICAgY29uc3QgZHJhZ0hhbmRsZUJvdW5kcyA9IHRoaXMuZHJhZ0hhbmRsZS5nZXRCb3VuZHMoKTtcbiAgICByZXR1cm4gbmV3IEJCb3goXG4gICAgICBib3VuZHMueCArIHBvcG92ZXJCb3VuZHMueCAtIGRyYWdIYW5kbGVCb3VuZHMud2lkdGgsXG4gICAgICBib3VuZHMueSArIHBvcG92ZXJCb3VuZHMueSxcbiAgICAgIGJvdW5kcy53aWR0aCxcbiAgICAgIGJvdW5kcy5oZWlnaHRcbiAgICApO1xuICB9XG59O1xudmFyIERyYWdIYW5kbGVXaWRnZXQgPSBjbGFzcyBleHRlbmRzIE5hdGl2ZVdpZGdldCB7XG4gIGNvbnN0cnVjdG9yKHRpdGxlKSB7XG4gICAgc3VwZXIoY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImFnLWNoYXJ0cy1mbG9hdGluZy10b29sYmFyX19kcmFnLWhhbmRsZVwiKSk7XG4gICAgY29uc3QgaWNvbiA9IG5ldyBOYXRpdmVXaWRnZXQoXG4gICAgICBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBgJHtnZXRJY29uQ2xhc3NOYW1lcyhcImRyYWctaGFuZGxlXCIpfSBhZy1jaGFydHMtdG9vbGJhcl9faWNvbmApXG4gICAgKTtcbiAgICBpY29uLnNldEFyaWFIaWRkZW4odHJ1ZSk7XG4gICAgdGhpcy5hZGRDaGlsZChpY29uKTtcbiAgICB0aGlzLmVsZW0udGl0bGUgPSB0aXRsZTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW9kdWxlLXN1cHBvcnQudHNcbnZhciBtb3Rpb24gPSB7IC4uLmZyb21Ub01vdGlvbl9leHBvcnRzLCAuLi5yZXNldE1vdGlvbl9leHBvcnRzIH07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21haW4udHNcbnZhciBBZ0NoYXJ0c0NvbW11bml0eU1vZHVsZSA9IHtcbiAgVkVSU0lPTixcbiAgX1NjZW5lOiBpbnRlZ3JhdGVkX2NoYXJ0c19zY2VuZV9leHBvcnRzLFxuICBfVGhlbWU6IGludGVncmF0ZWRfY2hhcnRzX3RoZW1lX2V4cG9ydHMsXG4gIF9VdGlsOiBpbnRlZ3JhdGVkX2NoYXJ0c191dGlsX2V4cG9ydHMsXG4gIGNyZWF0ZTogQWdDaGFydHMuY3JlYXRlLmJpbmQoQWdDaGFydHMpLFxuICBjcmVhdGVTcGFya2xpbmU6IEFnQ2hhcnRzLl9fY3JlYXRlU3BhcmtsaW5lLmJpbmQoQWdDaGFydHMpLFxuICBzZXR1cDogcmVnaXN0ZXJJbmJ1aWx0TW9kdWxlcyxcbiAgaXNFbnRlcnByaXNlOiBmYWxzZVxufTtcbmV4cG9ydCB7XG4gIEFHX0NIQVJUU19MT0NBTEVfRU5fVVMsXG4gIEFnQ2hhcnRzLFxuICBBZ0NoYXJ0c0NvbW11bml0eU1vZHVsZSxcbiAgQWdFcnJvckJhclN1cHBvcnRlZFNlcmllc1R5cGVzLFxuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUsXG4gIFZFUlNJT04sXG4gIG1vZHVsZV9zdXBwb3J0X2V4cG9ydHMgYXMgX01vZHVsZVN1cHBvcnQsXG4gIGludGVncmF0ZWRfY2hhcnRzX3NjZW5lX2V4cG9ydHMgYXMgX1NjZW5lLFxuICBpbnRlZ3JhdGVkX2NoYXJ0c190aGVtZV9leHBvcnRzIGFzIF9UaGVtZSxcbiAgaW50ZWdyYXRlZF9jaGFydHNfdXRpbF9leHBvcnRzIGFzIF9VdGlsLFxuICBleHBvcnRzX2V4cG9ydHMgYXMgX1dpZGdldCxcbiAgcmVnaXN0ZXJJbmJ1aWx0TW9kdWxlcyBhcyBzZXR1cENvbW11bml0eU1vZHVsZXMsXG4gIHRpbWVfZXhwb3J0cyBhcyB0aW1lXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ag-charts-community/dist/package/main.esm.mjs\n");

/***/ })

};
;